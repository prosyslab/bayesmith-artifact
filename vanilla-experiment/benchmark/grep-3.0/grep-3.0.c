/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 25 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_384461983 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_384461983 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 169 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 181 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 108 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 203 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 63 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
} ;
#line 270
struct quoting_options ;
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 826 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 117 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 210 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 167 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 174 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 43 "/home/khheo/project/benchmark/grep-3.0/lib/memchr2.c"
typedef unsigned long longword;
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 286 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 26 "./localeinfo.h"
struct localeinfo {
   _Bool multibyte ;
   _Bool using_utf8 ;
   signed char sbclen[256] ;
   wint_t sbctowc[256] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.h"
typedef struct I_ring I_ring;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 53 "/home/khheo/project/benchmark/grep-3.0/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/khheo/project/benchmark/grep-3.0/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "/home/khheo/project/benchmark/grep-3.0/lib/hash.h"
typedef struct hash_table Hash_table;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
struct _ftsent ;
#line 80
struct cycle_check_state ;
#line 80 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
struct __anonstruct_FTS_451178386 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 80 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
typedef struct __anonstruct_FTS_451178386 FTS;
#line 201 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[] ;
};
#line 201 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 7 "/home/khheo/project/benchmark/grep-3.0/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 754 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 57 "./regex.h"
typedef unsigned long __re_long_size_t;
#line 73 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 414
struct re_dfa_t ;
#line 414 "./regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 479 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 491 "./regex.h"
typedef int regoff_t;
#line 518 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 518 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 47 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.h"
struct exclude ;
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
union __anonunion_v_827610566 {
   char const   *pattern ;
   regex_t re ;
};
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct patopts {
   int options ;
   union __anonunion_v_827610566 v ;
};
#line 88 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 95
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 101 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 101 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 113 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct pattern_buffer {
   struct pattern_buffer *next ;
   char *base ;
};
#line 121 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct pattern_buffer *patbuf ;
};
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.h"
struct dfamust {
   _Bool exact ;
   _Bool begline ;
   _Bool endline ;
   char *must ;
};
#line 44
struct dfa ;
#line 74 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef unsigned long charclass_word;
#line 106 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_charclass_425059741 {
   charclass_word w[4] ;
};
#line 106 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct __anonstruct_charclass_425059741 charclass;
#line 208 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef ptrdiff_t token;
#line 213 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef ptrdiff_t state_num;
#line 308 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 308 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 315 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_position_set_349475030 {
   position *elems ;
   ptrdiff_t nelem ;
   ptrdiff_t alloc ;
};
#line 315 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct __anonstruct_position_set_349475030 position_set;
#line 323 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 323 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 332 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_dfa_state_810101419 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
   state_num mb_trindex ;
};
#line 332 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct __anonstruct_dfa_state_810101419 dfa_state;
#line 353 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   _Bool invert ;
   wchar_t *chars ;
   ptrdiff_t nchars ;
   ptrdiff_t nchars_alloc ;
};
#line 362 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct regex_syntax {
   reg_syntax_t syntax_bits ;
   _Bool syntax_bits_set ;
   _Bool case_fold ;
   _Bool anchor ;
   unsigned char eolbyte ;
   char sbit[256] ;
   _Bool never_trail[256] ;
   charclass letters ;
   charclass newline ;
};
#line 396 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct lexer_state {
   char const   *ptr ;
   size_t left ;
   token lasttok ;
   size_t parens ;
   int minrep ;
   int maxrep ;
   wint_t wctok ;
   int cur_mb_len ;
   struct mb_char_classes brack ;
   _Bool laststart ;
};
#line 421 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct parser_state {
   token tok ;
   size_t depth ;
};
#line 432 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct dfa {
   struct regex_syntax syntax ;
   charclass *charclasses ;
   ptrdiff_t cindex ;
   ptrdiff_t calloc ;
   size_t canychar ;
   struct lexer_state lex ;
   struct parser_state parse ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   _Bool fast ;
   token utf8_anychar_classes[5] ;
   mbstate_t mbs ;
   char *multibyte_prop ;
   struct dfa *superset ;
   dfa_state *states ;
   state_num sindex ;
   ptrdiff_t salloc ;
   position_set *follows ;
   _Bool searchflag ;
   state_num tralloc ;
   int trcount ;
   int min_trcount ;
   state_num **trans ;
   state_num **fails ;
   char *success ;
   state_num *newlines ;
   state_num initstate_notbol ;
   position_set mb_follows ;
   state_num **mb_trans ;
   state_num mb_trcount ;
   char *(*dfaexec)(struct dfa * , char const   * , char * , _Bool  , size_t * , _Bool * ) ;
   _Bool simple_locale ;
   struct localeinfo localeinfo ;
};
#line 953 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef int predicate(int  );
#line 959 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 1230 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct lexptr {
   char const   *ptr ;
   size_t left ;
};
#line 2374 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_stkalloc_360611398 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 3728
struct must ;
#line 3728 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
typedef struct must must;
#line 3730 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct must {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
   _Bool begline ;
   _Bool endline ;
   must *prev ;
};
#line 41 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 63 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.c"
union __anonunion_tmp_771759453___0 {
   unsigned int align ;
   char buf[4096] ;
};
#line 2374 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct __anonstruct_stkalloc_360611398___0 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 34 "/home/khheo/project/benchmark/grep-3.0/src/kwset.h"
struct kwset ;
#line 35 "/home/khheo/project/benchmark/grep-3.0/src/kwset.h"
typedef struct kwset *kwset_t;
#line 324 "/usr/include/pcre.h"
struct real_pcre ;
#line 325 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 333
struct real_pcre_jit_stack ;
#line 334 "/usr/include/pcre.h"
typedef struct real_pcre_jit_stack pcre_jit_stack;
#line 376 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 36 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
struct pcre_comp {
   pcre *cre ;
   pcre_extra *extra ;
   pcre_jit_stack *jit_stack ;
   int jit_stack_size ;
   int empty_match[2] ;
};
#line 25 "/home/khheo/project/benchmark/grep-3.0/src/kwset.h"
struct kwsmatch {
   ptrdiff_t index ;
   ptrdiff_t offset[1] ;
   ptrdiff_t size[1] ;
};
#line 60 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
struct trie ;
#line 60 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
#line 70 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
struct trie {
   size_t accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   ptrdiff_t depth ;
   ptrdiff_t shift ;
   ptrdiff_t maxshift ;
};
#line 88 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
struct kwset {
   struct obstack obstack ;
   ptrdiff_t words ;
   struct trie *trie ;
   ptrdiff_t mind ;
   ptrdiff_t maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   ptrdiff_t *shift ;
   char const   *trans ;
   int gc1 ;
   int gc1help ;
   char gc2 ;
   ptrdiff_t (*kwsexec)(kwset_t  , char const   * , ptrdiff_t  , struct kwsmatch * ,
                        _Bool  ) ;
};
#line 194
enum __anonenum_dirs_744895363 {
    L = 0,
    R = 1
} ;
#line 26 "/home/khheo/project/benchmark/grep-3.0/src/kwsearch.c"
struct kwsearch {
   kwset_t kwset ;
   ptrdiff_t words ;
   char *pattern ;
   size_t size ;
   void *re ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 88 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
struct FL_pair {
   char const   *filename ;
   size_t lineno ;
};
#line 326 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
struct color_cap {
   char const   *name ;
   char const   **var ;
   void (*fct)(void) ;
};
#line 505
enum directories_type {
    READ_DIRECTORIES = 2,
    RECURSE_DIRECTORIES = 3,
    SKIP_DIRECTORIES = 4
} ;
#line 529
enum __anonenum_devices_473526324 {
    READ_COMMAND_LINE_DEVICES = 0,
    READ_DEVICES = 1,
    SKIP_DEVICES = 2
} ;
#line 626 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
typedef uintmax_t uword;
#line 993
enum __anonenum_binary_files_601436154 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
#line 1001
enum __anonenum_list_files_328606374 {
    LISTFILES_NONE = 0,
    LISTFILES_MATCHING = 1,
    LISTFILES_NONMATCHING = 2
} ;
#line 33 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
enum __anonenum_File_type_103687233 {
    UNKNOWN = 0,
    DOS_BINARY = 1,
    DOS_TEXT = 2,
    UNIX_TEXT = 3
} ;
#line 33 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
typedef enum __anonenum_File_type_103687233 File_type;
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
struct dos_map {
   off_t pos ;
   off_t add ;
};
#line 2028 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
struct __anonstruct_matchers_307522949 {
   char const   name[12] ;
   int syntax ;
   void *(*compile)(char * , size_t  , reg_syntax_t  ) ;
   size_t (*execute)(void * , char const   * , size_t  , size_t * , char const   * ) ;
};
#line 56 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 498 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 27 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
struct dfa_comp {
   kwset_t kwset ;
   struct dfa *dfa ;
   struct re_pattern_buffer *patterns ;
   size_t pcount ;
   struct re_registers regs ;
   ptrdiff_t kwset_exact_matches ;
   _Bool begline ;
};
#line 45 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                    96U, "xstrtoul");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                  96U, "xstrtoul");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 104
  q = s;
#line 105
  ch = (unsigned char )*q;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___2 = __ctype_b_loc();
    }
#line 106
    if (! ((int const   )*(*tmp___2 + (int )ch) & 8192)) {
#line 106
      goto while_break;
    }
#line 107
    q ++;
#line 107
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((int )ch == 45) {
#line 109
    return ((strtol_error )4);
  }
  {
#line 112
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1UL;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 44 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___0(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                    96U, "xstrtol");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                  96U, "xstrtol");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 112
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1L;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/grep-3.0/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 91 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale___1(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___1(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                    96U, "xstrtoimax");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c",
                  96U, "xstrtoimax");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 112
  tmp = strtoimax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = (intmax_t )1;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 154
    if ((int )*(*p) == 90) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 89) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 116) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 84) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 80) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 109) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 77) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 75) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 107) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 103) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 71) {
#line 154
      goto case_90;
    }
#line 154
    if ((int )*(*p) == 69) {
#line 154
      goto case_90;
    }
#line 151
    goto switch_break;
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
    {
#line 163
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 163
    if (tmp___7) {
      {
#line 166
      if ((int )*(*(p + 0) + 1) == 105) {
#line 166
        goto case_105;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 68) {
#line 172
        goto case_68;
      }
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_68;
      }
#line 164
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 167
      if ((int )*(*(p + 0) + 2) == 66) {
#line 168
        suffixes += 2;
      }
#line 169
      goto switch_break___0;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 173
      base = 1000;
#line 174
      suffixes ++;
#line 175
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    if ((int )*(*p) == 98) {
#line 181
      goto case_98;
    }
#line 185
    if ((int )*(*p) == 66) {
#line 185
      goto case_66___0;
    }
#line 192
    if ((int )*(*p) == 99) {
#line 192
      goto case_99;
    }
#line 196
    if ((int )*(*p) == 69) {
#line 196
      goto case_69___0;
    }
#line 201
    if ((int )*(*p) == 103) {
#line 201
      goto case_103___0;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_103___0;
    }
#line 206
    if ((int )*(*p) == 75) {
#line 206
      goto case_75___0;
    }
#line 206
    if ((int )*(*p) == 107) {
#line 206
      goto case_75___0;
    }
#line 211
    if ((int )*(*p) == 109) {
#line 211
      goto case_109___0;
    }
#line 211
    if ((int )*(*p) == 77) {
#line 211
      goto case_109___0;
    }
#line 215
    if ((int )*(*p) == 80) {
#line 215
      goto case_80___0;
    }
#line 220
    if ((int )*(*p) == 116) {
#line 220
      goto case_116___0;
    }
#line 220
    if ((int )*(*p) == 84) {
#line 220
      goto case_116___0;
    }
#line 224
    if ((int )*(*p) == 119) {
#line 224
      goto case_119;
    }
#line 228
    if ((int )*(*p) == 89) {
#line 228
      goto case_89___0;
    }
#line 232
    if ((int )*(*p) == 90) {
#line 232
      goto case_90___0;
    }
#line 236
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 183
    goto switch_break___1;
    case_66___0: /* CIL Label */ 
    {
#line 189
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 190
    goto switch_break___1;
    case_99: /* CIL Label */ 
#line 193
    overflow = (strtol_error )0;
#line 194
    goto switch_break___1;
    case_69___0: /* CIL Label */ 
    {
#line 197
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 198
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 203
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    {
#line 207
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 208
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    case_77___0: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 213
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
    {
#line 216
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 217
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 221
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 222
    goto switch_break___1;
    case_119: /* CIL Label */ 
    {
#line 225
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 226
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 229
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 230
    goto switch_break___1;
    case_90___0: /* CIL Label */ 
    {
#line 233
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 234
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 237
    *val = tmp;
#line 238
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___1: /* CIL Label */ ;
    }
#line 241
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 242
    *p += suffixes;
#line 243
    if (*(*p)) {
#line 244
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 247
  *val = tmp;
#line 248
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/grep-3.0/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 44 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 55
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 66
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57
void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 65
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 107
  if (9223372036854775807UL / s < n) {
    {
#line 108
    xalloc_die();
    }
  }
  {
#line 109
  tmp = xmalloc(n * s);
  }
#line 109
  return (tmp);
}
}
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 120
  if (9223372036854775807UL / s < n) {
    {
#line 121
    xalloc_die();
    }
  }
  {
#line 122
  tmp = xrealloc(p, n * s);
  }
#line 122
  return (tmp);
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 182
  n = *pn;
#line 184
  if (! p) {
#line 186
    if (! n) {
#line 194
      n = 128UL / s;
#line 195
      n += (size_t )(! n);
    }
  } else {
#line 204
    if (6148914691236517204UL / s <= n) {
      {
#line 206
      xalloc_die();
      }
    }
#line 207
    n += n / 2UL + 1UL;
  }
  {
#line 210
  *pn = n;
#line 211
  tmp = xrealloc(p, n * s);
  }
#line 211
  return (tmp);
}
}
#line 217
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 219
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 219 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 222
  if (sizeof(char ) == 1UL) {
    {
#line 222
    tmp = xmalloc(n);
#line 222
    tmp___1 = tmp;
    }
  } else {
    {
#line 222
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 222
    tmp___1 = tmp___0;
    }
  }
#line 222
  return ((char *)tmp___1);
}
}
#line 264
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/khheo/project/benchmark/grep-3.0/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 61
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 67
void *x2realloc(void *p , size_t *pn ) ;
#line 68
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 70
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 264
#pragma GCC diagnostic pop
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 100
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  } else {
    {
#line 100
    p = calloc(n, s);
    }
#line 100
    if (! p) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/grep-3.0/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 20 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[2304]  = 
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )16,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )223,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )247,      (unsigned char const   )63, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )239,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )211,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )248,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )133, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )176, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )167, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )40,      (unsigned char const   )191,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )188,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )96, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )127,      (unsigned char const   )248, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 361 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[248]  = 
#line 361
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )29,      (signed char const   )-1,      (signed char const   )30, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )31,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )32,      (signed char const   )33,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )34,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 396
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 396 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 400
  if (uc >> 9 < 248U) {
#line 402
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 403
    if (ind >= 0) {
#line 404
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 406
        if (uc > 0U) {
#line 406
          if (uc < 160U) {
#line 407
            return (-1);
          } else {
#line 409
            return (0);
          }
        } else {
#line 409
          return (0);
        }
      }
    }
  } else
#line 412
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 414
    if (uc >= 917760U) {
#line 416
      if (uc <= 917999U) {
#line 417
        return (0);
      }
    } else {
#line 421
      if (uc >= 917536U) {
#line 421
        tmp = uc <= 917631U;
      } else {
#line 421
        tmp = uc == 917505U;
      }
#line 421
      if (tmp) {
#line 422
        return (0);
      }
    }
  }
#line 429
  if (uc >= 4352U) {
#line 429
    if (uc < 4448U) {
#line 443
      return (2);
    } else
#line 429
    if (uc >= 9001U) {
#line 429
      if (uc < 9003U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 429
    if (uc >= 11904U) {
#line 429
      if (uc < 42192U) {
#line 429
        if (! (uc == 12351U)) {
#line 429
          if (uc >= 19904U) {
#line 429
            if (uc < 19968U) {
#line 429
              goto _L___8;
            } else {
#line 443
              return (2);
            }
          } else {
#line 443
            return (2);
          }
        } else {
#line 429
          goto _L___8;
        }
      } else {
#line 429
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 429
    if (uc >= 44032U) {
#line 429
      if (uc < 55204U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 429
    if (uc >= 63744U) {
#line 429
      if (uc < 64256U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 429
    if (uc >= 65040U) {
#line 429
      if (uc < 65056U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 429
    if (uc >= 65072U) {
#line 429
      if (uc < 65136U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 429
    if (uc >= 65280U) {
#line 429
      if (uc < 65377U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 429
    if (uc >= 65504U) {
#line 429
      if (uc < 65511U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 429
    if (uc >= 131072U) {
#line 429
      if (uc <= 196607U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 429
    if (uc >= 196608U) {
#line 429
      if (uc <= 262143U) {
#line 443
        return (2);
      }
    }
  }
#line 446
  if (uc >= 161U) {
#line 446
    if (uc < 65377U) {
#line 446
      if (uc != 8361U) {
        {
#line 446
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 446
        if (tmp___0) {
#line 448
          return (2);
        }
      }
    }
  }
#line 449
  return (1);
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2017);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-grep@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU grep", "http://www.gnu.org/software/grep/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 141 "/home/khheo/project/benchmark/grep-3.0/lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 308 "./unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 23 "/home/khheo/project/benchmark/grep-3.0/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 28
  if (uc < 128U) {
#line 30
    return (-2);
  } else
#line 31
  if (uc < 2048U) {
#line 32
    count = 2;
  } else
#line 33
  if (uc < 65536U) {
#line 35
    if (uc < 55296U) {
#line 36
      count = 3;
    } else
#line 35
    if (uc >= 57344U) {
#line 36
      count = 3;
    } else {
#line 38
      return (-1);
    }
  } else
#line 40
  if (uc < 1114112U) {
#line 41
    count = 4;
  } else {
#line 43
    return (-1);
  }
#line 45
  if (n < count) {
#line 46
    return (-2);
  }
  {
#line 50
  if (count == 4) {
#line 50
    goto case_4;
  }
#line 52
  if (count == 3) {
#line 52
    goto case_3;
  }
#line 54
  if (count == 2) {
#line 54
    goto case_2;
  }
#line 48
  goto switch_break;
  case_4: /* CIL Label */ 
#line 50
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 50
  uc >>= 6;
#line 50
  uc |= 65536U;
  case_3: /* CIL Label */ 
#line 52
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 52
  uc >>= 6;
#line 52
  uc |= 2048U;
  case_2: /* CIL Label */ 
#line 54
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 54
  uc >>= 6;
#line 54
  uc |= 192U;
#line 55
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 57
  return (count);
}
}
#line 286 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 23 "/home/khheo/project/benchmark/grep-3.0/lib/unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ 
  uint8_t c ;

  {
#line 26
  c = (uint8_t )*s;
#line 28
  if ((int )c < 128) {
#line 30
    *puc = (ucs4_t )c;
#line 31
    return (1);
  } else
#line 33
  if ((int )c >= 194) {
#line 35
    if ((int )c < 224) {
#line 37
      if (n >= 2UL) {
#line 39
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 41
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 43
          return (2);
        }
      } else {
#line 50
        *puc = (ucs4_t )65533;
#line 51
        return (-2);
      }
    } else
#line 54
    if ((int )c < 240) {
#line 56
      if (n >= 2UL) {
#line 58
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 58
          if ((int )c >= 225) {
#line 58
            goto _L___0;
          } else
#line 58
          if ((int const   )*(s + 1) >= 160) {
            _L___0: /* CIL Label */ 
#line 58
            if ((int )c != 237) {
#line 58
              goto _L;
            } else
#line 58
            if ((int const   )*(s + 1) < 160) {
              _L: /* CIL Label */ 
#line 62
              if (n >= 3UL) {
#line 64
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 66
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 69
                  return (3);
                }
              } else {
#line 76
                *puc = (ucs4_t )65533;
#line 77
                return (-2);
              }
            }
          }
        }
      } else {
#line 85
        *puc = (ucs4_t )65533;
#line 86
        return (-2);
      }
    } else
#line 89
    if ((int )c < 248) {
#line 91
      if (n >= 2UL) {
#line 93
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 93
          if ((int )c >= 241) {
#line 93
            goto _L___2;
          } else
#line 93
          if ((int const   )*(s + 1) >= 144) {
            _L___2: /* CIL Label */ 
#line 93
            if ((int )c < 244) {
#line 93
              goto _L___1;
            } else
#line 93
            if ((int )c == 244) {
#line 93
              if ((int const   )*(s + 1) < 144) {
                _L___1: /* CIL Label */ 
#line 97
                if (n >= 3UL) {
#line 99
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 101
                    if (n >= 4UL) {
#line 103
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 105
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 109
                        return (4);
                      }
                    } else {
#line 116
                      *puc = (ucs4_t )65533;
#line 117
                      return (-2);
                    }
                  }
                } else {
#line 125
                  *puc = (ucs4_t )65533;
#line 126
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 134
        *puc = (ucs4_t )65533;
#line 135
        return (-2);
      }
    }
  }
#line 140
  *puc = (ucs4_t )65533;
#line 141
  return (-1);
}
}
#line 33 "/home/khheo/project/benchmark/grep-3.0/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 367
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 587 "./wchar.h"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 246 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
__inline int mb_width_aux(wint_t wc ) 
{ 
  int w ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 249
  tmp = wcwidth((wchar_t )wc);
#line 249
  w = tmp;
  }
#line 252
  if (w >= 0) {
#line 252
    tmp___3 = w;
  } else {
    {
#line 252
    tmp___2 = iswcntrl(wc);
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 0;
    } else {
#line 252
      tmp___1 = 1;
    }
#line 252
    tmp___3 = tmp___1;
  }
#line 252
  return (tmp___3);
}
}
#line 267 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
__inline void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 270
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 272
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 273
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 276
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 277
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 278
  tmp = (_Bool )old_mbc->wc_valid;
#line 278
  new_mbc->wc_valid = tmp;
#line 278
  if (tmp) {
#line 279
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 280
  return;
}
}
#line 313
unsigned int const   is_basic_table[8] ;
#line 315 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
__inline _Bool is_basic(char c ) 
{ 


  {
#line 318
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 123 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
__inline void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp___2 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___6 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___6) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp___2) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h",
                    142U, "mbiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    iter->cur.bytes = rpl_mbrtowc(& iter->cur.wc, iter->cur.ptr, (size_t )(iter->limit - iter->cur.ptr),
                                  & iter->state);
    }
#line 147
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 150
      iter->cur.bytes = (size_t )1;
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 155
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 158
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 159
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 165
      if (iter->cur.bytes == 0UL) {
#line 168
        iter->cur.bytes = (size_t )1;
#line 169
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 169
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h",
                        169U, "mbiter_multi_next");
          }
        }
#line 170
        if (! (iter->cur.wc == 0)) {
          {
#line 170
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h",
                        170U, "mbiter_multi_next");
          }
        }
      }
      {
#line 172
      iter->cur.wc_valid = (_Bool)1;
#line 176
      tmp___5 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 176
      if (tmp___5) {
#line 177
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 180
  iter->next_done = (_Bool)1;
#line 181
  return;
}
}
#line 183 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
__inline void mbiter_multi_reloc(struct mbiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 186
  iter->cur.ptr += ptrdiff;
#line 187
  iter->limit += ptrdiff;
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
__inline void mbiter_multi_copy(struct mbiter_multi *new_iter , struct mbiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 193
  new_iter->limit = (char const   *)old_iter->limit;
#line 194
  tmp = (_Bool )old_iter->in_shift;
#line 194
  new_iter->in_shift = tmp;
#line 194
  if (tmp) {
    {
#line 195
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 197
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 198
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 199
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 200
  return;
}
}
#line 223
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 40 "/home/khheo/project/benchmark/grep-3.0/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
            {
#line 78
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 78
            if (! tmp___4) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
            {
#line 84
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 84
            if (! tmp___5) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (tmp___7) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
            {
#line 92
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 92
            if (! tmp___6) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*p) {
          {
#line 113
          tmp___8 = __ctype_b_loc();
          }
#line 113
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
#line 113
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___9 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 120
    if (how != 1) {
      {
#line 122
      tmp___10 = strlen((char const   *)d);
#line 122
      p = (d + tmp___10) - 1;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 122
          tmp___11 = __ctype_b_loc();
          }
#line 122
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            goto while_break___2;
          }
        } else {
#line 122
          goto while_break___2;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (d);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-3.0/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/grep-3.0/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 44 "/home/khheo/project/benchmark/grep-3.0/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/grep-3.0/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 55
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (insize > 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 72
    res = tmp___0;
    }
#line 76
    if (res == 0xffffffffffffffffUL) {
      {
#line 78
      tmp___2 = __errno_location();
      }
#line 78
      if (! (*tmp___2 == 7)) {
        {
#line 80
        tmp___1 = __errno_location();
        }
#line 80
        if (*tmp___1 == 22) {
#line 81
          goto while_break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  outptr___0 = tmp.buf;
#line 104
  outsize___0 = (size_t )4096;
#line 105
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 105
  res___0 = tmp___3;
  }
#line 107
  if (res___0 == 0xffffffffffffffffUL) {
#line 108
    return (-1);
  }
#line 109
  count += (size_t )(outptr___0 - tmp.buf);
#line 112
  length = count;
#line 116
  if (length == 0UL) {
#line 118
    *lengthp = (size_t )0;
#line 119
    return (0);
  }
#line 121
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 121
    if (*lengthp >= length) {
#line 122
      result = *resultp;
    } else {
#line 121
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 125
    tmp___4 = malloc(length);
#line 125
    result = (char *)tmp___4;
    }
#line 126
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 128
      tmp___5 = __errno_location();
#line 128
      *tmp___5 = 12;
      }
#line 129
      return (-1);
    }
  }
  {
#line 138
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 143
  inptr___0 = src;
#line 144
  insize___0 = srclen;
#line 145
  outptr___1 = result;
#line 146
  outsize___1 = length;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (insize___0 > 0UL)) {
#line 148
      goto while_break___0;
    }
    {
#line 150
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 150
    res___1 = tmp___6;
    }
#line 154
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 156
      tmp___7 = __errno_location();
      }
#line 156
      if (*tmp___7 == 22) {
#line 157
        goto while_break___0;
      } else {
#line 159
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 178
  res___2 = tmp___8;
  }
#line 180
  if (res___2 == 0xffffffffffffffffUL) {
#line 181
    goto fail;
  }
#line 184
  if (outsize___1 != 0UL) {
    {
#line 185
    abort();
    }
  }
#line 188
  *resultp = result;
#line 189
  *lengthp = length;
#line 191
  return (0);
  fail: 
#line 195
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 197
    tmp___9 = __errno_location();
#line 197
    saved_errno = *tmp___9;
#line 198
    free((void *)result);
#line 199
    tmp___10 = __errno_location();
#line 199
    *tmp___10 = saved_errno;
    }
  }
#line 201
  return (-1);
}
}
#line 206 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used___0 ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___1 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 255
  inptr = src;
#line 256
  tmp = strlen(src);
#line 256
  inbytes_remaining = tmp;
#line 261
  result_size = inbytes_remaining;
#line 263
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 264
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 265
    result_size *= 16UL;
  }
  {
#line 267
  result_size ++;
#line 269
  tmp___0 = malloc(result_size);
#line 269
  result = (char *)tmp___0;
  }
#line 270
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 12;
    }
#line 273
    return ((char *)((void *)0));
  }
  {
#line 281
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 286
  outptr = result;
#line 287
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 293
    res = tmp___2;
    }
#line 297
    if (res == 0xffffffffffffffffUL) {
      {
#line 299
      tmp___7 = __errno_location();
      }
#line 299
      if (*tmp___7 == 22) {
#line 300
        goto while_break;
      } else {
        {
#line 301
        tmp___6 = __errno_location();
        }
#line 301
        if (*tmp___6 == 7) {
#line 303
          used___0 = (size_t )(outptr - result);
#line 304
          newsize = result_size * 2UL;
#line 307
          if (! (newsize > result_size)) {
            {
#line 309
            tmp___3 = __errno_location();
#line 309
            *tmp___3 = 12;
            }
#line 310
            goto failed;
          }
          {
#line 312
          tmp___4 = realloc((void *)result, newsize);
#line 312
          newresult = (char *)tmp___4;
          }
#line 313
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 315
            tmp___5 = __errno_location();
#line 315
            *tmp___5 = 12;
            }
#line 316
            goto failed;
          }
#line 318
          result = newresult;
#line 319
          result_size = newsize;
#line 320
          outptr = result + used___0;
#line 321
          outbytes_remaining = (result_size - 1UL) - used___0;
        } else {
#line 324
          goto failed;
        }
      }
    } else {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 336
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 336
    res___0 = tmp___8;
    }
#line 338
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 340
      tmp___12 = __errno_location();
      }
#line 340
      if (*tmp___12 == 7) {
#line 342
        used___1 = (size_t )(outptr - result);
#line 343
        newsize___0 = result_size * 2UL;
#line 346
        if (! (newsize___0 > result_size)) {
          {
#line 348
          tmp___9 = __errno_location();
#line 348
          *tmp___9 = 12;
          }
#line 349
          goto failed;
        }
        {
#line 351
        tmp___10 = realloc((void *)result, newsize___0);
#line 351
        newresult___0 = (char *)tmp___10;
        }
#line 352
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 354
          tmp___11 = __errno_location();
#line 354
          *tmp___11 = 12;
          }
#line 355
          goto failed;
        }
#line 357
        result = newresult___0;
#line 358
        result_size = newsize___0;
#line 359
        outptr = result + used___1;
#line 360
        outbytes_remaining = (result_size - 1UL) - used___1;
      } else {
#line 363
        goto failed;
      }
    } else {
#line 366
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  tmp___13 = outptr;
#line 371
  outptr ++;
#line 371
  *tmp___13 = (char )'\000';
#line 373
  length = (size_t )(outptr - result);
#line 377
  if (length < result_size) {
    {
#line 379
    tmp___14 = realloc((void *)result, length);
#line 379
    smaller_result = (char *)tmp___14;
    }
#line 381
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 382
      result = smaller_result;
    }
  }
#line 385
  return (result);
  failed: 
  {
#line 389
  tmp___15 = __errno_location();
#line 389
  saved_errno = *tmp___15;
#line 390
  free((void *)result);
#line 391
  tmp___16 = __errno_location();
#line 391
  *tmp___16 = saved_errno;
  }
#line 392
  return ((char *)((void *)0));
}
}
#line 400 "/home/khheo/project/benchmark/grep-3.0/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 403
  if ((int const   )*src == 0) {
#line 403
    goto _L;
  } else {
    {
#line 403
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 403
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 405
      tmp = strdup(src);
#line 405
      result = tmp;
      }
#line 407
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 408
        tmp___0 = __errno_location();
#line 408
        *tmp___0 = 12;
        }
      }
#line 409
      return (result);
    } else {
      {
#line 427
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 428
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 429
        return ((char *)((void *)0));
      }
      {
#line 431
      result___0 = str_cd_iconv(src, cd);
      }
#line 433
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 436
        tmp___1 = __errno_location();
#line 436
        saved_errno = *tmp___1;
#line 437
        iconv_close(cd);
#line 438
        tmp___2 = __errno_location();
#line 438
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 442
        tmp___5 = iconv_close(cd);
        }
#line 442
        if (tmp___5 < 0) {
          {
#line 446
          tmp___3 = __errno_location();
#line 446
          saved_errno___0 = *tmp___3;
#line 447
          free((void *)result___0);
#line 448
          tmp___4 = __errno_location();
#line 448
          *tmp___4 = saved_errno___0;
          }
#line 449
          return ((char *)((void *)0));
        }
      }
#line 452
      return (result___0);
    }
  }
}
}
#line 30 "/home/khheo/project/benchmark/grep-3.0/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 32
void free_cwd(struct saved_cwd *cwd ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 514
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 22 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 62 "/home/khheo/project/benchmark/grep-3.0/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;

  {
  {
#line 65
  cwd->name = (char *)((void *)0);
#line 67
  cwd->desc = open_safer(".", 0);
  }
#line 70
  if (cwd->desc < 0) {
    {
#line 72
    cwd->name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 73
    if (cwd->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
  {
#line 76
  set_cloexec_flag(cwd->desc, (_Bool)1);
  }
#line 77
  return (0);
}
}
#line 84 "/home/khheo/project/benchmark/grep-3.0/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd->desc) {
    {
#line 88
    tmp = fchdir((int )cwd->desc);
    }
#line 88
    return (tmp);
  } else {
    {
#line 90
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 90
    return (tmp___0);
  }
}
}
#line 93 "/home/khheo/project/benchmark/grep-3.0/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 96
  if (cwd->desc >= 0) {
    {
#line 97
    close(cwd->desc);
    }
  }
  {
#line 98
  free((void *)cwd->name);
  }
#line 99
  return;
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/grep-3.0/lib/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 267 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.h"
char const   * const  quoting_style_args[11] ;
#line 268
enum quoting_style  const  quoting_style_vals[10] ;
#line 278
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 281
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) ;
#line 285
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 294
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 300
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 311
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 326
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 333
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 342
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 352
char *quotearg_n(int n , char const   *arg ) ;
#line 355
char *quotearg(char const   *arg ) ;
#line 360
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 363
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 368
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 373
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 380
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 385
char *quotearg_char(char const   *arg , char ch ) ;
#line 388
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 391
char *quotearg_colon(char const   *arg ) ;
#line 394
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 397
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) ;
#line 403
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 408
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 413
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 418
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 423
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/grep-3.0/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 44
char const   *quote(char const   *arg ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 168 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isalnum(int c ) 
{ 


  {
  {
#line 175
  if (c == 90) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 89) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 88) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 87) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 86) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 85) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 84) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 83) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 82) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 81) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 80) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 79) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 78) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 77) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 76) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 75) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 74) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 73) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 72) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 71) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 70) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 69) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 68) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 67) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 66) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 65) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 122) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 121) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 120) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 119) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 118) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 117) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 116) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 115) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 114) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 113) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 112) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 111) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 110) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 109) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 108) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 107) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 106) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 105) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 104) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 103) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 102) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 101) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 100) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 99) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 98) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 97) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 57) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 56) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 55) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 54) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 53) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 52) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 51) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 50) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 49) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 48) {
#line 175
    goto case_90;
  }
#line 177
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 176
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 178
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isalpha(int c ) 
{ 


  {
  {
#line 188
  if (c == 90) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 89) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 88) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 87) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 86) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 85) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 84) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 83) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 82) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 81) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 80) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 79) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 78) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 77) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 76) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 75) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 74) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 73) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 72) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 71) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 70) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 69) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 68) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 67) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 66) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 65) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 122) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 121) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 120) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 119) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 118) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 117) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 116) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 115) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 114) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 113) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 112) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 111) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 110) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 109) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 108) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 107) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 106) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 105) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 104) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 103) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 102) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 101) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 100) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 99) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 98) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 97) {
#line 188
    goto case_90;
  }
#line 190
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 189
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 191
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isascii(int c ) 
{ 


  {
  {
#line 207
  if (c == 90) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 89) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 88) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 87) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 86) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 85) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 84) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 83) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 82) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 81) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 80) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 79) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 78) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 77) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 76) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 75) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 74) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 73) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 72) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 71) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 70) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 69) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 68) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 67) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 66) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 65) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 126) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 125) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 124) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 123) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 96) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 95) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 94) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 93) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 92) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 91) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 64) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 63) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 62) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 61) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 60) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 59) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 58) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 47) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 46) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 45) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 44) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 43) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 42) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 41) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 40) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 39) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 38) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 37) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 36) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 35) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 34) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 33) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 122) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 121) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 120) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 119) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 118) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 117) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 116) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 115) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 114) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 113) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 112) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 111) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 110) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 109) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 108) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 107) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 106) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 105) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 104) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 103) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 102) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 101) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 100) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 99) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 98) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 97) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 57) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 56) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 55) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 54) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 53) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 52) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 51) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 50) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 49) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 48) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 127) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 31) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 30) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 29) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 28) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 27) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 26) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 25) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 24) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 23) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 22) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 21) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 20) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 19) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 18) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 17) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 16) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 15) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 14) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 6) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 5) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 4) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 3) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 2) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 1) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 0) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 11) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 9) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 13) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 10) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 12) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 8) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 7) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 32) {
#line 207
    goto case_90;
  }
#line 209
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 208
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 210
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 217
  if (c == 32) {
#line 217
    tmp = 1;
  } else
#line 217
  if (c == 9) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  return ((_Bool )tmp);
}
}
#line 220 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_iscntrl(int c ) 
{ 


  {
  {
#line 225
  if (c == 127) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 31) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 30) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 29) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 28) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 27) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 26) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 25) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 24) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 23) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 22) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 21) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 20) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 19) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 18) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 17) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 16) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 15) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 14) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 6) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 5) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 4) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 3) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 2) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 1) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 0) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 11) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 9) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 13) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 10) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 12) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 8) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 7) {
#line 225
    goto case_127;
  }
#line 227
  goto switch_default;
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 226
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 228
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 232 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isdigit(int c ) 
{ 


  {
  {
#line 237
  if (c == 57) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 56) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 55) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 54) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 53) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 52) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 51) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 50) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 49) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 48) {
#line 237
    goto case_57;
  }
#line 239
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 238
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 240
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 244 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isgraph(int c ) 
{ 


  {
  {
#line 252
  if (c == 90) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 89) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 88) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 87) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 86) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 85) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 84) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 83) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 82) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 81) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 80) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 79) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 78) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 77) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 76) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 75) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 74) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 73) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 72) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 71) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 70) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 69) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 68) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 67) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 66) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 65) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 126) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 125) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 124) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 123) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 96) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 95) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 94) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 93) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 92) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 91) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 64) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 63) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 62) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 61) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 60) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 59) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 58) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 47) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 46) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 45) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 44) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 43) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 42) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 41) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 40) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 39) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 38) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 37) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 36) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 35) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 34) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 33) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 122) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 121) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 120) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 119) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 118) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 117) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 116) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 115) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 114) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 113) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 112) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 111) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 110) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 109) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 108) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 107) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 106) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 105) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 104) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 103) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 102) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 101) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 100) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 99) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 98) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 97) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 57) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 56) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 55) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 54) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 53) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 52) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 51) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 50) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 49) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 48) {
#line 252
    goto case_90;
  }
#line 254
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 253
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 255
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_islower(int c ) 
{ 


  {
  {
#line 264
  if (c == 122) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 121) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 120) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 119) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 118) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 117) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 116) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 115) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 114) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 113) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 112) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 111) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 110) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 109) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 108) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 107) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 106) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 105) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 104) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 103) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 102) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 101) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 100) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 99) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 98) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 97) {
#line 264
    goto case_122;
  }
#line 266
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 265
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 267
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 271 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isprint(int c ) 
{ 


  {
  {
#line 280
  if (c == 90) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 89) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 88) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 87) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 86) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 85) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 84) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 83) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 82) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 81) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 80) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 79) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 78) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 77) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 76) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 75) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 74) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 73) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 72) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 71) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 70) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 69) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 68) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 67) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 66) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 65) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 126) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 125) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 124) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 123) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 96) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 95) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 94) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 93) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 92) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 91) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 64) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 63) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 62) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 61) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 60) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 59) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 58) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 47) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 46) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 45) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 44) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 43) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 42) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 41) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 40) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 39) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 38) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 37) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 36) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 35) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 34) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 33) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 122) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 121) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 120) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 119) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 118) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 117) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 116) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 115) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 114) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 113) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 112) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 111) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 110) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 109) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 108) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 107) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 106) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 105) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 104) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 103) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 102) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 101) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 100) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 99) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 98) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 97) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 57) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 56) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 55) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 54) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 53) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 52) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 51) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 50) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 49) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 48) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 32) {
#line 280
    goto case_90;
  }
#line 282
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 281
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 283
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 287 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_ispunct(int c ) 
{ 


  {
  {
#line 292
  if (c == 126) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 125) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 124) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 123) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 96) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 95) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 94) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 93) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 92) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 91) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 64) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 63) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 62) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 61) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 60) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 59) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 58) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 47) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 46) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 45) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 44) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 43) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 42) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 41) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 39) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 38) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 37) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 36) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 35) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 34) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 33) {
#line 292
    goto case_126;
  }
#line 294
  goto switch_default;
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 293
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 295
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 299 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isspace(int c ) 
{ 


  {
  {
#line 304
  if (c == 13) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 12) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 11) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 10) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 9) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 32) {
#line 304
    goto case_13;
  }
#line 306
  goto switch_default;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 305
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 307
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isupper(int c ) 
{ 


  {
  {
#line 316
  if (c == 90) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 89) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 88) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 87) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 86) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 85) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 84) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 83) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 82) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 81) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 80) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 79) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 78) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 77) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 76) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 75) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 74) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 73) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 72) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 71) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 70) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 69) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 68) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 67) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 66) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 65) {
#line 316
    goto case_90;
  }
#line 318
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 317
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 319
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 323 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline _Bool c_isxdigit(int c ) 
{ 


  {
  {
#line 329
  if (c == 70) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 69) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 68) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 67) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 66) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 65) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 102) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 101) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 100) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 99) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 98) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 97) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 57) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 56) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 55) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 54) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 53) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 52) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 51) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 50) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 49) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 48) {
#line 329
    goto case_70;
  }
#line 331
  goto switch_default;
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 330
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 332
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 336 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline int c_tolower(int c ) 
{ 


  {
  {
#line 341
  if (c == 90) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 89) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 88) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 87) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 86) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 85) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 83) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 82) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 81) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 80) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 79) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 78) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 77) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 76) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 75) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 74) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 73) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 72) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 71) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 70) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 69) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 68) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 67) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 66) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 65) {
#line 341
    goto case_90;
  }
#line 343
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 342
  return ((c - 65) + 97);
  switch_default: /* CIL Label */ 
#line 344
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
__inline int c_toupper(int c ) 
{ 


  {
  {
#line 353
  if (c == 122) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 121) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 120) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 119) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 118) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 117) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 116) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 115) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 114) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 113) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 112) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 111) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 110) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 109) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 108) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 107) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 106) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 105) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 104) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 103) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 102) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 101) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 100) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 99) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 98) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 97) {
#line 353
    goto case_122;
  }
#line 355
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 354
  return ((c - 97) + 65);
  switch_default: /* CIL Label */ 
#line 356
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 364
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 77 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char const   * const  quoting_style_args[11]  = 
#line 77 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"shell-escape", 
        (char const   */* const  */)"shell-escape-always",      (char const   */* const  */)"c",      (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape", 
        (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 93 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[10]  = 
#line 93
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7, 
        (enum quoting_style  const  )8,      (enum quoting_style  const  )9};
#line 108 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 113 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 116
  tmp = __errno_location();
#line 116
  e = *tmp;
  }
#line 117
  if (o) {
#line 117
    tmp___0 = o;
  } else {
#line 117
    tmp___0 = & default_quoting_options;
  }
  {
#line 117
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 117
  p = (struct quoting_options *)tmp___1;
#line 119
  tmp___2 = __errno_location();
#line 119
  *tmp___2 = e;
  }
#line 120
  return (p);
}
}
#line 124 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *tmp ;

  {
#line 127
  if (o) {
#line 127
    tmp = o;
  } else {
#line 127
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 127
  return ((enum quoting_style )tmp->style);
}
}
#line 132 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 135
  if (o) {
#line 135
    tmp = o;
  } else {
#line 135
    tmp = & default_quoting_options;
  }
#line 135
  tmp->style = s;
#line 136
  return;
}
}
#line 143 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 146
  uc = (unsigned char )c;
#line 147
  if (o) {
#line 147
    tmp = o;
  } else {
#line 147
    tmp = & default_quoting_options;
  }
#line 147
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 149
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 150
  r = (int )((*p >> shift) & 1U);
#line 151
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 152
  return (r);
}
}
#line 159 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 163
  if (! o) {
#line 164
    o = & default_quoting_options;
  }
#line 165
  r = o->flags;
#line 166
  o->flags = i;
#line 167
  return (r);
}
}
#line 170 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 174
  if (! o) {
#line 175
    o = & default_quoting_options;
  }
#line 176
  o->style = (enum quoting_style )10;
#line 177
  if (! left_quote) {
    {
#line 178
    abort();
    }
  } else
#line 177
  if (! right_quote) {
    {
#line 178
    abort();
    }
  }
#line 179
  o->left_quote = left_quote;
#line 180
  o->right_quote = right_quote;
#line 181
  return;
}
}
#line 184 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 187
  o.style = (enum quoting_style )0;
#line 187
  o.flags = 0;
#line 187
  o.quote_these_too[0] = 0U;
#line 187
  tmp = 1U;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (tmp >= 8U) {
#line 187
      goto while_break;
    }
#line 187
    o.quote_these_too[tmp] = 0U;
#line 187
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  o.left_quote = (char const   *)((void *)0);
#line 187
  o.right_quote = (char const   *)((void *)0);
#line 188
  if ((unsigned int )style == 10U) {
    {
#line 189
    abort();
    }
  }
#line 190
  o.style = style;
#line 191
  return (o);
}
}
#line 198 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 201
  tmp = gettext(msgid);
#line 201
  translation = (char const   *)tmp;
  }
#line 204
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 205
    return (translation);
  }
  {
#line 225
  locale_code = locale_charset();
#line 226
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 226
  if (tmp___1 == 0) {
#line 227
    if ((int const   )*(msgid + 0) == 96) {
#line 227
      tmp___0 = "\342\200\230";
    } else {
#line 227
      tmp___0 = "\342\200\231";
    }
#line 227
    return (tmp___0);
  }
  {
#line 228
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 228
  if (tmp___3 == 0) {
#line 229
    if ((int const   )*(msgid + 0) == 96) {
#line 229
      tmp___2 = "\241\ae";
    } else {
#line 229
      tmp___2 = "\241\257";
    }
#line 229
    return (tmp___2);
  }
#line 231
  if ((unsigned int )s == 9U) {
#line 231
    tmp___4 = "\"";
  } else {
#line 231
    tmp___4 = "\'";
  }
#line 231
  return (tmp___4);
}
}
#line 247 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 256
  len = (size_t )0;
#line 257
  orig_buffersize = (size_t )0;
#line 258
  quote_string = (char const   *)0;
#line 259
  quote_string_len = (size_t )0;
#line 260
  backslash_escapes = (_Bool)0;
#line 261
  tmp = __ctype_get_mb_cur_max();
#line 261
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 262
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 263
  pending_shell_escape_end = (_Bool)0;
#line 264
  encountered_single_quote = (_Bool)0;
#line 265
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 310
  if ((unsigned int )quoting_style == 6U) {
#line 310
    goto case_6;
  }
#line 314
  if ((unsigned int )quoting_style == 5U) {
#line 314
    goto case_5;
  }
#line 322
  if ((unsigned int )quoting_style == 7U) {
#line 322
    goto case_7;
  }
#line 329
  if ((unsigned int )quoting_style == 10U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 9U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 8U) {
#line 329
    goto case_10;
  }
#line 366
  if ((unsigned int )quoting_style == 3U) {
#line 366
    goto case_3;
  }
#line 369
  if ((unsigned int )quoting_style == 1U) {
#line 369
    goto case_1;
  }
#line 372
  if ((unsigned int )quoting_style == 4U) {
#line 372
    goto case_4;
  }
#line 376
  if ((unsigned int )quoting_style == 2U) {
#line 376
    goto case_2;
  }
#line 384
  if ((unsigned int )quoting_style == 0U) {
#line 384
    goto case_0;
  }
#line 388
  goto switch_default;
  case_6: /* CIL Label */ 
#line 311
  quoting_style = (enum quoting_style )5;
#line 312
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 315
  if (! elide_outer_quotes) {
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 316
      if (len < buffersize) {
#line 316
        *(buffer___0 + len) = (char )'\"';
      }
#line 316
      len ++;
#line 316
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 317
  backslash_escapes = (_Bool)1;
#line 318
  quote_string = "\"";
#line 319
  quote_string_len = (size_t )1;
#line 320
  goto switch_break;
  case_7: /* CIL Label */ 
#line 323
  backslash_escapes = (_Bool)1;
#line 324
  elide_outer_quotes = (_Bool)0;
#line 325
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 331
  if ((unsigned int )quoting_style != 10U) {
    {
#line 354
    left_quote = gettext_quote("`", quoting_style);
#line 355
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 357
  if (! elide_outer_quotes) {
#line 358
    quote_string = left_quote;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! *quote_string) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 359
        if (len < buffersize) {
#line 359
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 359
        len ++;
#line 359
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 358
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 360
  backslash_escapes = (_Bool)1;
#line 361
  quote_string = right_quote;
#line 362
  quote_string_len = strlen(quote_string);
  }
#line 364
  goto switch_break;
  case_3: /* CIL Label */ 
#line 367
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 370
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 373
  if (! elide_outer_quotes) {
#line 374
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 377
  quoting_style = (enum quoting_style )2;
#line 378
  if (! elide_outer_quotes) {
    {
#line 379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 379
      if (len < buffersize) {
#line 379
        *(buffer___0 + len) = (char )'\'';
      }
#line 379
      len ++;
#line 379
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 380
  quote_string = "\'";
#line 381
  quote_string_len = (size_t )1;
#line 382
  goto switch_break;
  case_0: /* CIL Label */ 
#line 385
  elide_outer_quotes = (_Bool)0;
#line 386
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 389
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 392
  i = (size_t )0;
  {
#line 392
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 392
    if (argsize == 0xffffffffffffffffUL) {
#line 392
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 392
      tmp___7 = i == argsize;
    }
#line 392
    if (tmp___7) {
#line 392
      goto while_break___3;
    }
#line 396
    is_right_quote = (_Bool)0;
#line 397
    escaping = (_Bool)0;
#line 398
    c_and_shell_quote_compat = (_Bool)0;
#line 400
    if (backslash_escapes) {
#line 400
      if ((unsigned int )quoting_style != 2U) {
#line 400
        if (quote_string_len) {
#line 400
          if (argsize == 0xffffffffffffffffUL) {
#line 400
            if (1UL < quote_string_len) {
              {
#line 400
              argsize = strlen(arg);
#line 400
              tmp___0 = argsize;
              }
            } else {
#line 400
              tmp___0 = argsize;
            }
          } else {
#line 400
            tmp___0 = argsize;
          }
#line 400
          if (i + quote_string_len <= tmp___0) {
            {
#line 400
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 400
            if (tmp___1 == 0) {
#line 411
              if (elide_outer_quotes) {
#line 412
                goto force_outer_quoting_style;
              }
#line 413
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 416
    c = (unsigned char )*(arg + i);
    {
#line 419
    if ((int )c == 0) {
#line 419
      goto case_0___0;
    }
#line 445
    if ((int )c == 63) {
#line 445
      goto case_63;
    }
#line 483
    if ((int )c == 7) {
#line 483
      goto case_7___0;
    }
#line 484
    if ((int )c == 8) {
#line 484
      goto case_8___0;
    }
#line 485
    if ((int )c == 12) {
#line 485
      goto case_12;
    }
#line 486
    if ((int )c == 10) {
#line 486
      goto case_10___0;
    }
#line 487
    if ((int )c == 13) {
#line 487
      goto case_13;
    }
#line 488
    if ((int )c == 9) {
#line 488
      goto case_9___0;
    }
#line 489
    if ((int )c == 11) {
#line 489
      goto case_11;
    }
#line 490
    if ((int )c == 92) {
#line 490
      goto case_92;
    }
#line 517
    if ((int )c == 125) {
#line 517
      goto case_125;
    }
#line 517
    if ((int )c == 123) {
#line 517
      goto case_125;
    }
#line 521
    if ((int )c == 126) {
#line 521
      goto case_126;
    }
#line 521
    if ((int )c == 35) {
#line 521
      goto case_126;
    }
#line 525
    if ((int )c == 32) {
#line 525
      goto case_32;
    }
#line 535
    if ((int )c == 124) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 96) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 94) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 91) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 62) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 61) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 60) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 59) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 42) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 41) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 40) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 38) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 36) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 34) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 33) {
#line 535
      goto case_124;
    }
#line 545
    if ((int )c == 39) {
#line 545
      goto case_39___0;
    }
#line 580
    if ((int )c == 122) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 121) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 120) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 119) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 118) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 117) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 116) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 115) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 114) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 113) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 112) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 111) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 110) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 109) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 108) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 107) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 106) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 105) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 104) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 103) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 102) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 101) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 100) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 99) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 98) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 97) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 95) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 93) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 90) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 89) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 88) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 87) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 86) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 85) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 84) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 83) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 82) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 81) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 80) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 79) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 78) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 77) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 76) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 75) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 74) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 73) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 72) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 71) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 70) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 69) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 68) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 67) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 66) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 65) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 58) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 57) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 56) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 55) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 54) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 53) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 52) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 51) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 50) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 49) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 48) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 47) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 46) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 45) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 44) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 43) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 37) {
#line 580
      goto case_122;
    }
#line 594
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 420
    if (backslash_escapes) {
      {
#line 422
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 422
        if (elide_outer_quotes) {
#line 422
          goto force_outer_quoting_style;
        }
#line 422
        escaping = (_Bool)1;
#line 422
        if ((unsigned int )quoting_style == 2U) {
#line 422
          if (! pending_shell_escape_end) {
            {
#line 422
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'$';
              }
#line 422
              len ++;
#line 422
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 422
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 422
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 422
          if (len < buffersize) {
#line 422
            *(buffer___0 + len) = (char )'\\';
          }
#line 422
          len ++;
#line 422
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 422
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 429
      if ((unsigned int )quoting_style != 2U) {
#line 429
        if (i + 1UL < argsize) {
#line 429
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 429
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 432
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 432
                if (len < buffersize) {
#line 432
                  *(buffer___0 + len) = (char )'0';
                }
#line 432
                len ++;
#line 432
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 433
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 433
                if (len < buffersize) {
#line 433
                  *(buffer___0 + len) = (char )'0';
                }
#line 433
                len ++;
#line 433
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 435
      c = (unsigned char )'0';
    } else
#line 441
    if (flags & 1) {
#line 442
      goto __Cont;
    }
#line 443
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 448
    if ((unsigned int )quoting_style == 2U) {
#line 448
      goto case_2___0;
    }
#line 453
    if ((unsigned int )quoting_style == 5U) {
#line 453
      goto case_5___0;
    }
#line 478
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 449
    if (elide_outer_quotes) {
#line 450
      goto force_outer_quoting_style;
    }
#line 451
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 454
    if (flags & 4) {
#line 454
      if (i + 2UL < argsize) {
#line 454
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 460
            goto case_62;
          }
#line 473
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 463
          if (elide_outer_quotes) {
#line 464
            goto force_outer_quoting_style;
          }
#line 465
          c = (unsigned char )*(arg + (i + 2UL));
#line 466
          i += 2UL;
          {
#line 467
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 467
            if (len < buffersize) {
#line 467
              *(buffer___0 + len) = (char )'?';
            }
#line 467
            len ++;
#line 467
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 468
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 468
            if (len < buffersize) {
#line 468
              *(buffer___0 + len) = (char )'\"';
            }
#line 468
            len ++;
#line 468
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 469
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 469
            if (len < buffersize) {
#line 469
              *(buffer___0 + len) = (char )'\"';
            }
#line 469
            len ++;
#line 469
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 470
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 470
            if (len < buffersize) {
#line 470
              *(buffer___0 + len) = (char )'?';
            }
#line 470
            len ++;
#line 470
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 471
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 474
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 476
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 479
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 481
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 483
    esc = (unsigned char )'a';
#line 483
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 484
    esc = (unsigned char )'b';
#line 484
    goto c_escape;
    case_12: /* CIL Label */ 
#line 485
    esc = (unsigned char )'f';
#line 485
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 486
    esc = (unsigned char )'n';
#line 486
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 487
    esc = (unsigned char )'r';
#line 487
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 488
    esc = (unsigned char )'t';
#line 488
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 489
    esc = (unsigned char )'v';
#line 489
    goto c_escape;
    case_92: /* CIL Label */ 
#line 490
    esc = c;
#line 492
    if ((unsigned int )quoting_style == 2U) {
#line 494
      if (elide_outer_quotes) {
#line 495
        goto force_outer_quoting_style;
      }
#line 496
      goto store_c;
    }
#line 501
    if (backslash_escapes) {
#line 501
      if (elide_outer_quotes) {
#line 501
        if (quote_string_len) {
#line 502
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 505
    if ((unsigned int )quoting_style == 2U) {
#line 505
      if (elide_outer_quotes) {
#line 507
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 510
    if (backslash_escapes) {
#line 512
      c = esc;
#line 513
      goto store_escape;
    }
#line 515
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 518
    if (argsize == 0xffffffffffffffffUL) {
#line 518
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 518
      tmp___2 = argsize == 1UL;
    }
#line 518
    if (! tmp___2) {
#line 519
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 522
    if (i != 0UL) {
#line 523
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 526
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 540
    if ((unsigned int )quoting_style == 2U) {
#line 540
      if (elide_outer_quotes) {
#line 542
        goto force_outer_quoting_style;
      }
    }
#line 543
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 546
    encountered_single_quote = (_Bool)1;
#line 547
    c_and_shell_quote_compat = (_Bool)1;
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 550
      if (elide_outer_quotes) {
#line 551
        goto force_outer_quoting_style;
      }
#line 553
      if (buffersize) {
#line 553
        if (! orig_buffersize) {
#line 558
          orig_buffersize = buffersize;
#line 559
          buffersize = (size_t )0;
        }
      }
      {
#line 562
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 562
        if (len < buffersize) {
#line 562
          *(buffer___0 + len) = (char )'\'';
        }
#line 562
        len ++;
#line 562
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 563
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 563
        if (len < buffersize) {
#line 563
          *(buffer___0 + len) = (char )'\\';
        }
#line 563
        len ++;
#line 563
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 564
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 564
        if (len < buffersize) {
#line 564
          *(buffer___0 + len) = (char )'\'';
        }
#line 564
        len ++;
#line 564
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 565
      pending_shell_escape_end = (_Bool)0;
    }
#line 567
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 591
    c_and_shell_quote_compat = (_Bool)1;
#line 592
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 606
    if (unibyte_locale) {
      {
#line 608
      m = (size_t )1;
#line 609
      tmp___3 = __ctype_b_loc();
#line 609
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 614
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 616
      m = (size_t )0;
#line 617
      printable = (_Bool)1;
      }
#line 618
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 619
        argsize = strlen(arg);
        }
      }
      {
#line 621
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 624
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 624
        bytes = tmp___4;
        }
#line 626
        if (bytes == 0UL) {
#line 627
          goto while_break___18;
        } else
#line 628
        if (bytes == 0xffffffffffffffffUL) {
#line 630
          printable = (_Bool)0;
#line 631
          goto while_break___18;
        } else
#line 633
        if (bytes == 0xfffffffffffffffeUL) {
#line 635
          printable = (_Bool)0;
          {
#line 636
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 636
            if (i + m < argsize) {
#line 636
              if (! *(arg + (i + m))) {
#line 636
                goto while_break___19;
              }
            } else {
#line 636
              goto while_break___19;
            }
#line 637
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 638
          goto while_break___18;
        } else {
#line 646
          if (elide_outer_quotes) {
#line 646
            if ((unsigned int )quoting_style == 2U) {
#line 650
              j = (size_t )1;
              {
#line 650
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 650
                if (! (j < bytes)) {
#line 650
                  goto while_break___20;
                }
                {
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 654
                  goto case_124___0;
                }
#line 657
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 655
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 658
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 650
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 662
          tmp___5 = iswprint((wint_t )w);
          }
#line 662
          if (! tmp___5) {
#line 663
            printable = (_Bool)0;
          }
#line 664
          m += bytes;
        }
        {
#line 621
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 621
        if (tmp___6) {
#line 621
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 670
    c_and_shell_quote_compat = printable;
#line 672
    if (1UL < m) {
#line 672
      goto _L___0;
    } else
#line 672
    if (backslash_escapes) {
#line 672
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 676
        ilim = i + m;
        {
#line 678
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 680
          if (backslash_escapes) {
#line 680
            if (! printable) {
              {
#line 682
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 682
                if (elide_outer_quotes) {
#line 682
                  goto force_outer_quoting_style;
                }
#line 682
                escaping = (_Bool)1;
#line 682
                if ((unsigned int )quoting_style == 2U) {
#line 682
                  if (! pending_shell_escape_end) {
                    {
#line 682
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'$';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 682
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 682
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 682
                  if (len < buffersize) {
#line 682
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 682
                  len ++;
#line 682
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 682
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 683
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 683
                if (len < buffersize) {
#line 683
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 683
                len ++;
#line 683
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 684
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 684
                if (len < buffersize) {
#line 684
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 684
                len ++;
#line 684
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 685
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 680
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 687
          if (is_right_quote) {
            {
#line 689
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 689
              if (len < buffersize) {
#line 689
                *(buffer___0 + len) = (char )'\\';
              }
#line 689
              len ++;
#line 689
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 690
            is_right_quote = (_Bool)0;
          }
#line 692
          if (ilim <= i + 1UL) {
#line 693
            goto while_break___21;
          }
          {
#line 694
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 694
            if (pending_shell_escape_end) {
#line 694
              if (! escaping) {
                {
#line 694
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 694
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 694
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 694
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 695
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 695
            if (len < buffersize) {
#line 695
              *(buffer___0 + len) = (char )c;
            }
#line 695
            len ++;
#line 695
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 696
          i ++;
#line 696
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 699
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 704
    if (backslash_escapes) {
#line 704
      if ((unsigned int )quoting_style != 2U) {
#line 704
        goto _L___3;
      } else {
#line 704
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 704
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 704
      if (quote_these_too) {
#line 704
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 704
          goto _L___2;
        }
      } else {
#line 704
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 704
    if (! is_right_quote) {
#line 709
      goto store_c;
    }
    store_escape: 
    {
#line 712
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 712
      if (elide_outer_quotes) {
#line 712
        goto force_outer_quoting_style;
      }
#line 712
      escaping = (_Bool)1;
#line 712
      if ((unsigned int )quoting_style == 2U) {
#line 712
        if (! pending_shell_escape_end) {
          {
#line 712
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'$';
            }
#line 712
            len ++;
#line 712
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 712
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 712
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 712
        if (len < buffersize) {
#line 712
          *(buffer___0 + len) = (char )'\\';
        }
#line 712
        len ++;
#line 712
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 712
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 715
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 715
      if (pending_shell_escape_end) {
#line 715
        if (! escaping) {
          {
#line 715
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 715
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 715
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 715
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 716
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 716
      if (len < buffersize) {
#line 716
        *(buffer___0 + len) = (char )c;
      }
#line 716
      len ++;
#line 716
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 718
    if (! c_and_shell_quote_compat) {
#line 719
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 392
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 722
  if (len == 0UL) {
#line 722
    if ((unsigned int )quoting_style == 2U) {
#line 722
      if (elide_outer_quotes) {
#line 724
        goto force_outer_quoting_style;
      }
    }
  }
#line 730
  if ((unsigned int )quoting_style == 2U) {
#line 730
    if (! elide_outer_quotes) {
#line 730
      if (encountered_single_quote) {
#line 733
        if (all_c_and_shell_quote_compat) {
          {
#line 734
          tmp___8 = quotearg_buffer_restyled(buffer___0, orig_buffersize, arg, argsize,
                                             (enum quoting_style )5, flags, quote_these_too,
                                             left_quote, right_quote);
          }
#line 734
          return (tmp___8);
        } else
#line 738
        if (! buffersize) {
#line 738
          if (orig_buffersize) {
#line 741
            buffersize = orig_buffersize;
#line 742
            len = (size_t )0;
#line 743
            goto process_input;
          }
        }
      }
    }
  }
#line 747
  if (quote_string) {
#line 747
    if (! elide_outer_quotes) {
      {
#line 748
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 748
        if (! *quote_string) {
#line 748
          goto while_break___43;
        }
        {
#line 749
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 749
          if (len < buffersize) {
#line 749
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 749
          len ++;
#line 749
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 748
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 751
  if (len < buffersize) {
#line 752
    *(buffer___0 + len) = (char )'\000';
  }
#line 753
  return (len);
  force_outer_quoting_style: 
#line 758
  if ((unsigned int )quoting_style == 2U) {
#line 758
    if (backslash_escapes) {
#line 759
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 760
  tmp___9 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 760
  return (tmp___9);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 780
  if (o) {
#line 780
    tmp = o;
  } else {
#line 780
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 780
  p = tmp;
#line 781
  tmp___0 = __errno_location();
#line 781
  e = *tmp___0;
#line 782
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 782
  r = tmp___1;
#line 785
  tmp___2 = __errno_location();
#line 785
  *tmp___2 = e;
  }
#line 786
  return (r);
}
}
#line 790 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 794
  return (tmp);
}
}
#line 803 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 807
  if (o) {
#line 807
    tmp = o;
  } else {
#line 807
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 807
  p = tmp;
#line 808
  tmp___0 = __errno_location();
#line 808
  e = *tmp___0;
  }
#line 810
  if (size) {
#line 810
    tmp___1 = 0;
  } else {
#line 810
    tmp___1 = 1;
  }
  {
#line 810
  flags = (int )(p->flags | (int const   )tmp___1);
#line 811
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 811
  bufsize = tmp___2 + 1UL;
#line 815
  tmp___3 = xcharalloc(bufsize);
#line 815
  buf = tmp___3;
#line 816
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 819
  tmp___4 = __errno_location();
#line 819
  *tmp___4 = e;
  }
#line 820
  if (size) {
#line 821
    *size = bufsize - 1UL;
  }
#line 822
  return (buf);
}
}
#line 834 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char slot0[256]  ;
#line 835 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static int nslots  =    1;
#line 836 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 837 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 839 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  int i ;

  {
#line 842
  sv = slotvec;
#line 844
  i = 1;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (i < nslots)) {
#line 844
      goto while_break;
    }
    {
#line 845
    free((void *)(sv + i)->val);
#line 844
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 848
    free((void *)(sv + 0)->val);
#line 849
    slotvec0.size = sizeof(slot0);
#line 850
    slotvec0.val = slot0;
    }
  }
#line 852
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 854
    free((void *)sv);
#line 855
    slotvec = & slotvec0;
    }
  }
#line 857
  nslots = 1;
#line 858
  return;
}
}
#line 868 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 872
  tmp = __errno_location();
#line 872
  e = *tmp;
#line 874
  sv = slotvec;
  }
#line 876
  if (n < 0) {
    {
#line 877
    abort();
    }
  }
#line 879
  if (nslots <= n) {
#line 881
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 883
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 883
      tmp___0 = 2147483647UL;
    } else {
#line 883
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 883
    if (tmp___0 <= (unsigned long )n) {
      {
#line 884
      xalloc_die();
      }
    }
#line 886
    if (preallocated) {
#line 886
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 886
      tmp___1 = sv;
    }
    {
#line 886
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 886
    sv = (struct slotvec *)tmp___2;
#line 886
    slotvec = sv;
    }
#line 887
    if (preallocated) {
#line 888
      *sv = slotvec0;
    }
    {
#line 889
    memset((void *)(sv + nslots), 0, (unsigned long )((n + 1) - nslots) * sizeof(*sv));
#line 890
    nslots = n + 1;
    }
  }
  {
#line 894
  size = (sv + n)->size;
#line 895
  val = (sv + n)->val;
#line 897
  flags = (int )(options->flags | 1);
#line 898
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 898
  qsize = tmp___3;
  }
#line 904
  if (size <= qsize) {
#line 906
    size = qsize + 1UL;
#line 906
    (sv + n)->size = size;
#line 907
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 908
      free((void *)val);
      }
    }
    {
#line 909
    val = xcharalloc(size);
#line 909
    (sv + n)->val = val;
#line 910
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 916
  tmp___4 = __errno_location();
#line 916
  *tmp___4 = e;
  }
#line 917
  return (val);
}
}
#line 921 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 924
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 924
  return (tmp);
}
}
#line 927 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 930
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 930
  return (tmp);
}
}
#line 933 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 936
  tmp = quotearg_n(0, arg);
  }
#line 936
  return (tmp);
}
}
#line 939 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 942
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 942
  return (tmp);
}
}
#line 945 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 948
  tmp = quoting_options_from_style(s);
#line 948
  o = tmp;
#line 949
  tmp___0 = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& o));
  }
#line 949
  return (tmp___0);
}
}
#line 952 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 956
  tmp = quoting_options_from_style(s);
#line 956
  o = tmp;
#line 957
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 957
  return (tmp___0);
}
}
#line 960 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 963
  tmp = quotearg_n_style(0, s, arg);
  }
#line 963
  return (tmp);
}
}
#line 966 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 969
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 969
  return (tmp);
}
}
#line 972 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 976
  options = default_quoting_options;
#line 977
  set_char_quoting(& options, ch, 1);
#line 978
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 978
  return (tmp);
}
}
#line 981 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 984
  tmp = quotearg_char_mem(arg, 0xffffffffffffffffUL, ch);
  }
#line 984
  return (tmp);
}
}
#line 987 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 990
  tmp = quotearg_char(arg, (char )':');
  }
#line 990
  return (tmp);
}
}
#line 993 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 996
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 996
  return (tmp);
}
}
#line 999 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 1003
  options = quoting_options_from_style(s);
#line 1004
  set_char_quoting(& options, (char )':', 1);
#line 1005
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& options));
  }
#line 1005
  return (tmp);
}
}
#line 1008 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1012
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, 0xffffffffffffffffUL);
  }
#line 1012
  return (tmp);
}
}
#line 1016 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 1021
  o = default_quoting_options;
#line 1022
  set_custom_quoting(& o, left_quote, right_quote);
#line 1023
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 1023
  return (tmp);
}
}
#line 1026 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1030
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 1030
  return (tmp);
}
}
#line 1033 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1037
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 1037
  return (tmp);
}
}
#line 1043 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )8, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 1051 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1054
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 1054
  return ((char const   *)tmp);
}
}
#line 1057 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 1060
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 1060
  return (tmp);
}
}
#line 1063 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1066
  tmp = quote_n_mem(n, arg, 0xffffffffffffffffUL);
  }
#line 1066
  return (tmp);
}
}
#line 1069 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1072
  tmp = quote_n(0, arg);
  }
#line 1072
  return (tmp);
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 92 "/home/khheo/project/benchmark/grep-3.0/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 1170 "./string.h"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
__inline void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 134
  if (iter->next_done) {
#line 135
    return;
  }
#line 136
  if (iter->in_shift) {
#line 137
    goto with_shift;
  }
  {
#line 139
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 139
  if (tmp___8) {
#line 144
    iter->cur.bytes = (size_t )1;
#line 145
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 146
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 150
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 150
    if (! tmp___2) {
      {
#line 150
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h",
                    150U, "mbuiter_multi_next");
      }
    }
#line 151
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 153
    tmp___3 = __ctype_get_mb_cur_max();
#line 153
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 153
    iter->cur.bytes = rpl_mbrtowc(& iter->cur.wc, iter->cur.ptr, tmp___4, & iter->state);
    }
#line 156
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 159
      iter->cur.bytes = (size_t )1;
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 164
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 167
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 168
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 174
      if (iter->cur.bytes == 0UL) {
#line 177
        iter->cur.bytes = (size_t )1;
#line 178
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 178
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h",
                        178U, "mbuiter_multi_next");
          }
        }
#line 179
        if (! (iter->cur.wc == 0)) {
          {
#line 179
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h",
                        179U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 181
      iter->cur.wc_valid = (_Bool)1;
#line 185
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 185
      if (tmp___7) {
#line 186
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 189
  iter->next_done = (_Bool)1;
#line 190
  return;
}
}
#line 192 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
__inline void mbuiter_multi_reloc(struct mbuiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 195
  iter->cur.ptr += ptrdiff;
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
__inline void mbuiter_multi_copy(struct mbuiter_multi *new_iter , struct mbuiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 201
  tmp = (_Bool )old_iter->in_shift;
#line 201
  new_iter->in_shift = tmp;
#line 201
  if (tmp) {
    {
#line 202
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 204
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 205
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 206
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 207
  return;
}
}
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 157 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 161
  tmp = gettext(name);
#line 161
  translation = (char const   *)tmp;
  }
#line 163
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 166
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 166
    if (tmp___7) {
#line 167
      return (translation);
    } else {
#line 171
      if (sizeof(char ) == 1UL) {
        {
#line 171
        tmp___0 = strlen(translation);
#line 171
        tmp___1 = strlen(name);
#line 171
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 171
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 171
        tmp___3 = strlen(translation);
#line 171
        tmp___4 = strlen(name);
#line 171
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 171
        tmp___6 = tmp___5;
        }
      }
      {
#line 171
      result = (char *)tmp___6;
#line 174
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 175
      return ((char const   *)result);
    }
  } else {
#line 179
    return (name);
  }
}
}
#line 187 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;

  {
  {
#line 191
  tmp = gettext(name_ascii);
#line 191
  translation = (char const   *)tmp;
#line 194
  tmp___0 = locale_charset();
#line 194
  locale_code = tmp___0;
#line 195
  alloc_name_converted = (char *)((void *)0);
#line 196
  alloc_name_converted_translit = (char *)((void *)0);
#line 197
  name_converted = (char const   *)((void *)0);
#line 198
  name_converted_translit = (char const   *)((void *)0);
#line 201
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 201
  if (tmp___6 != 0) {
    {
#line 204
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 204
    name_converted = (char const   *)alloc_name_converted;
#line 213
    tmp___1 = strlen(locale_code);
#line 213
    len = tmp___1;
    }
#line 214
    if (sizeof(char ) == 1UL) {
      {
#line 214
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 214
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 214
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 214
      tmp___4 = tmp___3;
      }
    }
    {
#line 214
    locale_code_translit = (char *)tmp___4;
#line 215
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 216
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 218
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 221
    free((void *)locale_code_translit);
    }
#line 223
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 230
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 230
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 231
        free((void *)converted_translit);
        }
      } else {
#line 234
        alloc_name_converted_translit = converted_translit;
#line 234
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 243
    name_converted = name_utf8;
#line 244
    name_converted_translit = name_utf8;
  }
#line 248
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 248
    name = name_converted;
  } else {
#line 248
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 248
      tmp___7 = name_converted_translit;
    } else {
#line 248
      tmp___7 = name_ascii;
    }
#line 248
    name = tmp___7;
  }
  {
#line 255
  tmp___18 = strcmp(translation, name_ascii);
  }
#line 255
  if (tmp___18 != 0) {
    {
#line 258
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 258
    if (tmp___15) {
#line 258
      goto _L;
    } else
#line 258
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 258
      if (tmp___16) {
#line 258
        goto _L;
      } else {
#line 258
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 258
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 258
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 258
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 264
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 265
          free((void *)alloc_name_converted);
          }
        }
#line 266
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 267
          free((void *)alloc_name_converted_translit);
          }
        }
#line 268
        return (translation);
      } else {
#line 258
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 273
      if (sizeof(char ) == 1UL) {
        {
#line 273
        tmp___8 = strlen(translation);
#line 273
        tmp___9 = strlen(name);
#line 273
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 273
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 273
        tmp___11 = strlen(translation);
#line 273
        tmp___12 = strlen(name);
#line 273
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 273
        tmp___14 = tmp___13;
        }
      }
      {
#line 273
      result = (char *)tmp___14;
#line 276
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 278
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 279
        free((void *)alloc_name_converted);
        }
      }
#line 280
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 281
        free((void *)alloc_name_converted_translit);
        }
      }
#line 282
      return ((char const   *)result);
    }
  } else {
#line 287
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 287
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 288
        free((void *)alloc_name_converted);
        }
      }
    }
#line 289
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 289
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 291
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 292
    return (name);
  }
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.0/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-3.0/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 22 "/home/khheo/project/benchmark/grep-3.0/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-3.0/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/khheo/project/benchmark/grep-3.0/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl-safer.h"
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = openat(fd, file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.0/lib/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 65 "/home/khheo/project/benchmark/grep-3.0/lib/openat-proc.c"
static int proc_status  =    0;
#line 43 "/home/khheo/project/benchmark/grep-3.0/lib/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file ) 
{ 
  char *result ;
  int dirlen ;
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(27UL + sizeof("../fd")) - 1UL] ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 46
  result = (char *)buf;
#line 50
  if (! *file) {
#line 52
    *(buf + 0) = (char )'\000';
#line 53
    return ((char *)buf);
  }
#line 66
  if (! proc_status) {
    {
#line 76
    tmp = open("/proc/self/fd", 67840);
#line 76
    proc_self_fd = tmp;
    }
#line 78
    if (proc_self_fd < 0) {
#line 79
      proc_status = -1;
    } else {
      {
#line 88
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/../fd",
              proc_self_fd);
#line 89
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      }
#line 89
      if (tmp___1) {
#line 89
        proc_status = -1;
      } else {
#line 89
        proc_status = 1;
      }
      {
#line 90
      close(proc_self_fd);
      }
    }
  }
#line 94
  if (proc_status < 0) {
#line 95
    return ((char *)((void *)0));
  } else {
    {
#line 98
    tmp___2 = strlen(file);
#line 98
    bufsize = 27UL + tmp___2;
    }
#line 99
    if (4032UL < bufsize) {
      {
#line 101
      tmp___3 = malloc(bufsize);
#line 101
      result = (char *)tmp___3;
      }
#line 102
      if (! result) {
#line 103
        return ((char *)((void *)0));
      }
    }
    {
#line 106
    dirlen = sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/",
                     fd);
    }
  }
  {
#line 132
  strcpy((char */* __restrict  */)(result + dirlen), (char const   */* __restrict  */)file);
  }
#line 133
  return (result);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 48
void openat_restore_fail(int errnum ) ;
#line 49
void openat_save_fail(int errnum ) ;
#line 121
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/grep-3.0/lib/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 37
  tmp = gettext("unable to record current working directory");
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
  }
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("failed to return to initial working directory");
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
    }
  }
  {
#line 45
  tmp___0 = open(file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
  }
#line 45
  return (tmp___1);
}
}
#line 213 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 214
void _obstack_free(struct obstack *h , void *obj ) ;
#line 215
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 218
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 222
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 230
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 329 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 27 "/home/khheo/project/benchmark/grep-3.0/lib/memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ 
  unsigned char const   *char_ptr ;
  void const   *void_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 54
  c1 = (unsigned char )c1_in;
#line 55
  c2 = (unsigned char )c2_in;
#line 57
  if ((int )c1 == (int )c2) {
    {
#line 58
    tmp = memchr(s, (int )c1, n);
    }
#line 58
    return (tmp);
  }
#line 62
  void_ptr = s;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (n > 0UL) {
#line 62
      if (! ((uintptr_t )void_ptr % sizeof(longword ) != 0UL)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 66
    char_ptr = (unsigned char const   *)void_ptr;
#line 67
    if ((int const   )*char_ptr == (int const   )c1) {
#line 68
      return ((void *)void_ptr);
    } else
#line 67
    if ((int const   )*char_ptr == (int const   )c2) {
#line 68
      return ((void *)void_ptr);
    }
#line 69
    void_ptr = (void const   *)(char_ptr + 1);
#line 62
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  longword_ptr = (longword const   *)void_ptr;
#line 81
  repeated_one = (longword )16843009;
#line 82
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 83
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 84
  repeated_c1 |= repeated_c1 << 16;
#line 85
  repeated_c2 |= repeated_c2 << 16;
#line 88
  repeated_one |= (repeated_one << 31) << 1;
#line 89
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 90
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 91
  if (8UL < sizeof(longword )) {
#line 95
    i = (size_t )64;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! (i < sizeof(longword ) * 8UL)) {
#line 95
        goto while_break___0;
      }
#line 97
      repeated_one |= repeated_one << i;
#line 98
      repeated_c1 |= repeated_c1 << i;
#line 99
      repeated_c2 |= repeated_c2 << i;
#line 95
      i *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if (! (n >= sizeof(longword ))) {
#line 140
      goto while_break___1;
    }
#line 142
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 143
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 145
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 148
      goto while_break___1;
    }
#line 149
    longword_ptr ++;
#line 150
    n -= sizeof(longword );
  }
  while_break___1: /* CIL Label */ ;
  }
#line 153
  char_ptr = (unsigned char const   *)longword_ptr;
  {
#line 162
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 162
    if (! (n > 0UL)) {
#line 162
      goto while_break___2;
    }
#line 164
    if ((int const   )*char_ptr == (int const   )c1) {
#line 165
      return ((void *)char_ptr);
    } else
#line 164
    if ((int const   )*char_ptr == (int const   )c2) {
#line 165
      return ((void *)char_ptr);
    }
#line 162
    n --;
#line 162
    char_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 168
  return ((void *)0);
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 390 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 1105 "./string.h"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 66 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-3.0/lib/str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (9223372036854775807UL / sizeof(size_t ) < m) {
#line 42
    tmp___2 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___1 = (void *)((char *)tmp + 16);
      }
    } else {
      {
#line 42
      tmp___0 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___1 = tmp___0;
      }
    }
#line 42
    tmp___2 = tmp___1;
  }
#line 42
  table = (size_t *)tmp___2;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___4 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (9223372036854775807UL / (sizeof(mbchar_t ) + sizeof(size_t )) < m) {
#line 48
    tmp___3 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___0 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 48
      tmp___1 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___2 = tmp___1;
      }
    }
#line 48
    tmp___3 = tmp___2;
  }
#line 48
  memory = tmp___3;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 54
  table = (size_t *)table_memory;
#line 61
  j = (size_t )0;
#line 62
  iter.cur.ptr = needle;
#line 62
  iter.in_shift = (_Bool)0;
#line 62
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 62
  iter.next_done = (_Bool)0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    mbuiter_multi_next(& iter);
    }
#line 62
    if (iter.cur.wc_valid) {
#line 62
      if (iter.cur.wc == 0) {
#line 62
        tmp___4 = 0;
      } else {
#line 62
        tmp___4 = 1;
      }
    } else {
#line 62
      tmp___4 = 1;
    }
#line 62
    if (! tmp___4) {
#line 62
      goto while_break;
    }
    {
#line 63
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 62
    iter.cur.ptr += iter.cur.bytes;
#line 62
    iter.next_done = (_Bool)0;
#line 62
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *(table + 1) = (size_t )1;
#line 86
  j___0 = (size_t )0;
#line 88
  i = (size_t )2;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < m)) {
#line 88
      goto while_break___0;
    }
#line 94
    b = needle_mbchars + (i - 1UL);
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (b->wc_valid) {
#line 101
        if ((needle_mbchars + j___0)->wc_valid) {
#line 101
          tmp___7 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 101
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 101
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 101
          tmp___5 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 101
          if (tmp___5 == 0) {
#line 101
            tmp___6 = 1;
          } else {
#line 101
            tmp___6 = 0;
          }
        } else {
#line 101
          tmp___6 = 0;
        }
#line 101
        tmp___7 = tmp___6;
      }
#line 101
      if (tmp___7) {
#line 104
        j___0 ++;
#line 104
        *(table + i) = i - j___0;
#line 105
        goto while_break___1;
      }
#line 110
      if (j___0 == 0UL) {
#line 113
        *(table + i) = i;
#line 114
        goto while_break___1;
      }
#line 127
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  *resultp = (char const   *)((void *)0);
#line 140
  j___1 = (size_t )0;
#line 141
  rhaystack.cur.ptr = haystack;
#line 141
  rhaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  rhaystack.next_done = (_Bool)0;
#line 142
  phaystack.cur.ptr = haystack;
#line 142
  phaystack.in_shift = (_Bool)0;
#line 142
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 142
  phaystack.next_done = (_Bool)0;
  }
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 144
    mbuiter_multi_next(& phaystack);
    }
#line 144
    if (phaystack.cur.wc_valid) {
#line 144
      if (phaystack.cur.wc == 0) {
#line 144
        tmp___13 = 0;
      } else {
#line 144
        tmp___13 = 1;
      }
    } else {
#line 144
      tmp___13 = 1;
    }
#line 144
    if (! tmp___13) {
#line 144
      goto while_break___2;
    }
#line 145
    if ((needle_mbchars + j___1)->wc_valid) {
#line 145
      if (phaystack.cur.wc_valid) {
#line 145
        tmp___12 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 145
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 145
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 145
        tmp___10 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 145
        if (tmp___10 == 0) {
#line 145
          tmp___11 = 1;
        } else {
#line 145
          tmp___11 = 0;
        }
      } else {
#line 145
        tmp___11 = 0;
      }
#line 145
      tmp___12 = tmp___11;
    }
#line 145
    if (tmp___12) {
#line 147
      j___1 ++;
#line 148
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 148
      phaystack.next_done = (_Bool)0;
#line 149
      if (j___1 == m) {
#line 152
        *resultp = rhaystack.cur.ptr;
#line 153
        goto while_break___2;
      }
    } else
#line 156
    if (j___1 > 0UL) {
#line 159
      count = *(table + j___1);
#line 160
      j___1 -= count;
      {
#line 161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 161
        if (! (count > 0UL)) {
#line 161
          goto while_break___3;
        }
        {
#line 163
        mbuiter_multi_next(& rhaystack);
        }
#line 163
        if (rhaystack.cur.wc_valid) {
#line 163
          if (rhaystack.cur.wc == 0) {
#line 163
            tmp___8 = 0;
          } else {
#line 163
            tmp___8 = 1;
          }
        } else {
#line 163
          tmp___8 = 1;
        }
#line 163
        if (! tmp___8) {
          {
#line 164
          abort();
          }
        }
#line 165
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 165
        rhaystack.next_done = (_Bool)0;
#line 161
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 171
      mbuiter_multi_next(& rhaystack);
      }
#line 171
      if (rhaystack.cur.wc_valid) {
#line 171
        if (rhaystack.cur.wc == 0) {
#line 171
          tmp___9 = 0;
        } else {
#line 171
          tmp___9 = 1;
        }
      } else {
#line 171
        tmp___9 = 1;
      }
#line 171
      if (! tmp___9) {
        {
#line 172
        abort();
        }
      }
#line 173
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 173
      rhaystack.next_done = (_Bool)0;
#line 174
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 174
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 178
  freea(memory);
  }
#line 179
  return ((_Bool)1);
}
}
#line 184
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle )  __attribute__((__pure__)) ;
#line 184 "/home/khheo/project/benchmark/grep-3.0/lib/mbsstr.c"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
  {
#line 192
  tmp___17 = __ctype_get_mb_cur_max();
  }
#line 192
  if (tmp___17 > 1UL) {
    {
#line 196
    iter_needle.cur.ptr = needle;
#line 196
    iter_needle.in_shift = (_Bool)0;
#line 196
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 196
    iter_needle.next_done = (_Bool)0;
#line 197
    mbuiter_multi_next(& iter_needle);
    }
#line 197
    if (iter_needle.cur.wc_valid) {
#line 197
      if (iter_needle.cur.wc == 0) {
#line 197
        tmp___12 = 0;
      } else {
#line 197
        tmp___12 = 1;
      }
    } else {
#line 197
      tmp___12 = 1;
    }
#line 197
    if (tmp___12) {
      {
#line 213
      try_kmp = (_Bool)1;
#line 214
      outer_loop_count = (size_t )0;
#line 215
      comparison_count = (size_t )0;
#line 216
      last_ccount = (size_t )0;
#line 221
      iter_needle_last_ccount.cur.ptr = needle;
#line 221
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 221
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 221
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 222
      iter_haystack.cur.ptr = haystack;
#line 222
      iter_haystack.in_shift = (_Bool)0;
#line 222
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 222
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 223
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 225
        mbuiter_multi_next(& iter_haystack);
        }
#line 225
        if (iter_haystack.cur.wc_valid) {
#line 225
          if (iter_haystack.cur.wc == 0) {
#line 225
            tmp = 0;
          } else {
#line 225
            tmp = 1;
          }
        } else {
#line 225
          tmp = 1;
        }
#line 225
        if (! tmp) {
#line 227
          return ((char *)((void *)0));
        }
#line 231
        if (try_kmp) {
#line 231
          if (outer_loop_count >= 10UL) {
#line 231
            if (comparison_count >= 5UL * outer_loop_count) {
#line 237
              count = comparison_count - last_ccount;
              {
#line 238
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 238
                if (count > 0UL) {
                  {
#line 238
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 238
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 238
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 238
                      tmp___0 = 0;
                    } else {
#line 238
                      tmp___0 = 1;
                    }
                  } else {
#line 238
                    tmp___0 = 1;
                  }
#line 238
                  if (! tmp___0) {
#line 238
                    goto while_break___0;
                  }
                } else {
#line 238
                  goto while_break___0;
                }
#line 241
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 241
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 238
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 242
              last_ccount = comparison_count;
#line 243
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 243
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 243
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 243
                  tmp___2 = 0;
                } else {
#line 243
                  tmp___2 = 1;
                }
              } else {
#line 243
                tmp___2 = 1;
              }
#line 243
              if (! tmp___2) {
                {
#line 247
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 247
                success = tmp___1;
                }
#line 250
                if (success) {
#line 251
                  return ((char *)result);
                }
#line 252
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 256
        outer_loop_count ++;
#line 257
        comparison_count ++;
#line 258
        if (iter_haystack.cur.wc_valid) {
#line 258
          if (iter_needle.cur.wc_valid) {
#line 258
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 258
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 258
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 258
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 258
            if (tmp___9 == 0) {
#line 258
              tmp___10 = 1;
            } else {
#line 258
              tmp___10 = 0;
            }
          } else {
#line 258
            tmp___10 = 0;
          }
#line 258
          tmp___11 = tmp___10;
        }
#line 258
        if (tmp___11) {
          {
#line 264
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 265
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 265
          rhaystack.next_done = (_Bool)0;
#line 267
          rneedle.cur.ptr = needle;
#line 267
          rneedle.in_shift = (_Bool)0;
#line 267
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 267
          rneedle.next_done = (_Bool)0;
#line 268
          mbuiter_multi_next(& rneedle);
          }
#line 268
          if (rneedle.cur.wc_valid) {
#line 268
            if (rneedle.cur.wc == 0) {
#line 268
              tmp___3 = 0;
            } else {
#line 268
              tmp___3 = 1;
            }
          } else {
#line 268
            tmp___3 = 1;
          }
#line 268
          if (! tmp___3) {
            {
#line 269
            abort();
            }
          }
#line 270
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 270
          rneedle.next_done = (_Bool)0;
          {
#line 272
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 274
            mbuiter_multi_next(& rneedle);
            }
#line 274
            if (rneedle.cur.wc_valid) {
#line 274
              if (rneedle.cur.wc == 0) {
#line 274
                tmp___4 = 0;
              } else {
#line 274
                tmp___4 = 1;
              }
            } else {
#line 274
              tmp___4 = 1;
            }
#line 274
            if (! tmp___4) {
#line 276
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 277
            mbuiter_multi_next(& rhaystack);
            }
#line 277
            if (rhaystack.cur.wc_valid) {
#line 277
              if (rhaystack.cur.wc == 0) {
#line 277
                tmp___5 = 0;
              } else {
#line 277
                tmp___5 = 1;
              }
            } else {
#line 277
              tmp___5 = 1;
            }
#line 277
            if (! tmp___5) {
#line 279
              return ((char *)((void *)0));
            }
#line 280
            comparison_count ++;
#line 281
            if (rhaystack.cur.wc_valid) {
#line 281
              if (rneedle.cur.wc_valid) {
#line 281
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 281
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 281
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 281
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 281
                if (tmp___6 == 0) {
#line 281
                  tmp___7 = 1;
                } else {
#line 281
                  tmp___7 = 0;
                }
              } else {
#line 281
                tmp___7 = 0;
              }
#line 281
              tmp___8 = tmp___7;
            }
#line 281
            if (! tmp___8) {
#line 283
              goto while_break___1;
            }
#line 272
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 272
            rhaystack.next_done = (_Bool)0;
#line 272
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 272
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 223
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 223
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 289
      return ((char *)haystack);
    }
  } else
#line 293
  if ((int const   )*needle != 0) {
#line 309
    try_kmp___0 = (_Bool)1;
#line 310
    outer_loop_count___0 = (size_t )0;
#line 311
    comparison_count___0 = (size_t )0;
#line 312
    last_ccount___0 = (size_t )0;
#line 313
    needle_last_ccount = needle;
#line 317
    tmp___13 = needle;
#line 317
    needle ++;
#line 317
    b = (char )*tmp___13;
    {
#line 319
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 321
      if ((int const   )*haystack == 0) {
#line 323
        return ((char *)((void *)0));
      }
#line 327
      if (try_kmp___0) {
#line 327
        if (outer_loop_count___0 >= 10UL) {
#line 327
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 333
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 335
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 335
              needle_last_ccount += tmp___14;
              }
#line 338
              if ((int const   )*needle_last_ccount == 0) {
#line 339
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 340
              last_ccount___0 = comparison_count___0;
            }
#line 342
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 346
              tmp___15 = strlen(needle - 1);
#line 346
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 346
              success___0 = tmp___16;
              }
#line 351
              if (success___0) {
#line 352
                return ((char *)result___0);
              }
#line 353
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 357
      outer_loop_count___0 ++;
#line 358
      comparison_count___0 ++;
#line 359
      if ((int const   )*haystack == (int const   )b) {
#line 362
        rhaystack___0 = haystack + 1;
#line 363
        rneedle___0 = needle;
        {
#line 365
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 367
          if ((int const   )*rneedle___0 == 0) {
#line 369
            return ((char *)haystack);
          }
#line 370
          if ((int const   )*rhaystack___0 == 0) {
#line 372
            return ((char *)((void *)0));
          }
#line 373
          comparison_count___0 ++;
#line 374
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 376
            goto while_break___3;
          }
#line 365
          rhaystack___0 ++;
#line 365
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 319
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 382
    return ((char *)haystack);
  }
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 1182 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 23 "/home/khheo/project/benchmark/grep-3.0/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 333 "/home/khheo/project/benchmark/grep-3.0/lib/mbrtowc.c"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t ret ;
  wchar_t wc ;
  unsigned char uc ;
  _Bool tmp ;

  {
#line 353
  if (! pwc) {
#line 354
    pwc = & wc;
  }
  {
#line 388
  ret = mbrtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s,
                n, (mbstate_t */* __restrict  */)ps);
  }
#line 396
  if (0xfffffffffffffffeUL <= ret) {
#line 396
    if (n != 0UL) {
      {
#line 396
      tmp = hard_locale(0);
      }
#line 396
      if (! tmp) {
#line 398
        uc = (unsigned char )*s;
#line 399
        *pwc = (wchar_t )uc;
#line 400
        return ((size_t )1);
      }
    }
  }
#line 404
  return (ret);
}
}
#line 616 "./wchar.h"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) ;
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/mbrlen.c"
static mbstate_t internal_state  ;
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/mbrlen.c"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t tmp ;

  {
#line 29
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 30
    ps = & internal_state;
  }
  {
#line 31
  tmp = rpl_mbrtowc((wchar_t *)((void *)0), s, n, ps);
  }
#line 31
  return (tmp);
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 69 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 750 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 807
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 811
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 834
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                                int __kind ) ;
#line 889
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                          pthread_rwlockattr_t const   * __restrict  __attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr ) ;
#line 960
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                                                    int __pref ) ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 142
#pragma weak pthread_rwlockattr_init
#line 143
#pragma weak pthread_rwlockattr_setkind_np
#line 144
#pragma weak pthread_rwlockattr_destroy
#line 146
#pragma weak pthread_self
#line 150
#pragma weak pthread_cancel
#line 201
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) ;
#line 306
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 380
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 40 "/home/khheo/project/benchmark/grep-3.0/lib/glthread/lock.c"
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) 
{ 
  pthread_rwlockattr_t attributes ;
  int err ;

  {
  {
#line 46
  err = pthread_rwlockattr_init(& attributes);
  }
#line 47
  if (err != 0) {
#line 48
    return (err);
  }
  {
#line 53
  err = pthread_rwlockattr_setkind_np(& attributes, 2);
  }
#line 55
  if (err == 0) {
    {
#line 56
    err = pthread_rwlock_init((pthread_rwlock_t */* __restrict  */)lock, (pthread_rwlockattr_t const   */* __restrict  */)(& attributes));
    }
  }
  {
#line 59
  pthread_rwlockattr_destroy(& attributes);
  }
#line 60
  return (err);
}
}
#line 310 "/home/khheo/project/benchmark/grep-3.0/lib/glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ 
  pthread_mutexattr_t attributes ;
  int err ;

  {
  {
#line 316
  err = pthread_mutexattr_init(& attributes);
  }
#line 317
  if (err != 0) {
#line 318
    return (err);
  }
  {
#line 319
  err = pthread_mutexattr_settype(& attributes, 1);
  }
#line 320
  if (err != 0) {
    {
#line 322
    pthread_mutexattr_destroy(& attributes);
    }
#line 323
    return (err);
  }
  {
#line 325
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  }
#line 326
  if (err != 0) {
    {
#line 328
    pthread_mutexattr_destroy(& attributes);
    }
#line 329
    return (err);
  }
  {
#line 331
  err = pthread_mutexattr_destroy(& attributes);
  }
#line 332
  if (err != 0) {
#line 333
    return (err);
  }
#line 334
  return (0);
}
}
#line 481 "/home/khheo/project/benchmark/grep-3.0/lib/glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 483 "/home/khheo/project/benchmark/grep-3.0/lib/glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ 
  char *firstbyte ;

  {
#line 488
  firstbyte = (char *)once_control;
#line 489
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 492
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 493
    return (1);
  } else {
#line 496
    return (0);
  }
}
}
#line 47 "./localeinfo.h"
void init_localeinfo(struct localeinfo *localeinfo___0 ) ;
#line 54
int case_folded_counterparts(wint_t c , wchar_t *folded ) ;
#line 169 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
static _Bool is_using_utf8(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
void init_localeinfo(struct localeinfo *localeinfo___0 ) 
{ 
  int i ;
  size_t tmp ;
  char c ;
  unsigned char uc ;
  mbstate_t s ;
  wchar_t wc ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 54
  tmp = __ctype_get_mb_cur_max();
#line 54
  localeinfo___0->multibyte = (_Bool )(tmp > 1UL);
#line 55
  localeinfo___0->using_utf8 = is_using_utf8();
#line 57
  i = -128;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= 127)) {
#line 57
      goto while_break;
    }
    {
#line 59
    c = (char )i;
#line 60
    uc = (unsigned char )i;
#line 61
    s.__count = 0;
#line 61
    s.__value.__wch = 0U;
#line 63
    tmp___0 = rpl_mbrtowc(& wc, (char const   *)(& c), (size_t )1, & s);
#line 63
    len = tmp___0;
    }
#line 64
    if (len <= 1UL) {
#line 64
      localeinfo___0->sbclen[uc] = (signed char)1;
    } else {
#line 64
      localeinfo___0->sbclen[uc] = (signed char )(- ((int )(- len)));
    }
#line 65
    if (len <= 1UL) {
#line 65
      localeinfo___0->sbctowc[uc] = (wint_t )wc;
    } else {
#line 65
      localeinfo___0->sbctowc[uc] = 4294967295U;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
static short const   lonesome_lower[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 95 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
int case_folded_counterparts(wint_t c , wchar_t *folded ) 
{ 
  int i ;
  int n ;
  wint_t uc ;
  wint_t tmp ;
  wint_t lc ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  wint_t tmp___3 ;
  wint_t li ;
  int tmp___4 ;
  wint_t tmp___5 ;

  {
  {
#line 99
  n = 0;
#line 100
  tmp = towupper(c);
#line 100
  uc = tmp;
#line 101
  tmp___0 = towlower(uc);
#line 101
  lc = tmp___0;
  }
#line 102
  if (uc != c) {
#line 103
    tmp___1 = n;
#line 103
    n ++;
#line 103
    *(folded + tmp___1) = (wchar_t )uc;
  }
#line 104
  if (lc != uc) {
#line 104
    if (lc != c) {
      {
#line 104
      tmp___3 = towupper(lc);
      }
#line 104
      if (tmp___3 == uc) {
#line 105
        tmp___2 = n;
#line 105
        n ++;
#line 105
        *(folded + tmp___2) = (wchar_t )lc;
      }
    }
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )i < sizeof(lonesome_lower) / sizeof(lonesome_lower[0]))) {
#line 106
      goto while_break;
    }
#line 108
    li = (wint_t )lonesome_lower[i];
#line 109
    if (li != lc) {
#line 109
      if (li != uc) {
#line 109
        if (li != c) {
          {
#line 109
          tmp___5 = towupper(li);
          }
#line 109
          if (tmp___5 == uc) {
#line 110
            tmp___4 = n;
#line 110
            n ++;
#line 110
            *(folded + tmp___4) = (wchar_t )li;
          }
        }
      }
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (n);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 120 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 123 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 128
  cp = (char const   *)charset_aliases;
#line 129
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    base = "charset.alias";
#line 138
    tmp = getenv("CHARSETALIASDIR");
#line 138
    dir = (char const   *)tmp;
    }
#line 139
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 140
      dir = "/usr/local/lib";
    } else
#line 139
    if ((int const   )*(dir + 0) == 0) {
#line 140
      dir = "/usr/local/lib";
    }
    {
#line 144
    tmp___0 = strlen(dir);
#line 144
    dir_len___0 = tmp___0;
#line 145
    tmp___1 = strlen(base);
#line 145
    base_len___0 = tmp___1;
    }
#line 146
    if (dir_len___0 > 0UL) {
#line 146
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 146
        tmp___2 = 1;
      } else {
#line 146
        tmp___2 = 0;
      }
    } else {
#line 146
      tmp___2 = 0;
    }
    {
#line 146
    add_slash = tmp___2;
#line 147
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 147
    file_name___1 = (char *)tmp___3;
    }
#line 148
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 150
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 151
      if (add_slash) {
#line 152
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 153
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 157
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 159
      cp = "";
    } else {
      {
#line 171
      fd = open((char const   *)file_name___1, 131072);
      }
#line 173
      if (fd < 0) {
#line 175
        cp = "";
      } else {
        {
#line 180
        fp = fdopen(fd, "r");
        }
#line 181
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 184
          close(fd);
#line 185
          cp = "";
          }
        } else {
#line 190
          res_ptr = (char *)((void *)0);
#line 191
          res_size = (size_t )0;
          {
#line 193
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 201
            c = getc_unlocked(fp);
            }
#line 202
            if (c == -1) {
#line 203
              goto while_break;
            }
#line 204
            if (c == 10) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 32) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 9) {
#line 205
              goto __Cont;
            }
#line 206
            if (c == 35) {
              {
#line 209
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 210
                c = getc_unlocked(fp);
                }
#line 209
                if (c == -1) {
#line 209
                  goto while_break___0;
                } else
#line 209
                if (c == 10) {
#line 209
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 212
              if (c == -1) {
#line 213
                goto while_break;
              }
#line 214
              goto __Cont;
            }
            {
#line 216
            ungetc(c, fp);
#line 217
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 217
            if (tmp___4 < 2) {
#line 218
              goto while_break;
            }
            {
#line 219
            l1 = strlen((char const   *)(buf1));
#line 220
            l2 = strlen((char const   *)(buf2));
#line 221
            old_res_ptr = res_ptr;
            }
#line 222
            if (res_size == 0UL) {
              {
#line 224
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 225
              tmp___5 = malloc(res_size + 1UL);
#line 225
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 229
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 230
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 230
              res_ptr = (char *)tmp___6;
              }
            }
#line 232
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 235
              res_size = (size_t )0;
#line 236
              free((void *)old_res_ptr);
              }
#line 237
              goto while_break;
            }
            {
#line 239
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 240
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 242
          fclose(fp);
          }
#line 243
          if (res_size == 0UL) {
#line 244
            cp = "";
          } else {
#line 247
            *(res_ptr + res_size) = (char )'\000';
#line 248
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 253
      free((void *)file_name___1);
      }
    }
#line 377
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 380
  return (cp);
}
}
#line 392 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 403
  tmp = nl_langinfo(14);
#line 403
  codeset = (char const   *)tmp;
  }
#line 584
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 586
    codeset = "";
  }
  {
#line 589
  aliases = get_charset_aliases();
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! ((int const   )*aliases != 0)) {
#line 589
      goto while_break;
    }
    {
#line 592
    tmp___3 = strcmp(codeset, aliases);
    }
#line 592
    if (tmp___3 == 0) {
      {
#line 595
      tmp___2 = strlen(aliases);
#line 595
      codeset = (aliases + tmp___2) + 1;
      }
#line 596
      goto while_break;
    } else
#line 592
    if ((int const   )*(aliases + 0) == 42) {
#line 592
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 595
        tmp___2 = strlen(aliases);
#line 595
        codeset = (aliases + tmp___2) + 1;
        }
#line 596
        goto while_break;
      }
    }
    {
#line 589
    tmp___0 = strlen(aliases);
#line 589
    aliases += tmp___0 + 1UL;
#line 589
    tmp___1 = strlen(aliases);
#line 589
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if ((int const   )*(codeset + 0) == 0) {
#line 603
    codeset = "ASCII";
  }
#line 612
  return (codeset);
}
}
#line 41 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ 
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 4)) {
#line 31
      goto while_break;
    }
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36
_Bool i_ring_empty(I_ring const   *ir )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ 
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/khheo/project/benchmark/grep-3.0/lib/i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ 
  int top_val ;
  _Bool tmp ;

  {
  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
  }
#line 59
  if (tmp) {
    {
#line 60
    abort();
    }
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.0/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 99
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 101
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n ) 
{ 


  {
#line 41
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n ) 
{ 


  {
#line 50
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n ) 
{ 


  {
#line 60
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 66 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n ) 
{ 


  {
#line 69
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 75 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n ) 
{ 


  {
#line 78
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 84 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 87
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 95 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n ) 
{ 


  {
#line 98
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 106 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n ) 
{ 


  {
#line 109
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 117 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n ) 
{ 


  {
#line 120
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 128 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n ) 
{ 


  {
#line 131
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer___0 , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer___0 + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 430
  value = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (9223372036854775807UL / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete___1 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___1) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___1) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1125 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1129
  tmp = hash_insert_if_absent(table, entry, & matched_ent);
#line 1129
  err = tmp;
  }
#line 1130
  if (err == -1) {
#line 1130
    tmp___1 = (void *)0;
  } else {
#line 1130
    if (err == 0) {
#line 1130
      tmp___0 = matched_ent;
    } else {
#line 1130
      tmp___0 = entry;
    }
#line 1130
    tmp___1 = (void *)tmp___0;
  }
#line 1130
  return (tmp___1);
}
}
#line 1139 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1145
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1146
  if (! data) {
#line 1147
    return ((void *)0);
  }
#line 1149
  (table->n_entries) --;
#line 1150
  if (! bucket->data) {
#line 1152
    (table->n_buckets_used) --;
#line 1157
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1162
      check_tuning(table);
      }
#line 1163
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1166
        tuning = table->tuning;
#line 1167
        if (tuning->is_n_buckets) {
#line 1167
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1167
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1167
        candidate = (size_t )tmp;
#line 1173
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1173
        if (! tmp___0) {
#line 1181
          cursor = table->free_entry_list;
          {
#line 1183
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1183
            if (! cursor) {
#line 1183
              goto while_break;
            }
            {
#line 1185
            next = cursor->next;
#line 1186
            free((void *)cursor);
#line 1187
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1189
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1196
  return (data);
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 37 "/home/khheo/project/benchmark/grep-3.0/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
  }
#line 43
  if (p) {
#line 45
    if (1) {
      {
#line 47
      tmp___0 = strcmp(p, "C");
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
        {
#line 47
        tmp___1 = strcmp(p, "POSIX");
        }
#line 47
        if (tmp___1 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 52
      tmp___2 = strdup(p);
#line 52
      locale = tmp___2;
      }
#line 53
      if (locale) {
        {
#line 58
        tmp___3 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___3;
        }
#line 58
        if (p) {
          {
#line 58
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 58
          if (tmp___4 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 58
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 58
          tmp___5 = setlocale(category, "POSIX");
#line 58
          p = (char const   *)tmp___5;
          }
#line 58
          if (p) {
            {
#line 58
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 58
            if (tmp___6 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
        {
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
        }
      }
    }
  }
#line 71
  return (hard);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/getprogname.h"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 46 "/usr/include/errno.h"
extern char *program_invocation_short_name ;
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/getprogname.c"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/getprogname.c"
char const   *getprogname(void) 
{ 


  {
#line 62
  return ((char const   *)program_invocation_short_name);
}
}
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 273 "/home/khheo/project/benchmark/grep-3.0/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 274
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 275
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 278
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 279
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 206 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 207
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 208
static void fts_lfree(FTSENT *head ) ;
#line 209
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 210
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) ;
#line 211
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 212
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 213
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 214
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 215
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 271 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 274
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 274
    if (tmp___0) {
#line 274
      goto while_break;
    }
    {
#line 276
    tmp = i_ring_pop(fd_ring);
#line 276
    fd = tmp;
    }
#line 277
    if (0 <= fd) {
      {
#line 278
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 285 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((int )p->fts_info == 11)) {
      {
#line 288
      abort();
      }
    }
#line 288
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (required) {
#line 289
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 289
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 292
  return;
}
}
#line 296 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 300
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 300
  new_fd = tmp;
  }
#line 305
  if (new_fd < 0) {
#line 306
    return ((DIR *)((void *)0));
  }
  {
#line 307
  set_cloexec_flag(new_fd, (_Bool)1);
#line 308
  dirp = fdopendir(new_fd);
  }
#line 309
  if (dirp) {
#line 310
    *pdir_fd = new_fd;
  } else {
    {
#line 313
    tmp___0 = __errno_location();
#line 313
    saved_errno = *tmp___0;
#line 314
    close(new_fd);
#line 315
    tmp___1 = __errno_location();
#line 315
    *tmp___1 = saved_errno;
    }
  }
#line 317
  return (dirp);
}
}
#line 325 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 329
  old = sp->fts_cwd_fd;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (old != fd)) {
#line 330
      if (! (old == -100)) {
        {
#line 330
        abort();
        }
      }
    }
#line 330
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  if (chdir_down_one) {
    {
#line 336
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 336
    prev_fd_in_slot = tmp;
    }
#line 338
    if (0 <= prev_fd_in_slot) {
      {
#line 339
      close(prev_fd_in_slot);
      }
    }
  } else
#line 341
  if (! (sp->fts_options & 4)) {
#line 343
    if (0 <= old) {
      {
#line 344
      close(old);
      }
    }
  }
#line 347
  sp->fts_cwd_fd = fd;
#line 348
  return;
}
}
#line 354 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int restore_initial_cwd(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 357
  if (! (sp->fts_options & 4)) {
#line 357
    if (sp->fts_options & 512) {
#line 357
      if (sp->fts_options & 512) {
#line 357
        tmp = -100;
      } else {
#line 357
        tmp = sp->fts_rfd;
      }
      {
#line 357
      cwd_advance_fd(sp, tmp, (_Bool)1);
#line 357
      tmp___2 = 0;
      }
    } else {
#line 357
      if (sp->fts_options & 512) {
#line 357
        tmp___0 = -100;
      } else {
#line 357
        tmp___0 = sp->fts_rfd;
      }
      {
#line 357
      tmp___1 = fchdir(tmp___0);
#line 357
      tmp___2 = tmp___1;
      }
    }
#line 357
    if (tmp___2) {
#line 357
      tmp___3 = 1;
    } else {
#line 357
      tmp___3 = 0;
    }
  } else {
#line 357
    tmp___3 = 0;
  }
  {
#line 357
  fail = tmp___3;
#line 358
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 359
  return (fail);
}
}
#line 366 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int diropen(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 370
  if (sp->fts_options & 16) {
#line 370
    tmp = 131072;
  } else {
#line 370
    tmp = 0;
  }
#line 370
  if (sp->fts_options & 2048) {
#line 370
    tmp___0 = 262144;
  } else {
#line 370
    tmp___0 = 0;
  }
#line 370
  open_flags = (67840 | tmp) | tmp___0;
#line 374
  if (sp->fts_options & 512) {
    {
#line 374
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 374
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 374
    tmp___2 = open_safer(dir, open_flags);
#line 374
    tmp___3 = tmp___2;
    }
  }
#line 374
  fd = tmp___3;
#line 377
  if (0 <= fd) {
    {
#line 378
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 379
  return (fd);
}
}
#line 382
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 382 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                   int options , int (*compar)(FTSENT const   ** ,
                                                                                               FTSENT const   ** ) ) 
{ 
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  char const   *v ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
#line 390
  parent = (FTSENT *)((void *)0);
#line 391
  tmp = (FTSENT *)((void *)0);
#line 395
  if (options & -8192) {
    {
#line 396
    tmp___0 = __errno_location();
#line 396
    *tmp___0 = 22;
    }
#line 397
    return ((FTS *)((void *)0));
  }
#line 399
  if (options & 4) {
#line 399
    if (options & 512) {
      {
#line 400
      tmp___1 = __errno_location();
#line 400
      *tmp___1 = 22;
      }
#line 401
      return ((FTS *)((void *)0));
    }
  }
#line 403
  if (! (options & 18)) {
    {
#line 404
    tmp___2 = __errno_location();
#line 404
    *tmp___2 = 22;
    }
#line 405
    return ((FTS *)((void *)0));
  }
  {
#line 409
  tmp___3 = malloc(sizeof(FTS ));
#line 409
  sp = (FTS *)tmp___3;
  }
#line 409
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 410
    return ((FTS *)((void *)0));
  }
  {
#line 411
  memset((void *)sp, 0, sizeof(FTS ));
#line 412
  sp->fts_compar = compar;
#line 413
  sp->fts_options = options;
  }
#line 416
  if (sp->fts_options & 2) {
#line 417
    sp->fts_options |= 4;
#line 418
    sp->fts_options &= -513;
  }
#line 422
  sp->fts_cwd_fd = -100;
#line 423
  if (sp->fts_options & 512) {

  }
  {
#line 464
  tmp___6 = (size_t )fts_maxarglen(argv);
#line 464
  maxarglen = tmp___6;
  }
#line 465
  if (maxarglen > 4096UL) {
#line 465
    tmp___7 = maxarglen;
  } else {
#line 465
    tmp___7 = (size_t )4096;
  }
  {
#line 465
  tmp___8 = fts_palloc(sp, tmp___7);
  }
#line 465
  if (! tmp___8) {
#line 466
    goto mem1;
  }
#line 470
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
#line 471
    parent = fts_alloc(sp, "", (size_t )0);
    }
#line 471
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 472
      goto mem2;
    }
#line 473
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 487
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 487
    tmp___9 = 1;
  } else
#line 487
  if (sp->fts_options & 1024) {
#line 487
    tmp___9 = 1;
  } else {
#line 487
    tmp___9 = 0;
  }
#line 487
  defer_stat = (_Bool )tmp___9;
#line 490
  root = (FTSENT *)((void *)0);
#line 490
  nitems = (size_t )0;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 490
      goto while_break;
    }
    {
#line 492
    tmp___10 = strlen((char const   *)*argv);
#line 492
    len = tmp___10;
    }
#line 494
    if (! (options & 4096)) {
#line 498
      v = (char const   *)*argv;
#line 499
      if (2UL < len) {
#line 499
        if ((int const   )*(v + (len - 1UL)) == 47) {
          {
#line 500
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 500
            if (1UL < len) {
#line 500
              if (! ((int const   )*(v + (len - 2UL)) == 47)) {
#line 500
                goto while_break___0;
              }
            } else {
#line 500
              goto while_break___0;
            }
#line 501
            len --;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 504
    p = fts_alloc(sp, (char const   *)*argv, len);
    }
#line 504
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 505
      goto mem3;
    }
#line 506
    p->fts_level = (ptrdiff_t )0;
#line 507
    p->fts_parent = parent;
#line 508
    p->fts_accpath = p->fts_name;
#line 512
    if (defer_stat) {
#line 512
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
#line 513
        p->fts_info = (unsigned short)11;
#line 514
        fts_set_stat_required(p, (_Bool)1);
        }
      } else {
        {
#line 516
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
      }
    } else {
      {
#line 516
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    }
#line 523
    if (compar) {
#line 524
      p->fts_link = root;
#line 525
      root = p;
    } else {
#line 527
      p->fts_link = (struct _ftsent *)((void *)0);
#line 528
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 529
        root = p;
#line 529
        tmp = root;
      } else {
#line 531
        tmp->fts_link = p;
#line 532
        tmp = p;
      }
    }
#line 490
    argv ++;
#line 490
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (compar) {
#line 536
    if (nitems > 1UL) {
      {
#line 537
      root = fts_sort(sp, root, nitems);
      }
    }
  }
  {
#line 544
  tmp___11 = fts_alloc(sp, "", (size_t )0);
#line 544
  sp->fts_cur = tmp___11;
  }
#line 544
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 545
    goto mem3;
  }
  {
#line 546
  (sp->fts_cur)->fts_link = root;
#line 547
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 548
  tmp___12 = setup_dir(sp);
  }
#line 548
  if (! tmp___12) {
#line 549
    goto mem3;
  }
#line 558
  if (! (sp->fts_options & 4)) {
#line 558
    if (! (sp->fts_options & 512)) {
      {
#line 558
      tmp___13 = diropen((FTS const   *)sp, ".");
#line 558
      sp->fts_rfd = tmp___13;
      }
#line 558
      if (tmp___13 < 0) {
#line 560
        sp->fts_options |= 4;
      }
    }
  }
  {
#line 562
  i_ring_init(& sp->fts_fd_ring, -1);
  }
#line 563
  return (sp);
  mem3: 
  {
#line 565
  fts_lfree(root);
#line 566
  free((void *)parent);
  }
  mem2: 
  {
#line 567
  free((void *)sp->fts_path);
  }
  mem1: 
  {
#line 568
  free((void *)sp);
  }
#line 569
  return ((FTS *)((void *)0));
}
}
#line 572 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 586
  tmp = p->fts_namelen;
#line 586
  p->fts_pathlen = tmp;
#line 586
  len = tmp;
#line 587
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 588
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 588
  if (cp) {
#line 588
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 589
      cp ++;
#line 589
      len = strlen((char const   *)cp);
#line 590
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 591
      p->fts_namelen = len;
      }
    } else
#line 588
    if (*(cp + 1)) {
      {
#line 589
      cp ++;
#line 589
      len = strlen((char const   *)cp);
#line 590
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 591
      p->fts_namelen = len;
      }
    }
  }
#line 593
  tmp___0 = sp->fts_path;
#line 593
  p->fts_path = tmp___0;
#line 593
  p->fts_accpath = tmp___0;
#line 594
  return;
}
}
#line 596
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 596 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) 
{ 
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 600
  saved_errno = 0;
#line 607
  if (sp->fts_cur) {
#line 608
    p = sp->fts_cur;
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 608
      if (! (p->fts_level >= 0L)) {
#line 608
        goto while_break;
      }
#line 609
      freep = p;
#line 610
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 610
        p = p->fts_link;
      } else {
#line 610
        p = p->fts_parent;
      }
      {
#line 611
      free((void *)freep);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 613
    free((void *)p);
    }
  }
#line 617
  if (sp->fts_child) {
    {
#line 618
    fts_lfree(sp->fts_child);
    }
  }
  {
#line 619
  free((void *)sp->fts_array);
#line 620
  free((void *)sp->fts_path);
  }
#line 622
  if (sp->fts_options & 512) {
#line 624
    if (0 <= sp->fts_cwd_fd) {
      {
#line 625
      tmp___0 = close(sp->fts_cwd_fd);
      }
#line 625
      if (tmp___0) {
        {
#line 626
        tmp = __errno_location();
#line 626
        saved_errno = *tmp;
        }
      }
    }
  } else
#line 628
  if (! (sp->fts_options & 4)) {
    {
#line 631
    tmp___2 = fchdir(sp->fts_rfd);
    }
#line 631
    if (tmp___2) {
      {
#line 632
      tmp___1 = __errno_location();
#line 632
      saved_errno = *tmp___1;
      }
    }
    {
#line 636
    tmp___4 = close(sp->fts_rfd);
    }
#line 636
    if (tmp___4) {
#line 637
      if (saved_errno == 0) {
        {
#line 638
        tmp___3 = __errno_location();
#line 638
        saved_errno = *tmp___3;
        }
      }
    }
  }
  {
#line 641
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 643
  if (sp->fts_leaf_optimization_works_ht) {
    {
#line 644
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
  }
  {
#line 646
  free_dir(sp);
#line 649
  free((void *)sp);
  }
#line 652
  if (saved_errno) {
    {
#line 653
    tmp___5 = __errno_location();
#line 653
    *tmp___5 = saved_errno;
    }
#line 654
    return (-1);
  }
#line 657
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 676 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 687
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 687
  if (tmp != 0) {
#line 688
    return ((_Bool)1);
  }
  {
#line 695
  if (fs_buf.f_type == 26985L) {
#line 695
    goto case_26985;
  }
#line 695
  if (fs_buf.f_type == 16914836L) {
#line 695
    goto case_26985;
  }
#line 700
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 698
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 701
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 708 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 714
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 714
  if (tmp != 0) {
#line 715
    return ((_Bool)0);
  }
  {
#line 725
  if (fs_buf.f_type == 1481003842L) {
#line 725
    goto case_1481003842;
  }
#line 725
  if (fs_buf.f_type == 1382369651L) {
#line 725
    goto case_1481003842;
  }
#line 740
  goto switch_default;
  case_1481003842: /* CIL Label */ 
  case_1382369651: /* CIL Label */ 
#line 726
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 741
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 765 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 768
  ax = (struct LCO_ent  const  *)x;
#line 769
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 772 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 775
  ax = (struct LCO_ent  const  *)x;
#line 776
  ay = (struct LCO_ent  const  *)y;
#line 777
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 783 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 786
  sp = (FTS *)p->fts_fts;
#line 787
  h = sp->fts_leaf_optimization_works_ht;
#line 795
  if (! (sp->fts_options & 512)) {
#line 796
    return ((_Bool)0);
  }
#line 799
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 801
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 801
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 801
    h = tmp___0;
    }
#line 804
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 805
      return ((_Bool)0);
    }
  }
  {
#line 807
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 808
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 808
  ent = (struct LCO_ent *)tmp___1;
  }
#line 809
  if (ent) {
#line 810
    return (ent->opt_ok);
  }
  {
#line 813
  tmp___2 = malloc(sizeof(*t2));
#line 813
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 814
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 815
    return ((_Bool)0);
  }
  {
#line 818
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 819
  t2->opt_ok = opt_ok;
#line 820
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 822
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 822
  ent = (struct LCO_ent *)tmp___3;
  }
#line 823
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 826
    free((void *)t2);
    }
#line 827
    return ((_Bool)0);
  }
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 829
      abort();
      }
    }
#line 829
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  return (opt_ok);
}
}
#line 842
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 842 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) 
{ 
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  FTSENT *parent ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  _Bool tmp___12 ;
  int *tmp___13 ;
  struct _ftsent *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  FTSENT *tmp___22 ;

  {
#line 850
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 851
    return ((FTSENT *)((void *)0));
  } else
#line 850
  if (sp->fts_options & 16384) {
#line 851
    return ((FTSENT *)((void *)0));
  }
#line 854
  p = sp->fts_cur;
#line 857
  instr = p->fts_instr;
#line 858
  p->fts_instr = (unsigned short)3;
#line 861
  if ((int )instr == 1) {
    {
#line 862
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 863
    return (p);
  }
#line 874
  if ((int )instr == 2) {
#line 874
    if ((int )p->fts_info == 12) {
#line 874
      goto _L;
    } else
#line 874
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */ 
      {
#line 876
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 877
      if ((int )p->fts_info == 1) {
#line 877
        if (! (sp->fts_options & 4)) {
          {
#line 878
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 878
          p->fts_symfd = tmp___1;
          }
#line 878
          if (tmp___1 < 0) {
            {
#line 879
            tmp___0 = __errno_location();
#line 879
            p->fts_errno = *tmp___0;
#line 880
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 882
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 884
      goto check_for_dir;
    }
  }
#line 888
  if ((int )p->fts_info == 1) {
#line 890
    if ((int )instr == 4) {
#line 890
      goto _L___0;
    } else
#line 890
    if (sp->fts_options & 64) {
#line 890
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */ 
#line 892
        if ((int )p->fts_flags & 2) {
          {
#line 893
          close(p->fts_symfd);
          }
        }
#line 894
        if (sp->fts_child) {
          {
#line 895
          fts_lfree(sp->fts_child);
#line 896
          sp->fts_child = (struct _ftsent *)((void *)0);
          }
        }
#line 898
        p->fts_info = (unsigned short)6;
        {
#line 899
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 899
          leave_dir(sp, p);
          }
#line 899
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 900
        return (p);
      }
    }
#line 904
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 904
      if (sp->fts_options & 8192) {
        {
#line 905
        sp->fts_options &= -8193;
#line 906
        fts_lfree(sp->fts_child);
#line 907
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
      }
    }
#line 922
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
#line 923
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      }
#line 923
      if (tmp___3) {
        {
#line 924
        tmp___2 = __errno_location();
#line 924
        p->fts_errno = *tmp___2;
#line 925
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 926
        p = sp->fts_child;
        }
        {
#line 926
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 926
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 926
            goto while_break___0;
          }
#line 928
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 926
          p = p->fts_link;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 931
      tmp___4 = fts_build(sp, 3);
#line 931
      sp->fts_child = tmp___4;
      }
#line 931
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 932
        if (sp->fts_options & 16384) {
#line 933
          return ((FTSENT *)((void *)0));
        }
#line 937
        if (p->fts_errno) {
#line 937
          if ((int )p->fts_info != 4) {
#line 938
            p->fts_info = (unsigned short)7;
          }
        }
        {
#line 939
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 939
          leave_dir(sp, p);
          }
#line 939
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 940
        return (p);
      }
    }
#line 942
    p = sp->fts_child;
#line 943
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 944
    goto name;
  }
  next: 
#line 948
  tmp = p;
#line 953
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
#line 953
    if ((p->fts_parent)->fts_dirp) {
      {
#line 955
      p = tmp->fts_parent;
#line 956
      sp->fts_cur = p;
#line 957
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 959
      p = fts_build(sp, 3);
      }
#line 959
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 961
        if (sp->fts_options & 16384) {
#line 962
          return ((FTSENT *)((void *)0));
        }
#line 963
        goto cd_dot_dot;
      }
      {
#line 966
      free((void *)tmp);
      }
#line 967
      goto name;
    }
  }
#line 970
  p = p->fts_link;
#line 970
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 971
    sp->fts_cur = p;
#line 972
    free((void *)tmp);
    }
#line 979
    if (p->fts_level == 0L) {
      {
#line 980
      tmp___5 = restore_initial_cwd(sp);
      }
#line 980
      if (tmp___5) {
#line 981
        sp->fts_options |= 16384;
#line 982
        return ((FTSENT *)((void *)0));
      }
      {
#line 984
      free_dir(sp);
#line 985
      fts_load(sp, p);
#line 986
      setup_dir(sp);
      }
#line 987
      goto check_for_dir;
    }
#line 995
    if ((int )p->fts_instr == 4) {
#line 996
      goto next;
    }
#line 997
    if ((int )p->fts_instr == 2) {
      {
#line 998
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 999
      if ((int )p->fts_info == 1) {
#line 999
        if (! (sp->fts_options & 4)) {
          {
#line 1000
          tmp___7 = diropen((FTS const   *)sp, ".");
#line 1000
          p->fts_symfd = tmp___7;
          }
#line 1000
          if (tmp___7 < 0) {
            {
#line 1001
            tmp___6 = __errno_location();
#line 1001
            p->fts_errno = *tmp___6;
#line 1002
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 1004
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 1006
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 1009
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 1009
      tmp___8 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 1009
      tmp___8 = (p->fts_parent)->fts_pathlen;
    }
    {
#line 1009
    t = sp->fts_path + tmp___8;
#line 1010
    tmp___9 = t;
#line 1010
    t ++;
#line 1010
    *tmp___9 = (char )'/';
#line 1011
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir: 
#line 1013
    sp->fts_cur = p;
#line 1014
    if ((int )p->fts_info == 11) {
#line 1016
      if (p->fts_statp[0].st_size == 2L) {
#line 1018
        parent = p->fts_parent;
#line 1019
        if (0L < p->fts_level) {
#line 1019
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 1019
            if (sp->fts_options & 8) {
#line 1019
              if (sp->fts_options & 16) {
                {
#line 1019
                tmp___10 = link_count_optimize_ok((FTSENT const   *)parent);
                }
#line 1019
                if (! tmp___10) {
#line 1019
                  goto _L___4;
                }
              } else {
#line 1019
                goto _L___4;
              }
            } else {
#line 1019
              goto _L___4;
            }
          } else {
#line 1019
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 1031
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
#line 1032
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 1032
            if (p->fts_level != 0L) {
#line 1032
              if (parent->fts_n_dirs_remaining) {
#line 1035
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        {
#line 1039
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1039
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
#line 1039
            abort();
            }
          }
#line 1039
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1042
    if ((int )p->fts_info == 1) {
#line 1047
      if (p->fts_level == 0L) {
#line 1048
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      {
#line 1050
      tmp___12 = enter_dir(sp, p);
      }
#line 1050
      if (! tmp___12) {
        {
#line 1052
        tmp___11 = __errno_location();
#line 1052
        *tmp___11 = 12;
        }
#line 1053
        return ((FTSENT *)((void *)0));
      }
    }
#line 1056
    return (p);
  }
  cd_dot_dot: 
  {
#line 1061
  p = tmp->fts_parent;
#line 1062
  sp->fts_cur = p;
#line 1063
  free((void *)tmp);
  }
#line 1065
  if (p->fts_level == -1L) {
    {
#line 1070
    free((void *)p);
#line 1071
    tmp___13 = __errno_location();
#line 1071
    *tmp___13 = 0;
#line 1072
    tmp___14 = (struct _ftsent *)((void *)0);
#line 1072
    sp->fts_cur = tmp___14;
    }
#line 1072
    return (tmp___14);
  }
  {
#line 1075
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1075
    if (! ((int )p->fts_info != 11)) {
      {
#line 1075
      abort();
      }
    }
#line 1075
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1078
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1086
  if (p->fts_level == 0L) {
    {
#line 1087
    tmp___16 = restore_initial_cwd(sp);
    }
#line 1087
    if (tmp___16) {
      {
#line 1088
      tmp___15 = __errno_location();
#line 1088
      p->fts_errno = *tmp___15;
#line 1089
      sp->fts_options |= 16384;
      }
    }
  } else
#line 1091
  if ((int )p->fts_flags & 2) {
#line 1092
    if (! (sp->fts_options & 4)) {
#line 1092
      if (sp->fts_options & 512) {
        {
#line 1092
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1092
        tmp___19 = 0;
        }
      } else {
        {
#line 1092
        tmp___18 = fchdir(p->fts_symfd);
#line 1092
        tmp___19 = tmp___18;
        }
      }
#line 1092
      if (tmp___19) {
        {
#line 1093
        tmp___17 = __errno_location();
#line 1093
        p->fts_errno = *tmp___17;
#line 1094
        sp->fts_options |= 16384;
        }
      }
    }
    {
#line 1096
    close(p->fts_symfd);
    }
  } else
#line 1097
  if (! ((int )p->fts_flags & 1)) {
    {
#line 1097
    tmp___21 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    }
#line 1097
    if (tmp___21) {
      {
#line 1099
      tmp___20 = __errno_location();
#line 1099
      p->fts_errno = *tmp___20;
#line 1100
      sp->fts_options |= 16384;
      }
    }
  }
#line 1106
  if ((int )p->fts_info != 2) {
#line 1107
    if (p->fts_errno) {
#line 1107
      p->fts_info = (unsigned short)7;
    } else {
#line 1107
      p->fts_info = (unsigned short)6;
    }
#line 1108
    if (p->fts_errno == 0) {
      {
#line 1109
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1109
        leave_dir(sp, p);
        }
#line 1109
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1111
  if (sp->fts_options & 16384) {
#line 1111
    tmp___22 = (FTSENT *)((void *)0);
  } else {
#line 1111
    tmp___22 = p;
  }
#line 1111
  return (tmp___22);
}
}
#line 1121
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1121 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr ) 
{ 
  int *tmp ;

  {
#line 1124
  if (instr != 0) {
#line 1124
    if (instr != 1) {
#line 1124
      if (instr != 2) {
#line 1124
        if (instr != 3) {
#line 1124
          if (instr != 4) {
            {
#line 1126
            tmp = __errno_location();
#line 1126
            *tmp = 22;
            }
#line 1127
            return (1);
          }
        }
      }
    }
  }
#line 1129
  p->fts_instr = (unsigned short )instr;
#line 1130
  return (0);
}
}
#line 1133
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 1133 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                          int instr ) 
{ 
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1139
  if (instr != 0) {
#line 1139
    if (instr != 8192) {
      {
#line 1140
      tmp = __errno_location();
#line 1140
      *tmp = 22;
      }
#line 1141
      return ((FTSENT *)((void *)0));
    }
  }
  {
#line 1145
  p = sp->fts_cur;
#line 1151
  tmp___0 = __errno_location();
#line 1151
  *tmp___0 = 0;
  }
#line 1154
  if (sp->fts_options & 16384) {
#line 1155
    return ((FTSENT *)((void *)0));
  }
#line 1158
  if ((int )p->fts_info == 9) {
#line 1159
    return (p->fts_link);
  }
#line 1166
  if ((int )p->fts_info != 1) {
#line 1167
    return ((FTSENT *)((void *)0));
  }
#line 1170
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
#line 1171
    fts_lfree(sp->fts_child);
    }
  }
#line 1173
  if (instr == 8192) {
#line 1174
    sp->fts_options |= 8192;
#line 1175
    instr = 2;
  } else {
#line 1177
    instr = 1;
  }
#line 1186
  if (p->fts_level != 0L) {
    {
#line 1188
    tmp___1 = fts_build(sp, instr);
#line 1188
    sp->fts_child = tmp___1;
    }
#line 1188
    return (tmp___1);
  } else
#line 1186
  if ((int )*(p->fts_accpath + 0) == 47) {
    {
#line 1188
    tmp___1 = fts_build(sp, instr);
#line 1188
    sp->fts_child = tmp___1;
    }
#line 1188
    return (tmp___1);
  } else
#line 1186
  if (sp->fts_options & 4) {
    {
#line 1188
    tmp___1 = fts_build(sp, instr);
#line 1188
    sp->fts_child = tmp___1;
    }
#line 1188
    return (tmp___1);
  }
  {
#line 1190
  fd = diropen((FTS const   *)sp, ".");
  }
#line 1190
  if (fd < 0) {
#line 1191
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1191
    sp->fts_child = tmp___2;
#line 1191
    return (tmp___2);
  }
  {
#line 1192
  sp->fts_child = fts_build(sp, instr);
  }
#line 1193
  if (sp->fts_options & 512) {
    {
#line 1195
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
  } else {
    {
#line 1199
    tmp___5 = fchdir(fd);
    }
#line 1199
    if (tmp___5) {
      {
#line 1201
      tmp___3 = __errno_location();
#line 1201
      saved_errno = *tmp___3;
#line 1202
      close(fd);
#line 1203
      tmp___4 = __errno_location();
#line 1203
      *tmp___4 = saved_errno;
      }
#line 1204
      return ((FTSENT *)((void *)0));
    }
    {
#line 1206
    close(fd);
    }
  }
#line 1208
  return (sp->fts_child);
}
}
#line 1216 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1219
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1219
    tmp___0 = -1;
  } else {
#line 1219
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1219
      tmp = 1;
    } else {
#line 1219
      tmp = 0;
    }
#line 1219
    tmp___0 = tmp;
  }
#line 1219
  return (tmp___0);
}
}
#line 1225 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1231
  if (dtype == 6U) {
#line 1231
    goto case_6;
  }
#line 1234
  if (dtype == 2U) {
#line 1234
    goto case_2;
  }
#line 1237
  if (dtype == 4U) {
#line 1237
    goto case_4;
  }
#line 1240
  if (dtype == 1U) {
#line 1240
    goto case_1;
  }
#line 1243
  if (dtype == 10U) {
#line 1243
    goto case_10;
  }
#line 1246
  if (dtype == 8U) {
#line 1246
    goto case_8;
  }
#line 1249
  if (dtype == 12U) {
#line 1249
    goto case_12;
  }
#line 1252
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1232
  type = (mode_t )24576;
#line 1233
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1235
  type = (mode_t )8192;
#line 1236
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1238
  type = (mode_t )16384;
#line 1239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1241
  type = (mode_t )4096;
#line 1242
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1244
  type = (mode_t )40960;
#line 1245
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1247
  type = (mode_t )32768;
#line 1248
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1250
  type = (mode_t )49152;
#line 1251
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1253
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1255
  st->st_mode = type;
#line 1256
  return;
}
}
#line 1291 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  size_t max_entries ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool is_dir ;
  size_t d_namelen ;
  int *tmp___11 ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  _Bool tmp___17 ;
  int *tmp___18 ;
  _Bool skip_stat ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1308
  cur = sp->fts_cur;
#line 1309
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1315
  if (continue_readdir) {
    {
#line 1317
    dp = cur->fts_dirp;
#line 1318
    dir_fd = dirfd(dp);
    }
#line 1319
    if (dir_fd < 0) {
      {
#line 1321
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1321
        closedir(cur->fts_dirp);
#line 1321
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1321
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1322
      if (type == 3) {
        {
#line 1324
        cur->fts_info = (unsigned short)4;
#line 1325
        tmp = __errno_location();
#line 1325
        cur->fts_errno = *tmp;
        }
      }
#line 1327
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1334
    if (sp->fts_options & 16) {
#line 1334
      if (sp->fts_options & 1) {
#line 1334
        if (cur->fts_level == 0L) {
#line 1334
          tmp___2 = 0;
        } else {
#line 1334
          tmp___2 = 131072;
        }
      } else {
#line 1334
        tmp___2 = 131072;
      }
    } else {
#line 1334
      tmp___2 = 0;
    }
#line 1334
    if (sp->fts_options & 2048) {
#line 1334
      tmp___3 = 262144;
    } else {
#line 1334
      tmp___3 = 0;
    }
#line 1334
    if (! (sp->fts_options & 4)) {
#line 1334
      if (sp->fts_options & 512) {
#line 1334
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1334
        tmp___4 = -100;
      }
    } else {
#line 1334
      tmp___4 = -100;
    }
    {
#line 1334
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
#line 1334
    cur->fts_dirp = tmp___1;
    }
#line 1334
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1336
      if (type == 3) {
        {
#line 1338
        cur->fts_info = (unsigned short)4;
#line 1339
        tmp___0 = __errno_location();
#line 1339
        cur->fts_errno = *tmp___0;
        }
      }
#line 1341
      return ((FTSENT *)((void *)0));
    }
#line 1346
    if ((int )cur->fts_info == 11) {
      {
#line 1347
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
      }
    } else
#line 1348
    if (sp->fts_options & 256) {
      {
#line 1355
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1355
        leave_dir(sp, cur);
        }
#line 1355
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1356
      fts_stat(sp, cur, (_Bool)0);
#line 1357
      tmp___6 = enter_dir(sp, cur);
      }
#line 1357
      if (! tmp___6) {
        {
#line 1359
        tmp___5 = __errno_location();
#line 1359
        *tmp___5 = 12;
        }
#line 1360
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1372
  if (sp->fts_compar) {
#line 1372
    max_entries = 0xffffffffffffffffUL;
  } else {
#line 1372
    max_entries = (size_t )100000;
  }
#line 1379
  if (type == 2) {
#line 1380
    nlinks = (nlink_t )0;
#line 1382
    nostat = (_Bool)0;
  } else
#line 1383
  if (sp->fts_options & 8) {
#line 1383
    if (sp->fts_options & 16) {
#line 1384
      if (sp->fts_options & 32) {
#line 1384
        tmp___7 = 0;
      } else {
#line 1384
        tmp___7 = 2;
      }
#line 1384
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___7;
#line 1386
      nostat = (_Bool)1;
    } else {
#line 1388
      nlinks = (nlink_t )-1;
#line 1389
      nostat = (_Bool)0;
    }
  } else {
#line 1388
    nlinks = (nlink_t )-1;
#line 1389
    nostat = (_Bool)0;
  }
#line 1407
  if (continue_readdir) {
#line 1411
    descend = (_Bool)1;
  } else
#line 1413
  if (nlinks) {
#line 1413
    goto _L___0;
  } else
#line 1413
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1414
    if (sp->fts_options & 512) {
      {
#line 1416
      dir_fd = dup_safer(dir_fd);
      }
#line 1417
      if (0 <= dir_fd) {
        {
#line 1418
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1420
    if (dir_fd < 0) {
#line 1420
      goto _L;
    } else {
      {
#line 1420
      tmp___9 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1420
      if (tmp___9) {
        _L: /* CIL Label */ 
#line 1421
        if (nlinks) {
#line 1421
          if (type == 3) {
            {
#line 1422
            tmp___8 = __errno_location();
#line 1422
            cur->fts_errno = *tmp___8;
            }
          }
        }
#line 1423
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1424
        descend = (_Bool)0;
        {
#line 1425
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1425
          closedir(cur->fts_dirp);
#line 1425
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1425
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1426
        if (sp->fts_options & 512) {
#line 1426
          if (0 <= dir_fd) {
            {
#line 1427
            close(dir_fd);
            }
          }
        }
#line 1428
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1430
        descend = (_Bool)1;
      }
    }
  } else {
#line 1432
    descend = (_Bool)0;
  }
#line 1444
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1444
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1444
    len = cur->fts_pathlen;
  }
#line 1445
  if (sp->fts_options & 4) {
#line 1446
    cp = sp->fts_path + len;
#line 1447
    tmp___10 = cp;
#line 1447
    cp ++;
#line 1447
    *tmp___10 = (char )'/';
  } else {
#line 1450
    cp = (char *)((void *)0);
  }
#line 1452
  len ++;
#line 1453
  maxlen = sp->fts_pathlen - len;
#line 1455
  level = cur->fts_level + 1L;
#line 1458
  doadjust = (_Bool)0;
#line 1459
  head = (FTSENT *)((void *)0);
#line 1460
  tail = (FTSENT *)((void *)0);
#line 1461
  nitems = (size_t )0;
  {
#line 1462
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1462
    if (! cur->fts_dirp) {
#line 1462
      goto while_break___2;
    }
    {
#line 1465
    tmp___11 = __errno_location();
#line 1465
    *tmp___11 = 0;
#line 1466
    tmp___12 = readdir(cur->fts_dirp);
#line 1466
    dp___0 = tmp___12;
    }
#line 1467
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      {
#line 1468
      tmp___14 = __errno_location();
      }
#line 1468
      if (*tmp___14) {
        {
#line 1469
        tmp___13 = __errno_location();
#line 1469
        cur->fts_errno = *tmp___13;
        }
#line 1472
        if (continue_readdir) {
#line 1472
          cur->fts_info = (unsigned short)7;
        } else
#line 1472
        if (nitems) {
#line 1472
          cur->fts_info = (unsigned short)7;
        } else {
#line 1472
          cur->fts_info = (unsigned short)4;
        }
      }
#line 1475
      goto while_break___2;
    }
#line 1477
    if (! (sp->fts_options & 32)) {
#line 1477
      if ((int )dp___0->d_name[0] == 46) {
#line 1477
        if (! dp___0->d_name[1]) {
#line 1478
          goto while_continue___2;
        } else
#line 1477
        if ((int )dp___0->d_name[1] == 46) {
#line 1477
          if (! dp___0->d_name[2]) {
#line 1478
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1480
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1481
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1482
    if (! p) {
#line 1483
      goto mem1;
    }
#line 1484
    if (d_namelen >= maxlen) {
      {
#line 1486
      oldaddr = (void *)sp->fts_path;
#line 1487
      tmp___17 = fts_palloc(sp, (d_namelen + len) + 1UL);
      }
#line 1487
      if (! tmp___17) {
        mem1: 
        {
#line 1493
        tmp___15 = __errno_location();
#line 1493
        saved_errno = *tmp___15;
#line 1494
        free((void *)p);
#line 1495
        fts_lfree(head);
        }
        {
#line 1496
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1496
          closedir(cur->fts_dirp);
#line 1496
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1496
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1497
        cur->fts_info = (unsigned short)7;
#line 1498
        sp->fts_options |= 16384;
#line 1499
        tmp___16 = __errno_location();
#line 1499
        *tmp___16 = saved_errno;
        }
#line 1500
        return ((FTSENT *)((void *)0));
      }
#line 1503
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1504
        doadjust = (_Bool)1;
#line 1505
        if (sp->fts_options & 4) {
#line 1506
          cp = sp->fts_path + len;
        }
      }
#line 1508
      maxlen = sp->fts_pathlen - len;
    }
#line 1511
    new_len = len + d_namelen;
#line 1512
    if (new_len < len) {
      {
#line 1519
      free((void *)p);
#line 1520
      fts_lfree(head);
      }
      {
#line 1521
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1521
        closedir(cur->fts_dirp);
#line 1521
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1521
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1522
      cur->fts_info = (unsigned short)7;
#line 1523
      sp->fts_options |= 16384;
#line 1524
      tmp___18 = __errno_location();
#line 1524
      *tmp___18 = 36;
      }
#line 1525
      return ((FTSENT *)((void *)0));
    }
#line 1527
    p->fts_level = level;
#line 1528
    p->fts_parent = sp->fts_cur;
#line 1529
    p->fts_pathlen = new_len;
#line 1533
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1536
    if (sp->fts_options & 4) {
      {
#line 1537
      p->fts_accpath = p->fts_path;
#line 1538
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1540
      p->fts_accpath = p->fts_name;
    }
#line 1542
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1542
      goto _L___1;
    } else
#line 1542
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1555
      if (sp->fts_options & 16) {
#line 1555
        if (sp->fts_options & 8) {
#line 1555
          if ((int )dp___0->d_type != 0) {
#line 1555
            if (! ((int )dp___0->d_type == 4)) {
#line 1555
              tmp___19 = 1;
            } else {
#line 1555
              tmp___19 = 0;
            }
          } else {
#line 1555
            tmp___19 = 0;
          }
        } else {
#line 1555
          tmp___19 = 0;
        }
      } else {
#line 1555
        tmp___19 = 0;
      }
      {
#line 1555
      skip_stat = (_Bool )tmp___19;
#line 1559
      p->fts_info = (unsigned short)11;
#line 1562
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1563
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      }
#line 1564
      if (sp->fts_options & 16) {
#line 1564
        if ((int )dp___0->d_type == 4) {
#line 1564
          tmp___20 = 1;
        } else {
#line 1564
          tmp___20 = 0;
        }
      } else {
#line 1564
        tmp___20 = 0;
      }
#line 1564
      is_dir = (_Bool )tmp___20;
    } else {
      {
#line 1567
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
#line 1568
      if ((int )p->fts_info == 1) {
#line 1568
        tmp___21 = 1;
      } else
#line 1568
      if ((int )p->fts_info == 2) {
#line 1568
        tmp___21 = 1;
      } else
#line 1568
      if ((int )p->fts_info == 5) {
#line 1568
        tmp___21 = 1;
      } else {
#line 1568
        tmp___21 = 0;
      }
#line 1568
      is_dir = (_Bool )tmp___21;
    }
#line 1574
    if (nlinks > 0UL) {
#line 1574
      if (is_dir) {
#line 1575
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1578
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1579
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1580
      tail = p;
#line 1580
      head = tail;
    } else {
#line 1582
      tail->fts_link = p;
#line 1583
      tail = p;
    }
#line 1585
    nitems ++;
#line 1586
    if (max_entries <= nitems) {
#line 1590
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1594
  if (cur->fts_dirp) {
    {
#line 1595
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1595
      closedir(cur->fts_dirp);
#line 1595
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1595
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1603
  if (doadjust) {
    {
#line 1604
    fts_padjust(sp, head);
    }
  }
#line 1610
  if (sp->fts_options & 4) {
#line 1611
    if (len == sp->fts_pathlen) {
#line 1612
      cp --;
    } else
#line 1611
    if (nitems == 0UL) {
#line 1612
      cp --;
    }
#line 1613
    *cp = (char )'\000';
  }
#line 1623
  if (! continue_readdir) {
#line 1623
    if (descend) {
#line 1623
      if (type == 1) {
#line 1623
        goto _L___2;
      } else
#line 1623
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1623
        if (cur->fts_level == 0L) {
          {
#line 1623
          tmp___22 = restore_initial_cwd(sp);
#line 1623
          tmp___24 = tmp___22;
          }
        } else {
          {
#line 1623
          tmp___23 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1623
          tmp___24 = tmp___23;
          }
        }
#line 1623
        if (tmp___24) {
          {
#line 1627
          cur->fts_info = (unsigned short)7;
#line 1628
          sp->fts_options |= 16384;
#line 1629
          fts_lfree(head);
          }
#line 1630
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1634
  if (! nitems) {
#line 1635
    if (type == 3) {
#line 1635
      if ((int )cur->fts_info != 4) {
#line 1635
        if ((int )cur->fts_info != 7) {
#line 1637
          cur->fts_info = (unsigned short)6;
        }
      }
    }
    {
#line 1638
    fts_lfree(head);
    }
#line 1639
    return ((FTSENT *)((void *)0));
  }
#line 1646
  if (nitems > 10000UL) {
#line 1646
    if (! sp->fts_compar) {
#line 1646
      if (sp->fts_options & 512) {
        {
#line 1646
        tmp___25 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
#line 1646
        if (tmp___25) {
          {
#line 1650
          sp->fts_compar = & fts_compare_ino;
#line 1651
          head = fts_sort(sp, head, nitems);
#line 1652
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1656
  if (sp->fts_compar) {
#line 1656
    if (nitems > 1UL) {
      {
#line 1657
      head = fts_sort(sp, head, nitems);
      }
    }
  }
#line 1658
  return (head);
}
}
#line 1805 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1809
  sbp = p->fts_statp;
#line 1812
  if (p->fts_level == 0L) {
#line 1812
    if (sp->fts_options & 1) {
#line 1813
      follow = (_Bool)1;
    }
  }
#line 1820
  if (sp->fts_options & 2) {
#line 1820
    goto _L;
  } else
#line 1820
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1821
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1821
    if (tmp___3) {
      {
#line 1822
      tmp = __errno_location();
#line 1822
      saved_errno = *tmp;
#line 1823
      tmp___1 = __errno_location();
      }
#line 1823
      if (*tmp___1 == 2) {
        {
#line 1823
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1823
        if (tmp___2 == 0) {
          {
#line 1825
          tmp___0 = __errno_location();
#line 1825
          *tmp___0 = 0;
          }
#line 1826
          return ((unsigned short)13);
        }
      }
#line 1828
      p->fts_errno = saved_errno;
#line 1829
      goto err;
    }
  } else {
    {
#line 1831
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1831
    if (tmp___5) {
      {
#line 1833
      tmp___4 = __errno_location();
#line 1833
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1834
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1835
      return ((unsigned short)10);
    }
  }
#line 1838
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1839
    if (sp->fts_options & 32) {
#line 1839
      tmp___6 = 0;
    } else {
#line 1839
      tmp___6 = 2;
    }
#line 1839
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1841
    if ((int )p->fts_name[0] == 46) {
#line 1841
      if (! p->fts_name[1]) {
#line 1841
        goto _L___0;
      } else
#line 1841
      if ((int )p->fts_name[1] == 46) {
#line 1841
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1843
          if (p->fts_level == 0L) {
#line 1843
            tmp___7 = 1;
          } else {
#line 1843
            tmp___7 = 5;
          }
#line 1843
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1846
    return ((unsigned short)1);
  }
#line 1848
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1849
    return ((unsigned short)12);
  }
#line 1850
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1851
    return ((unsigned short)8);
  }
#line 1852
  return ((unsigned short)3);
}
}
#line 1855 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1863
  pa = (FTSENT const   **)a;
#line 1864
  pb = (FTSENT const   **)b;
#line 1865
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1865
  return (tmp);
}
}
#line 1868 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1882
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1882
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1882
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1882
      tmp = & fts_compar;
    }
  } else {
#line 1882
    tmp = & fts_compar;
  }
#line 1882
  compare = tmp;
#line 1895
  if (nitems > sp->fts_nitems) {
#line 1898
    sp->fts_nitems = nitems + 40UL;
#line 1899
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1902
      free((void *)sp->fts_array);
#line 1903
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1904
      sp->fts_nitems = (size_t )0;
      }
#line 1905
      return (head);
    } else {
      {
#line 1899
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1899
      a = (FTSENT **)tmp___0;
      }
#line 1899
      if (! a) {
        {
#line 1902
        free((void *)sp->fts_array);
#line 1903
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1904
        sp->fts_nitems = (size_t )0;
        }
#line 1905
        return (head);
      }
    }
#line 1907
    sp->fts_array = a;
  }
#line 1909
  ap = sp->fts_array;
#line 1909
  p = head;
  {
#line 1909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1909
    if (! p) {
#line 1909
      goto while_break;
    }
#line 1910
    tmp___1 = ap;
#line 1910
    ap ++;
#line 1910
    *tmp___1 = p;
#line 1909
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1911
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1912
  ap = sp->fts_array;
#line 1912
  head = *ap;
  }
  {
#line 1912
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1912
    nitems --;
#line 1912
    if (! nitems) {
#line 1912
      goto while_break___0;
    }
#line 1913
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1912
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1914
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1915
  return (head);
}
}
#line 1918 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1929
  len = ((((unsigned long )(& ((FTSENT *)0)->fts_name) + __alignof__(FTSENT )) - 1UL) + (namelen + 1UL)) & ~ (__alignof__(FTSENT ) - 1UL);
#line 1930
  tmp = malloc(len);
#line 1930
  p = (FTSENT *)tmp;
  }
#line 1930
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1931
    return ((FTSENT *)((void *)0));
  }
  {
#line 1934
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1935
  p->fts_name[namelen] = (char )'\000';
#line 1937
  p->fts_namelen = namelen;
#line 1938
  p->fts_fts = sp;
#line 1939
  p->fts_path = sp->fts_path;
#line 1940
  p->fts_errno = 0;
#line 1941
  p->fts_dirp = (DIR *)((void *)0);
#line 1942
  p->fts_flags = (unsigned short)0;
#line 1943
  p->fts_instr = (unsigned short)3;
#line 1944
  p->fts_number = 0L;
#line 1945
  p->fts_pointer = (void *)0;
  }
#line 1946
  return (p);
}
}
#line 1949 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_lfree(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1956
    p = head;
#line 1956
    if (! p) {
#line 1956
      goto while_break;
    }
#line 1957
    head = head->fts_link;
#line 1958
    if (p->fts_dirp) {
      {
#line 1959
      closedir(p->fts_dirp);
      }
    }
    {
#line 1960
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1962
  return;
}
}
#line 1971 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1976
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1981
  if (new_len < sp->fts_pathlen) {
    {
#line 1982
    free((void *)sp->fts_path);
#line 1983
    sp->fts_path = (char *)((void *)0);
#line 1984
    tmp = __errno_location();
#line 1984
    *tmp = 36;
    }
#line 1985
    return ((_Bool)0);
  }
  {
#line 1987
  sp->fts_pathlen = new_len;
#line 1988
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1988
  p = (char *)tmp___0;
  }
#line 1989
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1990
    free((void *)sp->fts_path);
#line 1991
    sp->fts_path = (char *)((void *)0);
    }
#line 1992
    return ((_Bool)0);
  }
#line 1994
  sp->fts_path = p;
#line 1995
  return ((_Bool)1);
}
}
#line 2002 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 2007
  addr = sp->fts_path;
#line 2017
  p = sp->fts_child;
  {
#line 2017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2017
    if (! p) {
#line 2017
      goto while_break;
    }
    {
#line 2018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2018
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2018
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2018
      p->fts_path = addr;
#line 2018
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2017
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  p = head;
  {
#line 2021
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2021
    if (! (p->fts_level >= 0L)) {
#line 2021
      goto while_break___1;
    }
    {
#line 2022
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2022
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2022
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2022
      p->fts_path = addr;
#line 2022
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2023
    if (p->fts_link) {
#line 2023
      p = p->fts_link;
    } else {
#line 2023
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2025
  return;
}
}
#line 2027 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2033
  max = (size_t )0;
  {
#line 2033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2033
    if (! *argv) {
#line 2033
      goto while_break;
    }
    {
#line 2034
    len = strlen((char const   *)*argv);
    }
#line 2034
    if (len > max) {
#line 2035
      max = len;
    }
#line 2033
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2036
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2048 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2053
  if (dir) {
    {
#line 2053
    tmp = strcmp(dir, "..");
    }
#line 2053
    if (tmp == 0) {
#line 2053
      tmp___0 = 1;
    } else {
#line 2053
      tmp___0 = 0;
    }
  } else {
#line 2053
    tmp___0 = 0;
  }
#line 2053
  is_dotdot = (_Bool )tmp___0;
#line 2060
  if (sp->fts_options & 4) {
#line 2062
    if (sp->fts_options & 512) {
#line 2062
      if (0 <= fd) {
        {
#line 2063
        close(fd);
        }
      }
    }
#line 2064
    return (0);
  }
#line 2067
  if (fd < 0) {
#line 2067
    if (is_dotdot) {
#line 2067
      if (sp->fts_options & 512) {
        {
#line 2074
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2074
        if (! tmp___1) {
          {
#line 2078
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2079
          is_dotdot = (_Bool)1;
          }
#line 2080
          if (0 <= parent_fd) {
#line 2082
            fd = parent_fd;
#line 2083
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2088
  newfd = fd;
#line 2089
  if (fd < 0) {
    {
#line 2089
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 2089
    if (newfd < 0) {
#line 2090
      return (-1);
    }
  }
#line 2099
  if (sp->fts_options & 2) {
#line 2099
    goto _L;
  } else
#line 2099
  if (dir) {
    {
#line 2099
    tmp___4 = strcmp(dir, "..");
    }
#line 2099
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2103
      tmp___2 = fstat(newfd, & sb);
      }
#line 2103
      if (tmp___2) {
#line 2105
        ret = -1;
#line 2106
        goto bail;
      }
#line 2108
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2111
        tmp___3 = __errno_location();
#line 2111
        *tmp___3 = 2;
#line 2112
        ret = -1;
        }
#line 2113
        goto bail;
      } else
#line 2108
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2111
        tmp___3 = __errno_location();
#line 2111
        *tmp___3 = 2;
#line 2112
        ret = -1;
        }
#line 2113
        goto bail;
      }
    }
  }
#line 2117
  if (sp->fts_options & 512) {
    {
#line 2119
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2120
    return (0);
  }
  {
#line 2123
  ret = fchdir(newfd);
  }
  bail: 
#line 2125
  if (fd < 0) {
    {
#line 2127
    tmp___5 = __errno_location();
#line 2127
    oerrno = *tmp___5;
#line 2128
    close(newfd);
#line 2129
    tmp___6 = __errno_location();
#line 2129
    *tmp___6 = oerrno;
    }
  }
#line 2131
  return (ret);
}
}
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/khheo/project/benchmark/grep-3.0/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 60 "/home/khheo/project/benchmark/grep-3.0/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = (char const   *)tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 448 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 335 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 271 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 275
  result = -1;
#line 276
  __builtin_va_start(arg, action);
  }
  {
#line 320
  if (action == 1030) {
#line 320
    goto case_1030;
  }
#line 401
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 322
  tmp___0 = __builtin_va_arg(arg, int );
#line 322
  target = tmp___0;
  }
#line 336
  if (0 <= have_dupfd_cloexec) {
    {
#line 338
    result = fcntl(fd, action, target);
    }
#line 339
    if (0 <= result) {
#line 341
      have_dupfd_cloexec = 1;
    } else {
      {
#line 339
      tmp___1 = __errno_location();
      }
#line 339
      if (*tmp___1 != 22) {
#line 341
        have_dupfd_cloexec = 1;
      } else {
        {
#line 349
        result = rpl_fcntl(fd, 0, target);
        }
#line 350
        if (result < 0) {
#line 351
          goto switch_break;
        }
#line 352
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 356
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 357
  if (0 <= result) {
#line 357
    if (have_dupfd_cloexec == -1) {
      {
#line 359
      tmp___2 = fcntl(result, 1);
#line 359
      flags = tmp___2;
      }
#line 360
      if (flags < 0) {
#line 360
        goto _L;
      } else {
        {
#line 360
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 360
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 362
          tmp___3 = __errno_location();
#line 362
          saved_errno = *tmp___3;
#line 363
          close(result);
#line 364
          tmp___4 = __errno_location();
#line 364
          *tmp___4 = saved_errno;
#line 365
          result = -1;
          }
        }
      }
    }
  }
#line 368
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 404
  tmp___7 = __builtin_va_arg(arg, void *);
#line 404
  p = tmp___7;
#line 405
  result = fcntl(fd, action, p);
  }
#line 409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  __builtin_va_end(arg);
  }
#line 413
  return (result);
}
}
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 640 "./regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 644
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __String ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 652
extern void regfree(regex_t *__preg ) ;
#line 49 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 51
struct exclude *new_exclude(void) ;
#line 52
void free_exclude(struct exclude *ex ) ;
#line 53
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 54
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 56
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data ) ;
#line 58
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 59
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) ;
#line 60
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 131 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) 
{ 
  struct pattern_buffer *pbuf ;
  void *tmp ;

  {
  {
#line 134
  tmp = xmalloc(sizeof(*pbuf));
#line 134
  pbuf = (struct pattern_buffer *)tmp;
#line 135
  pbuf->base = buf;
#line 136
  pbuf->next = ex->patbuf;
#line 137
  ex->patbuf = pbuf;
  }
#line 138
  return;
}
}
#line 142
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options )  __attribute__((__pure__)) ;
#line 142 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    tmp = str;
#line 147
    str ++;
    {
#line 153
    if ((int const   )*tmp == 41) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 40) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 125) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 123) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 46) {
#line 153
      goto case_41;
    }
#line 158
    if ((int const   )*tmp == 92) {
#line 158
      goto case_92;
    }
#line 165
    if ((int const   )*tmp == 33) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 64) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 43) {
#line 165
      goto case_33;
    }
#line 170
    if ((int const   )*tmp == 91) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 42) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 63) {
#line 170
      goto case_91;
    }
#line 173
    if ((int const   )*tmp == 0) {
#line 173
      goto case_0;
    }
#line 147
    goto switch_break;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 154
    if (options & (1 << 27)) {
#line 155
      return ((_Bool)1);
    }
#line 156
    goto switch_break;
    case_92: /* CIL Label */ 
#line 159
    if (options & (1 << 27)) {
#line 160
      goto while_continue;
    } else {
#line 162
      if (! (options & (1 << 1))) {
#line 162
        if (*str) {
#line 162
          tmp___0 = 1;
        } else {
#line 162
          tmp___0 = 0;
        }
      } else {
#line 162
        tmp___0 = 0;
      }
#line 162
      str += tmp___0;
    }
#line 163
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 166
    if (options & (1 << 5)) {
#line 166
      if ((int const   )*str == 40) {
#line 167
        return ((_Bool)1);
      }
    }
#line 168
    goto switch_break;
    case_91: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 171
    return ((_Bool)1);
    case_0: /* CIL Label */ 
#line 174
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 179 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void unescape_pattern(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 190 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 193
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 193
  return ((struct exclude *)tmp___0);
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void string_free(void *data ) 
{ 


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void new_exclude_segment(struct exclude *ex , enum exclude_type type , int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  goto switch_break;
  case_0: /* CIL Label */ 
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci;
  } else {
#line 266
    tmp___0 = & string_compare;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci;
  } else {
#line 266
    tmp___1 = & string_hasher;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 305 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct pattern_buffer *pbuf ;
  struct exclude_segment *next ;
  struct pattern_buffer *next___0 ;

  {
#line 311
  seg = ex->head;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! seg) {
#line 311
      goto while_break;
    }
    {
#line 313
    next = seg->next;
#line 314
    free_exclude_segment(seg);
#line 315
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  pbuf = ex->patbuf;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! pbuf) {
#line 318
      goto while_break___0;
    }
    {
#line 320
    next___0 = pbuf->next;
#line 321
    free((void *)pbuf->base);
#line 322
    free((void *)pbuf);
#line 323
    pbuf = next___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  free((void *)ex);
  }
#line 327
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 377 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 380
  if (options & (1 << 28)) {
#line 380
    tmp = & fnmatch;
  } else {
#line 380
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 380
  matcher = tmp;
#line 384
  tmp___0 = (*matcher)(pattern, f, options);
#line 384
  matched = (_Bool )(tmp___0 == 0);
  }
#line 387
  if (! (options & (1 << 30))) {
#line 388
    p = f;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (*p) {
#line 388
        if (! (! matched)) {
#line 388
          goto while_break;
        }
      } else {
#line 388
        goto while_break;
      }
#line 389
      if ((int const   )*p == 47) {
#line 389
        if ((int const   )*(p + 1) != 47) {
          {
#line 390
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 390
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 388
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 392
  return (matched);
}
}
#line 395 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool exclude_patopts(struct patopts  const  *opts , char const   *f ) 
{ 
  int options ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options = (int )opts->options;
#line 400
  if (options & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool file_pattern_matches(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool file_name_matches(struct exclude_segment  const  *seg , char const   *f ,
                               char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 469 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool invert ;
  char *filename___0 ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 473
  invert = (_Bool)0;
#line 474
  filename___0 = (char *)((void *)0);
#line 477
  if (! ex->head) {
#line 478
    return ((_Bool)0);
  }
#line 483
  seg = (struct exclude_segment *)ex->head;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if ((unsigned int )seg->type == 0U) {
#line 487
      if (! filename___0) {
        {
#line 488
        tmp = strlen(f);
#line 488
        tmp___0 = xmalloc(tmp + 1UL);
#line 488
        filename___0 = (char *)tmp___0;
        }
      }
      {
#line 489
      tmp___1 = file_name_matches((struct exclude_segment  const  *)seg, f, filename___0);
      }
#line 489
      if (tmp___1) {
#line 490
        goto while_break;
      }
    } else {
      {
#line 494
      tmp___2 = file_pattern_matches((struct exclude_segment  const  *)seg, f);
      }
#line 494
      if (tmp___2) {
#line 495
        goto while_break;
      }
    }
#line 498
    if (! seg->next) {
#line 506
      invert = (_Bool)1;
#line 507
      goto while_break;
    }
#line 483
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  free((void *)filename___0);
  }
#line 512
  return ((_Bool )((int )invert ^ ! (seg->options & (1 << 29))));
}
}
#line 517 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  int rc ;
  int cflags ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t len ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *str ;
  char *p ;
  int exclude_hash_flags ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 524
  if (options & ((1 << 27) | (1 << 28))) {
    {
#line 524
    tmp___7 = fnmatch_pattern_has_wildcards(pattern, options);
    }
#line 524
    if (tmp___7) {
#line 527
      if (ex->head) {
#line 527
        if ((unsigned int )(ex->head)->type == 1U) {
#line 527
          if (! (((ex->head)->options & (1 << 29)) == (options & (1 << 29)))) {
            {
#line 530
            new_exclude_segment(ex, (enum exclude_type )1, options);
            }
          }
        } else {
          {
#line 530
          new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        }
      } else {
        {
#line 530
        new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      }
#line 532
      seg = ex->head;
#line 534
      pat = & seg->v.pat;
#line 535
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 536
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 536
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 538
      tmp___0 = pat->exclude_count;
#line 538
      (pat->exclude_count) ++;
#line 538
      patopts = pat->exclude + tmp___0;
#line 540
      patopts->options = options;
#line 541
      if (options & (1 << 27)) {
#line 544
        if (options & (1 << 4)) {
#line 544
          tmp___1 = 1 << 1;
        } else {
#line 544
          tmp___1 = 0;
        }
#line 544
        cflags = ((1 << 3) | 1) | tmp___1;
#line 547
        if (options & (1 << 3)) {
          {
#line 550
          tmp___3 = strlen(pattern);
#line 550
          len = tmp___3;
          }
          {
#line 552
          while (1) {
            while_continue: /* CIL Label */ ;
#line 552
            if (len > 0UL) {
#line 552
              if (! ((int const   )*(pattern + (len - 1UL)) == 47)) {
#line 552
                goto while_break;
              }
            } else {
#line 552
              goto while_break;
            }
#line 553
            len --;
          }
          while_break: /* CIL Label */ ;
          }
#line 555
          if (len == 0UL) {
#line 556
            rc = 1;
          } else {
            {
#line 559
            tmp___4 = xmalloc(len + 7UL);
#line 559
            tmp___2 = (char *)tmp___4;
#line 560
            memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)pattern,
                   len);
#line 561
            strcpy((char */* __restrict  */)(tmp___2 + len), (char const   */* __restrict  */)"(/.*)?");
#line 562
            rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)tmp___2,
                         cflags);
#line 563
            free((void *)tmp___2);
            }
          }
        } else {
          {
#line 567
          rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)pattern,
                       cflags);
          }
        }
#line 569
        if (rc) {
#line 571
          (pat->exclude_count) --;
#line 572
          return;
        }
      } else {
#line 577
        if (options & (1 << 26)) {
          {
#line 579
          tmp___5 = xstrdup(pattern);
#line 579
          pattern = (char const   *)tmp___5;
#line 580
          exclude_add_pattern_buffer(ex, (char *)pattern);
          }
        }
#line 582
        patopts->v.pattern = pattern;
      }
    } else {
#line 524
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 588
    exclude_hash_flags = (((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4);
#line 590
    if (ex->head) {
#line 590
      if ((unsigned int )(ex->head)->type == 0U) {
#line 590
        if (! (((ex->head)->options & exclude_hash_flags) == (options & exclude_hash_flags))) {
          {
#line 593
          new_exclude_segment(ex, (enum exclude_type )0, options);
          }
        }
      } else {
        {
#line 593
        new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      }
    } else {
      {
#line 593
      new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    }
    {
#line 594
    seg = ex->head;
#line 596
    str = xstrdup(pattern);
    }
#line 597
    if ((options & ((1 << 28) | (1 << 1))) == 1 << 28) {
      {
#line 598
      unescape_pattern(str);
      }
    }
    {
#line 599
    tmp___6 = hash_insert(seg->v.table, (void const   *)str);
#line 599
    p = (char *)tmp___6;
    }
#line 600
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 601
      free((void *)str);
      }
    }
  }
#line 603
  return;
}
}
#line 610 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options , char line_end , void *data ) 
{ 
  char *buf ;
  char *p ;
  char *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *pattern_end ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 616
  buf = (char *)((void *)0);
#line 620
  buf_alloc = (size_t )0;
#line 621
  buf_count = (size_t )0;
#line 623
  e = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    c = getc_unlocked(fp);
    }
#line 625
    if (! (c != -1)) {
#line 625
      goto while_break;
    }
#line 627
    if (buf_count == buf_alloc) {
      {
#line 628
      tmp = x2realloc((void *)buf, & buf_alloc);
#line 628
      buf = (char *)tmp;
      }
    }
#line 629
    tmp___0 = buf_count;
#line 629
    buf_count ++;
#line 629
    *(buf + tmp___0) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  tmp___2 = ferror_unlocked(fp);
  }
#line 632
  if (tmp___2) {
    {
#line 633
    tmp___1 = __errno_location();
#line 633
    e = *tmp___1;
    }
  }
  {
#line 635
  tmp___3 = xrealloc((void *)buf, buf_count + 1UL);
#line 635
  buf = (char *)tmp___3;
#line 636
  *(buf + buf_count) = line_end;
  }
#line 637
  if (buf_count == 0UL) {
#line 637
    tmp___4 = 0;
  } else
#line 637
  if ((int )*(buf + (buf_count - 1UL)) == (int )line_end) {
#line 637
    tmp___4 = 0;
  } else {
#line 637
    tmp___4 = 1;
  }
  {
#line 637
  lim = (char const   *)((buf + buf_count) + tmp___4);
#line 639
  exclude_add_pattern_buffer(ex, buf);
#line 641
  pattern = buf;
#line 643
  p = buf;
  }
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 643
      goto while_break___0;
    }
#line 644
    if ((int )*p == (int )line_end) {
      {
#line 646
      pattern_end = p;
#line 648
      tmp___6 = __ctype_b_loc();
      }
#line 648
      if ((int const   )*(*tmp___6 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 650
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 651
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 652
            goto next_pattern;
          } else {
            {
#line 653
            tmp___5 = __ctype_b_loc();
            }
#line 653
            if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 654
              goto while_break___1;
            }
          }
#line 650
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 657
      *pattern_end = (char )'\000';
#line 658
      (*add_func)(ex, (char const   *)pattern, options, data);
      }
      next_pattern: 
#line 661
      pattern = p + 1;
    }
#line 643
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 664
  tmp___7 = __errno_location();
#line 664
  *tmp___7 = e;
  }
#line 665
  if (e) {
#line 665
    tmp___8 = -1;
  } else {
#line 665
    tmp___8 = 0;
  }
#line 665
  return (tmp___8);
}
}
#line 668 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void call_addfn(struct exclude *ex , char const   *pattern , int options ,
                       void *data ) 
{ 
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 675 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  int rc ;
  int tmp___0 ;

  {
#line 680
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 680
    if (! *(file_name___1 + 1)) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 680
  use_stdin = (_Bool )tmp;
#line 682
  rc = 0;
#line 684
  if (use_stdin) {
#line 685
    in = stdin;
  } else {
    {
#line 686
    in = fopen((char const   */* __restrict  */)file_name___1, (char const   */* __restrict  */)"r");
    }
#line 686
    if (! in) {
#line 687
      return (-1);
    }
  }
  {
#line 689
  rc = add_exclude_fp(& call_addfn, ex, in, options, line_end, (void *)(& add_func));
  }
#line 691
  if (! use_stdin) {
    {
#line 691
    tmp___0 = fclose(in);
    }
#line 691
    if (tmp___0 != 0) {
#line 692
      rc = -1;
    }
  }
#line 694
  return (rc);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/grep-3.0/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 43 "/home/khheo/project/benchmark/grep-3.0/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 45
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/grep-3.0/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 51 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.h"
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 71
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) ;
#line 75
struct dfamust *dfamust(struct dfa  const  *d ) ;
#line 78
void dfamustfree(struct dfamust *dm ) ;
#line 83
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) ;
#line 97
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) ;
#line 104
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 107
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 110
void dfafree(struct dfa *d ) ;
#line 118
void dfawarn(char const   *mesg ) ;
#line 123
void dfaerror(char const   *mesg ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool streq(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = strcmp(a, b);
  }
#line 39
  return ((_Bool )(tmp == 0));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool isasciidigit(char c ) 
{ 
  int tmp ;

  {
#line 45
  if (48 <= (int )c) {
#line 45
    if ((int )c <= 57) {
#line 45
      tmp = 1;
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 288 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 96 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 111 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned char to_uchar___0(char ch ) 
{ 


  {
#line 114
  return ((unsigned char )ch);
}
}
#line 152 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int newline_constraint(int constraint ) 
{ 


  {
#line 155
  return ((constraint >> 6) & 7);
}
}
#line 157 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int letter_constraint(int constraint ) 
{ 


  {
#line 160
  return ((constraint >> 3) & 7);
}
}
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int other_constraint(int constraint ) 
{ 


  {
#line 165
  return (constraint & 7);
}
}
#line 168 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool succeeds_in_context(int constraint , int prev , int curr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 171
  if (curr & 1) {
    {
#line 171
    tmp = other_constraint(constraint);
#line 171
    tmp___0 = tmp;
    }
  } else {
#line 171
    tmp___0 = 0;
  }
#line 171
  if (curr & 2) {
    {
#line 171
    tmp___1 = letter_constraint(constraint);
#line 171
    tmp___2 = tmp___1;
    }
  } else {
#line 171
    tmp___2 = 0;
  }
#line 171
  if (curr & 4) {
    {
#line 171
    tmp___3 = newline_constraint(constraint);
#line 171
    tmp___4 = tmp___3;
    }
  } else {
#line 171
    tmp___4 = 0;
  }
#line 171
  if (((tmp___0 | tmp___2) | tmp___4) & prev) {
#line 171
    tmp___5 = 1;
  } else {
#line 171
    tmp___5 = 0;
  }
#line 171
  return ((_Bool )tmp___5);
}
}
#line 178 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool prev_newline_dependent(int constraint ) 
{ 


  {
#line 181
  return ((_Bool )(((constraint ^ (constraint >> 2)) & 73) != 0));
}
}
#line 183 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool prev_letter_dependent(int constraint ) 
{ 


  {
#line 186
  return ((_Bool )(((constraint ^ (constraint >> 1)) & 73) != 0));
}
}
#line 209 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static long const   TOKEN_MAX  =    (ptrdiff_t const   )9223372036854775807L;
#line 565 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool accepting(state_num s , struct dfa  const  *r ) 
{ 


  {
#line 568
  return ((_Bool )((int )(r->states + s)->constraint != 0));
}
}
#line 572 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool accepts_in_context(int prev , int curr , state_num state , struct dfa  const  *dfa ) 
{ 
  _Bool tmp ;

  {
  {
#line 575
  tmp = succeeds_in_context((int )(dfa->states + state)->constraint, prev, curr);
  }
#line 575
  return (tmp);
}
}
#line 578
static void regexp(struct dfa *dfa ) ;
#line 597 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static size_t mbs_to_wchar(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 600
  uc = (unsigned char )*(s + 0);
#line 601
  wc = d->localeinfo.sbctowc[uc];
#line 603
  if (wc == 4294967295U) {
    {
#line 606
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 606
    nbytes = tmp;
    }
#line 607
    if (0UL < nbytes) {
#line 607
      if (nbytes < 0xfffffffffffffffeUL) {
#line 609
        *pwc = (wint_t )wch;
#line 610
        return (nbytes);
      }
    }
    {
#line 612
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 615
  *pwc = wc;
#line 616
  return ((size_t )1);
}
}
#line 698 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool tstbit(unsigned int b , charclass const   *c ) 
{ 


  {
#line 701
  return ((_Bool )((c->w[b / 64U] >> b % 64U) & 1UL));
}
}
#line 704 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void setbit(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 707
  one = (charclass_word )1;
#line 708
  c->w[b / 64U] |= one << b % 64U;
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void clrbit(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 714
  one = (charclass_word )1;
#line 715
  c->w[b / 64U] &= ~ (one << b % 64U);
#line 716
  return;
}
}
#line 718 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void zeroset(charclass *s ) 
{ 


  {
  {
#line 721
  memset((void *)s, 0, sizeof(*s));
  }
#line 722
  return;
}
}
#line 724 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void fillset(charclass *s ) 
{ 
  int i ;

  {
#line 727
  i = 0;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! (i < 4)) {
#line 727
      goto while_break;
    }
#line 728
    s->w[i] = (charclass_word )CHARCLASS_WORD_MASK;
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return;
}
}
#line 731 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void notset(charclass *s ) 
{ 
  int i ;

  {
#line 734
  i = 0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (i < 4)) {
#line 734
      goto while_break;
    }
#line 735
    s->w[i] = (charclass_word )(CHARCLASS_WORD_MASK & (unsigned long const   )(~ s->w[i]));
#line 734
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return;
}
}
#line 738 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool equal(charclass const   *s1 , charclass const   *s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 741
  w = (charclass_word )0;
#line 742
  i = 0;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! (i < 4)) {
#line 742
      goto while_break;
    }
#line 743
    w |= s1->w[i] ^ s2->w[i];
#line 742
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return ((_Bool )(w == 0UL));
}
}
#line 747 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool emptyset(charclass const   *s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 750
  w = (charclass_word )0;
#line 751
  i = 0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (i < 4)) {
#line 751
      goto while_break;
    }
#line 752
    w |= s->w[i];
#line 751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return ((_Bool )(w == 0UL));
}
}
#line 772 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void *xpalloc(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min , ptrdiff_t nitems_max ,
                     ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 776
  n0 = *nitems;
#line 789
  if (sizeof(n) == sizeof(signed char )) {
#line 789
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 789
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 789
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 789
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 789
        tmp___7 = tmp___4;
      } else {
#line 789
        if ((int )((signed char )n0) < 0) {
#line 789
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 789
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 789
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 789
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 789
          tmp___6 = tmp___5;
        }
#line 789
        tmp___7 = tmp___6;
      }
#line 789
      if (tmp___7) {
#line 789
        goto _L;
      } else
#line 789
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 789
        goto _L;
      } else
#line 789
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
        _L: /* CIL Label */ 
#line 789
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 789
        tmp___3 = 1;
      } else {
#line 789
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 789
        tmp___3 = 0;
      }
#line 789
      tmp___17 = tmp___3;
    } else {
#line 789
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
        if (n0 >> 1 < 0L) {
#line 789
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 789
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 789
        tmp___16 = tmp___13;
      } else {
#line 789
        if (n0 < 0L) {
#line 789
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 789
          if (n0 >> 1 < 0L) {
#line 789
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 789
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 789
          tmp___15 = tmp___14;
        }
#line 789
        tmp___16 = tmp___15;
      }
#line 789
      if (tmp___16) {
#line 789
        goto _L___0;
      } else
#line 789
      if (n0 + (n0 >> 1) < -128L) {
#line 789
        goto _L___0;
      } else
#line 789
      if (127L < n0 + (n0 >> 1)) {
        _L___0: /* CIL Label */ 
#line 789
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 789
        tmp___12 = 1;
      } else {
#line 789
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 789
        tmp___12 = 0;
      }
#line 789
      tmp___17 = tmp___12;
    }
#line 789
    tmp___97 = tmp___17;
  } else {
#line 789
    if (sizeof(n) == sizeof(short )) {
#line 789
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 789
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
          if ((int )((short )(n0 >> 1)) < 0) {
#line 789
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 789
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 789
          tmp___26 = tmp___23;
        } else {
#line 789
          if ((int )((short )n0) < 0) {
#line 789
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 789
            if ((int )((short )(n0 >> 1)) < 0) {
#line 789
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 789
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 789
            tmp___25 = tmp___24;
          }
#line 789
          tmp___26 = tmp___25;
        }
#line 789
        if (tmp___26) {
#line 789
          goto _L___1;
        } else
#line 789
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 789
          goto _L___1;
        } else
#line 789
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
          _L___1: /* CIL Label */ 
#line 789
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 789
          tmp___22 = 1;
        } else {
#line 789
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 789
          tmp___22 = 0;
        }
#line 789
        tmp___36 = tmp___22;
      } else {
#line 789
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
          if (n0 >> 1 < 0L) {
#line 789
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 789
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 789
          tmp___35 = tmp___32;
        } else {
#line 789
          if (n0 < 0L) {
#line 789
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 789
            if (n0 >> 1 < 0L) {
#line 789
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 789
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 789
            tmp___34 = tmp___33;
          }
#line 789
          tmp___35 = tmp___34;
        }
#line 789
        if (tmp___35) {
#line 789
          goto _L___2;
        } else
#line 789
        if (n0 + (n0 >> 1) < -32768L) {
#line 789
          goto _L___2;
        } else
#line 789
        if (32767L < n0 + (n0 >> 1)) {
          _L___2: /* CIL Label */ 
#line 789
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 789
          tmp___31 = 1;
        } else {
#line 789
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 789
          tmp___31 = 0;
        }
#line 789
        tmp___36 = tmp___31;
      }
#line 789
      tmp___96 = tmp___36;
    } else {
#line 789
      if (sizeof(n) == sizeof(int )) {
#line 789
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 789
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
            if ((int )(n0 >> 1) < 0) {
#line 789
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 789
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 789
            tmp___45 = tmp___42;
          } else {
#line 789
            if ((int )n0 < 0) {
#line 789
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 789
              if ((int )(n0 >> 1) < 0) {
#line 789
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 789
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 789
              tmp___44 = tmp___43;
            }
#line 789
            tmp___45 = tmp___44;
          }
#line 789
          if (tmp___45) {
#line 789
            goto _L___3;
          } else
#line 789
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 789
            goto _L___3;
          } else
#line 789
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
            _L___3: /* CIL Label */ 
#line 789
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___41 = 1;
          } else {
#line 789
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___41 = 0;
          }
#line 789
          tmp___55 = tmp___41;
        } else {
#line 789
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
            if (n0 >> 1 < 0L) {
#line 789
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 789
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 789
            tmp___54 = tmp___51;
          } else {
#line 789
            if (n0 < 0L) {
#line 789
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 789
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 789
              tmp___53 = tmp___52;
            }
#line 789
            tmp___54 = tmp___53;
          }
#line 789
          if (tmp___54) {
#line 789
            goto _L___4;
          } else
#line 789
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 789
            goto _L___4;
          } else
#line 789
          if (2147483647L < n0 + (n0 >> 1)) {
            _L___4: /* CIL Label */ 
#line 789
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___50 = 1;
          } else {
#line 789
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___50 = 0;
          }
#line 789
          tmp___55 = tmp___50;
        }
#line 789
        tmp___95 = tmp___55;
      } else {
#line 789
        if (sizeof(n) == sizeof(long )) {
#line 789
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___64 = tmp___61;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___63 = tmp___62;
              }
#line 789
              tmp___64 = tmp___63;
            }
#line 789
            if (tmp___64) {
#line 789
              goto _L___5;
            } else
#line 789
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___5;
            } else
#line 789
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___5: /* CIL Label */ 
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___60 = 1;
            } else {
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___60 = 0;
            }
#line 789
            tmp___74 = tmp___60;
          } else {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___73 = tmp___70;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___72 = tmp___71;
              }
#line 789
              tmp___73 = tmp___72;
            }
#line 789
            if (tmp___73) {
#line 789
              goto _L___6;
            } else
#line 789
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___6;
            } else
#line 789
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___6: /* CIL Label */ 
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___69 = 1;
            } else {
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___69 = 0;
            }
#line 789
            tmp___74 = tmp___69;
          }
#line 789
          tmp___94 = tmp___74;
        } else {
#line 789
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 789
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 789
              if ((long long )(n0 >> 1) < 0LL) {
#line 789
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 789
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 789
              tmp___83 = tmp___80;
            } else {
#line 789
              if ((long long )n0 < 0LL) {
#line 789
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 789
                if ((long long )(n0 >> 1) < 0LL) {
#line 789
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 789
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 789
                tmp___82 = tmp___81;
              }
#line 789
              tmp___83 = tmp___82;
            }
#line 789
            if (tmp___83) {
#line 789
              goto _L___7;
            } else
#line 789
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___7;
            } else
#line 789
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
              _L___7: /* CIL Label */ 
#line 789
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___79 = 1;
            } else {
#line 789
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___79 = 0;
            }
#line 789
            tmp___93 = tmp___79;
          } else {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___92 = tmp___89;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___91 = tmp___90;
              }
#line 789
              tmp___92 = tmp___91;
            }
#line 789
            if (tmp___92) {
#line 789
              goto _L___8;
            } else
#line 789
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___8;
            } else
#line 789
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
              _L___8: /* CIL Label */ 
#line 789
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___88 = 1;
            } else {
#line 789
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___88 = 0;
            }
#line 789
            tmp___93 = tmp___88;
          }
#line 789
          tmp___94 = tmp___93;
        }
#line 789
        tmp___95 = tmp___94;
      }
#line 789
      tmp___96 = tmp___95;
    }
#line 789
    tmp___97 = tmp___96;
  }
#line 789
  if (tmp___97) {
#line 790
    n = 9223372036854775807L;
  }
#line 791
  if (0L <= nitems_max) {
#line 791
    if (nitems_max < n) {
#line 792
      n = nitems_max;
    }
  }
#line 794
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 794
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 794
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
        if ((int )((signed char )n) < 0) {
#line 794
          if (0 < (int )((signed char )item_size)) {
#line 794
            goto _L___39;
          } else {
#line 794
            goto _L___41;
          }
        } else
        _L___41: /* CIL Label */ 
#line 794
        if ((int )((signed char )item_size) < 0) {
#line 794
          if (0 < (int )((signed char )n)) {
#line 794
            goto _L___39;
          } else {
#line 794
            goto _L___40;
          }
        } else {
#line 794
          goto _L___40;
        }
      } else {
        _L___40: /* CIL Label */ 
#line 794
        if ((int )((signed char )item_size) < 0) {
#line 794
          if ((int )((signed char )n) < 0) {
#line 794
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 794
            if ((int )((signed char )item_size) == -1) {
#line 794
              tmp___225 = 0;
            } else {
#line 794
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 794
            tmp___226 = tmp___225;
          }
#line 794
          tmp___229 = tmp___226;
        } else {
#line 794
          if ((int )((signed char )item_size) == 0) {
#line 794
            tmp___228 = 0;
          } else {
#line 794
            if ((int )((signed char )n) < 0) {
#line 794
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 794
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 794
            tmp___228 = tmp___227;
          }
#line 794
          tmp___229 = tmp___228;
        }
#line 794
        if (tmp___229) {
#line 794
          goto _L___39;
        } else
#line 794
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 794
          goto _L___39;
        } else
#line 794
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
          _L___39: /* CIL Label */ 
#line 794
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 794
          tmp___224 = 1;
        } else {
#line 794
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 794
          tmp___224 = 0;
        }
      }
#line 794
      tmp___241 = tmp___224;
    } else {
#line 794
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
        if (n < 0L) {
#line 794
          if (0L < item_size) {
#line 794
            goto _L___42;
          } else {
#line 794
            goto _L___44;
          }
        } else
        _L___44: /* CIL Label */ 
#line 794
        if (item_size < 0L) {
#line 794
          if (0L < n) {
#line 794
            goto _L___42;
          } else {
#line 794
            goto _L___43;
          }
        } else {
#line 794
          goto _L___43;
        }
      } else {
        _L___43: /* CIL Label */ 
#line 794
        if (item_size < 0L) {
#line 794
          if (n < 0L) {
#line 794
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 794
            if (item_size == -1L) {
#line 794
              tmp___236 = 0;
            } else {
#line 794
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 794
            tmp___237 = tmp___236;
          }
#line 794
          tmp___240 = tmp___237;
        } else {
#line 794
          if (item_size == 0L) {
#line 794
            tmp___239 = 0;
          } else {
#line 794
            if (n < 0L) {
#line 794
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 794
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 794
            tmp___239 = tmp___238;
          }
#line 794
          tmp___240 = tmp___239;
        }
#line 794
        if (tmp___240) {
#line 794
          goto _L___42;
        } else
#line 794
        if (n * item_size < -128L) {
#line 794
          goto _L___42;
        } else
#line 794
        if (127L < n * item_size) {
          _L___42: /* CIL Label */ 
#line 794
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 794
          tmp___235 = 1;
        } else {
#line 794
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 794
          tmp___235 = 0;
        }
      }
#line 794
      tmp___241 = tmp___235;
    }
#line 794
    tmp___337 = tmp___241;
  } else {
#line 794
    if (sizeof(nbytes) == sizeof(short )) {
#line 794
      if (sizeof(n * item_size) < sizeof(short )) {
#line 794
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
          if ((int )((short )n) < 0) {
#line 794
            if (0 < (int )((short )item_size)) {
#line 794
              goto _L___45;
            } else {
#line 794
              goto _L___47;
            }
          } else
          _L___47: /* CIL Label */ 
#line 794
          if ((int )((short )item_size) < 0) {
#line 794
            if (0 < (int )((short )n)) {
#line 794
              goto _L___45;
            } else {
#line 794
              goto _L___46;
            }
          } else {
#line 794
            goto _L___46;
          }
        } else {
          _L___46: /* CIL Label */ 
#line 794
          if ((int )((short )item_size) < 0) {
#line 794
            if ((int )((short )n) < 0) {
#line 794
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 794
              if ((int )((short )item_size) == -1) {
#line 794
                tmp___248 = 0;
              } else {
#line 794
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 794
              tmp___249 = tmp___248;
            }
#line 794
            tmp___252 = tmp___249;
          } else {
#line 794
            if ((int )((short )item_size) == 0) {
#line 794
              tmp___251 = 0;
            } else {
#line 794
              if ((int )((short )n) < 0) {
#line 794
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 794
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 794
              tmp___251 = tmp___250;
            }
#line 794
            tmp___252 = tmp___251;
          }
#line 794
          if (tmp___252) {
#line 794
            goto _L___45;
          } else
#line 794
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 794
            goto _L___45;
          } else
#line 794
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
            _L___45: /* CIL Label */ 
#line 794
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 794
            tmp___247 = 1;
          } else {
#line 794
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 794
            tmp___247 = 0;
          }
        }
#line 794
        tmp___264 = tmp___247;
      } else {
#line 794
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
          if (n < 0L) {
#line 794
            if (0L < item_size) {
#line 794
              goto _L___48;
            } else {
#line 794
              goto _L___50;
            }
          } else
          _L___50: /* CIL Label */ 
#line 794
          if (item_size < 0L) {
#line 794
            if (0L < n) {
#line 794
              goto _L___48;
            } else {
#line 794
              goto _L___49;
            }
          } else {
#line 794
            goto _L___49;
          }
        } else {
          _L___49: /* CIL Label */ 
#line 794
          if (item_size < 0L) {
#line 794
            if (n < 0L) {
#line 794
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 794
              if (item_size == -1L) {
#line 794
                tmp___259 = 0;
              } else {
#line 794
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 794
              tmp___260 = tmp___259;
            }
#line 794
            tmp___263 = tmp___260;
          } else {
#line 794
            if (item_size == 0L) {
#line 794
              tmp___262 = 0;
            } else {
#line 794
              if (n < 0L) {
#line 794
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 794
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 794
              tmp___262 = tmp___261;
            }
#line 794
            tmp___263 = tmp___262;
          }
#line 794
          if (tmp___263) {
#line 794
            goto _L___48;
          } else
#line 794
          if (n * item_size < -32768L) {
#line 794
            goto _L___48;
          } else
#line 794
          if (32767L < n * item_size) {
            _L___48: /* CIL Label */ 
#line 794
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 794
            tmp___258 = 1;
          } else {
#line 794
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 794
            tmp___258 = 0;
          }
        }
#line 794
        tmp___264 = tmp___258;
      }
#line 794
      tmp___336 = tmp___264;
    } else {
#line 794
      if (sizeof(nbytes) == sizeof(int )) {
#line 794
        if (sizeof(n * item_size) < sizeof(int )) {
#line 794
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
            if ((int )n < 0) {
#line 794
              if (0 < (int )item_size) {
#line 794
                goto _L___51;
              } else {
#line 794
                goto _L___53;
              }
            } else
            _L___53: /* CIL Label */ 
#line 794
            if ((int )item_size < 0) {
#line 794
              if (0 < (int )n) {
#line 794
                goto _L___51;
              } else {
#line 794
                goto _L___52;
              }
            } else {
#line 794
              goto _L___52;
            }
          } else {
            _L___52: /* CIL Label */ 
#line 794
            if ((int )item_size < 0) {
#line 794
              if ((int )n < 0) {
#line 794
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 794
                if ((int )item_size == -1) {
#line 794
                  tmp___271 = 0;
                } else {
#line 794
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 794
                tmp___272 = tmp___271;
              }
#line 794
              tmp___275 = tmp___272;
            } else {
#line 794
              if ((int )item_size == 0) {
#line 794
                tmp___274 = 0;
              } else {
#line 794
                if ((int )n < 0) {
#line 794
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 794
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 794
                tmp___274 = tmp___273;
              }
#line 794
              tmp___275 = tmp___274;
            }
#line 794
            if (tmp___275) {
#line 794
              goto _L___51;
            } else
#line 794
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 794
              goto _L___51;
            } else
#line 794
            if (2147483647 < (int )n * (int )item_size) {
              _L___51: /* CIL Label */ 
#line 794
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___270 = 1;
            } else {
#line 794
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___270 = 0;
            }
          }
#line 794
          tmp___287 = tmp___270;
        } else {
#line 794
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
            if (n < 0L) {
#line 794
              if (0L < item_size) {
#line 794
                goto _L___54;
              } else {
#line 794
                goto _L___56;
              }
            } else
            _L___56: /* CIL Label */ 
#line 794
            if (item_size < 0L) {
#line 794
              if (0L < n) {
#line 794
                goto _L___54;
              } else {
#line 794
                goto _L___55;
              }
            } else {
#line 794
              goto _L___55;
            }
          } else {
            _L___55: /* CIL Label */ 
#line 794
            if (item_size < 0L) {
#line 794
              if (n < 0L) {
#line 794
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 794
                if (item_size == -1L) {
#line 794
                  tmp___282 = 0;
                } else {
#line 794
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 794
                tmp___283 = tmp___282;
              }
#line 794
              tmp___286 = tmp___283;
            } else {
#line 794
              if (item_size == 0L) {
#line 794
                tmp___285 = 0;
              } else {
#line 794
                if (n < 0L) {
#line 794
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 794
                tmp___285 = tmp___284;
              }
#line 794
              tmp___286 = tmp___285;
            }
#line 794
            if (tmp___286) {
#line 794
              goto _L___54;
            } else
#line 794
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 794
              goto _L___54;
            } else
#line 794
            if (2147483647L < n * item_size) {
              _L___54: /* CIL Label */ 
#line 794
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___281 = 1;
            } else {
#line 794
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___281 = 0;
            }
          }
#line 794
          tmp___287 = tmp___281;
        }
#line 794
        tmp___335 = tmp___287;
      } else {
#line 794
        if (sizeof(nbytes) == sizeof(long )) {
#line 794
          if (sizeof(n * item_size) < sizeof(long )) {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___57;
                } else {
#line 794
                  goto _L___59;
                }
              } else
              _L___59: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___57;
                } else {
#line 794
                  goto _L___58;
                }
              } else {
#line 794
                goto _L___58;
              }
            } else {
              _L___58: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___294 = 0;
                  } else {
#line 794
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___295 = tmp___294;
                }
#line 794
                tmp___298 = tmp___295;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___297 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___297 = tmp___296;
                }
#line 794
                tmp___298 = tmp___297;
              }
#line 794
              if (tmp___298) {
#line 794
                goto _L___57;
              } else
#line 794
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___57;
              } else
#line 794
              if (9223372036854775807L < n * item_size) {
                _L___57: /* CIL Label */ 
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___293 = 1;
              } else {
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___293 = 0;
              }
            }
#line 794
            tmp___310 = tmp___293;
          } else {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___60;
                } else {
#line 794
                  goto _L___62;
                }
              } else
              _L___62: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___60;
                } else {
#line 794
                  goto _L___61;
                }
              } else {
#line 794
                goto _L___61;
              }
            } else {
              _L___61: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___305 = 0;
                  } else {
#line 794
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___306 = tmp___305;
                }
#line 794
                tmp___309 = tmp___306;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___308 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___308 = tmp___307;
                }
#line 794
                tmp___309 = tmp___308;
              }
#line 794
              if (tmp___309) {
#line 794
                goto _L___60;
              } else
#line 794
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___60;
              } else
#line 794
              if (9223372036854775807L < n * item_size) {
                _L___60: /* CIL Label */ 
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___304 = 1;
              } else {
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___304 = 0;
              }
            }
#line 794
            tmp___310 = tmp___304;
          }
#line 794
          tmp___334 = tmp___310;
        } else {
#line 794
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 794
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 794
              if ((long long )n < 0LL) {
#line 794
                if (0LL < (long long )item_size) {
#line 794
                  goto _L___63;
                } else {
#line 794
                  goto _L___65;
                }
              } else
              _L___65: /* CIL Label */ 
#line 794
              if ((long long )item_size < 0LL) {
#line 794
                if (0LL < (long long )n) {
#line 794
                  goto _L___63;
                } else {
#line 794
                  goto _L___64;
                }
              } else {
#line 794
                goto _L___64;
              }
            } else {
              _L___64: /* CIL Label */ 
#line 794
              if ((long long )item_size < 0LL) {
#line 794
                if ((long long )n < 0LL) {
#line 794
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 794
                  if ((long long )item_size == -1LL) {
#line 794
                    tmp___317 = 0;
                  } else {
#line 794
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 794
                  tmp___318 = tmp___317;
                }
#line 794
                tmp___321 = tmp___318;
              } else {
#line 794
                if ((long long )item_size == 0LL) {
#line 794
                  tmp___320 = 0;
                } else {
#line 794
                  if ((long long )n < 0LL) {
#line 794
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 794
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 794
                  tmp___320 = tmp___319;
                }
#line 794
                tmp___321 = tmp___320;
              }
#line 794
              if (tmp___321) {
#line 794
                goto _L___63;
              } else
#line 794
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___63;
              } else
#line 794
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
                _L___63: /* CIL Label */ 
#line 794
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___316 = 1;
              } else {
#line 794
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___316 = 0;
              }
            }
#line 794
            tmp___333 = tmp___316;
          } else {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___66;
                } else {
#line 794
                  goto _L___68;
                }
              } else
              _L___68: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___66;
                } else {
#line 794
                  goto _L___67;
                }
              } else {
#line 794
                goto _L___67;
              }
            } else {
              _L___67: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___328 = 0;
                  } else {
#line 794
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___329 = tmp___328;
                }
#line 794
                tmp___332 = tmp___329;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___331 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___331 = tmp___330;
                }
#line 794
                tmp___332 = tmp___331;
              }
#line 794
              if (tmp___332) {
#line 794
                goto _L___66;
              } else
#line 794
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___66;
              } else
#line 794
              if (9223372036854775807LL < (long long )(n * item_size)) {
                _L___66: /* CIL Label */ 
#line 794
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___327 = 1;
              } else {
#line 794
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___327 = 0;
              }
            }
#line 794
            tmp___333 = tmp___327;
          }
#line 794
          tmp___334 = tmp___333;
        }
#line 794
        tmp___335 = tmp___334;
      }
#line 794
      tmp___336 = tmp___335;
    }
#line 794
    tmp___337 = tmp___336;
  }
#line 794
  if (tmp___337) {
#line 794
    tmp___218 = 9223372036854775807UL;
  } else
#line 794
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 794
    tmp___218 = 9223372036854775807UL;
  } else {
#line 794
    if (nbytes < 128L) {
#line 794
      tmp___217 = 128;
    } else {
#line 794
      tmp___217 = 0;
    }
#line 794
    tmp___218 = (unsigned long )tmp___217;
  }
#line 794
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 798
  if (adjusted_nbytes) {
#line 800
    n = adjusted_nbytes / item_size;
#line 801
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 804
  if (! pa) {
#line 805
    *nitems = (ptrdiff_t )0;
  }
#line 806
  if (n - n0 < nitems_incr_min) {
#line 806
    if (sizeof(n) == sizeof(signed char )) {
#line 806
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 806
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 806
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 806
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 806
          tmp___346 = tmp___343;
        } else {
#line 806
          if ((int )((signed char )n0) < 0) {
#line 806
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 806
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 806
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 806
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 806
            tmp___345 = tmp___344;
          }
#line 806
          tmp___346 = tmp___345;
        }
#line 806
        if (tmp___346) {
#line 806
          goto _L___69;
        } else
#line 806
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 806
          goto _L___69;
        } else
#line 806
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
          _L___69: /* CIL Label */ 
#line 806
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 806
          tmp___342 = 1;
        } else {
#line 806
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 806
          tmp___342 = 0;
        }
#line 806
        tmp___356 = tmp___342;
      } else {
#line 806
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
          if (nitems_incr_min < 0L) {
#line 806
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 806
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 806
          tmp___355 = tmp___352;
        } else {
#line 806
          if (n0 < 0L) {
#line 806
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 806
            if (nitems_incr_min < 0L) {
#line 806
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 806
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 806
            tmp___354 = tmp___353;
          }
#line 806
          tmp___355 = tmp___354;
        }
#line 806
        if (tmp___355) {
#line 806
          goto _L___70;
        } else
#line 806
        if (n0 + nitems_incr_min < -128L) {
#line 806
          goto _L___70;
        } else
#line 806
        if (127L < n0 + nitems_incr_min) {
          _L___70: /* CIL Label */ 
#line 806
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 806
          tmp___351 = 1;
        } else {
#line 806
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 806
          tmp___351 = 0;
        }
#line 806
        tmp___356 = tmp___351;
      }
#line 806
      tmp___436 = tmp___356;
    } else {
#line 806
      if (sizeof(n) == sizeof(short )) {
#line 806
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 806
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
            if ((int )((short )nitems_incr_min) < 0) {
#line 806
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 806
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 806
            tmp___365 = tmp___362;
          } else {
#line 806
            if ((int )((short )n0) < 0) {
#line 806
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 806
              if ((int )((short )nitems_incr_min) < 0) {
#line 806
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 806
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 806
              tmp___364 = tmp___363;
            }
#line 806
            tmp___365 = tmp___364;
          }
#line 806
          if (tmp___365) {
#line 806
            goto _L___71;
          } else
#line 806
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 806
            goto _L___71;
          } else
#line 806
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
            _L___71: /* CIL Label */ 
#line 806
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 806
            tmp___361 = 1;
          } else {
#line 806
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 806
            tmp___361 = 0;
          }
#line 806
          tmp___375 = tmp___361;
        } else {
#line 806
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
            if (nitems_incr_min < 0L) {
#line 806
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 806
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 806
            tmp___374 = tmp___371;
          } else {
#line 806
            if (n0 < 0L) {
#line 806
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 806
              if (nitems_incr_min < 0L) {
#line 806
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 806
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 806
              tmp___373 = tmp___372;
            }
#line 806
            tmp___374 = tmp___373;
          }
#line 806
          if (tmp___374) {
#line 806
            goto _L___72;
          } else
#line 806
          if (n0 + nitems_incr_min < -32768L) {
#line 806
            goto _L___72;
          } else
#line 806
          if (32767L < n0 + nitems_incr_min) {
            _L___72: /* CIL Label */ 
#line 806
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 806
            tmp___370 = 1;
          } else {
#line 806
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 806
            tmp___370 = 0;
          }
#line 806
          tmp___375 = tmp___370;
        }
#line 806
        tmp___435 = tmp___375;
      } else {
#line 806
        if (sizeof(n) == sizeof(int )) {
#line 806
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 806
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
              if ((int )nitems_incr_min < 0) {
#line 806
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 806
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 806
              tmp___384 = tmp___381;
            } else {
#line 806
              if ((int )n0 < 0) {
#line 806
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 806
                if ((int )nitems_incr_min < 0) {
#line 806
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 806
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 806
                tmp___383 = tmp___382;
              }
#line 806
              tmp___384 = tmp___383;
            }
#line 806
            if (tmp___384) {
#line 806
              goto _L___73;
            } else
#line 806
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 806
              goto _L___73;
            } else
#line 806
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
              _L___73: /* CIL Label */ 
#line 806
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___380 = 1;
            } else {
#line 806
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___380 = 0;
            }
#line 806
            tmp___394 = tmp___380;
          } else {
#line 806
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
              if (nitems_incr_min < 0L) {
#line 806
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 806
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 806
              tmp___393 = tmp___390;
            } else {
#line 806
              if (n0 < 0L) {
#line 806
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 806
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 806
                tmp___392 = tmp___391;
              }
#line 806
              tmp___393 = tmp___392;
            }
#line 806
            if (tmp___393) {
#line 806
              goto _L___74;
            } else
#line 806
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 806
              goto _L___74;
            } else
#line 806
            if (2147483647L < n0 + nitems_incr_min) {
              _L___74: /* CIL Label */ 
#line 806
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___389 = 1;
            } else {
#line 806
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___389 = 0;
            }
#line 806
            tmp___394 = tmp___389;
          }
#line 806
          tmp___434 = tmp___394;
        } else {
#line 806
          if (sizeof(n) == sizeof(long )) {
#line 806
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___403 = tmp___400;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___402 = tmp___401;
                }
#line 806
                tmp___403 = tmp___402;
              }
#line 806
              if (tmp___403) {
#line 806
                goto _L___75;
              } else
#line 806
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___75;
              } else
#line 806
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___75: /* CIL Label */ 
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___399 = 1;
              } else {
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___399 = 0;
              }
#line 806
              tmp___413 = tmp___399;
            } else {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___412 = tmp___409;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___411 = tmp___410;
                }
#line 806
                tmp___412 = tmp___411;
              }
#line 806
              if (tmp___412) {
#line 806
                goto _L___76;
              } else
#line 806
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___76;
              } else
#line 806
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___76: /* CIL Label */ 
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___408 = 1;
              } else {
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___408 = 0;
              }
#line 806
              tmp___413 = tmp___408;
            }
#line 806
            tmp___433 = tmp___413;
          } else {
#line 806
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 806
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 806
                if ((long long )nitems_incr_min < 0LL) {
#line 806
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 806
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 806
                tmp___422 = tmp___419;
              } else {
#line 806
                if ((long long )n0 < 0LL) {
#line 806
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 806
                  if ((long long )nitems_incr_min < 0LL) {
#line 806
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 806
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 806
                  tmp___421 = tmp___420;
                }
#line 806
                tmp___422 = tmp___421;
              }
#line 806
              if (tmp___422) {
#line 806
                goto _L___77;
              } else
#line 806
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___77;
              } else
#line 806
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
                _L___77: /* CIL Label */ 
#line 806
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___418 = 1;
              } else {
#line 806
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___418 = 0;
              }
#line 806
              tmp___432 = tmp___418;
            } else {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___431 = tmp___428;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___430 = tmp___429;
                }
#line 806
                tmp___431 = tmp___430;
              }
#line 806
              if (tmp___431) {
#line 806
                goto _L___78;
              } else
#line 806
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___78;
              } else
#line 806
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
                _L___78: /* CIL Label */ 
#line 806
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___427 = 1;
              } else {
#line 806
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___427 = 0;
              }
#line 806
              tmp___432 = tmp___427;
            }
#line 806
            tmp___433 = tmp___432;
          }
#line 806
          tmp___434 = tmp___433;
        }
#line 806
        tmp___435 = tmp___434;
      }
#line 806
      tmp___436 = tmp___435;
    }
#line 806
    if (tmp___436) {
      {
#line 810
      xalloc_die();
      }
    } else
#line 806
    if (0L <= nitems_max) {
#line 806
      if (nitems_max < n) {
        {
#line 810
        xalloc_die();
        }
      } else {
#line 806
        goto _L___109;
      }
    } else {
      _L___109: /* CIL Label */ 
#line 806
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 806
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 806
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
            if ((int )((signed char )n) < 0) {
#line 806
              if (0 < (int )((signed char )item_size)) {
#line 806
                goto _L___79;
              } else {
#line 806
                goto _L___81;
              }
            } else
            _L___81: /* CIL Label */ 
#line 806
            if ((int )((signed char )item_size) < 0) {
#line 806
              if (0 < (int )((signed char )n)) {
#line 806
                goto _L___79;
              } else {
#line 806
                goto _L___80;
              }
            } else {
#line 806
              goto _L___80;
            }
          } else {
            _L___80: /* CIL Label */ 
#line 806
            if ((int )((signed char )item_size) < 0) {
#line 806
              if ((int )((signed char )n) < 0) {
#line 806
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 806
                if ((int )((signed char )item_size) == -1) {
#line 806
                  tmp___443 = 0;
                } else {
#line 806
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 806
                tmp___444 = tmp___443;
              }
#line 806
              tmp___447 = tmp___444;
            } else {
#line 806
              if ((int )((signed char )item_size) == 0) {
#line 806
                tmp___446 = 0;
              } else {
#line 806
                if ((int )((signed char )n) < 0) {
#line 806
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 806
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 806
                tmp___446 = tmp___445;
              }
#line 806
              tmp___447 = tmp___446;
            }
#line 806
            if (tmp___447) {
#line 806
              goto _L___79;
            } else
#line 806
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 806
              goto _L___79;
            } else
#line 806
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
              _L___79: /* CIL Label */ 
#line 806
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 806
              tmp___442 = 1;
            } else {
#line 806
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 806
              tmp___442 = 0;
            }
          }
#line 806
          tmp___459 = tmp___442;
        } else {
#line 806
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
            if (n < 0L) {
#line 806
              if (0L < item_size) {
#line 806
                goto _L___82;
              } else {
#line 806
                goto _L___84;
              }
            } else
            _L___84: /* CIL Label */ 
#line 806
            if (item_size < 0L) {
#line 806
              if (0L < n) {
#line 806
                goto _L___82;
              } else {
#line 806
                goto _L___83;
              }
            } else {
#line 806
              goto _L___83;
            }
          } else {
            _L___83: /* CIL Label */ 
#line 806
            if (item_size < 0L) {
#line 806
              if (n < 0L) {
#line 806
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 806
                if (item_size == -1L) {
#line 806
                  tmp___454 = 0;
                } else {
#line 806
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 806
                tmp___455 = tmp___454;
              }
#line 806
              tmp___458 = tmp___455;
            } else {
#line 806
              if (item_size == 0L) {
#line 806
                tmp___457 = 0;
              } else {
#line 806
                if (n < 0L) {
#line 806
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 806
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 806
                tmp___457 = tmp___456;
              }
#line 806
              tmp___458 = tmp___457;
            }
#line 806
            if (tmp___458) {
#line 806
              goto _L___82;
            } else
#line 806
            if (n * item_size < -128L) {
#line 806
              goto _L___82;
            } else
#line 806
            if (127L < n * item_size) {
              _L___82: /* CIL Label */ 
#line 806
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 806
              tmp___453 = 1;
            } else {
#line 806
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 806
              tmp___453 = 0;
            }
          }
#line 806
          tmp___459 = tmp___453;
        }
#line 806
        tmp___555 = tmp___459;
      } else {
#line 806
        if (sizeof(nbytes) == sizeof(short )) {
#line 806
          if (sizeof(n * item_size) < sizeof(short )) {
#line 806
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
              if ((int )((short )n) < 0) {
#line 806
                if (0 < (int )((short )item_size)) {
#line 806
                  goto _L___85;
                } else {
#line 806
                  goto _L___87;
                }
              } else
              _L___87: /* CIL Label */ 
#line 806
              if ((int )((short )item_size) < 0) {
#line 806
                if (0 < (int )((short )n)) {
#line 806
                  goto _L___85;
                } else {
#line 806
                  goto _L___86;
                }
              } else {
#line 806
                goto _L___86;
              }
            } else {
              _L___86: /* CIL Label */ 
#line 806
              if ((int )((short )item_size) < 0) {
#line 806
                if ((int )((short )n) < 0) {
#line 806
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 806
                  if ((int )((short )item_size) == -1) {
#line 806
                    tmp___466 = 0;
                  } else {
#line 806
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 806
                  tmp___467 = tmp___466;
                }
#line 806
                tmp___470 = tmp___467;
              } else {
#line 806
                if ((int )((short )item_size) == 0) {
#line 806
                  tmp___469 = 0;
                } else {
#line 806
                  if ((int )((short )n) < 0) {
#line 806
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 806
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 806
                  tmp___469 = tmp___468;
                }
#line 806
                tmp___470 = tmp___469;
              }
#line 806
              if (tmp___470) {
#line 806
                goto _L___85;
              } else
#line 806
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 806
                goto _L___85;
              } else
#line 806
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
                _L___85: /* CIL Label */ 
#line 806
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 806
                tmp___465 = 1;
              } else {
#line 806
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 806
                tmp___465 = 0;
              }
            }
#line 806
            tmp___482 = tmp___465;
          } else {
#line 806
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
              if (n < 0L) {
#line 806
                if (0L < item_size) {
#line 806
                  goto _L___88;
                } else {
#line 806
                  goto _L___90;
                }
              } else
              _L___90: /* CIL Label */ 
#line 806
              if (item_size < 0L) {
#line 806
                if (0L < n) {
#line 806
                  goto _L___88;
                } else {
#line 806
                  goto _L___89;
                }
              } else {
#line 806
                goto _L___89;
              }
            } else {
              _L___89: /* CIL Label */ 
#line 806
              if (item_size < 0L) {
#line 806
                if (n < 0L) {
#line 806
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 806
                  if (item_size == -1L) {
#line 806
                    tmp___477 = 0;
                  } else {
#line 806
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 806
                  tmp___478 = tmp___477;
                }
#line 806
                tmp___481 = tmp___478;
              } else {
#line 806
                if (item_size == 0L) {
#line 806
                  tmp___480 = 0;
                } else {
#line 806
                  if (n < 0L) {
#line 806
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 806
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 806
                  tmp___480 = tmp___479;
                }
#line 806
                tmp___481 = tmp___480;
              }
#line 806
              if (tmp___481) {
#line 806
                goto _L___88;
              } else
#line 806
              if (n * item_size < -32768L) {
#line 806
                goto _L___88;
              } else
#line 806
              if (32767L < n * item_size) {
                _L___88: /* CIL Label */ 
#line 806
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 806
                tmp___476 = 1;
              } else {
#line 806
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 806
                tmp___476 = 0;
              }
            }
#line 806
            tmp___482 = tmp___476;
          }
#line 806
          tmp___554 = tmp___482;
        } else {
#line 806
          if (sizeof(nbytes) == sizeof(int )) {
#line 806
            if (sizeof(n * item_size) < sizeof(int )) {
#line 806
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
                if ((int )n < 0) {
#line 806
                  if (0 < (int )item_size) {
#line 806
                    goto _L___91;
                  } else {
#line 806
                    goto _L___93;
                  }
                } else
                _L___93: /* CIL Label */ 
#line 806
                if ((int )item_size < 0) {
#line 806
                  if (0 < (int )n) {
#line 806
                    goto _L___91;
                  } else {
#line 806
                    goto _L___92;
                  }
                } else {
#line 806
                  goto _L___92;
                }
              } else {
                _L___92: /* CIL Label */ 
#line 806
                if ((int )item_size < 0) {
#line 806
                  if ((int )n < 0) {
#line 806
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 806
                    if ((int )item_size == -1) {
#line 806
                      tmp___489 = 0;
                    } else {
#line 806
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 806
                    tmp___490 = tmp___489;
                  }
#line 806
                  tmp___493 = tmp___490;
                } else {
#line 806
                  if ((int )item_size == 0) {
#line 806
                    tmp___492 = 0;
                  } else {
#line 806
                    if ((int )n < 0) {
#line 806
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 806
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 806
                    tmp___492 = tmp___491;
                  }
#line 806
                  tmp___493 = tmp___492;
                }
#line 806
                if (tmp___493) {
#line 806
                  goto _L___91;
                } else
#line 806
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 806
                  goto _L___91;
                } else
#line 806
                if (2147483647 < (int )n * (int )item_size) {
                  _L___91: /* CIL Label */ 
#line 806
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___488 = 1;
                } else {
#line 806
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___488 = 0;
                }
              }
#line 806
              tmp___505 = tmp___488;
            } else {
#line 806
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                if (n < 0L) {
#line 806
                  if (0L < item_size) {
#line 806
                    goto _L___94;
                  } else {
#line 806
                    goto _L___96;
                  }
                } else
                _L___96: /* CIL Label */ 
#line 806
                if (item_size < 0L) {
#line 806
                  if (0L < n) {
#line 806
                    goto _L___94;
                  } else {
#line 806
                    goto _L___95;
                  }
                } else {
#line 806
                  goto _L___95;
                }
              } else {
                _L___95: /* CIL Label */ 
#line 806
                if (item_size < 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 806
                    if (item_size == -1L) {
#line 806
                      tmp___500 = 0;
                    } else {
#line 806
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 806
                    tmp___501 = tmp___500;
                  }
#line 806
                  tmp___504 = tmp___501;
                } else {
#line 806
                  if (item_size == 0L) {
#line 806
                    tmp___503 = 0;
                  } else {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 806
                    tmp___503 = tmp___502;
                  }
#line 806
                  tmp___504 = tmp___503;
                }
#line 806
                if (tmp___504) {
#line 806
                  goto _L___94;
                } else
#line 806
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 806
                  goto _L___94;
                } else
#line 806
                if (2147483647L < n * item_size) {
                  _L___94: /* CIL Label */ 
#line 806
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___499 = 1;
                } else {
#line 806
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___499 = 0;
                }
              }
#line 806
              tmp___505 = tmp___499;
            }
#line 806
            tmp___553 = tmp___505;
          } else {
#line 806
            if (sizeof(nbytes) == sizeof(long )) {
#line 806
              if (sizeof(n * item_size) < sizeof(long )) {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___97;
                    } else {
#line 806
                      goto _L___99;
                    }
                  } else
                  _L___99: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___97;
                    } else {
#line 806
                      goto _L___98;
                    }
                  } else {
#line 806
                    goto _L___98;
                  }
                } else {
                  _L___98: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___512 = 0;
                      } else {
#line 806
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___513 = tmp___512;
                    }
#line 806
                    tmp___516 = tmp___513;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___515 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___515 = tmp___514;
                    }
#line 806
                    tmp___516 = tmp___515;
                  }
#line 806
                  if (tmp___516) {
#line 806
                    goto _L___97;
                  } else
#line 806
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___97;
                  } else
#line 806
                  if (9223372036854775807L < n * item_size) {
                    _L___97: /* CIL Label */ 
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___511 = 1;
                  } else {
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___511 = 0;
                  }
                }
#line 806
                tmp___528 = tmp___511;
              } else {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___100;
                    } else {
#line 806
                      goto _L___102;
                    }
                  } else
                  _L___102: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___100;
                    } else {
#line 806
                      goto _L___101;
                    }
                  } else {
#line 806
                    goto _L___101;
                  }
                } else {
                  _L___101: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___523 = 0;
                      } else {
#line 806
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___524 = tmp___523;
                    }
#line 806
                    tmp___527 = tmp___524;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___526 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___526 = tmp___525;
                    }
#line 806
                    tmp___527 = tmp___526;
                  }
#line 806
                  if (tmp___527) {
#line 806
                    goto _L___100;
                  } else
#line 806
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___100;
                  } else
#line 806
                  if (9223372036854775807L < n * item_size) {
                    _L___100: /* CIL Label */ 
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___522 = 1;
                  } else {
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___522 = 0;
                  }
                }
#line 806
                tmp___528 = tmp___522;
              }
#line 806
              tmp___552 = tmp___528;
            } else {
#line 806
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 806
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 806
                  if ((long long )n < 0LL) {
#line 806
                    if (0LL < (long long )item_size) {
#line 806
                      goto _L___103;
                    } else {
#line 806
                      goto _L___105;
                    }
                  } else
                  _L___105: /* CIL Label */ 
#line 806
                  if ((long long )item_size < 0LL) {
#line 806
                    if (0LL < (long long )n) {
#line 806
                      goto _L___103;
                    } else {
#line 806
                      goto _L___104;
                    }
                  } else {
#line 806
                    goto _L___104;
                  }
                } else {
                  _L___104: /* CIL Label */ 
#line 806
                  if ((long long )item_size < 0LL) {
#line 806
                    if ((long long )n < 0LL) {
#line 806
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 806
                      if ((long long )item_size == -1LL) {
#line 806
                        tmp___535 = 0;
                      } else {
#line 806
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 806
                      tmp___536 = tmp___535;
                    }
#line 806
                    tmp___539 = tmp___536;
                  } else {
#line 806
                    if ((long long )item_size == 0LL) {
#line 806
                      tmp___538 = 0;
                    } else {
#line 806
                      if ((long long )n < 0LL) {
#line 806
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 806
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 806
                      tmp___538 = tmp___537;
                    }
#line 806
                    tmp___539 = tmp___538;
                  }
#line 806
                  if (tmp___539) {
#line 806
                    goto _L___103;
                  } else
#line 806
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___103;
                  } else
#line 806
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
                    _L___103: /* CIL Label */ 
#line 806
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___534 = 1;
                  } else {
#line 806
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___534 = 0;
                  }
                }
#line 806
                tmp___551 = tmp___534;
              } else {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___106;
                    } else {
#line 806
                      goto _L___108;
                    }
                  } else
                  _L___108: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___106;
                    } else {
#line 806
                      goto _L___107;
                    }
                  } else {
#line 806
                    goto _L___107;
                  }
                } else {
                  _L___107: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___546 = 0;
                      } else {
#line 806
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___547 = tmp___546;
                    }
#line 806
                    tmp___550 = tmp___547;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___549 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___549 = tmp___548;
                    }
#line 806
                    tmp___550 = tmp___549;
                  }
#line 806
                  if (tmp___550) {
#line 806
                    goto _L___106;
                  } else
#line 806
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___106;
                  } else
#line 806
                  if (9223372036854775807LL < (long long )(n * item_size)) {
                    _L___106: /* CIL Label */ 
#line 806
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___545 = 1;
                  } else {
#line 806
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___545 = 0;
                  }
                }
#line 806
                tmp___551 = tmp___545;
              }
#line 806
              tmp___552 = tmp___551;
            }
#line 806
            tmp___553 = tmp___552;
          }
#line 806
          tmp___554 = tmp___553;
        }
#line 806
        tmp___555 = tmp___554;
      }
#line 806
      if (tmp___555) {
        {
#line 810
        xalloc_die();
        }
      }
    }
  }
  {
#line 811
  pa = xrealloc(pa, (size_t )nbytes);
#line 812
  *nitems = n;
  }
#line 813
  return (pa);
}
}
#line 825 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void *maybe_realloc(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                           ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 829
  if (i < *nitems) {
#line 830
    return (pa);
  }
  {
#line 831
  tmp = xpalloc(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 831
  return (tmp);
}
}
#line 835 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static ptrdiff_t charclass_index(struct dfa *d , charclass *s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 840
  i = (ptrdiff_t )0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < d->cindex)) {
#line 840
      goto while_break;
    }
    {
#line 841
    tmp = equal((charclass const   *)s, (charclass const   *)(d->charclasses + i));
    }
#line 841
    if (tmp) {
#line 842
      return (i);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  tmp___0 = maybe_realloc((void *)d->charclasses, d->cindex, & d->calloc, (ptrdiff_t )(TOKEN_MAX - 275L),
                          (ptrdiff_t )sizeof(*(d->charclasses)));
#line 843
  d->charclasses = (charclass *)tmp___0;
#line 845
  (d->cindex) ++;
#line 846
  *(d->charclasses + i) = *s;
  }
#line 847
  return (i);
}
}
#line 850 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool unibyte_word_constituent(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 853
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 853
    tmp = __ctype_b_loc();
    }
#line 853
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 853
      tmp___0 = 1;
    } else
#line 853
    if ((int )c == 95) {
#line 853
      tmp___0 = 1;
    } else {
#line 853
      tmp___0 = 0;
    }
  } else {
#line 853
    tmp___0 = 0;
  }
#line 853
  return ((_Bool )tmp___0);
}
}
#line 856 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int char_context(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 859
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 859
    if (! dfa->syntax.anchor) {
#line 860
      return (4);
    }
  }
  {
#line 861
  tmp = unibyte_word_constituent(dfa, c);
  }
#line 861
  if (tmp) {
#line 862
    return (2);
  }
#line 863
  return (1);
}
}
#line 871 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool setbit_wc(wint_t wc , charclass *c ) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 874
  tmp = wctob(wc);
#line 874
  b = tmp;
  }
#line 875
  if (b < 0) {
#line 876
    return ((_Bool)0);
  }
  {
#line 878
  setbit((unsigned int )b, c);
  }
#line 879
  return ((_Bool)1);
}
}
#line 884 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void setbit_case_fold_c(int b , charclass *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 887
  tmp = toupper(b);
#line 887
  ub = tmp;
#line 888
  i = 0;
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! (i < 256)) {
#line 888
      goto while_break;
    }
    {
#line 889
    tmp___0 = toupper(i);
    }
#line 889
    if (tmp___0 == ub) {
      {
#line 890
      setbit((unsigned int )i, c);
      }
    }
#line 888
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  return;
}
}
#line 895 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool using_simple_locale(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 914
  if (multibyte) {
#line 915
    return ((_Bool)0);
  } else {
    {
#line 920
    tmp = setlocale(6, (char const   *)((void *)0));
#line 920
    loc = (char const   *)tmp;
    }
#line 921
    if (! loc) {
#line 921
      tmp___2 = 1;
    } else {
      {
#line 921
      tmp___0 = streq(loc, "C");
      }
#line 921
      if (tmp___0) {
#line 921
        tmp___2 = 1;
      } else {
        {
#line 921
        tmp___1 = streq(loc, "POSIX");
        }
#line 921
        if (tmp___1) {
#line 921
          tmp___2 = 1;
        } else {
#line 921
          tmp___2 = 0;
        }
      }
    }
#line 921
    return ((_Bool )tmp___2);
  }
}
}
#line 931 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int fetch_wc(struct dfa *dfa ) 
{ 
  size_t nbytes ;
  size_t tmp ;
  int c ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 934
  tmp = mbs_to_wchar(& dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left, dfa);
#line 934
  nbytes = tmp;
#line 936
  dfa->lex.cur_mb_len = (int )nbytes;
  }
#line 937
  if (nbytes == 1UL) {
    {
#line 937
    tmp___0 = to_uchar___0((char )*(dfa->lex.ptr + 0));
#line 937
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 937
    tmp___1 = -1;
  }
#line 937
  c = tmp___1;
#line 938
  dfa->lex.ptr += nbytes;
#line 939
  dfa->lex.left -= nbytes;
#line 940
  return (c);
}
}
#line 945 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int bracket_fetch_wc(struct dfa *dfa ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 948
  if (! dfa->lex.left) {
    {
#line 949
    tmp = gettext("unbalanced [");
#line 949
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 950
  tmp___0 = fetch_wc(dfa);
  }
#line 950
  return (tmp___0);
}
}
#line 966 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 966
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 982 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i ;
  _Bool tmp ;

  {
#line 985
  i = 0U;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! prednames[i].name) {
#line 985
      goto while_break;
    }
    {
#line 986
    tmp = streq(str, (char const   *)prednames[i].name);
    }
#line 986
    if (tmp) {
#line 987
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
    }
#line 985
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 988
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 993 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static token parse_bracket_exp(struct dfa *dfa ) 
{ 
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  charclass ccl ;
  int c ;
  int tmp ;
  _Bool invert ;
  wint_t wc ;
  int c1 ;
  wint_t wc1 ;
  char str[33] ;
  size_t len ;
  size_t tmp___0 ;
  char const   *class ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___6 ;
  char *tmp___7 ;
  int c2 ;
  int tmp___8 ;
  int c2___0 ;
  int tmp___9 ;
  wint_t wc2 ;
  int ci ;
  int uc ;
  int tmp___10 ;
  int uc2 ;
  int tmp___11 ;
  int uci ;
  int tmp___12 ;
  int tmp___13 ;
  wchar_t folded[33] ;
  unsigned int n ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int i ;
  void *tmp___16 ;
  ptrdiff_t tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  ptrdiff_t tmp___21 ;
  _Bool tmp___22 ;
  ptrdiff_t tmp___24 ;

  {
  {
#line 998
  known_bracket_exp = (_Bool)1;
#line 1007
  dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1009
  zeroset(& ccl);
#line 1010
  tmp = bracket_fetch_wc(dfa);
#line 1010
  c = tmp;
#line 1011
  invert = (_Bool )(c == 94);
  }
#line 1012
  if (invert) {
    {
#line 1014
    c = bracket_fetch_wc(dfa);
#line 1015
    invert = (_Bool)1;
#line 1016
    known_bracket_exp = dfa->simple_locale;
    }
  }
#line 1018
  wc = dfa->lex.wctok;
#line 1021
  colon_warning_state = c == 58;
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1024
    c1 = 256;
#line 1025
    colon_warning_state &= -3;
#line 1031
    if (c == 91) {
      {
#line 1033
      c1 = bracket_fetch_wc(dfa);
#line 1034
      wc1 = dfa->lex.wctok;
      }
#line 1036
      if (c1 == 58) {
#line 1036
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1036
          goto _L___0;
        } else {
#line 1036
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1036
      if (c1 == 46) {
#line 1036
        goto _L___0;
      } else
#line 1036
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1041
        len = (size_t )0;
        {
#line 1042
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1044
          c = bracket_fetch_wc(dfa);
          }
#line 1045
          if (dfa->lex.left == 0UL) {
#line 1047
            goto while_break___0;
          } else
#line 1045
          if (c == c1) {
#line 1045
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1047
              goto while_break___0;
            }
          }
#line 1048
          if (len < 32UL) {
#line 1049
            tmp___0 = len;
#line 1049
            len ++;
#line 1049
            str[tmp___0] = (char )c;
          } else {
#line 1052
            str[0] = (char )'\000';
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1054
        str[len] = (char )'\000';
#line 1057
        c = bracket_fetch_wc(dfa);
#line 1058
        wc = dfa->lex.wctok;
        }
#line 1059
        if (c1 == 58) {
#line 1065
          if (dfa->syntax.case_fold) {
            {
#line 1065
            tmp___4 = streq((char const   *)(str), "upper");
            }
#line 1065
            if (tmp___4) {
#line 1065
              tmp___3 = "alpha";
            } else {
              {
#line 1065
              tmp___5 = streq((char const   *)(str), "lower");
              }
#line 1065
              if (tmp___5) {
#line 1065
                tmp___3 = "alpha";
              } else {
#line 1065
                tmp___3 = (char const   *)(str);
              }
            }
          } else {
#line 1065
            tmp___3 = (char const   *)(str);
          }
          {
#line 1065
          class = tmp___3;
#line 1069
          tmp___6 = find_pred(class);
#line 1069
          pred = (struct dfa_ctype  const  *)tmp___6;
          }
#line 1070
          if (! pred) {
            {
#line 1071
            tmp___7 = gettext("invalid character class");
#line 1071
            dfaerror((char const   *)tmp___7);
            }
          }
#line 1073
          if (dfa->localeinfo.multibyte) {
#line 1073
            if (! pred->single_byte_only) {
#line 1074
              known_bracket_exp = (_Bool)0;
            } else {
#line 1073
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1076
            c2 = 0;
            {
#line 1076
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1076
              if (! (c2 < 256)) {
#line 1076
                goto while_break___1;
              }
              {
#line 1077
              tmp___8 = (*(pred->func))(c2);
              }
#line 1077
              if (tmp___8) {
                {
#line 1078
                setbit((unsigned int )c2, & ccl);
                }
              }
#line 1076
              c2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1081
          known_bracket_exp = (_Bool)0;
        }
        {
#line 1083
        colon_warning_state |= 8;
#line 1086
        c1 = bracket_fetch_wc(dfa);
#line 1087
        wc1 = dfa->lex.wctok;
        }
#line 1088
        goto __Cont;
      }
    }
#line 1095
    if (c == 92) {
#line 1095
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1098
        c = bracket_fetch_wc(dfa);
#line 1099
        wc = dfa->lex.wctok;
        }
      }
    }
#line 1102
    if (c1 == 256) {
      {
#line 1104
      c1 = bracket_fetch_wc(dfa);
#line 1105
      wc1 = dfa->lex.wctok;
      }
    }
#line 1108
    if (c1 == 45) {
      {
#line 1111
      tmp___9 = bracket_fetch_wc(dfa);
#line 1111
      c2___0 = tmp___9;
#line 1112
      wc2 = dfa->lex.wctok;
      }
#line 1117
      if (c2___0 == 91) {
#line 1117
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1119
          known_bracket_exp = (_Bool)0;
#line 1120
          c2___0 = ']';
        }
      }
#line 1123
      if (c2___0 == 93) {
#line 1127
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1128
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1132
        if (c2___0 == 92) {
#line 1132
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1135
            c2___0 = bracket_fetch_wc(dfa);
#line 1136
            wc2 = dfa->lex.wctok;
            }
          }
        }
        {
#line 1139
        colon_warning_state |= 8;
#line 1140
        c1 = bracket_fetch_wc(dfa);
#line 1141
        wc1 = dfa->lex.wctok;
        }
#line 1144
        if (wc != wc2) {
#line 1144
          goto _L___2;
        } else
#line 1144
        if (wc == 4294967295U) {
          _L___2: /* CIL Label */ 
#line 1146
          if (dfa->localeinfo.multibyte) {
#line 1147
            known_bracket_exp = (_Bool)0;
          } else
#line 1148
          if (dfa->simple_locale) {
#line 1151
            ci = c;
            {
#line 1151
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1151
              if (! (ci <= c2___0)) {
#line 1151
                goto while_break___2;
              }
              {
#line 1152
              setbit((unsigned int )ci, & ccl);
#line 1151
              ci ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1153
            if (dfa->syntax.case_fold) {
              {
#line 1155
              tmp___10 = toupper(c);
#line 1155
              uc = tmp___10;
#line 1156
              tmp___11 = toupper(c2___0);
#line 1156
              uc2 = tmp___11;
#line 1157
              ci = 0;
              }
              {
#line 1157
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1157
                if (! (ci < 256)) {
#line 1157
                  goto while_break___3;
                }
                {
#line 1159
                tmp___12 = toupper(ci);
#line 1159
                uci = tmp___12;
                }
#line 1160
                if (uc <= uci) {
#line 1160
                  if (uci <= uc2) {
                    {
#line 1161
                    setbit((unsigned int )ci, & ccl);
                    }
                  }
                }
#line 1157
                ci ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          } else {
#line 1166
            known_bracket_exp = (_Bool)0;
          }
#line 1168
          goto __Cont;
        }
      }
    }
#line 1173
    if (c == 58) {
#line 1173
      tmp___13 = 2;
    } else {
#line 1173
      tmp___13 = 4;
    }
#line 1173
    colon_warning_state |= tmp___13;
#line 1175
    if (! dfa->localeinfo.multibyte) {
#line 1177
      if (dfa->syntax.case_fold) {
        {
#line 1178
        setbit_case_fold_c(c, & ccl);
        }
      } else {
        {
#line 1180
        setbit((unsigned int )c, & ccl);
        }
      }
#line 1181
      goto __Cont;
    }
#line 1184
    if (wc == 4294967295U) {
#line 1185
      known_bracket_exp = (_Bool)0;
    } else {
#line 1189
      if (dfa->syntax.case_fold) {
        {
#line 1189
        tmp___14 = case_folded_counterparts(wc, (wchar_t *)(folded + 1));
#line 1189
        tmp___15 = tmp___14 + 1;
        }
      } else {
#line 1189
        tmp___15 = 1;
      }
#line 1189
      n = (unsigned int )tmp___15;
#line 1192
      folded[0] = (wchar_t )wc;
#line 1193
      i = 0U;
      {
#line 1193
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1193
        if (! (i < n)) {
#line 1193
          goto while_break___4;
        }
        {
#line 1194
        tmp___18 = setbit_wc((wint_t )folded[i], & ccl);
        }
#line 1194
        if (! tmp___18) {
          {
#line 1196
          tmp___16 = maybe_realloc((void *)dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                   & dfa->lex.brack.nchars_alloc, (ptrdiff_t )-1,
                                   (ptrdiff_t )sizeof(*(dfa->lex.brack.chars)));
#line 1196
          dfa->lex.brack.chars = (wchar_t *)tmp___16;
#line 1200
          tmp___17 = dfa->lex.brack.nchars;
#line 1200
          (dfa->lex.brack.nchars) ++;
#line 1200
          *(dfa->lex.brack.chars + tmp___17) = folded[i];
          }
        }
#line 1193
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1022
    wc = wc1;
#line 1022
    c = c1;
#line 1022
    if (! (c != 93)) {
#line 1022
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1206
  if (colon_warning_state == 7) {
    {
#line 1207
    tmp___19 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1207
    dfawarn((char const   *)tmp___19);
    }
  }
#line 1209
  if (! known_bracket_exp) {
#line 1210
    return ((token )257);
  }
#line 1212
  if (dfa->localeinfo.multibyte) {
    {
#line 1214
    dfa->lex.brack.invert = invert;
#line 1215
    tmp___22 = emptyset((charclass const   *)(& ccl));
    }
#line 1215
    if (tmp___22) {
#line 1215
      dfa->lex.brack.cset = (ptrdiff_t )-1;
    } else {
      {
#line 1215
      tmp___21 = charclass_index(dfa, & ccl);
#line 1215
      dfa->lex.brack.cset = tmp___21;
      }
    }
#line 1216
    return ((token )273);
  }
#line 1219
  if (invert) {
#line 1221
    if (! (! dfa->localeinfo.multibyte)) {
      {
#line 1221
      __assert_fail("!dfa->localeinfo.multibyte", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c",
                    1221U, "parse_bracket_exp");
      }
    }
    {
#line 1222
    notset(& ccl);
    }
#line 1223
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1224
      clrbit((unsigned int )'\n', & ccl);
      }
    }
  }
  {
#line 1227
  tmp___24 = charclass_index(dfa, & ccl);
  }
#line 1227
  return (275L + tmp___24);
}
}
#line 1236 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void push_lex_state(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1239
  ls->ptr = dfa->lex.ptr;
#line 1240
  ls->left = dfa->lex.left;
#line 1241
  dfa->lex.ptr = s;
#line 1242
  dfa->lex.left = strlen(s);
  }
#line 1243
  return;
}
}
#line 1245 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void pop_lex_state(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1248
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1249
  dfa->lex.left = (size_t )ls->left;
#line 1250
  return;
}
}
#line 1252 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static token lex(struct dfa *dfa ) 
{ 
  _Bool backslash ;
  int i ;
  token tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  char const   *p ;
  char const   *lim ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  token tmp___27 ;
  charclass ccl ;
  int c2 ;
  ptrdiff_t tmp___28 ;
  token tmp___29 ;
  charclass ccl___0 ;
  int c2___0 ;
  unsigned short const   **tmp___30 ;
  token tmp___31 ;
  ptrdiff_t tmp___32 ;
  struct lexptr ls ;
  charclass ccl___1 ;
  int c2___1 ;
  token tmp___33 ;
  ptrdiff_t tmp___34 ;
  struct lexptr ls___0 ;
  token tmp___35 ;
  token tmp___36 ;
  charclass ccl___2 ;
  token tmp___37 ;
  ptrdiff_t tmp___38 ;
  unsigned short const   **tmp___39 ;
  token tmp___40 ;

  {
#line 1255
  backslash = (_Bool)0;
#line 1263
  i = 0;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! (i < 2)) {
#line 1263
      goto while_break;
    }
#line 1265
    if (! dfa->lex.left) {
#line 1266
      tmp = (token )-1;
#line 1266
      dfa->lex.lasttok = tmp;
#line 1266
      return (tmp);
    }
    {
#line 1267
    tmp___0 = fetch_wc(dfa);
#line 1267
    c = tmp___0;
    }
    {
#line 1271
    if (c == 92) {
#line 1271
      goto case_92;
    }
#line 1279
    if (c == 94) {
#line 1279
      goto case_94;
    }
#line 1288
    if (c == 36) {
#line 1288
      goto case_36;
    }
#line 1316
    if (c == 57) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 56) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 55) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 54) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 53) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 52) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 51) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 50) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 49) {
#line 1316
      goto case_57;
    }
#line 1324
    if (c == 96) {
#line 1324
      goto case_96;
    }
#line 1332
    if (c == 39) {
#line 1332
      goto case_39;
    }
#line 1340
    if (c == 60) {
#line 1340
      goto case_60;
    }
#line 1345
    if (c == 62) {
#line 1345
      goto case_62;
    }
#line 1350
    if (c == 98) {
#line 1350
      goto case_98;
    }
#line 1355
    if (c == 66) {
#line 1355
      goto case_66;
    }
#line 1360
    if (c == 63) {
#line 1360
      goto case_63;
    }
#line 1370
    if (c == 42) {
#line 1370
      goto case_42;
    }
#line 1378
    if (c == 43) {
#line 1378
      goto case_43;
    }
#line 1388
    if (c == 123) {
#line 1388
      goto case_123;
    }
#line 1446
    if (c == 124) {
#line 1446
      goto case_124;
    }
#line 1454
    if (c == 10) {
#line 1454
      goto case_10;
    }
#line 1461
    if (c == 40) {
#line 1461
      goto case_40;
    }
#line 1468
    if (c == 41) {
#line 1468
      goto case_41;
    }
#line 1478
    if (c == 46) {
#line 1478
      goto case_46;
    }
#line 1501
    if (c == 83) {
#line 1501
      goto case_83;
    }
#line 1501
    if (c == 115) {
#line 1501
      goto case_83;
    }
#line 1534
    if (c == 87) {
#line 1534
      goto case_87;
    }
#line 1534
    if (c == 119) {
#line 1534
      goto case_87;
    }
#line 1567
    if (c == 91) {
#line 1567
      goto case_91;
    }
#line 1573
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1272
    if (backslash) {
#line 1273
      goto normal_char;
    }
#line 1274
    if (dfa->lex.left == 0UL) {
      {
#line 1275
      tmp___1 = gettext("unfinished \\ escape");
#line 1275
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1276
    backslash = (_Bool)1;
#line 1277
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1280
    if (backslash) {
#line 1281
      goto normal_char;
    }
#line 1282
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == -1L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == 270L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == 269L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    }
#line 1286
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1289
    if (backslash) {
#line 1290
      goto normal_char;
    }
#line 1291
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1305
      tmp___3 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___3;
#line 1305
      return (tmp___3);
    } else
#line 1291
    if (dfa->lex.left == 0UL) {
#line 1305
      tmp___3 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___3;
#line 1305
      return (tmp___3);
    } else
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1305
        tmp___3 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___3;
#line 1305
        return (tmp___3);
      } else {
#line 1291
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1305
        tmp___3 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___3;
#line 1305
        return (tmp___3);
      } else {
#line 1291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1291
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1291
      if (dfa->lex.left > 0UL) {
#line 1291
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1305
          tmp___3 = (token )259;
#line 1305
          dfa->lex.lasttok = tmp___3;
#line 1305
          return (tmp___3);
        }
      }
    }
#line 1306
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1317
    if (backslash) {
#line 1317
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1319
        dfa->lex.laststart = (_Bool)0;
#line 1320
        tmp___4 = (token )257;
#line 1320
        dfa->lex.lasttok = tmp___4;
#line 1320
        return (tmp___4);
      }
    }
#line 1322
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1325
    if (backslash) {
#line 1325
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1328
        tmp___5 = (token )258;
#line 1328
        dfa->lex.lasttok = tmp___5;
#line 1328
        return (tmp___5);
      }
    }
#line 1330
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1333
    if (backslash) {
#line 1333
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1336
        tmp___6 = (token )259;
#line 1336
        dfa->lex.lasttok = tmp___6;
#line 1336
        return (tmp___6);
      }
    }
#line 1338
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1341
    if (backslash) {
#line 1341
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1342
        tmp___7 = (token )260;
#line 1342
        dfa->lex.lasttok = tmp___7;
#line 1342
        return (tmp___7);
      }
    }
#line 1343
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1346
    if (backslash) {
#line 1346
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1347
        tmp___8 = (token )261;
#line 1347
        dfa->lex.lasttok = tmp___8;
#line 1347
        return (tmp___8);
      }
    }
#line 1348
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1351
    if (backslash) {
#line 1351
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1352
        tmp___9 = (token )262;
#line 1352
        dfa->lex.lasttok = tmp___9;
#line 1352
        return (tmp___9);
      }
    }
#line 1353
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1356
    if (backslash) {
#line 1356
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1357
        tmp___10 = (token )263;
#line 1357
        dfa->lex.lasttok = tmp___10;
#line 1357
        return (tmp___10);
      }
    }
#line 1358
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1361
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1362
      goto normal_char;
    }
#line 1363
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1364
      goto normal_char;
    }
#line 1365
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1365
      if (dfa->lex.laststart) {
#line 1367
        goto normal_char;
      }
    }
#line 1368
    tmp___11 = (token )264;
#line 1368
    dfa->lex.lasttok = tmp___11;
#line 1368
    return (tmp___11);
    case_42: /* CIL Label */ 
#line 1371
    if (backslash) {
#line 1372
      goto normal_char;
    }
#line 1373
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1373
      if (dfa->lex.laststart) {
#line 1375
        goto normal_char;
      }
    }
#line 1376
    tmp___12 = (token )265;
#line 1376
    dfa->lex.lasttok = tmp___12;
#line 1376
    return (tmp___12);
    case_43: /* CIL Label */ 
#line 1379
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1380
      goto normal_char;
    }
#line 1381
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1382
      goto normal_char;
    }
#line 1383
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1383
      if (dfa->lex.laststart) {
#line 1385
        goto normal_char;
      }
    }
#line 1386
    tmp___13 = (token )266;
#line 1386
    dfa->lex.lasttok = tmp___13;
#line 1386
    return (tmp___13);
    case_123: /* CIL Label */ 
#line 1389
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1390
      goto normal_char;
    }
#line 1391
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1392
      goto normal_char;
    }
#line 1393
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1393
      if (dfa->lex.laststart) {
#line 1395
        goto normal_char;
      }
    }
#line 1404
    p = dfa->lex.ptr;
#line 1405
    lim = p + dfa->lex.left;
#line 1406
    tmp___14 = -1;
#line 1406
    dfa->lex.maxrep = tmp___14;
#line 1406
    dfa->lex.minrep = tmp___14;
    {
#line 1407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1407
      if ((unsigned long )p != (unsigned long )lim) {
        {
#line 1407
        tmp___16 = isasciidigit((char )*p);
        }
#line 1407
        if (! tmp___16) {
#line 1407
          goto while_break___0;
        }
      } else {
#line 1407
        goto while_break___0;
      }
#line 1408
      if (dfa->lex.minrep < 0) {
#line 1408
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1408
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1408
          tmp___15 = 32768;
        } else {
#line 1408
          tmp___15 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1408
        dfa->lex.minrep = tmp___15;
      }
#line 1407
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1412
    if ((unsigned long )p != (unsigned long )lim) {
#line 1414
      if ((int const   )*p != 44) {
#line 1415
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1418
        if (dfa->lex.minrep < 0) {
#line 1419
          dfa->lex.minrep = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1420
          p ++;
#line 1420
          if ((unsigned long )p != (unsigned long )lim) {
            {
#line 1420
            tmp___18 = isasciidigit((char )*p);
            }
#line 1420
            if (! tmp___18) {
#line 1420
              goto while_break___1;
            }
          } else {
#line 1420
            goto while_break___1;
          }
#line 1421
          if (dfa->lex.maxrep < 0) {
#line 1421
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1421
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1421
              tmp___17 = 32768;
            } else {
#line 1421
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1421
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1428
    if (! backslash) {
#line 1428
      goto _L___5;
    } else
#line 1428
    if ((unsigned long )p != (unsigned long )lim) {
#line 1428
      tmp___20 = p;
#line 1428
      p ++;
#line 1428
      if ((int const   )*tmp___20 == 92) {
        _L___5: /* CIL Label */ 
#line 1428
        if ((unsigned long )p != (unsigned long )lim) {
#line 1428
          tmp___21 = p;
#line 1428
          p ++;
#line 1428
          if ((int const   )*tmp___21 == 125) {
#line 1428
            if (0 <= dfa->lex.minrep) {
#line 1428
              if (! (dfa->lex.maxrep < 0)) {
#line 1428
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1428
                  goto _L___6;
                }
              }
            } else {
#line 1428
              goto _L___6;
            }
          } else {
#line 1428
            goto _L___6;
          }
        } else {
#line 1428
          goto _L___6;
        }
      } else {
#line 1428
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1434
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1435
        goto normal_char;
      }
      {
#line 1436
      tmp___19 = gettext("invalid content of \\{\\}");
#line 1436
      dfaerror((char const   *)tmp___19);
      }
    }
#line 1438
    if (32767 < dfa->lex.maxrep) {
      {
#line 1439
      tmp___22 = gettext("regular expression too big");
#line 1439
      dfaerror((char const   *)tmp___22);
      }
    }
#line 1440
    dfa->lex.ptr = p;
#line 1441
    dfa->lex.left = (size_t )(lim - p);
#line 1443
    dfa->lex.laststart = (_Bool)0;
#line 1444
    tmp___23 = (token )267;
#line 1444
    dfa->lex.lasttok = tmp___23;
#line 1444
    return (tmp___23);
    case_124: /* CIL Label */ 
#line 1447
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1448
      goto normal_char;
    }
#line 1449
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1450
      goto normal_char;
    }
#line 1451
    dfa->lex.laststart = (_Bool)1;
#line 1452
    tmp___24 = (token )269;
#line 1452
    dfa->lex.lasttok = tmp___24;
#line 1452
    return (tmp___24);
    case_10: /* CIL Label */ 
#line 1455
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (backslash) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1457
      goto normal_char;
    }
#line 1458
    dfa->lex.laststart = (_Bool)1;
#line 1459
    tmp___25 = (token )269;
#line 1459
    dfa->lex.lasttok = tmp___25;
#line 1459
    return (tmp___25);
    case_40: /* CIL Label */ 
#line 1462
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1463
      goto normal_char;
    }
#line 1464
    (dfa->lex.parens) ++;
#line 1465
    dfa->lex.laststart = (_Bool)1;
#line 1466
    tmp___26 = (token )270;
#line 1466
    dfa->lex.lasttok = tmp___26;
#line 1466
    return (tmp___26);
    case_41: /* CIL Label */ 
#line 1469
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1470
      goto normal_char;
    }
#line 1471
    if (dfa->lex.parens == 0UL) {
#line 1471
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1473
        goto normal_char;
      }
    }
#line 1474
    (dfa->lex.parens) --;
#line 1475
    dfa->lex.laststart = (_Bool)0;
#line 1476
    tmp___27 = (token )271;
#line 1476
    dfa->lex.lasttok = tmp___27;
#line 1476
    return (tmp___27);
    case_46: /* CIL Label */ 
#line 1479
    if (backslash) {
#line 1480
      goto normal_char;
    }
#line 1481
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1484
      fillset(& ccl);
      }
#line 1485
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1486
        clrbit((unsigned int )'\n', & ccl);
        }
      }
#line 1487
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1488
        clrbit((unsigned int )'\000', & ccl);
        }
      }
#line 1489
      if (dfa->localeinfo.multibyte) {
#line 1490
        c2 = 0;
        {
#line 1490
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1490
          if (! (c2 < 256)) {
#line 1490
            goto while_break___2;
          }
#line 1491
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1492
            clrbit((unsigned int )c2, & ccl);
            }
          }
#line 1490
          c2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1493
      tmp___28 = charclass_index(dfa, & ccl);
#line 1493
      dfa->canychar = (size_t )tmp___28;
      }
    }
#line 1495
    dfa->lex.laststart = (_Bool)0;
#line 1496
    if (dfa->localeinfo.multibyte) {
#line 1496
      tmp___29 = (token )272;
    } else {
#line 1496
      tmp___29 = (token )(275UL + dfa->canychar);
    }
#line 1496
    dfa->lex.lasttok = tmp___29;
#line 1496
    return (tmp___29);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1502
    if (! backslash) {
#line 1503
      goto normal_char;
    } else
#line 1502
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1503
      goto normal_char;
    }
#line 1504
    if (! dfa->localeinfo.multibyte) {
      {
#line 1507
      zeroset(& ccl___0);
#line 1508
      c2___0 = 0;
      }
      {
#line 1508
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1508
        if (! (c2___0 < 256)) {
#line 1508
          goto while_break___3;
        }
        {
#line 1509
        tmp___30 = __ctype_b_loc();
        }
#line 1509
        if ((int const   )*(*tmp___30 + c2___0) & 8192) {
          {
#line 1510
          setbit((unsigned int )c2___0, & ccl___0);
          }
        }
#line 1508
        c2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1511
      if (c == 83) {
        {
#line 1512
        notset(& ccl___0);
        }
      }
      {
#line 1513
      dfa->lex.laststart = (_Bool)0;
#line 1514
      tmp___32 = charclass_index(dfa, & ccl___0);
#line 1514
      tmp___31 = 275L + tmp___32;
#line 1514
      dfa->lex.lasttok = tmp___31;
      }
#line 1514
      return (tmp___31);
    }
    {
#line 1525
    push_lex_state(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1526
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1527
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls));
#line 1530
    dfa->lex.laststart = (_Bool)0;
    }
#line 1531
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1535
    if (! backslash) {
#line 1536
      goto normal_char;
    } else
#line 1535
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1536
      goto normal_char;
    }
#line 1538
    if (! dfa->localeinfo.multibyte) {
      {
#line 1541
      zeroset(& ccl___1);
#line 1542
      c2___1 = 0;
      }
      {
#line 1542
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1542
        if (! (c2___1 < 256)) {
#line 1542
          goto while_break___4;
        }
#line 1543
        if ((int )dfa->syntax.sbit[c2___1] == 2) {
          {
#line 1544
          setbit((unsigned int )c2___1, & ccl___1);
          }
        }
#line 1542
        c2___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1545
      if (c == 87) {
        {
#line 1546
        notset(& ccl___1);
        }
      }
      {
#line 1547
      dfa->lex.laststart = (_Bool)0;
#line 1548
      tmp___34 = charclass_index(dfa, & ccl___1);
#line 1548
      tmp___33 = 275L + tmp___34;
#line 1548
      dfa->lex.lasttok = tmp___33;
      }
#line 1548
      return (tmp___33);
    }
    {
#line 1559
    push_lex_state(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1560
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1561
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls___0));
#line 1564
    dfa->lex.laststart = (_Bool)0;
    }
#line 1565
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1568
    if (backslash) {
#line 1569
      goto normal_char;
    }
    {
#line 1570
    dfa->lex.laststart = (_Bool)0;
#line 1571
    tmp___35 = parse_bracket_exp(dfa);
#line 1571
    dfa->lex.lasttok = tmp___35;
    }
#line 1571
    return (tmp___35);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1575
    dfa->lex.laststart = (_Bool)0;
#line 1578
    if (dfa->localeinfo.multibyte) {
#line 1579
      tmp___36 = (token )274;
#line 1579
      dfa->lex.lasttok = tmp___36;
#line 1579
      return (tmp___36);
    }
#line 1581
    if (dfa->syntax.case_fold) {
      {
#line 1581
      tmp___39 = __ctype_b_loc();
      }
#line 1581
      if ((int const   )*(*tmp___39 + c) & 1024) {
        {
#line 1584
        zeroset(& ccl___2);
#line 1585
        setbit_case_fold_c(c, & ccl___2);
#line 1586
        tmp___38 = charclass_index(dfa, & ccl___2);
#line 1586
        tmp___37 = 275L + tmp___38;
#line 1586
        dfa->lex.lasttok = tmp___37;
        }
#line 1586
        return (tmp___37);
      }
    }
#line 1589
    tmp___40 = (token )c;
#line 1589
    dfa->lex.lasttok = tmp___40;
#line 1589
    return (tmp___40);
    switch_break: /* CIL Label */ ;
    }
#line 1263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  abort();
  }
#line 1596
  return ((token )-1);
}
}
#line 1599 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok_mb(struct dfa *dfa , token t , char mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1602
  if (dfa->talloc == dfa->tindex) {
    {
#line 1604
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1604
    dfa->tokens = (token *)tmp;
    }
#line 1606
    if (dfa->localeinfo.multibyte) {
      {
#line 1607
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1607
      dfa->multibyte_prop = (char *)tmp___0;
      }
    }
  }
#line 1610
  if (dfa->localeinfo.multibyte) {
#line 1611
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1612
  tmp___1 = dfa->tindex;
#line 1612
  (dfa->tindex) ++;
#line 1612
  *(dfa->tokens + tmp___1) = t;
  {
#line 1618
  if (t == 266L) {
#line 1618
    goto case_266;
  }
#line 1618
  if (t == 265L) {
#line 1618
    goto case_266;
  }
#line 1618
  if (t == 264L) {
#line 1618
    goto case_266;
  }
#line 1622
  if (t == 269L) {
#line 1622
    goto case_269;
  }
#line 1622
  if (t == 268L) {
#line 1622
    goto case_269;
  }
#line 1626
  if (t == 257L) {
#line 1626
    goto case_257;
  }
#line 1632
  if (t == 256L) {
#line 1632
    goto case_256;
  }
#line 1629
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1619
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1623
  (dfa->parse.depth) --;
#line 1624
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1627
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1630
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1633
  (dfa->parse.depth) ++;
#line 1634
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1636
  if (dfa->parse.depth > dfa->depth) {
#line 1637
    dfa->depth = dfa->parse.depth;
  }
#line 1638
  return;
}
}
#line 1640
static void addtok_wc(struct dfa *dfa , wint_t wc ) ;
#line 1644 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  ptrdiff_t i ;

  {
#line 1647
  if (dfa->localeinfo.multibyte) {
#line 1647
    if (t == 273L) {
#line 1649
      need_or = (_Bool)0;
#line 1653
      i = (ptrdiff_t )0;
      {
#line 1653
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1653
        if (! (i < dfa->lex.brack.nchars)) {
#line 1653
          goto while_break;
        }
        {
#line 1655
        addtok_wc(dfa, (wint_t )*(dfa->lex.brack.chars + i));
        }
#line 1656
        if (need_or) {
          {
#line 1657
          addtok(dfa, (token )269);
          }
        }
#line 1658
        need_or = (_Bool)1;
#line 1653
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1660
      dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1664
      if (dfa->lex.brack.cset != -1L) {
        {
#line 1666
        addtok(dfa, 275L + dfa->lex.brack.cset);
        }
#line 1667
        if (need_or) {
          {
#line 1668
          addtok(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1673
      addtok_mb(dfa, t, (char)3);
      }
    }
  } else {
    {
#line 1673
    addtok_mb(dfa, t, (char)3);
    }
  }
#line 1675
  return;
}
}
#line 1683 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok_wc(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 1687
  s.__count = 0;
#line 1687
  s.__value.__wch = 0U;
#line 1688
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1688
  stored_bytes = tmp;
  }
#line 1690
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1691
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1696
    dfa->lex.cur_mb_len = 1;
#line 1697
    buf[0] = (unsigned char)0;
  }
#line 1700
  if (dfa->lex.cur_mb_len == 1) {
#line 1700
    tmp___0 = 3;
  } else {
#line 1700
    tmp___0 = 1;
  }
  {
#line 1700
  addtok_mb(dfa, (token )buf[0], (char )tmp___0);
#line 1701
  i = 1;
  }
  {
#line 1701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1701
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1701
      goto while_break;
    }
#line 1703
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1703
      tmp___1 = 2;
    } else {
#line 1703
      tmp___1 = 0;
    }
    {
#line 1703
    addtok_mb(dfa, (token )buf[i], (char )tmp___1);
#line 1704
    addtok(dfa, (token )268);
#line 1701
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1706
  return;
}
}
#line 1711
static void add_utf8_anychar(struct dfa *dfa ) ;
#line 1711 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static charclass const   utf8_classes[5]  = {      {{0UL, 0UL, (4294967295UL << 32) + 4294967295UL, 0UL}}, 
        {{(4294967295UL << 32) + 4294967295UL, (4294967295UL << 32) + 4294967295UL, 0UL,
       0UL}}, 
        {{0UL, 0UL, 0UL, 4294967292UL}}, 
        {{0UL, 0UL, 0UL, 65535UL << 32}}, 
        {{0UL, 0UL, 0UL, 16711680UL << 32}}};
#line 1708 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void add_utf8_anychar(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;
  unsigned int i___0 ;

  {
#line 1727
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1730
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1731
    i = 0U;
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if (! (i < n)) {
#line 1731
        goto while_break;
      }
#line 1733
      c = utf8_classes[i];
#line 1734
      if (i == 1U) {
#line 1736
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1737
          clrbit((unsigned int )'\n', & c);
          }
        }
#line 1738
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1739
          clrbit((unsigned int )'\000', & c);
          }
        }
      }
      {
#line 1741
      tmp = charclass_index(dfa, & c);
#line 1741
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1731
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1755
  i___0 = 1U;
  {
#line 1755
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1755
    if (! (i___0 < n)) {
#line 1755
      goto while_break___0;
    }
    {
#line 1756
    addtok(dfa, dfa->utf8_anychar_classes[i___0]);
#line 1755
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1757
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1757
    i___0 --;
#line 1757
    if (! (i___0 > 1U)) {
#line 1757
      goto while_break___1;
    }
    {
#line 1759
    addtok(dfa, dfa->utf8_anychar_classes[0]);
#line 1760
    addtok(dfa, (token )268);
#line 1761
    addtok(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1763
  return;
}
}
#line 1800 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void atom(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int n ;
  int tmp ;
  unsigned int i ;
  char *tmp___0 ;

  {
#line 1803
  if (dfa->parse.tok == 274L) {
#line 1805
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1806
      addtok(dfa, (token )257);
      }
    } else {
      {
#line 1809
      addtok_wc(dfa, dfa->lex.wctok);
      }
#line 1811
      if (dfa->syntax.case_fold) {
        {
#line 1814
        tmp = case_folded_counterparts(dfa->lex.wctok, (wchar_t *)(folded));
#line 1814
        n = (unsigned int )tmp;
#line 1816
        i = 0U;
        }
        {
#line 1816
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1816
          if (! (i < n)) {
#line 1816
            goto while_break;
          }
          {
#line 1818
          addtok_wc(dfa, (wint_t )folded[i]);
#line 1819
          addtok(dfa, (token )269);
#line 1816
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1824
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1826
  if (dfa->parse.tok == 272L) {
#line 1826
    if (dfa->localeinfo.using_utf8) {
      {
#line 1835
      add_utf8_anychar(dfa);
#line 1836
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1826
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1838
  if (0L <= dfa->parse.tok) {
#line 1838
    if (dfa->parse.tok < 256L) {
      {
#line 1845
      addtok(dfa, dfa->parse.tok);
#line 1846
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1838
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1838
  if (dfa->parse.tok >= 275L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 257L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 258L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 259L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 260L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 272L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 273L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 261L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 262L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 263L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1848
  if (dfa->parse.tok == 270L) {
    {
#line 1850
    dfa->parse.tok = lex(dfa);
#line 1851
    regexp(dfa);
    }
#line 1852
    if (dfa->parse.tok != 271L) {
      {
#line 1853
      tmp___0 = gettext("unbalanced (");
#line 1853
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1854
    dfa->parse.tok = lex(dfa);
    }
  } else {
    {
#line 1857
    addtok(dfa, (token )256);
    }
  }
#line 1858
  return;
}
}
#line 1861 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1870
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1870
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1870
    goto case_266;
  }
#line 1873
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1873
    goto case_269;
  }
#line 1873
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1873
    goto case_269;
  }
#line 1866
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1867
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1871
  tmp = nsubtoks(dfa, tindex - 1UL);
  }
#line 1871
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1875
  tmp___0 = nsubtoks(dfa, tindex - 1UL);
#line 1875
  ntoks1 = (size_t )tmp___0;
#line 1876
  tmp___1 = nsubtoks(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1876
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1882 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void copytoks(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t i___0 ;

  {
#line 1885
  if (dfa->localeinfo.multibyte) {
#line 1886
    i = (size_t )0;
    {
#line 1886
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1886
      if (! (i < ntokens)) {
#line 1886
        goto while_break;
      }
      {
#line 1887
      addtok_mb(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1886
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1890
    i___0 = (size_t )0;
    {
#line 1890
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1890
      if (! (i___0 < ntokens)) {
#line 1890
        goto while_break___0;
      }
      {
#line 1891
      addtok_mb(dfa, *(dfa->tokens + (tindex + i___0)), (char)3);
#line 1890
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1892
  return;
}
}
#line 1894 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void closure(struct dfa *dfa ) 
{ 
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tindex ;
  int i ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1897
  atom(dfa);
  }
  {
#line 1898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1898
    if (! (dfa->parse.tok == 264L)) {
#line 1898
      if (! (dfa->parse.tok == 265L)) {
#line 1898
        if (! (dfa->parse.tok == 266L)) {
#line 1898
          if (! (dfa->parse.tok == 267L)) {
#line 1898
            goto while_break;
          }
        }
      }
    }
#line 1900
    if (dfa->parse.tok == 267L) {
#line 1900
      if (dfa->lex.minrep) {
#line 1900
        goto _L___0;
      } else
#line 1900
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1902
        tmp = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1902
        ntokens = (size_t )tmp;
#line 1903
        tindex = dfa->tindex - ntokens;
        }
#line 1904
        if (dfa->lex.maxrep < 0) {
          {
#line 1905
          addtok(dfa, (token )266);
          }
        }
#line 1906
        if (dfa->lex.minrep == 0) {
          {
#line 1907
          addtok(dfa, (token )264);
          }
        }
#line 1909
        i = 1;
        {
#line 1909
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1909
          if (! (i < dfa->lex.minrep)) {
#line 1909
            goto while_break___0;
          }
          {
#line 1911
          copytoks(dfa, tindex, ntokens);
#line 1912
          addtok(dfa, (token )268);
#line 1909
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1914
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1914
          if (! (i < dfa->lex.maxrep)) {
#line 1914
            goto while_break___1;
          }
          {
#line 1916
          copytoks(dfa, tindex, ntokens);
#line 1917
          addtok(dfa, (token )264);
#line 1918
          addtok(dfa, (token )268);
#line 1914
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1920
        dfa->parse.tok = lex(dfa);
        }
      } else {
#line 1900
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1922
    if (dfa->parse.tok == 267L) {
      {
#line 1924
      tmp___0 = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1924
      dfa->tindex -= (size_t )tmp___0;
#line 1925
      dfa->parse.tok = lex(dfa);
#line 1926
      closure(dfa);
      }
    } else {
      {
#line 1930
      addtok(dfa, dfa->parse.tok);
#line 1931
      dfa->parse.tok = lex(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1933
  return;
}
}
#line 1935 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void branch(struct dfa *dfa ) 
{ 


  {
  {
#line 1938
  closure(dfa);
  }
  {
#line 1939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1939
    if (dfa->parse.tok != 271L) {
#line 1939
      if (dfa->parse.tok != 269L) {
#line 1939
        if (! (dfa->parse.tok >= 0L)) {
#line 1939
          goto while_break;
        }
      } else {
#line 1939
        goto while_break;
      }
    } else {
#line 1939
      goto while_break;
    }
    {
#line 1942
    closure(dfa);
#line 1943
    addtok(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1945
  return;
}
}
#line 1947 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void regexp(struct dfa *dfa ) 
{ 


  {
  {
#line 1950
  branch(dfa);
  }
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! (dfa->parse.tok == 269L)) {
#line 1951
      goto while_break;
    }
    {
#line 1953
    dfa->parse.tok = lex(dfa);
#line 1954
    branch(dfa);
#line 1955
    addtok(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1957
  return;
}
}
#line 1962 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1965
  d->lex.ptr = s;
#line 1966
  d->lex.left = len;
#line 1967
  d->lex.lasttok = (token )-1;
#line 1968
  d->lex.laststart = (_Bool)1;
#line 1970
  if (! d->syntax.syntax_bits_set) {
    {
#line 1971
    tmp = gettext("no syntax specified");
#line 1971
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1973
  d->parse.tok = lex(d);
#line 1974
  d->parse.depth = d->depth;
#line 1976
  regexp(d);
  }
#line 1978
  if (d->parse.tok != -1L) {
    {
#line 1979
    tmp___0 = gettext("unbalanced )");
#line 1979
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1981
  addtok(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1982
  addtok(d, (token )268);
  }
#line 1984
  if (d->nregexps) {
    {
#line 1985
    addtok(d, (token )269);
    }
  }
#line 1987
  (d->nregexps) ++;
#line 1988
  return;
}
}
#line 1993 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 1996
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 1998
    free((void *)dst->elems);
#line 1999
    tmp = xpalloc((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                  (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 1999
    dst->elems = (position *)tmp;
    }
  }
#line 2002
  dst->nelem = (ptrdiff_t )src->nelem;
#line 2003
  if (src->nelem != 0L) {
    {
#line 2004
    memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(*(dst->elems)));
    }
  }
#line 2005
  return;
}
}
#line 2007 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void alloc_position_set(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2010
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2010
  s->elems = (position *)tmp;
#line 2011
  s->alloc = (ptrdiff_t )size;
#line 2012
  s->nelem = (ptrdiff_t )0;
  }
#line 2013
  return;
}
}
#line 2019 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void insert(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t mid ;
  void *tmp ;
  ptrdiff_t i ;

  {
#line 2022
  count = s->nelem;
#line 2023
  lo = (ptrdiff_t )0;
#line 2023
  hi = count;
  {
#line 2024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2024
    if (! (lo < hi)) {
#line 2024
      goto while_break;
    }
#line 2026
    mid = (lo + hi) >> 1;
#line 2027
    if ((s->elems + mid)->index > p.index) {
#line 2028
      lo = mid + 1L;
    } else
#line 2029
    if ((s->elems + mid)->index == p.index) {
#line 2031
      (s->elems + mid)->constraint |= p.constraint;
#line 2032
      return;
    } else {
#line 2035
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2038
  tmp = maybe_realloc((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2038
  s->elems = (position *)tmp;
#line 2039
  i = count;
  }
  {
#line 2039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2039
    if (! (i > lo)) {
#line 2039
      goto while_break___0;
    }
#line 2040
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2039
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2041
  *(s->elems + lo) = p;
#line 2042
  (s->nelem) ++;
#line 2043
  return;
}
}
#line 2048 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void merge_constrained(position_set const   *s1 , position_set const   *s2 ,
                              unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2052
  i = (ptrdiff_t )0;
#line 2052
  j = (ptrdiff_t )0;
#line 2054
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2056
    free((void *)m->elems);
#line 2057
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2058
    tmp = xpalloc((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(m->elems)));
#line 2058
    m->elems = (position *)tmp;
    }
  }
#line 2060
  m->nelem = (ptrdiff_t )0;
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2061
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2061
        goto while_break;
      }
    }
#line 2062
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2062
      goto _L;
    } else
#line 2062
    if (i < (ptrdiff_t )s1->nelem) {
#line 2062
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2065
        if (i < (ptrdiff_t )s1->nelem) {
#line 2065
          if (j < (ptrdiff_t )s2->nelem) {
#line 2065
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2065
              tmp___0 = j;
#line 2065
              j ++;
#line 2065
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2065
              tmp___1 = 0U;
            }
          } else {
#line 2065
            tmp___1 = 0U;
          }
        } else {
#line 2065
          tmp___1 = 0U;
        }
#line 2065
        c = tmp___1;
#line 2069
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2070
        tmp___2 = m->nelem;
#line 2070
        (m->nelem) ++;
#line 2070
        tmp___3 = i;
#line 2070
        i ++;
#line 2070
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2062
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2074
      if ((s2->elems + j)->constraint & c2) {
#line 2076
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2077
        tmp___4 = m->nelem;
#line 2077
        (m->nelem) ++;
#line 2077
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2079
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2081
  return;
}
}
#line 2085 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2088
  merge_constrained(s1, s2, 4294967295U, m);
  }
#line 2089
  return;
}
}
#line 2093 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned int delete(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2096
  count = (size_t )s->nelem;
#line 2097
  lo = (size_t )0;
#line 2097
  hi = count;
  {
#line 2098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2098
    if (! (lo < hi)) {
#line 2098
      goto while_break;
    }
#line 2100
    mid = (lo + hi) >> 1;
#line 2101
    if ((s->elems + mid)->index > del) {
#line 2102
      lo = mid + 1UL;
    } else
#line 2103
    if ((s->elems + mid)->index == del) {
#line 2105
      c = (s->elems + mid)->constraint;
#line 2107
      i = mid;
      {
#line 2107
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2107
        if (! (i + 1UL < count)) {
#line 2107
          goto while_break___0;
        }
#line 2108
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2107
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2109
      s->nelem = (ptrdiff_t )i;
#line 2110
      return (c);
    } else {
#line 2113
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  return (0U);
}
}
#line 2119 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void replace(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                    position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2123
  tmp___0 = delete(del, dst);
#line 2123
  c = tmp___0 & constraint;
  }
#line 2125
  if (c) {
    {
#line 2127
    copy((position_set const   *)dst, tmp);
#line 2128
    merge_constrained((position_set const   *)tmp, (position_set const   *)add, c,
                      dst);
    }
  }
#line 2130
  return;
}
}
#line 2135 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  token first_end ;
  state_num j ;
  state_num j___0 ;
  int c ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 2138
  hash = (size_t )0;
#line 2139
  constraint = 0;
#line 2141
  first_end = (token )0;
#line 2143
  i = (state_num )0;
  {
#line 2143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2143
    if (! (i < (state_num )s->nelem)) {
#line 2143
      goto while_break;
    }
#line 2144
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  i = (state_num )0;
  {
#line 2147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2147
    if (! (i < d->sindex)) {
#line 2147
      goto while_break___0;
    }
#line 2149
    if (hash != (d->states + i)->hash) {
#line 2151
      goto __Cont;
    } else
#line 2149
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2151
      goto __Cont;
    } else
#line 2149
    if (context != (int )(d->states + i)->context) {
#line 2151
      goto __Cont;
    }
#line 2153
    j = (state_num )0;
    {
#line 2153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2153
      if (! (j < (state_num )s->nelem)) {
#line 2153
        goto while_break___1;
      }
#line 2154
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2156
        goto while_break___1;
      } else
#line 2154
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2156
        goto while_break___1;
      }
#line 2153
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2157
    if (j == (state_num )s->nelem) {
#line 2158
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2147
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2183
  j___0 = (state_num )0;
  {
#line 2183
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2183
    if (! (j___0 < (state_num )s->nelem)) {
#line 2183
      goto while_break___2;
    }
#line 2185
    c = (int )(s->elems + j___0)->constraint;
#line 2186
    if (*(d->tokens + (s->elems + j___0)->index) < 0L) {
      {
#line 2188
      tmp = succeeds_in_context(c, context, 7);
      }
#line 2188
      if (tmp) {
#line 2189
        constraint |= c;
      }
#line 2190
      if (! first_end) {
#line 2191
        first_end = *(d->tokens + (s->elems + j___0)->index);
      }
    } else
#line 2193
    if (*(d->tokens + (s->elems + j___0)->index) == 257L) {
#line 2194
      constraint = 511;
    }
#line 2183
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2199
  tmp___0 = maybe_realloc((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1,
                          (ptrdiff_t )sizeof(*(d->states)));
#line 2199
  d->states = (dfa_state *)tmp___0;
#line 2201
  (d->states + i)->hash = hash;
#line 2202
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2203
  copy(s, & (d->states + i)->elems);
#line 2204
  (d->states + i)->context = (unsigned char )context;
#line 2205
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2206
  (d->states + i)->first_end = first_end;
#line 2207
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2208
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2209
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2211
  (d->sindex) ++;
  }
#line 2213
  return (i);
}
}
#line 2221 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void epsclosure(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2225
  alloc_position_set(& tmp, (size_t )d->nleaves);
#line 2226
  i = (size_t )0;
  }
  {
#line 2226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2226
    if (! (i < (size_t )d->tindex)) {
#line 2226
      goto while_break;
    }
#line 2227
    if ((d->follows + i)->nelem > 0L) {
#line 2227
      if (*(d->tokens + i) >= 256L) {
#line 2227
        if (*(d->tokens + i) != 257L) {
#line 2227
          if (*(d->tokens + i) != 272L) {
#line 2227
            if (*(d->tokens + i) != 273L) {
#line 2227
              if (*(d->tokens + i) < 275L) {
                {
#line 2234
                if (*(d->tokens + i) == 258L) {
#line 2234
                  goto case_258;
                }
#line 2237
                if (*(d->tokens + i) == 259L) {
#line 2237
                  goto case_259;
                }
#line 2240
                if (*(d->tokens + i) == 260L) {
#line 2240
                  goto case_260;
                }
#line 2243
                if (*(d->tokens + i) == 261L) {
#line 2243
                  goto case_261;
                }
#line 2246
                if (*(d->tokens + i) == 262L) {
#line 2246
                  goto case_262;
                }
#line 2249
                if (*(d->tokens + i) == 263L) {
#line 2249
                  goto case_263;
                }
#line 2252
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2235
                constraint = 292U;
#line 2236
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2238
                constraint = 448U;
#line 2239
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2241
                constraint = 40U;
#line 2242
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2244
                constraint = 130U;
#line 2245
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2247
                constraint = 170U;
#line 2248
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2250
                constraint = 341U;
#line 2251
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2253
                constraint = 511U;
#line 2254
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2257
                delete(i, d->follows + i);
#line 2259
                j = (size_t )0;
                }
                {
#line 2259
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2259
                  if (! (j < (size_t )d->tindex)) {
#line 2259
                    goto while_break___0;
                  }
#line 2260
                  if (i != j) {
#line 2260
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2261
                      replace(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2259
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2263
                replace(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2265
  free((void *)tmp.elems);
  }
#line 2266
  return;
}
}
#line 2271 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int charclass_context(struct dfa  const  *dfa , charclass const   *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2274
  context = 0;
#line 2276
  j = 0U;
  {
#line 2276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2276
    if (! (j < 4U)) {
#line 2276
      goto while_break;
    }
#line 2278
    if (c->w[j] & dfa->syntax.newline.w[j]) {
#line 2279
      context |= 4;
    }
#line 2280
    if (c->w[j] & dfa->syntax.letters.w[j]) {
#line 2281
      context |= 2;
    }
#line 2282
    if (c->w[j] & ~ (dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j])) {
#line 2283
      context |= 1;
    }
#line 2276
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2286
  return (context);
}
}
#line 2295 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 2298
  separate_contexts = 0;
#line 2300
  j = (size_t )0;
  {
#line 2300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2300
    if (! (j < (size_t )s->nelem)) {
#line 2300
      goto while_break;
    }
    {
#line 2302
    tmp = prev_newline_dependent((int )(s->elems + j)->constraint);
    }
#line 2302
    if (tmp) {
#line 2303
      separate_contexts |= 4;
    }
    {
#line 2304
    tmp___0 = prev_letter_dependent((int )(s->elems + j)->constraint);
    }
#line 2304
    if (tmp___0) {
#line 2305
      separate_contexts |= 2;
    }
#line 2300
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2308
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2364 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaanalyze(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398 *stk ;
  position_set merged ;
  void *tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  position_set tmp___3 ;
  position *pos ;
  size_t j ;
  position_set tmp___4 ;
  position *pos___0 ;
  size_t j___0 ;
  position *pos___1 ;
  size_t j___1 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;
  state_num tmp___11 ;
  state_num tmp___12 ;

  {
  {
#line 2368
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2368
  posalloc = (position *)tmp;
#line 2370
  firstpos = posalloc + d->nleaves;
#line 2371
  lastpos = firstpos + d->nleaves;
#line 2374
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2374
  stkalloc = (struct __anonstruct_stkalloc_360611398 *)tmp___0;
#line 2374
  stk = stkalloc;
#line 2396
  d->searchflag = searchflag;
#line 2397
  alloc_position_set(& merged, d->nleaves);
#line 2398
  tmp___1 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2398
  d->follows = (position_set *)tmp___1;
#line 2400
  i = (size_t )0;
  }
  {
#line 2400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2400
    if (! (i < d->tindex)) {
#line 2400
      goto while_break;
    }
    {
#line 2404
    if (*(d->tokens + i) == 256L) {
#line 2404
      goto case_256;
    }
#line 2414
    if (*(d->tokens + i) == 266L) {
#line 2414
      goto case_266;
    }
#line 2414
    if (*(d->tokens + i) == 265L) {
#line 2414
      goto case_266;
    }
#line 2430
    if (*(d->tokens + i) == 264L) {
#line 2430
      goto case_264;
    }
#line 2436
    if (*(d->tokens + i) == 268L) {
#line 2436
      goto case_268;
    }
#line 2476
    if (*(d->tokens + i) == 269L) {
#line 2476
      goto case_269;
    }
#line 2488
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2406
    stk->nullable = (_Bool)1;
#line 2409
    tmp___2 = (size_t )0;
#line 2409
    stk->nlastpos = tmp___2;
#line 2409
    stk->nfirstpos = tmp___2;
#line 2410
    stk ++;
#line 2411
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2419
    tmp___3.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2420
    tmp___3.elems = firstpos;
#line 2421
    pos = lastpos;
#line 2422
    j = (size_t )0;
    {
#line 2422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2422
      if (! (j < (stk + -1)->nlastpos)) {
#line 2422
        goto while_break___0;
      }
      {
#line 2424
      merge((position_set const   *)(& tmp___3), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2425
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2422
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2432
    if (*(d->tokens + i) != 266L) {
#line 2433
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2434
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2441
    tmp___4.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2442
    tmp___4.elems = firstpos;
#line 2443
    pos___0 = lastpos + (stk + -1)->nlastpos;
#line 2444
    j___0 = (size_t )0;
    {
#line 2444
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2444
      if (! (j___0 < (stk + -2)->nlastpos)) {
#line 2444
        goto while_break___1;
      }
      {
#line 2446
      merge((position_set const   *)(& tmp___4), (position_set const   *)(d->follows + (pos___0 + j___0)->index),
            & merged);
#line 2447
      copy((position_set const   *)(& merged), d->follows + (pos___0 + j___0)->index);
#line 2444
      j___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2453
    if ((stk + -2)->nullable) {
#line 2454
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2456
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2460
    if ((stk + -1)->nullable) {
#line 2461
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2464
      pos___1 = lastpos + (stk + -2)->nlastpos;
#line 2465
      j___1 = (stk + -1)->nlastpos;
      {
#line 2465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2465
        tmp___5 = j___1;
#line 2465
        j___1 --;
#line 2465
        if (! (tmp___5 > 0UL)) {
#line 2465
          goto while_break___2;
        }
#line 2466
        *(pos___1 + j___1) = *(lastpos + j___1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2467
      lastpos += (stk + -2)->nlastpos;
#line 2468
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2472
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2473
    stk --;
#line 2474
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2478
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2481
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2484
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2485
    stk --;
#line 2486
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2494
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2497
    tmp___6 = (size_t )1;
#line 2497
    stk->nlastpos = tmp___6;
#line 2497
    stk->nfirstpos = tmp___6;
#line 2498
    stk ++;
#line 2500
    firstpos --;
#line 2500
    lastpos --;
#line 2501
    tmp___7 = i;
#line 2501
    lastpos->index = tmp___7;
#line 2501
    firstpos->index = tmp___7;
#line 2502
    tmp___8 = 511U;
#line 2502
    lastpos->constraint = tmp___8;
#line 2502
    firstpos->constraint = tmp___8;
#line 2504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2549
  merged.nelem = (ptrdiff_t )0;
#line 2550
  i___0 = (size_t )0;
  {
#line 2550
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2550
    if (! (i___0 < (stk + -1)->nfirstpos)) {
#line 2550
      goto while_break___3;
    }
    {
#line 2551
    insert(*(firstpos + i___0), & merged);
#line 2550
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2555
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2558
  tmp___9 = state_separate_contexts((position_set const   *)(& merged));
#line 2558
  separate_contexts = (int )tmp___9;
  }
#line 2561
  if (separate_contexts & 4) {
    {
#line 2562
    state_index(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2563
  tmp___11 = state_index(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2563
  tmp___10 = (int )tmp___11;
#line 2563
  d->min_trcount = tmp___10;
#line 2563
  d->initstate_notbol = (state_num )tmp___10;
  }
#line 2565
  if (separate_contexts & 2) {
    {
#line 2566
    tmp___12 = state_index(d, (position_set const   *)(& merged), 2);
#line 2566
    d->min_trcount = (int )tmp___12;
    }
  }
  {
#line 2567
  (d->min_trcount) ++;
#line 2568
  d->trcount = 0;
#line 2570
  free((void *)posalloc);
#line 2571
  free((void *)stkalloc);
#line 2572
  free((void *)merged.elems);
  }
#line 2573
  return;
}
}
#line 2576 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc1 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  state_num *tmp___2 ;
  ptrdiff_t newalloc ;
  state_num tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num *tmp___8 ;

  {
#line 2579
  oldalloc = d->tralloc;
#line 2580
  if (oldalloc < d->sindex) {
#line 2582
    if (d->trans) {
#line 2582
      tmp = d->trans - 2;
    } else {
#line 2582
      tmp = (state_num **)((void *)0);
    }
#line 2582
    realtrans = tmp;
#line 2583
    if (realtrans) {
#line 2583
      tmp___0 = d->tralloc + 2L;
    } else {
#line 2583
      tmp___0 = (state_num )0;
    }
    {
#line 2583
    newalloc1 = tmp___0;
#line 2584
    tmp___1 = xpalloc((void *)realtrans, & newalloc1, d->sindex - oldalloc, (ptrdiff_t )-1,
                      (ptrdiff_t )sizeof(*realtrans));
#line 2584
    realtrans = (state_num **)tmp___1;
#line 2586
    tmp___2 = (state_num *)((void *)0);
#line 2586
    *(realtrans + 1) = tmp___2;
#line 2586
    *(realtrans + 0) = tmp___2;
#line 2587
    d->trans = realtrans + 2;
#line 2588
    tmp___3 = newalloc1 - 2L;
#line 2588
    d->tralloc = tmp___3;
#line 2588
    newalloc = tmp___3;
#line 2589
    tmp___4 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2589
    d->fails = (state_num **)tmp___4;
#line 2590
    tmp___5 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2590
    d->success = (char *)tmp___5;
#line 2591
    tmp___6 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2591
    d->newlines = (state_num *)tmp___6;
    }
#line 2592
    if (d->localeinfo.multibyte) {
#line 2594
      if (d->mb_trans) {
#line 2594
        realtrans = d->mb_trans - 2;
      } else {
#line 2594
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2595
      tmp___7 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2595
      realtrans = (state_num **)tmp___7;
      }
#line 2596
      if (oldalloc == 0L) {
#line 2597
        tmp___8 = (state_num *)((void *)0);
#line 2597
        *(realtrans + 1) = tmp___8;
#line 2597
        *(realtrans + 0) = tmp___8;
      }
#line 2598
      d->mb_trans = realtrans + 2;
    }
    {
#line 2600
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2600
      if (! (oldalloc < newalloc)) {
#line 2600
        goto while_break;
      }
#line 2602
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2603
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2604
      if (d->localeinfo.multibyte) {
#line 2605
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2600
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2608
  return;
}
}
#line 2643 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num build_state(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  state_num **ptrans ;
  state_num **tmp___1 ;
  _Bool tmp___2 ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___3 ;
  void *tmp___4 ;
  int i___0 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  leaf_set group ;
  void *tmp___8 ;
  charclass label___0 ;
  size_t i___1 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  size_t j ;
  _Bool tmp___11 ;
  size_t j___0 ;
  _Bool tmp___12 ;
  size_t j___1 ;
  _Bool tmp___13 ;
  size_t j___2 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  size_t k ;
  size_t tmp___17 ;
  size_t k___0 ;
  size_t j___3 ;
  size_t k___1 ;
  _Bool mergeit ;
  size_t j___4 ;
  int possible_contexts ;
  int tmp___18 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___19 ;
  size_t i___2 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  {
#line 2657
  tmp___2 = accepting(s, (struct dfa  const  *)d);
  }
#line 2657
  if (tmp___2) {
#line 2657
    tmp___1 = d->fails;
  } else {
#line 2657
    tmp___1 = d->trans;
  }
#line 2657
  ptrans = tmp___1 + s;
#line 2658
  trans = *ptrans;
#line 2660
  if (! trans) {
#line 2666
    if (1024 <= d->trcount) {
#line 2668
      i = (state_num )d->min_trcount;
      {
#line 2668
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2668
        if (! (i < d->tralloc)) {
#line 2668
          goto while_break;
        }
        {
#line 2670
        free((void *)*(d->trans + i));
#line 2671
        free((void *)*(d->fails + i));
#line 2672
        tmp___3 = (state_num *)((void *)0);
#line 2672
        *(d->fails + i) = tmp___3;
#line 2672
        *(d->trans + i) = tmp___3;
#line 2668
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2674
      d->trcount = 0;
    }
    {
#line 2677
    (d->trcount) ++;
#line 2678
    tmp___4 = xmalloc(256UL * sizeof(*trans));
#line 2678
    trans = (state_num *)tmp___4;
#line 2678
    *ptrans = trans;
#line 2682
    i___0 = 0;
    }
    {
#line 2682
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2682
      if (! (i___0 < 256)) {
#line 2682
        goto while_break___0;
      }
#line 2683
      *(trans + i___0) = (state_num )-2;
#line 2682
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2687
  *(d->success + s) = (char)0;
#line 2688
  tmp___5 = accepts_in_context((int )(d->states + s)->context, 4, s, (struct dfa  const  *)d);
  }
#line 2688
  if (tmp___5) {
#line 2689
    *(d->success + s) = (char )((int )*(d->success + s) | 4);
  }
  {
#line 2690
  tmp___6 = accepts_in_context((int )(d->states + s)->context, 2, s, (struct dfa  const  *)d);
  }
#line 2690
  if (tmp___6) {
#line 2691
    *(d->success + s) = (char )((int )*(d->success + s) | 2);
  }
  {
#line 2692
  tmp___7 = accepts_in_context((int )(d->states + s)->context, 1, s, (struct dfa  const  *)d);
  }
#line 2692
  if (tmp___7) {
#line 2693
    *(d->success + s) = (char )((int )*(d->success + s) | 1);
  }
  {
#line 2697
  tmp___8 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2697
  group.elems = (size_t *)tmp___8;
#line 2698
  group.nelem = (size_t )0;
#line 2702
  fillset(& label___0);
#line 2704
  i___1 = (size_t )0;
  }
  {
#line 2704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2704
    if (! (i___1 < (size_t )(d->states + s)->elems.nelem)) {
#line 2704
      goto while_break___1;
    }
#line 2707
    pos = *((d->states + s)->elems.elems + i___1);
#line 2708
    matched = (_Bool)0;
#line 2709
    if (*(d->tokens + pos.index) >= 0L) {
#line 2709
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2711
        zeroset(& matches);
#line 2712
        setbit((unsigned int )*(d->tokens + pos.index), & matches);
        }
#line 2713
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2714
          matched = (_Bool)1;
        }
      } else {
#line 2709
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2716
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2718
      matches = *(d->charclasses + (*(d->tokens + pos.index) - 275L));
#line 2719
      tmp___9 = tstbit((unsigned int )uc, (charclass const   *)(d->charclasses + (*(d->tokens + pos.index) - 275L)));
      }
#line 2719
      if (tmp___9) {
#line 2720
        matched = (_Bool)1;
      }
    } else
#line 2722
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2724
      matches = *(d->charclasses + d->canychar);
#line 2725
      tmp___10 = tstbit((unsigned int )uc, (charclass const   *)(d->charclasses + d->canychar));
      }
#line 2725
      if (tmp___10) {
#line 2726
        matched = (_Bool)1;
      }
      {
#line 2734
      tmp___11 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2734
      if (tmp___11) {
#line 2737
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2738
          alloc_position_set(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2740
        j = (size_t )0;
        {
#line 2740
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2740
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2740
            goto while_break___2;
          }
          {
#line 2741
          insert(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2740
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 2745
      goto __Cont;
    }
#line 2749
    if (pos.constraint != 511U) {
      {
#line 2751
      tmp___12 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     4);
      }
#line 2751
      if (! tmp___12) {
#line 2753
        j___0 = (size_t )0;
        {
#line 2753
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2753
          if (! (j___0 < 4UL)) {
#line 2753
            goto while_break___3;
          }
#line 2754
          matches.w[j___0] &= ~ d->syntax.newline.w[j___0];
#line 2753
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 2755
      tmp___13 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     2);
      }
#line 2755
      if (! tmp___13) {
#line 2757
        j___1 = (size_t )0;
        {
#line 2757
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2757
          if (! (j___1 < 4UL)) {
#line 2757
            goto while_break___4;
          }
#line 2758
          matches.w[j___1] &= ~ d->syntax.letters.w[j___1];
#line 2757
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2759
      tmp___14 = succeeds_in_context((int )pos.constraint, (int )(d->states + s)->context,
                                     1);
      }
#line 2759
      if (! tmp___14) {
#line 2761
        j___2 = (size_t )0;
        {
#line 2761
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2761
          if (! (j___2 < 4UL)) {
#line 2761
            goto while_break___5;
          }
#line 2762
          matches.w[j___2] &= d->syntax.letters.w[j___2] | d->syntax.newline.w[j___2];
#line 2761
          j___2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2765
      tmp___15 = emptyset((charclass const   *)(& matches));
      }
#line 2765
      if (tmp___15) {
#line 2766
        goto __Cont;
      }
      {
#line 2771
      tmp___16 = tstbit((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2771
      if (! tmp___16) {
#line 2772
        matched = (_Bool)0;
      }
    }
#line 2785
    if (matched) {
#line 2787
      k = (size_t )0;
      {
#line 2787
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2787
        if (! (k < 4UL)) {
#line 2787
          goto while_break___6;
        }
#line 2788
        label___0.w[k] &= matches.w[k];
#line 2787
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2789
      tmp___17 = group.nelem;
#line 2789
      (group.nelem) ++;
#line 2789
      *(group.elems + tmp___17) = pos.index;
    } else {
#line 2793
      k___0 = (size_t )0;
      {
#line 2793
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2793
        if (! (k___0 < 4UL)) {
#line 2793
          goto while_break___7;
        }
#line 2794
        label___0.w[k___0] &= ~ matches.w[k___0];
#line 2793
        k___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2704
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2798
  alloc_position_set(& follows, d->nleaves);
#line 2799
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2801
  if (group.nelem > 0UL) {
#line 2803
    follows.nelem = (ptrdiff_t )0;
#line 2807
    j___3 = (size_t )0;
    {
#line 2807
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2807
      if (! (j___3 < group.nelem)) {
#line 2807
        goto while_break___8;
      }
#line 2808
      k___1 = (size_t )0;
      {
#line 2808
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2808
        if (! (k___1 < (size_t )(d->follows + *(group.elems + j___3))->nelem)) {
#line 2808
          goto while_break___9;
        }
        {
#line 2809
        insert(*((d->follows + *(group.elems + j___3))->elems + k___1), & follows);
#line 2808
        k___1 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2807
      j___3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2813
    if (d->searchflag) {
#line 2832
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2833
      if (! mergeit) {
#line 2835
        mergeit = (_Bool)1;
#line 2836
        j___4 = (size_t )0;
        {
#line 2836
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2836
          if (mergeit) {
#line 2836
            if (! (j___4 < (size_t )follows.nelem)) {
#line 2836
              goto while_break___10;
            }
          } else {
#line 2836
            goto while_break___10;
          }
#line 2837
          mergeit = (_Bool )((int )mergeit & (int )*(d->multibyte_prop + (follows.elems + j___4)->index));
#line 2836
          j___4 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2839
      if (mergeit) {
        {
#line 2841
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2842
        copy((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2849
    tmp___18 = charclass_context((struct dfa  const  *)d, (charclass const   *)(& label___0));
#line 2849
    possible_contexts = tmp___18;
#line 2850
    tmp___19 = state_separate_contexts((position_set const   *)(& follows));
#line 2850
    separate_contexts = (int )tmp___19;
    }
#line 2853
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2854
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2856
      state = (state_num )-1;
    }
#line 2857
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2858
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2860
      state_newline = state;
    }
#line 2861
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2862
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2864
      state_letter = state;
    }
    {
#line 2867
    realloc_trans_if_necessary(d);
    }
  } else
#line 2873
  if (d->searchflag) {
#line 2875
    state_newline = (state_num )0;
#line 2876
    state_letter = (state_num )(d->min_trcount - 1);
#line 2877
    state = d->initstate_notbol;
  } else {
#line 2881
    state_newline = (state_num )-1;
#line 2882
    state_letter = (state_num )-1;
#line 2883
    state = (state_num )-1;
  }
#line 2887
  i___2 = (size_t )0;
  {
#line 2887
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2887
    if (! (i___2 < 256UL)) {
#line 2887
      goto while_break___11;
    }
    {
#line 2888
    tmp___20 = tstbit((unsigned int )i___2, (charclass const   *)(& label___0));
    }
#line 2888
    if (tmp___20) {
      {
#line 2891
      if ((int )d->syntax.sbit[i___2] == 4) {
#line 2891
        goto case_4;
      }
#line 2894
      if ((int )d->syntax.sbit[i___2] == 2) {
#line 2894
        goto case_2;
      }
#line 2897
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2892
      *(trans + i___2) = state_newline;
#line 2893
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2895
      *(trans + i___2) = state_letter;
#line 2896
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2898
      *(trans + i___2) = state;
#line 2899
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2887
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2913
  free((void *)group.elems);
#line 2914
  free((void *)follows.elems);
#line 2915
  free((void *)tmp.elems);
#line 2919
  tmp___21 = tstbit((unsigned int )d->syntax.eolbyte, (charclass const   *)(& label___0));
  }
#line 2919
  if (tmp___21) {
#line 2921
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2922
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2925
  return (*(trans + uc));
}
}
#line 2934 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num transit_state_singlebyte(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2939
  if (*(d->trans + s)) {
#line 2940
    t = *(d->trans + s);
  } else
#line 2941
  if (*(d->fails + s)) {
#line 2942
    t = *(d->fails + s);
  } else {
    {
#line 2945
    build_state(s, d, (unsigned char )*(*pp));
    }
#line 2946
    if (*(d->trans + s)) {
#line 2947
      t = *(d->trans + s);
    } else {
#line 2950
      t = *(d->fails + s);
#line 2951
      if (! t) {
        {
#line 2951
        __assert_fail("t", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c", 2951U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2955
  if (*(t + *(*pp)) == -2L) {
    {
#line 2956
    build_state(s, d, (unsigned char )*(*pp));
    }
  }
#line 2958
  tmp___0 = *pp;
#line 2958
  (*pp) ++;
#line 2958
  return (*(t + *tmp___0));
}
}
#line 2964 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ,
                               unsigned char const   *end ) 
{ 
  wint_t wc ;
  int mbclen ;
  size_t tmp ;
  state_num s1 ;
  int mbci ;
  state_num s3 ;
  state_num i ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___2 ;
  state_num s2 ;
  state_num tmp___3 ;

  {
  {
#line 2970
  tmp = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2970
  mbclen = (int )tmp;
#line 2973
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 2977
  s1 = s;
#line 2979
  mbci = 0;
  }
  {
#line 2979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2979
    if (mbci < mbclen) {
#line 2979
      if (! (mbci == 0)) {
#line 2979
        if (! ((state_num )d->min_trcount <= s)) {
#line 2979
          goto while_break;
        }
      }
    } else {
#line 2979
      goto while_break;
    }
    {
#line 2980
    s = transit_state_singlebyte(d, s, pp);
#line 2979
    mbci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2981
  *pp += mbclen - mbci;
#line 2983
  if (wc == 4294967295U) {
#line 2986
    return (s);
  }
#line 2992
  if ((d->states + s1)->mb_trindex < 0L) {
#line 2994
    if (1024L <= d->mb_trcount) {
#line 2997
      s3 = (state_num )-1;
      {
#line 2997
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2997
        if (! (s3 < d->tralloc)) {
#line 2997
          goto while_break___0;
        }
        {
#line 2999
        free((void *)*(d->mb_trans + s3));
#line 3000
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 2997
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3003
      i = (state_num )0;
      {
#line 3003
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3003
        if (! (i < d->sindex)) {
#line 3003
          goto while_break___1;
        }
#line 3004
        (d->states + i)->mb_trindex = (state_num )-1;
#line 3003
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3005
      d->mb_trcount = (state_num )0;
    }
#line 3007
    tmp___0 = d->mb_trcount;
#line 3007
    (d->mb_trcount) ++;
#line 3007
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3010
  if (! *(d->mb_trans + s)) {
    {
#line 3014
    tmp___1 = xmalloc((size_t )8192);
#line 3014
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3015
    i___0 = 0;
    }
    {
#line 3015
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3015
      if (! (i___0 < 1024)) {
#line 3015
        goto while_break___2;
      }
#line 3016
      *(*(d->mb_trans + s) + i___0) = (state_num )-1;
#line 3015
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3018
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3019
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3021
  if (s == -1L) {
    {
#line 3022
    copy((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3024
    merge((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
          & d->mb_follows);
    }
  }
  {
#line 3026
  tmp___2 = state_separate_contexts((position_set const   *)(& d->mb_follows));
#line 3026
  separate_contexts = (int )tmp___2;
#line 3027
  tmp___3 = state_index(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3027
  s2 = tmp___3;
#line 3028
  realloc_trans_if_necessary(d);
#line 3030
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3032
  return (s2);
}
}
#line 3050 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned char const   *skip_remains_mb(struct dfa *d , unsigned char const   *p ,
                                              unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3054
  if (d->syntax.never_trail[*p]) {
#line 3055
    return (p);
  }
  {
#line 3056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3056
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3056
      goto while_break;
    }
    {
#line 3059
    tmp = mbs_to_wchar(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                       d);
#line 3059
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3062
  return (mbp);
}
}
#line 3085 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
__inline static char *dfaexec_main(struct dfa *d , char const   *begin , char *end ,
                                   _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s___0 ;
  state_num *tmp ;
  state_num s___1 ;
  state_num s___2 ;
  state_num s___3 ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  _Bool tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3089
  if (1024L <= d->sindex) {
#line 3091
    s = (state_num )d->min_trcount;
    {
#line 3091
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3091
      if (! (s < d->sindex)) {
#line 3091
        goto while_break;
      }
      {
#line 3093
      free((void *)(d->states + s)->elems.elems);
#line 3094
      free((void *)(d->states + s)->mbps.elems);
#line 3091
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3096
    d->sindex = (state_num )d->min_trcount;
#line 3098
    if (d->trans) {
#line 3100
      s___0 = (state_num )0;
      {
#line 3100
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3100
        if (! (s___0 < d->tralloc)) {
#line 3100
          goto while_break___0;
        }
        {
#line 3102
        free((void *)*(d->trans + s___0));
#line 3103
        free((void *)*(d->fails + s___0));
#line 3104
        tmp = (state_num *)((void *)0);
#line 3104
        *(d->fails + s___0) = tmp;
#line 3104
        *(d->trans + s___0) = tmp;
#line 3100
        s___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3106
      d->trcount = 0;
    }
#line 3109
    if (d->localeinfo.multibyte) {
#line 3109
      if (d->mb_trans) {
#line 3111
        s___1 = (state_num )-1;
        {
#line 3111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3111
          if (! (s___1 < d->tralloc)) {
#line 3111
            goto while_break___1;
          }
          {
#line 3113
          free((void *)*(d->mb_trans + s___1));
#line 3114
          *(d->mb_trans + s___1) = (state_num *)((void *)0);
#line 3111
          s___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3116
        s___2 = (state_num )0;
        {
#line 3116
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3116
          if (! (s___2 < (state_num )d->min_trcount)) {
#line 3116
            goto while_break___2;
          }
#line 3117
          (d->states + s___2)->mb_trindex = (state_num )-1;
#line 3116
          s___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3118
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3122
  if (! d->tralloc) {
    {
#line 3123
    realloc_trans_if_necessary(d);
    }
  }
#line 3126
  s___3 = (state_num )0;
#line 3126
  s1 = (state_num )0;
#line 3129
  p = (unsigned char const   *)begin;
#line 3130
  mbp = p;
#line 3133
  trans = d->trans;
#line 3134
  eol = d->syntax.eolbyte;
#line 3135
  saved_end = *((unsigned char *)end);
#line 3136
  *end = (char )eol;
#line 3138
  if (multibyte) {
    {
#line 3140
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3141
    if (d->mb_follows.alloc == 0L) {
      {
#line 3142
      alloc_position_set(& d->mb_follows, d->nleaves);
      }
    }
  }
#line 3145
  nlcount = (size_t )0;
  {
#line 3146
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3149
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3149
      t = *(trans + s___3);
#line 3149
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3149
        goto while_break___4;
      }
#line 3151
      if (s___3 < (state_num )d->min_trcount) {
#line 3153
        if (! multibyte) {
#line 3153
          goto _L;
        } else
#line 3153
        if ((d->states + s___3)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3155
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3155
            if (! (*(t + *p) == s___3)) {
#line 3155
              goto while_break___5;
            }
#line 3156
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3158
        if (multibyte) {
          {
#line 3159
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3159
          p = mbp;
          }
        }
      }
#line 3162
      if (multibyte) {
#line 3164
        s1 = s___3;
#line 3166
        if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else
#line 3166
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else
#line 3166
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else {
          {
#line 3175
          s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3176
          mbp = p;
#line 3177
          trans = d->trans;
          }
        }
      } else {
#line 3182
        tmp___1 = p;
#line 3182
        p ++;
#line 3182
        s1 = *(t + *tmp___1);
#line 3183
        t = *(trans + s1);
#line 3184
        if (! t) {
#line 3186
          tmp___2 = s___3;
#line 3187
          s___3 = s1;
#line 3188
          s1 = tmp___2;
#line 3189
          goto while_break___4;
        }
#line 3191
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3193
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3193
            if (! (*(t + *p) == s1)) {
#line 3193
              goto while_break___6;
            }
#line 3194
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3196
        tmp___3 = p;
#line 3196
        p ++;
#line 3196
        s___3 = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3200
    if (s___3 < 0L) {
#line 3202
      if (s___3 == -2L) {
        {
#line 3204
        s___3 = build_state(s1, d, (unsigned char )*(p + -1));
#line 3205
        trans = d->trans;
        }
      } else
#line 3207
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3207
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3207
          if (0L <= *(d->newlines + s1)) {
#line 3211
            nlcount ++;
#line 3212
            mbp = p;
#line 3214
            if (allow_nl) {
#line 3214
              s___3 = *(d->newlines + s1);
            } else {
#line 3214
              if ((int )d->syntax.sbit[eol] == 4) {
#line 3214
                tmp___5 = (state_num )0;
              } else {
#line 3214
                if ((int )d->syntax.sbit[eol] == 2) {
#line 3214
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3214
                  tmp___4 = d->initstate_notbol;
                }
#line 3214
                tmp___5 = tmp___4;
              }
#line 3214
              s___3 = tmp___5;
            }
          } else {
#line 3221
            p = (unsigned char const   *)((void *)0);
#line 3222
            goto done;
          }
        } else {
#line 3221
          p = (unsigned char const   *)((void *)0);
#line 3222
          goto done;
        }
      } else {
#line 3221
        p = (unsigned char const   *)((void *)0);
#line 3222
        goto done;
      }
    } else
#line 3225
    if (*(d->fails + s___3)) {
#line 3227
      if ((int )*(d->success + s___3) & (int )d->syntax.sbit[*p]) {
#line 3231
        goto done;
      } else
#line 3227
      if ((unsigned long )((char *)p) == (unsigned long )end) {
        {
#line 3227
        tmp___6 = accepts_in_context((int )(d->states + s___3)->context, 4, s___3,
                                     (struct dfa  const  *)d);
        }
#line 3227
        if (tmp___6) {
#line 3231
          goto done;
        }
      }
#line 3233
      if (multibyte) {
#line 3233
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3234
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3234
          p = mbp;
          }
        }
      }
#line 3236
      s1 = s___3;
#line 3237
      if (! multibyte) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else {
        {
#line 3246
        s___3 = transit_state(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3247
        mbp = p;
#line 3248
        trans = d->trans;
        }
      }
    } else {
      {
#line 3253
      build_state(s___3, d, (unsigned char )*(p + 0));
#line 3254
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3259
  if (count) {
#line 3260
    *count += nlcount;
  }
#line 3261
  *end = (char )saved_end;
#line 3262
  return ((char *)p);
}
}
#line 3268 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_mb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3272
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3272
  return (tmp);
}
}
#line 3275 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_sb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3279
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3279
  return (tmp);
}
}
#line 3284 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_noop(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                          size_t *count , _Bool *backref ) 
{ 


  {
#line 3288
  *backref = (_Bool)1;
#line 3289
  return ((char *)begin);
}
}
#line 3296 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3300
  tmp = (*(d->dfaexec))(d, begin, end, allow_nl, count, backref);
  }
#line 3300
  return (tmp);
}
}
#line 3303
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3303 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct dfa *dfasuperset(struct dfa  const  *d ) 
{ 


  {
#line 3306
  return ((struct dfa *)d->superset);
}
}
#line 3309
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3309 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
_Bool dfaisfast(struct dfa  const  *d ) 
{ 


  {
#line 3312
  return ((_Bool )d->fast);
}
}
#line 3315 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  state_num s ;

  {
  {
#line 3318
  free((void *)d->multibyte_prop);
#line 3319
  free((void *)d->lex.brack.chars);
#line 3320
  free((void *)d->mb_follows.elems);
  }
#line 3322
  if (d->mb_trans) {
#line 3325
    s = (state_num )-1;
    {
#line 3325
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3325
      if (! (s < d->tralloc)) {
#line 3325
        goto while_break;
      }
      {
#line 3326
      free((void *)*(d->mb_trans + s));
#line 3325
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3327
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3329
  return;
}
}
#line 3332 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3335
  i = (size_t )0;
  {
#line 3335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3335
    if (! (i < (size_t )d->tindex)) {
#line 3335
      goto while_break;
    }
    {
#line 3342
    if (*(d->tokens + i) == 263L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 262L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 261L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 260L) {
#line 3342
      goto case_263;
    }
#line 3348
    if (*(d->tokens + i) == 273L) {
#line 3348
      goto case_273;
    }
#line 3348
    if (*(d->tokens + i) == 257L) {
#line 3348
      goto case_273;
    }
#line 3337
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3343
    if (! d->localeinfo.multibyte) {
#line 3344
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3349
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3352
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3355 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  _Bool have_backref ;
  size_t i ;

  {
#line 3358
  if (! d->localeinfo.using_utf8) {
#line 3359
    return;
  }
#line 3361
  have_backref = (_Bool)0;
#line 3362
  i = (size_t )0;
  {
#line 3362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3362
    if (! (i < d->tindex)) {
#line 3362
      goto while_break;
    }
    {
#line 3366
    if (*(d->tokens + i) == 272L) {
#line 3366
      goto case_272;
    }
#line 3369
    if (*(d->tokens + i) == 257L) {
#line 3369
      goto case_257;
    }
#line 3372
    if (*(d->tokens + i) == 273L) {
#line 3372
      goto case_273;
    }
#line 3375
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3368
    abort();
    }
    case_257: /* CIL Label */ 
#line 3370
    have_backref = (_Bool)1;
#line 3371
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3374
    return;
    switch_default: /* CIL Label */ 
#line 3376
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3380
  if (! have_backref) {
#line 3380
    if (d->superset) {
      {
#line 3383
      dfafree(d->superset);
#line 3384
      free((void *)d->superset);
#line 3385
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3388
  free_mbdata(d);
#line 3389
  d->localeinfo.multibyte = (_Bool)0;
#line 3390
  d->dfaexec = & dfaexec_sb;
#line 3391
  d->fast = (_Bool)1;
  }
#line 3392
  return;
}
}
#line 3394 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfassbuild(struct dfa *d ) 
{ 
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  _Bool have_achar ;
  _Bool have_nchar ;
  size_t j ;
  size_t i ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3397
  tmp = dfaalloc();
#line 3397
  sup = tmp;
#line 3399
  *sup = *d;
#line 3400
  sup->localeinfo.multibyte = (_Bool)0;
#line 3401
  sup->dfaexec = & dfaexec_sb;
#line 3402
  sup->multibyte_prop = (char *)((void *)0);
#line 3403
  sup->superset = (struct dfa *)((void *)0);
#line 3404
  sup->states = (dfa_state *)((void *)0);
#line 3405
  sup->sindex = (state_num )0;
#line 3406
  sup->follows = (position_set *)((void *)0);
#line 3407
  sup->tralloc = (state_num )0;
#line 3408
  sup->trans = (state_num **)((void *)0);
#line 3409
  sup->fails = (state_num **)((void *)0);
#line 3410
  sup->success = (char *)((void *)0);
#line 3411
  sup->newlines = (state_num *)((void *)0);
#line 3413
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3413
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3414
  if (d->cindex) {
    {
#line 3416
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3420
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3420
  sup->tokens = (token *)tmp___1;
#line 3421
  sup->talloc = d->tindex * 2UL;
#line 3423
  have_achar = (_Bool)0;
#line 3424
  have_nchar = (_Bool)0;
#line 3426
  j = (size_t )0;
#line 3426
  i = j;
  }
  {
#line 3426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3426
    if (! (i < d->tindex)) {
#line 3426
      goto while_break;
    }
    {
#line 3432
    if (*(d->tokens + i) == 257L) {
#line 3432
      goto case_257;
    }
#line 3432
    if (*(d->tokens + i) == 273L) {
#line 3432
      goto case_257;
    }
#line 3432
    if (*(d->tokens + i) == 272L) {
#line 3432
      goto case_257;
    }
#line 3447
    if (*(d->tokens + i) == 263L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 262L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 261L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 260L) {
#line 3447
      goto case_263;
    }
#line 3456
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3435
    fillset(& ccl);
#line 3436
    tmp___2 = j;
#line 3436
    j ++;
#line 3436
    tmp___3 = charclass_index(sup, & ccl);
#line 3436
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3437
    tmp___4 = j;
#line 3437
    j ++;
#line 3437
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3438
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3440
      i ++;
    } else
#line 3438
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3440
      i ++;
    } else
#line 3438
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3440
      i ++;
    }
#line 3441
    have_achar = (_Bool)1;
#line 3443
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3448
    if (d->localeinfo.multibyte) {
#line 3452
      tmp___5 = j;
#line 3452
      j ++;
#line 3452
      *(sup->tokens + tmp___5) = (token )256;
#line 3453
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3457
    tmp___6 = j;
#line 3457
    j ++;
#line 3457
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3458
    if (0L <= *(d->tokens + i)) {
#line 3458
      if (*(d->tokens + i) < 256L) {
#line 3460
        have_nchar = (_Bool)1;
      } else {
#line 3458
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3458
    if (*(d->tokens + i) >= 275L) {
#line 3460
      have_nchar = (_Bool)1;
    }
#line 3461
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3464
  sup->tindex = j;
#line 3466
  if (have_nchar) {
#line 3466
    if (have_achar) {
#line 3467
      d->superset = sup;
    } else
#line 3466
    if (d->localeinfo.multibyte) {
#line 3467
      d->superset = sup;
    } else {
      {
#line 3470
      dfafree(sup);
#line 3471
      free((void *)sup);
      }
    }
  } else {
    {
#line 3470
    dfafree(sup);
#line 3471
    free((void *)sup);
    }
  }
#line 3473
  return;
}
}
#line 3476 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;

  {
  {
#line 3479
  dfaparse(s, len, d);
#line 3480
  dfassbuild(d);
#line 3482
  tmp = dfa_supported((struct dfa  const  *)d);
  }
#line 3482
  if (tmp) {
    {
#line 3484
    dfaoptimize(d);
#line 3485
    dfaanalyze(d, searchflag);
    }
  } else {
#line 3489
    d->dfaexec = & dfaexec_noop;
  }
#line 3492
  if (d->superset) {
    {
#line 3494
    d->fast = (_Bool)1;
#line 3495
    dfaanalyze(d->superset, searchflag);
    }
  }
#line 3497
  return;
}
}
#line 3500 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i ;
  size_t i___0 ;
  size_t i___1 ;

  {
  {
#line 3503
  free((void *)d->charclasses);
#line 3504
  free((void *)d->tokens);
  }
#line 3506
  if (d->localeinfo.multibyte) {
    {
#line 3507
    free_mbdata(d);
    }
  }
#line 3509
  i = (size_t )0;
  {
#line 3509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3509
    if (! (i < (size_t )d->sindex)) {
#line 3509
      goto while_break;
    }
    {
#line 3511
    free((void *)(d->states + i)->elems.elems);
#line 3512
    free((void *)(d->states + i)->mbps.elems);
#line 3509
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3514
  free((void *)d->states);
  }
#line 3516
  if (d->follows) {
#line 3518
    i___0 = (size_t )0;
    {
#line 3518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3518
      if (! (i___0 < d->tindex)) {
#line 3518
        goto while_break___0;
      }
      {
#line 3519
      free((void *)(d->follows + i___0)->elems);
#line 3518
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3520
    free((void *)d->follows);
    }
  }
#line 3523
  if (d->trans) {
#line 3525
    i___1 = (size_t )0;
    {
#line 3525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3525
      if (! (i___1 < (size_t )d->tralloc)) {
#line 3525
        goto while_break___1;
      }
      {
#line 3527
      free((void *)*(d->trans + i___1));
#line 3528
      free((void *)*(d->fails + i___1));
#line 3525
      i___1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3531
    free((void *)(d->trans - 2));
#line 3532
    free((void *)d->fails);
#line 3533
    free((void *)d->newlines);
#line 3534
    free((void *)d->success);
    }
  }
#line 3537
  if (d->superset) {
    {
#line 3538
    dfafree(d->superset);
    }
  }
#line 3539
  return;
}
}
#line 3623 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  size_t newsize ;
  size_t tmp ;
  size_t oldsize ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 3626
  tmp = strlen(new);
#line 3626
  newsize = tmp;
  }
#line 3627
  if (newsize == 0UL) {
#line 3628
    return (old);
  }
  {
#line 3629
  tmp___0 = strlen((char const   *)old);
#line 3629
  oldsize = tmp___0;
#line 3630
  tmp___1 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3630
  result = (char *)tmp___1;
#line 3631
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3632
  return (result);
}
}
#line 3635 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void freelist(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3638
    if (! *cpp) {
#line 3638
      goto while_break;
    }
    {
#line 3639
    tmp = cpp;
#line 3639
    cpp ++;
#line 3639
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3640
  return;
}
}
#line 3642 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t i ;
  char *tmp___1 ;
  size_t j ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3645
  tmp = xmalloc(len + 1UL);
#line 3645
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3645
  new = (char *)tmp___0;
#line 3646
  *(new + len) = (char )'\000';
#line 3649
  i = (size_t )0;
  }
  {
#line 3649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3649
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3649
      goto while_break;
    }
    {
#line 3650
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3650
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3652
      free((void *)new);
      }
#line 3653
      return (cpp);
    }
#line 3649
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3656
  j = (size_t )0;
  {
#line 3656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3656
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3656
      goto while_break___0;
    }
    {
#line 3657
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3657
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3658
      j ++;
    } else {
      {
#line 3661
      free((void *)*(cpp + j));
#line 3662
      i --;
      }
#line 3662
      if (i == j) {
#line 3663
        goto while_break___0;
      }
#line 3664
      *(cpp + j) = *(cpp + i);
#line 3665
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3668
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3668
  cpp = (char **)tmp___3;
#line 3669
  *(cpp + i) = new;
#line 3670
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3671
  return (cpp);
}
}
#line 3676 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3679
  tmp = xzalloc(sizeof(*cpp));
#line 3679
  cpp = (char **)tmp;
#line 3681
  lcp = left;
  }
  {
#line 3681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3681
    if (! ((int )*lcp != 0)) {
#line 3681
      goto while_break;
    }
    {
#line 3683
    len = (size_t )0;
#line 3684
    tmp___0 = strchr(right, (int )*lcp);
#line 3684
    rcp = tmp___0;
    }
    {
#line 3685
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3685
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3685
        goto while_break___0;
      }
#line 3688
      i = (size_t )1;
      {
#line 3688
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3688
        if ((int )*(lcp + i) != 0) {
#line 3688
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3688
            goto while_break___1;
          }
        } else {
#line 3688
          goto while_break___1;
        }
#line 3689
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3688
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3690
      if (i > len) {
#line 3691
        len = i;
      }
      {
#line 3692
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3694
    if (len != 0UL) {
      {
#line 3695
      cpp = enlist(cpp, lcp, len);
      }
    }
#line 3681
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3697
  return (cpp);
}
}
#line 3700 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3703
    if (! *new) {
#line 3703
      goto while_break;
    }
    {
#line 3704
    tmp = strlen((char const   *)*new);
#line 3704
    old = enlist(old, *new, tmp);
#line 3703
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3705
  return (old);
}
}
#line 3710 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3713
  tmp = xzalloc(sizeof(*both));
#line 3713
  both = (char **)tmp;
#line 3715
  lnum = (size_t )0;
  }
  {
#line 3715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3715
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3715
      goto while_break;
    }
#line 3717
    rnum = (size_t )0;
    {
#line 3717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3717
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3717
        goto while_break___0;
      }
      {
#line 3719
      tmp___0 = comsubs(*(left + lnum), (char const   *)*(right + rnum));
#line 3719
      temp = tmp___0;
#line 3720
      both = addlists(both, temp);
#line 3721
      freelist(temp);
#line 3722
      free((void *)temp);
#line 3717
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3715
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3725
  return (both);
}
}
#line 3741 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static must *allocmust(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3744
  tmp = xmalloc(sizeof(*new_mp));
#line 3744
  new_mp = (must *)tmp;
#line 3745
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3745
  new_mp->in = (char **)tmp___0;
#line 3746
  tmp___1 = xzalloc(size);
#line 3746
  new_mp->left = (char *)tmp___1;
#line 3747
  tmp___2 = xzalloc(size);
#line 3747
  new_mp->right = (char *)tmp___2;
#line 3748
  tmp___3 = xzalloc(size);
#line 3748
  new_mp->is = (char *)tmp___3;
#line 3749
  new_mp->begline = (_Bool)0;
#line 3750
  new_mp->endline = (_Bool)0;
#line 3751
  new_mp->prev = mp;
  }
#line 3752
  return (new_mp);
}
}
#line 3755 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3758
  freelist(mp->in);
#line 3759
  *(mp->in + 0) = (char *)((void *)0);
#line 3760
  tmp___0 = (char )'\000';
#line 3760
  *(mp->is + 0) = tmp___0;
#line 3760
  tmp = tmp___0;
#line 3760
  *(mp->right + 0) = tmp;
#line 3760
  *(mp->left + 0) = tmp;
#line 3761
  mp->begline = (_Bool)0;
#line 3762
  mp->endline = (_Bool)0;
  }
#line 3763
  return;
}
}
#line 3765 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void freemust(must *mp ) 
{ 


  {
  {
#line 3768
  freelist(mp->in);
#line 3769
  free((void *)mp->in);
#line 3770
  free((void *)mp->left);
#line 3771
  free((void *)mp->right);
#line 3772
  free((void *)mp->is);
#line 3773
  free((void *)mp);
  }
#line 3774
  return;
}
}
#line 3776 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct dfamust *dfamust(struct dfa  const  *d ) 
{ 
  must *mp ;
  char const   *result ;
  _Bool exact ;
  _Bool begline ;
  _Bool endline ;
  _Bool need_begline ;
  _Bool need_endline ;
  _Bool case_fold_unibyte ;
  size_t tmp ;
  int tmp___0 ;
  size_t ri ;
  token t ;
  char **new ;
  must *rmp ;
  must *lmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  _Bool tmp___1 ;
  size_t i ;
  size_t i___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  must *rmp___0 ;
  must *lmp___0 ;
  size_t lrlen ;
  size_t tmp___6 ;
  size_t rllen ;
  size_t tmp___7 ;
  char *tp ;
  void *tmp___8 ;
  charclass *ccl ;
  int j___0 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t rj ;
  char tmp___13 ;
  char tmp___14 ;
  int tmp___15 ;
  size_t i___1 ;
  char tmp___16 ;
  char tmp___17 ;
  int tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  struct dfamust *dm ;
  void *tmp___21 ;
  must *prev ;

  {
#line 3779
  mp = (must *)((void *)0);
#line 3780
  result = "";
#line 3781
  exact = (_Bool)0;
#line 3782
  begline = (_Bool)0;
#line 3783
  endline = (_Bool)0;
#line 3784
  need_begline = (_Bool)0;
#line 3785
  need_endline = (_Bool)0;
#line 3786
  if (d->syntax.case_fold) {
    {
#line 3786
    tmp = __ctype_get_mb_cur_max();
    }
#line 3786
    if (tmp == 1UL) {
#line 3786
      tmp___0 = 1;
    } else {
#line 3786
      tmp___0 = 0;
    }
  } else {
#line 3786
    tmp___0 = 0;
  }
#line 3786
  case_fold_unibyte = (_Bool )tmp___0;
#line 3788
  ri = (size_t )0;
  {
#line 3788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3788
    if (! (ri < (size_t )d->tindex)) {
#line 3788
      goto while_break;
    }
#line 3790
    t = *(d->tokens + ri);
    {
#line 3793
    if (t == 258L) {
#line 3793
      goto case_258;
    }
#line 3798
    if (t == 259L) {
#line 3798
      goto case_259;
    }
#line 3804
    if (t == 271L) {
#line 3804
      goto case_271;
    }
#line 3804
    if (t == 270L) {
#line 3804
      goto case_271;
    }
#line 3814
    if (t == 273L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 272L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 257L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 263L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 262L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 261L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 260L) {
#line 3814
      goto case_273;
    }
#line 3814
    if (t == 256L) {
#line 3814
      goto case_273;
    }
#line 3819
    if (t == 264L) {
#line 3819
      goto case_264;
    }
#line 3819
    if (t == 265L) {
#line 3819
      goto case_264;
    }
#line 3823
    if (t == 269L) {
#line 3823
      goto case_269;
    }
#line 3867
    if (t == 266L) {
#line 3867
      goto case_266;
    }
#line 3871
    if (t == -1L) {
#line 3871
      goto case_neg_1;
    }
#line 3886
    if (t == 268L) {
#line 3886
      goto case_268;
    }
#line 3929
    if (t == 0L) {
#line 3929
      goto case_0;
    }
#line 3933
    goto switch_default;
    case_258: /* CIL Label */ 
    {
#line 3794
    mp = allocmust(mp, (size_t )2);
#line 3795
    mp->begline = (_Bool)1;
#line 3796
    need_begline = (_Bool)1;
    }
#line 3797
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 3799
    mp = allocmust(mp, (size_t )2);
#line 3800
    mp->endline = (_Bool)1;
#line 3801
    need_endline = (_Bool)1;
    }
#line 3802
    goto switch_break;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 3805
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c",
                  3805U, "dfamust");
    }
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3815
    mp = allocmust(mp, (size_t )2);
    }
#line 3816
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 3820
    resetmust(mp);
    }
#line 3821
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 3826
    rmp = mp;
#line 3827
    mp = mp->prev;
#line 3827
    lmp = mp;
#line 3831
    tmp___1 = streq((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3831
    if (tmp___1) {
#line 3833
      lmp->begline = (_Bool )((int )lmp->begline & (int )rmp->begline);
#line 3834
      lmp->endline = (_Bool )((int )lmp->endline & (int )rmp->endline);
    } else {
#line 3838
      *(lmp->is + 0) = (char )'\000';
#line 3839
      lmp->begline = (_Bool)0;
#line 3840
      lmp->endline = (_Bool)0;
    }
#line 3843
    i = (size_t )0;
    {
#line 3844
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3844
      if ((int )*(lmp->left + i) != 0) {
#line 3844
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3844
          goto while_break___0;
        }
      } else {
#line 3844
        goto while_break___0;
      }
#line 3845
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3846
    *(lmp->left + i) = (char )'\000';
#line 3848
    ln = strlen((char const   *)lmp->right);
#line 3849
    rn = strlen((char const   *)rmp->right);
#line 3850
    n = ln;
    }
#line 3851
    if (n > rn) {
#line 3852
      n = rn;
    }
#line 3853
    i = (size_t )0;
    {
#line 3853
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3853
      if (! (i < n)) {
#line 3853
        goto while_break___1;
      }
#line 3854
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3855
        goto while_break___1;
      }
#line 3853
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3856
    j = (size_t )0;
    {
#line 3856
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3856
      if (! (j < i)) {
#line 3856
        goto while_break___2;
      }
#line 3857
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3856
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3858
    *(lmp->right + j) = (char )'\000';
#line 3859
    new = inboth(lmp->in, rmp->in);
#line 3860
    freelist(lmp->in);
#line 3861
    free((void *)lmp->in);
#line 3862
    lmp->in = new;
#line 3863
    freemust(rmp);
    }
#line 3865
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3868
    *(mp->is + 0) = (char )'\000';
#line 3869
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3872
    if (! (! mp->prev)) {
      {
#line 3872
      __assert_fail("!mp->prev", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c",
                    3872U, "dfamust");
      }
    }
#line 3873
    i___0 = (size_t )0;
    {
#line 3873
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3873
      if (! ((unsigned long )*(mp->in + i___0) != (unsigned long )((void *)0))) {
#line 3873
        goto while_break___3;
      }
      {
#line 3874
      tmp___3 = strlen((char const   *)*(mp->in + i___0));
#line 3874
      tmp___4 = strlen(result);
      }
#line 3874
      if (tmp___3 > tmp___4) {
#line 3875
        result = (char const   *)*(mp->in + i___0);
      }
#line 3873
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3876
    tmp___5 = streq(result, (char const   *)mp->is);
    }
#line 3876
    if (tmp___5) {
#line 3878
      if (! need_begline) {
#line 3878
        goto _L;
      } else
#line 3878
      if (mp->begline) {
        _L: /* CIL Label */ 
#line 3878
        if (! need_endline) {
#line 3880
          exact = (_Bool)1;
        } else
#line 3878
        if (mp->endline) {
#line 3880
          exact = (_Bool)1;
        }
      }
#line 3881
      begline = mp->begline;
#line 3882
      endline = mp->endline;
    }
#line 3884
    goto done;
    case_268: /* CIL Label */ 
    {
#line 3888
    rmp___0 = mp;
#line 3889
    mp = mp->prev;
#line 3889
    lmp___0 = mp;
#line 3894
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 3895
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3895
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 3897
        tmp___6 = strlen((char const   *)lmp___0->right);
#line 3897
        lrlen = tmp___6;
#line 3898
        tmp___7 = strlen((char const   *)rmp___0->left);
#line 3898
        rllen = tmp___7;
#line 3899
        tmp___8 = xmalloc(lrlen + rllen);
#line 3899
        tp = (char *)tmp___8;
#line 3900
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)lmp___0->right,
               lrlen);
#line 3901
        memcpy((void */* __restrict  */)(tp + lrlen), (void const   */* __restrict  */)rmp___0->left,
               rllen);
#line 3902
        lmp___0->in = enlist(lmp___0->in, tp, lrlen + rllen);
#line 3903
        free((void *)tp);
        }
      }
    }
#line 3906
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 3907
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
    }
#line 3909
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3910
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 3911
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 3913
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3913
      goto _L___0;
    } else
#line 3913
    if (lmp___0->begline) {
      _L___0: /* CIL Label */ 
#line 3913
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 3916
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3917
        lmp___0->endline = rmp___0->endline;
        }
      } else
#line 3913
      if (rmp___0->endline) {
        {
#line 3916
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3917
        lmp___0->endline = rmp___0->endline;
        }
      } else {
#line 3921
        *(lmp___0->is + 0) = (char )'\000';
#line 3922
        lmp___0->begline = (_Bool)0;
#line 3923
        lmp___0->endline = (_Bool)0;
      }
    } else {
#line 3921
      *(lmp___0->is + 0) = (char )'\000';
#line 3922
      lmp___0->begline = (_Bool)0;
#line 3923
      lmp___0->endline = (_Bool)0;
    }
    {
#line 3925
    freemust(rmp___0);
    }
#line 3927
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3931
    goto done;
    switch_default: /* CIL Label */ 
#line 3934
    if (275L <= t) {
#line 3940
      ccl = d->charclasses + (t - 275L);
#line 3942
      j___0 = 0;
      {
#line 3942
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3942
        if (! (j___0 < 256)) {
#line 3942
          goto while_break___4;
        }
        {
#line 3943
        tmp___9 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3943
        if (tmp___9) {
#line 3944
          goto while_break___4;
        }
#line 3942
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3945
      if (! (j___0 < 256)) {
        {
#line 3947
        mp = allocmust(mp, (size_t )2);
        }
#line 3948
        goto switch_break;
      }
#line 3950
      t = (token )j___0;
      {
#line 3951
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3951
        j___0 ++;
#line 3951
        if (! (j___0 < 256)) {
#line 3951
          goto while_break___5;
        }
        {
#line 3952
        tmp___10 = tstbit((unsigned int )j___0, (charclass const   *)ccl);
        }
#line 3952
        if (tmp___10) {
#line 3952
          if (case_fold_unibyte) {
            {
#line 3952
            tmp___11 = toupper(j___0);
#line 3952
            tmp___12 = toupper((int )t);
            }
#line 3952
            if (! (tmp___11 == tmp___12)) {
#line 3955
              goto while_break___5;
            }
          } else {
#line 3955
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3956
      if (j___0 < 256) {
        {
#line 3958
        mp = allocmust(mp, (size_t )2);
        }
#line 3959
        goto switch_break;
      }
    }
#line 3963
    rj = ri + 2UL;
#line 3964
    if (*(d->tokens + (ri + 1UL)) == 268L) {
      {
#line 3966
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3966
        if (! (rj < (size_t )(d->tindex - 1UL))) {
#line 3966
          goto while_break___6;
        }
#line 3968
        if (rj != ri) {
#line 3968
          if (*(d->tokens + rj) <= 0L) {
#line 3971
            goto while_break___6;
          } else
#line 3968
          if (256L <= *(d->tokens + rj)) {
#line 3971
            goto while_break___6;
          } else {
#line 3968
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3968
        if (*(d->tokens + (rj + 1UL)) != 268L) {
#line 3971
          goto while_break___6;
        }
#line 3966
        rj += 2UL;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 3974
    mp = allocmust(mp, ((rj - ri) >> 1) + 1UL);
    }
#line 3975
    if (case_fold_unibyte) {
      {
#line 3975
      tmp___15 = toupper((int )t);
#line 3975
      tmp___14 = (char )tmp___15;
      }
    } else {
#line 3975
      tmp___14 = (char )t;
    }
#line 3975
    *(mp->right + 0) = tmp___14;
#line 3975
    tmp___13 = tmp___14;
#line 3975
    *(mp->left + 0) = tmp___13;
#line 3975
    *(mp->is + 0) = tmp___13;
#line 3979
    i___1 = (size_t )1;
    {
#line 3979
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3979
      if (! (ri + 2UL < rj)) {
#line 3979
        goto while_break___7;
      }
#line 3981
      ri += 2UL;
#line 3982
      t = *(d->tokens + ri);
#line 3983
      if (case_fold_unibyte) {
        {
#line 3983
        tmp___18 = toupper((int )t);
#line 3983
        tmp___17 = (char )tmp___18;
        }
      } else {
#line 3983
        tmp___17 = (char )t;
      }
#line 3983
      *(mp->right + i___1) = tmp___17;
#line 3983
      tmp___16 = tmp___17;
#line 3983
      *(mp->left + i___1) = tmp___16;
#line 3983
      *(mp->is + i___1) = tmp___16;
#line 3979
      i___1 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 3986
    tmp___20 = (char )'\000';
#line 3986
    *(mp->right + i___1) = tmp___20;
#line 3986
    tmp___19 = tmp___20;
#line 3986
    *(mp->left + i___1) = tmp___19;
#line 3986
    *(mp->is + i___1) = tmp___19;
#line 3987
    mp->in = enlist(mp->in, mp->is, i___1);
    }
#line 3988
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3788
    ri ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 3993
  dm = (struct dfamust *)((void *)0);
#line 3994
  if (*result) {
    {
#line 3996
    tmp___21 = xmalloc(sizeof(*dm));
#line 3996
    dm = (struct dfamust *)tmp___21;
#line 3997
    dm->exact = exact;
#line 3998
    dm->begline = begline;
#line 3999
    dm->endline = endline;
#line 4000
    dm->must = xstrdup(result);
    }
  }
  {
#line 4003
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 4003
    if (! mp) {
#line 4003
      goto while_break___8;
    }
    {
#line 4005
    prev = mp->prev;
#line 4006
    freemust(mp);
#line 4007
    mp = prev;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 4010
  return (dm);
}
}
#line 4013 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
void dfamustfree(struct dfamust *dm ) 
{ 


  {
  {
#line 4016
  free((void *)dm->must);
#line 4017
  free((void *)dm);
  }
#line 4018
  return;
}
}
#line 4020
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 4020 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp ;

  {
  {
#line 4023
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4023
  return ((struct dfa *)tmp);
}
}
#line 4027 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) 
{ 
  int i ;
  unsigned char uc ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 4031
  memset((void *)dfa, 0, (unsigned long )(& ((struct dfa *)0)->dfaexec));
  }
#line 4032
  if (linfo->multibyte) {
#line 4032
    dfa->dfaexec = & dfaexec_mb;
  } else {
#line 4032
    dfa->dfaexec = & dfaexec_sb;
  }
  {
#line 4033
  dfa->simple_locale = using_simple_locale((_Bool )linfo->multibyte);
#line 4034
  dfa->localeinfo = (struct localeinfo )*linfo;
#line 4036
  dfa->fast = (_Bool )(! dfa->localeinfo.multibyte);
#line 4038
  dfa->canychar = (size_t )-1;
#line 4039
  dfa->lex.cur_mb_len = 1;
#line 4040
  dfa->syntax.syntax_bits_set = (_Bool)1;
#line 4041
  dfa->syntax.case_fold = (_Bool )((bits & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL);
#line 4042
  dfa->syntax.anchor = (_Bool )((dfaopts & 1) != 0);
  }
#line 4043
  if (dfaopts & 2) {
#line 4043
    dfa->syntax.eolbyte = (unsigned char )'\000';
  } else {
#line 4043
    dfa->syntax.eolbyte = (unsigned char )'\n';
  }
#line 4044
  dfa->syntax.syntax_bits = bits;
#line 4046
  i = -128;
  {
#line 4046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4046
    if (! (i <= 127)) {
#line 4046
      goto while_break;
    }
    {
#line 4048
    uc = (unsigned char )i;
#line 4050
    tmp = char_context((struct dfa  const  *)dfa, uc);
#line 4050
    dfa->syntax.sbit[uc] = (char )tmp;
    }
    {
#line 4053
    if ((int )dfa->syntax.sbit[uc] == 2) {
#line 4053
      goto case_2;
    }
#line 4056
    if ((int )dfa->syntax.sbit[uc] == 4) {
#line 4056
      goto case_4;
    }
#line 4051
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4054
    setbit((unsigned int )uc, & dfa->syntax.letters);
    }
#line 4055
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 4057
    setbit((unsigned int )uc, & dfa->syntax.newline);
    }
#line 4058
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4063
    if (dfa->localeinfo.using_utf8) {
#line 4063
      dfa->syntax.never_trail[uc] = (_Bool )(((int )uc & 192) != 128);
    } else {
      {
#line 4063
      tmp___0 = strchr("\n\r./", (int )uc);
#line 4063
      dfa->syntax.never_trail[uc] = (_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0));
      }
    }
#line 4046
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4067
  return;
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 


  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ 
  _Bool tmp___0 ;

  {
#line 60
  if (! (state->magic == 9827862)) {
    {
#line 60
    __assert_fail("state->magic == 9827862", "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.c",
                  60U, "cycle_check");
    }
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
  {
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp___0 = is_zero_or_power_of_two(state->chdir_counter);
  }
#line 70
  if (tmp___0) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 23 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 27 "/home/khheo/project/benchmark/grep-3.0/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = creat(file, mode);
#line 30
  tmp___0 = fd_safer(tmp);
  }
#line 30
  return (tmp___0);
}
}
#line 22 "./colorize-posix.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 19 "./colorize.h"
int should_colorize(void) ;
#line 20
void init_colorize(void) ;
#line 21
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) ;
#line 22
void print_end_colorize(char const   *sgr_end___0 ) ;
#line 626 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 36 "./colorize-posix.c"
int should_colorize(void) 
{ 
  char const   *t ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = getenv("TERM");
#line 39
  t = (char const   *)tmp;
  }
#line 40
  if (t) {
    {
#line 40
    tmp___0 = strcmp(t, "dumb");
    }
#line 40
    if (tmp___0 != 0) {
#line 40
      tmp___1 = 1;
    } else {
#line 40
      tmp___1 = 0;
    }
  } else {
#line 40
    tmp___1 = 0;
  }
#line 40
  return (tmp___1);
}
}
#line 43 "./colorize-posix.c"
void init_colorize(void) 
{ 


  {
#line 43
  return;
}
}
#line 47 "./colorize-posix.c"
void print_start_colorize(char const   *sgr_start___0 , char const   *sgr_seq ) 
{ 


  {
  {
#line 50
  printf((char const   */* __restrict  */)sgr_start___0, sgr_seq);
  }
#line 51
  return;
}
}
#line 54 "./colorize-posix.c"
void print_end_colorize(char const   *sgr_end___0 ) 
{ 


  {
  {
#line 57
  fputs((char const   */* __restrict  */)sgr_end___0, (FILE */* __restrict  */)stdout);
  }
#line 58
  return;
}
}
#line 28 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/grep-3.0/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/grep-3.0/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/grep-3.0/lib/cloexec.h"
int dup_cloexec(int fd ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/grep-3.0/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/khheo/project/benchmark/grep-3.0/lib/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 114 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 49
  cdb->fd = -100;
#line 50
  return;
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = fchdir((int )cdb->fd);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 61
  if (0 <= (int )cdb->fd) {
    {
#line 63
    tmp = close((int )cdb->fd);
#line 63
    close_fail = (_Bool )tmp;
    }
#line 64
    if (! (! close_fail)) {
      {
#line 64
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                    64U, "cdb_free");
      }
    }
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 75
  tmp = openat(cdb->fd, dir, 67840);
#line 75
  new_fd = tmp;
  }
#line 77
  if (new_fd < 0) {
#line 78
    return (-1);
  }
  {
#line 80
  cdb_free((struct cd_buf  const  *)cdb);
#line 81
  cdb->fd = new_fd;
  }
#line 83
  return (0);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 90
  tmp = strspn(s, "/");
#line 90
  n_slash = tmp;
  }
#line 91
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 109 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  char * __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char * __attribute__((__pure__)) tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int saved_errno ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 112
  tmp = chdir((char const   *)dir);
#line 112
  e = tmp;
  }
#line 113
  if (e == 0) {
#line 114
    return (e);
  } else {
    {
#line 113
    tmp___0 = __errno_location();
    }
#line 113
    if (*tmp___0 != 36) {
#line 114
      return (e);
    }
  }
  {
#line 117
  tmp___1 = strlen((char const   *)dir);
#line 117
  len = tmp___1;
#line 118
  dir_end = dir + len;
#line 122
  cdb_init(& cdb);
  }
#line 126
  if (! (0UL < len)) {
    {
#line 126
    __assert_fail("0 < len", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                  126U, "chdir_long");
    }
  }
#line 127
  if (! (4096UL <= len)) {
    {
#line 127
    __assert_fail("4096 <= len", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                  127U, "chdir_long");
    }
  }
  {
#line 130
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 137
  if (n_leading_slash == 2UL) {
    {
#line 142
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 142
    slash = (char *)tmp___4;
    }
#line 143
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___5 = __errno_location();
#line 145
      *tmp___5 = 36;
      }
#line 146
      return (-1);
    }
    {
#line 148
    *slash = (char )'\000';
#line 149
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 150
    *slash = (char )'/';
    }
#line 151
    if (err != 0) {
#line 152
      goto Fail;
    }
    {
#line 153
    tmp___6 = find_non_slash((char const   *)(slash + 1));
#line 153
    dir = (char *)tmp___6;
    }
  } else
#line 155
  if (n_leading_slash) {
    {
#line 157
    tmp___7 = cdb_advance_fd(& cdb, "/");
    }
#line 157
    if (tmp___7 != 0) {
#line 158
      goto Fail;
    }
#line 159
    dir += n_leading_slash;
  }
#line 162
  if (! ((int )*dir != 47)) {
    {
#line 162
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                  162U, "chdir_long");
    }
  }
#line 163
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 163
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                  163U, "chdir_long");
    }
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (4096L <= dir_end - dir)) {
#line 165
      goto while_break;
    }
    {
#line 171
    tmp___10 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 171
    slash___0 = (char *)tmp___10;
    }
#line 172
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 174
      tmp___11 = __errno_location();
#line 174
      *tmp___11 = 36;
      }
#line 175
      return (-1);
    }
#line 178
    *slash___0 = (char )'\000';
#line 179
    if (! (slash___0 - dir < 4096L)) {
      {
#line 179
      __assert_fail("slash - dir < 4096", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                    179U, "chdir_long");
      }
    }
    {
#line 180
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 181
    *slash___0 = (char )'/';
    }
#line 182
    if (err___0 != 0) {
#line 183
      goto Fail;
    }
    {
#line 185
    tmp___13 = find_non_slash((char const   *)(slash___0 + 1));
#line 185
    dir = (char *)tmp___13;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 190
    tmp___14 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 190
    if (tmp___14 != 0) {
#line 191
      goto Fail;
    }
  }
  {
#line 194
  tmp___15 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 194
  if (tmp___15 != 0) {
#line 195
    goto Fail;
  }
  {
#line 197
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 198
  return (0);
  Fail: 
  {
#line 202
  tmp___16 = __errno_location();
#line 202
  saved_errno = *tmp___16;
#line 203
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 204
  tmp___17 = __errno_location();
#line 204
  *tmp___17 = saved_errno;
  }
#line 205
  return (-1);
}
}
#line 47 "/home/khheo/project/benchmark/grep-3.0/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/grep-3.0/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/binary-io.h"
__inline int set_binary_mode(int fd , int mode ) 
{ 


  {
#line 57
  return (0);
}
}
#line 73
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/grep-3.0/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 56
void (*argmatch_die)(void) ;
#line 60
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 72
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 83
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 98
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 545 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 58 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
void usage(int status ) ;
#line 61 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 64
  usage(1);
  }
#line 65
  return;
}
}
#line 69 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 83
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 83 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  matchind = (ptrdiff_t )-1;
#line 90
  ambiguous = (_Bool)0;
#line 92
  arglen = strlen(arg);
#line 95
  i = (size_t )0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! *(arglist + i)) {
#line 95
      goto while_break;
    }
    {
#line 97
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 97
    if (! tmp___1) {
      {
#line 99
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 99
      if (tmp___0 == arglen) {
#line 101
        return ((ptrdiff_t )i);
      } else
#line 102
      if (matchind == -1L) {
#line 104
        matchind = (ptrdiff_t )i;
      } else
#line 108
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 114
        ambiguous = (_Bool)1;
      } else {
        {
#line 108
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 108
        if (tmp) {
#line 114
          ambiguous = (_Bool)1;
        }
      }
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (ambiguous) {
#line 120
    return ((ptrdiff_t )-2);
  } else {
#line 122
    return (matchind);
  }
}
}
#line 130 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 133
  if (problem == -1L) {
    {
#line 133
    tmp = gettext("invalid argument %s for %s");
#line 133
    tmp___1 = tmp;
    }
  } else {
    {
#line 133
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 133
    tmp___1 = tmp___0;
    }
  }
  {
#line 133
  format = (char const   *)tmp___1;
#line 137
  tmp___2 = quote_n(1, context);
#line 137
  tmp___3 = quotearg_n_style(0, (enum quoting_style )8, value);
#line 137
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 139
  return;
}
}
#line 145 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 150
  last_val = (char const   *)((void *)0);
#line 154
  tmp = gettext("Valid arguments are:");
#line 154
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 155
  i = (size_t )0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! *(arglist + i)) {
#line 155
      goto while_break;
    }
#line 156
    if (i == 0UL) {
      {
#line 159
      tmp___0 = quote((char const   *)*(arglist + i));
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp___0);
#line 160
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 156
      tmp___2 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 156
      if (tmp___2) {
        {
#line 159
        tmp___0 = quote((char const   *)*(arglist + i));
#line 159
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp___0);
#line 160
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 164
        tmp___1 = quote((char const   *)*(arglist + i));
#line 164
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___1);
        }
      }
    }
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  putc_unlocked('\n', stderr);
  }
#line 167
  return;
}
}
#line 175 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 181
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 181
  res = tmp;
  }
#line 182
  if (res >= 0L) {
#line 184
    return (res);
  }
  {
#line 187
  argmatch_invalid(context, arg, res);
#line 188
  argmatch_valid(arglist, vallist, valsize);
#line 189
  (*exit_fn)();
  }
#line 191
  return ((ptrdiff_t )-1);
}
}
#line 196
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 196 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 203
  i = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! *(arglist + i)) {
#line 203
      goto while_break;
    }
    {
#line 204
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 204
    if (! tmp) {
#line 205
      return ((char const   *)*(arglist + i));
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale___2(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___2(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale___3(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___3(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___3(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol-error.c"
static void xstrtol_error___0(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                              char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale___4(intmax_t *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (intmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/grep-3.0/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___4(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___4(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 29
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 29
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/cjk.h"
static int is_cjk_encoding___0(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data___0[2304]  = 
#line 35 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )16,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )223,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )247,      (unsigned char const   )63, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )239,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )211,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )248,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )133, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )176, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )167, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )40,      (unsigned char const   )191,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )188,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )96, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )127,      (unsigned char const   )248, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 361 "/home/khheo/project/benchmark/grep-3.0/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind___0[248]  = 
#line 361
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )29,      (signed char const   )-1,      (signed char const   )30, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )31,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )32,      (signed char const   )33,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )34,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 141 "/home/khheo/project/benchmark/grep-3.0/lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 108 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct quoting_options default_quoting_options___0  ;
#line 184 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct quoting_options quoting_options_from_style___0(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 187
  o.style = (enum quoting_style )0;
#line 187
  o.flags = 0;
#line 187
  o.quote_these_too[0] = 0U;
#line 187
  tmp = 1U;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (tmp >= 8U) {
#line 187
      goto while_break;
    }
#line 187
    o.quote_these_too[tmp] = 0U;
#line 187
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  o.left_quote = (char const   *)((void *)0);
#line 187
  o.right_quote = (char const   *)((void *)0);
#line 188
  if ((unsigned int )style == 10U) {
    {
#line 189
    abort();
    }
  }
#line 190
  o.style = style;
#line 191
  return (o);
}
}
#line 198 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char const   *gettext_quote___0(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 201
  tmp = gettext(msgid);
#line 201
  translation = (char const   *)tmp;
  }
#line 204
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 205
    return (translation);
  }
  {
#line 225
  locale_code = locale_charset();
#line 226
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 226
  if (tmp___1 == 0) {
#line 227
    if ((int const   )*(msgid + 0) == 96) {
#line 227
      tmp___0 = "\342\200\230";
    } else {
#line 227
      tmp___0 = "\342\200\231";
    }
#line 227
    return (tmp___0);
  }
  {
#line 228
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 228
  if (tmp___3 == 0) {
#line 229
    if ((int const   )*(msgid + 0) == 96) {
#line 229
      tmp___2 = "\241\ae";
    } else {
#line 229
      tmp___2 = "\241\257";
    }
#line 229
    return (tmp___2);
  }
#line 231
  if ((unsigned int )s == 9U) {
#line 231
    tmp___4 = "\"";
  } else {
#line 231
    tmp___4 = "\'";
  }
#line 231
  return (tmp___4);
}
}
#line 247 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static size_t quotearg_buffer_restyled___0(char *buffer___0 , size_t buffersize ,
                                           char const   *arg , size_t argsize , enum quoting_style quoting_style ,
                                           int flags , unsigned int const   *quote_these_too ,
                                           char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 256
  len = (size_t )0;
#line 257
  orig_buffersize = (size_t )0;
#line 258
  quote_string = (char const   *)0;
#line 259
  quote_string_len = (size_t )0;
#line 260
  backslash_escapes = (_Bool)0;
#line 261
  tmp = __ctype_get_mb_cur_max();
#line 261
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 262
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 263
  pending_shell_escape_end = (_Bool)0;
#line 264
  encountered_single_quote = (_Bool)0;
#line 265
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 310
  if ((unsigned int )quoting_style == 6U) {
#line 310
    goto case_6;
  }
#line 314
  if ((unsigned int )quoting_style == 5U) {
#line 314
    goto case_5;
  }
#line 322
  if ((unsigned int )quoting_style == 7U) {
#line 322
    goto case_7;
  }
#line 329
  if ((unsigned int )quoting_style == 10U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 9U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 8U) {
#line 329
    goto case_10;
  }
#line 366
  if ((unsigned int )quoting_style == 3U) {
#line 366
    goto case_3;
  }
#line 369
  if ((unsigned int )quoting_style == 1U) {
#line 369
    goto case_1;
  }
#line 372
  if ((unsigned int )quoting_style == 4U) {
#line 372
    goto case_4;
  }
#line 376
  if ((unsigned int )quoting_style == 2U) {
#line 376
    goto case_2;
  }
#line 384
  if ((unsigned int )quoting_style == 0U) {
#line 384
    goto case_0;
  }
#line 388
  goto switch_default;
  case_6: /* CIL Label */ 
#line 311
  quoting_style = (enum quoting_style )5;
#line 312
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 315
  if (! elide_outer_quotes) {
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 316
      if (len < buffersize) {
#line 316
        *(buffer___0 + len) = (char )'\"';
      }
#line 316
      len ++;
#line 316
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 317
  backslash_escapes = (_Bool)1;
#line 318
  quote_string = "\"";
#line 319
  quote_string_len = (size_t )1;
#line 320
  goto switch_break;
  case_7: /* CIL Label */ 
#line 323
  backslash_escapes = (_Bool)1;
#line 324
  elide_outer_quotes = (_Bool)0;
#line 325
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 331
  if ((unsigned int )quoting_style != 10U) {
    {
#line 354
    left_quote = gettext_quote___0("`", quoting_style);
#line 355
    right_quote = gettext_quote___0("\'", quoting_style);
    }
  }
#line 357
  if (! elide_outer_quotes) {
#line 358
    quote_string = left_quote;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! *quote_string) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 359
        if (len < buffersize) {
#line 359
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 359
        len ++;
#line 359
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 358
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 360
  backslash_escapes = (_Bool)1;
#line 361
  quote_string = right_quote;
#line 362
  quote_string_len = strlen(quote_string);
  }
#line 364
  goto switch_break;
  case_3: /* CIL Label */ 
#line 367
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 370
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 373
  if (! elide_outer_quotes) {
#line 374
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 377
  quoting_style = (enum quoting_style )2;
#line 378
  if (! elide_outer_quotes) {
    {
#line 379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 379
      if (len < buffersize) {
#line 379
        *(buffer___0 + len) = (char )'\'';
      }
#line 379
      len ++;
#line 379
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 380
  quote_string = "\'";
#line 381
  quote_string_len = (size_t )1;
#line 382
  goto switch_break;
  case_0: /* CIL Label */ 
#line 385
  elide_outer_quotes = (_Bool)0;
#line 386
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 389
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 392
  i = (size_t )0;
  {
#line 392
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 392
    if (argsize == 0xffffffffffffffffUL) {
#line 392
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 392
      tmp___7 = i == argsize;
    }
#line 392
    if (tmp___7) {
#line 392
      goto while_break___3;
    }
#line 396
    is_right_quote = (_Bool)0;
#line 397
    escaping = (_Bool)0;
#line 398
    c_and_shell_quote_compat = (_Bool)0;
#line 400
    if (backslash_escapes) {
#line 400
      if ((unsigned int )quoting_style != 2U) {
#line 400
        if (quote_string_len) {
#line 400
          if (argsize == 0xffffffffffffffffUL) {
#line 400
            if (1UL < quote_string_len) {
              {
#line 400
              argsize = strlen(arg);
#line 400
              tmp___0 = argsize;
              }
            } else {
#line 400
              tmp___0 = argsize;
            }
          } else {
#line 400
            tmp___0 = argsize;
          }
#line 400
          if (i + quote_string_len <= tmp___0) {
            {
#line 400
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 400
            if (tmp___1 == 0) {
#line 411
              if (elide_outer_quotes) {
#line 412
                goto force_outer_quoting_style;
              }
#line 413
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 416
    c = (unsigned char )*(arg + i);
    {
#line 419
    if ((int )c == 0) {
#line 419
      goto case_0___0;
    }
#line 445
    if ((int )c == 63) {
#line 445
      goto case_63;
    }
#line 483
    if ((int )c == 7) {
#line 483
      goto case_7___0;
    }
#line 484
    if ((int )c == 8) {
#line 484
      goto case_8___0;
    }
#line 485
    if ((int )c == 12) {
#line 485
      goto case_12;
    }
#line 486
    if ((int )c == 10) {
#line 486
      goto case_10___0;
    }
#line 487
    if ((int )c == 13) {
#line 487
      goto case_13;
    }
#line 488
    if ((int )c == 9) {
#line 488
      goto case_9___0;
    }
#line 489
    if ((int )c == 11) {
#line 489
      goto case_11;
    }
#line 490
    if ((int )c == 92) {
#line 490
      goto case_92;
    }
#line 517
    if ((int )c == 125) {
#line 517
      goto case_125;
    }
#line 517
    if ((int )c == 123) {
#line 517
      goto case_125;
    }
#line 521
    if ((int )c == 126) {
#line 521
      goto case_126;
    }
#line 521
    if ((int )c == 35) {
#line 521
      goto case_126;
    }
#line 525
    if ((int )c == 32) {
#line 525
      goto case_32;
    }
#line 535
    if ((int )c == 124) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 96) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 94) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 91) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 62) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 61) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 60) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 59) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 42) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 41) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 40) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 38) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 36) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 34) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 33) {
#line 535
      goto case_124;
    }
#line 545
    if ((int )c == 39) {
#line 545
      goto case_39___0;
    }
#line 580
    if ((int )c == 122) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 121) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 120) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 119) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 118) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 117) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 116) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 115) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 114) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 113) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 112) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 111) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 110) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 109) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 108) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 107) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 106) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 105) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 104) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 103) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 102) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 101) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 100) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 99) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 98) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 97) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 95) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 93) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 90) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 89) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 88) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 87) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 86) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 85) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 84) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 83) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 82) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 81) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 80) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 79) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 78) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 77) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 76) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 75) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 74) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 73) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 72) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 71) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 70) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 69) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 68) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 67) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 66) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 65) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 58) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 57) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 56) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 55) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 54) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 53) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 52) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 51) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 50) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 49) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 48) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 47) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 46) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 45) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 44) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 43) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 37) {
#line 580
      goto case_122;
    }
#line 594
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 420
    if (backslash_escapes) {
      {
#line 422
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 422
        if (elide_outer_quotes) {
#line 422
          goto force_outer_quoting_style;
        }
#line 422
        escaping = (_Bool)1;
#line 422
        if ((unsigned int )quoting_style == 2U) {
#line 422
          if (! pending_shell_escape_end) {
            {
#line 422
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'$';
              }
#line 422
              len ++;
#line 422
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 422
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 422
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 422
          if (len < buffersize) {
#line 422
            *(buffer___0 + len) = (char )'\\';
          }
#line 422
          len ++;
#line 422
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 422
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 429
      if ((unsigned int )quoting_style != 2U) {
#line 429
        if (i + 1UL < argsize) {
#line 429
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 429
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 432
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 432
                if (len < buffersize) {
#line 432
                  *(buffer___0 + len) = (char )'0';
                }
#line 432
                len ++;
#line 432
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 433
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 433
                if (len < buffersize) {
#line 433
                  *(buffer___0 + len) = (char )'0';
                }
#line 433
                len ++;
#line 433
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 435
      c = (unsigned char )'0';
    } else
#line 441
    if (flags & 1) {
#line 442
      goto __Cont;
    }
#line 443
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 448
    if ((unsigned int )quoting_style == 2U) {
#line 448
      goto case_2___0;
    }
#line 453
    if ((unsigned int )quoting_style == 5U) {
#line 453
      goto case_5___0;
    }
#line 478
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 449
    if (elide_outer_quotes) {
#line 450
      goto force_outer_quoting_style;
    }
#line 451
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 454
    if (flags & 4) {
#line 454
      if (i + 2UL < argsize) {
#line 454
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 460
            goto case_62;
          }
#line 473
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 463
          if (elide_outer_quotes) {
#line 464
            goto force_outer_quoting_style;
          }
#line 465
          c = (unsigned char )*(arg + (i + 2UL));
#line 466
          i += 2UL;
          {
#line 467
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 467
            if (len < buffersize) {
#line 467
              *(buffer___0 + len) = (char )'?';
            }
#line 467
            len ++;
#line 467
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 468
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 468
            if (len < buffersize) {
#line 468
              *(buffer___0 + len) = (char )'\"';
            }
#line 468
            len ++;
#line 468
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 469
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 469
            if (len < buffersize) {
#line 469
              *(buffer___0 + len) = (char )'\"';
            }
#line 469
            len ++;
#line 469
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 470
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 470
            if (len < buffersize) {
#line 470
              *(buffer___0 + len) = (char )'?';
            }
#line 470
            len ++;
#line 470
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 471
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 474
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 476
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 479
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 481
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 483
    esc = (unsigned char )'a';
#line 483
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 484
    esc = (unsigned char )'b';
#line 484
    goto c_escape;
    case_12: /* CIL Label */ 
#line 485
    esc = (unsigned char )'f';
#line 485
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 486
    esc = (unsigned char )'n';
#line 486
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 487
    esc = (unsigned char )'r';
#line 487
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 488
    esc = (unsigned char )'t';
#line 488
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 489
    esc = (unsigned char )'v';
#line 489
    goto c_escape;
    case_92: /* CIL Label */ 
#line 490
    esc = c;
#line 492
    if ((unsigned int )quoting_style == 2U) {
#line 494
      if (elide_outer_quotes) {
#line 495
        goto force_outer_quoting_style;
      }
#line 496
      goto store_c;
    }
#line 501
    if (backslash_escapes) {
#line 501
      if (elide_outer_quotes) {
#line 501
        if (quote_string_len) {
#line 502
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 505
    if ((unsigned int )quoting_style == 2U) {
#line 505
      if (elide_outer_quotes) {
#line 507
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 510
    if (backslash_escapes) {
#line 512
      c = esc;
#line 513
      goto store_escape;
    }
#line 515
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 518
    if (argsize == 0xffffffffffffffffUL) {
#line 518
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 518
      tmp___2 = argsize == 1UL;
    }
#line 518
    if (! tmp___2) {
#line 519
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 522
    if (i != 0UL) {
#line 523
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 526
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 540
    if ((unsigned int )quoting_style == 2U) {
#line 540
      if (elide_outer_quotes) {
#line 542
        goto force_outer_quoting_style;
      }
    }
#line 543
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 546
    encountered_single_quote = (_Bool)1;
#line 547
    c_and_shell_quote_compat = (_Bool)1;
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 550
      if (elide_outer_quotes) {
#line 551
        goto force_outer_quoting_style;
      }
#line 553
      if (buffersize) {
#line 553
        if (! orig_buffersize) {
#line 558
          orig_buffersize = buffersize;
#line 559
          buffersize = (size_t )0;
        }
      }
      {
#line 562
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 562
        if (len < buffersize) {
#line 562
          *(buffer___0 + len) = (char )'\'';
        }
#line 562
        len ++;
#line 562
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 563
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 563
        if (len < buffersize) {
#line 563
          *(buffer___0 + len) = (char )'\\';
        }
#line 563
        len ++;
#line 563
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 564
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 564
        if (len < buffersize) {
#line 564
          *(buffer___0 + len) = (char )'\'';
        }
#line 564
        len ++;
#line 564
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 565
      pending_shell_escape_end = (_Bool)0;
    }
#line 567
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 591
    c_and_shell_quote_compat = (_Bool)1;
#line 592
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 606
    if (unibyte_locale) {
      {
#line 608
      m = (size_t )1;
#line 609
      tmp___3 = __ctype_b_loc();
#line 609
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 614
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 616
      m = (size_t )0;
#line 617
      printable = (_Bool)1;
      }
#line 618
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 619
        argsize = strlen(arg);
        }
      }
      {
#line 621
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 624
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 624
        bytes = tmp___4;
        }
#line 626
        if (bytes == 0UL) {
#line 627
          goto while_break___18;
        } else
#line 628
        if (bytes == 0xffffffffffffffffUL) {
#line 630
          printable = (_Bool)0;
#line 631
          goto while_break___18;
        } else
#line 633
        if (bytes == 0xfffffffffffffffeUL) {
#line 635
          printable = (_Bool)0;
          {
#line 636
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 636
            if (i + m < argsize) {
#line 636
              if (! *(arg + (i + m))) {
#line 636
                goto while_break___19;
              }
            } else {
#line 636
              goto while_break___19;
            }
#line 637
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 638
          goto while_break___18;
        } else {
#line 646
          if (elide_outer_quotes) {
#line 646
            if ((unsigned int )quoting_style == 2U) {
#line 650
              j = (size_t )1;
              {
#line 650
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 650
                if (! (j < bytes)) {
#line 650
                  goto while_break___20;
                }
                {
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 654
                  goto case_124___0;
                }
#line 657
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 655
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 658
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 650
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 662
          tmp___5 = iswprint((wint_t )w);
          }
#line 662
          if (! tmp___5) {
#line 663
            printable = (_Bool)0;
          }
#line 664
          m += bytes;
        }
        {
#line 621
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 621
        if (tmp___6) {
#line 621
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 670
    c_and_shell_quote_compat = printable;
#line 672
    if (1UL < m) {
#line 672
      goto _L___0;
    } else
#line 672
    if (backslash_escapes) {
#line 672
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 676
        ilim = i + m;
        {
#line 678
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 680
          if (backslash_escapes) {
#line 680
            if (! printable) {
              {
#line 682
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 682
                if (elide_outer_quotes) {
#line 682
                  goto force_outer_quoting_style;
                }
#line 682
                escaping = (_Bool)1;
#line 682
                if ((unsigned int )quoting_style == 2U) {
#line 682
                  if (! pending_shell_escape_end) {
                    {
#line 682
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'$';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 682
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 682
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 682
                  if (len < buffersize) {
#line 682
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 682
                  len ++;
#line 682
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 682
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 683
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 683
                if (len < buffersize) {
#line 683
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 683
                len ++;
#line 683
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 684
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 684
                if (len < buffersize) {
#line 684
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 684
                len ++;
#line 684
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 685
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 680
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 687
          if (is_right_quote) {
            {
#line 689
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 689
              if (len < buffersize) {
#line 689
                *(buffer___0 + len) = (char )'\\';
              }
#line 689
              len ++;
#line 689
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 690
            is_right_quote = (_Bool)0;
          }
#line 692
          if (ilim <= i + 1UL) {
#line 693
            goto while_break___21;
          }
          {
#line 694
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 694
            if (pending_shell_escape_end) {
#line 694
              if (! escaping) {
                {
#line 694
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 694
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 694
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 694
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 695
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 695
            if (len < buffersize) {
#line 695
              *(buffer___0 + len) = (char )c;
            }
#line 695
            len ++;
#line 695
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 696
          i ++;
#line 696
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 699
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 704
    if (backslash_escapes) {
#line 704
      if ((unsigned int )quoting_style != 2U) {
#line 704
        goto _L___3;
      } else {
#line 704
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 704
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 704
      if (quote_these_too) {
#line 704
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 704
          goto _L___2;
        }
      } else {
#line 704
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 704
    if (! is_right_quote) {
#line 709
      goto store_c;
    }
    store_escape: 
    {
#line 712
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 712
      if (elide_outer_quotes) {
#line 712
        goto force_outer_quoting_style;
      }
#line 712
      escaping = (_Bool)1;
#line 712
      if ((unsigned int )quoting_style == 2U) {
#line 712
        if (! pending_shell_escape_end) {
          {
#line 712
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'$';
            }
#line 712
            len ++;
#line 712
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 712
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 712
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 712
        if (len < buffersize) {
#line 712
          *(buffer___0 + len) = (char )'\\';
        }
#line 712
        len ++;
#line 712
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 712
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 715
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 715
      if (pending_shell_escape_end) {
#line 715
        if (! escaping) {
          {
#line 715
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 715
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 715
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 715
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 716
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 716
      if (len < buffersize) {
#line 716
        *(buffer___0 + len) = (char )c;
      }
#line 716
      len ++;
#line 716
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 718
    if (! c_and_shell_quote_compat) {
#line 719
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 392
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 722
  if (len == 0UL) {
#line 722
    if ((unsigned int )quoting_style == 2U) {
#line 722
      if (elide_outer_quotes) {
#line 724
        goto force_outer_quoting_style;
      }
    }
  }
#line 730
  if ((unsigned int )quoting_style == 2U) {
#line 730
    if (! elide_outer_quotes) {
#line 730
      if (encountered_single_quote) {
#line 733
        if (all_c_and_shell_quote_compat) {
          {
#line 734
          tmp___8 = quotearg_buffer_restyled___0(buffer___0, orig_buffersize, arg,
                                                 argsize, (enum quoting_style )5,
                                                 flags, quote_these_too, left_quote,
                                                 right_quote);
          }
#line 734
          return (tmp___8);
        } else
#line 738
        if (! buffersize) {
#line 738
          if (orig_buffersize) {
#line 741
            buffersize = orig_buffersize;
#line 742
            len = (size_t )0;
#line 743
            goto process_input;
          }
        }
      }
    }
  }
#line 747
  if (quote_string) {
#line 747
    if (! elide_outer_quotes) {
      {
#line 748
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 748
        if (! *quote_string) {
#line 748
          goto while_break___43;
        }
        {
#line 749
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 749
          if (len < buffersize) {
#line 749
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 749
          len ++;
#line 749
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 748
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 751
  if (len < buffersize) {
#line 752
    *(buffer___0 + len) = (char )'\000';
  }
#line 753
  return (len);
  force_outer_quoting_style: 
#line 758
  if ((unsigned int )quoting_style == 2U) {
#line 758
    if (backslash_escapes) {
#line 759
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 760
  tmp___9 = quotearg_buffer_restyled___0(buffer___0, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0),
                                         left_quote, right_quote);
  }
#line 760
  return (tmp___9);
}
}
#line 834 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char slot0___0[256]  ;
#line 835 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static int nslots___0  =    1;
#line 836 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct slotvec slotvec0___0  =    {sizeof(slot0___0), slot0___0};
#line 837 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static struct slotvec *slotvec___0  =    & slotvec0___0;
#line 868 "/home/khheo/project/benchmark/grep-3.0/lib/quotearg.c"
static char *quotearg_n_options___0(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 872
  tmp = __errno_location();
#line 872
  e = *tmp;
#line 874
  sv = slotvec___0;
  }
#line 876
  if (n < 0) {
    {
#line 877
    abort();
    }
  }
#line 879
  if (nslots___0 <= n) {
#line 881
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0___0));
#line 883
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 883
      tmp___0 = 2147483647UL;
    } else {
#line 883
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 883
    if (tmp___0 <= (unsigned long )n) {
      {
#line 884
      xalloc_die();
      }
    }
#line 886
    if (preallocated) {
#line 886
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 886
      tmp___1 = sv;
    }
    {
#line 886
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 886
    sv = (struct slotvec *)tmp___2;
#line 886
    slotvec___0 = sv;
    }
#line 887
    if (preallocated) {
#line 888
      *sv = slotvec0___0;
    }
    {
#line 889
    memset((void *)(sv + nslots___0), 0, (unsigned long )((n + 1) - nslots___0) * sizeof(*sv));
#line 890
    nslots___0 = n + 1;
    }
  }
  {
#line 894
  size = (sv + n)->size;
#line 895
  val = (sv + n)->val;
#line 897
  flags = (int )(options->flags | 1);
#line 898
  tmp___3 = quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                         flags, (unsigned int const   *)(options->quote_these_too),
                                         (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 898
  qsize = tmp___3;
  }
#line 904
  if (size <= qsize) {
#line 906
    size = qsize + 1UL;
#line 906
    (sv + n)->size = size;
#line 907
    if ((unsigned long )val != (unsigned long )(slot0___0)) {
      {
#line 908
      free((void *)val);
      }
    }
    {
#line 909
    val = xcharalloc(size);
#line 909
    (sv + n)->val = val;
#line 910
    quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                 flags, (unsigned int const   *)(options->quote_these_too),
                                 (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 916
  tmp___4 = __errno_location();
#line 916
  *tmp___4 = e;
  }
#line 917
  return (val);
}
}
#line 21 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded___0(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 57
  tmp = trim2(sub, 2);
#line 57
  tsub = tmp;
#line 58
  found = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*string != 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 62
    tsub_in_string = (char const   *)tmp___0;
    }
#line 63
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 64
      goto while_break;
    } else {
      {
#line 67
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 67
      if (tmp___11 > 1UL) {
        {
#line 73
        string_iter.cur.ptr = string;
#line 73
        string_iter.in_shift = (_Bool)0;
#line 73
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 73
        string_iter.next_done = (_Bool)0;
#line 74
        word_boundary_before = (_Bool)1;
        }
#line 75
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 78
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 80
            mbuiter_multi_next(& string_iter);
            }
#line 80
            if (string_iter.cur.wc_valid) {
#line 80
              if (string_iter.cur.wc == 0) {
#line 80
                tmp___1 = 0;
              } else {
#line 80
                tmp___1 = 1;
              }
            } else {
#line 80
              tmp___1 = 1;
            }
#line 80
            if (! tmp___1) {
              {
#line 81
              abort();
              }
            }
#line 82
            last_char_before_tsub = string_iter.cur;
#line 83
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 83
            string_iter.next_done = (_Bool)0;
#line 78
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 78
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 86
          if (last_char_before_tsub.wc_valid) {
            {
#line 86
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 86
            if (tmp___2) {
#line 87
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 90
        string_iter.cur.ptr = tsub_in_string;
#line 90
        string_iter.in_shift = (_Bool)0;
#line 90
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 90
        string_iter.next_done = (_Bool)0;
#line 94
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 94
        tsub_iter.in_shift = (_Bool)0;
#line 94
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 94
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 94
          mbuiter_multi_next(& tsub_iter);
          }
#line 94
          if (tsub_iter.cur.wc_valid) {
#line 94
            if (tsub_iter.cur.wc == 0) {
#line 94
              tmp___4 = 0;
            } else {
#line 94
              tmp___4 = 1;
            }
          } else {
#line 94
            tmp___4 = 1;
          }
#line 94
          if (! tmp___4) {
#line 94
            goto while_break___1;
          }
          {
#line 98
          mbuiter_multi_next(& string_iter);
          }
#line 98
          if (string_iter.cur.wc_valid) {
#line 98
            if (string_iter.cur.wc == 0) {
#line 98
              tmp___3 = 0;
            } else {
#line 98
              tmp___3 = 1;
            }
          } else {
#line 98
            tmp___3 = 1;
          }
#line 98
          if (! tmp___3) {
            {
#line 99
            abort();
            }
          }
#line 100
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 100
          string_iter.next_done = (_Bool)0;
#line 94
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 94
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 103
        word_boundary_after = (_Bool)1;
#line 104
        mbuiter_multi_next(& string_iter);
        }
#line 104
        if (string_iter.cur.wc_valid) {
#line 104
          if (string_iter.cur.wc == 0) {
#line 104
            tmp___6 = 0;
          } else {
#line 104
            tmp___6 = 1;
          }
        } else {
#line 104
          tmp___6 = 1;
        }
#line 104
        if (tmp___6) {
#line 106
          first_char_after_tsub = string_iter.cur;
#line 107
          if (first_char_after_tsub.wc_valid) {
            {
#line 107
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 107
            if (tmp___5) {
#line 108
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 111
        if (word_boundary_before) {
#line 111
          if (word_boundary_after) {
#line 113
            found = (_Bool)1;
#line 114
            goto while_break;
          }
        }
        {
#line 117
        string_iter.cur.ptr = tsub_in_string;
#line 117
        string_iter.in_shift = (_Bool)0;
#line 117
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 117
        string_iter.next_done = (_Bool)0;
#line 118
        mbuiter_multi_next(& string_iter);
        }
#line 118
        if (string_iter.cur.wc_valid) {
#line 118
          if (string_iter.cur.wc == 0) {
#line 118
            tmp___7 = 0;
          } else {
#line 118
            tmp___7 = 1;
          }
        } else {
#line 118
          tmp___7 = 1;
        }
#line 118
        if (! tmp___7) {
#line 119
          goto while_break;
        }
#line 120
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 128
        word_boundary_before___0 = (_Bool)1;
#line 129
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 130
          tmp___8 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 131
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 133
        tmp___9 = strlen((char const   *)tsub);
#line 133
        p = tsub_in_string + tmp___9;
#line 134
        word_boundary_after___0 = (_Bool)1;
        }
#line 135
        if ((int const   )*p != 0) {
          {
#line 136
          tmp___10 = __ctype_b_loc();
          }
#line 136
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 137
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 139
        if (word_boundary_before___0) {
#line 139
          if (word_boundary_after___0) {
#line 141
            found = (_Bool)1;
#line 142
            goto while_break;
          }
        }
#line 145
        if ((int const   )*tsub_in_string == 0) {
#line 146
          goto while_break;
        }
#line 147
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)tsub);
  }
#line 152
  return (found);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 65 "/home/khheo/project/benchmark/grep-3.0/lib/openat-proc.c"
static int proc_status___0  =    0;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 83 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void *call_chunkfun___0(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void call_freefun___0(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static int _obstack_begin_worker___0(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun___0(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 329 "/home/khheo/project/benchmark/grep-3.0/lib/obstack.c"
static void print_and_abort___0(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/grep-3.0/lib/str-kmp.h"
static _Bool knuth_morris_pratt___0(unsigned char const   *haystack , unsigned char const   *needle ,
                                    size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 39
  m = needle_len;
#line 42
  if (9223372036854775807UL / sizeof(size_t ) < m) {
#line 42
    tmp___2 = (void *)0;
  } else {
#line 42
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 42
      tmp = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 42
      tmp___1 = (void *)((char *)tmp + 16);
      }
    } else {
      {
#line 42
      tmp___0 = mmalloca(m * sizeof(size_t ));
#line 42
      tmp___1 = tmp___0;
      }
    }
#line 42
    tmp___2 = tmp___1;
  }
#line 42
  table = (size_t *)tmp___2;
#line 43
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 44
    return ((_Bool)0);
  }
#line 64
  *(table + 1) = (size_t )1;
#line 65
  j = (size_t )0;
#line 67
  i = (size_t )2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < m)) {
#line 67
      goto while_break;
    }
#line 73
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if ((int )b == (int )*(needle + j)) {
#line 83
        j ++;
#line 83
        *(table + i) = i - j;
#line 84
        goto while_break___0;
      }
#line 89
      if (j == 0UL) {
#line 92
        *(table + i) = i;
#line 93
        goto while_break___0;
      }
#line 106
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *resultp = (unsigned char const   *)((void *)0);
#line 119
  j___0 = (size_t )0;
#line 120
  rhaystack = haystack;
#line 121
  phaystack = haystack;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! ((int const   )*phaystack != 0)) {
#line 123
      goto while_break___1;
    }
#line 124
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 126
      j___0 ++;
#line 127
      phaystack ++;
#line 128
      if (j___0 == m) {
#line 131
        *resultp = rhaystack;
#line 132
        goto while_break___1;
      }
    } else
#line 135
    if (j___0 > 0UL) {
#line 138
      rhaystack += *(table + j___0);
#line 139
      j___0 -= *(table + j___0);
    } else {
#line 144
      rhaystack ++;
#line 145
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 149
  freea((void *)table);
  }
#line 150
  return ((_Bool)1);
}
}
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte___0(char const   *haystack , char const   *needle ,
                                              char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  void *memory ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *table_memory ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___4 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (9223372036854775807UL / (sizeof(mbchar_t ) + sizeof(size_t )) < m) {
#line 48
    tmp___3 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___0 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 48
      tmp___1 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___2 = tmp___1;
      }
    }
#line 48
    tmp___3 = tmp___2;
  }
#line 48
  memory = tmp___3;
#line 50
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 51
    return ((_Bool)0);
  }
  {
#line 52
  needle_mbchars = (mbchar_t *)memory;
#line 53
  table_memory = (void *)(needle_mbchars + m);
#line 54
  table = (size_t *)table_memory;
#line 61
  j = (size_t )0;
#line 62
  iter.cur.ptr = needle;
#line 62
  iter.in_shift = (_Bool)0;
#line 62
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 62
  iter.next_done = (_Bool)0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    mbuiter_multi_next(& iter);
    }
#line 62
    if (iter.cur.wc_valid) {
#line 62
      if (iter.cur.wc == 0) {
#line 62
        tmp___4 = 0;
      } else {
#line 62
        tmp___4 = 1;
      }
    } else {
#line 62
      tmp___4 = 1;
    }
#line 62
    if (! tmp___4) {
#line 62
      goto while_break;
    }
    {
#line 63
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 62
    iter.cur.ptr += iter.cur.bytes;
#line 62
    iter.next_done = (_Bool)0;
#line 62
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *(table + 1) = (size_t )1;
#line 86
  j___0 = (size_t )0;
#line 88
  i = (size_t )2;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < m)) {
#line 88
      goto while_break___0;
    }
#line 94
    b = needle_mbchars + (i - 1UL);
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (b->wc_valid) {
#line 101
        if ((needle_mbchars + j___0)->wc_valid) {
#line 101
          tmp___7 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 101
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 101
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 101
          tmp___5 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 101
          if (tmp___5 == 0) {
#line 101
            tmp___6 = 1;
          } else {
#line 101
            tmp___6 = 0;
          }
        } else {
#line 101
          tmp___6 = 0;
        }
#line 101
        tmp___7 = tmp___6;
      }
#line 101
      if (tmp___7) {
#line 104
        j___0 ++;
#line 104
        *(table + i) = i - j___0;
#line 105
        goto while_break___1;
      }
#line 110
      if (j___0 == 0UL) {
#line 113
        *(table + i) = i;
#line 114
        goto while_break___1;
      }
#line 127
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 88
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  *resultp = (char const   *)((void *)0);
#line 140
  j___1 = (size_t )0;
#line 141
  rhaystack.cur.ptr = haystack;
#line 141
  rhaystack.in_shift = (_Bool)0;
#line 141
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 141
  rhaystack.next_done = (_Bool)0;
#line 142
  phaystack.cur.ptr = haystack;
#line 142
  phaystack.in_shift = (_Bool)0;
#line 142
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 142
  phaystack.next_done = (_Bool)0;
  }
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 144
    mbuiter_multi_next(& phaystack);
    }
#line 144
    if (phaystack.cur.wc_valid) {
#line 144
      if (phaystack.cur.wc == 0) {
#line 144
        tmp___13 = 0;
      } else {
#line 144
        tmp___13 = 1;
      }
    } else {
#line 144
      tmp___13 = 1;
    }
#line 144
    if (! tmp___13) {
#line 144
      goto while_break___2;
    }
#line 145
    if ((needle_mbchars + j___1)->wc_valid) {
#line 145
      if (phaystack.cur.wc_valid) {
#line 145
        tmp___12 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 145
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 145
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 145
        tmp___10 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 145
        if (tmp___10 == 0) {
#line 145
          tmp___11 = 1;
        } else {
#line 145
          tmp___11 = 0;
        }
      } else {
#line 145
        tmp___11 = 0;
      }
#line 145
      tmp___12 = tmp___11;
    }
#line 145
    if (tmp___12) {
#line 147
      j___1 ++;
#line 148
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 148
      phaystack.next_done = (_Bool)0;
#line 149
      if (j___1 == m) {
#line 152
        *resultp = rhaystack.cur.ptr;
#line 153
        goto while_break___2;
      }
    } else
#line 156
    if (j___1 > 0UL) {
#line 159
      count = *(table + j___1);
#line 160
      j___1 -= count;
      {
#line 161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 161
        if (! (count > 0UL)) {
#line 161
          goto while_break___3;
        }
        {
#line 163
        mbuiter_multi_next(& rhaystack);
        }
#line 163
        if (rhaystack.cur.wc_valid) {
#line 163
          if (rhaystack.cur.wc == 0) {
#line 163
            tmp___8 = 0;
          } else {
#line 163
            tmp___8 = 1;
          }
        } else {
#line 163
          tmp___8 = 1;
        }
#line 163
        if (! tmp___8) {
          {
#line 164
          abort();
          }
        }
#line 165
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 165
        rhaystack.next_done = (_Bool)0;
#line 161
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 171
      mbuiter_multi_next(& rhaystack);
      }
#line 171
      if (rhaystack.cur.wc_valid) {
#line 171
        if (rhaystack.cur.wc == 0) {
#line 171
          tmp___9 = 0;
        } else {
#line 171
          tmp___9 = 1;
        }
      } else {
#line 171
        tmp___9 = 1;
      }
#line 171
      if (! tmp___9) {
        {
#line 172
        abort();
        }
      }
#line 173
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 173
      rhaystack.next_done = (_Bool)0;
#line 174
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 174
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 178
  freea(memory);
  }
#line 179
  return ((_Bool)1);
}
}
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/grep-3.0/lib/mbrlen.c"
static mbstate_t internal_state___0  ;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 103 "/home/khheo/project/benchmark/grep-3.0/lib/mbiter.h"
#pragma GCC diagnostic push
#line 103
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 103
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 223
#pragma GCC diagnostic pop
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 69 "/home/khheo/project/benchmark/grep-3.0/lib/malloca.c"
static void *mmalloca_results___0[257]  ;
#line 124 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 125
#pragma weak pthread_mutex_lock
#line 126
#pragma weak pthread_mutex_unlock
#line 127
#pragma weak pthread_mutex_destroy
#line 128
#pragma weak pthread_rwlock_init
#line 129
#pragma weak pthread_rwlock_rdlock
#line 130
#pragma weak pthread_rwlock_wrlock
#line 131
#pragma weak pthread_rwlock_unlock
#line 132
#pragma weak pthread_rwlock_destroy
#line 133
#pragma weak pthread_once
#line 134
#pragma weak pthread_cond_init
#line 135
#pragma weak pthread_cond_wait
#line 136
#pragma weak pthread_cond_signal
#line 137
#pragma weak pthread_cond_broadcast
#line 138
#pragma weak pthread_cond_destroy
#line 139
#pragma weak pthread_mutexattr_init
#line 140
#pragma weak pthread_mutexattr_settype
#line 141
#pragma weak pthread_mutexattr_destroy
#line 142
#pragma weak pthread_rwlockattr_init
#line 143
#pragma weak pthread_rwlockattr_setkind_np
#line 144
#pragma weak pthread_rwlockattr_destroy
#line 146
#pragma weak pthread_self
#line 150
#pragma weak pthread_cancel
#line 481 "/home/khheo/project/benchmark/grep-3.0/lib/glthread/lock.c"
static int const   fresh_once___0  =    (pthread_once_t const   )0;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
static _Bool is_using_utf8___0(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 74 "/home/khheo/project/benchmark/grep-3.0/lib/localeinfo.c"
static short const   lonesome_lower___0[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 120 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.c"
static char const   * volatile  charset_aliases___0  ;
#line 123 "/home/khheo/project/benchmark/grep-3.0/lib/localcharset.c"
static char const   *get_charset_aliases___0(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 128
  cp = (char const   *)charset_aliases___0;
#line 129
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    base = "charset.alias";
#line 138
    tmp = getenv("CHARSETALIASDIR");
#line 138
    dir = (char const   *)tmp;
    }
#line 139
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 140
      dir = "/usr/local/lib";
    } else
#line 139
    if ((int const   )*(dir + 0) == 0) {
#line 140
      dir = "/usr/local/lib";
    }
    {
#line 144
    tmp___0 = strlen(dir);
#line 144
    dir_len___0 = tmp___0;
#line 145
    tmp___1 = strlen(base);
#line 145
    base_len___0 = tmp___1;
    }
#line 146
    if (dir_len___0 > 0UL) {
#line 146
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 146
        tmp___2 = 1;
      } else {
#line 146
        tmp___2 = 0;
      }
    } else {
#line 146
      tmp___2 = 0;
    }
    {
#line 146
    add_slash = tmp___2;
#line 147
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 147
    file_name___1 = (char *)tmp___3;
    }
#line 148
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      {
#line 150
      memcpy((void */* __restrict  */)file_name___1, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 151
      if (add_slash) {
#line 152
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      {
#line 153
      memcpy((void */* __restrict  */)((file_name___1 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 157
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 159
      cp = "";
    } else {
      {
#line 171
      fd = open((char const   *)file_name___1, 131072);
      }
#line 173
      if (fd < 0) {
#line 175
        cp = "";
      } else {
        {
#line 180
        fp = fdopen(fd, "r");
        }
#line 181
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 184
          close(fd);
#line 185
          cp = "";
          }
        } else {
#line 190
          res_ptr = (char *)((void *)0);
#line 191
          res_size = (size_t )0;
          {
#line 193
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 201
            c = getc_unlocked(fp);
            }
#line 202
            if (c == -1) {
#line 203
              goto while_break;
            }
#line 204
            if (c == 10) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 32) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 9) {
#line 205
              goto __Cont;
            }
#line 206
            if (c == 35) {
              {
#line 209
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 210
                c = getc_unlocked(fp);
                }
#line 209
                if (c == -1) {
#line 209
                  goto while_break___0;
                } else
#line 209
                if (c == 10) {
#line 209
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 212
              if (c == -1) {
#line 213
                goto while_break;
              }
#line 214
              goto __Cont;
            }
            {
#line 216
            ungetc(c, fp);
#line 217
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 217
            if (tmp___4 < 2) {
#line 218
              goto while_break;
            }
            {
#line 219
            l1 = strlen((char const   *)(buf1));
#line 220
            l2 = strlen((char const   *)(buf2));
#line 221
            old_res_ptr = res_ptr;
            }
#line 222
            if (res_size == 0UL) {
              {
#line 224
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 225
              tmp___5 = malloc(res_size + 1UL);
#line 225
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 229
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 230
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 230
              res_ptr = (char *)tmp___6;
              }
            }
#line 232
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 235
              res_size = (size_t )0;
#line 236
              free((void *)old_res_ptr);
              }
#line 237
              goto while_break;
            }
            {
#line 239
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 240
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 242
          fclose(fp);
          }
#line 243
          if (res_size == 0UL) {
#line 244
            cp = "";
          } else {
#line 247
            *(res_ptr + res_size) = (char )'\000';
#line 248
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 253
      free((void *)file_name___1);
      }
    }
#line 377
    charset_aliases___0 = (char const   */* volatile  */)cp;
  }
#line 380
  return (cp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_tuning  const  default_tuning___0  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 248 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_entry *safe_hasher___0(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 443
static _Bool is_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool is_prime___0(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime___0(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t next_prime___0(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime___0(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 485 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t raw_hasher___0(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool raw_comparator___0(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool check_tuning___0(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning___0)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning___0;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size___0(size_t candidate ,
                                                                 Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime___0(candidate);
  }
#line 554
  if (9223372036854775807UL / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 750 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static struct hash_entry *allocate_entry___0(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static void free_entry___0(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static void *hash_find_entry___0(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                                 _Bool delete___1 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher___0((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete___1) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry___0(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete___1) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry___0(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/grep-3.0/lib/hash.c"
static _Bool transfer_entries___0(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry___0(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher___0((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry___0(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/grep-3.0/lib/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 206 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) ;
#line 207
static FTSENT *fts_build___0(FTS *sp , int type ) ;
#line 208
static void fts_lfree___0(FTSENT *head ) ;
#line 209
static void fts_load___0(FTS *sp , FTSENT *p ) ;
#line 210
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) ;
#line 211
static void fts_padjust___0(FTS *sp , FTSENT *head ) ;
#line 212
static _Bool fts_palloc___0(FTS *sp , size_t more ) ;
#line 213
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 214
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 215
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool AD_compare___0(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static size_t AD_hash___0(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool setup_dir___0(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash___0, & AD_compare___0, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static _Bool enter_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static void leave_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/grep-3.0/lib/fts-cycle.c"
static void free_dir___0(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 271 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fd_ring_clear___0(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 274
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 274
    if (tmp___0) {
#line 274
      goto while_break;
    }
    {
#line 276
    tmp = i_ring_pop(fd_ring);
#line 276
    fd = tmp;
    }
#line 277
    if (0 <= fd) {
      {
#line 278
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 285 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_set_stat_required___0(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((int )p->fts_info == 11)) {
      {
#line 288
      abort();
      }
    }
#line 288
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (required) {
#line 289
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 289
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 292
  return;
}
}
#line 296 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static DIR *opendirat___0(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 300
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
#line 300
  new_fd = tmp;
  }
#line 305
  if (new_fd < 0) {
#line 306
    return ((DIR *)((void *)0));
  }
  {
#line 307
  set_cloexec_flag(new_fd, (_Bool)1);
#line 308
  dirp = fdopendir(new_fd);
  }
#line 309
  if (dirp) {
#line 310
    *pdir_fd = new_fd;
  } else {
    {
#line 313
    tmp___0 = __errno_location();
#line 313
    saved_errno = *tmp___0;
#line 314
    close(new_fd);
#line 315
    tmp___1 = __errno_location();
#line 315
    *tmp___1 = saved_errno;
    }
  }
#line 317
  return (dirp);
}
}
#line 325 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void cwd_advance_fd___0(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 329
  old = sp->fts_cwd_fd;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (old != fd)) {
#line 330
      if (! (old == -100)) {
        {
#line 330
        abort();
        }
      }
    }
#line 330
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  if (chdir_down_one) {
    {
#line 336
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 336
    prev_fd_in_slot = tmp;
    }
#line 338
    if (0 <= prev_fd_in_slot) {
      {
#line 339
      close(prev_fd_in_slot);
      }
    }
  } else
#line 341
  if (! (sp->fts_options & 4)) {
#line 343
    if (0 <= old) {
      {
#line 344
      close(old);
      }
    }
  }
#line 347
  sp->fts_cwd_fd = fd;
#line 348
  return;
}
}
#line 354 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int restore_initial_cwd___0(FTS *sp ) 
{ 
  int fail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 357
  if (! (sp->fts_options & 4)) {
#line 357
    if (sp->fts_options & 512) {
#line 357
      if (sp->fts_options & 512) {
#line 357
        tmp = -100;
      } else {
#line 357
        tmp = sp->fts_rfd;
      }
      {
#line 357
      cwd_advance_fd___0(sp, tmp, (_Bool)1);
#line 357
      tmp___2 = 0;
      }
    } else {
#line 357
      if (sp->fts_options & 512) {
#line 357
        tmp___0 = -100;
      } else {
#line 357
        tmp___0 = sp->fts_rfd;
      }
      {
#line 357
      tmp___1 = fchdir(tmp___0);
#line 357
      tmp___2 = tmp___1;
      }
    }
#line 357
    if (tmp___2) {
#line 357
      tmp___3 = 1;
    } else {
#line 357
      tmp___3 = 0;
    }
  } else {
#line 357
    tmp___3 = 0;
  }
  {
#line 357
  fail = tmp___3;
#line 358
  fd_ring_clear___0(& sp->fts_fd_ring);
  }
#line 359
  return (fail);
}
}
#line 366 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int diropen___0(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 370
  if (sp->fts_options & 16) {
#line 370
    tmp = 131072;
  } else {
#line 370
    tmp = 0;
  }
#line 370
  if (sp->fts_options & 2048) {
#line 370
    tmp___0 = 262144;
  } else {
#line 370
    tmp___0 = 0;
  }
#line 370
  open_flags = (67840 | tmp) | tmp___0;
#line 374
  if (sp->fts_options & 512) {
    {
#line 374
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 374
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 374
    tmp___2 = open_safer(dir, open_flags);
#line 374
    tmp___3 = tmp___2;
    }
  }
#line 374
  fd = tmp___3;
#line 377
  if (0 <= fd) {
    {
#line 378
    set_cloexec_flag(fd, (_Bool)1);
    }
  }
#line 379
  return (fd);
}
}
#line 572 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_load___0(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 586
  tmp = p->fts_namelen;
#line 586
  p->fts_pathlen = tmp;
#line 586
  len = tmp;
#line 587
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 588
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 588
  if (cp) {
#line 588
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 589
      cp ++;
#line 589
      len = strlen((char const   *)cp);
#line 590
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 591
      p->fts_namelen = len;
      }
    } else
#line 588
    if (*(cp + 1)) {
      {
#line 589
      cp ++;
#line 589
      len = strlen((char const   *)cp);
#line 590
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 591
      p->fts_namelen = len;
      }
    }
  }
#line 593
  tmp___0 = sp->fts_path;
#line 593
  p->fts_path = tmp___0;
#line 593
  p->fts_accpath = tmp___0;
#line 594
  return;
}
}
#line 676 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 687
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 687
  if (tmp != 0) {
#line 688
    return ((_Bool)1);
  }
  {
#line 695
  if (fs_buf.f_type == 26985L) {
#line 695
    goto case_26985;
  }
#line 695
  if (fs_buf.f_type == 16914836L) {
#line 695
    goto case_26985;
  }
#line 700
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 698
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 701
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 708 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool leaf_optimization_applies___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 714
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 714
  if (tmp != 0) {
#line 715
    return ((_Bool)0);
  }
  {
#line 725
  if (fs_buf.f_type == 1481003842L) {
#line 725
    goto case_1481003842;
  }
#line 725
  if (fs_buf.f_type == 1382369651L) {
#line 725
    goto case_1481003842;
  }
#line 740
  goto switch_default;
  case_1481003842: /* CIL Label */ 
  case_1382369651: /* CIL Label */ 
#line 726
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 741
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 765 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static size_t LCO_hash___0(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 768
  ax = (struct LCO_ent  const  *)x;
#line 769
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 772 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool LCO_compare___0(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 775
  ax = (struct LCO_ent  const  *)x;
#line 776
  ay = (struct LCO_ent  const  *)y;
#line 777
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 783 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool link_count_optimize_ok___0(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 786
  sp = (FTS *)p->fts_fts;
#line 787
  h = sp->fts_leaf_optimization_works_ht;
#line 795
  if (! (sp->fts_options & 512)) {
#line 796
    return ((_Bool)0);
  }
#line 799
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 801
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash___0,
                              & LCO_compare___0, (void (*)(void * ))(& free));
#line 801
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 801
    h = tmp___0;
    }
#line 804
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 805
      return ((_Bool)0);
    }
  }
  {
#line 807
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 808
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 808
  ent = (struct LCO_ent *)tmp___1;
  }
#line 809
  if (ent) {
#line 810
    return (ent->opt_ok);
  }
  {
#line 813
  tmp___2 = malloc(sizeof(*t2));
#line 813
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 814
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 815
    return ((_Bool)0);
  }
  {
#line 818
  opt_ok = leaf_optimization_applies___0(sp->fts_cwd_fd);
#line 819
  t2->opt_ok = opt_ok;
#line 820
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 822
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 822
  ent = (struct LCO_ent *)tmp___3;
  }
#line 823
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 826
    free((void *)t2);
    }
#line 827
    return ((_Bool)0);
  }
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 829
      abort();
      }
    }
#line 829
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  return (opt_ok);
}
}
#line 1216 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_compare_ino___0(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1219
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1219
    tmp___0 = -1;
  } else {
#line 1219
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1219
      tmp = 1;
    } else {
#line 1219
      tmp = 0;
    }
#line 1219
    tmp___0 = tmp;
  }
#line 1219
  return (tmp___0);
}
}
#line 1225 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void set_stat_type___0(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1231
  if (dtype == 6U) {
#line 1231
    goto case_6;
  }
#line 1234
  if (dtype == 2U) {
#line 1234
    goto case_2;
  }
#line 1237
  if (dtype == 4U) {
#line 1237
    goto case_4;
  }
#line 1240
  if (dtype == 1U) {
#line 1240
    goto case_1;
  }
#line 1243
  if (dtype == 10U) {
#line 1243
    goto case_10;
  }
#line 1246
  if (dtype == 8U) {
#line 1246
    goto case_8;
  }
#line 1249
  if (dtype == 12U) {
#line 1249
    goto case_12;
  }
#line 1252
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1232
  type = (mode_t )24576;
#line 1233
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1235
  type = (mode_t )8192;
#line 1236
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1238
  type = (mode_t )16384;
#line 1239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1241
  type = (mode_t )4096;
#line 1242
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1244
  type = (mode_t )40960;
#line 1245
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1247
  type = (mode_t )32768;
#line 1248
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1250
  type = (mode_t )49152;
#line 1251
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1253
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1255
  st->st_mode = type;
#line 1256
  return;
}
}
#line 1291 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_build___0(FTS *sp , int type ) 
{ 
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  size_t max_entries ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool is_dir ;
  size_t d_namelen ;
  int *tmp___11 ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  _Bool tmp___17 ;
  int *tmp___18 ;
  _Bool skip_stat ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1308
  cur = sp->fts_cur;
#line 1309
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
#line 1315
  if (continue_readdir) {
    {
#line 1317
    dp = cur->fts_dirp;
#line 1318
    dir_fd = dirfd(dp);
    }
#line 1319
    if (dir_fd < 0) {
      {
#line 1321
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1321
        closedir(cur->fts_dirp);
#line 1321
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1321
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1322
      if (type == 3) {
        {
#line 1324
        cur->fts_info = (unsigned short)4;
#line 1325
        tmp = __errno_location();
#line 1325
        cur->fts_errno = *tmp;
        }
      }
#line 1327
      return ((FTSENT *)((void *)0));
    }
  } else {
#line 1334
    if (sp->fts_options & 16) {
#line 1334
      if (sp->fts_options & 1) {
#line 1334
        if (cur->fts_level == 0L) {
#line 1334
          tmp___2 = 0;
        } else {
#line 1334
          tmp___2 = 131072;
        }
      } else {
#line 1334
        tmp___2 = 131072;
      }
    } else {
#line 1334
      tmp___2 = 0;
    }
#line 1334
    if (sp->fts_options & 2048) {
#line 1334
      tmp___3 = 262144;
    } else {
#line 1334
      tmp___3 = 0;
    }
#line 1334
    if (! (sp->fts_options & 4)) {
#line 1334
      if (sp->fts_options & 512) {
#line 1334
        tmp___4 = sp->fts_cwd_fd;
      } else {
#line 1334
        tmp___4 = -100;
      }
    } else {
#line 1334
      tmp___4 = -100;
    }
    {
#line 1334
    tmp___1 = opendirat___0(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                            & dir_fd);
#line 1334
    cur->fts_dirp = tmp___1;
    }
#line 1334
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1336
      if (type == 3) {
        {
#line 1338
        cur->fts_info = (unsigned short)4;
#line 1339
        tmp___0 = __errno_location();
#line 1339
        cur->fts_errno = *tmp___0;
        }
      }
#line 1341
      return ((FTSENT *)((void *)0));
    }
#line 1346
    if ((int )cur->fts_info == 11) {
      {
#line 1347
      cur->fts_info = fts_stat___0(sp, cur, (_Bool)0);
      }
    } else
#line 1348
    if (sp->fts_options & 256) {
      {
#line 1355
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1355
        leave_dir___0(sp, cur);
        }
#line 1355
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1356
      fts_stat___0(sp, cur, (_Bool)0);
#line 1357
      tmp___6 = enter_dir___0(sp, cur);
      }
#line 1357
      if (! tmp___6) {
        {
#line 1359
        tmp___5 = __errno_location();
#line 1359
        *tmp___5 = 12;
        }
#line 1360
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1372
  if (sp->fts_compar) {
#line 1372
    max_entries = 0xffffffffffffffffUL;
  } else {
#line 1372
    max_entries = (size_t )100000;
  }
#line 1379
  if (type == 2) {
#line 1380
    nlinks = (nlink_t )0;
#line 1382
    nostat = (_Bool)0;
  } else
#line 1383
  if (sp->fts_options & 8) {
#line 1383
    if (sp->fts_options & 16) {
#line 1384
      if (sp->fts_options & 32) {
#line 1384
        tmp___7 = 0;
      } else {
#line 1384
        tmp___7 = 2;
      }
#line 1384
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___7;
#line 1386
      nostat = (_Bool)1;
    } else {
#line 1388
      nlinks = (nlink_t )-1;
#line 1389
      nostat = (_Bool)0;
    }
  } else {
#line 1388
    nlinks = (nlink_t )-1;
#line 1389
    nostat = (_Bool)0;
  }
#line 1407
  if (continue_readdir) {
#line 1411
    descend = (_Bool)1;
  } else
#line 1413
  if (nlinks) {
#line 1413
    goto _L___0;
  } else
#line 1413
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1414
    if (sp->fts_options & 512) {
      {
#line 1416
      dir_fd = dup_safer(dir_fd);
      }
#line 1417
      if (0 <= dir_fd) {
        {
#line 1418
        set_cloexec_flag(dir_fd, (_Bool)1);
        }
      }
    }
#line 1420
    if (dir_fd < 0) {
#line 1420
      goto _L;
    } else {
      {
#line 1420
      tmp___9 = fts_safe_changedir___0(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1420
      if (tmp___9) {
        _L: /* CIL Label */ 
#line 1421
        if (nlinks) {
#line 1421
          if (type == 3) {
            {
#line 1422
            tmp___8 = __errno_location();
#line 1422
            cur->fts_errno = *tmp___8;
            }
          }
        }
#line 1423
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1424
        descend = (_Bool)0;
        {
#line 1425
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1425
          closedir(cur->fts_dirp);
#line 1425
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1425
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1426
        if (sp->fts_options & 512) {
#line 1426
          if (0 <= dir_fd) {
            {
#line 1427
            close(dir_fd);
            }
          }
        }
#line 1428
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
#line 1430
        descend = (_Bool)1;
      }
    }
  } else {
#line 1432
    descend = (_Bool)0;
  }
#line 1444
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1444
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1444
    len = cur->fts_pathlen;
  }
#line 1445
  if (sp->fts_options & 4) {
#line 1446
    cp = sp->fts_path + len;
#line 1447
    tmp___10 = cp;
#line 1447
    cp ++;
#line 1447
    *tmp___10 = (char )'/';
  } else {
#line 1450
    cp = (char *)((void *)0);
  }
#line 1452
  len ++;
#line 1453
  maxlen = sp->fts_pathlen - len;
#line 1455
  level = cur->fts_level + 1L;
#line 1458
  doadjust = (_Bool)0;
#line 1459
  head = (FTSENT *)((void *)0);
#line 1460
  tail = (FTSENT *)((void *)0);
#line 1461
  nitems = (size_t )0;
  {
#line 1462
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1462
    if (! cur->fts_dirp) {
#line 1462
      goto while_break___2;
    }
    {
#line 1465
    tmp___11 = __errno_location();
#line 1465
    *tmp___11 = 0;
#line 1466
    tmp___12 = readdir(cur->fts_dirp);
#line 1466
    dp___0 = tmp___12;
    }
#line 1467
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      {
#line 1468
      tmp___14 = __errno_location();
      }
#line 1468
      if (*tmp___14) {
        {
#line 1469
        tmp___13 = __errno_location();
#line 1469
        cur->fts_errno = *tmp___13;
        }
#line 1472
        if (continue_readdir) {
#line 1472
          cur->fts_info = (unsigned short)7;
        } else
#line 1472
        if (nitems) {
#line 1472
          cur->fts_info = (unsigned short)7;
        } else {
#line 1472
          cur->fts_info = (unsigned short)4;
        }
      }
#line 1475
      goto while_break___2;
    }
#line 1477
    if (! (sp->fts_options & 32)) {
#line 1477
      if ((int )dp___0->d_name[0] == 46) {
#line 1477
        if (! dp___0->d_name[1]) {
#line 1478
          goto while_continue___2;
        } else
#line 1477
        if ((int )dp___0->d_name[1] == 46) {
#line 1477
          if (! dp___0->d_name[2]) {
#line 1478
            goto while_continue___2;
          }
        }
      }
    }
    {
#line 1480
    d_namelen = strlen((char const   *)(dp___0->d_name));
#line 1481
    p = fts_alloc___0(sp, (char const   *)(dp___0->d_name), d_namelen);
    }
#line 1482
    if (! p) {
#line 1483
      goto mem1;
    }
#line 1484
    if (d_namelen >= maxlen) {
      {
#line 1486
      oldaddr = (void *)sp->fts_path;
#line 1487
      tmp___17 = fts_palloc___0(sp, (d_namelen + len) + 1UL);
      }
#line 1487
      if (! tmp___17) {
        mem1: 
        {
#line 1493
        tmp___15 = __errno_location();
#line 1493
        saved_errno = *tmp___15;
#line 1494
        free((void *)p);
#line 1495
        fts_lfree___0(head);
        }
        {
#line 1496
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1496
          closedir(cur->fts_dirp);
#line 1496
          cur->fts_dirp = (DIR *)((void *)0);
          }
#line 1496
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1497
        cur->fts_info = (unsigned short)7;
#line 1498
        sp->fts_options |= 16384;
#line 1499
        tmp___16 = __errno_location();
#line 1499
        *tmp___16 = saved_errno;
        }
#line 1500
        return ((FTSENT *)((void *)0));
      }
#line 1503
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1504
        doadjust = (_Bool)1;
#line 1505
        if (sp->fts_options & 4) {
#line 1506
          cp = sp->fts_path + len;
        }
      }
#line 1508
      maxlen = sp->fts_pathlen - len;
    }
#line 1511
    new_len = len + d_namelen;
#line 1512
    if (new_len < len) {
      {
#line 1519
      free((void *)p);
#line 1520
      fts_lfree___0(head);
      }
      {
#line 1521
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1521
        closedir(cur->fts_dirp);
#line 1521
        cur->fts_dirp = (DIR *)((void *)0);
        }
#line 1521
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1522
      cur->fts_info = (unsigned short)7;
#line 1523
      sp->fts_options |= 16384;
#line 1524
      tmp___18 = __errno_location();
#line 1524
      *tmp___18 = 36;
      }
#line 1525
      return ((FTSENT *)((void *)0));
    }
#line 1527
    p->fts_level = level;
#line 1528
    p->fts_parent = sp->fts_cur;
#line 1529
    p->fts_pathlen = new_len;
#line 1533
    p->fts_statp[0].st_ino = dp___0->d_ino;
#line 1536
    if (sp->fts_options & 4) {
      {
#line 1537
      p->fts_accpath = p->fts_path;
#line 1538
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1540
      p->fts_accpath = p->fts_name;
    }
#line 1542
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1542
      goto _L___1;
    } else
#line 1542
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1555
      if (sp->fts_options & 16) {
#line 1555
        if (sp->fts_options & 8) {
#line 1555
          if ((int )dp___0->d_type != 0) {
#line 1555
            if (! ((int )dp___0->d_type == 4)) {
#line 1555
              tmp___19 = 1;
            } else {
#line 1555
              tmp___19 = 0;
            }
          } else {
#line 1555
            tmp___19 = 0;
          }
        } else {
#line 1555
          tmp___19 = 0;
        }
      } else {
#line 1555
        tmp___19 = 0;
      }
      {
#line 1555
      skip_stat = (_Bool )tmp___19;
#line 1559
      p->fts_info = (unsigned short)11;
#line 1562
      set_stat_type___0(p->fts_statp, (unsigned int )dp___0->d_type);
#line 1563
      fts_set_stat_required___0(p, (_Bool )(! skip_stat));
      }
#line 1564
      if (sp->fts_options & 16) {
#line 1564
        if ((int )dp___0->d_type == 4) {
#line 1564
          tmp___20 = 1;
        } else {
#line 1564
          tmp___20 = 0;
        }
      } else {
#line 1564
        tmp___20 = 0;
      }
#line 1564
      is_dir = (_Bool )tmp___20;
    } else {
      {
#line 1567
      p->fts_info = fts_stat___0(sp, p, (_Bool)0);
      }
#line 1568
      if ((int )p->fts_info == 1) {
#line 1568
        tmp___21 = 1;
      } else
#line 1568
      if ((int )p->fts_info == 2) {
#line 1568
        tmp___21 = 1;
      } else
#line 1568
      if ((int )p->fts_info == 5) {
#line 1568
        tmp___21 = 1;
      } else {
#line 1568
        tmp___21 = 0;
      }
#line 1568
      is_dir = (_Bool )tmp___21;
    }
#line 1574
    if (nlinks > 0UL) {
#line 1574
      if (is_dir) {
#line 1575
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1578
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1579
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1580
      tail = p;
#line 1580
      head = tail;
    } else {
#line 1582
      tail->fts_link = p;
#line 1583
      tail = p;
    }
#line 1585
    nitems ++;
#line 1586
    if (max_entries <= nitems) {
#line 1590
      goto break_without_closedir;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1594
  if (cur->fts_dirp) {
    {
#line 1595
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1595
      closedir(cur->fts_dirp);
#line 1595
      cur->fts_dirp = (DIR *)((void *)0);
      }
#line 1595
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  break_without_closedir: 
#line 1603
  if (doadjust) {
    {
#line 1604
    fts_padjust___0(sp, head);
    }
  }
#line 1610
  if (sp->fts_options & 4) {
#line 1611
    if (len == sp->fts_pathlen) {
#line 1612
      cp --;
    } else
#line 1611
    if (nitems == 0UL) {
#line 1612
      cp --;
    }
#line 1613
    *cp = (char )'\000';
  }
#line 1623
  if (! continue_readdir) {
#line 1623
    if (descend) {
#line 1623
      if (type == 1) {
#line 1623
        goto _L___2;
      } else
#line 1623
      if (! nitems) {
        _L___2: /* CIL Label */ 
#line 1623
        if (cur->fts_level == 0L) {
          {
#line 1623
          tmp___22 = restore_initial_cwd___0(sp);
#line 1623
          tmp___24 = tmp___22;
          }
        } else {
          {
#line 1623
          tmp___23 = fts_safe_changedir___0(sp, cur->fts_parent, -1, "..");
#line 1623
          tmp___24 = tmp___23;
          }
        }
#line 1623
        if (tmp___24) {
          {
#line 1627
          cur->fts_info = (unsigned short)7;
#line 1628
          sp->fts_options |= 16384;
#line 1629
          fts_lfree___0(head);
          }
#line 1630
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
#line 1634
  if (! nitems) {
#line 1635
    if (type == 3) {
#line 1635
      if ((int )cur->fts_info != 4) {
#line 1635
        if ((int )cur->fts_info != 7) {
#line 1637
          cur->fts_info = (unsigned short)6;
        }
      }
    }
    {
#line 1638
    fts_lfree___0(head);
    }
#line 1639
    return ((FTSENT *)((void *)0));
  }
#line 1646
  if (nitems > 10000UL) {
#line 1646
    if (! sp->fts_compar) {
#line 1646
      if (sp->fts_options & 512) {
        {
#line 1646
        tmp___25 = dirent_inode_sort_may_be_useful___0(sp->fts_cwd_fd);
        }
#line 1646
        if (tmp___25) {
          {
#line 1650
          sp->fts_compar = & fts_compare_ino___0;
#line 1651
          head = fts_sort___0(sp, head, nitems);
#line 1652
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1656
  if (sp->fts_compar) {
#line 1656
    if (nitems > 1UL) {
      {
#line 1657
      head = fts_sort___0(sp, head, nitems);
      }
    }
  }
#line 1658
  return (head);
}
}
#line 1805 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1809
  sbp = p->fts_statp;
#line 1812
  if (p->fts_level == 0L) {
#line 1812
    if (sp->fts_options & 1) {
#line 1813
      follow = (_Bool)1;
    }
  }
#line 1820
  if (sp->fts_options & 2) {
#line 1820
    goto _L;
  } else
#line 1820
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1821
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1821
    if (tmp___3) {
      {
#line 1822
      tmp = __errno_location();
#line 1822
      saved_errno = *tmp;
#line 1823
      tmp___1 = __errno_location();
      }
#line 1823
      if (*tmp___1 == 2) {
        {
#line 1823
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1823
        if (tmp___2 == 0) {
          {
#line 1825
          tmp___0 = __errno_location();
#line 1825
          *tmp___0 = 0;
          }
#line 1826
          return ((unsigned short)13);
        }
      }
#line 1828
      p->fts_errno = saved_errno;
#line 1829
      goto err;
    }
  } else {
    {
#line 1831
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1831
    if (tmp___5) {
      {
#line 1833
      tmp___4 = __errno_location();
#line 1833
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1834
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1835
      return ((unsigned short)10);
    }
  }
#line 1838
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1839
    if (sp->fts_options & 32) {
#line 1839
      tmp___6 = 0;
    } else {
#line 1839
      tmp___6 = 2;
    }
#line 1839
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1841
    if ((int )p->fts_name[0] == 46) {
#line 1841
      if (! p->fts_name[1]) {
#line 1841
        goto _L___0;
      } else
#line 1841
      if ((int )p->fts_name[1] == 46) {
#line 1841
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1843
          if (p->fts_level == 0L) {
#line 1843
            tmp___7 = 1;
          } else {
#line 1843
            tmp___7 = 5;
          }
#line 1843
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1846
    return ((unsigned short)1);
  }
#line 1848
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1849
    return ((unsigned short)12);
  }
#line 1850
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1851
    return ((unsigned short)8);
  }
#line 1852
  return ((unsigned short)3);
}
}
#line 1855 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_compar___0(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1863
  pa = (FTSENT const   **)a;
#line 1864
  pb = (FTSENT const   **)b;
#line 1865
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1865
  return (tmp);
}
}
#line 1868 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1882
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1882
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1882
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1882
      tmp = & fts_compar___0;
    }
  } else {
#line 1882
    tmp = & fts_compar___0;
  }
#line 1882
  compare = tmp;
#line 1895
  if (nitems > sp->fts_nitems) {
#line 1898
    sp->fts_nitems = nitems + 40UL;
#line 1899
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1902
      free((void *)sp->fts_array);
#line 1903
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1904
      sp->fts_nitems = (size_t )0;
      }
#line 1905
      return (head);
    } else {
      {
#line 1899
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1899
      a = (FTSENT **)tmp___0;
      }
#line 1899
      if (! a) {
        {
#line 1902
        free((void *)sp->fts_array);
#line 1903
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1904
        sp->fts_nitems = (size_t )0;
        }
#line 1905
        return (head);
      }
    }
#line 1907
    sp->fts_array = a;
  }
#line 1909
  ap = sp->fts_array;
#line 1909
  p = head;
  {
#line 1909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1909
    if (! p) {
#line 1909
      goto while_break;
    }
#line 1910
    tmp___1 = ap;
#line 1910
    ap ++;
#line 1910
    *tmp___1 = p;
#line 1909
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1911
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1912
  ap = sp->fts_array;
#line 1912
  head = *ap;
  }
  {
#line 1912
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1912
    nitems --;
#line 1912
    if (! nitems) {
#line 1912
      goto while_break___0;
    }
#line 1913
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1912
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1914
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1915
  return (head);
}
}
#line 1918 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1929
  len = ((((unsigned long )(& ((FTSENT *)0)->fts_name) + __alignof__(FTSENT )) - 1UL) + (namelen + 1UL)) & ~ (__alignof__(FTSENT ) - 1UL);
#line 1930
  tmp = malloc(len);
#line 1930
  p = (FTSENT *)tmp;
  }
#line 1930
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1931
    return ((FTSENT *)((void *)0));
  }
  {
#line 1934
  memcpy((void */* __restrict  */)(p->fts_name), (void const   */* __restrict  */)name,
         namelen);
#line 1935
  p->fts_name[namelen] = (char )'\000';
#line 1937
  p->fts_namelen = namelen;
#line 1938
  p->fts_fts = sp;
#line 1939
  p->fts_path = sp->fts_path;
#line 1940
  p->fts_errno = 0;
#line 1941
  p->fts_dirp = (DIR *)((void *)0);
#line 1942
  p->fts_flags = (unsigned short)0;
#line 1943
  p->fts_instr = (unsigned short)3;
#line 1944
  p->fts_number = 0L;
#line 1945
  p->fts_pointer = (void *)0;
  }
#line 1946
  return (p);
}
}
#line 1949 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_lfree___0(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1956
    p = head;
#line 1956
    if (! p) {
#line 1956
      goto while_break;
    }
#line 1957
    head = head->fts_link;
#line 1958
    if (p->fts_dirp) {
      {
#line 1959
      closedir(p->fts_dirp);
      }
    }
    {
#line 1960
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1962
  return;
}
}
#line 1971 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static _Bool fts_palloc___0(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1976
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1981
  if (new_len < sp->fts_pathlen) {
    {
#line 1982
    free((void *)sp->fts_path);
#line 1983
    sp->fts_path = (char *)((void *)0);
#line 1984
    tmp = __errno_location();
#line 1984
    *tmp = 36;
    }
#line 1985
    return ((_Bool)0);
  }
  {
#line 1987
  sp->fts_pathlen = new_len;
#line 1988
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1988
  p = (char *)tmp___0;
  }
#line 1989
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1990
    free((void *)sp->fts_path);
#line 1991
    sp->fts_path = (char *)((void *)0);
    }
#line 1992
    return ((_Bool)0);
  }
#line 1994
  sp->fts_path = p;
#line 1995
  return ((_Bool)1);
}
}
#line 2002 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static void fts_padjust___0(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 2007
  addr = sp->fts_path;
#line 2017
  p = sp->fts_child;
  {
#line 2017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2017
    if (! p) {
#line 2017
      goto while_break;
    }
    {
#line 2018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2018
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2018
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2018
      p->fts_path = addr;
#line 2018
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2017
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  p = head;
  {
#line 2021
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2021
    if (! (p->fts_level >= 0L)) {
#line 2021
      goto while_break___1;
    }
    {
#line 2022
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2022
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 2022
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 2022
      p->fts_path = addr;
#line 2022
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2023
    if (p->fts_link) {
#line 2023
      p = p->fts_link;
    } else {
#line 2023
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2025
  return;
}
}
#line 2027 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static size_t __attribute__((__pure__))  fts_maxarglen___0(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 2033
  max = (size_t )0;
  {
#line 2033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2033
    if (! *argv) {
#line 2033
      goto while_break;
    }
    {
#line 2034
    len = strlen((char const   *)*argv);
    }
#line 2034
    if (len > max) {
#line 2035
      max = len;
    }
#line 2033
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2036
  return ((size_t __attribute__((__pure__))  )(max + 1UL));
}
}
#line 2048 "/home/khheo/project/benchmark/grep-3.0/lib/fts.c"
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 2053
  if (dir) {
    {
#line 2053
    tmp = strcmp(dir, "..");
    }
#line 2053
    if (tmp == 0) {
#line 2053
      tmp___0 = 1;
    } else {
#line 2053
      tmp___0 = 0;
    }
  } else {
#line 2053
    tmp___0 = 0;
  }
#line 2053
  is_dotdot = (_Bool )tmp___0;
#line 2060
  if (sp->fts_options & 4) {
#line 2062
    if (sp->fts_options & 512) {
#line 2062
      if (0 <= fd) {
        {
#line 2063
        close(fd);
        }
      }
    }
#line 2064
    return (0);
  }
#line 2067
  if (fd < 0) {
#line 2067
    if (is_dotdot) {
#line 2067
      if (sp->fts_options & 512) {
        {
#line 2074
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 2074
        if (! tmp___1) {
          {
#line 2078
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 2079
          is_dotdot = (_Bool)1;
          }
#line 2080
          if (0 <= parent_fd) {
#line 2082
            fd = parent_fd;
#line 2083
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 2088
  newfd = fd;
#line 2089
  if (fd < 0) {
    {
#line 2089
    newfd = diropen___0((FTS const   *)sp, dir);
    }
#line 2089
    if (newfd < 0) {
#line 2090
      return (-1);
    }
  }
#line 2099
  if (sp->fts_options & 2) {
#line 2099
    goto _L;
  } else
#line 2099
  if (dir) {
    {
#line 2099
    tmp___4 = strcmp(dir, "..");
    }
#line 2099
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 2103
      tmp___2 = fstat(newfd, & sb);
      }
#line 2103
      if (tmp___2) {
#line 2105
        ret = -1;
#line 2106
        goto bail;
      }
#line 2108
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2111
        tmp___3 = __errno_location();
#line 2111
        *tmp___3 = 2;
#line 2112
        ret = -1;
        }
#line 2113
        goto bail;
      } else
#line 2108
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2111
        tmp___3 = __errno_location();
#line 2111
        *tmp___3 = 2;
#line 2112
        ret = -1;
        }
#line 2113
        goto bail;
      }
    }
  }
#line 2117
  if (sp->fts_options & 512) {
    {
#line 2119
    cwd_advance_fd___0(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2120
    return (0);
  }
  {
#line 2123
  ret = fchdir(newfd);
  }
  bail: 
#line 2125
  if (fd < 0) {
    {
#line 2127
    tmp___5 = __errno_location();
#line 2127
    oerrno = *tmp___5;
#line 2128
    close(newfd);
#line 2129
    tmp___6 = __errno_location();
#line 2129
    *tmp___6 = oerrno;
    }
  }
#line 2131
  return (ret);
}
}
#line 37 "/home/khheo/project/benchmark/grep-3.0/lib/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix___0(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 335 "/home/khheo/project/benchmark/grep-3.0/lib/fcntl.c"
static int have_dupfd_cloexec___0  =    0;
#line 80 "./wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/grep-3.0/lib/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 179 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void unescape_pattern___0(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 197 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static size_t string_hasher___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static size_t string_hasher_ci___0(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value);
}
}
#line 229 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool string_compare___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool string_compare_ci___0(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void string_free___0(void *data ) 
{ 


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void new_exclude_segment___0(struct exclude *ex , enum exclude_type type ,
                                    int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  goto switch_break;
  case_0: /* CIL Label */ 
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci___0;
  } else {
#line 266
    tmp___0 = & string_compare___0;
  }
#line 266
  if (options & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci___0;
  } else {
#line 266
    tmp___1 = & string_hasher___0;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free___0);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void free_exclude_segment___0(struct exclude_segment *seg ) 
{ 
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 332 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static int fnmatch_no_wildcards___0(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options & (1 << 3))) {
#line 336
    if (options & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 395 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool exclude_patopts___0(struct patopts  const  *opts , char const   *f ) 
{ 
  int options ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options = (int )opts->options;
#line 400
  if (options & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool file_pattern_matches___0(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts___0(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static _Bool file_name_matches___0(struct exclude_segment  const  *seg , char const   *f ,
                                   char *buffer___0 ) 
{ 
  int options ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___0);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___0, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 668 "/home/khheo/project/benchmark/grep-3.0/lib/exclude.c"
static void call_addfn___0(struct exclude *ex , char const   *pattern , int options ,
                           void *data ) 
{ 
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options);
  }
#line 673
  return;
}
}
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool streq___0(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = strcmp(a, b);
  }
#line 39
  return ((_Bool )(tmp == 0));
}
}
#line 42 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool isasciidigit___0(char c ) 
{ 
  int tmp ;

  {
#line 45
  if (48 <= (int )c) {
#line 45
    if ((int )c <= 57) {
#line 45
      tmp = 1;
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 96 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK___0  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 111 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned char to_uchar___1(char ch ) 
{ 


  {
#line 114
  return ((unsigned char )ch);
}
}
#line 152 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int newline_constraint___0(int constraint ) 
{ 


  {
#line 155
  return ((constraint >> 6) & 7);
}
}
#line 157 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int letter_constraint___0(int constraint ) 
{ 


  {
#line 160
  return ((constraint >> 3) & 7);
}
}
#line 162 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int other_constraint___0(int constraint ) 
{ 


  {
#line 165
  return (constraint & 7);
}
}
#line 168 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool succeeds_in_context___0(int constraint , int prev , int curr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 171
  if (curr & 1) {
    {
#line 171
    tmp = other_constraint___0(constraint);
#line 171
    tmp___0 = tmp;
    }
  } else {
#line 171
    tmp___0 = 0;
  }
#line 171
  if (curr & 2) {
    {
#line 171
    tmp___1 = letter_constraint___0(constraint);
#line 171
    tmp___2 = tmp___1;
    }
  } else {
#line 171
    tmp___2 = 0;
  }
#line 171
  if (curr & 4) {
    {
#line 171
    tmp___3 = newline_constraint___0(constraint);
#line 171
    tmp___4 = tmp___3;
    }
  } else {
#line 171
    tmp___4 = 0;
  }
#line 171
  if (((tmp___0 | tmp___2) | tmp___4) & prev) {
#line 171
    tmp___5 = 1;
  } else {
#line 171
    tmp___5 = 0;
  }
#line 171
  return ((_Bool )tmp___5);
}
}
#line 178 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool prev_newline_dependent___0(int constraint ) 
{ 


  {
#line 181
  return ((_Bool )(((constraint ^ (constraint >> 2)) & 73) != 0));
}
}
#line 183 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool prev_letter_dependent___0(int constraint ) 
{ 


  {
#line 186
  return ((_Bool )(((constraint ^ (constraint >> 1)) & 73) != 0));
}
}
#line 209 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static long const   TOKEN_MAX___0  =    (ptrdiff_t const   )9223372036854775807L;
#line 565 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool accepting___0(state_num s , struct dfa  const  *r ) 
{ 


  {
#line 568
  return ((_Bool )((int )(r->states + s)->constraint != 0));
}
}
#line 572 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool accepts_in_context___0(int prev , int curr , state_num state , struct dfa  const  *dfa ) 
{ 
  _Bool tmp ;

  {
  {
#line 575
  tmp = succeeds_in_context___0((int )(dfa->states + state)->constraint, prev, curr);
  }
#line 575
  return (tmp);
}
}
#line 578
static void regexp___0(struct dfa *dfa ) ;
#line 597 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static size_t mbs_to_wchar___0(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 600
  uc = (unsigned char )*(s + 0);
#line 601
  wc = d->localeinfo.sbctowc[uc];
#line 603
  if (wc == 4294967295U) {
    {
#line 606
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 606
    nbytes = tmp;
    }
#line 607
    if (0UL < nbytes) {
#line 607
      if (nbytes < 0xfffffffffffffffeUL) {
#line 609
        *pwc = (wint_t )wch;
#line 610
        return (nbytes);
      }
    }
    {
#line 612
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 615
  *pwc = wc;
#line 616
  return ((size_t )1);
}
}
#line 698 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool tstbit___0(unsigned int b , charclass const   *c ) 
{ 


  {
#line 701
  return ((_Bool )((c->w[b / 64U] >> b % 64U) & 1UL));
}
}
#line 704 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void setbit___0(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 707
  one = (charclass_word )1;
#line 708
  c->w[b / 64U] |= one << b % 64U;
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void clrbit___0(unsigned int b , charclass *c ) 
{ 
  charclass_word one ;

  {
#line 714
  one = (charclass_word )1;
#line 715
  c->w[b / 64U] &= ~ (one << b % 64U);
#line 716
  return;
}
}
#line 718 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void zeroset___0(charclass *s ) 
{ 


  {
  {
#line 721
  memset((void *)s, 0, sizeof(*s));
  }
#line 722
  return;
}
}
#line 724 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void fillset___0(charclass *s ) 
{ 
  int i ;

  {
#line 727
  i = 0;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! (i < 4)) {
#line 727
      goto while_break;
    }
#line 728
    s->w[i] = (charclass_word )CHARCLASS_WORD_MASK___0;
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return;
}
}
#line 731 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void notset___0(charclass *s ) 
{ 
  int i ;

  {
#line 734
  i = 0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (i < 4)) {
#line 734
      goto while_break;
    }
#line 735
    s->w[i] = (charclass_word )(CHARCLASS_WORD_MASK___0 & (unsigned long const   )(~ s->w[i]));
#line 734
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return;
}
}
#line 738 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool equal___0(charclass const   *s1 , charclass const   *s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 741
  w = (charclass_word )0;
#line 742
  i = 0;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! (i < 4)) {
#line 742
      goto while_break;
    }
#line 743
    w |= s1->w[i] ^ s2->w[i];
#line 742
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return ((_Bool )(w == 0UL));
}
}
#line 747 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool emptyset___0(charclass const   *s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 750
  w = (charclass_word )0;
#line 751
  i = 0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (i < 4)) {
#line 751
      goto while_break;
    }
#line 752
    w |= s->w[i];
#line 751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return ((_Bool )(w == 0UL));
}
}
#line 772 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void *xpalloc___0(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min ,
                         ptrdiff_t nitems_max , ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 776
  n0 = *nitems;
#line 789
  if (sizeof(n) == sizeof(signed char )) {
#line 789
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 789
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 789
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 789
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 789
        tmp___7 = tmp___4;
      } else {
#line 789
        if ((int )((signed char )n0) < 0) {
#line 789
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 789
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 789
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 789
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 789
          tmp___6 = tmp___5;
        }
#line 789
        tmp___7 = tmp___6;
      }
#line 789
      if (tmp___7) {
#line 789
        goto _L;
      } else
#line 789
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 789
        goto _L;
      } else
#line 789
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
        _L: /* CIL Label */ 
#line 789
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 789
        tmp___3 = 1;
      } else {
#line 789
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 789
        tmp___3 = 0;
      }
#line 789
      tmp___17 = tmp___3;
    } else {
#line 789
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
        if (n0 >> 1 < 0L) {
#line 789
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 789
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 789
        tmp___16 = tmp___13;
      } else {
#line 789
        if (n0 < 0L) {
#line 789
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 789
          if (n0 >> 1 < 0L) {
#line 789
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 789
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 789
          tmp___15 = tmp___14;
        }
#line 789
        tmp___16 = tmp___15;
      }
#line 789
      if (tmp___16) {
#line 789
        goto _L___0;
      } else
#line 789
      if (n0 + (n0 >> 1) < -128L) {
#line 789
        goto _L___0;
      } else
#line 789
      if (127L < n0 + (n0 >> 1)) {
        _L___0: /* CIL Label */ 
#line 789
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 789
        tmp___12 = 1;
      } else {
#line 789
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 789
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 789
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 789
        tmp___12 = 0;
      }
#line 789
      tmp___17 = tmp___12;
    }
#line 789
    tmp___97 = tmp___17;
  } else {
#line 789
    if (sizeof(n) == sizeof(short )) {
#line 789
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 789
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
          if ((int )((short )(n0 >> 1)) < 0) {
#line 789
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 789
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 789
          tmp___26 = tmp___23;
        } else {
#line 789
          if ((int )((short )n0) < 0) {
#line 789
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 789
            if ((int )((short )(n0 >> 1)) < 0) {
#line 789
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 789
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 789
            tmp___25 = tmp___24;
          }
#line 789
          tmp___26 = tmp___25;
        }
#line 789
        if (tmp___26) {
#line 789
          goto _L___1;
        } else
#line 789
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 789
          goto _L___1;
        } else
#line 789
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
          _L___1: /* CIL Label */ 
#line 789
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 789
          tmp___22 = 1;
        } else {
#line 789
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 789
          tmp___22 = 0;
        }
#line 789
        tmp___36 = tmp___22;
      } else {
#line 789
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
          if (n0 >> 1 < 0L) {
#line 789
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 789
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 789
          tmp___35 = tmp___32;
        } else {
#line 789
          if (n0 < 0L) {
#line 789
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 789
            if (n0 >> 1 < 0L) {
#line 789
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 789
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 789
            tmp___34 = tmp___33;
          }
#line 789
          tmp___35 = tmp___34;
        }
#line 789
        if (tmp___35) {
#line 789
          goto _L___2;
        } else
#line 789
        if (n0 + (n0 >> 1) < -32768L) {
#line 789
          goto _L___2;
        } else
#line 789
        if (32767L < n0 + (n0 >> 1)) {
          _L___2: /* CIL Label */ 
#line 789
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 789
          tmp___31 = 1;
        } else {
#line 789
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 789
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 789
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 789
          tmp___31 = 0;
        }
#line 789
        tmp___36 = tmp___31;
      }
#line 789
      tmp___96 = tmp___36;
    } else {
#line 789
      if (sizeof(n) == sizeof(int )) {
#line 789
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 789
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 789
            if ((int )(n0 >> 1) < 0) {
#line 789
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 789
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 789
            tmp___45 = tmp___42;
          } else {
#line 789
            if ((int )n0 < 0) {
#line 789
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 789
              if ((int )(n0 >> 1) < 0) {
#line 789
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 789
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 789
              tmp___44 = tmp___43;
            }
#line 789
            tmp___45 = tmp___44;
          }
#line 789
          if (tmp___45) {
#line 789
            goto _L___3;
          } else
#line 789
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 789
            goto _L___3;
          } else
#line 789
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
            _L___3: /* CIL Label */ 
#line 789
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___41 = 1;
          } else {
#line 789
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___41 = 0;
          }
#line 789
          tmp___55 = tmp___41;
        } else {
#line 789
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
            if (n0 >> 1 < 0L) {
#line 789
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 789
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 789
            tmp___54 = tmp___51;
          } else {
#line 789
            if (n0 < 0L) {
#line 789
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 789
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 789
              tmp___53 = tmp___52;
            }
#line 789
            tmp___54 = tmp___53;
          }
#line 789
          if (tmp___54) {
#line 789
            goto _L___4;
          } else
#line 789
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 789
            goto _L___4;
          } else
#line 789
          if (2147483647L < n0 + (n0 >> 1)) {
            _L___4: /* CIL Label */ 
#line 789
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___50 = 1;
          } else {
#line 789
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 789
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 789
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 789
            tmp___50 = 0;
          }
#line 789
          tmp___55 = tmp___50;
        }
#line 789
        tmp___95 = tmp___55;
      } else {
#line 789
        if (sizeof(n) == sizeof(long )) {
#line 789
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___64 = tmp___61;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___63 = tmp___62;
              }
#line 789
              tmp___64 = tmp___63;
            }
#line 789
            if (tmp___64) {
#line 789
              goto _L___5;
            } else
#line 789
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___5;
            } else
#line 789
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___5: /* CIL Label */ 
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___60 = 1;
            } else {
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___60 = 0;
            }
#line 789
            tmp___74 = tmp___60;
          } else {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___73 = tmp___70;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___72 = tmp___71;
              }
#line 789
              tmp___73 = tmp___72;
            }
#line 789
            if (tmp___73) {
#line 789
              goto _L___6;
            } else
#line 789
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___6;
            } else
#line 789
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___6: /* CIL Label */ 
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___69 = 1;
            } else {
#line 789
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 789
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 789
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 789
              tmp___69 = 0;
            }
#line 789
            tmp___74 = tmp___69;
          }
#line 789
          tmp___94 = tmp___74;
        } else {
#line 789
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 789
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 789
              if ((long long )(n0 >> 1) < 0LL) {
#line 789
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 789
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 789
              tmp___83 = tmp___80;
            } else {
#line 789
              if ((long long )n0 < 0LL) {
#line 789
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 789
                if ((long long )(n0 >> 1) < 0LL) {
#line 789
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 789
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 789
                tmp___82 = tmp___81;
              }
#line 789
              tmp___83 = tmp___82;
            }
#line 789
            if (tmp___83) {
#line 789
              goto _L___7;
            } else
#line 789
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___7;
            } else
#line 789
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
              _L___7: /* CIL Label */ 
#line 789
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___79 = 1;
            } else {
#line 789
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___79 = 0;
            }
#line 789
            tmp___93 = tmp___79;
          } else {
#line 789
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 789
              if (n0 >> 1 < 0L) {
#line 789
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 789
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 789
              tmp___92 = tmp___89;
            } else {
#line 789
              if (n0 < 0L) {
#line 789
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 789
                if (n0 >> 1 < 0L) {
#line 789
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 789
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 789
                tmp___91 = tmp___90;
              }
#line 789
              tmp___92 = tmp___91;
            }
#line 789
            if (tmp___92) {
#line 789
              goto _L___8;
            } else
#line 789
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 789
              goto _L___8;
            } else
#line 789
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
              _L___8: /* CIL Label */ 
#line 789
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___88 = 1;
            } else {
#line 789
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 789
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 789
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 789
              tmp___88 = 0;
            }
#line 789
            tmp___93 = tmp___88;
          }
#line 789
          tmp___94 = tmp___93;
        }
#line 789
        tmp___95 = tmp___94;
      }
#line 789
      tmp___96 = tmp___95;
    }
#line 789
    tmp___97 = tmp___96;
  }
#line 789
  if (tmp___97) {
#line 790
    n = 9223372036854775807L;
  }
#line 791
  if (0L <= nitems_max) {
#line 791
    if (nitems_max < n) {
#line 792
      n = nitems_max;
    }
  }
#line 794
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 794
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 794
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
        if ((int )((signed char )n) < 0) {
#line 794
          if (0 < (int )((signed char )item_size)) {
#line 794
            goto _L___39;
          } else {
#line 794
            goto _L___41;
          }
        } else
        _L___41: /* CIL Label */ 
#line 794
        if ((int )((signed char )item_size) < 0) {
#line 794
          if (0 < (int )((signed char )n)) {
#line 794
            goto _L___39;
          } else {
#line 794
            goto _L___40;
          }
        } else {
#line 794
          goto _L___40;
        }
      } else {
        _L___40: /* CIL Label */ 
#line 794
        if ((int )((signed char )item_size) < 0) {
#line 794
          if ((int )((signed char )n) < 0) {
#line 794
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 794
            if ((int )((signed char )item_size) == -1) {
#line 794
              tmp___225 = 0;
            } else {
#line 794
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 794
            tmp___226 = tmp___225;
          }
#line 794
          tmp___229 = tmp___226;
        } else {
#line 794
          if ((int )((signed char )item_size) == 0) {
#line 794
            tmp___228 = 0;
          } else {
#line 794
            if ((int )((signed char )n) < 0) {
#line 794
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 794
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 794
            tmp___228 = tmp___227;
          }
#line 794
          tmp___229 = tmp___228;
        }
#line 794
        if (tmp___229) {
#line 794
          goto _L___39;
        } else
#line 794
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 794
          goto _L___39;
        } else
#line 794
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
          _L___39: /* CIL Label */ 
#line 794
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 794
          tmp___224 = 1;
        } else {
#line 794
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 794
          tmp___224 = 0;
        }
      }
#line 794
      tmp___241 = tmp___224;
    } else {
#line 794
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
        if (n < 0L) {
#line 794
          if (0L < item_size) {
#line 794
            goto _L___42;
          } else {
#line 794
            goto _L___44;
          }
        } else
        _L___44: /* CIL Label */ 
#line 794
        if (item_size < 0L) {
#line 794
          if (0L < n) {
#line 794
            goto _L___42;
          } else {
#line 794
            goto _L___43;
          }
        } else {
#line 794
          goto _L___43;
        }
      } else {
        _L___43: /* CIL Label */ 
#line 794
        if (item_size < 0L) {
#line 794
          if (n < 0L) {
#line 794
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 794
            if (item_size == -1L) {
#line 794
              tmp___236 = 0;
            } else {
#line 794
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 794
            tmp___237 = tmp___236;
          }
#line 794
          tmp___240 = tmp___237;
        } else {
#line 794
          if (item_size == 0L) {
#line 794
            tmp___239 = 0;
          } else {
#line 794
            if (n < 0L) {
#line 794
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 794
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 794
            tmp___239 = tmp___238;
          }
#line 794
          tmp___240 = tmp___239;
        }
#line 794
        if (tmp___240) {
#line 794
          goto _L___42;
        } else
#line 794
        if (n * item_size < -128L) {
#line 794
          goto _L___42;
        } else
#line 794
        if (127L < n * item_size) {
          _L___42: /* CIL Label */ 
#line 794
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 794
          tmp___235 = 1;
        } else {
#line 794
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 794
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 794
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 794
          tmp___235 = 0;
        }
      }
#line 794
      tmp___241 = tmp___235;
    }
#line 794
    tmp___337 = tmp___241;
  } else {
#line 794
    if (sizeof(nbytes) == sizeof(short )) {
#line 794
      if (sizeof(n * item_size) < sizeof(short )) {
#line 794
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
          if ((int )((short )n) < 0) {
#line 794
            if (0 < (int )((short )item_size)) {
#line 794
              goto _L___45;
            } else {
#line 794
              goto _L___47;
            }
          } else
          _L___47: /* CIL Label */ 
#line 794
          if ((int )((short )item_size) < 0) {
#line 794
            if (0 < (int )((short )n)) {
#line 794
              goto _L___45;
            } else {
#line 794
              goto _L___46;
            }
          } else {
#line 794
            goto _L___46;
          }
        } else {
          _L___46: /* CIL Label */ 
#line 794
          if ((int )((short )item_size) < 0) {
#line 794
            if ((int )((short )n) < 0) {
#line 794
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 794
              if ((int )((short )item_size) == -1) {
#line 794
                tmp___248 = 0;
              } else {
#line 794
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 794
              tmp___249 = tmp___248;
            }
#line 794
            tmp___252 = tmp___249;
          } else {
#line 794
            if ((int )((short )item_size) == 0) {
#line 794
              tmp___251 = 0;
            } else {
#line 794
              if ((int )((short )n) < 0) {
#line 794
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 794
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 794
              tmp___251 = tmp___250;
            }
#line 794
            tmp___252 = tmp___251;
          }
#line 794
          if (tmp___252) {
#line 794
            goto _L___45;
          } else
#line 794
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 794
            goto _L___45;
          } else
#line 794
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
            _L___45: /* CIL Label */ 
#line 794
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 794
            tmp___247 = 1;
          } else {
#line 794
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 794
            tmp___247 = 0;
          }
        }
#line 794
        tmp___264 = tmp___247;
      } else {
#line 794
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
          if (n < 0L) {
#line 794
            if (0L < item_size) {
#line 794
              goto _L___48;
            } else {
#line 794
              goto _L___50;
            }
          } else
          _L___50: /* CIL Label */ 
#line 794
          if (item_size < 0L) {
#line 794
            if (0L < n) {
#line 794
              goto _L___48;
            } else {
#line 794
              goto _L___49;
            }
          } else {
#line 794
            goto _L___49;
          }
        } else {
          _L___49: /* CIL Label */ 
#line 794
          if (item_size < 0L) {
#line 794
            if (n < 0L) {
#line 794
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 794
              if (item_size == -1L) {
#line 794
                tmp___259 = 0;
              } else {
#line 794
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 794
              tmp___260 = tmp___259;
            }
#line 794
            tmp___263 = tmp___260;
          } else {
#line 794
            if (item_size == 0L) {
#line 794
              tmp___262 = 0;
            } else {
#line 794
              if (n < 0L) {
#line 794
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 794
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 794
              tmp___262 = tmp___261;
            }
#line 794
            tmp___263 = tmp___262;
          }
#line 794
          if (tmp___263) {
#line 794
            goto _L___48;
          } else
#line 794
          if (n * item_size < -32768L) {
#line 794
            goto _L___48;
          } else
#line 794
          if (32767L < n * item_size) {
            _L___48: /* CIL Label */ 
#line 794
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 794
            tmp___258 = 1;
          } else {
#line 794
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 794
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 794
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 794
            tmp___258 = 0;
          }
        }
#line 794
        tmp___264 = tmp___258;
      }
#line 794
      tmp___336 = tmp___264;
    } else {
#line 794
      if (sizeof(nbytes) == sizeof(int )) {
#line 794
        if (sizeof(n * item_size) < sizeof(int )) {
#line 794
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 794
            if ((int )n < 0) {
#line 794
              if (0 < (int )item_size) {
#line 794
                goto _L___51;
              } else {
#line 794
                goto _L___53;
              }
            } else
            _L___53: /* CIL Label */ 
#line 794
            if ((int )item_size < 0) {
#line 794
              if (0 < (int )n) {
#line 794
                goto _L___51;
              } else {
#line 794
                goto _L___52;
              }
            } else {
#line 794
              goto _L___52;
            }
          } else {
            _L___52: /* CIL Label */ 
#line 794
            if ((int )item_size < 0) {
#line 794
              if ((int )n < 0) {
#line 794
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 794
                if ((int )item_size == -1) {
#line 794
                  tmp___271 = 0;
                } else {
#line 794
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 794
                tmp___272 = tmp___271;
              }
#line 794
              tmp___275 = tmp___272;
            } else {
#line 794
              if ((int )item_size == 0) {
#line 794
                tmp___274 = 0;
              } else {
#line 794
                if ((int )n < 0) {
#line 794
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 794
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 794
                tmp___274 = tmp___273;
              }
#line 794
              tmp___275 = tmp___274;
            }
#line 794
            if (tmp___275) {
#line 794
              goto _L___51;
            } else
#line 794
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 794
              goto _L___51;
            } else
#line 794
            if (2147483647 < (int )n * (int )item_size) {
              _L___51: /* CIL Label */ 
#line 794
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___270 = 1;
            } else {
#line 794
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___270 = 0;
            }
          }
#line 794
          tmp___287 = tmp___270;
        } else {
#line 794
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
            if (n < 0L) {
#line 794
              if (0L < item_size) {
#line 794
                goto _L___54;
              } else {
#line 794
                goto _L___56;
              }
            } else
            _L___56: /* CIL Label */ 
#line 794
            if (item_size < 0L) {
#line 794
              if (0L < n) {
#line 794
                goto _L___54;
              } else {
#line 794
                goto _L___55;
              }
            } else {
#line 794
              goto _L___55;
            }
          } else {
            _L___55: /* CIL Label */ 
#line 794
            if (item_size < 0L) {
#line 794
              if (n < 0L) {
#line 794
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 794
                if (item_size == -1L) {
#line 794
                  tmp___282 = 0;
                } else {
#line 794
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 794
                tmp___283 = tmp___282;
              }
#line 794
              tmp___286 = tmp___283;
            } else {
#line 794
              if (item_size == 0L) {
#line 794
                tmp___285 = 0;
              } else {
#line 794
                if (n < 0L) {
#line 794
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 794
                tmp___285 = tmp___284;
              }
#line 794
              tmp___286 = tmp___285;
            }
#line 794
            if (tmp___286) {
#line 794
              goto _L___54;
            } else
#line 794
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 794
              goto _L___54;
            } else
#line 794
            if (2147483647L < n * item_size) {
              _L___54: /* CIL Label */ 
#line 794
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___281 = 1;
            } else {
#line 794
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 794
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 794
              tmp___281 = 0;
            }
          }
#line 794
          tmp___287 = tmp___281;
        }
#line 794
        tmp___335 = tmp___287;
      } else {
#line 794
        if (sizeof(nbytes) == sizeof(long )) {
#line 794
          if (sizeof(n * item_size) < sizeof(long )) {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___57;
                } else {
#line 794
                  goto _L___59;
                }
              } else
              _L___59: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___57;
                } else {
#line 794
                  goto _L___58;
                }
              } else {
#line 794
                goto _L___58;
              }
            } else {
              _L___58: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___294 = 0;
                  } else {
#line 794
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___295 = tmp___294;
                }
#line 794
                tmp___298 = tmp___295;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___297 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___297 = tmp___296;
                }
#line 794
                tmp___298 = tmp___297;
              }
#line 794
              if (tmp___298) {
#line 794
                goto _L___57;
              } else
#line 794
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___57;
              } else
#line 794
              if (9223372036854775807L < n * item_size) {
                _L___57: /* CIL Label */ 
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___293 = 1;
              } else {
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___293 = 0;
              }
            }
#line 794
            tmp___310 = tmp___293;
          } else {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___60;
                } else {
#line 794
                  goto _L___62;
                }
              } else
              _L___62: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___60;
                } else {
#line 794
                  goto _L___61;
                }
              } else {
#line 794
                goto _L___61;
              }
            } else {
              _L___61: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___305 = 0;
                  } else {
#line 794
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___306 = tmp___305;
                }
#line 794
                tmp___309 = tmp___306;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___308 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___308 = tmp___307;
                }
#line 794
                tmp___309 = tmp___308;
              }
#line 794
              if (tmp___309) {
#line 794
                goto _L___60;
              } else
#line 794
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___60;
              } else
#line 794
              if (9223372036854775807L < n * item_size) {
                _L___60: /* CIL Label */ 
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___304 = 1;
              } else {
#line 794
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 794
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 794
                tmp___304 = 0;
              }
            }
#line 794
            tmp___310 = tmp___304;
          }
#line 794
          tmp___334 = tmp___310;
        } else {
#line 794
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 794
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 794
              if ((long long )n < 0LL) {
#line 794
                if (0LL < (long long )item_size) {
#line 794
                  goto _L___63;
                } else {
#line 794
                  goto _L___65;
                }
              } else
              _L___65: /* CIL Label */ 
#line 794
              if ((long long )item_size < 0LL) {
#line 794
                if (0LL < (long long )n) {
#line 794
                  goto _L___63;
                } else {
#line 794
                  goto _L___64;
                }
              } else {
#line 794
                goto _L___64;
              }
            } else {
              _L___64: /* CIL Label */ 
#line 794
              if ((long long )item_size < 0LL) {
#line 794
                if ((long long )n < 0LL) {
#line 794
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 794
                  if ((long long )item_size == -1LL) {
#line 794
                    tmp___317 = 0;
                  } else {
#line 794
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 794
                  tmp___318 = tmp___317;
                }
#line 794
                tmp___321 = tmp___318;
              } else {
#line 794
                if ((long long )item_size == 0LL) {
#line 794
                  tmp___320 = 0;
                } else {
#line 794
                  if ((long long )n < 0LL) {
#line 794
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 794
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 794
                  tmp___320 = tmp___319;
                }
#line 794
                tmp___321 = tmp___320;
              }
#line 794
              if (tmp___321) {
#line 794
                goto _L___63;
              } else
#line 794
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___63;
              } else
#line 794
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
                _L___63: /* CIL Label */ 
#line 794
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___316 = 1;
              } else {
#line 794
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___316 = 0;
              }
            }
#line 794
            tmp___333 = tmp___316;
          } else {
#line 794
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 794
              if (n < 0L) {
#line 794
                if (0L < item_size) {
#line 794
                  goto _L___66;
                } else {
#line 794
                  goto _L___68;
                }
              } else
              _L___68: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (0L < n) {
#line 794
                  goto _L___66;
                } else {
#line 794
                  goto _L___67;
                }
              } else {
#line 794
                goto _L___67;
              }
            } else {
              _L___67: /* CIL Label */ 
#line 794
              if (item_size < 0L) {
#line 794
                if (n < 0L) {
#line 794
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 794
                  if (item_size == -1L) {
#line 794
                    tmp___328 = 0;
                  } else {
#line 794
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___329 = tmp___328;
                }
#line 794
                tmp___332 = tmp___329;
              } else {
#line 794
                if (item_size == 0L) {
#line 794
                  tmp___331 = 0;
                } else {
#line 794
                  if (n < 0L) {
#line 794
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 794
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 794
                  tmp___331 = tmp___330;
                }
#line 794
                tmp___332 = tmp___331;
              }
#line 794
              if (tmp___332) {
#line 794
                goto _L___66;
              } else
#line 794
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 794
                goto _L___66;
              } else
#line 794
              if (9223372036854775807LL < (long long )(n * item_size)) {
                _L___66: /* CIL Label */ 
#line 794
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___327 = 1;
              } else {
#line 794
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 794
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 794
                tmp___327 = 0;
              }
            }
#line 794
            tmp___333 = tmp___327;
          }
#line 794
          tmp___334 = tmp___333;
        }
#line 794
        tmp___335 = tmp___334;
      }
#line 794
      tmp___336 = tmp___335;
    }
#line 794
    tmp___337 = tmp___336;
  }
#line 794
  if (tmp___337) {
#line 794
    tmp___218 = 9223372036854775807UL;
  } else
#line 794
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 794
    tmp___218 = 9223372036854775807UL;
  } else {
#line 794
    if (nbytes < 128L) {
#line 794
      tmp___217 = 128;
    } else {
#line 794
      tmp___217 = 0;
    }
#line 794
    tmp___218 = (unsigned long )tmp___217;
  }
#line 794
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 798
  if (adjusted_nbytes) {
#line 800
    n = adjusted_nbytes / item_size;
#line 801
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 804
  if (! pa) {
#line 805
    *nitems = (ptrdiff_t )0;
  }
#line 806
  if (n - n0 < nitems_incr_min) {
#line 806
    if (sizeof(n) == sizeof(signed char )) {
#line 806
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 806
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 806
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 806
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 806
          tmp___346 = tmp___343;
        } else {
#line 806
          if ((int )((signed char )n0) < 0) {
#line 806
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 806
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 806
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 806
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 806
            tmp___345 = tmp___344;
          }
#line 806
          tmp___346 = tmp___345;
        }
#line 806
        if (tmp___346) {
#line 806
          goto _L___69;
        } else
#line 806
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 806
          goto _L___69;
        } else
#line 806
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
          _L___69: /* CIL Label */ 
#line 806
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 806
          tmp___342 = 1;
        } else {
#line 806
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 806
          tmp___342 = 0;
        }
#line 806
        tmp___356 = tmp___342;
      } else {
#line 806
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
          if (nitems_incr_min < 0L) {
#line 806
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 806
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 806
          tmp___355 = tmp___352;
        } else {
#line 806
          if (n0 < 0L) {
#line 806
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 806
            if (nitems_incr_min < 0L) {
#line 806
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 806
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 806
            tmp___354 = tmp___353;
          }
#line 806
          tmp___355 = tmp___354;
        }
#line 806
        if (tmp___355) {
#line 806
          goto _L___70;
        } else
#line 806
        if (n0 + nitems_incr_min < -128L) {
#line 806
          goto _L___70;
        } else
#line 806
        if (127L < n0 + nitems_incr_min) {
          _L___70: /* CIL Label */ 
#line 806
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 806
          tmp___351 = 1;
        } else {
#line 806
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 806
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 806
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 806
          tmp___351 = 0;
        }
#line 806
        tmp___356 = tmp___351;
      }
#line 806
      tmp___436 = tmp___356;
    } else {
#line 806
      if (sizeof(n) == sizeof(short )) {
#line 806
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 806
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
            if ((int )((short )nitems_incr_min) < 0) {
#line 806
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 806
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 806
            tmp___365 = tmp___362;
          } else {
#line 806
            if ((int )((short )n0) < 0) {
#line 806
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 806
              if ((int )((short )nitems_incr_min) < 0) {
#line 806
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 806
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 806
              tmp___364 = tmp___363;
            }
#line 806
            tmp___365 = tmp___364;
          }
#line 806
          if (tmp___365) {
#line 806
            goto _L___71;
          } else
#line 806
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 806
            goto _L___71;
          } else
#line 806
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
            _L___71: /* CIL Label */ 
#line 806
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 806
            tmp___361 = 1;
          } else {
#line 806
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 806
            tmp___361 = 0;
          }
#line 806
          tmp___375 = tmp___361;
        } else {
#line 806
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
            if (nitems_incr_min < 0L) {
#line 806
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 806
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 806
            tmp___374 = tmp___371;
          } else {
#line 806
            if (n0 < 0L) {
#line 806
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 806
              if (nitems_incr_min < 0L) {
#line 806
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 806
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 806
              tmp___373 = tmp___372;
            }
#line 806
            tmp___374 = tmp___373;
          }
#line 806
          if (tmp___374) {
#line 806
            goto _L___72;
          } else
#line 806
          if (n0 + nitems_incr_min < -32768L) {
#line 806
            goto _L___72;
          } else
#line 806
          if (32767L < n0 + nitems_incr_min) {
            _L___72: /* CIL Label */ 
#line 806
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 806
            tmp___370 = 1;
          } else {
#line 806
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 806
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 806
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 806
            tmp___370 = 0;
          }
#line 806
          tmp___375 = tmp___370;
        }
#line 806
        tmp___435 = tmp___375;
      } else {
#line 806
        if (sizeof(n) == sizeof(int )) {
#line 806
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 806
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 806
              if ((int )nitems_incr_min < 0) {
#line 806
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 806
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 806
              tmp___384 = tmp___381;
            } else {
#line 806
              if ((int )n0 < 0) {
#line 806
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 806
                if ((int )nitems_incr_min < 0) {
#line 806
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 806
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 806
                tmp___383 = tmp___382;
              }
#line 806
              tmp___384 = tmp___383;
            }
#line 806
            if (tmp___384) {
#line 806
              goto _L___73;
            } else
#line 806
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 806
              goto _L___73;
            } else
#line 806
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
              _L___73: /* CIL Label */ 
#line 806
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___380 = 1;
            } else {
#line 806
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___380 = 0;
            }
#line 806
            tmp___394 = tmp___380;
          } else {
#line 806
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
              if (nitems_incr_min < 0L) {
#line 806
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 806
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 806
              tmp___393 = tmp___390;
            } else {
#line 806
              if (n0 < 0L) {
#line 806
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 806
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 806
                tmp___392 = tmp___391;
              }
#line 806
              tmp___393 = tmp___392;
            }
#line 806
            if (tmp___393) {
#line 806
              goto _L___74;
            } else
#line 806
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 806
              goto _L___74;
            } else
#line 806
            if (2147483647L < n0 + nitems_incr_min) {
              _L___74: /* CIL Label */ 
#line 806
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___389 = 1;
            } else {
#line 806
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 806
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 806
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 806
              tmp___389 = 0;
            }
#line 806
            tmp___394 = tmp___389;
          }
#line 806
          tmp___434 = tmp___394;
        } else {
#line 806
          if (sizeof(n) == sizeof(long )) {
#line 806
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___403 = tmp___400;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___402 = tmp___401;
                }
#line 806
                tmp___403 = tmp___402;
              }
#line 806
              if (tmp___403) {
#line 806
                goto _L___75;
              } else
#line 806
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___75;
              } else
#line 806
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___75: /* CIL Label */ 
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___399 = 1;
              } else {
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___399 = 0;
              }
#line 806
              tmp___413 = tmp___399;
            } else {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___412 = tmp___409;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___411 = tmp___410;
                }
#line 806
                tmp___412 = tmp___411;
              }
#line 806
              if (tmp___412) {
#line 806
                goto _L___76;
              } else
#line 806
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___76;
              } else
#line 806
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___76: /* CIL Label */ 
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___408 = 1;
              } else {
#line 806
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 806
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 806
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 806
                tmp___408 = 0;
              }
#line 806
              tmp___413 = tmp___408;
            }
#line 806
            tmp___433 = tmp___413;
          } else {
#line 806
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 806
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 806
                if ((long long )nitems_incr_min < 0LL) {
#line 806
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 806
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 806
                tmp___422 = tmp___419;
              } else {
#line 806
                if ((long long )n0 < 0LL) {
#line 806
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 806
                  if ((long long )nitems_incr_min < 0LL) {
#line 806
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 806
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 806
                  tmp___421 = tmp___420;
                }
#line 806
                tmp___422 = tmp___421;
              }
#line 806
              if (tmp___422) {
#line 806
                goto _L___77;
              } else
#line 806
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___77;
              } else
#line 806
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
                _L___77: /* CIL Label */ 
#line 806
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___418 = 1;
              } else {
#line 806
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___418 = 0;
              }
#line 806
              tmp___432 = tmp___418;
            } else {
#line 806
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 806
                if (nitems_incr_min < 0L) {
#line 806
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 806
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 806
                tmp___431 = tmp___428;
              } else {
#line 806
                if (n0 < 0L) {
#line 806
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 806
                  if (nitems_incr_min < 0L) {
#line 806
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 806
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 806
                  tmp___430 = tmp___429;
                }
#line 806
                tmp___431 = tmp___430;
              }
#line 806
              if (tmp___431) {
#line 806
                goto _L___78;
              } else
#line 806
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                goto _L___78;
              } else
#line 806
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
                _L___78: /* CIL Label */ 
#line 806
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___427 = 1;
              } else {
#line 806
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 806
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 806
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 806
                tmp___427 = 0;
              }
#line 806
              tmp___432 = tmp___427;
            }
#line 806
            tmp___433 = tmp___432;
          }
#line 806
          tmp___434 = tmp___433;
        }
#line 806
        tmp___435 = tmp___434;
      }
#line 806
      tmp___436 = tmp___435;
    }
#line 806
    if (tmp___436) {
      {
#line 810
      xalloc_die();
      }
    } else
#line 806
    if (0L <= nitems_max) {
#line 806
      if (nitems_max < n) {
        {
#line 810
        xalloc_die();
        }
      } else {
#line 806
        goto _L___109;
      }
    } else {
      _L___109: /* CIL Label */ 
#line 806
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 806
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 806
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
            if ((int )((signed char )n) < 0) {
#line 806
              if (0 < (int )((signed char )item_size)) {
#line 806
                goto _L___79;
              } else {
#line 806
                goto _L___81;
              }
            } else
            _L___81: /* CIL Label */ 
#line 806
            if ((int )((signed char )item_size) < 0) {
#line 806
              if (0 < (int )((signed char )n)) {
#line 806
                goto _L___79;
              } else {
#line 806
                goto _L___80;
              }
            } else {
#line 806
              goto _L___80;
            }
          } else {
            _L___80: /* CIL Label */ 
#line 806
            if ((int )((signed char )item_size) < 0) {
#line 806
              if ((int )((signed char )n) < 0) {
#line 806
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 806
                if ((int )((signed char )item_size) == -1) {
#line 806
                  tmp___443 = 0;
                } else {
#line 806
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 806
                tmp___444 = tmp___443;
              }
#line 806
              tmp___447 = tmp___444;
            } else {
#line 806
              if ((int )((signed char )item_size) == 0) {
#line 806
                tmp___446 = 0;
              } else {
#line 806
                if ((int )((signed char )n) < 0) {
#line 806
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 806
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 806
                tmp___446 = tmp___445;
              }
#line 806
              tmp___447 = tmp___446;
            }
#line 806
            if (tmp___447) {
#line 806
              goto _L___79;
            } else
#line 806
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 806
              goto _L___79;
            } else
#line 806
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
              _L___79: /* CIL Label */ 
#line 806
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 806
              tmp___442 = 1;
            } else {
#line 806
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 806
              tmp___442 = 0;
            }
          }
#line 806
          tmp___459 = tmp___442;
        } else {
#line 806
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
            if (n < 0L) {
#line 806
              if (0L < item_size) {
#line 806
                goto _L___82;
              } else {
#line 806
                goto _L___84;
              }
            } else
            _L___84: /* CIL Label */ 
#line 806
            if (item_size < 0L) {
#line 806
              if (0L < n) {
#line 806
                goto _L___82;
              } else {
#line 806
                goto _L___83;
              }
            } else {
#line 806
              goto _L___83;
            }
          } else {
            _L___83: /* CIL Label */ 
#line 806
            if (item_size < 0L) {
#line 806
              if (n < 0L) {
#line 806
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 806
                if (item_size == -1L) {
#line 806
                  tmp___454 = 0;
                } else {
#line 806
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 806
                tmp___455 = tmp___454;
              }
#line 806
              tmp___458 = tmp___455;
            } else {
#line 806
              if (item_size == 0L) {
#line 806
                tmp___457 = 0;
              } else {
#line 806
                if (n < 0L) {
#line 806
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 806
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 806
                tmp___457 = tmp___456;
              }
#line 806
              tmp___458 = tmp___457;
            }
#line 806
            if (tmp___458) {
#line 806
              goto _L___82;
            } else
#line 806
            if (n * item_size < -128L) {
#line 806
              goto _L___82;
            } else
#line 806
            if (127L < n * item_size) {
              _L___82: /* CIL Label */ 
#line 806
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 806
              tmp___453 = 1;
            } else {
#line 806
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 806
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 806
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 806
              tmp___453 = 0;
            }
          }
#line 806
          tmp___459 = tmp___453;
        }
#line 806
        tmp___555 = tmp___459;
      } else {
#line 806
        if (sizeof(nbytes) == sizeof(short )) {
#line 806
          if (sizeof(n * item_size) < sizeof(short )) {
#line 806
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
              if ((int )((short )n) < 0) {
#line 806
                if (0 < (int )((short )item_size)) {
#line 806
                  goto _L___85;
                } else {
#line 806
                  goto _L___87;
                }
              } else
              _L___87: /* CIL Label */ 
#line 806
              if ((int )((short )item_size) < 0) {
#line 806
                if (0 < (int )((short )n)) {
#line 806
                  goto _L___85;
                } else {
#line 806
                  goto _L___86;
                }
              } else {
#line 806
                goto _L___86;
              }
            } else {
              _L___86: /* CIL Label */ 
#line 806
              if ((int )((short )item_size) < 0) {
#line 806
                if ((int )((short )n) < 0) {
#line 806
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 806
                  if ((int )((short )item_size) == -1) {
#line 806
                    tmp___466 = 0;
                  } else {
#line 806
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 806
                  tmp___467 = tmp___466;
                }
#line 806
                tmp___470 = tmp___467;
              } else {
#line 806
                if ((int )((short )item_size) == 0) {
#line 806
                  tmp___469 = 0;
                } else {
#line 806
                  if ((int )((short )n) < 0) {
#line 806
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 806
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 806
                  tmp___469 = tmp___468;
                }
#line 806
                tmp___470 = tmp___469;
              }
#line 806
              if (tmp___470) {
#line 806
                goto _L___85;
              } else
#line 806
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 806
                goto _L___85;
              } else
#line 806
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
                _L___85: /* CIL Label */ 
#line 806
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 806
                tmp___465 = 1;
              } else {
#line 806
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 806
                tmp___465 = 0;
              }
            }
#line 806
            tmp___482 = tmp___465;
          } else {
#line 806
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
              if (n < 0L) {
#line 806
                if (0L < item_size) {
#line 806
                  goto _L___88;
                } else {
#line 806
                  goto _L___90;
                }
              } else
              _L___90: /* CIL Label */ 
#line 806
              if (item_size < 0L) {
#line 806
                if (0L < n) {
#line 806
                  goto _L___88;
                } else {
#line 806
                  goto _L___89;
                }
              } else {
#line 806
                goto _L___89;
              }
            } else {
              _L___89: /* CIL Label */ 
#line 806
              if (item_size < 0L) {
#line 806
                if (n < 0L) {
#line 806
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 806
                  if (item_size == -1L) {
#line 806
                    tmp___477 = 0;
                  } else {
#line 806
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 806
                  tmp___478 = tmp___477;
                }
#line 806
                tmp___481 = tmp___478;
              } else {
#line 806
                if (item_size == 0L) {
#line 806
                  tmp___480 = 0;
                } else {
#line 806
                  if (n < 0L) {
#line 806
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 806
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 806
                  tmp___480 = tmp___479;
                }
#line 806
                tmp___481 = tmp___480;
              }
#line 806
              if (tmp___481) {
#line 806
                goto _L___88;
              } else
#line 806
              if (n * item_size < -32768L) {
#line 806
                goto _L___88;
              } else
#line 806
              if (32767L < n * item_size) {
                _L___88: /* CIL Label */ 
#line 806
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 806
                tmp___476 = 1;
              } else {
#line 806
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 806
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 806
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 806
                tmp___476 = 0;
              }
            }
#line 806
            tmp___482 = tmp___476;
          }
#line 806
          tmp___554 = tmp___482;
        } else {
#line 806
          if (sizeof(nbytes) == sizeof(int )) {
#line 806
            if (sizeof(n * item_size) < sizeof(int )) {
#line 806
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 806
                if ((int )n < 0) {
#line 806
                  if (0 < (int )item_size) {
#line 806
                    goto _L___91;
                  } else {
#line 806
                    goto _L___93;
                  }
                } else
                _L___93: /* CIL Label */ 
#line 806
                if ((int )item_size < 0) {
#line 806
                  if (0 < (int )n) {
#line 806
                    goto _L___91;
                  } else {
#line 806
                    goto _L___92;
                  }
                } else {
#line 806
                  goto _L___92;
                }
              } else {
                _L___92: /* CIL Label */ 
#line 806
                if ((int )item_size < 0) {
#line 806
                  if ((int )n < 0) {
#line 806
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 806
                    if ((int )item_size == -1) {
#line 806
                      tmp___489 = 0;
                    } else {
#line 806
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 806
                    tmp___490 = tmp___489;
                  }
#line 806
                  tmp___493 = tmp___490;
                } else {
#line 806
                  if ((int )item_size == 0) {
#line 806
                    tmp___492 = 0;
                  } else {
#line 806
                    if ((int )n < 0) {
#line 806
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 806
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 806
                    tmp___492 = tmp___491;
                  }
#line 806
                  tmp___493 = tmp___492;
                }
#line 806
                if (tmp___493) {
#line 806
                  goto _L___91;
                } else
#line 806
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 806
                  goto _L___91;
                } else
#line 806
                if (2147483647 < (int )n * (int )item_size) {
                  _L___91: /* CIL Label */ 
#line 806
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___488 = 1;
                } else {
#line 806
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___488 = 0;
                }
              }
#line 806
              tmp___505 = tmp___488;
            } else {
#line 806
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                if (n < 0L) {
#line 806
                  if (0L < item_size) {
#line 806
                    goto _L___94;
                  } else {
#line 806
                    goto _L___96;
                  }
                } else
                _L___96: /* CIL Label */ 
#line 806
                if (item_size < 0L) {
#line 806
                  if (0L < n) {
#line 806
                    goto _L___94;
                  } else {
#line 806
                    goto _L___95;
                  }
                } else {
#line 806
                  goto _L___95;
                }
              } else {
                _L___95: /* CIL Label */ 
#line 806
                if (item_size < 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 806
                    if (item_size == -1L) {
#line 806
                      tmp___500 = 0;
                    } else {
#line 806
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 806
                    tmp___501 = tmp___500;
                  }
#line 806
                  tmp___504 = tmp___501;
                } else {
#line 806
                  if (item_size == 0L) {
#line 806
                    tmp___503 = 0;
                  } else {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 806
                    tmp___503 = tmp___502;
                  }
#line 806
                  tmp___504 = tmp___503;
                }
#line 806
                if (tmp___504) {
#line 806
                  goto _L___94;
                } else
#line 806
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 806
                  goto _L___94;
                } else
#line 806
                if (2147483647L < n * item_size) {
                  _L___94: /* CIL Label */ 
#line 806
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___499 = 1;
                } else {
#line 806
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 806
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 806
                  tmp___499 = 0;
                }
              }
#line 806
              tmp___505 = tmp___499;
            }
#line 806
            tmp___553 = tmp___505;
          } else {
#line 806
            if (sizeof(nbytes) == sizeof(long )) {
#line 806
              if (sizeof(n * item_size) < sizeof(long )) {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___97;
                    } else {
#line 806
                      goto _L___99;
                    }
                  } else
                  _L___99: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___97;
                    } else {
#line 806
                      goto _L___98;
                    }
                  } else {
#line 806
                    goto _L___98;
                  }
                } else {
                  _L___98: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___512 = 0;
                      } else {
#line 806
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___513 = tmp___512;
                    }
#line 806
                    tmp___516 = tmp___513;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___515 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___515 = tmp___514;
                    }
#line 806
                    tmp___516 = tmp___515;
                  }
#line 806
                  if (tmp___516) {
#line 806
                    goto _L___97;
                  } else
#line 806
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___97;
                  } else
#line 806
                  if (9223372036854775807L < n * item_size) {
                    _L___97: /* CIL Label */ 
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___511 = 1;
                  } else {
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___511 = 0;
                  }
                }
#line 806
                tmp___528 = tmp___511;
              } else {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___100;
                    } else {
#line 806
                      goto _L___102;
                    }
                  } else
                  _L___102: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___100;
                    } else {
#line 806
                      goto _L___101;
                    }
                  } else {
#line 806
                    goto _L___101;
                  }
                } else {
                  _L___101: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___523 = 0;
                      } else {
#line 806
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___524 = tmp___523;
                    }
#line 806
                    tmp___527 = tmp___524;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___526 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___526 = tmp___525;
                    }
#line 806
                    tmp___527 = tmp___526;
                  }
#line 806
                  if (tmp___527) {
#line 806
                    goto _L___100;
                  } else
#line 806
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___100;
                  } else
#line 806
                  if (9223372036854775807L < n * item_size) {
                    _L___100: /* CIL Label */ 
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___522 = 1;
                  } else {
#line 806
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 806
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 806
                    tmp___522 = 0;
                  }
                }
#line 806
                tmp___528 = tmp___522;
              }
#line 806
              tmp___552 = tmp___528;
            } else {
#line 806
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 806
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 806
                  if ((long long )n < 0LL) {
#line 806
                    if (0LL < (long long )item_size) {
#line 806
                      goto _L___103;
                    } else {
#line 806
                      goto _L___105;
                    }
                  } else
                  _L___105: /* CIL Label */ 
#line 806
                  if ((long long )item_size < 0LL) {
#line 806
                    if (0LL < (long long )n) {
#line 806
                      goto _L___103;
                    } else {
#line 806
                      goto _L___104;
                    }
                  } else {
#line 806
                    goto _L___104;
                  }
                } else {
                  _L___104: /* CIL Label */ 
#line 806
                  if ((long long )item_size < 0LL) {
#line 806
                    if ((long long )n < 0LL) {
#line 806
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 806
                      if ((long long )item_size == -1LL) {
#line 806
                        tmp___535 = 0;
                      } else {
#line 806
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 806
                      tmp___536 = tmp___535;
                    }
#line 806
                    tmp___539 = tmp___536;
                  } else {
#line 806
                    if ((long long )item_size == 0LL) {
#line 806
                      tmp___538 = 0;
                    } else {
#line 806
                      if ((long long )n < 0LL) {
#line 806
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 806
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 806
                      tmp___538 = tmp___537;
                    }
#line 806
                    tmp___539 = tmp___538;
                  }
#line 806
                  if (tmp___539) {
#line 806
                    goto _L___103;
                  } else
#line 806
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___103;
                  } else
#line 806
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
                    _L___103: /* CIL Label */ 
#line 806
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___534 = 1;
                  } else {
#line 806
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___534 = 0;
                  }
                }
#line 806
                tmp___551 = tmp___534;
              } else {
#line 806
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 806
                  if (n < 0L) {
#line 806
                    if (0L < item_size) {
#line 806
                      goto _L___106;
                    } else {
#line 806
                      goto _L___108;
                    }
                  } else
                  _L___108: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (0L < n) {
#line 806
                      goto _L___106;
                    } else {
#line 806
                      goto _L___107;
                    }
                  } else {
#line 806
                    goto _L___107;
                  }
                } else {
                  _L___107: /* CIL Label */ 
#line 806
                  if (item_size < 0L) {
#line 806
                    if (n < 0L) {
#line 806
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 806
                      if (item_size == -1L) {
#line 806
                        tmp___546 = 0;
                      } else {
#line 806
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___547 = tmp___546;
                    }
#line 806
                    tmp___550 = tmp___547;
                  } else {
#line 806
                    if (item_size == 0L) {
#line 806
                      tmp___549 = 0;
                    } else {
#line 806
                      if (n < 0L) {
#line 806
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 806
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 806
                      tmp___549 = tmp___548;
                    }
#line 806
                    tmp___550 = tmp___549;
                  }
#line 806
                  if (tmp___550) {
#line 806
                    goto _L___106;
                  } else
#line 806
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 806
                    goto _L___106;
                  } else
#line 806
                  if (9223372036854775807LL < (long long )(n * item_size)) {
                    _L___106: /* CIL Label */ 
#line 806
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___545 = 1;
                  } else {
#line 806
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 806
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 806
                    tmp___545 = 0;
                  }
                }
#line 806
                tmp___551 = tmp___545;
              }
#line 806
              tmp___552 = tmp___551;
            }
#line 806
            tmp___553 = tmp___552;
          }
#line 806
          tmp___554 = tmp___553;
        }
#line 806
        tmp___555 = tmp___554;
      }
#line 806
      if (tmp___555) {
        {
#line 810
        xalloc_die();
        }
      }
    }
  }
  {
#line 811
  pa = xrealloc(pa, (size_t )nbytes);
#line 812
  *nitems = n;
  }
#line 813
  return (pa);
}
}
#line 825 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void *maybe_realloc___0(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                               ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 829
  if (i < *nitems) {
#line 830
    return (pa);
  }
  {
#line 831
  tmp = xpalloc___0(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 831
  return (tmp);
}
}
#line 835 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static ptrdiff_t charclass_index___0(struct dfa *d , charclass *s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 840
  i = (ptrdiff_t )0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < d->cindex)) {
#line 840
      goto while_break;
    }
    {
#line 841
    tmp = equal___0((charclass const   *)s, (charclass const   *)(d->charclasses + i));
    }
#line 841
    if (tmp) {
#line 842
      return (i);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  tmp___0 = maybe_realloc___0((void *)d->charclasses, d->cindex, & d->calloc, (ptrdiff_t )(TOKEN_MAX___0 - 275L),
                              (ptrdiff_t )sizeof(*(d->charclasses)));
#line 843
  d->charclasses = (charclass *)tmp___0;
#line 845
  (d->cindex) ++;
#line 846
  *(d->charclasses + i) = *s;
  }
#line 847
  return (i);
}
}
#line 850 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool unibyte_word_constituent___0(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 853
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 853
    tmp = __ctype_b_loc();
    }
#line 853
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 853
      tmp___0 = 1;
    } else
#line 853
    if ((int )c == 95) {
#line 853
      tmp___0 = 1;
    } else {
#line 853
      tmp___0 = 0;
    }
  } else {
#line 853
    tmp___0 = 0;
  }
#line 853
  return ((_Bool )tmp___0);
}
}
#line 856 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int char_context___0(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 859
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 859
    if (! dfa->syntax.anchor) {
#line 860
      return (4);
    }
  }
  {
#line 861
  tmp = unibyte_word_constituent___0(dfa, c);
  }
#line 861
  if (tmp) {
#line 862
    return (2);
  }
#line 863
  return (1);
}
}
#line 871 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool setbit_wc___0(wint_t wc , charclass *c ) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 874
  tmp = wctob(wc);
#line 874
  b = tmp;
  }
#line 875
  if (b < 0) {
#line 876
    return ((_Bool)0);
  }
  {
#line 878
  setbit___0((unsigned int )b, c);
  }
#line 879
  return ((_Bool)1);
}
}
#line 884 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void setbit_case_fold_c___0(int b , charclass *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 887
  tmp = toupper(b);
#line 887
  ub = tmp;
#line 888
  i = 0;
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! (i < 256)) {
#line 888
      goto while_break;
    }
    {
#line 889
    tmp___0 = toupper(i);
    }
#line 889
    if (tmp___0 == ub) {
      {
#line 890
      setbit___0((unsigned int )i, c);
      }
    }
#line 888
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  return;
}
}
#line 895 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool using_simple_locale___0(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 914
  if (multibyte) {
#line 915
    return ((_Bool)0);
  } else {
    {
#line 920
    tmp = setlocale(6, (char const   *)((void *)0));
#line 920
    loc = (char const   *)tmp;
    }
#line 921
    if (! loc) {
#line 921
      tmp___2 = 1;
    } else {
      {
#line 921
      tmp___0 = streq___0(loc, "C");
      }
#line 921
      if (tmp___0) {
#line 921
        tmp___2 = 1;
      } else {
        {
#line 921
        tmp___1 = streq___0(loc, "POSIX");
        }
#line 921
        if (tmp___1) {
#line 921
          tmp___2 = 1;
        } else {
#line 921
          tmp___2 = 0;
        }
      }
    }
#line 921
    return ((_Bool )tmp___2);
  }
}
}
#line 931 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int fetch_wc___0(struct dfa *dfa ) 
{ 
  size_t nbytes ;
  size_t tmp ;
  int c ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 934
  tmp = mbs_to_wchar___0(& dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left, dfa);
#line 934
  nbytes = tmp;
#line 936
  dfa->lex.cur_mb_len = (int )nbytes;
  }
#line 937
  if (nbytes == 1UL) {
    {
#line 937
    tmp___0 = to_uchar___1((char )*(dfa->lex.ptr + 0));
#line 937
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 937
    tmp___1 = -1;
  }
#line 937
  c = tmp___1;
#line 938
  dfa->lex.ptr += nbytes;
#line 939
  dfa->lex.left -= nbytes;
#line 940
  return (c);
}
}
#line 945 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int bracket_fetch_wc___0(struct dfa *dfa ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 948
  if (! dfa->lex.left) {
    {
#line 949
    tmp = gettext("unbalanced [");
#line 949
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 950
  tmp___0 = fetch_wc___0(dfa);
  }
#line 950
  return (tmp___0);
}
}
#line 966 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static struct dfa_ctype  const  prednames___0[13]  = 
#line 966
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 982 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred___0(char const   *str ) 
{ 
  unsigned int i ;
  _Bool tmp ;

  {
#line 985
  i = 0U;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! prednames___0[i].name) {
#line 985
      goto while_break;
    }
    {
#line 986
    tmp = streq___0(str, (char const   *)prednames___0[i].name);
    }
#line 986
    if (tmp) {
#line 987
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames___0[i]));
    }
#line 985
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 988
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 993 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static token parse_bracket_exp___0(struct dfa *dfa ) 
{ 
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  charclass ccl ;
  int c ;
  int tmp ;
  _Bool invert ;
  wint_t wc ;
  int c1 ;
  wint_t wc1 ;
  char str[33] ;
  size_t len ;
  size_t tmp___0 ;
  char const   *class ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___6 ;
  char *tmp___7 ;
  int c2 ;
  int tmp___8 ;
  int c2___0 ;
  int tmp___9 ;
  wint_t wc2 ;
  int ci ;
  int uc ;
  int tmp___10 ;
  int uc2 ;
  int tmp___11 ;
  int uci ;
  int tmp___12 ;
  int tmp___13 ;
  wchar_t folded[33] ;
  unsigned int n ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int i ;
  void *tmp___16 ;
  ptrdiff_t tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  ptrdiff_t tmp___21 ;
  _Bool tmp___22 ;
  ptrdiff_t tmp___24 ;

  {
  {
#line 998
  known_bracket_exp = (_Bool)1;
#line 1007
  dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1009
  zeroset___0(& ccl);
#line 1010
  tmp = bracket_fetch_wc___0(dfa);
#line 1010
  c = tmp;
#line 1011
  invert = (_Bool )(c == 94);
  }
#line 1012
  if (invert) {
    {
#line 1014
    c = bracket_fetch_wc___0(dfa);
#line 1015
    invert = (_Bool)1;
#line 1016
    known_bracket_exp = dfa->simple_locale;
    }
  }
#line 1018
  wc = dfa->lex.wctok;
#line 1021
  colon_warning_state = c == 58;
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1024
    c1 = 256;
#line 1025
    colon_warning_state &= -3;
#line 1031
    if (c == 91) {
      {
#line 1033
      c1 = bracket_fetch_wc___0(dfa);
#line 1034
      wc1 = dfa->lex.wctok;
      }
#line 1036
      if (c1 == 58) {
#line 1036
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1036
          goto _L___0;
        } else {
#line 1036
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1036
      if (c1 == 46) {
#line 1036
        goto _L___0;
      } else
#line 1036
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1041
        len = (size_t )0;
        {
#line 1042
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1044
          c = bracket_fetch_wc___0(dfa);
          }
#line 1045
          if (dfa->lex.left == 0UL) {
#line 1047
            goto while_break___0;
          } else
#line 1045
          if (c == c1) {
#line 1045
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1047
              goto while_break___0;
            }
          }
#line 1048
          if (len < 32UL) {
#line 1049
            tmp___0 = len;
#line 1049
            len ++;
#line 1049
            str[tmp___0] = (char )c;
          } else {
#line 1052
            str[0] = (char )'\000';
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1054
        str[len] = (char )'\000';
#line 1057
        c = bracket_fetch_wc___0(dfa);
#line 1058
        wc = dfa->lex.wctok;
        }
#line 1059
        if (c1 == 58) {
#line 1065
          if (dfa->syntax.case_fold) {
            {
#line 1065
            tmp___4 = streq___0((char const   *)(str), "upper");
            }
#line 1065
            if (tmp___4) {
#line 1065
              tmp___3 = "alpha";
            } else {
              {
#line 1065
              tmp___5 = streq___0((char const   *)(str), "lower");
              }
#line 1065
              if (tmp___5) {
#line 1065
                tmp___3 = "alpha";
              } else {
#line 1065
                tmp___3 = (char const   *)(str);
              }
            }
          } else {
#line 1065
            tmp___3 = (char const   *)(str);
          }
          {
#line 1065
          class = tmp___3;
#line 1069
          tmp___6 = find_pred___0(class);
#line 1069
          pred = (struct dfa_ctype  const  *)tmp___6;
          }
#line 1070
          if (! pred) {
            {
#line 1071
            tmp___7 = gettext("invalid character class");
#line 1071
            dfaerror((char const   *)tmp___7);
            }
          }
#line 1073
          if (dfa->localeinfo.multibyte) {
#line 1073
            if (! pred->single_byte_only) {
#line 1074
              known_bracket_exp = (_Bool)0;
            } else {
#line 1073
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1076
            c2 = 0;
            {
#line 1076
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1076
              if (! (c2 < 256)) {
#line 1076
                goto while_break___1;
              }
              {
#line 1077
              tmp___8 = (*(pred->func))(c2);
              }
#line 1077
              if (tmp___8) {
                {
#line 1078
                setbit___0((unsigned int )c2, & ccl);
                }
              }
#line 1076
              c2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1081
          known_bracket_exp = (_Bool)0;
        }
        {
#line 1083
        colon_warning_state |= 8;
#line 1086
        c1 = bracket_fetch_wc___0(dfa);
#line 1087
        wc1 = dfa->lex.wctok;
        }
#line 1088
        goto __Cont;
      }
    }
#line 1095
    if (c == 92) {
#line 1095
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1098
        c = bracket_fetch_wc___0(dfa);
#line 1099
        wc = dfa->lex.wctok;
        }
      }
    }
#line 1102
    if (c1 == 256) {
      {
#line 1104
      c1 = bracket_fetch_wc___0(dfa);
#line 1105
      wc1 = dfa->lex.wctok;
      }
    }
#line 1108
    if (c1 == 45) {
      {
#line 1111
      tmp___9 = bracket_fetch_wc___0(dfa);
#line 1111
      c2___0 = tmp___9;
#line 1112
      wc2 = dfa->lex.wctok;
      }
#line 1117
      if (c2___0 == 91) {
#line 1117
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1119
          known_bracket_exp = (_Bool)0;
#line 1120
          c2___0 = ']';
        }
      }
#line 1123
      if (c2___0 == 93) {
#line 1127
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1128
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1132
        if (c2___0 == 92) {
#line 1132
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1135
            c2___0 = bracket_fetch_wc___0(dfa);
#line 1136
            wc2 = dfa->lex.wctok;
            }
          }
        }
        {
#line 1139
        colon_warning_state |= 8;
#line 1140
        c1 = bracket_fetch_wc___0(dfa);
#line 1141
        wc1 = dfa->lex.wctok;
        }
#line 1144
        if (wc != wc2) {
#line 1144
          goto _L___2;
        } else
#line 1144
        if (wc == 4294967295U) {
          _L___2: /* CIL Label */ 
#line 1146
          if (dfa->localeinfo.multibyte) {
#line 1147
            known_bracket_exp = (_Bool)0;
          } else
#line 1148
          if (dfa->simple_locale) {
#line 1151
            ci = c;
            {
#line 1151
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1151
              if (! (ci <= c2___0)) {
#line 1151
                goto while_break___2;
              }
              {
#line 1152
              setbit___0((unsigned int )ci, & ccl);
#line 1151
              ci ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1153
            if (dfa->syntax.case_fold) {
              {
#line 1155
              tmp___10 = toupper(c);
#line 1155
              uc = tmp___10;
#line 1156
              tmp___11 = toupper(c2___0);
#line 1156
              uc2 = tmp___11;
#line 1157
              ci = 0;
              }
              {
#line 1157
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1157
                if (! (ci < 256)) {
#line 1157
                  goto while_break___3;
                }
                {
#line 1159
                tmp___12 = toupper(ci);
#line 1159
                uci = tmp___12;
                }
#line 1160
                if (uc <= uci) {
#line 1160
                  if (uci <= uc2) {
                    {
#line 1161
                    setbit___0((unsigned int )ci, & ccl);
                    }
                  }
                }
#line 1157
                ci ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          } else {
#line 1166
            known_bracket_exp = (_Bool)0;
          }
#line 1168
          goto __Cont;
        }
      }
    }
#line 1173
    if (c == 58) {
#line 1173
      tmp___13 = 2;
    } else {
#line 1173
      tmp___13 = 4;
    }
#line 1173
    colon_warning_state |= tmp___13;
#line 1175
    if (! dfa->localeinfo.multibyte) {
#line 1177
      if (dfa->syntax.case_fold) {
        {
#line 1178
        setbit_case_fold_c___0(c, & ccl);
        }
      } else {
        {
#line 1180
        setbit___0((unsigned int )c, & ccl);
        }
      }
#line 1181
      goto __Cont;
    }
#line 1184
    if (wc == 4294967295U) {
#line 1185
      known_bracket_exp = (_Bool)0;
    } else {
#line 1189
      if (dfa->syntax.case_fold) {
        {
#line 1189
        tmp___14 = case_folded_counterparts(wc, (wchar_t *)(folded + 1));
#line 1189
        tmp___15 = tmp___14 + 1;
        }
      } else {
#line 1189
        tmp___15 = 1;
      }
#line 1189
      n = (unsigned int )tmp___15;
#line 1192
      folded[0] = (wchar_t )wc;
#line 1193
      i = 0U;
      {
#line 1193
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1193
        if (! (i < n)) {
#line 1193
          goto while_break___4;
        }
        {
#line 1194
        tmp___18 = setbit_wc___0((wint_t )folded[i], & ccl);
        }
#line 1194
        if (! tmp___18) {
          {
#line 1196
          tmp___16 = maybe_realloc___0((void *)dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                       & dfa->lex.brack.nchars_alloc, (ptrdiff_t )-1,
                                       (ptrdiff_t )sizeof(*(dfa->lex.brack.chars)));
#line 1196
          dfa->lex.brack.chars = (wchar_t *)tmp___16;
#line 1200
          tmp___17 = dfa->lex.brack.nchars;
#line 1200
          (dfa->lex.brack.nchars) ++;
#line 1200
          *(dfa->lex.brack.chars + tmp___17) = folded[i];
          }
        }
#line 1193
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1022
    wc = wc1;
#line 1022
    c = c1;
#line 1022
    if (! (c != 93)) {
#line 1022
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1206
  if (colon_warning_state == 7) {
    {
#line 1207
    tmp___19 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1207
    dfawarn((char const   *)tmp___19);
    }
  }
#line 1209
  if (! known_bracket_exp) {
#line 1210
    return ((token )257);
  }
#line 1212
  if (dfa->localeinfo.multibyte) {
    {
#line 1214
    dfa->lex.brack.invert = invert;
#line 1215
    tmp___22 = emptyset___0((charclass const   *)(& ccl));
    }
#line 1215
    if (tmp___22) {
#line 1215
      dfa->lex.brack.cset = (ptrdiff_t )-1;
    } else {
      {
#line 1215
      tmp___21 = charclass_index___0(dfa, & ccl);
#line 1215
      dfa->lex.brack.cset = tmp___21;
      }
    }
#line 1216
    return ((token )273);
  }
#line 1219
  if (invert) {
#line 1221
    if (! (! dfa->localeinfo.multibyte)) {
      {
#line 1221
      __assert_fail("!dfa->localeinfo.multibyte", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c",
                    1221U, "parse_bracket_exp");
      }
    }
    {
#line 1222
    notset___0(& ccl);
    }
#line 1223
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1224
      clrbit___0((unsigned int )'\n', & ccl);
      }
    }
  }
  {
#line 1227
  tmp___24 = charclass_index___0(dfa, & ccl);
  }
#line 1227
  return (275L + tmp___24);
}
}
#line 1236 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void push_lex_state___0(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1239
  ls->ptr = dfa->lex.ptr;
#line 1240
  ls->left = dfa->lex.left;
#line 1241
  dfa->lex.ptr = s;
#line 1242
  dfa->lex.left = strlen(s);
  }
#line 1243
  return;
}
}
#line 1245 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void pop_lex_state___0(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1248
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1249
  dfa->lex.left = (size_t )ls->left;
#line 1250
  return;
}
}
#line 1252 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static token lex___0(struct dfa *dfa ) 
{ 
  _Bool backslash ;
  int i ;
  token tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  char const   *p ;
  char const   *lim ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  token tmp___27 ;
  charclass ccl ;
  int c2 ;
  ptrdiff_t tmp___28 ;
  token tmp___29 ;
  charclass ccl___0 ;
  int c2___0 ;
  unsigned short const   **tmp___30 ;
  token tmp___31 ;
  ptrdiff_t tmp___32 ;
  struct lexptr ls ;
  charclass ccl___1 ;
  int c2___1 ;
  token tmp___33 ;
  ptrdiff_t tmp___34 ;
  struct lexptr ls___0 ;
  token tmp___35 ;
  token tmp___36 ;
  charclass ccl___2 ;
  token tmp___37 ;
  ptrdiff_t tmp___38 ;
  unsigned short const   **tmp___39 ;
  token tmp___40 ;

  {
#line 1255
  backslash = (_Bool)0;
#line 1263
  i = 0;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! (i < 2)) {
#line 1263
      goto while_break;
    }
#line 1265
    if (! dfa->lex.left) {
#line 1266
      tmp = (token )-1;
#line 1266
      dfa->lex.lasttok = tmp;
#line 1266
      return (tmp);
    }
    {
#line 1267
    tmp___0 = fetch_wc___0(dfa);
#line 1267
    c = tmp___0;
    }
    {
#line 1271
    if (c == 92) {
#line 1271
      goto case_92;
    }
#line 1279
    if (c == 94) {
#line 1279
      goto case_94;
    }
#line 1288
    if (c == 36) {
#line 1288
      goto case_36;
    }
#line 1316
    if (c == 57) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 56) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 55) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 54) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 53) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 52) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 51) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 50) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 49) {
#line 1316
      goto case_57;
    }
#line 1324
    if (c == 96) {
#line 1324
      goto case_96;
    }
#line 1332
    if (c == 39) {
#line 1332
      goto case_39;
    }
#line 1340
    if (c == 60) {
#line 1340
      goto case_60;
    }
#line 1345
    if (c == 62) {
#line 1345
      goto case_62;
    }
#line 1350
    if (c == 98) {
#line 1350
      goto case_98;
    }
#line 1355
    if (c == 66) {
#line 1355
      goto case_66;
    }
#line 1360
    if (c == 63) {
#line 1360
      goto case_63;
    }
#line 1370
    if (c == 42) {
#line 1370
      goto case_42;
    }
#line 1378
    if (c == 43) {
#line 1378
      goto case_43;
    }
#line 1388
    if (c == 123) {
#line 1388
      goto case_123;
    }
#line 1446
    if (c == 124) {
#line 1446
      goto case_124;
    }
#line 1454
    if (c == 10) {
#line 1454
      goto case_10;
    }
#line 1461
    if (c == 40) {
#line 1461
      goto case_40;
    }
#line 1468
    if (c == 41) {
#line 1468
      goto case_41;
    }
#line 1478
    if (c == 46) {
#line 1478
      goto case_46;
    }
#line 1501
    if (c == 83) {
#line 1501
      goto case_83;
    }
#line 1501
    if (c == 115) {
#line 1501
      goto case_83;
    }
#line 1534
    if (c == 87) {
#line 1534
      goto case_87;
    }
#line 1534
    if (c == 119) {
#line 1534
      goto case_87;
    }
#line 1567
    if (c == 91) {
#line 1567
      goto case_91;
    }
#line 1573
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1272
    if (backslash) {
#line 1273
      goto normal_char;
    }
#line 1274
    if (dfa->lex.left == 0UL) {
      {
#line 1275
      tmp___1 = gettext("unfinished \\ escape");
#line 1275
      dfaerror((char const   *)tmp___1);
      }
    }
#line 1276
    backslash = (_Bool)1;
#line 1277
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1280
    if (backslash) {
#line 1281
      goto normal_char;
    }
#line 1282
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == -1L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == 270L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    } else
#line 1282
    if (dfa->lex.lasttok == 269L) {
#line 1285
      tmp___2 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___2;
#line 1285
      return (tmp___2);
    }
#line 1286
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1289
    if (backslash) {
#line 1290
      goto normal_char;
    }
#line 1291
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1305
      tmp___3 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___3;
#line 1305
      return (tmp___3);
    } else
#line 1291
    if (dfa->lex.left == 0UL) {
#line 1305
      tmp___3 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___3;
#line 1305
      return (tmp___3);
    } else
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1305
        tmp___3 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___3;
#line 1305
        return (tmp___3);
      } else {
#line 1291
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1305
        tmp___3 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___3;
#line 1305
        return (tmp___3);
      } else {
#line 1291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1291
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1291
      if (dfa->lex.left > 0UL) {
#line 1291
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1305
          tmp___3 = (token )259;
#line 1305
          dfa->lex.lasttok = tmp___3;
#line 1305
          return (tmp___3);
        }
      }
    }
#line 1306
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1317
    if (backslash) {
#line 1317
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1319
        dfa->lex.laststart = (_Bool)0;
#line 1320
        tmp___4 = (token )257;
#line 1320
        dfa->lex.lasttok = tmp___4;
#line 1320
        return (tmp___4);
      }
    }
#line 1322
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1325
    if (backslash) {
#line 1325
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1328
        tmp___5 = (token )258;
#line 1328
        dfa->lex.lasttok = tmp___5;
#line 1328
        return (tmp___5);
      }
    }
#line 1330
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1333
    if (backslash) {
#line 1333
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1336
        tmp___6 = (token )259;
#line 1336
        dfa->lex.lasttok = tmp___6;
#line 1336
        return (tmp___6);
      }
    }
#line 1338
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1341
    if (backslash) {
#line 1341
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1342
        tmp___7 = (token )260;
#line 1342
        dfa->lex.lasttok = tmp___7;
#line 1342
        return (tmp___7);
      }
    }
#line 1343
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1346
    if (backslash) {
#line 1346
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1347
        tmp___8 = (token )261;
#line 1347
        dfa->lex.lasttok = tmp___8;
#line 1347
        return (tmp___8);
      }
    }
#line 1348
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1351
    if (backslash) {
#line 1351
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1352
        tmp___9 = (token )262;
#line 1352
        dfa->lex.lasttok = tmp___9;
#line 1352
        return (tmp___9);
      }
    }
#line 1353
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1356
    if (backslash) {
#line 1356
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1357
        tmp___10 = (token )263;
#line 1357
        dfa->lex.lasttok = tmp___10;
#line 1357
        return (tmp___10);
      }
    }
#line 1358
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1361
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1362
      goto normal_char;
    }
#line 1363
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1364
      goto normal_char;
    }
#line 1365
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1365
      if (dfa->lex.laststart) {
#line 1367
        goto normal_char;
      }
    }
#line 1368
    tmp___11 = (token )264;
#line 1368
    dfa->lex.lasttok = tmp___11;
#line 1368
    return (tmp___11);
    case_42: /* CIL Label */ 
#line 1371
    if (backslash) {
#line 1372
      goto normal_char;
    }
#line 1373
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1373
      if (dfa->lex.laststart) {
#line 1375
        goto normal_char;
      }
    }
#line 1376
    tmp___12 = (token )265;
#line 1376
    dfa->lex.lasttok = tmp___12;
#line 1376
    return (tmp___12);
    case_43: /* CIL Label */ 
#line 1379
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1380
      goto normal_char;
    }
#line 1381
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1382
      goto normal_char;
    }
#line 1383
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1383
      if (dfa->lex.laststart) {
#line 1385
        goto normal_char;
      }
    }
#line 1386
    tmp___13 = (token )266;
#line 1386
    dfa->lex.lasttok = tmp___13;
#line 1386
    return (tmp___13);
    case_123: /* CIL Label */ 
#line 1389
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1390
      goto normal_char;
    }
#line 1391
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1392
      goto normal_char;
    }
#line 1393
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1393
      if (dfa->lex.laststart) {
#line 1395
        goto normal_char;
      }
    }
#line 1404
    p = dfa->lex.ptr;
#line 1405
    lim = p + dfa->lex.left;
#line 1406
    tmp___14 = -1;
#line 1406
    dfa->lex.maxrep = tmp___14;
#line 1406
    dfa->lex.minrep = tmp___14;
    {
#line 1407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1407
      if ((unsigned long )p != (unsigned long )lim) {
        {
#line 1407
        tmp___16 = isasciidigit___0((char )*p);
        }
#line 1407
        if (! tmp___16) {
#line 1407
          goto while_break___0;
        }
      } else {
#line 1407
        goto while_break___0;
      }
#line 1408
      if (dfa->lex.minrep < 0) {
#line 1408
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1408
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1408
          tmp___15 = 32768;
        } else {
#line 1408
          tmp___15 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1408
        dfa->lex.minrep = tmp___15;
      }
#line 1407
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1412
    if ((unsigned long )p != (unsigned long )lim) {
#line 1414
      if ((int const   )*p != 44) {
#line 1415
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1418
        if (dfa->lex.minrep < 0) {
#line 1419
          dfa->lex.minrep = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1420
          p ++;
#line 1420
          if ((unsigned long )p != (unsigned long )lim) {
            {
#line 1420
            tmp___18 = isasciidigit___0((char )*p);
            }
#line 1420
            if (! tmp___18) {
#line 1420
              goto while_break___1;
            }
          } else {
#line 1420
            goto while_break___1;
          }
#line 1421
          if (dfa->lex.maxrep < 0) {
#line 1421
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1421
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1421
              tmp___17 = 32768;
            } else {
#line 1421
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1421
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1428
    if (! backslash) {
#line 1428
      goto _L___5;
    } else
#line 1428
    if ((unsigned long )p != (unsigned long )lim) {
#line 1428
      tmp___20 = p;
#line 1428
      p ++;
#line 1428
      if ((int const   )*tmp___20 == 92) {
        _L___5: /* CIL Label */ 
#line 1428
        if ((unsigned long )p != (unsigned long )lim) {
#line 1428
          tmp___21 = p;
#line 1428
          p ++;
#line 1428
          if ((int const   )*tmp___21 == 125) {
#line 1428
            if (0 <= dfa->lex.minrep) {
#line 1428
              if (! (dfa->lex.maxrep < 0)) {
#line 1428
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1428
                  goto _L___6;
                }
              }
            } else {
#line 1428
              goto _L___6;
            }
          } else {
#line 1428
            goto _L___6;
          }
        } else {
#line 1428
          goto _L___6;
        }
      } else {
#line 1428
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1434
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1435
        goto normal_char;
      }
      {
#line 1436
      tmp___19 = gettext("invalid content of \\{\\}");
#line 1436
      dfaerror((char const   *)tmp___19);
      }
    }
#line 1438
    if (32767 < dfa->lex.maxrep) {
      {
#line 1439
      tmp___22 = gettext("regular expression too big");
#line 1439
      dfaerror((char const   *)tmp___22);
      }
    }
#line 1440
    dfa->lex.ptr = p;
#line 1441
    dfa->lex.left = (size_t )(lim - p);
#line 1443
    dfa->lex.laststart = (_Bool)0;
#line 1444
    tmp___23 = (token )267;
#line 1444
    dfa->lex.lasttok = tmp___23;
#line 1444
    return (tmp___23);
    case_124: /* CIL Label */ 
#line 1447
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1448
      goto normal_char;
    }
#line 1449
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1450
      goto normal_char;
    }
#line 1451
    dfa->lex.laststart = (_Bool)1;
#line 1452
    tmp___24 = (token )269;
#line 1452
    dfa->lex.lasttok = tmp___24;
#line 1452
    return (tmp___24);
    case_10: /* CIL Label */ 
#line 1455
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (backslash) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1457
      goto normal_char;
    }
#line 1458
    dfa->lex.laststart = (_Bool)1;
#line 1459
    tmp___25 = (token )269;
#line 1459
    dfa->lex.lasttok = tmp___25;
#line 1459
    return (tmp___25);
    case_40: /* CIL Label */ 
#line 1462
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1463
      goto normal_char;
    }
#line 1464
    (dfa->lex.parens) ++;
#line 1465
    dfa->lex.laststart = (_Bool)1;
#line 1466
    tmp___26 = (token )270;
#line 1466
    dfa->lex.lasttok = tmp___26;
#line 1466
    return (tmp___26);
    case_41: /* CIL Label */ 
#line 1469
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1470
      goto normal_char;
    }
#line 1471
    if (dfa->lex.parens == 0UL) {
#line 1471
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1473
        goto normal_char;
      }
    }
#line 1474
    (dfa->lex.parens) --;
#line 1475
    dfa->lex.laststart = (_Bool)0;
#line 1476
    tmp___27 = (token )271;
#line 1476
    dfa->lex.lasttok = tmp___27;
#line 1476
    return (tmp___27);
    case_46: /* CIL Label */ 
#line 1479
    if (backslash) {
#line 1480
      goto normal_char;
    }
#line 1481
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1484
      fillset___0(& ccl);
      }
#line 1485
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1486
        clrbit___0((unsigned int )'\n', & ccl);
        }
      }
#line 1487
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1488
        clrbit___0((unsigned int )'\000', & ccl);
        }
      }
#line 1489
      if (dfa->localeinfo.multibyte) {
#line 1490
        c2 = 0;
        {
#line 1490
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1490
          if (! (c2 < 256)) {
#line 1490
            goto while_break___2;
          }
#line 1491
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1492
            clrbit___0((unsigned int )c2, & ccl);
            }
          }
#line 1490
          c2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1493
      tmp___28 = charclass_index___0(dfa, & ccl);
#line 1493
      dfa->canychar = (size_t )tmp___28;
      }
    }
#line 1495
    dfa->lex.laststart = (_Bool)0;
#line 1496
    if (dfa->localeinfo.multibyte) {
#line 1496
      tmp___29 = (token )272;
    } else {
#line 1496
      tmp___29 = (token )(275UL + dfa->canychar);
    }
#line 1496
    dfa->lex.lasttok = tmp___29;
#line 1496
    return (tmp___29);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1502
    if (! backslash) {
#line 1503
      goto normal_char;
    } else
#line 1502
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1503
      goto normal_char;
    }
#line 1504
    if (! dfa->localeinfo.multibyte) {
      {
#line 1507
      zeroset___0(& ccl___0);
#line 1508
      c2___0 = 0;
      }
      {
#line 1508
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1508
        if (! (c2___0 < 256)) {
#line 1508
          goto while_break___3;
        }
        {
#line 1509
        tmp___30 = __ctype_b_loc();
        }
#line 1509
        if ((int const   )*(*tmp___30 + c2___0) & 8192) {
          {
#line 1510
          setbit___0((unsigned int )c2___0, & ccl___0);
          }
        }
#line 1508
        c2___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1511
      if (c == 83) {
        {
#line 1512
        notset___0(& ccl___0);
        }
      }
      {
#line 1513
      dfa->lex.laststart = (_Bool)0;
#line 1514
      tmp___32 = charclass_index___0(dfa, & ccl___0);
#line 1514
      tmp___31 = 275L + tmp___32;
#line 1514
      dfa->lex.lasttok = tmp___31;
      }
#line 1514
      return (tmp___31);
    }
    {
#line 1525
    push_lex_state___0(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1526
    dfa->lex.lasttok = parse_bracket_exp___0(dfa);
#line 1527
    pop_lex_state___0(dfa, (struct lexptr  const  *)(& ls));
#line 1530
    dfa->lex.laststart = (_Bool)0;
    }
#line 1531
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1535
    if (! backslash) {
#line 1536
      goto normal_char;
    } else
#line 1535
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1536
      goto normal_char;
    }
#line 1538
    if (! dfa->localeinfo.multibyte) {
      {
#line 1541
      zeroset___0(& ccl___1);
#line 1542
      c2___1 = 0;
      }
      {
#line 1542
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1542
        if (! (c2___1 < 256)) {
#line 1542
          goto while_break___4;
        }
#line 1543
        if ((int )dfa->syntax.sbit[c2___1] == 2) {
          {
#line 1544
          setbit___0((unsigned int )c2___1, & ccl___1);
          }
        }
#line 1542
        c2___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1545
      if (c == 87) {
        {
#line 1546
        notset___0(& ccl___1);
        }
      }
      {
#line 1547
      dfa->lex.laststart = (_Bool)0;
#line 1548
      tmp___34 = charclass_index___0(dfa, & ccl___1);
#line 1548
      tmp___33 = 275L + tmp___34;
#line 1548
      dfa->lex.lasttok = tmp___33;
      }
#line 1548
      return (tmp___33);
    }
    {
#line 1559
    push_lex_state___0(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1560
    dfa->lex.lasttok = parse_bracket_exp___0(dfa);
#line 1561
    pop_lex_state___0(dfa, (struct lexptr  const  *)(& ls___0));
#line 1564
    dfa->lex.laststart = (_Bool)0;
    }
#line 1565
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1568
    if (backslash) {
#line 1569
      goto normal_char;
    }
    {
#line 1570
    dfa->lex.laststart = (_Bool)0;
#line 1571
    tmp___35 = parse_bracket_exp___0(dfa);
#line 1571
    dfa->lex.lasttok = tmp___35;
    }
#line 1571
    return (tmp___35);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1575
    dfa->lex.laststart = (_Bool)0;
#line 1578
    if (dfa->localeinfo.multibyte) {
#line 1579
      tmp___36 = (token )274;
#line 1579
      dfa->lex.lasttok = tmp___36;
#line 1579
      return (tmp___36);
    }
#line 1581
    if (dfa->syntax.case_fold) {
      {
#line 1581
      tmp___39 = __ctype_b_loc();
      }
#line 1581
      if ((int const   )*(*tmp___39 + c) & 1024) {
        {
#line 1584
        zeroset___0(& ccl___2);
#line 1585
        setbit_case_fold_c___0(c, & ccl___2);
#line 1586
        tmp___38 = charclass_index___0(dfa, & ccl___2);
#line 1586
        tmp___37 = 275L + tmp___38;
#line 1586
        dfa->lex.lasttok = tmp___37;
        }
#line 1586
        return (tmp___37);
      }
    }
#line 1589
    tmp___40 = (token )c;
#line 1589
    dfa->lex.lasttok = tmp___40;
#line 1589
    return (tmp___40);
    switch_break: /* CIL Label */ ;
    }
#line 1263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  abort();
  }
#line 1596
  return ((token )-1);
}
}
#line 1599 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok_mb___0(struct dfa *dfa , token t , char mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1602
  if (dfa->talloc == dfa->tindex) {
    {
#line 1604
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1604
    dfa->tokens = (token *)tmp;
    }
#line 1606
    if (dfa->localeinfo.multibyte) {
      {
#line 1607
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1607
      dfa->multibyte_prop = (char *)tmp___0;
      }
    }
  }
#line 1610
  if (dfa->localeinfo.multibyte) {
#line 1611
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1612
  tmp___1 = dfa->tindex;
#line 1612
  (dfa->tindex) ++;
#line 1612
  *(dfa->tokens + tmp___1) = t;
  {
#line 1618
  if (t == 266L) {
#line 1618
    goto case_266;
  }
#line 1618
  if (t == 265L) {
#line 1618
    goto case_266;
  }
#line 1618
  if (t == 264L) {
#line 1618
    goto case_266;
  }
#line 1622
  if (t == 269L) {
#line 1622
    goto case_269;
  }
#line 1622
  if (t == 268L) {
#line 1622
    goto case_269;
  }
#line 1626
  if (t == 257L) {
#line 1626
    goto case_257;
  }
#line 1632
  if (t == 256L) {
#line 1632
    goto case_256;
  }
#line 1629
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1619
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1623
  (dfa->parse.depth) --;
#line 1624
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1627
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1630
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1633
  (dfa->parse.depth) ++;
#line 1634
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1636
  if (dfa->parse.depth > dfa->depth) {
#line 1637
    dfa->depth = dfa->parse.depth;
  }
#line 1638
  return;
}
}
#line 1640
static void addtok_wc___0(struct dfa *dfa , wint_t wc ) ;
#line 1644 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok___0(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  ptrdiff_t i ;

  {
#line 1647
  if (dfa->localeinfo.multibyte) {
#line 1647
    if (t == 273L) {
#line 1649
      need_or = (_Bool)0;
#line 1653
      i = (ptrdiff_t )0;
      {
#line 1653
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1653
        if (! (i < dfa->lex.brack.nchars)) {
#line 1653
          goto while_break;
        }
        {
#line 1655
        addtok_wc___0(dfa, (wint_t )*(dfa->lex.brack.chars + i));
        }
#line 1656
        if (need_or) {
          {
#line 1657
          addtok___0(dfa, (token )269);
          }
        }
#line 1658
        need_or = (_Bool)1;
#line 1653
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1660
      dfa->lex.brack.nchars = (ptrdiff_t )0;
#line 1664
      if (dfa->lex.brack.cset != -1L) {
        {
#line 1666
        addtok___0(dfa, 275L + dfa->lex.brack.cset);
        }
#line 1667
        if (need_or) {
          {
#line 1668
          addtok___0(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1673
      addtok_mb___0(dfa, t, (char)3);
      }
    }
  } else {
    {
#line 1673
    addtok_mb___0(dfa, t, (char)3);
    }
  }
#line 1675
  return;
}
}
#line 1683 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void addtok_wc___0(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 1687
  s.__count = 0;
#line 1687
  s.__value.__wch = 0U;
#line 1688
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1688
  stored_bytes = tmp;
  }
#line 1690
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1691
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1696
    dfa->lex.cur_mb_len = 1;
#line 1697
    buf[0] = (unsigned char)0;
  }
#line 1700
  if (dfa->lex.cur_mb_len == 1) {
#line 1700
    tmp___0 = 3;
  } else {
#line 1700
    tmp___0 = 1;
  }
  {
#line 1700
  addtok_mb___0(dfa, (token )buf[0], (char )tmp___0);
#line 1701
  i = 1;
  }
  {
#line 1701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1701
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1701
      goto while_break;
    }
#line 1703
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1703
      tmp___1 = 2;
    } else {
#line 1703
      tmp___1 = 0;
    }
    {
#line 1703
    addtok_mb___0(dfa, (token )buf[i], (char )tmp___1);
#line 1704
    addtok___0(dfa, (token )268);
#line 1701
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1706
  return;
}
}
#line 1711
static void add_utf8_anychar___0(struct dfa *dfa ) ;
#line 1711 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static charclass const   utf8_classes___0[5]  = {      {{0UL, 0UL, (4294967295UL << 32) + 4294967295UL, 0UL}}, 
        {{(4294967295UL << 32) + 4294967295UL, (4294967295UL << 32) + 4294967295UL, 0UL,
       0UL}}, 
        {{0UL, 0UL, 0UL, 4294967292UL}}, 
        {{0UL, 0UL, 0UL, 65535UL << 32}}, 
        {{0UL, 0UL, 0UL, 16711680UL << 32}}};
#line 1708 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void add_utf8_anychar___0(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;
  unsigned int i___0 ;

  {
#line 1727
  n = (unsigned int )(sizeof(utf8_classes___0) / sizeof(utf8_classes___0[0]));
#line 1730
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1731
    i = 0U;
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if (! (i < n)) {
#line 1731
        goto while_break;
      }
#line 1733
      c = utf8_classes___0[i];
#line 1734
      if (i == 1U) {
#line 1736
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1737
          clrbit___0((unsigned int )'\n', & c);
          }
        }
#line 1738
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1739
          clrbit___0((unsigned int )'\000', & c);
          }
        }
      }
      {
#line 1741
      tmp = charclass_index___0(dfa, & c);
#line 1741
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1731
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1755
  i___0 = 1U;
  {
#line 1755
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1755
    if (! (i___0 < n)) {
#line 1755
      goto while_break___0;
    }
    {
#line 1756
    addtok___0(dfa, dfa->utf8_anychar_classes[i___0]);
#line 1755
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1757
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1757
    i___0 --;
#line 1757
    if (! (i___0 > 1U)) {
#line 1757
      goto while_break___1;
    }
    {
#line 1759
    addtok___0(dfa, dfa->utf8_anychar_classes[0]);
#line 1760
    addtok___0(dfa, (token )268);
#line 1761
    addtok___0(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1763
  return;
}
}
#line 1800 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void atom___0(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int n ;
  int tmp ;
  unsigned int i ;
  char *tmp___0 ;

  {
#line 1803
  if (dfa->parse.tok == 274L) {
#line 1805
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1806
      addtok___0(dfa, (token )257);
      }
    } else {
      {
#line 1809
      addtok_wc___0(dfa, dfa->lex.wctok);
      }
#line 1811
      if (dfa->syntax.case_fold) {
        {
#line 1814
        tmp = case_folded_counterparts(dfa->lex.wctok, (wchar_t *)(folded));
#line 1814
        n = (unsigned int )tmp;
#line 1816
        i = 0U;
        }
        {
#line 1816
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1816
          if (! (i < n)) {
#line 1816
            goto while_break;
          }
          {
#line 1818
          addtok_wc___0(dfa, (wint_t )folded[i]);
#line 1819
          addtok___0(dfa, (token )269);
#line 1816
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1824
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1826
  if (dfa->parse.tok == 272L) {
#line 1826
    if (dfa->localeinfo.using_utf8) {
      {
#line 1835
      add_utf8_anychar___0(dfa);
#line 1836
      dfa->parse.tok = lex___0(dfa);
      }
    } else {
#line 1826
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1838
  if (0L <= dfa->parse.tok) {
#line 1838
    if (dfa->parse.tok < 256L) {
      {
#line 1845
      addtok___0(dfa, dfa->parse.tok);
#line 1846
      dfa->parse.tok = lex___0(dfa);
      }
    } else {
#line 1838
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1838
  if (dfa->parse.tok >= 275L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 257L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 258L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 259L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 260L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 272L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 273L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 261L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 262L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 263L) {
    {
#line 1845
    addtok___0(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex___0(dfa);
    }
  } else
#line 1848
  if (dfa->parse.tok == 270L) {
    {
#line 1850
    dfa->parse.tok = lex___0(dfa);
#line 1851
    regexp___0(dfa);
    }
#line 1852
    if (dfa->parse.tok != 271L) {
      {
#line 1853
      tmp___0 = gettext("unbalanced (");
#line 1853
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1854
    dfa->parse.tok = lex___0(dfa);
    }
  } else {
    {
#line 1857
    addtok___0(dfa, (token )256);
    }
  }
#line 1858
  return;
}
}
#line 1861 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks___0(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1870
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1870
    goto case_266;
  }
#line 1870
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1870
    goto case_266;
  }
#line 1873
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1873
    goto case_269;
  }
#line 1873
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1873
    goto case_269;
  }
#line 1866
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1867
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1871
  tmp = nsubtoks___0(dfa, tindex - 1UL);
  }
#line 1871
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1875
  tmp___0 = nsubtoks___0(dfa, tindex - 1UL);
#line 1875
  ntoks1 = (size_t )tmp___0;
#line 1876
  tmp___1 = nsubtoks___0(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1876
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1882 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void copytoks___0(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;
  size_t i___0 ;

  {
#line 1885
  if (dfa->localeinfo.multibyte) {
#line 1886
    i = (size_t )0;
    {
#line 1886
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1886
      if (! (i < ntokens)) {
#line 1886
        goto while_break;
      }
      {
#line 1887
      addtok_mb___0(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1886
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1890
    i___0 = (size_t )0;
    {
#line 1890
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1890
      if (! (i___0 < ntokens)) {
#line 1890
        goto while_break___0;
      }
      {
#line 1891
      addtok_mb___0(dfa, *(dfa->tokens + (tindex + i___0)), (char)3);
#line 1890
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1892
  return;
}
}
#line 1894 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void closure___0(struct dfa *dfa ) 
{ 
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t tindex ;
  int i ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1897
  atom___0(dfa);
  }
  {
#line 1898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1898
    if (! (dfa->parse.tok == 264L)) {
#line 1898
      if (! (dfa->parse.tok == 265L)) {
#line 1898
        if (! (dfa->parse.tok == 266L)) {
#line 1898
          if (! (dfa->parse.tok == 267L)) {
#line 1898
            goto while_break;
          }
        }
      }
    }
#line 1900
    if (dfa->parse.tok == 267L) {
#line 1900
      if (dfa->lex.minrep) {
#line 1900
        goto _L___0;
      } else
#line 1900
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1902
        tmp = nsubtoks___0((struct dfa  const  *)dfa, dfa->tindex);
#line 1902
        ntokens = (size_t )tmp;
#line 1903
        tindex = dfa->tindex - ntokens;
        }
#line 1904
        if (dfa->lex.maxrep < 0) {
          {
#line 1905
          addtok___0(dfa, (token )266);
          }
        }
#line 1906
        if (dfa->lex.minrep == 0) {
          {
#line 1907
          addtok___0(dfa, (token )264);
          }
        }
#line 1909
        i = 1;
        {
#line 1909
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1909
          if (! (i < dfa->lex.minrep)) {
#line 1909
            goto while_break___0;
          }
          {
#line 1911
          copytoks___0(dfa, tindex, ntokens);
#line 1912
          addtok___0(dfa, (token )268);
#line 1909
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1914
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1914
          if (! (i < dfa->lex.maxrep)) {
#line 1914
            goto while_break___1;
          }
          {
#line 1916
          copytoks___0(dfa, tindex, ntokens);
#line 1917
          addtok___0(dfa, (token )264);
#line 1918
          addtok___0(dfa, (token )268);
#line 1914
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1920
        dfa->parse.tok = lex___0(dfa);
        }
      } else {
#line 1900
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1922
    if (dfa->parse.tok == 267L) {
      {
#line 1924
      tmp___0 = nsubtoks___0((struct dfa  const  *)dfa, dfa->tindex);
#line 1924
      dfa->tindex -= (size_t )tmp___0;
#line 1925
      dfa->parse.tok = lex___0(dfa);
#line 1926
      closure___0(dfa);
      }
    } else {
      {
#line 1930
      addtok___0(dfa, dfa->parse.tok);
#line 1931
      dfa->parse.tok = lex___0(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1933
  return;
}
}
#line 1935 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void branch___0(struct dfa *dfa ) 
{ 


  {
  {
#line 1938
  closure___0(dfa);
  }
  {
#line 1939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1939
    if (dfa->parse.tok != 271L) {
#line 1939
      if (dfa->parse.tok != 269L) {
#line 1939
        if (! (dfa->parse.tok >= 0L)) {
#line 1939
          goto while_break;
        }
      } else {
#line 1939
        goto while_break;
      }
    } else {
#line 1939
      goto while_break;
    }
    {
#line 1942
    closure___0(dfa);
#line 1943
    addtok___0(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1945
  return;
}
}
#line 1947 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void regexp___0(struct dfa *dfa ) 
{ 


  {
  {
#line 1950
  branch___0(dfa);
  }
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! (dfa->parse.tok == 269L)) {
#line 1951
      goto while_break;
    }
    {
#line 1953
    dfa->parse.tok = lex___0(dfa);
#line 1954
    branch___0(dfa);
#line 1955
    addtok___0(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1957
  return;
}
}
#line 1962 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaparse___0(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1965
  d->lex.ptr = s;
#line 1966
  d->lex.left = len;
#line 1967
  d->lex.lasttok = (token )-1;
#line 1968
  d->lex.laststart = (_Bool)1;
#line 1970
  if (! d->syntax.syntax_bits_set) {
    {
#line 1971
    tmp = gettext("no syntax specified");
#line 1971
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1973
  d->parse.tok = lex___0(d);
#line 1974
  d->parse.depth = d->depth;
#line 1976
  regexp___0(d);
  }
#line 1978
  if (d->parse.tok != -1L) {
    {
#line 1979
    tmp___0 = gettext("unbalanced )");
#line 1979
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1981
  addtok___0(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1982
  addtok___0(d, (token )268);
  }
#line 1984
  if (d->nregexps) {
    {
#line 1985
    addtok___0(d, (token )269);
    }
  }
#line 1987
  (d->nregexps) ++;
#line 1988
  return;
}
}
#line 1993 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void copy___0(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 1996
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 1998
    free((void *)dst->elems);
#line 1999
    tmp = xpalloc___0((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                      (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 1999
    dst->elems = (position *)tmp;
    }
  }
#line 2002
  dst->nelem = (ptrdiff_t )src->nelem;
#line 2003
  if (src->nelem != 0L) {
    {
#line 2004
    memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(*(dst->elems)));
    }
  }
#line 2005
  return;
}
}
#line 2007 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void alloc_position_set___0(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2010
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2010
  s->elems = (position *)tmp;
#line 2011
  s->alloc = (ptrdiff_t )size;
#line 2012
  s->nelem = (ptrdiff_t )0;
  }
#line 2013
  return;
}
}
#line 2019 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void insert___0(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t mid ;
  void *tmp ;
  ptrdiff_t i ;

  {
#line 2022
  count = s->nelem;
#line 2023
  lo = (ptrdiff_t )0;
#line 2023
  hi = count;
  {
#line 2024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2024
    if (! (lo < hi)) {
#line 2024
      goto while_break;
    }
#line 2026
    mid = (lo + hi) >> 1;
#line 2027
    if ((s->elems + mid)->index > p.index) {
#line 2028
      lo = mid + 1L;
    } else
#line 2029
    if ((s->elems + mid)->index == p.index) {
#line 2031
      (s->elems + mid)->constraint |= p.constraint;
#line 2032
      return;
    } else {
#line 2035
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2038
  tmp = maybe_realloc___0((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2038
  s->elems = (position *)tmp;
#line 2039
  i = count;
  }
  {
#line 2039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2039
    if (! (i > lo)) {
#line 2039
      goto while_break___0;
    }
#line 2040
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2039
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2041
  *(s->elems + lo) = p;
#line 2042
  (s->nelem) ++;
#line 2043
  return;
}
}
#line 2048 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void merge_constrained___0(position_set const   *s1 , position_set const   *s2 ,
                                  unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2052
  i = (ptrdiff_t )0;
#line 2052
  j = (ptrdiff_t )0;
#line 2054
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2056
    free((void *)m->elems);
#line 2057
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2058
    tmp = xpalloc___0((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1,
                      (ptrdiff_t )sizeof(*(m->elems)));
#line 2058
    m->elems = (position *)tmp;
    }
  }
#line 2060
  m->nelem = (ptrdiff_t )0;
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2061
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2061
        goto while_break;
      }
    }
#line 2062
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2062
      goto _L;
    } else
#line 2062
    if (i < (ptrdiff_t )s1->nelem) {
#line 2062
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2065
        if (i < (ptrdiff_t )s1->nelem) {
#line 2065
          if (j < (ptrdiff_t )s2->nelem) {
#line 2065
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2065
              tmp___0 = j;
#line 2065
              j ++;
#line 2065
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2065
              tmp___1 = 0U;
            }
          } else {
#line 2065
            tmp___1 = 0U;
          }
        } else {
#line 2065
          tmp___1 = 0U;
        }
#line 2065
        c = tmp___1;
#line 2069
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2070
        tmp___2 = m->nelem;
#line 2070
        (m->nelem) ++;
#line 2070
        tmp___3 = i;
#line 2070
        i ++;
#line 2070
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2062
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2074
      if ((s2->elems + j)->constraint & c2) {
#line 2076
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2077
        tmp___4 = m->nelem;
#line 2077
        (m->nelem) ++;
#line 2077
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2079
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2081
  return;
}
}
#line 2085 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void merge___0(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2088
  merge_constrained___0(s1, s2, 4294967295U, m);
  }
#line 2089
  return;
}
}
#line 2093 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned int delete___0(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2096
  count = (size_t )s->nelem;
#line 2097
  lo = (size_t )0;
#line 2097
  hi = count;
  {
#line 2098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2098
    if (! (lo < hi)) {
#line 2098
      goto while_break;
    }
#line 2100
    mid = (lo + hi) >> 1;
#line 2101
    if ((s->elems + mid)->index > del) {
#line 2102
      lo = mid + 1UL;
    } else
#line 2103
    if ((s->elems + mid)->index == del) {
#line 2105
      c = (s->elems + mid)->constraint;
#line 2107
      i = mid;
      {
#line 2107
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2107
        if (! (i + 1UL < count)) {
#line 2107
          goto while_break___0;
        }
#line 2108
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2107
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2109
      s->nelem = (ptrdiff_t )i;
#line 2110
      return (c);
    } else {
#line 2113
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  return (0U);
}
}
#line 2119 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void replace___0(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                        position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2123
  tmp___0 = delete___0(del, dst);
#line 2123
  c = tmp___0 & constraint;
  }
#line 2125
  if (c) {
    {
#line 2127
    copy___0((position_set const   *)dst, tmp);
#line 2128
    merge_constrained___0((position_set const   *)tmp, (position_set const   *)add,
                          c, dst);
    }
  }
#line 2130
  return;
}
}
#line 2135 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num state_index___0(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  token first_end ;
  state_num j ;
  state_num j___0 ;
  int c ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 2138
  hash = (size_t )0;
#line 2139
  constraint = 0;
#line 2141
  first_end = (token )0;
#line 2143
  i = (state_num )0;
  {
#line 2143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2143
    if (! (i < (state_num )s->nelem)) {
#line 2143
      goto while_break;
    }
#line 2144
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  i = (state_num )0;
  {
#line 2147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2147
    if (! (i < d->sindex)) {
#line 2147
      goto while_break___0;
    }
#line 2149
    if (hash != (d->states + i)->hash) {
#line 2151
      goto __Cont;
    } else
#line 2149
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2151
      goto __Cont;
    } else
#line 2149
    if (context != (int )(d->states + i)->context) {
#line 2151
      goto __Cont;
    }
#line 2153
    j = (state_num )0;
    {
#line 2153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2153
      if (! (j < (state_num )s->nelem)) {
#line 2153
        goto while_break___1;
      }
#line 2154
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2156
        goto while_break___1;
      } else
#line 2154
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2156
        goto while_break___1;
      }
#line 2153
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2157
    if (j == (state_num )s->nelem) {
#line 2158
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2147
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2183
  j___0 = (state_num )0;
  {
#line 2183
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2183
    if (! (j___0 < (state_num )s->nelem)) {
#line 2183
      goto while_break___2;
    }
#line 2185
    c = (int )(s->elems + j___0)->constraint;
#line 2186
    if (*(d->tokens + (s->elems + j___0)->index) < 0L) {
      {
#line 2188
      tmp = succeeds_in_context___0(c, context, 7);
      }
#line 2188
      if (tmp) {
#line 2189
        constraint |= c;
      }
#line 2190
      if (! first_end) {
#line 2191
        first_end = *(d->tokens + (s->elems + j___0)->index);
      }
    } else
#line 2193
    if (*(d->tokens + (s->elems + j___0)->index) == 257L) {
#line 2194
      constraint = 511;
    }
#line 2183
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2199
  tmp___0 = maybe_realloc___0((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1,
                              (ptrdiff_t )sizeof(*(d->states)));
#line 2199
  d->states = (dfa_state *)tmp___0;
#line 2201
  (d->states + i)->hash = hash;
#line 2202
  alloc_position_set___0(& (d->states + i)->elems, (size_t )s->nelem);
#line 2203
  copy___0(s, & (d->states + i)->elems);
#line 2204
  (d->states + i)->context = (unsigned char )context;
#line 2205
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2206
  (d->states + i)->first_end = first_end;
#line 2207
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2208
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2209
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2211
  (d->sindex) ++;
  }
#line 2213
  return (i);
}
}
#line 2221 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void epsclosure___0(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2225
  alloc_position_set___0(& tmp, (size_t )d->nleaves);
#line 2226
  i = (size_t )0;
  }
  {
#line 2226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2226
    if (! (i < (size_t )d->tindex)) {
#line 2226
      goto while_break;
    }
#line 2227
    if ((d->follows + i)->nelem > 0L) {
#line 2227
      if (*(d->tokens + i) >= 256L) {
#line 2227
        if (*(d->tokens + i) != 257L) {
#line 2227
          if (*(d->tokens + i) != 272L) {
#line 2227
            if (*(d->tokens + i) != 273L) {
#line 2227
              if (*(d->tokens + i) < 275L) {
                {
#line 2234
                if (*(d->tokens + i) == 258L) {
#line 2234
                  goto case_258;
                }
#line 2237
                if (*(d->tokens + i) == 259L) {
#line 2237
                  goto case_259;
                }
#line 2240
                if (*(d->tokens + i) == 260L) {
#line 2240
                  goto case_260;
                }
#line 2243
                if (*(d->tokens + i) == 261L) {
#line 2243
                  goto case_261;
                }
#line 2246
                if (*(d->tokens + i) == 262L) {
#line 2246
                  goto case_262;
                }
#line 2249
                if (*(d->tokens + i) == 263L) {
#line 2249
                  goto case_263;
                }
#line 2252
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2235
                constraint = 292U;
#line 2236
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2238
                constraint = 448U;
#line 2239
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2241
                constraint = 40U;
#line 2242
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2244
                constraint = 130U;
#line 2245
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2247
                constraint = 170U;
#line 2248
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2250
                constraint = 341U;
#line 2251
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2253
                constraint = 511U;
#line 2254
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2257
                delete___0(i, d->follows + i);
#line 2259
                j = (size_t )0;
                }
                {
#line 2259
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2259
                  if (! (j < (size_t )d->tindex)) {
#line 2259
                    goto while_break___0;
                  }
#line 2260
                  if (i != j) {
#line 2260
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2261
                      replace___0(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2259
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2263
                replace___0(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2265
  free((void *)tmp.elems);
  }
#line 2266
  return;
}
}
#line 2271 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int charclass_context___0(struct dfa  const  *dfa , charclass const   *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2274
  context = 0;
#line 2276
  j = 0U;
  {
#line 2276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2276
    if (! (j < 4U)) {
#line 2276
      goto while_break;
    }
#line 2278
    if (c->w[j] & dfa->syntax.newline.w[j]) {
#line 2279
      context |= 4;
    }
#line 2280
    if (c->w[j] & dfa->syntax.letters.w[j]) {
#line 2281
      context |= 2;
    }
#line 2282
    if (c->w[j] & ~ (dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j])) {
#line 2283
      context |= 1;
    }
#line 2276
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2286
  return (context);
}
}
#line 2295 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts___0(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 2298
  separate_contexts = 0;
#line 2300
  j = (size_t )0;
  {
#line 2300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2300
    if (! (j < (size_t )s->nelem)) {
#line 2300
      goto while_break;
    }
    {
#line 2302
    tmp = prev_newline_dependent___0((int )(s->elems + j)->constraint);
    }
#line 2302
    if (tmp) {
#line 2303
      separate_contexts |= 4;
    }
    {
#line 2304
    tmp___0 = prev_letter_dependent___0((int )(s->elems + j)->constraint);
    }
#line 2304
    if (tmp___0) {
#line 2305
      separate_contexts |= 2;
    }
#line 2300
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2308
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2364 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaanalyze___0(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398___0 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398___0 *stk ;
  position_set merged ;
  void *tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  position_set tmp___3 ;
  position *pos ;
  size_t j ;
  position_set tmp___4 ;
  position *pos___0 ;
  size_t j___0 ;
  position *pos___1 ;
  size_t j___1 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___9 ;
  int tmp___10 ;
  state_num tmp___11 ;
  state_num tmp___12 ;

  {
  {
#line 2368
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2368
  posalloc = (position *)tmp;
#line 2370
  firstpos = posalloc + d->nleaves;
#line 2371
  lastpos = firstpos + d->nleaves;
#line 2374
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2374
  stkalloc = (struct __anonstruct_stkalloc_360611398___0 *)tmp___0;
#line 2374
  stk = stkalloc;
#line 2396
  d->searchflag = searchflag;
#line 2397
  alloc_position_set___0(& merged, d->nleaves);
#line 2398
  tmp___1 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2398
  d->follows = (position_set *)tmp___1;
#line 2400
  i = (size_t )0;
  }
  {
#line 2400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2400
    if (! (i < d->tindex)) {
#line 2400
      goto while_break;
    }
    {
#line 2404
    if (*(d->tokens + i) == 256L) {
#line 2404
      goto case_256;
    }
#line 2414
    if (*(d->tokens + i) == 266L) {
#line 2414
      goto case_266;
    }
#line 2414
    if (*(d->tokens + i) == 265L) {
#line 2414
      goto case_266;
    }
#line 2430
    if (*(d->tokens + i) == 264L) {
#line 2430
      goto case_264;
    }
#line 2436
    if (*(d->tokens + i) == 268L) {
#line 2436
      goto case_268;
    }
#line 2476
    if (*(d->tokens + i) == 269L) {
#line 2476
      goto case_269;
    }
#line 2488
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2406
    stk->nullable = (_Bool)1;
#line 2409
    tmp___2 = (size_t )0;
#line 2409
    stk->nlastpos = tmp___2;
#line 2409
    stk->nfirstpos = tmp___2;
#line 2410
    stk ++;
#line 2411
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2419
    tmp___3.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2420
    tmp___3.elems = firstpos;
#line 2421
    pos = lastpos;
#line 2422
    j = (size_t )0;
    {
#line 2422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2422
      if (! (j < (stk + -1)->nlastpos)) {
#line 2422
        goto while_break___0;
      }
      {
#line 2424
      merge___0((position_set const   *)(& tmp___3), (position_set const   *)(d->follows + (pos + j)->index),
                & merged);
#line 2425
      copy___0((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2422
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2432
    if (*(d->tokens + i) != 266L) {
#line 2433
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2434
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2441
    tmp___4.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2442
    tmp___4.elems = firstpos;
#line 2443
    pos___0 = lastpos + (stk + -1)->nlastpos;
#line 2444
    j___0 = (size_t )0;
    {
#line 2444
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2444
      if (! (j___0 < (stk + -2)->nlastpos)) {
#line 2444
        goto while_break___1;
      }
      {
#line 2446
      merge___0((position_set const   *)(& tmp___4), (position_set const   *)(d->follows + (pos___0 + j___0)->index),
                & merged);
#line 2447
      copy___0((position_set const   *)(& merged), d->follows + (pos___0 + j___0)->index);
#line 2444
      j___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2453
    if ((stk + -2)->nullable) {
#line 2454
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2456
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2460
    if ((stk + -1)->nullable) {
#line 2461
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2464
      pos___1 = lastpos + (stk + -2)->nlastpos;
#line 2465
      j___1 = (stk + -1)->nlastpos;
      {
#line 2465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2465
        tmp___5 = j___1;
#line 2465
        j___1 --;
#line 2465
        if (! (tmp___5 > 0UL)) {
#line 2465
          goto while_break___2;
        }
#line 2466
        *(pos___1 + j___1) = *(lastpos + j___1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2467
      lastpos += (stk + -2)->nlastpos;
#line 2468
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2472
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2473
    stk --;
#line 2474
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2478
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2481
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2484
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2485
    stk --;
#line 2486
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2494
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2497
    tmp___6 = (size_t )1;
#line 2497
    stk->nlastpos = tmp___6;
#line 2497
    stk->nfirstpos = tmp___6;
#line 2498
    stk ++;
#line 2500
    firstpos --;
#line 2500
    lastpos --;
#line 2501
    tmp___7 = i;
#line 2501
    lastpos->index = tmp___7;
#line 2501
    firstpos->index = tmp___7;
#line 2502
    tmp___8 = 511U;
#line 2502
    lastpos->constraint = tmp___8;
#line 2502
    firstpos->constraint = tmp___8;
#line 2504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2549
  merged.nelem = (ptrdiff_t )0;
#line 2550
  i___0 = (size_t )0;
  {
#line 2550
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2550
    if (! (i___0 < (stk + -1)->nfirstpos)) {
#line 2550
      goto while_break___3;
    }
    {
#line 2551
    insert___0(*(firstpos + i___0), & merged);
#line 2550
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2555
  epsclosure___0(& merged, (struct dfa  const  *)d);
#line 2558
  tmp___9 = state_separate_contexts___0((position_set const   *)(& merged));
#line 2558
  separate_contexts = (int )tmp___9;
  }
#line 2561
  if (separate_contexts & 4) {
    {
#line 2562
    state_index___0(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2563
  tmp___11 = state_index___0(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2563
  tmp___10 = (int )tmp___11;
#line 2563
  d->min_trcount = tmp___10;
#line 2563
  d->initstate_notbol = (state_num )tmp___10;
  }
#line 2565
  if (separate_contexts & 2) {
    {
#line 2566
    tmp___12 = state_index___0(d, (position_set const   *)(& merged), 2);
#line 2566
    d->min_trcount = (int )tmp___12;
    }
  }
  {
#line 2567
  (d->min_trcount) ++;
#line 2568
  d->trcount = 0;
#line 2570
  free((void *)posalloc);
#line 2571
  free((void *)stkalloc);
#line 2572
  free((void *)merged.elems);
  }
#line 2573
  return;
}
}
#line 2576 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void realloc_trans_if_necessary___0(struct dfa *d ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc1 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  state_num *tmp___2 ;
  ptrdiff_t newalloc ;
  state_num tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num *tmp___8 ;

  {
#line 2579
  oldalloc = d->tralloc;
#line 2580
  if (oldalloc < d->sindex) {
#line 2582
    if (d->trans) {
#line 2582
      tmp = d->trans - 2;
    } else {
#line 2582
      tmp = (state_num **)((void *)0);
    }
#line 2582
    realtrans = tmp;
#line 2583
    if (realtrans) {
#line 2583
      tmp___0 = d->tralloc + 2L;
    } else {
#line 2583
      tmp___0 = (state_num )0;
    }
    {
#line 2583
    newalloc1 = tmp___0;
#line 2584
    tmp___1 = xpalloc___0((void *)realtrans, & newalloc1, d->sindex - oldalloc, (ptrdiff_t )-1,
                          (ptrdiff_t )sizeof(*realtrans));
#line 2584
    realtrans = (state_num **)tmp___1;
#line 2586
    tmp___2 = (state_num *)((void *)0);
#line 2586
    *(realtrans + 1) = tmp___2;
#line 2586
    *(realtrans + 0) = tmp___2;
#line 2587
    d->trans = realtrans + 2;
#line 2588
    tmp___3 = newalloc1 - 2L;
#line 2588
    d->tralloc = tmp___3;
#line 2588
    newalloc = tmp___3;
#line 2589
    tmp___4 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2589
    d->fails = (state_num **)tmp___4;
#line 2590
    tmp___5 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2590
    d->success = (char *)tmp___5;
#line 2591
    tmp___6 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2591
    d->newlines = (state_num *)tmp___6;
    }
#line 2592
    if (d->localeinfo.multibyte) {
#line 2594
      if (d->mb_trans) {
#line 2594
        realtrans = d->mb_trans - 2;
      } else {
#line 2594
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2595
      tmp___7 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2595
      realtrans = (state_num **)tmp___7;
      }
#line 2596
      if (oldalloc == 0L) {
#line 2597
        tmp___8 = (state_num *)((void *)0);
#line 2597
        *(realtrans + 1) = tmp___8;
#line 2597
        *(realtrans + 0) = tmp___8;
      }
#line 2598
      d->mb_trans = realtrans + 2;
    }
    {
#line 2600
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2600
      if (! (oldalloc < newalloc)) {
#line 2600
        goto while_break;
      }
#line 2602
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2603
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2604
      if (d->localeinfo.multibyte) {
#line 2605
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2600
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2608
  return;
}
}
#line 2643 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num build_state___0(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  state_num **ptrans ;
  state_num **tmp___1 ;
  _Bool tmp___2 ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___3 ;
  void *tmp___4 ;
  int i___0 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  leaf_set group ;
  void *tmp___8 ;
  charclass label___0 ;
  size_t i___1 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  size_t j ;
  _Bool tmp___11 ;
  size_t j___0 ;
  _Bool tmp___12 ;
  size_t j___1 ;
  _Bool tmp___13 ;
  size_t j___2 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  size_t k ;
  size_t tmp___17 ;
  size_t k___0 ;
  size_t j___3 ;
  size_t k___1 ;
  _Bool mergeit ;
  size_t j___4 ;
  int possible_contexts ;
  int tmp___18 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___19 ;
  size_t i___2 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  {
#line 2657
  tmp___2 = accepting___0(s, (struct dfa  const  *)d);
  }
#line 2657
  if (tmp___2) {
#line 2657
    tmp___1 = d->fails;
  } else {
#line 2657
    tmp___1 = d->trans;
  }
#line 2657
  ptrans = tmp___1 + s;
#line 2658
  trans = *ptrans;
#line 2660
  if (! trans) {
#line 2666
    if (1024 <= d->trcount) {
#line 2668
      i = (state_num )d->min_trcount;
      {
#line 2668
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2668
        if (! (i < d->tralloc)) {
#line 2668
          goto while_break;
        }
        {
#line 2670
        free((void *)*(d->trans + i));
#line 2671
        free((void *)*(d->fails + i));
#line 2672
        tmp___3 = (state_num *)((void *)0);
#line 2672
        *(d->fails + i) = tmp___3;
#line 2672
        *(d->trans + i) = tmp___3;
#line 2668
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2674
      d->trcount = 0;
    }
    {
#line 2677
    (d->trcount) ++;
#line 2678
    tmp___4 = xmalloc(256UL * sizeof(*trans));
#line 2678
    trans = (state_num *)tmp___4;
#line 2678
    *ptrans = trans;
#line 2682
    i___0 = 0;
    }
    {
#line 2682
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2682
      if (! (i___0 < 256)) {
#line 2682
        goto while_break___0;
      }
#line 2683
      *(trans + i___0) = (state_num )-2;
#line 2682
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2687
  *(d->success + s) = (char)0;
#line 2688
  tmp___5 = accepts_in_context___0((int )(d->states + s)->context, 4, s, (struct dfa  const  *)d);
  }
#line 2688
  if (tmp___5) {
#line 2689
    *(d->success + s) = (char )((int )*(d->success + s) | 4);
  }
  {
#line 2690
  tmp___6 = accepts_in_context___0((int )(d->states + s)->context, 2, s, (struct dfa  const  *)d);
  }
#line 2690
  if (tmp___6) {
#line 2691
    *(d->success + s) = (char )((int )*(d->success + s) | 2);
  }
  {
#line 2692
  tmp___7 = accepts_in_context___0((int )(d->states + s)->context, 1, s, (struct dfa  const  *)d);
  }
#line 2692
  if (tmp___7) {
#line 2693
    *(d->success + s) = (char )((int )*(d->success + s) | 1);
  }
  {
#line 2697
  tmp___8 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2697
  group.elems = (size_t *)tmp___8;
#line 2698
  group.nelem = (size_t )0;
#line 2702
  fillset___0(& label___0);
#line 2704
  i___1 = (size_t )0;
  }
  {
#line 2704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2704
    if (! (i___1 < (size_t )(d->states + s)->elems.nelem)) {
#line 2704
      goto while_break___1;
    }
#line 2707
    pos = *((d->states + s)->elems.elems + i___1);
#line 2708
    matched = (_Bool)0;
#line 2709
    if (*(d->tokens + pos.index) >= 0L) {
#line 2709
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2711
        zeroset___0(& matches);
#line 2712
        setbit___0((unsigned int )*(d->tokens + pos.index), & matches);
        }
#line 2713
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2714
          matched = (_Bool)1;
        }
      } else {
#line 2709
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2716
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2718
      matches = *(d->charclasses + (*(d->tokens + pos.index) - 275L));
#line 2719
      tmp___9 = tstbit___0((unsigned int )uc, (charclass const   *)(d->charclasses + (*(d->tokens + pos.index) - 275L)));
      }
#line 2719
      if (tmp___9) {
#line 2720
        matched = (_Bool)1;
      }
    } else
#line 2722
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2724
      matches = *(d->charclasses + d->canychar);
#line 2725
      tmp___10 = tstbit___0((unsigned int )uc, (charclass const   *)(d->charclasses + d->canychar));
      }
#line 2725
      if (tmp___10) {
#line 2726
        matched = (_Bool)1;
      }
      {
#line 2734
      tmp___11 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         1);
      }
#line 2734
      if (tmp___11) {
#line 2737
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2738
          alloc_position_set___0(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2740
        j = (size_t )0;
        {
#line 2740
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2740
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2740
            goto while_break___2;
          }
          {
#line 2741
          insert___0(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2740
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 2745
      goto __Cont;
    }
#line 2749
    if (pos.constraint != 511U) {
      {
#line 2751
      tmp___12 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         4);
      }
#line 2751
      if (! tmp___12) {
#line 2753
        j___0 = (size_t )0;
        {
#line 2753
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2753
          if (! (j___0 < 4UL)) {
#line 2753
            goto while_break___3;
          }
#line 2754
          matches.w[j___0] &= ~ d->syntax.newline.w[j___0];
#line 2753
          j___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 2755
      tmp___13 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         2);
      }
#line 2755
      if (! tmp___13) {
#line 2757
        j___1 = (size_t )0;
        {
#line 2757
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2757
          if (! (j___1 < 4UL)) {
#line 2757
            goto while_break___4;
          }
#line 2758
          matches.w[j___1] &= ~ d->syntax.letters.w[j___1];
#line 2757
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2759
      tmp___14 = succeeds_in_context___0((int )pos.constraint, (int )(d->states + s)->context,
                                         1);
      }
#line 2759
      if (! tmp___14) {
#line 2761
        j___2 = (size_t )0;
        {
#line 2761
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2761
          if (! (j___2 < 4UL)) {
#line 2761
            goto while_break___5;
          }
#line 2762
          matches.w[j___2] &= d->syntax.letters.w[j___2] | d->syntax.newline.w[j___2];
#line 2761
          j___2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2765
      tmp___15 = emptyset___0((charclass const   *)(& matches));
      }
#line 2765
      if (tmp___15) {
#line 2766
        goto __Cont;
      }
      {
#line 2771
      tmp___16 = tstbit___0((unsigned int )uc, (charclass const   *)(& matches));
      }
#line 2771
      if (! tmp___16) {
#line 2772
        matched = (_Bool)0;
      }
    }
#line 2785
    if (matched) {
#line 2787
      k = (size_t )0;
      {
#line 2787
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2787
        if (! (k < 4UL)) {
#line 2787
          goto while_break___6;
        }
#line 2788
        label___0.w[k] &= matches.w[k];
#line 2787
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2789
      tmp___17 = group.nelem;
#line 2789
      (group.nelem) ++;
#line 2789
      *(group.elems + tmp___17) = pos.index;
    } else {
#line 2793
      k___0 = (size_t )0;
      {
#line 2793
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2793
        if (! (k___0 < 4UL)) {
#line 2793
          goto while_break___7;
        }
#line 2794
        label___0.w[k___0] &= ~ matches.w[k___0];
#line 2793
        k___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2704
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2798
  alloc_position_set___0(& follows, d->nleaves);
#line 2799
  alloc_position_set___0(& tmp, d->nleaves);
  }
#line 2801
  if (group.nelem > 0UL) {
#line 2803
    follows.nelem = (ptrdiff_t )0;
#line 2807
    j___3 = (size_t )0;
    {
#line 2807
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2807
      if (! (j___3 < group.nelem)) {
#line 2807
        goto while_break___8;
      }
#line 2808
      k___1 = (size_t )0;
      {
#line 2808
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2808
        if (! (k___1 < (size_t )(d->follows + *(group.elems + j___3))->nelem)) {
#line 2808
          goto while_break___9;
        }
        {
#line 2809
        insert___0(*((d->follows + *(group.elems + j___3))->elems + k___1), & follows);
#line 2808
        k___1 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2807
      j___3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2813
    if (d->searchflag) {
#line 2832
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2833
      if (! mergeit) {
#line 2835
        mergeit = (_Bool)1;
#line 2836
        j___4 = (size_t )0;
        {
#line 2836
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2836
          if (mergeit) {
#line 2836
            if (! (j___4 < (size_t )follows.nelem)) {
#line 2836
              goto while_break___10;
            }
          } else {
#line 2836
            goto while_break___10;
          }
#line 2837
          mergeit = (_Bool )((int )mergeit & (int )*(d->multibyte_prop + (follows.elems + j___4)->index));
#line 2836
          j___4 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2839
      if (mergeit) {
        {
#line 2841
        merge___0((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
                  & tmp);
#line 2842
        copy___0((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2849
    tmp___18 = charclass_context___0((struct dfa  const  *)d, (charclass const   *)(& label___0));
#line 2849
    possible_contexts = tmp___18;
#line 2850
    tmp___19 = state_separate_contexts___0((position_set const   *)(& follows));
#line 2850
    separate_contexts = (int )tmp___19;
    }
#line 2853
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2854
      state = state_index___0(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2856
      state = (state_num )-1;
    }
#line 2857
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2858
      state_newline = state_index___0(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2860
      state_newline = state;
    }
#line 2861
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2862
      state_letter = state_index___0(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2864
      state_letter = state;
    }
    {
#line 2867
    realloc_trans_if_necessary___0(d);
    }
  } else
#line 2873
  if (d->searchflag) {
#line 2875
    state_newline = (state_num )0;
#line 2876
    state_letter = (state_num )(d->min_trcount - 1);
#line 2877
    state = d->initstate_notbol;
  } else {
#line 2881
    state_newline = (state_num )-1;
#line 2882
    state_letter = (state_num )-1;
#line 2883
    state = (state_num )-1;
  }
#line 2887
  i___2 = (size_t )0;
  {
#line 2887
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2887
    if (! (i___2 < 256UL)) {
#line 2887
      goto while_break___11;
    }
    {
#line 2888
    tmp___20 = tstbit___0((unsigned int )i___2, (charclass const   *)(& label___0));
    }
#line 2888
    if (tmp___20) {
      {
#line 2891
      if ((int )d->syntax.sbit[i___2] == 4) {
#line 2891
        goto case_4;
      }
#line 2894
      if ((int )d->syntax.sbit[i___2] == 2) {
#line 2894
        goto case_2;
      }
#line 2897
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2892
      *(trans + i___2) = state_newline;
#line 2893
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2895
      *(trans + i___2) = state_letter;
#line 2896
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2898
      *(trans + i___2) = state;
#line 2899
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2887
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2913
  free((void *)group.elems);
#line 2914
  free((void *)follows.elems);
#line 2915
  free((void *)tmp.elems);
#line 2919
  tmp___21 = tstbit___0((unsigned int )d->syntax.eolbyte, (charclass const   *)(& label___0));
  }
#line 2919
  if (tmp___21) {
#line 2921
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2922
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2925
  return (*(trans + uc));
}
}
#line 2934 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num transit_state_singlebyte___0(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2939
  if (*(d->trans + s)) {
#line 2940
    t = *(d->trans + s);
  } else
#line 2941
  if (*(d->fails + s)) {
#line 2942
    t = *(d->fails + s);
  } else {
    {
#line 2945
    build_state___0(s, d, (unsigned char )*(*pp));
    }
#line 2946
    if (*(d->trans + s)) {
#line 2947
      t = *(d->trans + s);
    } else {
#line 2950
      t = *(d->fails + s);
#line 2951
      if (! t) {
        {
#line 2951
        __assert_fail("t", "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c", 2951U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2955
  if (*(t + *(*pp)) == -2L) {
    {
#line 2956
    build_state___0(s, d, (unsigned char )*(*pp));
    }
  }
#line 2958
  tmp___0 = *pp;
#line 2958
  (*pp) ++;
#line 2958
  return (*(t + *tmp___0));
}
}
#line 2964 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static state_num transit_state___0(struct dfa *d , state_num s , unsigned char const   **pp ,
                                   unsigned char const   *end ) 
{ 
  wint_t wc ;
  int mbclen ;
  size_t tmp ;
  state_num s1 ;
  int mbci ;
  state_num s3 ;
  state_num i ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  int separate_contexts ;
  int __attribute__((__pure__))  tmp___2 ;
  state_num s2 ;
  state_num tmp___3 ;

  {
  {
#line 2970
  tmp = mbs_to_wchar___0(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2970
  mbclen = (int )tmp;
#line 2973
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 2977
  s1 = s;
#line 2979
  mbci = 0;
  }
  {
#line 2979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2979
    if (mbci < mbclen) {
#line 2979
      if (! (mbci == 0)) {
#line 2979
        if (! ((state_num )d->min_trcount <= s)) {
#line 2979
          goto while_break;
        }
      }
    } else {
#line 2979
      goto while_break;
    }
    {
#line 2980
    s = transit_state_singlebyte___0(d, s, pp);
#line 2979
    mbci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2981
  *pp += mbclen - mbci;
#line 2983
  if (wc == 4294967295U) {
#line 2986
    return (s);
  }
#line 2992
  if ((d->states + s1)->mb_trindex < 0L) {
#line 2994
    if (1024L <= d->mb_trcount) {
#line 2997
      s3 = (state_num )-1;
      {
#line 2997
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2997
        if (! (s3 < d->tralloc)) {
#line 2997
          goto while_break___0;
        }
        {
#line 2999
        free((void *)*(d->mb_trans + s3));
#line 3000
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 2997
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3003
      i = (state_num )0;
      {
#line 3003
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3003
        if (! (i < d->sindex)) {
#line 3003
          goto while_break___1;
        }
#line 3004
        (d->states + i)->mb_trindex = (state_num )-1;
#line 3003
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3005
      d->mb_trcount = (state_num )0;
    }
#line 3007
    tmp___0 = d->mb_trcount;
#line 3007
    (d->mb_trcount) ++;
#line 3007
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3010
  if (! *(d->mb_trans + s)) {
    {
#line 3014
    tmp___1 = xmalloc((size_t )8192);
#line 3014
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3015
    i___0 = 0;
    }
    {
#line 3015
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3015
      if (! (i___0 < 1024)) {
#line 3015
        goto while_break___2;
      }
#line 3016
      *(*(d->mb_trans + s) + i___0) = (state_num )-1;
#line 3015
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3018
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3019
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3021
  if (s == -1L) {
    {
#line 3022
    copy___0((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3024
    merge___0((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
              & d->mb_follows);
    }
  }
  {
#line 3026
  tmp___2 = state_separate_contexts___0((position_set const   *)(& d->mb_follows));
#line 3026
  separate_contexts = (int )tmp___2;
#line 3027
  tmp___3 = state_index___0(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3027
  s2 = tmp___3;
#line 3028
  realloc_trans_if_necessary___0(d);
#line 3030
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3032
  return (s2);
}
}
#line 3050 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static unsigned char const   *skip_remains_mb___0(struct dfa *d , unsigned char const   *p ,
                                                  unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3054
  if (d->syntax.never_trail[*p]) {
#line 3055
    return (p);
  }
  {
#line 3056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3056
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3056
      goto while_break;
    }
    {
#line 3059
    tmp = mbs_to_wchar___0(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                           d);
#line 3059
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3062
  return (mbp);
}
}
#line 3085 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
__inline static char *dfaexec_main___0(struct dfa *d , char const   *begin , char *end ,
                                       _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s___0 ;
  state_num *tmp ;
  state_num s___1 ;
  state_num s___2 ;
  state_num s___3 ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  _Bool tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 3089
  if (1024L <= d->sindex) {
#line 3091
    s = (state_num )d->min_trcount;
    {
#line 3091
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3091
      if (! (s < d->sindex)) {
#line 3091
        goto while_break;
      }
      {
#line 3093
      free((void *)(d->states + s)->elems.elems);
#line 3094
      free((void *)(d->states + s)->mbps.elems);
#line 3091
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3096
    d->sindex = (state_num )d->min_trcount;
#line 3098
    if (d->trans) {
#line 3100
      s___0 = (state_num )0;
      {
#line 3100
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3100
        if (! (s___0 < d->tralloc)) {
#line 3100
          goto while_break___0;
        }
        {
#line 3102
        free((void *)*(d->trans + s___0));
#line 3103
        free((void *)*(d->fails + s___0));
#line 3104
        tmp = (state_num *)((void *)0);
#line 3104
        *(d->fails + s___0) = tmp;
#line 3104
        *(d->trans + s___0) = tmp;
#line 3100
        s___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3106
      d->trcount = 0;
    }
#line 3109
    if (d->localeinfo.multibyte) {
#line 3109
      if (d->mb_trans) {
#line 3111
        s___1 = (state_num )-1;
        {
#line 3111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3111
          if (! (s___1 < d->tralloc)) {
#line 3111
            goto while_break___1;
          }
          {
#line 3113
          free((void *)*(d->mb_trans + s___1));
#line 3114
          *(d->mb_trans + s___1) = (state_num *)((void *)0);
#line 3111
          s___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3116
        s___2 = (state_num )0;
        {
#line 3116
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3116
          if (! (s___2 < (state_num )d->min_trcount)) {
#line 3116
            goto while_break___2;
          }
#line 3117
          (d->states + s___2)->mb_trindex = (state_num )-1;
#line 3116
          s___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3118
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3122
  if (! d->tralloc) {
    {
#line 3123
    realloc_trans_if_necessary___0(d);
    }
  }
#line 3126
  s___3 = (state_num )0;
#line 3126
  s1 = (state_num )0;
#line 3129
  p = (unsigned char const   *)begin;
#line 3130
  mbp = p;
#line 3133
  trans = d->trans;
#line 3134
  eol = d->syntax.eolbyte;
#line 3135
  saved_end = *((unsigned char *)end);
#line 3136
  *end = (char )eol;
#line 3138
  if (multibyte) {
    {
#line 3140
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3141
    if (d->mb_follows.alloc == 0L) {
      {
#line 3142
      alloc_position_set___0(& d->mb_follows, d->nleaves);
      }
    }
  }
#line 3145
  nlcount = (size_t )0;
  {
#line 3146
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3149
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3149
      t = *(trans + s___3);
#line 3149
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3149
        goto while_break___4;
      }
#line 3151
      if (s___3 < (state_num )d->min_trcount) {
#line 3153
        if (! multibyte) {
#line 3153
          goto _L;
        } else
#line 3153
        if ((d->states + s___3)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3155
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3155
            if (! (*(t + *p) == s___3)) {
#line 3155
              goto while_break___5;
            }
#line 3156
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3158
        if (multibyte) {
          {
#line 3159
          mbp = skip_remains_mb___0(d, p, mbp, (char const   *)end);
#line 3159
          p = mbp;
          }
        }
      }
#line 3162
      if (multibyte) {
#line 3164
        s1 = s___3;
#line 3166
        if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else
#line 3166
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else
#line 3166
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3171
          tmp___0 = p;
#line 3171
          p ++;
#line 3171
          s___3 = *(t + *tmp___0);
        } else {
          {
#line 3175
          s___3 = transit_state___0(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3176
          mbp = p;
#line 3177
          trans = d->trans;
          }
        }
      } else {
#line 3182
        tmp___1 = p;
#line 3182
        p ++;
#line 3182
        s1 = *(t + *tmp___1);
#line 3183
        t = *(trans + s1);
#line 3184
        if (! t) {
#line 3186
          tmp___2 = s___3;
#line 3187
          s___3 = s1;
#line 3188
          s1 = tmp___2;
#line 3189
          goto while_break___4;
        }
#line 3191
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3193
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3193
            if (! (*(t + *p) == s1)) {
#line 3193
              goto while_break___6;
            }
#line 3194
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3196
        tmp___3 = p;
#line 3196
        p ++;
#line 3196
        s___3 = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3200
    if (s___3 < 0L) {
#line 3202
      if (s___3 == -2L) {
        {
#line 3204
        s___3 = build_state___0(s1, d, (unsigned char )*(p + -1));
#line 3205
        trans = d->trans;
        }
      } else
#line 3207
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3207
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3207
          if (0L <= *(d->newlines + s1)) {
#line 3211
            nlcount ++;
#line 3212
            mbp = p;
#line 3214
            if (allow_nl) {
#line 3214
              s___3 = *(d->newlines + s1);
            } else {
#line 3214
              if ((int )d->syntax.sbit[eol] == 4) {
#line 3214
                tmp___5 = (state_num )0;
              } else {
#line 3214
                if ((int )d->syntax.sbit[eol] == 2) {
#line 3214
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3214
                  tmp___4 = d->initstate_notbol;
                }
#line 3214
                tmp___5 = tmp___4;
              }
#line 3214
              s___3 = tmp___5;
            }
          } else {
#line 3221
            p = (unsigned char const   *)((void *)0);
#line 3222
            goto done;
          }
        } else {
#line 3221
          p = (unsigned char const   *)((void *)0);
#line 3222
          goto done;
        }
      } else {
#line 3221
        p = (unsigned char const   *)((void *)0);
#line 3222
        goto done;
      }
    } else
#line 3225
    if (*(d->fails + s___3)) {
#line 3227
      if ((int )*(d->success + s___3) & (int )d->syntax.sbit[*p]) {
#line 3231
        goto done;
      } else
#line 3227
      if ((unsigned long )((char *)p) == (unsigned long )end) {
        {
#line 3227
        tmp___6 = accepts_in_context___0((int )(d->states + s___3)->context, 4, s___3,
                                         (struct dfa  const  *)d);
        }
#line 3227
        if (tmp___6) {
#line 3231
          goto done;
        }
      }
#line 3233
      if (multibyte) {
#line 3233
        if (s___3 < (state_num )d->min_trcount) {
          {
#line 3234
          mbp = skip_remains_mb___0(d, p, mbp, (char const   *)end);
#line 3234
          p = mbp;
          }
        }
      }
#line 3236
      s1 = s___3;
#line 3237
      if (! multibyte) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if ((d->states + s___3)->mbps.nelem == 0L) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else
#line 3237
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3242
        tmp___7 = p;
#line 3242
        p ++;
#line 3242
        s___3 = *(*(d->fails + s___3) + *tmp___7);
      } else {
        {
#line 3246
        s___3 = transit_state___0(d, s___3, & p, (unsigned char const   *)((unsigned char *)end));
#line 3247
        mbp = p;
#line 3248
        trans = d->trans;
        }
      }
    } else {
      {
#line 3253
      build_state___0(s___3, d, (unsigned char )*(p + 0));
#line 3254
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3259
  if (count) {
#line 3260
    *count += nlcount;
  }
#line 3261
  *end = (char )saved_end;
#line 3262
  return ((char *)p);
}
}
#line 3268 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_mb___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                            size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3272
  tmp = dfaexec_main___0(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3272
  return (tmp);
}
}
#line 3275 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_sb___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                            size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3279
  tmp = dfaexec_main___0(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3279
  return (tmp);
}
}
#line 3284 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *dfaexec_noop___0(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                              size_t *count , _Bool *backref ) 
{ 


  {
#line 3288
  *backref = (_Bool)1;
#line 3289
  return ((char *)begin);
}
}
#line 3315 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void free_mbdata___0(struct dfa *d ) 
{ 
  state_num s ;

  {
  {
#line 3318
  free((void *)d->multibyte_prop);
#line 3319
  free((void *)d->lex.brack.chars);
#line 3320
  free((void *)d->mb_follows.elems);
  }
#line 3322
  if (d->mb_trans) {
#line 3325
    s = (state_num )-1;
    {
#line 3325
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3325
      if (! (s < d->tralloc)) {
#line 3325
        goto while_break;
      }
      {
#line 3326
      free((void *)*(d->mb_trans + s));
#line 3325
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3327
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3329
  return;
}
}
#line 3332 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported___0(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3335
  i = (size_t )0;
  {
#line 3335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3335
    if (! (i < (size_t )d->tindex)) {
#line 3335
      goto while_break;
    }
    {
#line 3342
    if (*(d->tokens + i) == 263L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 262L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 261L) {
#line 3342
      goto case_263;
    }
#line 3342
    if (*(d->tokens + i) == 260L) {
#line 3342
      goto case_263;
    }
#line 3348
    if (*(d->tokens + i) == 273L) {
#line 3348
      goto case_273;
    }
#line 3348
    if (*(d->tokens + i) == 257L) {
#line 3348
      goto case_273;
    }
#line 3337
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3343
    if (! d->localeinfo.multibyte) {
#line 3344
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3349
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3352
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3355 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfaoptimize___0(struct dfa *d ) 
{ 
  _Bool have_backref ;
  size_t i ;

  {
#line 3358
  if (! d->localeinfo.using_utf8) {
#line 3359
    return;
  }
#line 3361
  have_backref = (_Bool)0;
#line 3362
  i = (size_t )0;
  {
#line 3362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3362
    if (! (i < d->tindex)) {
#line 3362
      goto while_break;
    }
    {
#line 3366
    if (*(d->tokens + i) == 272L) {
#line 3366
      goto case_272;
    }
#line 3369
    if (*(d->tokens + i) == 257L) {
#line 3369
      goto case_257;
    }
#line 3372
    if (*(d->tokens + i) == 273L) {
#line 3372
      goto case_273;
    }
#line 3375
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3368
    abort();
    }
    case_257: /* CIL Label */ 
#line 3370
    have_backref = (_Bool)1;
#line 3371
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3374
    return;
    switch_default: /* CIL Label */ 
#line 3376
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3380
  if (! have_backref) {
#line 3380
    if (d->superset) {
      {
#line 3383
      dfafree(d->superset);
#line 3384
      free((void *)d->superset);
#line 3385
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3388
  free_mbdata___0(d);
#line 3389
  d->localeinfo.multibyte = (_Bool)0;
#line 3390
  d->dfaexec = & dfaexec_sb___0;
#line 3391
  d->fast = (_Bool)1;
  }
#line 3392
  return;
}
}
#line 3394 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void dfassbuild___0(struct dfa *d ) 
{ 
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  _Bool have_achar ;
  _Bool have_nchar ;
  size_t j ;
  size_t i ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3397
  tmp = dfaalloc();
#line 3397
  sup = tmp;
#line 3399
  *sup = *d;
#line 3400
  sup->localeinfo.multibyte = (_Bool)0;
#line 3401
  sup->dfaexec = & dfaexec_sb___0;
#line 3402
  sup->multibyte_prop = (char *)((void *)0);
#line 3403
  sup->superset = (struct dfa *)((void *)0);
#line 3404
  sup->states = (dfa_state *)((void *)0);
#line 3405
  sup->sindex = (state_num )0;
#line 3406
  sup->follows = (position_set *)((void *)0);
#line 3407
  sup->tralloc = (state_num )0;
#line 3408
  sup->trans = (state_num **)((void *)0);
#line 3409
  sup->fails = (state_num **)((void *)0);
#line 3410
  sup->success = (char *)((void *)0);
#line 3411
  sup->newlines = (state_num *)((void *)0);
#line 3413
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3413
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3414
  if (d->cindex) {
    {
#line 3416
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3420
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3420
  sup->tokens = (token *)tmp___1;
#line 3421
  sup->talloc = d->tindex * 2UL;
#line 3423
  have_achar = (_Bool)0;
#line 3424
  have_nchar = (_Bool)0;
#line 3426
  j = (size_t )0;
#line 3426
  i = j;
  }
  {
#line 3426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3426
    if (! (i < d->tindex)) {
#line 3426
      goto while_break;
    }
    {
#line 3432
    if (*(d->tokens + i) == 257L) {
#line 3432
      goto case_257;
    }
#line 3432
    if (*(d->tokens + i) == 273L) {
#line 3432
      goto case_257;
    }
#line 3432
    if (*(d->tokens + i) == 272L) {
#line 3432
      goto case_257;
    }
#line 3447
    if (*(d->tokens + i) == 263L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 262L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 261L) {
#line 3447
      goto case_263;
    }
#line 3447
    if (*(d->tokens + i) == 260L) {
#line 3447
      goto case_263;
    }
#line 3456
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3435
    fillset___0(& ccl);
#line 3436
    tmp___2 = j;
#line 3436
    j ++;
#line 3436
    tmp___3 = charclass_index___0(sup, & ccl);
#line 3436
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3437
    tmp___4 = j;
#line 3437
    j ++;
#line 3437
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3438
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3440
      i ++;
    } else
#line 3438
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3440
      i ++;
    } else
#line 3438
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3440
      i ++;
    }
#line 3441
    have_achar = (_Bool)1;
#line 3443
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3448
    if (d->localeinfo.multibyte) {
#line 3452
      tmp___5 = j;
#line 3452
      j ++;
#line 3452
      *(sup->tokens + tmp___5) = (token )256;
#line 3453
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3457
    tmp___6 = j;
#line 3457
    j ++;
#line 3457
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3458
    if (0L <= *(d->tokens + i)) {
#line 3458
      if (*(d->tokens + i) < 256L) {
#line 3460
        have_nchar = (_Bool)1;
      } else {
#line 3458
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3458
    if (*(d->tokens + i) >= 275L) {
#line 3460
      have_nchar = (_Bool)1;
    }
#line 3461
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3464
  sup->tindex = j;
#line 3466
  if (have_nchar) {
#line 3466
    if (have_achar) {
#line 3467
      d->superset = sup;
    } else
#line 3466
    if (d->localeinfo.multibyte) {
#line 3467
      d->superset = sup;
    } else {
      {
#line 3470
      dfafree(sup);
#line 3471
      free((void *)sup);
      }
    }
  } else {
    {
#line 3470
    dfafree(sup);
#line 3471
    free((void *)sup);
    }
  }
#line 3473
  return;
}
}
#line 3623 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char *icatalloc___0(char *old , char const   *new ) 
{ 
  size_t newsize ;
  size_t tmp ;
  size_t oldsize ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 3626
  tmp = strlen(new);
#line 3626
  newsize = tmp;
  }
#line 3627
  if (newsize == 0UL) {
#line 3628
    return (old);
  }
  {
#line 3629
  tmp___0 = strlen((char const   *)old);
#line 3629
  oldsize = tmp___0;
#line 3630
  tmp___1 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3630
  result = (char *)tmp___1;
#line 3631
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3632
  return (result);
}
}
#line 3635 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void freelist___0(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3638
    if (! *cpp) {
#line 3638
      goto while_break;
    }
    {
#line 3639
    tmp = cpp;
#line 3639
    cpp ++;
#line 3639
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3640
  return;
}
}
#line 3642 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **enlist___0(char **cpp , char *new , size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t i ;
  char *tmp___1 ;
  size_t j ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3645
  tmp = xmalloc(len + 1UL);
#line 3645
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3645
  new = (char *)tmp___0;
#line 3646
  *(new + len) = (char )'\000';
#line 3649
  i = (size_t )0;
  }
  {
#line 3649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3649
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3649
      goto while_break;
    }
    {
#line 3650
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3650
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3652
      free((void *)new);
      }
#line 3653
      return (cpp);
    }
#line 3649
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3656
  j = (size_t )0;
  {
#line 3656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3656
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3656
      goto while_break___0;
    }
    {
#line 3657
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3657
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3658
      j ++;
    } else {
      {
#line 3661
      free((void *)*(cpp + j));
#line 3662
      i --;
      }
#line 3662
      if (i == j) {
#line 3663
        goto while_break___0;
      }
#line 3664
      *(cpp + j) = *(cpp + i);
#line 3665
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3668
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3668
  cpp = (char **)tmp___3;
#line 3669
  *(cpp + i) = new;
#line 3670
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3671
  return (cpp);
}
}
#line 3676 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **comsubs___0(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3679
  tmp = xzalloc(sizeof(*cpp));
#line 3679
  cpp = (char **)tmp;
#line 3681
  lcp = left;
  }
  {
#line 3681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3681
    if (! ((int )*lcp != 0)) {
#line 3681
      goto while_break;
    }
    {
#line 3683
    len = (size_t )0;
#line 3684
    tmp___0 = strchr(right, (int )*lcp);
#line 3684
    rcp = tmp___0;
    }
    {
#line 3685
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3685
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3685
        goto while_break___0;
      }
#line 3688
      i = (size_t )1;
      {
#line 3688
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3688
        if ((int )*(lcp + i) != 0) {
#line 3688
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3688
            goto while_break___1;
          }
        } else {
#line 3688
          goto while_break___1;
        }
#line 3689
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3688
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3690
      if (i > len) {
#line 3691
        len = i;
      }
      {
#line 3692
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3694
    if (len != 0UL) {
      {
#line 3695
      cpp = enlist___0(cpp, lcp, len);
      }
    }
#line 3681
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3697
  return (cpp);
}
}
#line 3700 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **addlists___0(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3703
    if (! *new) {
#line 3703
      goto while_break;
    }
    {
#line 3704
    tmp = strlen((char const   *)*new);
#line 3704
    old = enlist___0(old, *new, tmp);
#line 3703
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3705
  return (old);
}
}
#line 3710 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static char **inboth___0(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3713
  tmp = xzalloc(sizeof(*both));
#line 3713
  both = (char **)tmp;
#line 3715
  lnum = (size_t )0;
  }
  {
#line 3715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3715
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3715
      goto while_break;
    }
#line 3717
    rnum = (size_t )0;
    {
#line 3717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3717
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3717
        goto while_break___0;
      }
      {
#line 3719
      tmp___0 = comsubs___0(*(left + lnum), (char const   *)*(right + rnum));
#line 3719
      temp = tmp___0;
#line 3720
      both = addlists___0(both, temp);
#line 3721
      freelist___0(temp);
#line 3722
      free((void *)temp);
#line 3717
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3715
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3725
  return (both);
}
}
#line 3741 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static must *allocmust___0(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3744
  tmp = xmalloc(sizeof(*new_mp));
#line 3744
  new_mp = (must *)tmp;
#line 3745
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3745
  new_mp->in = (char **)tmp___0;
#line 3746
  tmp___1 = xzalloc(size);
#line 3746
  new_mp->left = (char *)tmp___1;
#line 3747
  tmp___2 = xzalloc(size);
#line 3747
  new_mp->right = (char *)tmp___2;
#line 3748
  tmp___3 = xzalloc(size);
#line 3748
  new_mp->is = (char *)tmp___3;
#line 3749
  new_mp->begline = (_Bool)0;
#line 3750
  new_mp->endline = (_Bool)0;
#line 3751
  new_mp->prev = mp;
  }
#line 3752
  return (new_mp);
}
}
#line 3755 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void resetmust___0(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3758
  freelist___0(mp->in);
#line 3759
  *(mp->in + 0) = (char *)((void *)0);
#line 3760
  tmp___0 = (char )'\000';
#line 3760
  *(mp->is + 0) = tmp___0;
#line 3760
  tmp = tmp___0;
#line 3760
  *(mp->right + 0) = tmp;
#line 3760
  *(mp->left + 0) = tmp;
#line 3761
  mp->begline = (_Bool)0;
#line 3762
  mp->endline = (_Bool)0;
  }
#line 3763
  return;
}
}
#line 3765 "/home/khheo/project/benchmark/grep-3.0/lib/dfa.c"
static void freemust___0(must *mp ) 
{ 


  {
  {
#line 3768
  freelist___0(mp->in);
#line 3769
  free((void *)mp->in);
#line 3770
  free((void *)mp->left);
#line 3771
  free((void *)mp->right);
#line 3772
  free((void *)mp->is);
#line 3773
  free((void *)mp);
  }
#line 3774
  return;
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/cycle-check.c"
static _Bool is_zero_or_power_of_two___0(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 22 "./colorize-posix.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
static char const   *file_name___0  ;
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/closeout.c"
static _Bool ignore_EPIPE___0  ;
#line 141 "./unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 46 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static void cdb_init___0(struct cd_buf *cdb ) 
{ 


  {
#line 49
  cdb->fd = -100;
#line 50
  return;
}
}
#line 52 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static int cdb_fchdir___0(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = fchdir((int )cdb->fd);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static void cdb_free___0(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 61
  if (0 <= (int )cdb->fd) {
    {
#line 63
    tmp = close((int )cdb->fd);
#line 63
    close_fail = (_Bool )tmp;
    }
#line 64
    if (! (! close_fail)) {
      {
#line 64
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c",
                    64U, "cdb_free");
      }
    }
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static int cdb_advance_fd___0(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 75
  tmp = openat(cdb->fd, dir, 67840);
#line 75
  new_fd = tmp;
  }
#line 77
  if (new_fd < 0) {
#line 78
    return (-1);
  }
  {
#line 80
  cdb_free___0((struct cd_buf  const  *)cdb);
#line 81
  cdb->fd = new_fd;
  }
#line 83
  return (0);
}
}
#line 87 "/home/khheo/project/benchmark/grep-3.0/lib/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash___0(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 90
  tmp = strspn(s, "/");
#line 90
  n_slash = tmp;
  }
#line 91
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 31
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 31
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/grep-3.0/lib/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/grep-3.0/lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 61 "/home/khheo/project/benchmark/grep-3.0/lib/argmatch.c"
static void __argmatch_die___0(void) 
{ 


  {
  {
#line 64
  usage(1);
  }
#line 65
  return;
}
}
#line 80 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 64 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
__inline unsigned char to_uchar(char ch ) 
{ 


  {
#line 67
  return ((unsigned char )ch);
}
}
#line 70
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
_Bool match_icase ;
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/kwset.h"
kwset_t kwsalloc(char const   *trans ) ;
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 49
void wordinit(void) ;
#line 50
kwset_t kwsinit(_Bool mb_trans ) ;
#line 51
size_t wordchars_size(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 52
size_t wordchar_next(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 53
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end )  __attribute__((__pure__)) ;
#line 55
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end ) ;
#line 70
struct localeinfo localeinfo ;
#line 77 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
__inline size_t mb_clen(char const   *s , size_t n , mbstate_t *mbs ) 
{ 
  size_t len ;
  unsigned char tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 80
  tmp = to_uchar((char )*s);
#line 80
  len = (size_t )localeinfo.sbclen[tmp];
  }
#line 81
  if (len == 0xfffffffffffffffeUL) {
    {
#line 81
    tmp___0 = rpl_mbrlen(s, n, mbs);
#line 81
    tmp___1 = tmp___0;
    }
  } else {
#line 81
    tmp___1 = len;
  }
#line 81
  return (tmp___1);
}
}
#line 84
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
static _Bool sbwordchar[256]  ;
#line 30 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
static _Bool wordchar(wint_t wc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 33
  if (wc == 95U) {
#line 33
    tmp___0 = 1;
  } else {
    {
#line 33
    tmp = iswalnum(wc);
    }
#line 33
    if (tmp) {
#line 33
      tmp___0 = 1;
    } else {
#line 33
      tmp___0 = 0;
    }
  }
#line 33
  return ((_Bool )tmp___0);
}
}
#line 36 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
void wordinit(void) 
{ 
  int i ;

  {
#line 39
  i = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (i < 256)) {
#line 39
      goto while_break;
    }
    {
#line 40
    sbwordchar[i] = wordchar(localeinfo.sbctowc[i]);
#line 39
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
kwset_t kwsinit(_Bool mb_trans ) 
{ 
  char *trans ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int i___0 ;
  wint_t wc ;
  wint_t uwc ;
  wint_t tmp___1 ;
  mbstate_t mbs ;
  size_t len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  kwset_t tmp___5 ;

  {
#line 46
  trans = (char *)((void *)0);
#line 48
  if (match_icase) {
    {
#line 48
    tmp___4 = __ctype_get_mb_cur_max();
    }
#line 48
    if (tmp___4 == 1UL) {
#line 48
      goto _L;
    } else
#line 48
    if (mb_trans) {
      _L: /* CIL Label */ 
      {
#line 50
      tmp = xmalloc((size_t )256);
#line 50
      trans = (char *)tmp;
#line 51
      tmp___3 = __ctype_get_mb_cur_max();
      }
#line 51
      if (tmp___3 == 1UL) {
#line 52
        i = 0;
        {
#line 52
        while (1) {
          while_continue: /* CIL Label */ ;
#line 52
          if (! (i < 256)) {
#line 52
            goto while_break;
          }
          {
#line 53
          tmp___0 = toupper(i);
#line 53
          *(trans + i) = (char )tmp___0;
#line 52
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 55
        i___0 = 0;
        {
#line 55
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 55
          if (! (i___0 < 256)) {
#line 55
            goto while_break___0;
          }
          {
#line 57
          wc = localeinfo.sbctowc[i___0];
#line 58
          tmp___1 = towupper(wc);
#line 58
          uwc = tmp___1;
          }
#line 59
          if (uwc != wc) {
            {
#line 61
            mbs.__count = 0;
#line 61
            mbs.__value.__wch = 0U;
#line 62
            tmp___2 = wcrtomb((char */* __restrict  */)(trans + i___0), (wchar_t )uwc,
                              (mbstate_t */* __restrict  */)(& mbs));
#line 62
            len = tmp___2;
            }
#line 63
            if (len != 1UL) {
              {
#line 64
              abort();
              }
            }
          } else {
#line 67
            *(trans + i___0) = (char )i___0;
          }
#line 55
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 71
  tmp___5 = kwsalloc((char const   *)trans);
  }
#line 71
  return (tmp___5);
}
}
#line 85 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
ptrdiff_t mb_goback(char const   **mb_start , char const   *cur , char const   *end ) 
{ 
  char const   *p ;
  char const   *p0 ;
  int i ;
  mbstate_t mbs ;
  size_t clen ;
  size_t tmp ;
  mbstate_t mbs___0 ;
  size_t clen___0 ;
  size_t tmp___0 ;
  long tmp___1 ;

  {
#line 88
  p = *mb_start;
#line 89
  p0 = p;
#line 91
  if ((unsigned long )cur <= (unsigned long )p) {
#line 92
    return (cur - p);
  }
#line 94
  if (localeinfo.using_utf8) {
#line 96
    p = cur;
#line 98
    if ((unsigned long )cur < (unsigned long )end) {
#line 98
      if (((int const   )*cur & 192) == 128) {
#line 99
        i = 1;
        {
#line 99
        while (1) {
          while_continue: /* CIL Label */ ;
#line 99
          if (! (i <= 3)) {
#line 99
            goto while_break;
          }
#line 100
          if (((int const   )*(cur + - i) & 192) != 128) {
            {
#line 102
            mbs.__count = 0;
#line 102
            mbs.__value.__wch = 0U;
#line 103
            tmp = mb_clen(cur - i, (size_t )(end - (cur - i)), & mbs);
#line 103
            clen = tmp;
            }
#line 104
            if ((size_t )i < clen) {
#line 104
              if (clen < 0xfffffffffffffffeUL) {
#line 106
                p0 = cur - i;
#line 107
                p = p0 + clen;
              }
            }
#line 109
            goto while_break;
          }
#line 99
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 114
    mbs___0.__count = 0;
#line 114
    mbs___0.__value.__wch = 0U;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 117
      tmp___0 = mb_clen(p, (size_t )(end - p), & mbs___0);
#line 117
      clen___0 = tmp___0;
      }
#line 119
      if (0xfffffffffffffffeUL <= clen___0) {
        {
#line 123
        clen___0 = (size_t )1;
#line 124
        memset((void *)(& mbs___0), 0, sizeof(mbs___0));
        }
      }
#line 126
      p0 = p;
#line 127
      p += clen___0;
#line 115
      if (! ((unsigned long )p < (unsigned long )cur)) {
#line 115
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 132
  *mb_start = p;
#line 133
  if ((unsigned long )p == (unsigned long )cur) {
#line 133
    tmp___1 = 0L;
  } else {
#line 133
    tmp___1 = cur - p0;
  }
#line 133
  return (tmp___1);
}
}
#line 139 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
static size_t wordchars_count(char const   *buf , char const   *end , _Bool countall ) 
{ 
  size_t n ;
  mbstate_t mbs ;
  unsigned char b ;
  wchar_t wc ;
  size_t wcbytes ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
#line 142
  n = (size_t )0;
#line 143
  mbs.__count = 0;
#line 143
  mbs.__value.__wch = 0U;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (n < (size_t )(end - buf))) {
#line 144
      goto while_break;
    }
#line 146
    b = (unsigned char )*(buf + n);
#line 147
    if (sbwordchar[b]) {
#line 148
      n ++;
    } else
#line 149
    if ((int )localeinfo.sbclen[b] != -2) {
#line 150
      goto while_break;
    } else {
      {
#line 153
      wc = 0;
#line 154
      tmp = rpl_mbrtowc(& wc, buf + n, (size_t )(end - buf) - n, & mbs);
#line 154
      wcbytes = tmp;
#line 155
      tmp___0 = wordchar((wint_t )wc);
      }
#line 155
      if (! tmp___0) {
#line 156
        goto while_break;
      }
#line 157
      n += wcbytes + (size_t )(! wcbytes);
    }
#line 159
    if (! countall) {
#line 160
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (n);
}
}
#line 168
size_t wordchars_size(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 168 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
size_t wordchars_size(char const   *buf , char const   *end ) 
{ 
  size_t tmp ;

  {
  {
#line 171
  tmp = wordchars_count(buf, end, (_Bool)1);
  }
#line 171
  return (tmp);
}
}
#line 176
size_t wordchar_next(char const   *buf , char const   *end )  __attribute__((__pure__)) ;
#line 176 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
size_t wordchar_next(char const   *buf , char const   *end ) 
{ 
  size_t tmp ;

  {
  {
#line 179
  tmp = wordchars_count(buf, end, (_Bool)0);
  }
#line 179
  return (tmp);
}
}
#line 185
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end )  __attribute__((__pure__)) ;
#line 185 "/home/khheo/project/benchmark/grep-3.0/src/searchutils.c"
size_t wordchar_prev(char const   *buf , char const   *cur , char const   *end ) 
{ 
  unsigned char b ;
  char const   *p ;
  ptrdiff_t tmp ;
  size_t tmp___0 ;

  {
#line 188
  if ((unsigned long )buf == (unsigned long )cur) {
#line 189
    return ((size_t )0);
  }
#line 190
  cur --;
#line 190
  b = (unsigned char )*cur;
#line 191
  if (! localeinfo.multibyte) {
#line 193
    return ((size_t )sbwordchar[b]);
  } else
#line 191
  if (localeinfo.using_utf8) {
#line 191
    if ((int )localeinfo.sbclen[b] != -2) {
#line 193
      return ((size_t )sbwordchar[b]);
    }
  }
  {
#line 194
  p = buf;
#line 195
  tmp = mb_goback(& p, cur, end);
#line 195
  cur -= tmp;
#line 196
  tmp___0 = wordchar_next(cur, end);
  }
#line 196
  return (tmp___0);
}
}
#line 80 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
_Bool match_words ;
#line 29
_Bool match_lines ;
#line 30
char eolbyte ;
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 66
void *Pcompile(char *pattern , size_t size , reg_syntax_t ignored ) ;
#line 67
size_t Pexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) ;
#line 84
#pragma GCC diagnostic pop
#line 540 "/usr/include/pcre.h"
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 573
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 627
extern unsigned char const   *pcre_maketables(void) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 657
extern pcre_jit_stack *pcre_jit_stack_alloc(int  , int  ) ;
#line 660
extern void pcre_jit_stack_free(pcre_jit_stack * ) ;
#line 663
extern void pcre_assign_jit_stack(pcre_extra * , pcre_jit_stack *(*)(void * ) , void * ) ;
#line 60 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
static int jit_exec(struct pcre_comp *pc , char const   *subject , int search_bytes ,
                    int search_offset , int options , int *sub ) 
{ 
  int e ;
  int tmp ;
  int old_size ;
  int new_size ;
  int tmp___0 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra, subject,
                    search_bytes, search_offset, options, sub, 300);
#line 66
    e = tmp;
    }
#line 70
    if (e == -27) {
#line 70
      if (0 < pc->jit_stack_size) {
#line 70
        if (pc->jit_stack_size <= 1073741823) {
#line 73
          old_size = pc->jit_stack_size;
#line 74
          tmp___0 = old_size * 2;
#line 74
          pc->jit_stack_size = tmp___0;
#line 74
          new_size = tmp___0;
#line 75
          if (pc->jit_stack) {
            {
#line 76
            pcre_jit_stack_free(pc->jit_stack);
            }
          }
          {
#line 77
          pc->jit_stack = pcre_jit_stack_alloc(old_size, new_size);
          }
#line 78
          if (! pc->jit_stack) {
            {
#line 79
            exit(1);
            }
          }
          {
#line 81
          pcre_assign_jit_stack(pc->extra, (pcre_jit_stack *(*)(void * ))((void *)0),
                                (void *)pc->jit_stack);
          }
#line 82
          goto while_continue;
        }
      }
    }
#line 86
    return (e);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 102 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
static char const   wprefix[11]  = 
#line 102
  {      (char const   )'(',      (char const   )'?',      (char const   )'<',      (char const   )'!', 
        (char const   )'\\',      (char const   )'w',      (char const   )')',      (char const   )'(', 
        (char const   )'?',      (char const   )':',      (char const   )'\000'};
#line 103 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
static char const   wsuffix[8]  = 
#line 103
  {      (char const   )')',      (char const   )'(',      (char const   )'?',      (char const   )'!', 
        (char const   )'\\',      (char const   )'w',      (char const   )')',      (char const   )'\000'};
#line 104 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
static char const   xprefix[5]  = {      (char const   )'^',      (char const   )'(',      (char const   )'?',      (char const   )':', 
        (char const   )'\000'};
#line 105 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
static char const   xsuffix[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 92 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
void *Pcompile(char *pattern , size_t size , reg_syntax_t ignored ) 
{ 
  int e ;
  char const   *ep ;
  int fix_len_max ;
  unsigned long tmp ;
  char *re ;
  void *tmp___0 ;
  int flags ;
  int tmp___1 ;
  char const   *patlim ;
  char *n ;
  char const   *p ;
  char const   *pnul ;
  struct pcre_comp *pc ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  int sub[300] ;

  {
#line 106
  if (((sizeof(wprefix) - 1UL) + sizeof(wsuffix)) - 1UL > ((sizeof(xprefix) - 1UL) + sizeof(xsuffix)) - 1UL) {
#line 106
    tmp = ((sizeof(wprefix) - 1UL) + sizeof(wsuffix)) - 1UL;
  } else {
#line 106
    tmp = ((sizeof(xprefix) - 1UL) + sizeof(xsuffix)) - 1UL;
  }
  {
#line 106
  fix_len_max = (int )tmp;
#line 108
  tmp___0 = xnmalloc((size_t )4, size + (size_t )(((fix_len_max + 4) - 1) / 4));
#line 108
  re = (char *)tmp___0;
  }
#line 109
  if (match_icase) {
#line 109
    tmp___1 = 1;
  } else {
#line 109
    tmp___1 = 0;
  }
  {
#line 109
  flags = 32 | tmp___1;
#line 110
  patlim = (char const   *)(pattern + size);
#line 111
  n = re;
#line 114
  tmp___2 = xcalloc((size_t )1, sizeof(*pc));
#line 114
  pc = (struct pcre_comp *)tmp___2;
  }
#line 116
  if (localeinfo.multibyte) {
#line 118
    if (! localeinfo.using_utf8) {
      {
#line 119
      exit(1);
      }
    }
#line 120
    flags |= 2048;
  }
  {
#line 124
  tmp___3 = memchr((void const   *)pattern, '\n', size);
  }
#line 124
  if (tmp___3) {
    {
#line 125
    exit(1);
    }
  }
#line 127
  *n = (char )'\000';
#line 128
  if (match_words) {
    {
#line 129
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(wprefix));
    }
  }
#line 130
  if (match_lines) {
    {
#line 131
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(xprefix));
    }
  }
  {
#line 132
  tmp___4 = strlen((char const   *)n);
#line 132
  n += tmp___4;
#line 138
  p = (char const   *)pattern;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 138
    tmp___5 = memchr((void const   *)p, '\000', (size_t )(patlim - p));
#line 138
    pnul = (char const   *)tmp___5;
    }
#line 138
    if (! pnul) {
#line 138
      goto while_break;
    }
    {
#line 140
    memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(pnul - p));
#line 141
    n += pnul - p;
#line 142
    p = pnul;
    }
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if ((unsigned long )pattern < (unsigned long )p) {
#line 142
        if (! ((int const   )*(p + -1) == 92)) {
#line 142
          goto while_break___0;
        }
      } else {
#line 142
        goto while_break___0;
      }
#line 143
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 142
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 144
    n -= (pnul - p) & 1L;
#line 145
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\000");
#line 146
    n += 4;
#line 138
    p = pnul + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(patlim - p));
#line 150
  n += patlim - p;
#line 151
  *n = (char )'\000';
  }
#line 152
  if (match_words) {
    {
#line 153
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(wsuffix));
    }
  }
#line 154
  if (match_lines) {
    {
#line 155
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)(xsuffix));
    }
  }
  {
#line 157
  tmp___6 = pcre_maketables();
#line 157
  pc->cre = pcre_compile((char const   *)re, flags, & ep, & e, tmp___6);
  }
#line 158
  if (! pc->cre) {
    {
#line 159
    exit(1);
    }
  }
  {
#line 161
  pc->extra = pcre_study((pcre const   *)pc->cre, 1, & ep);
  }
#line 162
  if (ep) {
    {
#line 163
    exit(1);
    }
  }
  {
#line 166
  tmp___7 = pcre_fullinfo((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                          16, (void *)(& e));
  }
#line 166
  if (tmp___7) {
    {
#line 167
    exit(1);
    }
  }
#line 170
  if (e) {
#line 171
    pc->jit_stack_size = 32 << 10;
  }
  {
#line 174
  free((void *)re);
#line 177
  pc->empty_match[0] = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                                 "", 0, 0, 128, sub, 300);
#line 179
  pc->empty_match[1] = pcre_exec((pcre const   *)pc->cre, (pcre_extra const   *)pc->extra,
                                 "", 0, 0, 0, sub, 300);
  }
#line 182
  return ((void *)pc);
}
}
#line 186 "/home/khheo/project/benchmark/grep-3.0/src/pcresearch.c"
size_t Pexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) 
{ 
  int sub[300] ;
  char const   *p ;
  char const   *tmp ;
  _Bool bol ;
  char const   *line_start ;
  int e ;
  char const   *line_end ;
  struct pcre_comp *pc ;
  char const   *subject ;
  void *tmp___0 ;
  unsigned char tmp___1 ;
  int search_offset ;
  int options ;
  int valid_bytes ;
  char const   *matchbeg ;
  char const   *matchend ;
  char const   *beg ;
  char const   *end ;

  {
#line 195
  if (start_ptr) {
#line 195
    tmp = start_ptr;
  } else {
#line 195
    tmp = buf;
  }
#line 195
  p = tmp;
#line 196
  bol = (_Bool )((int const   )*(p + -1) == (int const   )eolbyte);
#line 197
  line_start = buf;
#line 198
  e = -1;
#line 200
  pc = (struct pcre_comp *)vcp;
#line 205
  subject = buf;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___0 = memchr((void const   *)p, (int )eolbyte, (size_t )((buf + size) - p));
#line 213
    line_end = (char const   *)tmp___0;
    }
#line 214
    if (2147483647L < line_end - p) {
      {
#line 215
      exit(1);
      }
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 222
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 222
        tmp___1 = to_uchar((char )*p);
        }
#line 222
        if (! ((int )localeinfo.sbclen[tmp___1] == -1)) {
#line 222
          goto while_break___1;
        }
#line 224
        p ++;
#line 225
        subject = p;
#line 226
        bol = (_Bool)0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 229
      search_offset = (int )(p - subject);
#line 233
      if ((unsigned long )p == (unsigned long )line_end) {
#line 235
        sub[1] = search_offset;
#line 235
        sub[0] = sub[1];
#line 236
        e = pc->empty_match[bol];
#line 237
        goto while_break___0;
      }
#line 240
      options = 0;
#line 241
      if (! bol) {
#line 242
        options |= 128;
      }
      {
#line 244
      e = jit_exec(pc, subject, (int )(line_end - subject), search_offset, options,
                   sub);
      }
#line 246
      if (e != -10) {
#line 247
        goto while_break___0;
      }
#line 248
      valid_bytes = sub[0];
#line 250
      if (search_offset <= valid_bytes) {
#line 253
        if (valid_bytes == 0) {
#line 258
          sub[1] = 0;
#line 259
          e = pc->empty_match[bol];
        } else {
          {
#line 262
          e = jit_exec(pc, subject, valid_bytes, search_offset, (options | 8192) | 256,
                       sub);
          }
        }
#line 265
        if (e != -1) {
#line 266
          goto while_break___0;
        }
#line 269
        p = (subject + valid_bytes) + 1;
#line 270
        bol = (_Bool)0;
      }
#line 273
      subject += valid_bytes + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    if (e != -1) {
#line 277
      goto while_break;
    }
#line 278
    bol = (_Bool)1;
#line 279
    line_start = line_end + 1;
#line 279
    subject = line_start;
#line 279
    p = subject;
#line 207
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if (e <= 0) {
    {
#line 287
    if (e == -1) {
#line 287
      goto case_neg_1;
    }
#line 290
    if (e == -6) {
#line 290
      goto case_neg_6;
    }
#line 294
    if (e == -27) {
#line 294
      goto case_neg_27;
    }
#line 298
    if (e == -8) {
#line 298
      goto case_neg_8;
    }
#line 301
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 288
    goto switch_break;
    case_neg_6: /* CIL Label */ 
    {
#line 291
    exit(1);
    }
    case_neg_27: /* CIL Label */ 
    {
#line 295
    exit(1);
    }
    case_neg_8: /* CIL Label */ 
    {
#line 299
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 306
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 309
    return ((size_t )-1);
  } else {
#line 313
    matchbeg = subject + sub[0];
#line 314
    matchend = subject + sub[1];
#line 317
    if (start_ptr) {
#line 319
      beg = matchbeg;
#line 320
      end = matchend;
    } else {
#line 324
      beg = line_start;
#line 325
      end = line_end + 1;
    }
#line 327
    *match_size = (size_t )(end - beg);
#line 328
    return ((size_t )(beg - buf));
  }
}
}
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
#line 38 "/home/khheo/project/benchmark/grep-3.0/src/kwset.h"
void kwsincr(kwset_t kwset , char const   *text , ptrdiff_t len ) ;
#line 39
ptrdiff_t kwswords(kwset_t kwset )  __attribute__((__pure__)) ;
#line 40
void kwsprep(kwset_t kwset ) ;
#line 41
ptrdiff_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset , char const   *text ,
                                                     ptrdiff_t size , struct kwsmatch *kwsmatch ,
                                                     _Bool longest ) ;
#line 44
void kwsfree(kwset_t kwset ) ;
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static unsigned char U(char ch ) 
{ 
  unsigned char tmp ;

  {
  {
#line 56
  tmp = to_uchar(ch);
  }
#line 56
  return (tmp);
}
}
#line 128 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
__inline static char tr(char const   *trans , char c ) 
{ 
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 131
  if (trans) {
    {
#line 131
    tmp = U(c);
#line 131
    tmp___0 = (int const   )*(trans + tmp);
    }
  } else {
#line 131
    tmp___0 = (int const   )c;
  }
#line 131
  return ((char )tmp___0);
}
}
#line 134
static ptrdiff_t acexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) ;
#line 136
static ptrdiff_t bmexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) ;
#line 142 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
kwset_t kwsalloc(char const   *trans ) 
{ 
  struct kwset *kwset ;
  void *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 145
  tmp = xmalloc(sizeof(*kwset));
#line 145
  kwset = (struct kwset *)tmp;
#line 147
  _obstack_begin(& kwset->obstack, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 148
  kwset->words = (ptrdiff_t )0;
#line 149
  __h = & kwset->obstack;
#line 149
  __o = __h;
#line 149
  __len = sizeof(*(kwset->trie));
#line 149
  __o1 = (struct obstack  const  *)__o;
  }
#line 149
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 149
    _obstack_newchunk(__o, __len);
    }
  }
#line 149
  __o->next_free += __len;
#line 149
  __o1___0 = __h;
#line 149
  __value = (void *)__o1___0->object_base;
#line 149
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 149
    __o1___0->maybe_empty_object = 1U;
  }
#line 149
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 149
    tmp___0 = __o1___0->object_base;
  } else {
#line 149
    tmp___0 = (char *)0;
  }
#line 149
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 149
    tmp___1 = __o1___0->object_base;
  } else {
#line 149
    tmp___1 = (char *)0;
  }
#line 149
  __o1___0->next_free = tmp___0 + (((size_t )(__o1___0->next_free - tmp___1) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 149
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 149
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 149
  __o1___0->object_base = __o1___0->next_free;
#line 149
  kwset->trie = (struct trie *)__value;
#line 150
  (kwset->trie)->accepting = (size_t )0;
#line 151
  (kwset->trie)->links = (struct tree *)((void *)0);
#line 152
  (kwset->trie)->parent = (struct trie *)((void *)0);
#line 153
  (kwset->trie)->next = (struct trie *)((void *)0);
#line 154
  (kwset->trie)->fail = (struct trie *)((void *)0);
#line 155
  (kwset->trie)->depth = (ptrdiff_t )0;
#line 156
  (kwset->trie)->shift = (ptrdiff_t )0;
#line 157
  kwset->mind = 9223372036854775807L;
#line 158
  kwset->maxd = (ptrdiff_t )-1;
#line 159
  kwset->target = (char *)((void *)0);
#line 160
  kwset->trans = trans;
#line 161
  kwset->kwsexec = & acexec;
#line 163
  return (kwset);
}
}
#line 171 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
void kwsincr(kwset_t kwset , char const   *text , ptrdiff_t len ) 
{ 
  struct trie *trie ;
  char const   *trans ;
  _Bool reverse ;
  unsigned char uc ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned char label___0 ;
  int tmp___1 ;
  struct tree *cur ;
  struct tree *links[12] ;
  enum __anonenum_dirs_744895363 dirs[12] ;
  ptrdiff_t depth ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  char tmp___8 ;
  char tmp___9 ;
  ptrdiff_t tmp___10 ;
  size_t words ;

  {
#line 174
  if (! (0L <= len)) {
    {
#line 174
    __builtin_unreachable();
    }
  }
#line 175
  trie = kwset->trie;
#line 176
  trans = kwset->trans;
#line 177
  reverse = (_Bool )((unsigned long )kwset->kwsexec == (unsigned long )(& bmexec));
#line 179
  if (reverse) {
#line 180
    text += len;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    tmp___10 = len;
#line 184
    len --;
#line 184
    if (! tmp___10) {
#line 184
      goto while_break;
    }
#line 186
    if (reverse) {
#line 186
      text --;
#line 186
      tmp___0 = (int const   )*text;
    } else {
#line 186
      tmp = text;
#line 186
      text ++;
#line 186
      tmp___0 = (int const   )*tmp;
    }
#line 186
    uc = (unsigned char )tmp___0;
#line 187
    if (trans) {
#line 187
      tmp___1 = (int const   )*(trans + uc);
    } else {
#line 187
      tmp___1 = (int const   )uc;
    }
#line 187
    label___0 = (unsigned char )tmp___1;
#line 192
    cur = trie->links;
#line 195
    links[0] = (struct tree *)(& trie->links);
#line 196
    dirs[0] = (enum __anonenum_dirs_744895363 )0;
#line 197
    depth = (ptrdiff_t )1;
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (cur) {
#line 199
        if (! ((int )label___0 != (int )cur->label)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 201
      links[depth] = cur;
#line 202
      if ((int )label___0 < (int )cur->label) {
#line 203
        tmp___2 = depth;
#line 203
        depth ++;
#line 203
        dirs[tmp___2] = (enum __anonenum_dirs_744895363 )0;
#line 203
        cur = cur->llink;
      } else {
#line 205
        tmp___3 = depth;
#line 205
        depth ++;
#line 205
        dirs[tmp___3] = (enum __anonenum_dirs_744895363 )1;
#line 205
        cur = cur->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    if (! cur) {
#line 213
      __h = & kwset->obstack;
#line 213
      __o = __h;
#line 213
      __len = sizeof(*cur);
#line 213
      __o1 = (struct obstack  const  *)__o;
#line 213
      if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
        {
#line 213
        _obstack_newchunk(__o, __len);
        }
      }
#line 213
      __o->next_free += __len;
#line 213
      __o1___0 = __h;
#line 213
      __value = (void *)__o1___0->object_base;
#line 213
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 213
        __o1___0->maybe_empty_object = 1U;
      }
#line 213
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 213
        tmp___4 = __o1___0->object_base;
      } else {
#line 213
        tmp___4 = (char *)0;
      }
#line 213
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 213
        tmp___5 = __o1___0->object_base;
      } else {
#line 213
        tmp___5 = (char *)0;
      }
#line 213
      __o1___0->next_free = tmp___4 + (((size_t )(__o1___0->next_free - tmp___5) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 213
      if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 213
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 213
      __o1___0->object_base = __o1___0->next_free;
#line 213
      cur = (struct tree *)__value;
#line 214
      cur->llink = (struct tree *)((void *)0);
#line 215
      cur->rlink = (struct tree *)((void *)0);
#line 216
      __h___0 = & kwset->obstack;
#line 216
      __o___0 = __h___0;
#line 216
      __len___0 = sizeof(*(cur->trie));
#line 216
      __o1___1 = (struct obstack  const  *)__o___0;
#line 216
      if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
        {
#line 216
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 216
      __o___0->next_free += __len___0;
#line 216
      __o1___2 = __h___0;
#line 216
      __value___0 = (void *)__o1___2->object_base;
#line 216
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 216
        __o1___2->maybe_empty_object = 1U;
      }
#line 216
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 216
        tmp___6 = __o1___2->object_base;
      } else {
#line 216
        tmp___6 = (char *)0;
      }
#line 216
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 216
        tmp___7 = __o1___2->object_base;
      } else {
#line 216
        tmp___7 = (char *)0;
      }
#line 216
      __o1___2->next_free = tmp___6 + (((size_t )(__o1___2->next_free - tmp___7) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 216
      if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 216
        __o1___2->next_free = __o1___2->chunk_limit;
      }
#line 216
      __o1___2->object_base = __o1___2->next_free;
#line 216
      cur->trie = (struct trie *)__value___0;
#line 217
      (cur->trie)->accepting = (size_t )0;
#line 218
      (cur->trie)->links = (struct tree *)((void *)0);
#line 219
      (cur->trie)->parent = trie;
#line 220
      (cur->trie)->next = (struct trie *)((void *)0);
#line 221
      (cur->trie)->fail = (struct trie *)((void *)0);
#line 222
      (cur->trie)->depth = trie->depth + 1L;
#line 223
      (cur->trie)->shift = (ptrdiff_t )0;
#line 224
      cur->label = label___0;
#line 225
      cur->balance = (char)0;
#line 228
      depth --;
#line 228
      if ((unsigned int )dirs[depth] == 0U) {
#line 229
        (links[depth])->llink = cur;
      } else {
#line 231
        (links[depth])->rlink = cur;
      }
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (depth) {
#line 234
          if (! (! (links[depth])->balance)) {
#line 234
            goto while_break___1;
          }
        } else {
#line 234
          goto while_break___1;
        }
#line 236
        if ((unsigned int )dirs[depth] == 0U) {
#line 237
          (links[depth])->balance = (char )((int )(links[depth])->balance - 1);
        } else {
#line 239
          (links[depth])->balance = (char )((int )(links[depth])->balance + 1);
        }
#line 240
        depth --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 244
      if (depth) {
#line 244
        if ((unsigned int )dirs[depth] == 0U) {
#line 244
          (links[depth])->balance = (char )((int )(links[depth])->balance - 1);
#line 244
          if ((links[depth])->balance) {
#line 244
            goto _L;
          } else {
#line 244
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 244
        if ((unsigned int )dirs[depth] == 1U) {
#line 244
          (links[depth])->balance = (char )((int )(links[depth])->balance + 1);
#line 244
          if ((links[depth])->balance) {
            _L: /* CIL Label */ 
            {
#line 251
            if ((int )(links[depth])->balance == -2) {
#line 251
              goto case_neg_2;
            }
#line 271
            if ((int )(links[depth])->balance == 2) {
#line 271
              goto case_2;
            }
#line 291
            goto switch_default___1;
            case_neg_2: /* CIL Label */ 
            {
#line 254
            if ((unsigned int )dirs[depth + 1L] == 0U) {
#line 254
              goto case_0;
            }
#line 259
            if ((unsigned int )dirs[depth + 1L] == 1U) {
#line 259
              goto case_1;
            }
#line 267
            goto switch_default;
            case_0: /* CIL Label */ 
#line 255
            r = links[depth];
#line 255
            t = r->llink;
#line 255
            rl = t->rlink;
#line 256
            t->rlink = r;
#line 256
            r->llink = rl;
#line 257
            tmp___8 = (char)0;
#line 257
            r->balance = tmp___8;
#line 257
            t->balance = tmp___8;
#line 258
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 260
            r = links[depth];
#line 260
            l = r->llink;
#line 260
            t = l->rlink;
#line 261
            rl = t->rlink;
#line 261
            lr = t->llink;
#line 262
            t->llink = l;
#line 262
            l->rlink = lr;
#line 262
            t->rlink = r;
#line 262
            r->llink = rl;
#line 263
            if ((int )t->balance != 1) {
#line 263
              l->balance = (char)0;
            } else {
#line 263
              l->balance = (char)-1;
            }
#line 264
            if ((int )t->balance != -1) {
#line 264
              r->balance = (char)0;
            } else {
#line 264
              r->balance = (char)1;
            }
#line 265
            t->balance = (char)0;
#line 266
            goto switch_break___0;
            switch_default: /* CIL Label */ 
            {
#line 268
            abort();
            }
            switch_break___0: /* CIL Label */ ;
            }
#line 270
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 274
            if ((unsigned int )dirs[depth + 1L] == 1U) {
#line 274
              goto case_1___0;
            }
#line 279
            if ((unsigned int )dirs[depth + 1L] == 0U) {
#line 279
              goto case_0___0;
            }
#line 287
            goto switch_default___0;
            case_1___0: /* CIL Label */ 
#line 275
            l = links[depth];
#line 275
            t = l->rlink;
#line 275
            lr = t->llink;
#line 276
            t->llink = l;
#line 276
            l->rlink = lr;
#line 277
            tmp___9 = (char)0;
#line 277
            l->balance = tmp___9;
#line 277
            t->balance = tmp___9;
#line 278
            goto switch_break___1;
            case_0___0: /* CIL Label */ 
#line 280
            l = links[depth];
#line 280
            r = l->rlink;
#line 280
            t = r->llink;
#line 281
            lr = t->llink;
#line 281
            rl = t->rlink;
#line 282
            t->llink = l;
#line 282
            l->rlink = lr;
#line 282
            t->rlink = r;
#line 282
            r->llink = rl;
#line 283
            if ((int )t->balance != 1) {
#line 283
              l->balance = (char)0;
            } else {
#line 283
              l->balance = (char)-1;
            }
#line 284
            if ((int )t->balance != -1) {
#line 284
              r->balance = (char)0;
            } else {
#line 284
              r->balance = (char)1;
            }
#line 285
            t->balance = (char)0;
#line 286
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
            {
#line 288
            abort();
            }
            switch_break___1: /* CIL Label */ ;
            }
#line 290
            goto switch_break;
            switch_default___1: /* CIL Label */ 
            {
#line 292
            abort();
            }
            switch_break: /* CIL Label */ ;
            }
#line 295
            if ((unsigned int )dirs[depth - 1L] == 0U) {
#line 296
              (links[depth - 1L])->llink = t;
            } else {
#line 298
              (links[depth - 1L])->rlink = t;
            }
          }
        }
      }
    }
#line 302
    trie = cur->trie;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (! trie->accepting) {
#line 309
    words = (size_t )kwset->words;
#line 310
    trie->accepting = 2UL * words + 1UL;
  }
#line 312
  (kwset->words) ++;
#line 315
  if (trie->depth < kwset->mind) {
#line 316
    kwset->mind = trie->depth;
  }
#line 317
  if (trie->depth > kwset->maxd) {
#line 318
    kwset->maxd = trie->depth;
  }
#line 319
  return;
}
}
#line 321
ptrdiff_t kwswords(kwset_t kwset )  __attribute__((__pure__)) ;
#line 321 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
ptrdiff_t kwswords(kwset_t kwset ) 
{ 


  {
#line 324
  return (kwset->words);
}
}
#line 329 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static void enqueue(struct tree *tree , struct trie **last ) 
{ 
  struct trie *tmp ;

  {
#line 332
  if (! tree) {
#line 333
    return;
  }
  {
#line 334
  enqueue(tree->llink, last);
#line 335
  enqueue(tree->rlink, last);
#line 336
  tmp = tree->trie;
#line 336
  (*last)->next = tmp;
#line 336
  *last = tmp;
  }
#line 337
  return;
}
}
#line 342 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static void treefails(struct tree  const  *tree , struct trie  const  *fail , struct trie *recourse ,
                      _Bool reverse ) 
{ 
  struct tree *cur ;

  {
#line 348
  if (! tree) {
#line 349
    return;
  }
  {
#line 351
  treefails((struct tree  const  *)tree->llink, fail, recourse, reverse);
#line 352
  treefails((struct tree  const  *)tree->rlink, fail, recourse, reverse);
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! fail) {
#line 356
      goto while_break;
    }
#line 358
    cur = (struct tree *)fail->links;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (cur) {
#line 359
        if (! ((int const   )tree->label != (int const   )cur->label)) {
#line 359
          goto while_break___0;
        }
      } else {
#line 359
        goto while_break___0;
      }
#line 360
      if ((int const   )tree->label < (int const   )cur->label) {
#line 361
        cur = cur->llink;
      } else {
#line 363
        cur = cur->rlink;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 364
    if (cur) {
#line 366
      (tree->trie)->fail = cur->trie;
#line 367
      if (! reverse) {
#line 367
        if ((cur->trie)->accepting) {
#line 367
          if (! (tree->trie)->accepting) {
#line 368
            (tree->trie)->accepting = 0xffffffffffffffffUL;
          }
        }
      }
#line 369
      return;
    }
#line 371
    fail = (struct trie  const  *)fail->fail;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  (tree->trie)->fail = recourse;
#line 375
  return;
}
}
#line 379 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static void treedelta(struct tree  const  *tree , ptrdiff_t depth , unsigned char *delta ) 
{ 


  {
#line 382
  if (! tree) {
#line 383
    return;
  }
  {
#line 384
  treedelta((struct tree  const  *)tree->llink, depth, delta);
#line 385
  treedelta((struct tree  const  *)tree->rlink, depth, delta);
  }
#line 386
  if (depth < (ptrdiff_t )*(delta + tree->label)) {
#line 387
    *(delta + tree->label) = (unsigned char )depth;
  }
#line 388
  return;
}
}
#line 391 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static _Bool __attribute__((__pure__))  hasevery(struct tree  const  *a , struct tree  const  *b ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;
  _Bool __attribute__((__pure__))  tmp___0 ;

  {
#line 394
  if (! b) {
#line 395
    return ((_Bool __attribute__((__pure__))  )1);
  }
  {
#line 396
  tmp = hasevery(a, (struct tree  const  *)b->llink);
  }
#line 396
  if (! tmp) {
#line 397
    return ((_Bool __attribute__((__pure__))  )0);
  }
  {
#line 398
  tmp___0 = hasevery(a, (struct tree  const  *)b->rlink);
  }
#line 398
  if (! tmp___0) {
#line 399
    return ((_Bool __attribute__((__pure__))  )0);
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (a) {
#line 400
      if (! ((int const   )b->label != (int const   )a->label)) {
#line 400
        goto while_break;
      }
    } else {
#line 400
      goto while_break;
    }
#line 401
    if ((int const   )b->label < (int const   )a->label) {
#line 402
      a = (struct tree  const  *)a->llink;
    } else {
#line 404
      a = (struct tree  const  *)a->rlink;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return ((_Bool __attribute__((__pure__))  )(! (! a)));
}
}
#line 410 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static void treenext(struct tree  const  *tree , struct trie **next ) 
{ 


  {
#line 413
  if (! tree) {
#line 414
    return;
  }
  {
#line 415
  treenext((struct tree  const  *)tree->llink, next);
#line 416
  treenext((struct tree  const  *)tree->rlink, next);
#line 417
  *(next + tree->label) = (struct trie *)tree->trie;
  }
#line 418
  return;
}
}
#line 421 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
void kwsprep(kwset_t kwset ) 
{ 
  char const   *trans ;
  ptrdiff_t i ;
  unsigned char deltabuf[256] ;
  unsigned char *delta ;
  unsigned char *tmp ;
  struct trie *curr ;
  struct trie *last ;
  _Bool reverse ;
  kwset_t new_kwset ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___2 ;
  ptrdiff_t tmp___3 ;
  struct trie *fail ;
  _Bool __attribute__((__pure__))  tmp___4 ;
  struct trie *nextbuf[256] ;
  struct trie **next ;
  struct trie **tmp___5 ;
  int gc1 ;
  int gc1help ;
  int ti ;
  unsigned char tmp___6 ;
  struct obstack *__h___0 ;
  struct obstack *__o___1 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct obstack *__h___1 ;
  struct obstack *__o___2 ;
  size_t __len___1 ;
  struct obstack  const  *__o1___3 ;
  struct obstack *__o1___4 ;
  void *__value___1 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 424
  trans = kwset->trans;
#line 427
  if (trans) {
#line 427
    tmp = deltabuf;
  } else {
#line 427
    tmp = kwset->delta;
  }
#line 427
  delta = tmp;
#line 431
  reverse = (_Bool )(kwset->words == 1L);
#line 433
  if (reverse) {
#line 438
    last = kwset->trie;
#line 438
    curr = last;
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;
#line 438
      if (! curr) {
#line 438
        goto while_break;
      }
      {
#line 439
      enqueue(curr->links, & last);
#line 438
      curr = curr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 442
    __h = & kwset->obstack;
#line 442
    __o = __h;
#line 442
    __len = (size_t )kwset->mind;
#line 442
    __o1 = (struct obstack  const  *)__o;
#line 442
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 442
      _obstack_newchunk(__o, __len);
      }
    }
#line 442
    __o->next_free += __len;
#line 442
    __o1___0 = __h;
#line 442
    __value = (void *)__o1___0->object_base;
#line 442
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 442
      __o1___0->maybe_empty_object = 1U;
    }
#line 442
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 442
      tmp___0 = __o1___0->object_base;
    } else {
#line 442
      tmp___0 = (char *)0;
    }
#line 442
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 442
      tmp___1 = __o1___0->object_base;
    } else {
#line 442
      tmp___1 = (char *)0;
    }
#line 442
    __o1___0->next_free = tmp___0 + (((size_t )(__o1___0->next_free - tmp___1) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 442
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 442
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 442
    __o1___0->object_base = __o1___0->next_free;
#line 442
    kwset->target = (char *)__value;
#line 443
    i = (ptrdiff_t )0;
#line 443
    curr = kwset->trie;
    {
#line 443
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 443
      if (! (i < kwset->mind)) {
#line 443
        goto while_break___0;
      }
#line 445
      *(kwset->target + i) = (char )(curr->links)->label;
#line 446
      curr = curr->next;
#line 443
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 449
    new_kwset = kwsalloc(kwset->trans);
#line 450
    new_kwset->kwsexec = & bmexec;
#line 451
    kwsincr(new_kwset, (char const   *)kwset->target, kwset->mind);
#line 452
    __o___0 = & kwset->obstack;
#line 452
    __obj = (void *)0;
    }
#line 452
    if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 452
      if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 452
        tmp___2 = (char *)__obj;
#line 452
        __o___0->object_base = tmp___2;
#line 452
        __o___0->next_free = tmp___2;
      } else {
        {
#line 452
        _obstack_free(__o___0, __obj);
        }
      }
    } else {
      {
#line 452
      _obstack_free(__o___0, __obj);
      }
    }
    {
#line 453
    *kwset = *new_kwset;
#line 454
    free((void *)new_kwset);
    }
  }
#line 460
  if (kwset->mind < 255L) {
#line 460
    tmp___3 = kwset->mind;
  } else {
#line 460
    tmp___3 = (ptrdiff_t )255;
  }
  {
#line 460
  memset((void *)delta, (int )tmp___3, sizeof(deltabuf));
#line 464
  last = kwset->trie;
#line 464
  curr = last;
  }
  {
#line 464
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 464
    if (! curr) {
#line 464
      goto while_break___1;
    }
    {
#line 467
    enqueue(curr->links, & last);
#line 470
    treedelta((struct tree  const  *)curr->links, curr->depth, delta);
#line 473
    treefails((struct tree  const  *)curr->links, (struct trie  const  *)curr->fail,
              kwset->trie, reverse);
    }
#line 475
    if (reverse) {
#line 477
      curr->shift = kwset->mind;
#line 478
      curr->maxshift = kwset->mind;
#line 483
      fail = curr->fail;
      {
#line 483
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 483
        if (! fail) {
#line 483
          goto while_break___2;
        }
        {
#line 488
        tmp___4 = hasevery((struct tree  const  *)fail->links, (struct tree  const  *)curr->links);
        }
#line 488
        if (! tmp___4) {
#line 489
          if (curr->depth - fail->depth < fail->shift) {
#line 490
            fail->shift = curr->depth - fail->depth;
          }
        }
#line 495
        if (curr->accepting) {
#line 495
          if (fail->maxshift > curr->depth - fail->depth) {
#line 496
            fail->maxshift = curr->depth - fail->depth;
          }
        }
#line 483
        fail = fail->fail;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 464
    curr = curr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 501
  if (reverse) {
#line 505
    curr = (kwset->trie)->next;
    {
#line 505
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 505
      if (! curr) {
#line 505
        goto while_break___3;
      }
#line 507
      if (curr->maxshift > (curr->parent)->maxshift) {
#line 508
        curr->maxshift = (curr->parent)->maxshift;
      }
#line 509
      if (curr->shift > curr->maxshift) {
#line 510
        curr->shift = curr->maxshift;
      }
#line 505
      curr = curr->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 517
  if (trans) {
#line 517
    tmp___5 = nextbuf;
  } else {
#line 517
    tmp___5 = kwset->next;
  }
  {
#line 517
  next = tmp___5;
#line 518
  memset((void *)next, 0, sizeof(nextbuf));
#line 519
  treenext((struct tree  const  *)(kwset->trie)->links, next);
#line 520
  gc1 = -2;
#line 521
  gc1help = -1;
#line 522
  i = (ptrdiff_t )0;
  }
  {
#line 522
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 522
    if (! (i < 256L)) {
#line 522
      goto while_break___4;
    }
#line 524
    ti = (int )i;
#line 525
    if (trans) {
      {
#line 527
      tmp___6 = U((char )*(trans + i));
#line 527
      ti = (int )tmp___6;
#line 528
      kwset->next[i] = *(next + ti);
      }
    }
#line 530
    if (kwset->next[i]) {
#line 532
      if (gc1 < -1) {
#line 534
        gc1 = ti;
#line 535
        gc1help = (int )i;
      } else
#line 537
      if (gc1 == ti) {
#line 538
        if (gc1help == ti) {
#line 538
          gc1help = (int )i;
        } else {
#line 538
          gc1help = -1;
        }
      } else
#line 539
      if (i == (ptrdiff_t )ti) {
#line 539
        if (gc1 == gc1help) {
#line 540
          gc1help = (int )i;
        } else {
#line 542
          gc1 = -1;
        }
      } else {
#line 542
        gc1 = -1;
      }
    }
#line 522
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 545
  kwset->gc1 = gc1;
#line 546
  kwset->gc1help = gc1help;
#line 548
  if (reverse) {
#line 551
    __h___0 = & kwset->obstack;
#line 551
    __o___1 = __h___0;
#line 551
    __len___0 = (size_t )kwset->mind;
#line 551
    __o1___1 = (struct obstack  const  *)__o___1;
#line 551
    if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
      {
#line 551
      _obstack_newchunk(__o___1, __len___0);
      }
    }
#line 551
    __o___1->next_free += __len___0;
#line 551
    __o1___2 = __h___0;
#line 551
    __value___0 = (void *)__o1___2->object_base;
#line 551
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 551
      __o1___2->maybe_empty_object = 1U;
    }
#line 551
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 551
      tmp___7 = __o1___2->object_base;
    } else {
#line 551
      tmp___7 = (char *)0;
    }
#line 551
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 551
      tmp___8 = __o1___2->object_base;
    } else {
#line 551
      tmp___8 = (char *)0;
    }
#line 551
    __o1___2->next_free = tmp___7 + (((size_t )(__o1___2->next_free - tmp___8) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 551
    if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 551
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 551
    __o1___2->object_base = __o1___2->next_free;
#line 551
    kwset->target = (char *)__value___0;
#line 552
    i = kwset->mind - 1L;
#line 552
    curr = kwset->trie;
    {
#line 552
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 552
      if (! (i >= 0L)) {
#line 552
        goto while_break___5;
      }
#line 554
      *(kwset->target + i) = (char )(curr->links)->label;
#line 555
      curr = curr->next;
#line 552
      i --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 558
    if (kwset->mind > 1L) {
#line 563
      __h___1 = & kwset->obstack;
#line 563
      __o___2 = __h___1;
#line 563
      __len___1 = sizeof(*(kwset->shift)) * (unsigned long )(kwset->mind - 1L);
#line 563
      __o1___3 = (struct obstack  const  *)__o___2;
#line 563
      if ((size_t )(__o1___3->chunk_limit - __o1___3->next_free) < __len___1) {
        {
#line 563
        _obstack_newchunk(__o___2, __len___1);
        }
      }
#line 563
      __o___2->next_free += __len___1;
#line 563
      __o1___4 = __h___1;
#line 563
      __value___1 = (void *)__o1___4->object_base;
#line 563
      if ((unsigned long )__o1___4->next_free == (unsigned long )__value___1) {
#line 563
        __o1___4->maybe_empty_object = 1U;
      }
#line 563
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 563
        tmp___9 = __o1___4->object_base;
      } else {
#line 563
        tmp___9 = (char *)0;
      }
#line 563
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 563
        tmp___10 = __o1___4->object_base;
      } else {
#line 563
        tmp___10 = (char *)0;
      }
#line 563
      __o1___4->next_free = tmp___9 + (((size_t )(__o1___4->next_free - tmp___10) + __o1___4->alignment_mask) & ~ __o1___4->alignment_mask);
#line 563
      if ((size_t )(__o1___4->next_free - (char *)__o1___4->chunk) > (size_t )(__o1___4->chunk_limit - (char *)__o1___4->chunk)) {
#line 563
        __o1___4->next_free = __o1___4->chunk_limit;
      }
#line 563
      __o1___4->object_base = __o1___4->next_free;
#line 563
      kwset->shift = (ptrdiff_t *)__value___1;
#line 565
      i = (ptrdiff_t )0;
#line 565
      curr = (kwset->trie)->next;
      {
#line 565
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 565
        if (! (i < kwset->mind - 1L)) {
#line 565
          goto while_break___6;
        }
#line 567
        *(kwset->shift + i) = curr->shift;
#line 568
        curr = curr->next;
#line 565
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 572
      kwset->gc2 = tr(trans, *(kwset->target + (kwset->mind - 2L)));
      }
    }
  }
#line 577
  if (trans) {
#line 578
    i = (ptrdiff_t )0;
    {
#line 578
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 578
      if (! (i < 256L)) {
#line 578
        goto while_break___7;
      }
      {
#line 579
      tmp___11 = U((char )*(trans + i));
#line 579
      kwset->delta[i] = *(delta + tmp___11);
#line 578
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 580
  return;
}
}
#line 590 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
__inline static _Bool bm_delta2_search(char const   **tpp , char const   *ep , char const   *sp ,
                                       ptrdiff_t len , char const   *trans , char gc1 ,
                                       char gc2 , unsigned char const   *d1 , kwset_t kwset ) 
{ 
  char const   *tp ;
  ptrdiff_t d ;
  ptrdiff_t skip ;
  ptrdiff_t i ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  unsigned char tmp___4 ;
  char tmp___5 ;

  {
#line 596
  tp = *tpp;
#line 597
  d = len;
#line 597
  skip = (ptrdiff_t )0;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 601
    i = (ptrdiff_t )2;
#line 602
    tmp___3 = tr(trans, (char )*(tp + -2));
    }
#line 602
    if ((int )tmp___3 == (int )gc2) {
      {
#line 604
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 604
        i ++;
#line 604
        if (! (i <= d)) {
#line 604
          goto while_break___0;
        }
        {
#line 605
        tmp = tr(trans, (char )*(tp + - i));
#line 605
        tmp___0 = tr(trans, (char )*(sp + - i));
        }
#line 605
        if ((int )tmp != (int )tmp___0) {
#line 606
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 607
      if (i > d) {
#line 609
        i = (d + skip) + 1L;
        {
#line 609
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 609
          if (! (i <= len)) {
#line 609
            goto while_break___1;
          }
          {
#line 610
          tmp___1 = tr(trans, (char )*(tp + - i));
#line 610
          tmp___2 = tr(trans, (char )*(sp + - i));
          }
#line 610
          if ((int )tmp___1 != (int )tmp___2) {
#line 611
            goto while_break___1;
          }
#line 609
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 612
        if (i > len) {
#line 614
          *tpp = tp - len;
#line 615
          return ((_Bool)1);
        }
      }
    }
#line 620
    d = *(kwset->shift + (i - 2L));
#line 620
    tp += d;
#line 621
    if ((unsigned long )tp > (unsigned long )ep) {
#line 622
      goto while_break;
    }
    {
#line 623
    tmp___5 = tr(trans, (char )*(tp + -1));
    }
#line 623
    if ((int )tmp___5 != (int )gc1) {
#line 625
      if (d1) {
        {
#line 626
        tmp___4 = U((char )*(tp + -1));
#line 626
        tp += (int const   )*(d1 + tmp___4);
        }
      }
#line 627
      goto while_break;
    }
#line 629
    skip = i - 1L;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  *tpp = tp;
#line 633
  return ((_Bool)0);
}
}
#line 639 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static char const   *memchr_kwset(char const   *s , ptrdiff_t n , kwset_t kwset ) 
{ 
  char const   *slim ;
  unsigned char tmp ;
  int small_heuristic ;
  size_t small_bytes ;
  unsigned char tmp___0 ;
  void *tmp___1 ;

  {
#line 642
  slim = s + n;
#line 643
  if (kwset->gc1help < 0) {
    {
#line 645
    while (1) {
      while_continue: /* CIL Label */ ;
#line 645
      if (! ((unsigned long )s < (unsigned long )slim)) {
#line 645
        goto while_break;
      }
      {
#line 646
      tmp = U((char )*s);
      }
#line 646
      if (kwset->next[tmp]) {
#line 647
        return (s);
      }
#line 645
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 651
    small_heuristic = 2;
#line 652
    small_bytes = (unsigned long )small_heuristic * sizeof(unsigned long );
    {
#line 653
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 653
      if (! ((unsigned long )s < (unsigned long )slim)) {
#line 653
        goto while_break___0;
      }
      {
#line 655
      tmp___0 = U((char )*s);
      }
#line 655
      if (kwset->next[tmp___0]) {
#line 656
        return (s);
      }
#line 657
      s ++;
#line 658
      if ((uintptr_t )s % small_bytes == 0UL) {
        {
#line 659
        tmp___1 = memchr2((void const   *)s, kwset->gc1, kwset->gc1help, (size_t )(slim - s));
        }
#line 659
        return ((char const   *)tmp___1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 662
  return ((char const   *)((void *)0));
}
}
#line 666 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
__inline static ptrdiff_t bmexec_trans(kwset_t kwset , char const   *text , ptrdiff_t size ) 
{ 
  unsigned char const   *d1 ;
  char const   *ep ;
  char const   *sp ;
  char const   *tp ;
  int d ;
  ptrdiff_t len ;
  char const   *trans ;
  long tmp ;
  char gc1 ;
  char gc2 ;
  ptrdiff_t len12 ;
  char const   *tp0 ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  int advance_heuristic ;
  _Bool tmp___10 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___59 ;
  int tmp___62 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  unsigned char tmp___70 ;
  unsigned char tmp___71 ;
  _Bool tmp___72 ;

  {
#line 669
  if (! (0L <= size)) {
    {
#line 669
    __builtin_unreachable();
    }
  }
#line 673
  len = kwset->mind;
#line 674
  trans = kwset->trans;
#line 676
  if (len == 0L) {
#line 677
    return ((ptrdiff_t )0);
  }
#line 678
  if (len > size) {
#line 679
    return ((ptrdiff_t )-1);
  }
#line 680
  if (len == 1L) {
    {
#line 682
    tp = memchr_kwset(text, size, kwset);
    }
#line 683
    if (tp) {
#line 683
      tmp = tp - text;
    } else {
#line 683
      tmp = -1L;
    }
#line 683
    return (tmp);
  }
#line 686
  d1 = (unsigned char const   *)(kwset->delta);
#line 687
  sp = (char const   *)(kwset->target + len);
#line 688
  tp = text + len;
#line 689
  gc1 = (char )kwset->gc1;
#line 690
  gc2 = kwset->gc2;
#line 694
  if (sizeof(len12) == sizeof(signed char )) {
#line 694
    if (sizeof(len * 12L) < sizeof(signed char )) {
#line 694
      if (~ (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 694
        if ((int )((signed char )len) < 0) {
#line 694
          goto _L;
        } else {
#line 694
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 694
        if ((int )((signed char )len) < 0) {
#line 694
          tmp___15 = (int )((signed char )len) < ~ (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
        } else {
#line 694
          tmp___15 = (((1 << (sizeof((int )((signed char )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )((signed char )len);
        }
#line 694
        if (tmp___15) {
#line 694
          goto _L;
        } else
#line 694
        if ((int )((signed char )len) * 12 < -128) {
#line 694
          goto _L;
        } else
#line 694
        if (127 < (int )((signed char )len) * 12) {
          _L: /* CIL Label */ 
#line 694
          if ((int )((unsigned char )((signed char )len)) * 12 <= 127) {
#line 694
            len12 = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )len)) * 12));
          } else {
#line 694
            len12 = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )len)) * 12 - -128)) + -128);
          }
#line 694
          tmp___13 = 1;
        } else {
#line 694
          if ((int )((unsigned char )((signed char )len)) * 12 <= 127) {
#line 694
            len12 = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )len)) * 12));
          } else {
#line 694
            len12 = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )len)) * 12 - -128)) + -128);
          }
#line 694
          tmp___13 = 0;
        }
      }
#line 694
      tmp___21 = tmp___13;
    } else {
#line 694
      if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
        if (len < 0L) {
#line 694
          goto _L___1;
        } else {
#line 694
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 694
        if (len < 0L) {
#line 694
          tmp___20 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
        } else {
#line 694
          tmp___20 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
        }
#line 694
        if (tmp___20) {
#line 694
          goto _L___1;
        } else
#line 694
        if (len * 12L < -128L) {
#line 694
          goto _L___1;
        } else
#line 694
        if (127L < len * 12L) {
          _L___1: /* CIL Label */ 
#line 694
          if ((int )((unsigned char )len) * 12 <= 127) {
#line 694
            len12 = (ptrdiff_t )((signed char )((int )((unsigned char )len) * 12));
          } else {
#line 694
            len12 = (ptrdiff_t )((int )((signed char )((int )((unsigned char )len) * 12 - -128)) + -128);
          }
#line 694
          tmp___18 = 1;
        } else {
#line 694
          if ((int )((unsigned char )len) * 12 <= 127) {
#line 694
            len12 = (ptrdiff_t )((signed char )((int )((unsigned char )len) * 12));
          } else {
#line 694
            len12 = (ptrdiff_t )((int )((signed char )((int )((unsigned char )len) * 12 - -128)) + -128);
          }
#line 694
          tmp___18 = 0;
        }
      }
#line 694
      tmp___21 = tmp___18;
    }
#line 694
    tmp___69 = tmp___21;
  } else {
#line 694
    if (sizeof(len12) == sizeof(short )) {
#line 694
      if (sizeof(len * 12L) < sizeof(short )) {
#line 694
        if (~ (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 694
          if ((int )((short )len) < 0) {
#line 694
            goto _L___3;
          } else {
#line 694
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 694
          if ((int )((short )len) < 0) {
#line 694
            tmp___26 = (int )((short )len) < ~ (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
          } else {
#line 694
            tmp___26 = (((1 << (sizeof((int )((short )len)) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )((short )len);
          }
#line 694
          if (tmp___26) {
#line 694
            goto _L___3;
          } else
#line 694
          if ((int )((short )len) * 12 < -32768) {
#line 694
            goto _L___3;
          } else
#line 694
          if (32767 < (int )((short )len) * 12) {
            _L___3: /* CIL Label */ 
#line 694
            if ((int )((unsigned short )((short )len)) * 12 <= 32767) {
#line 694
              len12 = (ptrdiff_t )((short )((int )((unsigned short )((short )len)) * 12));
            } else {
#line 694
              len12 = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )len)) * 12 - -32768)) + -32768);
            }
#line 694
            tmp___24 = 1;
          } else {
#line 694
            if ((int )((unsigned short )((short )len)) * 12 <= 32767) {
#line 694
              len12 = (ptrdiff_t )((short )((int )((unsigned short )((short )len)) * 12));
            } else {
#line 694
              len12 = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )len)) * 12 - -32768)) + -32768);
            }
#line 694
            tmp___24 = 0;
          }
        }
#line 694
        tmp___32 = tmp___24;
      } else {
#line 694
        if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
          if (len < 0L) {
#line 694
            goto _L___5;
          } else {
#line 694
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
#line 694
          if (len < 0L) {
#line 694
            tmp___31 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
          } else {
#line 694
            tmp___31 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
          }
#line 694
          if (tmp___31) {
#line 694
            goto _L___5;
          } else
#line 694
          if (len * 12L < -32768L) {
#line 694
            goto _L___5;
          } else
#line 694
          if (32767L < len * 12L) {
            _L___5: /* CIL Label */ 
#line 694
            if ((int )((unsigned short )len) * 12 <= 32767) {
#line 694
              len12 = (ptrdiff_t )((short )((int )((unsigned short )len) * 12));
            } else {
#line 694
              len12 = (ptrdiff_t )((int )((short )((int )((unsigned short )len) * 12 - -32768)) + -32768);
            }
#line 694
            tmp___29 = 1;
          } else {
#line 694
            if ((int )((unsigned short )len) * 12 <= 32767) {
#line 694
              len12 = (ptrdiff_t )((short )((int )((unsigned short )len) * 12));
            } else {
#line 694
              len12 = (ptrdiff_t )((int )((short )((int )((unsigned short )len) * 12 - -32768)) + -32768);
            }
#line 694
            tmp___29 = 0;
          }
        }
#line 694
        tmp___32 = tmp___29;
      }
#line 694
      tmp___68 = tmp___32;
    } else {
#line 694
      if (sizeof(len12) == sizeof(int )) {
#line 694
        if (sizeof(len * 12L) < sizeof(int )) {
#line 694
          if (~ (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 694
            if ((int )len < 0) {
#line 694
              goto _L___7;
            } else {
#line 694
              goto _L___8;
            }
          } else {
            _L___8: /* CIL Label */ 
#line 694
            if ((int )len < 0) {
#line 694
              tmp___37 = (int )len < ~ (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) / 12;
            } else {
#line 694
              tmp___37 = (((1 << (sizeof((int )len) * 8UL - 2UL)) - 1) * 2 + 1) / 12 < (int )len;
            }
#line 694
            if (tmp___37) {
#line 694
              goto _L___7;
            } else
#line 694
            if ((int )len * 12 < (-0x7FFFFFFF-1)) {
#line 694
              goto _L___7;
            } else
#line 694
            if (2147483647 < (int )len * 12) {
              _L___7: /* CIL Label */ 
#line 694
              if ((unsigned int )((int )len) * 12U <= 2147483647U) {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
              } else {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 694
              tmp___35 = 1;
            } else {
#line 694
              if ((unsigned int )((int )len) * 12U <= 2147483647U) {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U));
              } else {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )((int )len) * 12U - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 694
              tmp___35 = 0;
            }
          }
#line 694
          tmp___43 = tmp___35;
        } else {
#line 694
          if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
            if (len < 0L) {
#line 694
              goto _L___9;
            } else {
#line 694
              goto _L___10;
            }
          } else {
            _L___10: /* CIL Label */ 
#line 694
            if (len < 0L) {
#line 694
              tmp___42 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
            } else {
#line 694
              tmp___42 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
            }
#line 694
            if (tmp___42) {
#line 694
              goto _L___9;
            } else
#line 694
            if (len * 12L < (-0x7FFFFFFF-1)) {
#line 694
              goto _L___9;
            } else
#line 694
            if (2147483647L < len * 12L) {
              _L___9: /* CIL Label */ 
#line 694
              if ((unsigned int )len * 12U <= 2147483647U) {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
              } else {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )len * 12U - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 694
              tmp___40 = 1;
            } else {
#line 694
              if ((unsigned int )len * 12U <= 2147483647U) {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )len * 12U));
              } else {
#line 694
                len12 = (ptrdiff_t )((int )((unsigned int )len * 12U - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 694
              tmp___40 = 0;
            }
          }
#line 694
          tmp___43 = tmp___40;
        }
#line 694
        tmp___67 = tmp___43;
      } else {
#line 694
        if (sizeof(len12) == sizeof(long )) {
#line 694
          if (sizeof(len * 12L) < sizeof(long )) {
#line 694
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
              if (len < 0L) {
#line 694
                goto _L___11;
              } else {
#line 694
                goto _L___12;
              }
            } else {
              _L___12: /* CIL Label */ 
#line 694
              if (len < 0L) {
#line 694
                tmp___48 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 694
                tmp___48 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 694
              if (tmp___48) {
#line 694
                goto _L___11;
              } else
#line 694
              if (len * 12L < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 694
                goto _L___11;
              } else
#line 694
              if (9223372036854775807L < len * 12L) {
                _L___11: /* CIL Label */ 
#line 694
                if ((unsigned long )len * 12UL <= 9223372036854775807UL) {
#line 694
                  len12 = (long )((unsigned long )len * 12UL);
                } else {
#line 694
                  len12 = (long )((unsigned long )len * 12UL - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 694
                tmp___46 = 1;
              } else {
#line 694
                if ((unsigned long )len * 12UL <= 9223372036854775807UL) {
#line 694
                  len12 = (long )((unsigned long )len * 12UL);
                } else {
#line 694
                  len12 = (long )((unsigned long )len * 12UL - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 694
                tmp___46 = 0;
              }
            }
#line 694
            tmp___54 = tmp___46;
          } else {
#line 694
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
              if (len < 0L) {
#line 694
                goto _L___13;
              } else {
#line 694
                goto _L___14;
              }
            } else {
              _L___14: /* CIL Label */ 
#line 694
              if (len < 0L) {
#line 694
                tmp___53 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 694
                tmp___53 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 694
              if (tmp___53) {
#line 694
                goto _L___13;
              } else
#line 694
              if (len * 12L < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 694
                goto _L___13;
              } else
#line 694
              if (9223372036854775807L < len * 12L) {
                _L___13: /* CIL Label */ 
#line 694
                if ((unsigned long )len * 12UL <= 9223372036854775807UL) {
#line 694
                  len12 = (long )((unsigned long )len * 12UL);
                } else {
#line 694
                  len12 = (long )((unsigned long )len * 12UL - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 694
                tmp___51 = 1;
              } else {
#line 694
                if ((unsigned long )len * 12UL <= 9223372036854775807UL) {
#line 694
                  len12 = (long )((unsigned long )len * 12UL);
                } else {
#line 694
                  len12 = (long )((unsigned long )len * 12UL - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 694
                tmp___51 = 0;
              }
            }
#line 694
            tmp___54 = tmp___51;
          }
#line 694
          tmp___66 = tmp___54;
        } else {
#line 694
          if (sizeof(len * 12L) < sizeof(long long )) {
#line 694
            if (~ (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 694
              if ((long long )len < 0LL) {
#line 694
                goto _L___15;
              } else {
#line 694
                goto _L___16;
              }
            } else {
              _L___16: /* CIL Label */ 
#line 694
              if ((long long )len < 0LL) {
#line 694
                tmp___59 = (long long )len < ~ (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / 12LL;
              } else {
#line 694
                tmp___59 = (((1LL << (sizeof((long long )len) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / 12LL < (long long )len;
              }
#line 694
              if (tmp___59) {
#line 694
                goto _L___15;
              } else
#line 694
              if ((long long )len * 12LL < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 694
                goto _L___15;
              } else
#line 694
              if (9223372036854775807LL < (long long )len * 12LL) {
                _L___15: /* CIL Label */ 
#line 694
                if ((unsigned long long )((long long )len) * 12ULL <= 9223372036854775807ULL) {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
                } else {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 694
                tmp___57 = 1;
              } else {
#line 694
                if ((unsigned long long )((long long )len) * 12ULL <= 9223372036854775807ULL) {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL));
                } else {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )((long long )len) * 12ULL - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 694
                tmp___57 = 0;
              }
            }
#line 694
            tmp___65 = tmp___57;
          } else {
#line 694
            if (~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 694
              if (len < 0L) {
#line 694
                goto _L___17;
              } else {
#line 694
                goto _L___18;
              }
            } else {
              _L___18: /* CIL Label */ 
#line 694
              if (len < 0L) {
#line 694
                tmp___64 = len < ~ (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L;
              } else {
#line 694
                tmp___64 = (((1L << (sizeof(len) * 8UL - 2UL)) - 1L) * 2L + 1L) / 12L < len;
              }
#line 694
              if (tmp___64) {
#line 694
                goto _L___17;
              } else
#line 694
              if ((long long )(len * 12L) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 694
                goto _L___17;
              } else
#line 694
              if (9223372036854775807LL < (long long )(len * 12L)) {
                _L___17: /* CIL Label */ 
#line 694
                if ((unsigned long long )len * 12ULL <= 9223372036854775807ULL) {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
                } else {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 694
                tmp___62 = 1;
              } else {
#line 694
                if ((unsigned long long )len * 12ULL <= 9223372036854775807ULL) {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL));
                } else {
#line 694
                  len12 = (ptrdiff_t )((long long )((unsigned long long )len * 12ULL - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 694
                tmp___62 = 0;
              }
            }
#line 694
            tmp___65 = tmp___62;
          }
#line 694
          tmp___66 = tmp___65;
        }
#line 694
        tmp___67 = tmp___66;
      }
#line 694
      tmp___68 = tmp___67;
    }
#line 694
    tmp___69 = tmp___68;
  }
#line 694
  if (! tmp___69) {
#line 694
    if (len12 < size) {
#line 696
      ep = (text + size) - 11L * len;
      {
#line 696
      while (1) {
        while_continue: /* CIL Label */ ;
#line 696
        if (! ((unsigned long )tp <= (unsigned long )ep)) {
#line 696
          goto while_break;
        }
        {
#line 698
        tp0 = tp;
#line 699
        tmp___0 = U((char )*(tp + -1));
#line 699
        d = (int )*(d1 + tmp___0);
#line 699
        tp += d;
#line 700
        tmp___1 = U((char )*(tp + -1));
#line 700
        d = (int )*(d1 + tmp___1);
#line 700
        tp += d;
        }
#line 701
        if (d != 0) {
          {
#line 703
          tmp___2 = U((char )*(tp + -1));
#line 703
          d = (int )*(d1 + tmp___2);
#line 703
          tp += d;
#line 704
          tmp___3 = U((char )*(tp + -1));
#line 704
          d = (int )*(d1 + tmp___3);
#line 704
          tp += d;
#line 705
          tmp___4 = U((char )*(tp + -1));
#line 705
          d = (int )*(d1 + tmp___4);
#line 705
          tp += d;
          }
#line 706
          if (d != 0) {
            {
#line 708
            tmp___5 = U((char )*(tp + -1));
#line 708
            d = (int )*(d1 + tmp___5);
#line 708
            tp += d;
#line 709
            tmp___6 = U((char )*(tp + -1));
#line 709
            d = (int )*(d1 + tmp___6);
#line 709
            tp += d;
#line 710
            tmp___7 = U((char )*(tp + -1));
#line 710
            d = (int )*(d1 + tmp___7);
#line 710
            tp += d;
            }
#line 711
            if (d != 0) {
              {
#line 713
              tmp___8 = U((char )*(tp + -1));
#line 713
              d = (int )*(d1 + tmp___8);
#line 713
              tp += d;
#line 714
              tmp___9 = U((char )*(tp + -1));
#line 714
              d = (int )*(d1 + tmp___9);
#line 714
              tp += d;
#line 718
              advance_heuristic = (int )(16UL * sizeof(long ));
              }
#line 719
              if ((long )advance_heuristic <= tp - tp0) {
#line 720
                goto __Cont;
              }
              {
#line 721
              tp --;
#line 722
              tp = memchr_kwset(tp, (text + size) - tp, kwset);
              }
#line 723
              if (! tp) {
#line 724
                return ((ptrdiff_t )-1);
              }
#line 725
              tp ++;
#line 726
              if ((unsigned long )ep <= (unsigned long )tp) {
#line 727
                goto while_break;
              }
            }
          }
        }
        {
#line 731
        tmp___10 = bm_delta2_search(& tp, ep, sp, len, trans, gc1, gc2, d1, kwset);
        }
#line 731
        if (tmp___10) {
#line 732
          return (tp - text);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 737
  ep = text + size;
#line 738
  tmp___70 = U((char )*(tp + -1));
#line 738
  d = (int )*(d1 + tmp___70);
  }
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 739
    if (! ((long )d <= ep - tp)) {
#line 739
      goto while_break___0;
    }
    {
#line 741
    tp += d;
#line 741
    tmp___71 = U((char )*(tp + -1));
#line 741
    d = (int )*(d1 + tmp___71);
    }
#line 742
    if (d != 0) {
#line 743
      goto while_continue___0;
    }
    {
#line 744
    tmp___72 = bm_delta2_search(& tp, ep, sp, len, trans, gc1, gc2, (unsigned char const   *)((void *)0),
                                kwset);
    }
#line 744
    if (tmp___72) {
#line 745
      return (tp - text);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  return ((ptrdiff_t )-1);
}
}
#line 752 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static ptrdiff_t bmexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) 
{ 
  ptrdiff_t ret ;
  ptrdiff_t tmp ;
  ptrdiff_t tmp___0 ;
  ptrdiff_t tmp___1 ;

  {
#line 758
  if (kwset->trans) {
    {
#line 758
    tmp = bmexec_trans(kwset, text, size);
#line 758
    tmp___1 = tmp;
    }
  } else {
    {
#line 758
    tmp___0 = bmexec_trans(kwset, text, size);
#line 758
    tmp___1 = tmp___0;
    }
  }
#line 758
  ret = tmp___1;
#line 762
  if (0L <= ret) {
#line 764
    kwsmatch->index = (ptrdiff_t )0;
#line 765
    kwsmatch->offset[0] = ret;
#line 766
    kwsmatch->size[0] = kwset->mind;
  }
#line 769
  return (ret);
}
}
#line 774 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
__inline static ptrdiff_t acexec_trans(kwset_t kwset , char const   *text , ptrdiff_t len ,
                                       struct kwsmatch *kwsmatch , _Bool longest ) 
{ 
  struct trie  const  *trie ;
  struct trie  const  *accept ;
  char const   *tp ;
  char const   *left ;
  char const   *lim ;
  struct tree  const  *tree ;
  char const   *trans ;
  unsigned char c ;
  int gc1 ;
  char const   *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char tmp___2 ;
  char const   *tmp___3 ;
  char tmp___4 ;
  struct trie  const  *accept1 ;
  char const   *left1 ;
  unsigned char c___0 ;
  char const   *tmp___5 ;
  char tmp___6 ;

  {
#line 784
  if (len < kwset->mind) {
#line 785
    return ((ptrdiff_t )-1);
  }
#line 786
  trans = kwset->trans;
#line 787
  trie = (struct trie  const  *)kwset->trie;
#line 788
  lim = text + len;
#line 789
  tp = text;
#line 791
  if (! trie->accepting) {
#line 794
    gc1 = kwset->gc1;
    {
#line 796
    while (1) {
      while_continue: /* CIL Label */ ;
#line 798
      if (gc1 < 0) {
        {
#line 800
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 800
          tmp = tp;
#line 800
          tp ++;
#line 800
          tmp___0 = tr(trans, (char )*tmp);
#line 800
          c = (unsigned char )tmp___0;
#line 800
          trie = (struct trie  const  *)kwset->next[c];
          }
#line 800
          if (trie) {
#line 800
            goto while_break___0;
          }
#line 801
          if ((unsigned long )tp >= (unsigned long )lim) {
#line 802
            return ((ptrdiff_t )-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 806
        tp = memchr_kwset(tp, lim - tp, kwset);
        }
#line 807
        if (! tp) {
#line 808
          return ((ptrdiff_t )-1);
        }
        {
#line 809
        tmp___1 = tp;
#line 809
        tp ++;
#line 809
        tmp___2 = tr(trans, (char )*tmp___1);
#line 809
        c = (unsigned char )tmp___2;
#line 810
        trie = (struct trie  const  *)kwset->next[c];
        }
      }
      {
#line 813
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 815
        if (trie->accepting) {
#line 816
          goto match;
        }
#line 817
        if ((unsigned long )tp >= (unsigned long )lim) {
#line 818
          return ((ptrdiff_t )-1);
        }
        {
#line 819
        tmp___3 = tp;
#line 819
        tp ++;
#line 819
        tmp___4 = tr(trans, (char )*tmp___3);
#line 819
        c = (unsigned char )tmp___4;
#line 821
        tree = (struct tree  const  *)trie->links;
        }
        {
#line 821
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 821
          if (! ((int )c != (int )tree->label)) {
#line 821
            goto while_break___2;
          }
#line 823
          if ((int )c < (int )tree->label) {
#line 823
            tree = (struct tree  const  *)tree->llink;
          } else {
#line 823
            tree = (struct tree  const  *)tree->rlink;
          }
#line 824
          if (! tree) {
#line 826
            trie = (struct trie  const  *)trie->fail;
#line 827
            if (! trie) {
#line 829
              trie = (struct trie  const  *)kwset->next[c];
#line 830
              if (trie) {
#line 831
                goto have_trie;
              }
#line 832
              if ((unsigned long )tp >= (unsigned long )lim) {
#line 833
                return ((ptrdiff_t )-1);
              }
#line 834
              goto next_c;
            }
#line 836
            if (trie->accepting) {
#line 838
              tp --;
#line 839
              goto match;
            }
#line 841
            tree = (struct tree  const  *)trie->links;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 844
        trie = (struct trie  const  *)tree->trie;
        have_trie: ;
      }
      while_break___1: /* CIL Label */ ;
      }
      next_c: ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  match: 
#line 852
  accept = trie;
  {
#line 853
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 853
    if (! (accept->accepting == 0xffffffffffffffffUL)) {
#line 853
      goto while_break___3;
    }
#line 854
    accept = (struct trie  const  *)accept->fail;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 855
  left = tp - accept->depth;
#line 858
  if (longest) {
    {
#line 860
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 860
      if (! ((unsigned long )tp < (unsigned long )lim)) {
#line 860
        goto while_break___4;
      }
      {
#line 864
      tmp___5 = tp;
#line 864
      tp ++;
#line 864
      tmp___6 = tr(trans, (char )*tmp___5);
#line 864
      c___0 = (unsigned char )tmp___6;
      }
      {
#line 866
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 868
        tree = (struct tree  const  *)trie->links;
        {
#line 869
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 869
          if (tree) {
#line 869
            if (! ((int )c___0 != (int )tree->label)) {
#line 869
              goto while_break___6;
            }
          } else {
#line 869
            goto while_break___6;
          }
#line 870
          if ((int )c___0 < (int )tree->label) {
#line 870
            tree = (struct tree  const  *)tree->llink;
          } else {
#line 870
            tree = (struct tree  const  *)tree->rlink;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 866
        if (! tree) {
#line 866
          trie = (struct trie  const  *)trie->fail;
#line 866
          if (trie) {
#line 866
            if (! (accept->depth <= trie->depth)) {
#line 866
              goto while_break___5;
            }
          } else {
#line 866
            goto while_break___5;
          }
        } else {
#line 866
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 874
      if (! tree) {
#line 875
        goto while_break___4;
      }
#line 876
      trie = (struct trie  const  *)tree->trie;
#line 877
      if (trie->accepting) {
#line 879
        accept1 = trie;
        {
#line 880
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 880
          if (! (accept1->accepting == 0xffffffffffffffffUL)) {
#line 880
            goto while_break___7;
          }
#line 881
          accept1 = (struct trie  const  *)accept1->fail;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 882
        left1 = tp - accept1->depth;
#line 883
        if ((unsigned long )left1 <= (unsigned long )left) {
#line 885
          left = left1;
#line 886
          accept = accept1;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 892
  kwsmatch->index = (ptrdiff_t )(accept->accepting / 2UL);
#line 893
  kwsmatch->offset[0] = left - text;
#line 894
  kwsmatch->size[0] = (ptrdiff_t )accept->depth;
#line 896
  return (left - text);
}
}
#line 900 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
static ptrdiff_t acexec(kwset_t kwset , char const   *text , ptrdiff_t size , struct kwsmatch *kwsmatch ,
                        _Bool longest ) 
{ 
  ptrdiff_t tmp ;
  ptrdiff_t tmp___0 ;
  ptrdiff_t tmp___1 ;

  {
#line 904
  if (! (0L <= size)) {
    {
#line 904
    __builtin_unreachable();
    }
  }
#line 907
  if (kwset->trans) {
    {
#line 907
    tmp = acexec_trans(kwset, text, size, kwsmatch, longest);
#line 907
    tmp___1 = tmp;
    }
  } else {
    {
#line 907
    tmp___0 = acexec_trans(kwset, text, size, kwsmatch, longest);
#line 907
    tmp___1 = tmp___0;
    }
  }
#line 907
  return (tmp___1);
}
}
#line 918 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
ptrdiff_t ( __attribute__((__nonnull__(4))) kwsexec)(kwset_t kwset , char const   *text ,
                                                     ptrdiff_t size , struct kwsmatch *kwsmatch ,
                                                     _Bool longest ) 
{ 
  ptrdiff_t tmp ;

  {
  {
#line 922
  tmp = (*(kwset->kwsexec))(kwset, text, size, kwsmatch, longest);
  }
#line 922
  return (tmp);
}
}
#line 926 "/home/khheo/project/benchmark/grep-3.0/src/kwset.c"
void kwsfree(kwset_t kwset ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 929
  __o = & kwset->obstack;
#line 929
  __obj = (void *)0;
#line 929
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 929
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 929
      tmp = (char *)__obj;
#line 929
      __o->object_base = tmp;
#line 929
      __o->next_free = tmp;
    } else {
      {
#line 929
      _obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 929
    _obstack_free(__o, __obj);
    }
  }
  {
#line 930
  free((void *)kwset);
  }
#line 931
  return;
}
}
#line 80 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 58
void *GEAcompile(char *pattern , size_t size , reg_syntax_t syntax_bits ) ;
#line 59
size_t EGexecute(void *vdc , char const   *buf , size_t size , size_t *match_size ,
                 char const   *start_ptr ) ;
#line 62
void *Fcompile(char *pattern , size_t size , reg_syntax_t ignored ) ;
#line 63
size_t Fexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) ;
#line 71
void fgrep_to_grep_pattern(char **keys_p , size_t *len_p ) ;
#line 84
#pragma GCC diagnostic pop
#line 49 "/home/khheo/project/benchmark/grep-3.0/src/kwsearch.c"
void *Fcompile(char *pattern , size_t size , reg_syntax_t ignored ) 
{ 
  kwset_t kwset ;
  ptrdiff_t total ;
  char *buf ;
  size_t bufalloc___0 ;
  char const   *p ;
  ptrdiff_t len ;
  char const   *sep ;
  void *tmp ;
  void *tmp___0 ;
  ptrdiff_t words ;
  ptrdiff_t tmp___1 ;
  mbstate_t mbs ;
  char checked[256] ;
  unsigned int tmp___2 ;
  unsigned char c ;
  wint_t wc ;
  wchar_t folded[32] ;
  int i ;
  int tmp___3 ;
  char s[16] ;
  int nbytes ;
  size_t tmp___4 ;
  struct kwsearch *kwsearch ;
  void *tmp___5 ;

  {
  {
#line 53
  total = (ptrdiff_t )size;
#line 54
  buf = (char *)((void *)0);
#line 55
  bufalloc___0 = (size_t )0;
#line 57
  kwset = kwsinit((_Bool)1);
#line 59
  p = (char const   *)pattern;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp = memchr((void const   *)p, '\n', (size_t )total);
#line 63
    sep = (char const   *)tmp;
    }
#line 64
    if (sep) {
#line 66
      len = sep - p;
#line 67
      sep ++;
#line 68
      total -= len + 1L;
    } else {
#line 72
      len = total;
#line 73
      total = (ptrdiff_t )0;
    }
#line 76
    if (match_lines) {
#line 78
      if ((int )eolbyte == 10) {
#line 78
        if ((unsigned long )pattern < (unsigned long )p) {
#line 78
          if (sep) {
#line 79
            p --;
          } else {
#line 78
            goto _L___0;
          }
        } else {
#line 78
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 82
        if (bufalloc___0 < (size_t )(len + 2L)) {
          {
#line 84
          free((void *)buf);
#line 85
          bufalloc___0 = (size_t )(len + 2L);
#line 86
          tmp___0 = x2realloc((void *)0, & bufalloc___0);
#line 86
          buf = (char *)tmp___0;
#line 87
          *(buf + 0) = eolbyte;
          }
        }
        {
#line 89
        memcpy((void */* __restrict  */)(buf + 1), (void const   */* __restrict  */)p,
               (size_t )len);
#line 90
        *(buf + (len + 1L)) = eolbyte;
#line 91
        p = (char const   *)buf;
        }
      }
#line 93
      len += 2L;
    }
    {
#line 95
    kwsincr(kwset, p, len);
#line 97
    p = sep;
    }
#line 60
    if (! p) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)buf);
#line 102
  tmp___1 = kwswords(kwset);
#line 102
  words = tmp___1;
  }
#line 104
  if (match_icase) {
#line 114
    mbs.__count = 0;
#line 114
    mbs.__value.__wch = 0U;
#line 115
    checked[0] = (char)0;
#line 115
    tmp___2 = 1U;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (tmp___2 >= 256U) {
#line 115
        goto while_break___0;
      }
#line 115
      checked[tmp___2] = (char)0;
#line 115
      tmp___2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    p = (char const   *)pattern;
    {
#line 116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      if (! ((unsigned long )p < (unsigned long )(pattern + size))) {
#line 116
        goto while_break___1;
      }
#line 118
      c = (unsigned char )*p;
#line 119
      if (checked[c]) {
#line 120
        goto __Cont;
      }
      {
#line 121
      checked[c] = (char)1;
#line 123
      wc = localeinfo.sbctowc[c];
#line 126
      tmp___3 = case_folded_counterparts(wc, (wchar_t *)(folded));
#line 126
      i = tmp___3;
      }
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 126
        i --;
#line 126
        if (! (0 <= i)) {
#line 126
          goto while_break___2;
        }
        {
#line 129
        tmp___4 = wcrtomb((char */* __restrict  */)(s), folded[i], (mbstate_t */* __restrict  */)(& mbs));
#line 129
        nbytes = (int )tmp___4;
        }
#line 130
        if (1 < nbytes) {
          {
#line 131
          kwsincr(kwset, (char const   *)(s), (ptrdiff_t )nbytes);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 116
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 136
  kwsprep(kwset);
#line 138
  tmp___5 = xmalloc(sizeof(*kwsearch));
#line 138
  kwsearch = (struct kwsearch *)tmp___5;
#line 139
  kwsearch->kwset = kwset;
#line 140
  kwsearch->words = words;
#line 141
  kwsearch->pattern = pattern;
#line 142
  kwsearch->size = size;
#line 143
  kwsearch->re = (void *)0;
  }
#line 144
  return ((void *)kwsearch);
}
}
#line 151 "/home/khheo/project/benchmark/grep-3.0/src/kwsearch.c"
size_t Fexecute(void *vcp , char const   *buf , size_t size , size_t *match_size ,
                char const   *start_ptr ) 
{ 
  char const   *beg ;
  char const   *end ;
  char const   *mb_start ;
  ptrdiff_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  size_t ret_val ;
  _Bool mb_check ;
  _Bool longest ;
  struct kwsearch *kwsearch ;
  kwset_t kwset ;
  ptrdiff_t offset ;
  ptrdiff_t tmp ;
  size_t tmp___0 ;
  ptrdiff_t tmp___1 ;
  char const   *bol ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t off ;

  {
#line 157
  eol = eolbyte;
#line 162
  kwsearch = (struct kwsearch *)vcp;
#line 163
  kwset = kwsearch->kwset;
#line 165
  if (match_lines) {
#line 166
    longest = (_Bool)0;
#line 166
    mb_check = longest;
  } else {
#line 169
    mb_check = (_Bool )((int )localeinfo.multibyte & ! localeinfo.using_utf8);
#line 170
    longest = (_Bool )(((int )mb_check | ! (! start_ptr)) | (int )match_words);
  }
#line 173
  if (start_ptr) {
#line 173
    beg = start_ptr;
  } else {
#line 173
    beg = buf;
  }
#line 173
  mb_start = beg;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
#line 173
      goto while_break;
    }
    {
#line 175
    tmp = kwsexec(kwset, beg - (int )match_lines, ((buf + size) - beg) + (long )match_lines,
                  & kwsmatch, longest);
#line 175
    offset = tmp;
    }
#line 178
    if (offset < 0L) {
#line 179
      goto while_break;
    }
#line 180
    len = kwsmatch.size[0] - (ptrdiff_t )(2 * (int )match_lines);
#line 182
    if (kwsearch->words <= kwsmatch.index) {
#line 188
      if (! kwsearch->re) {
        {
#line 190
        fgrep_to_grep_pattern(& kwsearch->pattern, & kwsearch->size);
#line 191
        kwsearch->re = GEAcompile(kwsearch->pattern, kwsearch->size, (((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
        }
      }
      {
#line 194
      tmp___0 = EGexecute(kwsearch->re, buf, size, match_size, start_ptr);
      }
#line 194
      return (tmp___0);
    }
#line 197
    if (mb_check) {
      {
#line 197
      tmp___1 = mb_goback(& mb_start, beg + offset, buf + size);
      }
#line 197
      if (tmp___1 != 0L) {
#line 212
        beg = mb_start - 1;
#line 213
        goto __Cont;
      }
    }
#line 215
    beg += offset;
#line 216
    if (! (! start_ptr) & ! match_words) {
#line 217
      goto success_in_beg_and_len;
    }
#line 218
    if (match_lines) {
#line 220
      len += (ptrdiff_t )((unsigned long )start_ptr == (unsigned long )((void *)0));
#line 221
      goto success_in_beg_and_len;
    }
#line 223
    if (! match_words) {
#line 224
      goto success;
    }
    {
#line 229
    tmp___2 = memrchr((void const   *)mb_start, (int )eol, (size_t )(beg - mb_start));
#line 229
    bol = (char const   *)tmp___2;
    }
#line 230
    if (bol) {
#line 231
      mb_start = bol + 1;
    }
    {
#line 232
    tmp___4 = wordchar_prev(mb_start, beg, buf + size);
    }
#line 232
    if (! tmp___4) {
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 235
        tmp___3 = wordchar_next(beg + len, buf + size);
        }
#line 235
        if (! tmp___3) {
#line 237
          if (start_ptr) {
#line 238
            goto success_in_beg_and_len;
          } else {
#line 240
            goto success;
          }
        }
#line 242
        if (! len) {
#line 243
          goto while_break___0;
        }
        {
#line 244
        len --;
#line 244
        offset = kwsexec(kwset, beg, len, & kwsmatch, (_Bool)1);
        }
#line 245
        if (offset != 0L) {
#line 246
          goto while_break___0;
        }
#line 247
        len = kwsmatch.size[0];
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 253
    tmp___5 = wordchars_size(beg, buf + size);
#line 253
    beg += tmp___5;
#line 254
    mb_start = beg;
    }
    __Cont: /* CIL Label */ 
#line 173
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return ((size_t )-1);
  success: 
  {
#line 260
  tmp___6 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
#line 260
  end = (char const   *)tmp___6;
  }
#line 261
  if (end) {
#line 261
    end ++;
  } else {
#line 261
    end = buf + size;
  }
  {
#line 262
  tmp___7 = memrchr((void const   *)buf, (int )eol, (size_t )(beg - buf));
#line 262
  beg = (char const   *)tmp___7;
  }
#line 263
  if (beg) {
#line 263
    beg ++;
  } else {
#line 263
    beg = buf;
  }
#line 264
  len = end - beg;
  success_in_beg_and_len: 
#line 266
  off = (size_t )(beg - buf);
#line 268
  *match_size = (size_t )len;
#line 269
  ret_val = off;
#line 270
  return (ret_val);
}
}
#line 408 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 213 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 546
extern int putchar_unlocked(int __c ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 622
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 592 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70
#pragma GCC diagnostic pop
#line 31 "../lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc , char * const  *___argv ,
                                                            char const   *__shortopts ,
                                                            struct option  const  *__longopts ,
                                                            int *__longind ) ;
#line 27 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
_Bool match_icase  ;
#line 28 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
_Bool match_words  ;
#line 29 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
_Bool match_lines  ;
#line 30 "/home/khheo/project/benchmark/grep-3.0/src/grep.h"
char eolbyte  ;
#line 32
char const   * __attribute__((__pure__)) pattern_file_name(size_t lineno , size_t *new_lineno ) ;
#line 80 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
struct localeinfo localeinfo  ;
#line 84
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   SEP_STR_GROUP[3]  = {      (char const   )'-',      (char const   )'-',      (char const   )'\000'};
#line 64 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct stat out_stat  ;
#line 67 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int show_help  ;
#line 70 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool show_version  ;
#line 73 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool suppress_errors  ;
#line 76 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int color_option  ;
#line 79 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool only_matching  ;
#line 82 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool align_tabs  ;
#line 85 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int offset_width  ;
#line 101 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct FL_pair *fl_pair  ;
#line 102 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t n_fl_pair_slots  ;
#line 105 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t n_pattern_files  ;
#line 110 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t n_patterns  ;
#line 113 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t __attribute__((__pure__))  count_nl_bytes(char const   *buf , size_t size ) 
{ 
  char const   *p ;
  char const   *end_p ;
  size_t n ;
  void *tmp ;

  {
#line 116
  p = buf;
#line 117
  end_p = buf + size;
#line 118
  n = (size_t )0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    tmp = memchr((void const   *)p, '\n', (size_t )(end_p - p));
#line 119
    p = (char const   *)tmp;
    }
#line 119
    if (! p) {
#line 119
      goto while_break;
    }
#line 120
    p ++;
#line 120
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return ((size_t __attribute__((__pure__))  )n);
}
}
#line 126 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void fl_add(char const   *buf , size_t size , char const   *filename___0 ) 
{ 
  void *tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
#line 129
  if (n_fl_pair_slots <= n_pattern_files) {
    {
#line 130
    tmp = x2nrealloc((void *)fl_pair, & n_fl_pair_slots, sizeof(*fl_pair));
#line 130
    fl_pair = (struct FL_pair *)tmp;
    }
  }
  {
#line 132
  (fl_pair + n_pattern_files)->lineno = n_patterns + 1UL;
#line 133
  (fl_pair + n_pattern_files)->filename = filename___0;
#line 134
  n_pattern_files ++;
#line 135
  tmp___0 = count_nl_bytes(buf, size);
#line 135
  n_patterns += (size_t )tmp___0;
  }
#line 136
  return;
}
}
#line 141 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
char const   * __attribute__((__pure__)) pattern_file_name(size_t lineno , size_t *new_lineno ) 
{ 
  size_t i ;

  {
#line 145
  i = (size_t )1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < n_pattern_files)) {
#line 145
      goto while_break;
    }
#line 147
    if (lineno < (fl_pair + i)->lineno) {
#line 148
      goto while_break;
    }
#line 145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  *new_lineno = (lineno - (fl_pair + (i - 1UL))->lineno) + 1UL;
#line 152
  return ((char const   */* __attribute__((__pure__)) */)(fl_pair + (i - 1UL))->filename);
}
}
#line 177 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void clear_asan_poison(void) 
{ 


  {
#line 177
  return;
}
}
#line 178 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void asan_poison(void const volatile   *addr , size_t size ) 
{ 


  {
#line 178
  return;
}
}
#line 182 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *group_separator  =    SEP_STR_GROUP;
#line 229 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *selected_match_color  =    "01;31";
#line 230 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *context_match_color  =    "01;31";
#line 233 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *filename_color  =    "35";
#line 234 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *line_num_color  =    "32";
#line 235 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *byte_num_color  =    "32";
#line 236 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *sep_color  =    "36";
#line 237 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *selected_line_color  =    "";
#line 238 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *context_line_color  =    "";
#line 297 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *sgr_start  =    "\033[%sm\033[K";
#line 298 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *sgr_end  =    "\033[m\033[K";
#line 301 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void pr_sgr_start(char const   *s ) 
{ 


  {
#line 304
  if (*s) {
    {
#line 305
    print_start_colorize(sgr_start, s);
    }
  }
#line 306
  return;
}
}
#line 307 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void pr_sgr_end(char const   *s ) 
{ 


  {
#line 310
  if (*s) {
    {
#line 311
    print_end_colorize(sgr_end);
    }
  }
#line 312
  return;
}
}
#line 313 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void pr_sgr_start_if(char const   *s ) 
{ 


  {
#line 316
  if (color_option) {
    {
#line 317
    pr_sgr_start(s);
    }
  }
#line 318
  return;
}
}
#line 319 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void pr_sgr_end_if(char const   *s ) 
{ 


  {
#line 322
  if (color_option) {
    {
#line 323
    pr_sgr_end(s);
    }
  }
#line 324
  return;
}
}
#line 333 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void color_cap_mt_fct(void) 
{ 


  {
#line 337
  context_match_color = selected_match_color;
#line 338
  return;
}
}
#line 340 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void color_cap_rv_fct(void) 
{ 


  {
#line 344
  color_option = -1;
#line 345
  return;
}
}
#line 347 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void color_cap_ne_fct(void) 
{ 


  {
#line 350
  sgr_start = "\033[%sm";
#line 351
  sgr_end = "\033[m";
#line 352
  return;
}
}
#line 355 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct color_cap  const  color_dict[12]  = 
#line 355
  {      {"mt", & selected_match_color, & color_cap_mt_fct}, 
        {"ms", & selected_match_color, (void (*)(void))((void *)0)}, 
        {"mc", & context_match_color, (void (*)(void))((void *)0)}, 
        {"fn", & filename_color, (void (*)(void))((void *)0)}, 
        {"ln", & line_num_color, (void (*)(void))((void *)0)}, 
        {"bn", & byte_num_color, (void (*)(void))((void *)0)}, 
        {"se", & sep_color, (void (*)(void))((void *)0)}, 
        {"sl", & selected_line_color, (void (*)(void))((void *)0)}, 
        {"cx", & context_line_color, (void (*)(void))((void *)0)}, 
        {"rv", (char const   **)((void *)0), & color_cap_rv_fct}, 
        {"ne", (char const   **)((void *)0), & color_cap_ne_fct}, 
        {(char const   *)((void *)0), (char const   **)((void *)0), (void (*)(void))((void *)0)}};
#line 372 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int stdout_errno  ;
#line 374 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void putchar_errno(int c ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 377
  tmp___0 = putchar_unlocked(c);
  }
#line 377
  if (tmp___0 < 0) {
    {
#line 378
    tmp = __errno_location();
#line 378
    stdout_errno = *tmp;
    }
  }
#line 379
  return;
}
}
#line 381 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void fputs_errno(char const   *s ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 384
  tmp___0 = fputs_unlocked((char const   */* __restrict  */)s, (FILE */* __restrict  */)stdout);
  }
#line 384
  if (tmp___0 < 0) {
    {
#line 385
    tmp = __errno_location();
#line 385
    stdout_errno = *tmp;
    }
  }
#line 386
  return;
}
}
#line 388 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void ( /* format attribute */  printf_errno)(char const   *format  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 392
  __builtin_va_start(ap, format);
#line 393
  tmp___0 = vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
                     ap);
  }
#line 393
  if (tmp___0 < 0) {
    {
#line 394
    tmp = __errno_location();
#line 394
    stdout_errno = *tmp;
    }
  }
  {
#line 395
  __builtin_va_end(ap);
  }
#line 396
  return;
}
}
#line 398 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void fwrite_errno(void const   *ptr , size_t size , size_t nmemb ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
  {
#line 401
  tmp___0 = fwrite_unlocked((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stdout);
  }
#line 401
  if (tmp___0 != nmemb) {
    {
#line 402
    tmp = __errno_location();
#line 402
    stdout_errno = *tmp;
    }
  }
#line 403
  return;
}
}
#line 405 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void fflush_errno(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 408
  tmp___0 = fflush_unlocked(stdout);
  }
#line 408
  if (tmp___0 != 0) {
    {
#line 409
    tmp = __errno_location();
#line 409
    stdout_errno = *tmp;
    }
  }
#line 410
  return;
}
}
#line 412 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct exclude *excluded_patterns[2]  ;
#line 413 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct exclude *excluded_directory_patterns[2]  ;
#line 415 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   short_options[58]  = 
#line 415
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':', 
        (char const   )'D',      (char const   )':',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'P', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'X', 
        (char const   )':',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )':',      (char const   )'e',      (char const   )':', 
        (char const   )'f',      (char const   )':',      (char const   )'h',      (char const   )'i', 
        (char const   )'L',      (char const   )'l',      (char const   )'m',      (char const   )':', 
        (char const   )'n',      (char const   )'o',      (char const   )'q',      (char const   )'R', 
        (char const   )'r',      (char const   )'s',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'Z', 
        (char const   )'z',      (char const   )'\000'};
#line 433 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct option  const  long_options[50]  = 
#line 433
  {      {"basic-regexp", 0, (int *)((void *)0), 'G'}, 
        {"extended-regexp", 0, (int *)((void *)0), 'E'}, 
        {"fixed-regexp", 0, (int *)((void *)0), 'F'}, 
        {"fixed-strings", 0, (int *)((void *)0), 'F'}, 
        {"perl-regexp", 0, (int *)((void *)0), 'P'}, 
        {"after-context", 1, (int *)((void *)0), 'A'}, 
        {"before-context", 1, (int *)((void *)0), 'B'}, 
        {"binary-files", 1, (int *)((void *)0), 128}, 
        {"byte-offset", 0, (int *)((void *)0), 'b'}, 
        {"context", 1, (int *)((void *)0), 'C'}, 
        {"color", 2, (int *)((void *)0), 129}, 
        {"colour", 2, (int *)((void *)0), 129}, 
        {"count", 0, (int *)((void *)0), 'c'}, 
        {"devices", 1, (int *)((void *)0), 'D'}, 
        {"directories", 1, (int *)((void *)0), 'd'}, 
        {"exclude", 1, (int *)((void *)0), 131}, 
        {"exclude-from", 1, (int *)((void *)0), 132}, 
        {"exclude-dir", 1, (int *)((void *)0), 130}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-with-matches", 0, (int *)((void *)0), 'l'}, 
        {"files-without-match", 0, (int *)((void *)0), 'L'}, 
        {"group-separator", 1, (int *)((void *)0), 133}, 
        {"help", 0, & show_help, 1}, 
        {"include", 1, (int *)((void *)0), 134}, 
        {"ignore-case", 0, (int *)((void *)0), 'i'}, 
        {"initial-tab", 0, (int *)((void *)0), 'T'}, 
        {"label", 1, (int *)((void *)0), 136}, 
        {"line-buffered", 0, (int *)((void *)0), 135}, 
        {"line-number", 0, (int *)((void *)0), 'n'}, 
        {"line-regexp", 0, (int *)((void *)0), 'x'}, 
        {"max-count", 1, (int *)((void *)0), 'm'}, 
        {"no-filename", 0, (int *)((void *)0), 'h'}, 
        {"no-group-separator", 0, (int *)((void *)0), 133}, 
        {"no-messages", 0, (int *)((void *)0), 's'}, 
        {"null", 0, (int *)((void *)0), 'Z'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"only-matching", 0, (int *)((void *)0), 'o'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"dereference-recursive", 0, (int *)((void *)0), 'R'}, 
        {"regexp", 1, (int *)((void *)0), 'e'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"silent", 0, (int *)((void *)0), 'q'}, 
        {"text", 0, (int *)((void *)0), 'a'}, 
        {"binary", 0, (int *)((void *)0), 'U'}, 
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"with-filename", 0, (int *)((void *)0), 'H'}, 
        {"word-regexp", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 496 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *filename  ;
#line 498 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool omit_dot_slash  ;
#line 499 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool errseen  ;
#line 503 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool encoding_error_output  ;
#line 513 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   * const  directories_args[4]  = {      (char const   */* const  */)"read",      (char const   */* const  */)"recurse",      (char const   */* const  */)"skip",      (char const   */* const  */)((void *)0)};
#line 517 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static enum directories_type  const  directories_types[3]  = {      (enum directories_type  const  )2,      (enum directories_type  const  )3,      (enum directories_type  const  )4};
#line 523 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static enum directories_type directories  =    (enum directories_type )2;
#line 526 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int fts_options  =    793;
#line 529 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static enum __anonenum_devices_473526324 devices  =    (enum __anonenum_devices_473526324 )0;
#line 536
static _Bool grepfile(int dirdesc , char const   *name , _Bool follow , _Bool command_line ) ;
#line 537
static _Bool grepdesc(int desc , _Bool command_line ) ;
#line 539
static void dos_binary(void) ;
#line 540
static void dos_unix_byte_offsets(void) ;
#line 541
static size_t undossify_input(char *buf , size_t buflen ) ;
#line 543 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool is_device_mode(mode_t m ) 
{ 
  int tmp ;

  {
#line 546
  if ((m & 61440U) == 8192U) {
#line 546
    tmp = 1;
  } else
#line 546
  if ((m & 61440U) == 24576U) {
#line 546
    tmp = 1;
  } else
#line 546
  if ((m & 61440U) == 49152U) {
#line 546
    tmp = 1;
  } else
#line 546
  if ((m & 61440U) == 4096U) {
#line 546
    tmp = 1;
  } else {
#line 546
    tmp = 0;
  }
#line 546
  return ((_Bool )tmp);
}
}
#line 549 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool skip_devices(_Bool command_line ) 
{ 
  int tmp ;

  {
#line 552
  if ((unsigned int )devices == 2U) {
#line 552
    tmp = 1;
  } else
#line 552
  if (((unsigned int )devices == 0U) & ! command_line) {
#line 552
    tmp = 1;
  } else {
#line 552
    tmp = 0;
  }
#line 552
  return ((_Bool )tmp);
}
}
#line 558 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool usable_st_size(struct stat  const  *st ) 
{ 
  int tmp ;

  {
#line 561
  if ((st->st_mode & 61440U) == 32768U) {
#line 561
    tmp = 1;
  } else
#line 561
  if (st->st_mode - st->st_mode) {
#line 561
    tmp = 1;
  } else {
#line 561
    tmp = 0;
  }
#line 561
  return ((_Bool )tmp);
}
}
#line 574 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool seek_failed  ;
#line 575 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool seek_data_failed  ;
#line 581 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t (*execute)(void * , char const   * , size_t  , size_t * , char const   * )  ;
#line 582 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void *compiled_pattern  ;
#line 584 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *input_filename(void) 
{ 
  char *tmp ;

  {
#line 587
  if (! filename) {
    {
#line 588
    tmp = gettext("(standard input)");
#line 588
    filename = (char const   *)tmp;
    }
  }
#line 589
  return (filename);
}
}
#line 593 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void suppressible_error(int errnum ) 
{ 
  char const   *tmp ;

  {
#line 596
  if (! suppress_errors) {
    {
#line 597
    tmp = input_filename();
#line 597
    error(0, errnum, "%s", tmp);
    }
  }
#line 598
  errseen = (_Bool)1;
#line 599
  return;
}
}
#line 603 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void clean_up_stdout(void) 
{ 


  {
#line 606
  if (! stdout_errno) {
    {
#line 607
    close_stdout();
    }
  }
#line 608
  return;
}
}
#line 638 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static uword unibyte_mask  ;
#line 640 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void initialize_unibyte_mask(void) 
{ 
  unsigned char mask ;
  int ms1b ;
  int i ;
  uword uword_max ;

  {
#line 647
  mask = (unsigned char)0;
#line 648
  ms1b = 1;
#line 649
  i = 1;
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 649
    if (! (i <= 255)) {
#line 649
      goto while_break;
    }
#line 650
    if (((int )localeinfo.sbclen[i] != 1) & ! ((int )mask & i)) {
      {
#line 652
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 652
        if (! (ms1b * 2 <= i)) {
#line 652
          goto while_break___0;
        }
#line 653
        ms1b *= 2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 654
      mask = (unsigned char )((int )mask | ms1b);
    }
#line 649
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  uword_max = (uword )-1;
#line 661
  unibyte_mask = (uword_max / 255UL) * (uword )mask;
#line 662
  return;
}
}
#line 667 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   * __attribute__((__pure__)) skip_easy_bytes(char const   *buf ) 
{ 
  char const   *p ;
  uword const   *s ;
  unsigned char tmp ;
  char const   *val_ ;
  unsigned char tmp___0 ;

  {
#line 676
  p = buf;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! ((uintptr_t )p % sizeof(uword ) != 0UL)) {
#line 676
      goto while_break;
    }
    {
#line 677
    tmp = to_uchar((char )*p);
    }
#line 677
    if ((unsigned long )tmp & unibyte_mask) {
#line 678
      return ((char const   */* __attribute__((__pure__)) */)p);
    }
#line 676
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  val_ = p;
#line 679
  s = (uword const   *)val_;
  {
#line 679
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 679
    if (! (! (*s & (unsigned long const   )unibyte_mask))) {
#line 679
      goto while_break___0;
    }
#line 680
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 679
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 681
  p = (char const   *)s;
  {
#line 681
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 681
    tmp___0 = to_uchar((char )*p);
    }
#line 681
    if ((unsigned long )tmp___0 & unibyte_mask) {
#line 681
      goto while_break___1;
    }
#line 682
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 681
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 683
  return ((char const   */* __attribute__((__pure__)) */)p);
}
}
#line 689 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool buf_has_encoding_errors(char *buf , size_t size ) 
{ 
  mbstate_t mbs ;
  size_t clen ;
  char const   *p ;
  char const   * __attribute__((__pure__)) tmp ;

  {
#line 692
  if (! unibyte_mask) {
#line 693
    return ((_Bool)0);
  }
#line 695
  mbs.__count = 0;
#line 695
  mbs.__value.__wch = 0U;
#line 698
  *(buf + size) = (char)-1;
#line 699
  p = (char const   *)buf;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 699
    tmp = skip_easy_bytes(p);
#line 699
    p = (char const   *)tmp;
    }
#line 699
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 699
      goto while_break;
    }
    {
#line 701
    clen = rpl_mbrlen(p, (size_t )((buf + size) - (char *)p), & mbs);
    }
#line 702
    if (0xfffffffffffffffeUL <= clen) {
#line 703
      return ((_Bool)1);
    }
#line 699
    p += clen;
  }
  while_break: /* CIL Label */ ;
  }
#line 706
  return ((_Bool)0);
}
}
#line 713 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool buf_has_nulls(char *buf , size_t size ) 
{ 
  size_t tmp ;

  {
  {
#line 716
  *(buf + size) = (char)0;
#line 717
  tmp = strlen((char const   *)buf);
  }
#line 717
  return ((_Bool )(tmp != size));
}
}
#line 723 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool file_must_have_nulls(size_t size , int fd , struct stat  const  *st ) 
{ 
  off_t cur ;
  off_t hole_start ;
  __off_t tmp ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  _Bool tmp___2 ;

  {
#line 727
  if (! seek_failed) {
    {
#line 727
    tmp___2 = usable_st_size(st);
    }
#line 727
    if (tmp___2) {
#line 727
      if (size < (size_t )st->st_size) {
#line 730
        cur = (off_t )size;
#line 731
        if (fd == 0) {
          {
#line 733
          cur = lseek(fd, (__off_t )0, 1);
          }
#line 734
          if (cur < 0L) {
#line 735
            return ((_Bool)0);
          }
        }
        {
#line 739
        tmp = lseek(fd, cur, 4);
#line 739
        hole_start = tmp;
        }
#line 740
        if (0L <= hole_start) {
          {
#line 742
          tmp___1 = lseek(fd, cur, 0);
          }
#line 742
          if (tmp___1 < 0L) {
            {
#line 743
            tmp___0 = __errno_location();
#line 743
            suppressible_error(*tmp___0);
            }
          }
#line 744
          if (hole_start < (off_t )st->st_size) {
#line 745
            return ((_Bool)1);
          }
        }
      }
    }
  }
#line 749
  return ((_Bool)0);
}
}
#line 756 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void context_length_arg(char const   *str , intmax_t *out ) 
{ 
  strtol_error tmp ;

  {
  {
#line 759
  tmp = xstrtoimax(str, (char **)0, 10, out, "");
  }
  {
#line 762
  if ((unsigned int )tmp == 1U) {
#line 762
    goto case_1;
  }
#line 762
  if ((unsigned int )tmp == 0U) {
#line 762
    goto case_1;
  }
#line 766
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 763
  if (0L <= *out) {
#line 764
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 767
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 770
  return;
}
}
#line 774 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int exclude_options(_Bool command_line ) 
{ 
  int tmp ;

  {
#line 777
  if (command_line) {
#line 777
    tmp = 0;
  } else {
#line 777
    tmp = 1 << 30;
  }
#line 777
  return ((1 << 28) | tmp);
}
}
#line 783 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool skipped_file(char const   *name , _Bool command_line , _Bool is_dir ) 
{ 
  struct exclude **pats ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 787
  if (! is_dir) {
#line 788
    pats = excluded_patterns;
  } else
#line 789
  if ((unsigned int )directories == 4U) {
#line 790
    return ((_Bool)1);
  } else
#line 791
  if (command_line) {
#line 791
    if (omit_dot_slash) {
#line 792
      return ((_Bool)0);
    } else {
#line 794
      pats = excluded_directory_patterns;
    }
  } else {
#line 794
    pats = excluded_directory_patterns;
  }
#line 795
  if (*(pats + command_line)) {
    {
#line 795
    tmp = excluded_file_name((struct exclude  const  *)*(pats + command_line), name);
    }
#line 795
    if (tmp) {
#line 795
      tmp___0 = 1;
    } else {
#line 795
      tmp___0 = 0;
    }
  } else {
#line 795
    tmp___0 = 0;
  }
#line 795
  return ((_Bool )tmp___0);
}
}
#line 802 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *buffer  ;
#line 803 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t bufalloc  ;
#line 805 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int bufdesc  ;
#line 806 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *bufbeg  ;
#line 807 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *buflim  ;
#line 808 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t pagesize  ;
#line 809 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static off_t bufoffset  ;
#line 810 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static off_t after_last_match  ;
#line 813 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool skip_nuls  ;
#line 814 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool skip_empty_lines  ;
#line 815 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static uintmax_t totalnl  ;
#line 826 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static uintmax_t add_count(uintmax_t a , uintmax_t b ) 
{ 
  uintmax_t sum ;

  {
#line 829
  sum = a + b;
#line 830
  if (sum < a) {
    {
#line 831
    exit(1);
    }
  }
#line 832
  return (sum);
}
}
#line 836 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool all_zeros(char const   *buf , size_t size ) 
{ 
  char const   *p ;

  {
#line 839
  p = buf;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! ((unsigned long )p < (unsigned long )(buf + size))) {
#line 839
      goto while_break;
    }
#line 840
    if (*p) {
#line 841
      return ((_Bool)0);
    }
#line 839
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  return ((_Bool)1);
}
}
#line 847 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool reset(int fd , struct stat  const  *st ) 
{ 
  __off_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 850
  if ((size_t )(buffer + 1) % pagesize == 0UL) {
#line 850
    buflim = buffer + 1;
  } else {
#line 850
    buflim = (buffer + 1) + (pagesize - (size_t )(buffer + 1) % pagesize);
  }
#line 850
  bufbeg = buflim;
#line 851
  *(bufbeg + -1) = eolbyte;
#line 852
  bufdesc = fd;
#line 853
  if (fd == 0) {
    {
#line 853
    tmp = lseek(fd, (__off_t )0, 1);
#line 853
    bufoffset = tmp;
    }
  } else {
#line 853
    bufoffset = (off_t )0;
  }
#line 854
  seek_failed = (_Bool )(bufoffset < 0L);
#line 857
  seek_data_failed = seek_failed;
#line 859
  if (seek_failed) {
    {
#line 861
    tmp___1 = __errno_location();
    }
#line 861
    if (*tmp___1 != 29) {
      {
#line 863
      tmp___0 = __errno_location();
#line 863
      suppressible_error(*tmp___0);
      }
#line 864
      return ((_Bool)0);
    }
#line 866
    bufoffset = (off_t )0;
  }
#line 868
  return ((_Bool)1);
}
}
#line 875 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool fillbuf(size_t save , struct stat  const  *st ) 
{ 
  size_t fillsize ;
  _Bool cc ;
  char *readbuf ;
  size_t readsize ;
  size_t saved_offset ;
  size_t minsize ;
  size_t newsize ;
  size_t newalloc ;
  char *newbuf ;
  off_t to_be_read ;
  off_t maxsize_off ;
  _Bool tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  off_t data_start ;
  __off_t tmp___2 ;
  int *tmp___3 ;
  _Bool tmp___4 ;

  {
#line 879
  cc = (_Bool)1;
#line 885
  saved_offset = (size_t )((buflim - save) - buffer);
#line 887
  if (pagesize <= (size_t )(((buffer + bufalloc) - sizeof(uword )) - buflim)) {
#line 889
    readbuf = buflim;
#line 890
    bufbeg = buflim - save;
  } else {
#line 894
    minsize = save + pagesize;
#line 900
    newsize = (bufalloc - pagesize) - sizeof(uword );
    {
#line 900
    while (1) {
      while_continue: /* CIL Label */ ;
#line 900
      if (! (newsize < minsize)) {
#line 900
        goto while_break;
      }
#line 903
      if (((0xffffffffffffffffUL - pagesize) - sizeof(uword )) / 2UL < newsize) {
        {
#line 904
        xalloc_die();
        }
      }
#line 900
      newsize *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 911
    tmp = usable_st_size(st);
    }
#line 911
    if (tmp) {
#line 913
      to_be_read = (off_t )(st->st_size - (__off_t const   )bufoffset);
#line 914
      maxsize_off = (off_t )(save + (size_t )to_be_read);
#line 915
      if (0L <= to_be_read) {
#line 915
        if (to_be_read <= maxsize_off) {
#line 915
          if ((size_t )maxsize_off == (size_t )maxsize_off) {
#line 915
            if (minsize <= (size_t )maxsize_off) {
#line 915
              if ((size_t )maxsize_off < newsize) {
#line 919
                newsize = (size_t )maxsize_off;
              }
            }
          }
        }
      }
    }
#line 925
    newalloc = (newsize + pagesize) + sizeof(uword );
#line 927
    if (bufalloc < newalloc) {
      {
#line 927
      bufalloc = newalloc;
#line 927
      tmp___0 = xmalloc(bufalloc);
#line 927
      newbuf = (char *)tmp___0;
      }
    } else {
#line 927
      newbuf = buffer;
    }
#line 928
    if ((size_t )((newbuf + 1) + save) % pagesize == 0UL) {
#line 928
      readbuf = (newbuf + 1) + save;
    } else {
#line 928
      readbuf = ((newbuf + 1) + save) + (pagesize - (size_t )((newbuf + 1) + save) % pagesize);
    }
    {
#line 929
    bufbeg = readbuf - save;
#line 930
    memmove((void *)bufbeg, (void const   *)(buffer + saved_offset), save);
#line 931
    *(bufbeg + -1) = eolbyte;
    }
#line 932
    if ((unsigned long )newbuf != (unsigned long )buffer) {
      {
#line 934
      free((void *)buffer);
#line 935
      buffer = newbuf;
      }
    }
  }
  {
#line 939
  clear_asan_poison();
#line 941
  readsize = (size_t )(((buffer + bufalloc) - sizeof(uword )) - readbuf);
#line 942
  readsize -= readsize % pagesize;
  }
  {
#line 944
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 946
    fillsize = safe_read(bufdesc, (void *)readbuf, readsize);
    }
#line 947
    if (fillsize == 0xffffffffffffffffUL) {
#line 949
      fillsize = (size_t )0;
#line 950
      cc = (_Bool)0;
    }
#line 952
    bufoffset = (off_t )((size_t )bufoffset + fillsize);
#line 954
    if ((fillsize == 0UL) | ! skip_nuls) {
#line 955
      goto while_break___0;
    } else {
      {
#line 954
      tmp___1 = all_zeros((char const   *)readbuf, fillsize);
      }
#line 954
      if (! tmp___1) {
#line 955
        goto while_break___0;
      }
    }
    {
#line 956
    totalnl = add_count(totalnl, fillsize);
    }
#line 958
    if (! seek_data_failed) {
      {
#line 961
      tmp___2 = lseek(bufdesc, bufoffset, 3);
#line 961
      data_start = tmp___2;
      }
#line 962
      if (data_start < 0L) {
        {
#line 962
        tmp___3 = __errno_location();
        }
#line 962
        if (*tmp___3 == 6) {
          {
#line 962
          tmp___4 = usable_st_size(st);
          }
#line 962
          if (tmp___4) {
#line 962
            if (bufoffset < (off_t )st->st_size) {
              {
#line 964
              data_start = lseek(bufdesc, (__off_t )0, 2);
              }
            }
          }
        }
      }
#line 966
      if (data_start < 0L) {
#line 967
        seek_data_failed = (_Bool)1;
      } else {
        {
#line 970
        totalnl = add_count(totalnl, (uintmax_t )(data_start - bufoffset));
#line 971
        bufoffset = data_start;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 976
  fillsize = undossify_input(readbuf, fillsize);
#line 977
  buflim = readbuf + fillsize;
#line 982
  memset((void *)buflim, 0, sizeof(uword ));
#line 986
  asan_poison((void const volatile   *)(buflim + sizeof(uword )), (bufalloc - (size_t )(buflim - buffer)) - sizeof(uword ));
  }
#line 989
  return (cc);
}
}
#line 993 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static enum __anonenum_binary_files_601436154 binary_files  ;
#line 1001 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static enum __anonenum_list_files_328606374 list_files  ;
#line 1008 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int filename_mask  ;
#line 1009 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool out_quiet  ;
#line 1010 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool out_invert  ;
#line 1011 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int out_file  ;
#line 1012 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool out_line  ;
#line 1013 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool out_byte  ;
#line 1014 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t out_before  ;
#line 1015 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t out_after  ;
#line 1016 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool count_matches  ;
#line 1017 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool no_filenames  ;
#line 1018 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t max_count  ;
#line 1020 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool line_buffered  ;
#line 1021 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *label  =    (char *)((void *)0);
#line 1025 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static uintmax_t totalcc  ;
#line 1026 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char const   *lastnl  ;
#line 1027 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *lastout  ;
#line 1030 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t outleft  ;
#line 1031 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t pending  ;
#line 1033 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool done_on_match  ;
#line 1034 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool exit_on_match  ;
#line 1035 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool dev_null_output  ;
#line 42 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static int dos_report_unix_offset  =    0;
#line 44 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static File_type dos_file_type  =    (File_type )0;
#line 45 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static File_type dos_use_file_type  =    (File_type )0;
#line 46 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static off_t dos_stripped_crs  =    (off_t )0;
#line 47 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static struct dos_map *dos_pos_map  ;
#line 48 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static int dos_pos_map_size  =    0;
#line 49 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static int dos_pos_map_used  =    0;
#line 50 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static int inp_map_idx  =    0;
#line 50 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static int out_map_idx  =    1;
#line 53 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static void dos_binary(void) 
{ 


  {
#line 58
  return;
}
}
#line 61 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static void dos_unix_byte_offsets(void) 
{ 


  {
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static File_type guess_type(char *buf , size_t buflen ) 
{ 
  int crlf_seen ;
  char *bp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 72
  crlf_seen = 0;
#line 73
  bp = buf;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    tmp = buflen;
#line 75
    buflen --;
#line 75
    if (! tmp) {
#line 75
      goto while_break;
    }
#line 78
    if (! *bp) {
#line 79
      return ((File_type )1);
    } else
#line 83
    if ((int )*bp == 13) {
#line 83
      if (buflen) {
#line 83
        if ((int )*(bp + 1) == 10) {
#line 84
          crlf_seen = 1;
        }
      }
    }
#line 86
    bp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  if (crlf_seen) {
#line 89
    tmp___0 = 2;
  } else {
#line 89
    tmp___0 = 3;
  }
#line 89
  return ((File_type )tmp___0);
}
}
#line 95 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static size_t undossify_input(char *buf , size_t buflen ) 
{ 
  size_t bytes_left ;
  char *destp ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 99
  return (buflen);
#line 101
  bytes_left = (size_t )0;
#line 103
  if (totalcc == 0UL) {
#line 107
    inp_map_idx = 0;
#line 108
    out_map_idx = 1;
#line 109
    dos_pos_map_used = 0;
#line 110
    dos_stripped_crs = (off_t )0;
#line 111
    dos_file_type = dos_use_file_type;
  }
#line 115
  if ((unsigned int )dos_file_type == 0U) {
    {
#line 116
    dos_file_type = guess_type(buf, buflen);
    }
  }
#line 120
  if ((unsigned int )dos_file_type == 2U) {
#line 122
    destp = buf;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      tmp___4 = buflen;
#line 124
      buflen --;
#line 124
      if (! tmp___4) {
#line 124
        goto while_break;
      }
#line 126
      if ((int )*buf != 13) {
#line 128
        tmp = destp;
#line 128
        destp ++;
#line 128
        tmp___0 = buf;
#line 128
        buf ++;
#line 128
        *tmp = *tmp___0;
#line 129
        bytes_left ++;
      } else {
#line 133
        buf ++;
#line 134
        if (out_byte) {
#line 134
          if (! dos_report_unix_offset) {
#line 136
            dos_stripped_crs ++;
            {
#line 137
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 137
              if (buflen) {
#line 137
                if (! ((int )*buf == 13)) {
#line 137
                  goto while_break___0;
                }
              } else {
#line 137
                goto while_break___0;
              }
#line 139
              dos_stripped_crs ++;
#line 140
              buflen --;
#line 141
              buf ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 143
            if (inp_map_idx >= dos_pos_map_size - 1) {
#line 145
              if (inp_map_idx) {
#line 145
                dos_pos_map_size = inp_map_idx * 2;
              } else {
#line 145
                dos_pos_map_size = 1000;
              }
              {
#line 146
              tmp___1 = xrealloc((void *)dos_pos_map, (unsigned long )dos_pos_map_size * sizeof(struct dos_map ));
#line 146
              dos_pos_map = (struct dos_map *)tmp___1;
              }
            }
#line 151
            if (! inp_map_idx) {
#line 154
              (dos_pos_map + inp_map_idx)->pos = (off_t )0;
#line 155
              tmp___2 = inp_map_idx;
#line 155
              inp_map_idx ++;
#line 155
              (dos_pos_map + tmp___2)->add = (off_t )0;
#line 158
              (dos_pos_map + inp_map_idx)->add = (off_t )0;
            }
#line 167
            inp_map_idx ++;
#line 168
            if ((int )*buf == 10) {
#line 168
              tmp___3 = destp + 1;
            } else {
#line 168
              tmp___3 = destp;
            }
#line 168
            (dos_pos_map + (inp_map_idx - 1))->pos = (off_t )((uintmax_t )(tmp___3 - bufbeg) + totalcc);
#line 170
            (dos_pos_map + inp_map_idx)->add = dos_stripped_crs;
#line 171
            dos_pos_map_used = inp_map_idx;
#line 174
            (dos_pos_map + inp_map_idx)->pos = (off_t )(((uintmax_t )(destp - bufbeg) + totalcc) + 1UL);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 179
    return (bytes_left);
  }
#line 182
  return (buflen);
}
}
#line 186 "/home/khheo/project/benchmark/grep-3.0/src/dosbuf.c"
static off_t dossified_pos(off_t byteno ) 
{ 
  off_t pos_lo ;
  off_t pos_hi ;

  {
#line 190
  return (byteno);
#line 195
  if ((unsigned int )dos_file_type != 2U) {
#line 196
    return (byteno);
  } else
#line 195
  if (dos_report_unix_offset) {
#line 196
    return (byteno);
  }
#line 201
  pos_lo = (dos_pos_map + (out_map_idx - 1))->pos;
#line 202
  pos_hi = (dos_pos_map + out_map_idx)->pos;
#line 206
  if (byteno >= pos_hi) {
#line 208
    out_map_idx ++;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      if (out_map_idx < dos_pos_map_used) {
#line 209
        if (! (byteno >= (dos_pos_map + out_map_idx)->pos)) {
#line 209
          goto while_break;
        }
      } else {
#line 209
        goto while_break;
      }
#line 211
      out_map_idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 214
  if (byteno < pos_lo) {
#line 216
    out_map_idx --;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (out_map_idx > 1) {
#line 217
        if (! (byteno < (dos_pos_map + (out_map_idx - 1))->pos)) {
#line 217
          goto while_break___0;
        }
      } else {
#line 217
        goto while_break___0;
      }
#line 218
      out_map_idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 221
  return (byteno + (dos_pos_map + out_map_idx)->add);
}
}
#line 1039 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void nlscan(char const   *lim ) 
{ 
  size_t newlines ;
  char const   *beg ;
  void *tmp ;

  {
#line 1042
  newlines = (size_t )0;
#line 1044
  beg = lastnl;
  {
#line 1044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1044
    if (! ((unsigned long )beg < (unsigned long )lim)) {
#line 1044
      goto while_break;
    }
    {
#line 1046
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
#line 1046
    beg = (char const   *)tmp;
    }
#line 1047
    if (! beg) {
#line 1048
      goto while_break;
    }
#line 1049
    newlines ++;
#line 1044
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1051
  totalnl = add_count(totalnl, newlines);
#line 1052
  lastnl = lim;
  }
#line 1053
  return;
}
}
#line 1056 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void print_filename(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1059
  pr_sgr_start_if(filename_color);
#line 1060
  tmp = input_filename();
#line 1060
  fputs_errno(tmp);
#line 1061
  pr_sgr_end_if(filename_color);
  }
#line 1062
  return;
}
}
#line 1065 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void print_sep(char sep ) 
{ 


  {
  {
#line 1068
  pr_sgr_start_if(sep_color);
#line 1069
  putchar_errno((int )sep);
#line 1070
  pr_sgr_end_if(sep_color);
  }
#line 1071
  return;
}
}
#line 1074 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void print_offset(uintmax_t pos , char const   *color ) 
{ 


  {
  {
#line 1077
  pr_sgr_start_if(color);
#line 1078
  printf_errno("%*lu", offset_width, pos);
#line 1079
  pr_sgr_end_if(color);
  }
#line 1080
  return;
}
}
#line 1091 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool print_line_head(char *beg , size_t len , char const   *lim , char sep ) 
{ 
  char ch ;
  _Bool encoding_errors ;
  _Bool tmp ;
  uintmax_t pos ;
  uintmax_t tmp___0 ;
  off_t tmp___1 ;

  {
#line 1094
  if ((unsigned int )binary_files != 1U) {
    {
#line 1096
    ch = *(beg + len);
#line 1097
    tmp = buf_has_encoding_errors(beg, len);
#line 1097
    encoding_errors = tmp;
#line 1098
    *(beg + len) = ch;
    }
#line 1099
    if (encoding_errors) {
#line 1101
      encoding_error_output = (_Bool)1;
#line 1102
      return ((_Bool)0);
    }
  }
#line 1106
  if (out_file) {
    {
#line 1108
    print_filename();
    }
#line 1109
    if (filename_mask) {
      {
#line 1110
      print_sep(sep);
      }
    } else {
      {
#line 1112
      putchar_errno(0);
      }
    }
  }
#line 1115
  if (out_line) {
#line 1117
    if ((unsigned long )lastnl < (unsigned long )lim) {
      {
#line 1119
      nlscan((char const   *)beg);
#line 1120
      totalnl = add_count(totalnl, (uintmax_t )1);
#line 1121
      lastnl = lim;
      }
    }
    {
#line 1123
    print_offset(totalnl, line_num_color);
#line 1124
    print_sep(sep);
    }
  }
#line 1127
  if (out_byte) {
    {
#line 1129
    tmp___0 = add_count(totalcc, (uintmax_t )(beg - bufbeg));
#line 1129
    pos = tmp___0;
#line 1130
    tmp___1 = dossified_pos((off_t )pos);
#line 1130
    pos = (uintmax_t )tmp___1;
#line 1131
    print_offset(pos, byte_num_color);
#line 1132
    print_sep(sep);
    }
  }
#line 1135
  if (align_tabs) {
#line 1135
    if ((out_file | (int )out_line) | (int )out_byte) {
#line 1135
      if (len != 0UL) {
        {
#line 1136
        putchar_errno('\t');
        }
      }
    }
  }
#line 1138
  return ((_Bool)1);
}
}
#line 1141 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *print_line_middle(char *beg , char *lim , char const   *line_color ,
                               char const   *match_color ) 
{ 
  size_t match_size ;
  size_t match_offset ;
  char *cur ;
  char *mid ;
  char *b ;
  char sep ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 1148
  mid = (char *)((void *)0);
#line 1151
  cur = beg;
  {
#line 1151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1151
    if ((unsigned long )cur < (unsigned long )lim) {
      {
#line 1151
      match_offset = (*execute)(compiled_pattern, (char const   *)beg, (size_t )(lim - beg),
                                & match_size, (char const   *)cur);
      }
#line 1151
      if (! (match_offset != 0xffffffffffffffffUL)) {
#line 1151
        goto while_break;
      }
    } else {
#line 1151
      goto while_break;
    }
#line 1157
    b = beg + match_offset;
#line 1160
    if ((unsigned long )b == (unsigned long )lim) {
#line 1161
      goto while_break;
    }
#line 1164
    if (match_size == 0UL) {
#line 1168
      match_size = (size_t )1;
#line 1169
      if (! mid) {
#line 1170
        mid = cur;
      }
    } else {
#line 1176
      if (only_matching) {
#line 1178
        if (out_invert) {
#line 1178
          tmp = 45;
        } else {
#line 1178
          tmp = 58;
        }
        {
#line 1178
        sep = (char )tmp;
#line 1179
        tmp___0 = print_line_head(b, match_size, (char const   *)lim, sep);
        }
#line 1179
        if (! tmp___0) {
#line 1180
          return ((char *)((void *)0));
        }
      } else {
        {
#line 1184
        pr_sgr_start(line_color);
        }
#line 1185
        if (mid) {
#line 1187
          cur = mid;
#line 1188
          mid = (char *)((void *)0);
        }
        {
#line 1190
        fwrite_errno((void const   *)cur, (size_t )1, (size_t )(b - cur));
        }
      }
      {
#line 1193
      pr_sgr_start_if(match_color);
#line 1194
      fwrite_errno((void const   *)b, (size_t )1, match_size);
#line 1195
      pr_sgr_end_if(match_color);
      }
#line 1196
      if (only_matching) {
        {
#line 1197
        putchar_errno((int )eolbyte);
        }
      }
    }
#line 1151
    cur = b + match_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  if (only_matching) {
#line 1202
    cur = lim;
  } else
#line 1203
  if (mid) {
#line 1204
    cur = mid;
  }
#line 1206
  return (cur);
}
}
#line 1209 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char *print_line_tail(char *beg , char const   *lim , char const   *line_color ) 
{ 
  size_t eol_size ;
  size_t tail_size ;
  int tmp ;
  int tmp___0 ;

  {
#line 1215
  if ((unsigned long )lim > (unsigned long )beg) {
#line 1215
    if ((int const   )*(lim + -1) == (int const   )eolbyte) {
#line 1215
      tmp = 1;
    } else {
#line 1215
      tmp = 0;
    }
  } else {
#line 1215
    tmp = 0;
  }
#line 1215
  eol_size = (size_t )tmp;
#line 1216
  if ((unsigned long )(lim - eol_size) > (unsigned long )beg) {
#line 1216
    if ((int const   )*(lim + - (1UL + eol_size)) == 13) {
#line 1216
      tmp___0 = 1;
    } else {
#line 1216
      tmp___0 = 0;
    }
  } else {
#line 1216
    tmp___0 = 0;
  }
#line 1216
  eol_size += (size_t )tmp___0;
#line 1217
  tail_size = (size_t )((lim - eol_size) - (char const   *)beg);
#line 1219
  if (tail_size > 0UL) {
    {
#line 1221
    pr_sgr_start(line_color);
#line 1222
    fwrite_errno((void const   *)beg, (size_t )1, tail_size);
#line 1223
    beg += tail_size;
#line 1224
    pr_sgr_end(line_color);
    }
  }
#line 1227
  return (beg);
}
}
#line 1230 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void prline(char *beg , char *lim , char sep ) 
{ 
  _Bool matching ;
  char const   *line_color ;
  char const   *match_color ;
  _Bool tmp ;
  int tmp___1 ;

  {
#line 1237
  if (! only_matching) {
    {
#line 1238
    tmp = print_line_head(beg, (size_t )((lim - beg) - 1L), (char const   *)lim, sep);
    }
#line 1238
    if (! tmp) {
#line 1239
      return;
    }
  }
#line 1241
  matching = (_Bool )(((int )sep == 58) ^ (int )out_invert);
#line 1243
  if (color_option) {
#line 1245
    if (out_invert) {
#line 1245
      if (color_option < 0) {
#line 1245
        tmp___1 = 1;
      } else {
#line 1245
        tmp___1 = 0;
      }
    } else {
#line 1245
      tmp___1 = 0;
    }
#line 1245
    if (((int )sep == 58) ^ tmp___1) {
#line 1245
      line_color = selected_line_color;
    } else {
#line 1245
      line_color = context_line_color;
    }
#line 1248
    if ((int )sep == 58) {
#line 1248
      match_color = selected_match_color;
    } else {
#line 1248
      match_color = context_match_color;
    }
  } else {
#line 1252
    match_color = (char const   *)((void *)0);
#line 1252
    line_color = match_color;
  }
#line 1254
  if (only_matching) {
#line 1254
    if (matching) {
#line 1254
      goto _L___1;
    } else {
#line 1254
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1254
  if (color_option) {
#line 1254
    if (*line_color) {
#line 1254
      goto _L___1;
    } else
#line 1254
    if (*match_color) {
      _L___1: /* CIL Label */ 
#line 1258
      if (matching) {
#line 1258
        if (only_matching) {
#line 1258
          goto _L;
        } else
#line 1258
        if (*match_color) {
          _L: /* CIL Label */ 
          {
#line 1260
          beg = print_line_middle(beg, lim, line_color, match_color);
          }
#line 1261
          if (! beg) {
#line 1262
            return;
          }
        }
      }
#line 1265
      if (! only_matching) {
#line 1265
        if (*line_color) {
          {
#line 1269
          beg = print_line_tail(beg, (char const   *)lim, line_color);
          }
        }
      }
    }
  }
#line 1273
  if (! only_matching) {
#line 1273
    if ((unsigned long )lim > (unsigned long )beg) {
      {
#line 1274
      fwrite_errno((void const   *)beg, (size_t )1, (size_t )(lim - beg));
      }
    }
  }
#line 1276
  if (line_buffered) {
    {
#line 1277
    fflush_errno();
    }
  }
#line 1279
  if (stdout_errno) {
    {
#line 1280
    exit(1);
    }
  }
#line 1282
  lastout = lim;
#line 1283
  return;
}
}
#line 1287 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void prpending(char const   *lim ) 
{ 
  char *nl ;
  void *tmp ;
  size_t match_size ;
  size_t tmp___0 ;

  {
#line 1290
  if (! lastout) {
#line 1291
    lastout = bufbeg;
  }
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    if (pending > 0L) {
#line 1292
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
#line 1292
        goto while_break;
      }
    } else {
#line 1292
      goto while_break;
    }
    {
#line 1294
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - (char const   *)lastout));
#line 1294
    nl = (char *)tmp;
#line 1296
    pending --;
    }
#line 1297
    if (outleft) {
      {
#line 1301
      prline(lastout, nl + 1, (char)45);
      }
    } else {
      {
#line 1297
      tmp___0 = (*execute)(compiled_pattern, (char const   *)lastout, (size_t )((nl + 1) - lastout),
                           & match_size, (char const   *)((void *)0));
      }
#line 1297
      if ((tmp___0 == 0xffffffffffffffffUL) == ! out_invert) {
        {
#line 1301
        prline(lastout, nl + 1, (char)45);
        }
      } else {
#line 1303
        pending = (intmax_t )0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1305
  return;
}
}
#line 1311 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool used  ;
#line 1308 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void prtext(char *beg , char *lim ) 
{ 
  char eol ;
  char *p ;
  char const   *bp ;
  char *tmp ;
  intmax_t i ;
  char *nl ;
  void *tmp___0 ;
  intmax_t n ;
  char *nl___0 ;
  void *tmp___1 ;
  intmax_t tmp___2 ;

  {
#line 1312
  eol = eolbyte;
#line 1314
  if (! out_quiet) {
#line 1314
    if (pending > 0L) {
      {
#line 1315
      prpending((char const   *)beg);
      }
    }
  }
#line 1317
  p = beg;
#line 1319
  if (! out_quiet) {
#line 1322
    if (lastout) {
#line 1322
      tmp = lastout;
    } else {
#line 1322
      tmp = bufbeg;
    }
#line 1322
    bp = (char const   *)tmp;
#line 1324
    i = (intmax_t )0;
    {
#line 1324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1324
      if (! (i < out_before)) {
#line 1324
        goto while_break;
      }
#line 1325
      if ((unsigned long )p > (unsigned long )bp) {
        {
#line 1326
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1327
          p --;
#line 1326
          if (! ((int )*(p + -1) != (int )eol)) {
#line 1326
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1324
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1332
    if (0L <= out_before) {
#line 1332
      goto _L;
    } else
#line 1332
    if (0L <= out_after) {
      _L: /* CIL Label */ 
#line 1332
      if (used) {
#line 1332
        if ((unsigned long )p != (unsigned long )lastout) {
#line 1332
          if (group_separator) {
            {
#line 1335
            pr_sgr_start_if(sep_color);
#line 1336
            fputs_errno(group_separator);
#line 1337
            pr_sgr_end_if(sep_color);
#line 1338
            putchar_errno('\n');
            }
          }
        }
      }
    }
    {
#line 1341
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1341
      if (! ((unsigned long )p < (unsigned long )beg)) {
#line 1341
        goto while_break___1;
      }
      {
#line 1343
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
#line 1343
      nl = (char *)tmp___0;
#line 1344
      nl ++;
#line 1345
      prline(p, nl, (char)45);
#line 1346
      p = nl;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1351
  if (out_invert) {
#line 1354
    n = (intmax_t )0;
    {
#line 1354
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1354
      if ((unsigned long )p < (unsigned long )lim) {
#line 1354
        if (! (n < outleft)) {
#line 1354
          goto while_break___2;
        }
      } else {
#line 1354
        goto while_break___2;
      }
      {
#line 1356
      tmp___1 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
#line 1356
      nl___0 = (char *)tmp___1;
#line 1357
      nl___0 ++;
      }
#line 1358
      if (! out_quiet) {
        {
#line 1359
        prline(p, nl___0, (char)58);
        }
      }
#line 1360
      p = nl___0;
#line 1354
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1366
    if (! out_quiet) {
      {
#line 1367
      prline(beg, lim, (char)58);
      }
    }
#line 1368
    n = (intmax_t )1;
#line 1369
    p = lim;
  }
#line 1372
  after_last_match = bufoffset - (buflim - p);
#line 1373
  if (out_quiet) {
#line 1373
    pending = (intmax_t )0;
  } else {
#line 1373
    if (0L > out_after) {
#line 1373
      tmp___2 = (intmax_t )0;
    } else {
#line 1373
      tmp___2 = out_after;
    }
#line 1373
    pending = tmp___2;
  }
#line 1374
  used = (_Bool)1;
#line 1375
  outleft -= n;
#line 1376
  return;
}
}
#line 1382 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void zap_nuls(char *p , char *lim , char eol ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1385
  if (eol) {
    {
#line 1386
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1388
      *lim = (char )'\000';
#line 1389
      tmp = strlen((char const   *)p);
#line 1389
      p += tmp;
#line 1390
      *lim = eol;
      }
#line 1391
      if ((unsigned long )p == (unsigned long )lim) {
#line 1392
        goto while_break;
      }
      {
#line 1393
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1394
        tmp___0 = p;
#line 1394
        p ++;
#line 1394
        *tmp___0 = eol;
#line 1393
        if (! (! *p)) {
#line 1393
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1397
  return;
}
}
#line 1402 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t grepbuf(char *beg , char const   *lim ) 
{ 
  intmax_t outleft0 ;
  char *endp ;
  char *p ;
  size_t match_size ;
  size_t match_offset ;
  size_t tmp ;
  char *b ;
  char *prbeg ;
  char *tmp___0 ;
  char *prend ;
  char *tmp___1 ;
  int volatile   tmp___2 ;

  {
#line 1405
  outleft0 = outleft;
#line 1408
  p = beg;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 1408
      goto while_break;
    }
    {
#line 1411
    tmp = (*execute)(compiled_pattern, (char const   *)p, (size_t )(lim - (char const   *)p),
                     & match_size, (char const   *)((void *)0));
#line 1411
    match_offset = tmp;
    }
#line 1413
    if (match_offset == 0xffffffffffffffffUL) {
#line 1415
      if (! out_invert) {
#line 1416
        goto while_break;
      }
#line 1417
      match_offset = (size_t )(lim - (char const   *)p);
#line 1418
      match_size = (size_t )0;
    }
#line 1420
    b = p + match_offset;
#line 1421
    endp = b + match_size;
#line 1423
    if (! out_invert) {
#line 1423
      if ((unsigned long )b == (unsigned long )lim) {
#line 1424
        goto while_break;
      }
    }
#line 1425
    if (! out_invert) {
#line 1425
      goto _L___0;
    } else
#line 1425
    if ((unsigned long )p < (unsigned long )b) {
      _L___0: /* CIL Label */ 
#line 1427
      if (out_invert) {
#line 1427
        tmp___0 = p;
      } else {
#line 1427
        tmp___0 = b;
      }
#line 1427
      prbeg = tmp___0;
#line 1428
      if (out_invert) {
#line 1428
        tmp___1 = b;
      } else {
#line 1428
        tmp___1 = endp;
      }
      {
#line 1428
      prend = tmp___1;
#line 1429
      prtext(prbeg, prend);
      }
#line 1430
      if (! outleft) {
#line 1430
        goto _L;
      } else
#line 1430
      if (done_on_match) {
        _L: /* CIL Label */ 
#line 1432
        if (exit_on_match) {
#line 1433
          if (errseen) {
#line 1433
            tmp___2 = exit_failure;
          } else {
#line 1433
            tmp___2 = (int volatile   )0;
          }
          {
#line 1433
          exit((int )tmp___2);
          }
        }
#line 1434
        goto while_break;
      }
    }
#line 1408
    p = endp;
  }
  while_break: /* CIL Label */ ;
  }
#line 1439
  return (outleft0 - outleft);
}
}
#line 1444 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static intmax_t grep(int fd , struct stat  const  *st , _Bool *ineof ) 
{ 
  intmax_t nlines ;
  intmax_t i ;
  size_t residue ;
  size_t save ;
  char oldc ;
  char *beg ;
  char *lim ;
  char eol ;
  char nul_zapper ;
  _Bool done_on_match_0 ;
  _Bool out_quiet_0 ;
  intmax_t nlines_first_null ;
  _Bool tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  _Bool tmp___2 ;
  uintmax_t num ;
  unsigned long tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool firsttime ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  void *tmp___9 ;
  intmax_t tmp___10 ;
  intmax_t tmp___11 ;
  int *tmp___12 ;
  _Bool tmp___13 ;
  char *tmp___14 ;
  intmax_t tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 1452
  eol = eolbyte;
#line 1453
  nul_zapper = (char )'\000';
#line 1454
  done_on_match_0 = done_on_match;
#line 1455
  out_quiet_0 = out_quiet;
#line 1460
  nlines_first_null = (intmax_t )-1;
#line 1462
  tmp = reset(fd, st);
  }
#line 1462
  if (! tmp) {
#line 1463
    return ((intmax_t )0);
  }
#line 1465
  totalcc = (uintmax_t )0;
#line 1466
  lastout = (char *)0;
#line 1467
  totalnl = (uintmax_t )0;
#line 1468
  outleft = max_count;
#line 1469
  after_last_match = (off_t )0;
#line 1470
  pending = (intmax_t )0;
#line 1471
  if (skip_empty_lines) {
#line 1471
    if (! eol) {
#line 1471
      tmp___0 = 1;
    } else {
#line 1471
      tmp___0 = 0;
    }
  } else {
#line 1471
    tmp___0 = 0;
  }
  {
#line 1471
  skip_nuls = (_Bool )tmp___0;
#line 1472
  encoding_error_output = (_Bool)0;
#line 1474
  nlines = (intmax_t )0;
#line 1475
  residue = (size_t )0;
#line 1476
  save = (size_t )0;
#line 1478
  tmp___2 = fillbuf(save, st);
  }
#line 1478
  if (! tmp___2) {
    {
#line 1480
    tmp___1 = __errno_location();
#line 1480
    suppressible_error(*tmp___1);
    }
#line 1481
    return ((intmax_t )0);
  }
#line 1484
  offset_width = 0;
#line 1485
  if (align_tabs) {
    {
#line 1488
    tmp___5 = usable_st_size(st);
    }
#line 1488
    if (tmp___5) {
#line 1488
      tmp___4 = (unsigned long )st->st_size;
    } else {
#line 1488
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1488
    num = tmp___4;
#line 1489
    if (out_line) {
#line 1489
      if (num < 0xffffffffffffffffUL) {
#line 1489
        tmp___6 = 1;
      } else {
#line 1489
        tmp___6 = 0;
      }
    } else {
#line 1489
      tmp___6 = 0;
    }
#line 1489
    num += (uintmax_t )tmp___6;
    {
#line 1490
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1491
      offset_width ++;
#line 1490
      num /= 10UL;
#line 1490
      if (! (num != 0UL)) {
#line 1490
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1495
  firsttime = (_Bool)1;
  {
#line 1495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1497
    if (nlines_first_null < 0L) {
#line 1497
      if (eol) {
#line 1497
        if ((unsigned int )binary_files != 1U) {
          {
#line 1497
          tmp___7 = buf_has_nulls(bufbeg, (size_t )(buflim - bufbeg));
          }
#line 1497
          if (tmp___7) {
#line 1497
            goto _L;
          } else
#line 1497
          if (firsttime) {
            {
#line 1497
            tmp___8 = file_must_have_nulls((size_t )(buflim - bufbeg), fd, st);
            }
#line 1497
            if (tmp___8) {
              _L: /* CIL Label */ 
#line 1501
              if ((unsigned int )binary_files == 2U) {
#line 1502
                return ((intmax_t )0);
              }
#line 1503
              if (! count_matches) {
#line 1504
                out_quiet = (_Bool)1;
#line 1504
                done_on_match = out_quiet;
              }
#line 1505
              nlines_first_null = nlines;
#line 1506
              nul_zapper = eol;
#line 1507
              skip_nuls = skip_empty_lines;
            }
          }
        }
      }
    }
#line 1510
    lastnl = (char const   *)bufbeg;
#line 1511
    if (lastout) {
#line 1512
      lastout = bufbeg;
    }
#line 1514
    beg = bufbeg + save;
#line 1517
    if ((unsigned long )beg == (unsigned long )buflim) {
#line 1519
      *ineof = (_Bool)1;
#line 1520
      goto while_break___0;
    }
    {
#line 1523
    zap_nuls(beg, buflim, nul_zapper);
#line 1527
    oldc = *(beg + -1);
#line 1528
    *(beg + -1) = eol;
#line 1531
    tmp___9 = memrchr((void const   *)(beg - 1), (int )eol, (size_t )((buflim - beg) + 1L));
#line 1531
    lim = (char *)tmp___9;
#line 1532
    lim ++;
#line 1533
    *(beg + -1) = oldc;
    }
#line 1534
    if ((unsigned long )lim == (unsigned long )beg) {
#line 1535
      lim = beg - residue;
    }
#line 1536
    beg -= residue;
#line 1537
    residue = (size_t )(buflim - lim);
#line 1539
    if ((unsigned long )beg < (unsigned long )lim) {
#line 1541
      if (outleft) {
        {
#line 1542
        tmp___10 = grepbuf(beg, (char const   *)lim);
#line 1542
        nlines += tmp___10;
        }
      }
#line 1543
      if (pending) {
        {
#line 1544
        prpending((char const   *)lim);
        }
      }
#line 1545
      if (! outleft) {
#line 1545
        if (! pending) {
#line 1547
          goto finish_grep;
        } else {
#line 1545
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1545
      if (done_on_match) {
#line 1545
        if (0L > nlines_first_null) {
#line 1545
          tmp___11 = (intmax_t )0;
        } else {
#line 1545
          tmp___11 = nlines_first_null;
        }
#line 1545
        if (tmp___11 < nlines) {
#line 1547
          goto finish_grep;
        }
      }
    }
#line 1553
    i = (intmax_t )0;
#line 1554
    beg = lim;
    {
#line 1555
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1555
      if (i < out_before) {
#line 1555
        if ((unsigned long )beg > (unsigned long )bufbeg) {
#line 1555
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
#line 1555
            goto while_break___1;
          }
        } else {
#line 1555
          goto while_break___1;
        }
      } else {
#line 1555
        goto while_break___1;
      }
#line 1557
      i ++;
      {
#line 1558
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1559
        beg --;
#line 1558
        if (! ((int )*(beg + -1) != (int )eol)) {
#line 1558
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1564
    if ((unsigned long )beg != (unsigned long )lastout) {
#line 1565
      lastout = (char *)0;
    }
#line 1568
    save = (size_t )((lim + residue) - beg);
#line 1569
    if (out_byte) {
      {
#line 1570
      totalcc = add_count(totalcc, (size_t )(buflim - bufbeg) - save);
      }
    }
#line 1571
    if (out_line) {
      {
#line 1572
      nlscan((char const   *)beg);
      }
    }
    {
#line 1573
    tmp___13 = fillbuf(save, st);
    }
#line 1573
    if (! tmp___13) {
      {
#line 1575
      tmp___12 = __errno_location();
#line 1575
      suppressible_error(*tmp___12);
      }
#line 1576
      goto finish_grep;
    }
#line 1495
    firsttime = (_Bool)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1579
  if (residue) {
#line 1581
    tmp___14 = buflim;
#line 1581
    buflim ++;
#line 1581
    *tmp___14 = eol;
#line 1582
    if (outleft) {
      {
#line 1583
      tmp___15 = grepbuf((bufbeg + save) - residue, (char const   *)buflim);
#line 1583
      nlines += tmp___15;
      }
    }
#line 1584
    if (pending) {
      {
#line 1585
      prpending((char const   *)buflim);
      }
    }
  }
  finish_grep: 
#line 1589
  done_on_match = done_on_match_0;
#line 1590
  out_quiet = out_quiet_0;
#line 1591
  if (! out_quiet) {
#line 1591
    if (encoding_error_output) {
#line 1591
      goto _L___1;
    } else
#line 1591
    if (0L <= nlines_first_null) {
#line 1591
      if (nlines_first_null < nlines) {
        _L___1: /* CIL Label */ 
        {
#line 1594
        tmp___16 = input_filename();
#line 1594
        tmp___17 = gettext("Binary file %s matches\n");
#line 1594
        printf_errno((char const   *)tmp___17, tmp___16);
        }
#line 1595
        if (line_buffered) {
          {
#line 1596
          fflush_errno();
          }
        }
      }
    }
  }
#line 1598
  return (nlines);
}
}
#line 1601 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool grepdirent(FTS *fts , FTSENT *ent , _Bool command_line ) 
{ 
  _Bool follow ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat *st ;
  struct stat st1 ;
  int flag ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
#line 1605
  command_line = (_Bool )((int )command_line & (ent->fts_level == 0L));
#line 1607
  if ((int )ent->fts_info == 6) {
#line 1609
    if ((unsigned int )directories == 3U) {
#line 1609
      if (command_line) {
#line 1610
        out_file &= ~ (2 * ! no_filenames);
      }
    }
#line 1611
    return ((_Bool)1);
  }
#line 1614
  if (! command_line) {
#line 1614
    if ((int )ent->fts_info == 1) {
#line 1614
      tmp = 1;
    } else
#line 1614
    if ((int )ent->fts_info == 2) {
#line 1614
      tmp = 1;
    } else
#line 1614
    if ((int )ent->fts_info == 4) {
#line 1614
      tmp = 1;
    } else {
#line 1614
      tmp = 0;
    }
    {
#line 1614
    tmp___0 = skipped_file((char const   *)(ent->fts_name), (_Bool)0, (_Bool )tmp);
    }
#line 1614
    if (tmp___0) {
      {
#line 1619
      fts_set(fts, ent, 4);
      }
#line 1620
      return ((_Bool)1);
    }
  }
#line 1623
  filename = (char const   *)ent->fts_path;
#line 1624
  if (omit_dot_slash) {
#line 1624
    if (*(filename + 1)) {
#line 1625
      filename += 2;
    }
  }
#line 1626
  if (fts->fts_options & 2) {
#line 1626
    tmp___1 = 1;
  } else
#line 1626
  if (fts->fts_options & 1) {
#line 1626
    if (command_line) {
#line 1626
      tmp___1 = 1;
    } else {
#line 1626
      tmp___1 = 0;
    }
  } else {
#line 1626
    tmp___1 = 0;
  }
#line 1626
  follow = (_Bool )tmp___1;
  {
#line 1631
  if ((int )ent->fts_info == 1) {
#line 1631
    goto case_1;
  }
#line 1640
  if ((int )ent->fts_info == 2) {
#line 1640
    goto case_2;
  }
#line 1648
  if ((int )ent->fts_info == 10) {
#line 1648
    goto case_10;
  }
#line 1648
  if ((int )ent->fts_info == 7) {
#line 1648
    goto case_10;
  }
#line 1648
  if ((int )ent->fts_info == 4) {
#line 1648
    goto case_10;
  }
#line 1653
  if ((int )ent->fts_info == 11) {
#line 1653
    goto case_11;
  }
#line 1653
  if ((int )ent->fts_info == 3) {
#line 1653
    goto case_11;
  }
#line 1677
  if ((int )ent->fts_info == 13) {
#line 1677
    goto case_13;
  }
#line 1677
  if ((int )ent->fts_info == 8) {
#line 1677
    goto case_13;
  }
#line 1681
  if ((int )ent->fts_info == 14) {
#line 1681
    goto case_14;
  }
#line 1681
  if ((int )ent->fts_info == 12) {
#line 1681
    goto case_14;
  }
#line 1684
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1632
  if ((unsigned int )directories == 3U) {
#line 1634
    out_file |= 2 * ! no_filenames;
#line 1635
    return ((_Bool)1);
  }
  {
#line 1637
  fts_set(fts, ent, 4);
  }
#line 1638
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1641
  if (! suppress_errors) {
    {
#line 1642
    tmp___2 = gettext("recursive directory loop");
#line 1642
    tmp___3 = gettext("warning: %s: %s");
#line 1642
    error(0, 0, (char const   *)tmp___3, filename, tmp___2);
    }
  }
#line 1644
  return ((_Bool)1);
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1649
  suppressible_error(ent->fts_errno);
  }
#line 1650
  return ((_Bool)1);
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1654
  tmp___8 = skip_devices(command_line);
  }
#line 1654
  if (tmp___8) {
#line 1656
    st = ent->fts_statp;
#line 1658
    if (! st->st_mode) {
#line 1663
      if (follow) {
#line 1663
        tmp___4 = 0;
      } else {
#line 1663
        tmp___4 = 256;
      }
      {
#line 1663
      flag = tmp___4;
#line 1664
      tmp___6 = fstatat(fts->fts_cwd_fd, (char const   */* __restrict  */)ent->fts_accpath,
                        (struct stat */* __restrict  */)(& st1), flag);
      }
#line 1664
      if (tmp___6 != 0) {
        {
#line 1666
        tmp___5 = __errno_location();
#line 1666
        suppressible_error(*tmp___5);
        }
#line 1667
        return ((_Bool)1);
      }
#line 1669
      st = & st1;
    }
    {
#line 1671
    tmp___7 = is_device_mode(st->st_mode);
    }
#line 1671
    if (tmp___7) {
#line 1672
      return ((_Bool)1);
    }
  }
#line 1674
  goto switch_break;
  case_13: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 1678
  goto switch_break;
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 1682
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
  {
#line 1685
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1688
  tmp___9 = grepfile(fts->fts_cwd_fd, (char const   *)ent->fts_accpath, follow, command_line);
  }
#line 1688
  return (tmp___9);
}
}
#line 1693 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool open_symlink_nofollow_error(int err ) 
{ 


  {
#line 1696
  if (err == 40) {
#line 1697
    return ((_Bool)1);
  } else
#line 1696
  if (err == 31) {
#line 1697
    return ((_Bool)1);
  }
#line 1702
  return ((_Bool)0);
}
}
#line 1705 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool grepfile(int dirdesc , char const   *name , _Bool follow , _Bool command_line ) 
{ 
  int oflag ;
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int desc ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;

  {
#line 1708
  if (follow) {
#line 1708
    tmp = 0;
  } else {
#line 1708
    tmp = 131072;
  }
  {
#line 1708
  tmp___2 = skip_devices(command_line);
  }
#line 1708
  if (tmp___2) {
#line 1708
    tmp___1 = 2048;
  } else {
#line 1708
    tmp___1 = 0;
  }
  {
#line 1708
  oflag = (256 | tmp) | tmp___1;
#line 1711
  tmp___3 = openat_safer(dirdesc, name, oflag);
#line 1711
  desc = tmp___3;
  }
#line 1712
  if (desc < 0) {
#line 1714
    if (follow) {
      {
#line 1715
      tmp___4 = __errno_location();
#line 1715
      suppressible_error(*tmp___4);
      }
    } else {
      {
#line 1714
      tmp___5 = __errno_location();
#line 1714
      tmp___6 = open_symlink_nofollow_error(*tmp___5);
      }
#line 1714
      if (! tmp___6) {
        {
#line 1715
        tmp___4 = __errno_location();
#line 1715
        suppressible_error(*tmp___4);
        }
      }
    }
#line 1716
    return ((_Bool)1);
  }
  {
#line 1718
  tmp___7 = grepdesc(desc, command_line);
  }
#line 1718
  return (tmp___7);
}
}
#line 1723 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool drain_input(int fd , struct stat  const  *st ) 
{ 
  ssize_t nbytes ;
  int *tmp ;
  size_t tmp___0 ;

  {
#line 1727
  if ((st->st_mode & 61440U) == 4096U) {
#line 1727
    if (dev_null_output) {
      {
#line 1731
      nbytes = splice(fd, (__off64_t *)((void *)0), 1, (__off64_t *)((void *)0), (size_t )32768,
                      1U);
      }
#line 1733
      if (0L <= nbytes) {
#line 1733
        goto _L;
      } else {
        {
#line 1733
        tmp = __errno_location();
        }
#line 1733
        if (*tmp != 22) {
          _L: /* CIL Label */ 
          {
#line 1735
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1735
            if (! (0L < nbytes)) {
#line 1735
              goto while_break;
            }
            {
#line 1736
            nbytes = splice(fd, (__off64_t *)((void *)0), 1, (__off64_t *)((void *)0),
                            (size_t )32768, 1U);
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1738
          return ((_Bool )(nbytes == 0L));
        }
      }
    }
  }
  {
#line 1742
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1742
    tmp___0 = safe_read(fd, (void *)buffer, bufalloc);
#line 1742
    nbytes = (ssize_t )tmp___0;
    }
#line 1742
    if (! nbytes) {
#line 1742
      goto while_break___0;
    }
#line 1743
    if ((size_t )nbytes == 0xffffffffffffffffUL) {
#line 1744
      return ((_Bool)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1745
  return ((_Bool)1);
}
}
#line 1753 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void finalize_input(int fd , struct stat  const  *st , _Bool ineof ) 
{ 
  int *tmp ;
  __off_t tmp___0 ;
  int *tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  __off_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1756
  if (fd == 0) {
#line 1756
    if (outleft) {
#line 1756
      if (! ineof) {
#line 1756
        if (seek_failed) {
#line 1756
          goto _L;
        } else {
          {
#line 1756
          tmp___0 = lseek(fd, (__off_t )0, 2);
          }
#line 1756
          if (tmp___0 < 0L) {
            {
#line 1756
            tmp___1 = __errno_location();
            }
#line 1756
            if (*tmp___1 != 22) {
              _L: /* CIL Label */ 
              {
#line 1756
              tmp___2 = drain_input(fd, st);
              }
#line 1756
              if (tmp___2) {
#line 1756
                tmp___3 = 0;
              } else {
#line 1756
                tmp___3 = 1;
              }
            } else {
#line 1756
              tmp___3 = 0;
            }
          } else {
#line 1756
            tmp___3 = 0;
          }
        }
      } else {
#line 1756
        tmp___3 = 0;
      }
#line 1756
      tmp___6 = tmp___3;
    } else {
#line 1756
      if (bufoffset != after_last_match) {
#line 1756
        if (! seek_failed) {
          {
#line 1756
          tmp___4 = lseek(fd, after_last_match, 0);
          }
#line 1756
          if (tmp___4 < 0L) {
#line 1756
            tmp___5 = 1;
          } else {
#line 1756
            tmp___5 = 0;
          }
        } else {
#line 1756
          tmp___5 = 0;
        }
      } else {
#line 1756
        tmp___5 = 0;
      }
#line 1756
      tmp___6 = tmp___5;
    }
#line 1756
    if (tmp___6) {
      {
#line 1766
      tmp = __errno_location();
#line 1766
      suppressible_error(*tmp);
      }
    }
  }
#line 1767
  return;
}
}
#line 1769 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool grepdesc(int desc , _Bool command_line ) 
{ 
  intmax_t count ;
  _Bool status ;
  _Bool ineof ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  FTS *fts ;
  FTSENT *ent ;
  int opts ;
  int tmp___4 ;
  char *fts_arg[2] ;
  int *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;

  {
  {
#line 1773
  status = (_Bool)1;
#line 1774
  ineof = (_Bool)0;
#line 1783
  tmp___0 = fstat(desc, & st);
  }
#line 1783
  if (tmp___0 != 0) {
    {
#line 1785
    tmp = __errno_location();
#line 1785
    suppressible_error(*tmp);
    }
#line 1786
    goto closeout;
  }
#line 1789
  if (desc != 0) {
    {
#line 1789
    tmp___1 = skip_devices(command_line);
    }
#line 1789
    if (tmp___1) {
      {
#line 1789
      tmp___2 = is_device_mode(st.st_mode);
      }
#line 1789
      if (tmp___2) {
#line 1791
        goto closeout;
      }
    }
  }
#line 1793
  if (desc != 0) {
#line 1793
    if (command_line) {
      {
#line 1793
      tmp___3 = skipped_file(filename, (_Bool)1, (_Bool )(((st.st_mode & 61440U) == 16384U) != 0));
      }
#line 1793
      if (tmp___3) {
#line 1795
        goto closeout;
      }
    }
  }
#line 1797
  if (desc != 0) {
#line 1797
    if ((unsigned int )directories == 3U) {
#line 1797
      if ((st.st_mode & 61440U) == 16384U) {
#line 1806
        if (command_line) {
#line 1806
          tmp___4 = 0;
        } else {
#line 1806
          tmp___4 = 1;
        }
        {
#line 1806
        opts = fts_options & ~ tmp___4;
#line 1811
        tmp___6 = close(desc);
        }
#line 1811
        if (tmp___6 != 0) {
          {
#line 1812
          tmp___5 = __errno_location();
#line 1812
          suppressible_error(*tmp___5);
          }
        }
        {
#line 1814
        fts_arg[0] = (char *)filename;
#line 1815
        fts_arg[1] = (char *)((void *)0);
#line 1816
        fts = fts_open((char * const  *)(fts_arg), opts, (int (*)(FTSENT const   ** ,
                                                                  FTSENT const   ** ))((void *)0));
        }
#line 1818
        if (! fts) {
          {
#line 1819
          xalloc_die();
          }
        }
        {
#line 1820
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1820
          ent = fts_read(fts);
          }
#line 1820
          if (! ent) {
#line 1820
            goto while_break;
          }
          {
#line 1821
          tmp___7 = grepdirent(fts, ent, command_line);
#line 1821
          status = (_Bool )((int )status & (int )tmp___7);
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1822
        tmp___9 = __errno_location();
        }
#line 1822
        if (*tmp___9) {
          {
#line 1823
          tmp___8 = __errno_location();
#line 1823
          suppressible_error(*tmp___8);
          }
        }
        {
#line 1824
        tmp___11 = fts_close(fts);
        }
#line 1824
        if (tmp___11 != 0) {
          {
#line 1825
          tmp___10 = __errno_location();
#line 1825
          suppressible_error(*tmp___10);
          }
        }
#line 1826
        return (status);
      }
    }
  }
#line 1828
  if (desc != 0) {
#line 1828
    if ((unsigned int )directories == 4U) {
#line 1828
      if ((st.st_mode & 61440U) == 16384U) {
#line 1833
        goto closeout;
      } else {
#line 1828
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1828
    if ((unsigned int )devices == 2U) {
#line 1828
      goto _L;
    } else
#line 1828
    if ((unsigned int )devices == 0U) {
#line 1828
      if (! command_line) {
        _L: /* CIL Label */ 
        {
#line 1828
        tmp___12 = is_device_mode(st.st_mode);
        }
#line 1828
        if (tmp___12) {
#line 1833
          goto closeout;
        }
      }
    }
  }
#line 1853
  if (! out_quiet) {
#line 1853
    if ((unsigned int )list_files == 0U) {
#line 1853
      if (1L < max_count) {
#line 1853
        if ((st.st_mode & 61440U) == 32768U) {
#line 1853
          if (st.st_ino == out_stat.st_ino) {
#line 1853
            if (st.st_dev == out_stat.st_dev) {
#line 1856
              if (! suppress_errors) {
                {
#line 1857
                tmp___13 = input_filename();
#line 1857
                tmp___14 = quote(tmp___13);
#line 1857
                tmp___15 = gettext("input file %s is also the output");
#line 1857
                error(0, 0, (char const   *)tmp___15, tmp___14);
                }
              }
#line 1859
              errseen = (_Bool)1;
#line 1860
              goto closeout;
            }
          }
        }
      }
    }
  }
  {
#line 1868
  count = grep(desc, (struct stat  const  *)(& st), & ineof);
  }
#line 1869
  if (count_matches) {
#line 1871
    if (out_file) {
      {
#line 1873
      print_filename();
      }
#line 1874
      if (filename_mask) {
        {
#line 1875
        print_sep((char)58);
        }
      } else {
        {
#line 1877
        putchar_errno(0);
        }
      }
    }
    {
#line 1879
    printf_errno("%ld\n", count);
    }
#line 1880
    if (line_buffered) {
      {
#line 1881
      fflush_errno();
      }
    }
  }
#line 1884
  status = (_Bool )(! count);
#line 1886
  if ((unsigned int )list_files == 0U) {
    {
#line 1887
    finalize_input(desc, (struct stat  const  *)(& st), ineof);
    }
  } else {
#line 1888
    if (status) {
#line 1888
      tmp___17 = 2;
    } else {
#line 1888
      tmp___17 = 1;
    }
#line 1888
    if ((unsigned int )list_files == (unsigned int )tmp___17) {
      {
#line 1890
      print_filename();
#line 1891
      putchar_errno(10 & filename_mask);
      }
#line 1892
      if (line_buffered) {
        {
#line 1893
        fflush_errno();
        }
      }
    }
  }
  closeout: 
#line 1897
  if (desc != 0) {
    {
#line 1897
    tmp___19 = close(desc);
    }
#line 1897
    if (tmp___19 != 0) {
      {
#line 1898
      tmp___18 = __errno_location();
#line 1898
      suppressible_error(*tmp___18);
      }
    }
  }
#line 1899
  return (status);
}
}
#line 1902 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool grep_command_line_arg(char const   *arg ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1905
  tmp___1 = strcmp(arg, "-");
  }
#line 1905
  if (tmp___1 == 0) {
    {
#line 1907
    filename = (char const   *)label;
#line 1908
    tmp = grepdesc(0, (_Bool)1);
    }
#line 1908
    return (tmp);
  } else {
    {
#line 1912
    filename = arg;
#line 1913
    tmp___0 = grepfile(-100, arg, (_Bool)1, (_Bool)1);
    }
#line 1913
    return (tmp___0);
  }
}
}
#line 1918 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
void usage(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1921
  if (status != 0) {
    {
#line 1923
    tmp = getprogname();
#line 1923
    tmp___0 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1923
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            tmp);
#line 1925
    tmp___1 = getprogname();
#line 1925
    tmp___2 = gettext("Try \'%s --help\' for more information.\n");
#line 1925
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            tmp___1);
    }
  } else {
    {
#line 1930
    tmp___3 = getprogname();
#line 1930
    tmp___4 = gettext("Usage: %s [OPTION]... PATTERN [FILE]...\n");
#line 1930
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 1931
    tmp___5 = gettext("Search for PATTERN in each FILE or standard input.\n");
#line 1931
    printf((char const   */* __restrict  */)tmp___5);
#line 1932
    tmp___6 = gettext("PATTERN is, by default, a basic regular expression (BRE).\n");
#line 1932
    printf((char const   */* __restrict  */)tmp___6);
#line 1933
    tmp___7 = getprogname();
#line 1933
    tmp___8 = gettext("Example: %s -i \'hello world\' menu.h main.c\n\nRegexp selection and interpretation:\n");
#line 1933
    printf((char const   */* __restrict  */)tmp___8, tmp___7);
#line 1937
    tmp___9 = gettext("  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n");
#line 1937
    printf((char const   */* __restrict  */)tmp___9);
#line 1943
    tmp___10 = gettext("  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n");
#line 1943
    printf((char const   */* __restrict  */)tmp___10);
#line 1950
    tmp___11 = gettext("\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             display version information and exit\n      --help                display this help text and exit\n");
#line 1950
    printf((char const   */* __restrict  */)tmp___11);
#line 1957
    tmp___12 = gettext("\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the file name for each match\n  -h, --no-filename         suppress the file name prefix on output\n      --label=LABEL         use LABEL as the standard input file name prefix\n");
#line 1957
    printf((char const   */* __restrict  */)tmp___12);
#line 1968
    tmp___13 = gettext("  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is \'binary\', \'text\', or \'without-match\'\n  -a, --text                equivalent to --binary-files=text\n");
#line 1968
    printf((char const   */* __restrict  */)tmp___13);
#line 1975
    tmp___14 = gettext("  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is \'read\', \'recurse\', or \'skip\'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is \'read\' or \'skip\'\n  -r, --recursive           like --directories=recurse\n  -R, --dereference-recursive  likewise, but follow all symlinks\n");
#line 1975
    printf((char const   */* __restrict  */)tmp___14);
#line 1984
    tmp___15 = gettext("      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n");
#line 1984
    printf((char const   */* __restrict  */)tmp___15);
#line 1991
    tmp___16 = gettext("  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n");
#line 1991
    printf((char const   */* __restrict  */)tmp___16);
#line 1997
    tmp___17 = gettext("\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n");
#line 1997
    printf((char const   */* __restrict  */)tmp___17);
#line 2004
    tmp___18 = gettext("  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is \'always\', \'never\', or \'auto\'\n  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there\n                            (MSDOS/Windows)\n\n");
#line 2004
    printf((char const   */* __restrict  */)tmp___18);
#line 2013
    tmp___19 = gettext("\'egrep\' means \'grep -E\'.  \'fgrep\' means \'grep -F\'.\nDirect invocation as either \'egrep\' or \'fgrep\' is deprecated.\n");
#line 2013
    printf((char const   */* __restrict  */)tmp___19);
#line 2016
    tmp___20 = gettext("When FILE is -, read standard input.  With no FILE, read . if a command-line\n-r is given, - otherwise.  If fewer than two FILEs are given, assume -h.\nExit status is 0 if any line is selected, 1 otherwise;\nif any error occurs and -q is not given, the exit status is 2.\n");
#line 2016
    printf((char const   */* __restrict  */)tmp___20);
#line 2021
    emit_bug_reporting_address();
    }
  }
  {
#line 2023
  exit(status);
  }
}
}
#line 2028 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static struct __anonstruct_matchers_307522949  const  matchers[7]  = {      {{(char const   )'g', (char const   )'r', (char const   )'e', (char const   )'p',
       (char const   )'\000'}, (int )((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'e', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, (int )((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'f', (char const   )'g', (char const   )'r', (char const   )'e',
       (char const   )'p', (char const   )'\000'}, 0, & Fcompile, & Fexecute}, 
        {{(char const   )'a', (char const   )'w', (char const   )'k', (char const   )'\000'},
      (int )((((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((1UL << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'g', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, (int )((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((1UL << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1))),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'p', (char const   )'o', (char const   )'s', (char const   )'i',
       (char const   )'x', (char const   )'a', (char const   )'w', (char const   )'k',
       (char const   )'\000'}, (int )(((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
      & GEAcompile, & EGexecute}, 
        {{(char const   )'p', (char const   )'e', (char const   )'r', (char const   )'l',
       (char const   )'\000'}, 0, & Pcompile, & Pexecute}};
#line 2049 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int setmatcher(char const   *m , int matcher ) 
{ 
  int i ;
  int tmp ;

  {
#line 2052
  i = 0;
  {
#line 2052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2052
    if (! ((unsigned long )i < sizeof(matchers) / sizeof(matchers[0]))) {
#line 2052
      goto while_break;
    }
    {
#line 2053
    tmp = strcmp(m, (char const   *)(matchers[i].name));
    }
#line 2053
    if (tmp == 0) {
#line 2055
      if (0 <= matcher) {
#line 2055
        if (matcher != i) {
          {
#line 2056
          exit(1);
          }
        }
      }
#line 2057
      return (i);
    }
#line 2052
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2060
  exit(1);
  }
}
}
#line 2068 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static size_t prepend_args(char const   *options , char *buf , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  size_t n ;
  unsigned char tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___4 ;
  unsigned char tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;

  {
#line 2071
  o = options;
#line 2072
  b = buf;
#line 2073
  n = (size_t )0;
  {
#line 2075
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2077
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2077
      tmp = to_uchar((char )*o);
#line 2077
      tmp___0 = c_isspace((int )tmp);
      }
#line 2077
      if (! tmp___0) {
#line 2077
        goto while_break___0;
      }
#line 2078
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2079
    if (! *o) {
#line 2080
      return (n);
    }
#line 2081
    if (argv) {
#line 2082
      *(argv + n) = b;
    }
#line 2083
    n ++;
    {
#line 2085
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2086
      tmp___2 = b;
#line 2086
      b ++;
#line 2086
      tmp___4 = o;
#line 2086
      o ++;
#line 2086
      tmp___3 = (char )*tmp___4;
#line 2086
      *tmp___2 = tmp___3;
#line 2086
      if ((int )tmp___3 == 92) {
#line 2086
        if (*o) {
#line 2087
          tmp___1 = o;
#line 2087
          o ++;
#line 2087
          *(b + -1) = (char )*tmp___1;
        }
      }
#line 2085
      if (*o) {
        {
#line 2085
        tmp___5 = to_uchar((char )*o);
#line 2085
        tmp___6 = c_isspace((int )tmp___5);
        }
#line 2085
        if (tmp___6) {
#line 2085
          goto while_break___1;
        }
      } else {
#line 2085
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2090
    tmp___7 = b;
#line 2090
    b ++;
#line 2090
    *tmp___7 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2097 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t prepended ;
  size_t tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  size_t tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 2100
  if (options) {
#line 2100
    if (*options) {
      {
#line 2102
      tmp = strlen(options);
#line 2102
      tmp___0 = xmalloc(tmp + 1UL);
#line 2102
      buf = (char *)tmp___0;
#line 2103
      tmp___1 = prepend_args(options, buf, (char **)((void *)0));
#line 2103
      prepended = tmp___1;
#line 2104
      argc = *pargc;
#line 2105
      argv = (char * const  *)*pargv;
      }
#line 2108
      if ((size_t )(2147483647 - argc) < prepended) {
        {
#line 2109
        xalloc_die();
        }
      }
      {
#line 2110
      tmp___2 = xmalloc(((prepended + (size_t )argc) + 1UL) * sizeof(*pp));
#line 2110
      pp = (char **)tmp___2;
#line 2111
      *pargc = (int )(prepended + (size_t )argc);
#line 2112
      *pargv = pp;
#line 2113
      tmp___3 = pp;
#line 2113
      pp ++;
#line 2113
      tmp___4 = argv;
#line 2113
      argv ++;
#line 2113
      *tmp___3 = (char *)*tmp___4;
#line 2114
      tmp___5 = prepend_args(options, buf, pp);
#line 2114
      pp += tmp___5;
      }
      {
#line 2115
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2115
        tmp___6 = pp;
#line 2115
        pp ++;
#line 2115
        tmp___8 = argv;
#line 2115
        argv ++;
#line 2115
        tmp___7 = (char *)*tmp___8;
#line 2115
        *tmp___6 = tmp___7;
#line 2115
        if (! tmp___7) {
#line 2115
          goto while_break;
        }
#line 2116
        goto while_continue;
      }
      while_break: /* CIL Label */ ;
      }
#line 2117
      return ((int )prepended);
    }
  }
#line 2120
  return (0);
}
}
#line 2130
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) ;
#line 2130 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int prev_digit_optind  =    -1;
#line 2127 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int get_nondigit_option(int argc , char * const  *argv , intmax_t *default_context ) 
{ 
  int this_digit_optind ;
  _Bool was_digit ;
  char buf[((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL) + 4UL] ;
  char *p ;
  int opt ;
  _Bool tmp ;
  char *tmp___0 ;

  {
#line 2134
  p = buf;
#line 2137
  was_digit = (_Bool)0;
#line 2138
  this_digit_optind = optind;
  {
#line 2139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2141
    opt = getopt_long(argc, (char * const  *)((char **)argv), short_options, long_options,
                      (int *)((void *)0));
#line 2143
    tmp = c_isdigit(opt);
    }
#line 2143
    if (! tmp) {
#line 2144
      goto while_break;
    }
#line 2146
    if (prev_digit_optind != this_digit_optind) {
#line 2149
      p = buf;
    } else
#line 2146
    if (! was_digit) {
#line 2149
      p = buf;
    } else {
#line 2155
      p -= (int )buf[0] == 48;
    }
#line 2158
    if ((unsigned long )p == (unsigned long )((buf + sizeof(buf)) - 4)) {
      {
#line 2163
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"...");
#line 2164
      p += 3;
      }
#line 2165
      goto while_break;
    }
#line 2167
    tmp___0 = p;
#line 2167
    p ++;
#line 2167
    *tmp___0 = (char )opt;
#line 2169
    was_digit = (_Bool)1;
#line 2170
    prev_digit_optind = this_digit_optind;
#line 2171
    this_digit_optind = optind;
  }
  while_break: /* CIL Label */ ;
  }
#line 2173
  if ((unsigned long )p != (unsigned long )(buf)) {
    {
#line 2175
    *p = (char )'\000';
#line 2176
    context_length_arg((char const   *)(buf), default_context);
    }
  }
#line 2179
  return (opt);
}
}
#line 2186 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static void parse_grep_colors(void) 
{ 
  char const   *p ;
  char *q ;
  char *name ;
  char *val ;
  char *tmp ;
  char c ;
  struct color_cap  const  *cap ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 2194
  tmp = getenv("GREP_COLORS");
#line 2194
  p = (char const   *)tmp;
  }
#line 2195
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2196
    return;
  } else
#line 2195
  if ((int const   )*p == 0) {
#line 2196
    return;
  }
  {
#line 2199
  q = xstrdup(p);
#line 2201
  name = q;
#line 2202
  val = (char *)((void *)0);
  }
  {
#line 2204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2205
    if ((int )*q == 58) {
#line 2205
      goto _L;
    } else
#line 2205
    if ((int )*q == 0) {
      _L: /* CIL Label */ 
#line 2207
      c = *q;
#line 2210
      tmp___0 = q;
#line 2210
      q ++;
#line 2210
      *tmp___0 = (char )'\000';
#line 2213
      cap = color_dict;
      {
#line 2213
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2213
        if (! cap->name) {
#line 2213
          goto while_break___0;
        }
        {
#line 2214
        tmp___1 = strcmp((char const   *)cap->name, (char const   *)name);
        }
#line 2214
        if (tmp___1 == 0) {
#line 2215
          goto while_break___0;
        }
#line 2213
        cap ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2217
      if (cap->var) {
#line 2217
        if (val) {
#line 2218
          *(cap->var) = (char const   *)val;
        }
      }
#line 2219
      if (cap->fct) {
        {
#line 2220
        (*(cap->fct))();
        }
      }
#line 2221
      if ((int )c == 0) {
#line 2222
        return;
      }
#line 2223
      name = q;
#line 2224
      val = (char *)((void *)0);
    } else
#line 2226
    if ((int )*q == 61) {
#line 2228
      if ((unsigned long )q == (unsigned long )name) {
#line 2229
        return;
      } else
#line 2228
      if (val) {
#line 2229
        return;
      }
#line 2230
      tmp___2 = q;
#line 2230
      q ++;
#line 2230
      *tmp___2 = (char )'\000';
#line 2231
      val = q;
    } else
#line 2233
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 2234
      q ++;
    } else
#line 2235
    if ((int )*q == 59) {
#line 2236
      q ++;
    } else {
      {
#line 2235
      tmp___3 = c_isdigit((int )*q);
      }
#line 2235
      if (tmp___3) {
#line 2236
        q ++;
      } else {
#line 2238
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2242 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool contains_encoding_error(char const   *pat , size_t patlen ) 
{ 
  mbstate_t mbs ;
  size_t i ;
  size_t charlen ;

  {
#line 2245
  mbs.__count = 0;
#line 2245
  mbs.__value.__wch = 0U;
#line 2248
  i = (size_t )0;
  {
#line 2248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2248
    if (! (i < patlen)) {
#line 2248
      goto while_break;
    }
    {
#line 2250
    charlen = mb_clen(pat + i, patlen - i, & mbs);
    }
#line 2251
    if (0xfffffffffffffffeUL <= charlen) {
#line 2252
      return ((_Bool)1);
    }
#line 2248
    i += charlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 2254
  return ((_Bool)0);
}
}
#line 2264 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int fgrep_icase_charlen(char const   *pat , size_t patlen , mbstate_t *mbs ) 
{ 
  int n ;
  unsigned char tmp ;
  wchar_t wc ;
  wchar_t folded[32] ;
  size_t wn ;
  size_t tmp___0 ;
  int tmp___1 ;
  int i ;
  unsigned char c ;
  int tmp___2 ;

  {
  {
#line 2267
  tmp = to_uchar((char )*pat);
#line 2267
  n = (int )localeinfo.sbclen[tmp];
  }
#line 2268
  if (n < 0) {
    {
#line 2272
    tmp___0 = rpl_mbrtowc(& wc, pat, patlen, mbs);
#line 2272
    wn = tmp___0;
    }
#line 2273
    if (16UL < wn) {
#line 2274
      return (-1);
    } else {
      {
#line 2273
      tmp___1 = case_folded_counterparts((wint_t )wc, (wchar_t *)(folded));
      }
#line 2273
      if (tmp___1) {
#line 2274
        return (-1);
      }
    }
#line 2275
    i = (int )wn;
    {
#line 2275
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2275
      i --;
#line 2275
      if (! (0 < i)) {
#line 2275
        goto while_break;
      }
      {
#line 2277
      c = (unsigned char )*(pat + i);
#line 2278
      tmp___2 = toupper((int )c);
      }
#line 2278
      if (tmp___2 != (int )c) {
#line 2279
        return (-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2281
    n = (int )wn;
  }
#line 2283
  return (n);
}
}
#line 2290 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static _Bool fgrep_icase_available(char const   *pat , size_t patlen ) 
{ 
  mbstate_t mbs ;
  size_t i ;
  int n ;
  int tmp ;

  {
#line 2293
  mbs.__count = 0;
#line 2293
  mbs.__value.__wch = 0U;
#line 2295
  i = (size_t )0;
  {
#line 2295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2295
    if (! (i < patlen)) {
#line 2295
      goto while_break;
    }
    {
#line 2297
    tmp = fgrep_icase_charlen(pat + i, patlen - i, & mbs);
#line 2297
    n = tmp;
    }
#line 2298
    if (n < 0) {
#line 2299
      return ((_Bool)0);
    }
#line 2300
    i += (size_t )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  return ((_Bool)1);
}
}
#line 2308 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
void fgrep_to_grep_pattern(char **keys_p , size_t *len_p ) 
{ 
  size_t len ;
  char *keys ;
  mbstate_t mb_state ;
  char *new_keys ;
  void *tmp ;
  char *p ;
  size_t n ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2311
  len = *len_p;
#line 2312
  keys = *keys_p;
#line 2313
  mb_state.__count = 0;
#line 2313
  mb_state.__value.__wch = 0U;
#line 2314
  tmp = xnmalloc(len + 1UL, (size_t )2);
#line 2314
  new_keys = (char *)tmp;
#line 2315
  p = new_keys;
  }
  {
#line 2318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2318
    if (! len) {
#line 2318
      goto while_break;
    }
    {
#line 2320
    n = mb_clen((char const   *)keys, len, & mb_state);
    }
    {
#line 2323
    if (n == 0xfffffffffffffffeUL) {
#line 2323
      goto case_18446744073709551614;
    }
#line 2330
    if (n == 0xffffffffffffffffUL) {
#line 2330
      goto case_18446744073709551615;
    }
#line 2334
    if (n == 1UL) {
#line 2334
      goto case_1;
    }
#line 2326
    goto switch_default;
    case_18446744073709551614: /* CIL Label */ 
#line 2324
    n = len;
    switch_default: /* CIL Label */ 
    {
#line 2327
    tmp___0 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)keys,
                      n);
#line 2327
    p = (char *)tmp___0;
    }
#line 2328
    goto switch_break;
    case_18446744073709551615: /* CIL Label */ 
    {
#line 2331
    memset((void *)(& mb_state), 0, sizeof(mb_state));
#line 2332
    n = (size_t )1;
    }
    case_1: /* CIL Label */ 
    {
#line 2337
    if ((int )*keys == 94) {
#line 2337
      goto case_94;
    }
#line 2337
    if ((int )*keys == 92) {
#line 2337
      goto case_94;
    }
#line 2337
    if ((int )*keys == 91) {
#line 2337
      goto case_94;
    }
#line 2337
    if ((int )*keys == 46) {
#line 2337
      goto case_94;
    }
#line 2337
    if ((int )*keys == 42) {
#line 2337
      goto case_94;
    }
#line 2337
    if ((int )*keys == 36) {
#line 2337
      goto case_94;
    }
#line 2335
    goto switch_break___0;
    case_94: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 2338
    tmp___1 = p;
#line 2338
    p ++;
#line 2338
    *tmp___1 = (char )'\\';
#line 2338
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2340
    tmp___2 = p;
#line 2340
    p ++;
#line 2340
    *tmp___2 = *keys;
#line 2341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2318
    keys += n;
#line 2318
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2345
  free((void *)*keys_p);
#line 2346
  *keys_p = new_keys;
#line 2347
  *len_p = (size_t )(p - new_keys);
  }
#line 2348
  return;
}
}
#line 2357 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static int try_fgrep_pattern(int matcher , char *keys , size_t *len_p ) 
{ 
  int result ;
  size_t len ;
  char *new_keys ;
  void *tmp ;
  char *p ;
  char const   *q ;
  mbstate_t mb_state ;
  size_t n ;
  int ni ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2360
  result = matcher;
#line 2361
  len = *len_p;
#line 2362
  tmp = xmalloc(len + 1UL);
#line 2362
  new_keys = (char *)tmp;
#line 2363
  p = new_keys;
#line 2364
  q = (char const   *)keys;
#line 2365
  mb_state.__count = 0;
#line 2365
  mb_state.__value.__wch = 0U;
  }
  {
#line 2367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2367
    if (! (len != 0UL)) {
#line 2367
      goto while_break;
    }
    {
#line 2371
    if ((int const   )*q == 94) {
#line 2371
      goto case_94;
    }
#line 2371
    if ((int const   )*q == 91) {
#line 2371
      goto case_94;
    }
#line 2371
    if ((int const   )*q == 46) {
#line 2371
      goto case_94;
    }
#line 2371
    if ((int const   )*q == 42) {
#line 2371
      goto case_94;
    }
#line 2371
    if ((int const   )*q == 36) {
#line 2371
      goto case_94;
    }
#line 2374
    if ((int const   )*q == 124) {
#line 2374
      goto case_124;
    }
#line 2374
    if ((int const   )*q == 123) {
#line 2374
      goto case_124;
    }
#line 2374
    if ((int const   )*q == 63) {
#line 2374
      goto case_124;
    }
#line 2374
    if ((int const   )*q == 43) {
#line 2374
      goto case_124;
    }
#line 2374
    if ((int const   )*q == 40) {
#line 2374
      goto case_124;
    }
#line 2379
    if ((int const   )*q == 92) {
#line 2379
      goto case_92;
    }
#line 2369
    goto switch_break;
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 2372
    goto fail;
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 2375
    if (matcher != 0) {
#line 2376
      goto fail;
    }
#line 2377
    goto switch_break;
    case_92: /* CIL Label */ 
#line 2380
    if (1UL < len) {
      {
#line 2387
      if ((int const   )*(q + 1) == 57) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 56) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 55) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 54) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 53) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 52) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 51) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 50) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 49) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 62) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 96) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 119) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 115) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 98) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 60) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 39) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 87) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 83) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 66) {
#line 2387
        goto case_57;
      }
#line 2387
      if ((int const   )*(q + 1) == 10) {
#line 2387
        goto case_57;
      }
#line 2390
      if ((int const   )*(q + 1) == 124) {
#line 2390
        goto case_124___0;
      }
#line 2390
      if ((int const   )*(q + 1) == 123) {
#line 2390
        goto case_124___0;
      }
#line 2390
      if ((int const   )*(q + 1) == 63) {
#line 2390
        goto case_124___0;
      }
#line 2390
      if ((int const   )*(q + 1) == 43) {
#line 2390
        goto case_124___0;
      }
#line 2390
      if ((int const   )*(q + 1) == 40) {
#line 2390
        goto case_124___0;
      }
#line 2394
      goto switch_default;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_96: /* CIL Label */ 
      case_119: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 2388
      goto fail;
      case_124___0: /* CIL Label */ 
      case_123___0: /* CIL Label */ 
      case_63___0: /* CIL Label */ 
      case_43___0: /* CIL Label */ 
      case_40___0: /* CIL Label */ 
#line 2391
      if (matcher == 0) {
#line 2392
        goto fail;
      }
      switch_default: /* CIL Label */ 
#line 2395
      q ++;
#line 2395
      len --;
#line 2396
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2398
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2403
    if (match_icase) {
      {
#line 2405
      tmp___0 = fgrep_icase_charlen(q, len, & mb_state);
#line 2405
      ni = tmp___0;
      }
#line 2406
      if (ni < 0) {
#line 2407
        goto fail;
      }
#line 2408
      n = (size_t )ni;
    } else {
      {
#line 2412
      n = mb_clen(q, len, & mb_state);
      }
#line 2413
      if (16UL < n) {
#line 2414
        goto fail;
      }
    }
    {
#line 2417
    tmp___1 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)q,
                      n);
#line 2417
    p = (char *)tmp___1;
#line 2418
    q += n;
#line 2419
    len -= n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2423
  if (*len_p != (size_t )(p - new_keys)) {
    {
#line 2425
    *len_p = (size_t )(p - new_keys);
#line 2426
    memcpy((void */* __restrict  */)keys, (void const   */* __restrict  */)new_keys,
           (size_t )(p - new_keys));
    }
  }
#line 2428
  result = 2;
  fail: 
  {
#line 2431
  free((void *)new_keys);
  }
#line 2432
  return (result);
}
}
#line 2929
int main(int argc , char **argv ) ;
#line 2929 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char * const  cwd_only[2]  = {      (char */* const  */)((char *)"."),      (char */* const  */)((void *)0)};
#line 2935 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
static char * const  stdin_only[2]  = {      (char */* const  */)((char *)"-"),      (char */* const  */)((void *)0)};
#line 2435 "/home/khheo/project/benchmark/grep-3.0/src/grep.c"
int main(int argc , char **argv ) 
{ 
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int matcher ;
  _Bool with_filenames ;
  size_t cc ;
  int opt ;
  int prepended ;
  int prev_optind ;
  int last_recursive ;
  int fread_errno ;
  intmax_t default_context ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ptrdiff_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  FILE *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  strtol_error tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int cmd ;
  int tmp___26 ;
  int tmp___27 ;
  int cmd___0 ;
  int tmp___28 ;
  int tmp___29 ;
  int cmd___1 ;
  int tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  _Bool possibly_tty ;
  struct stat tmp_stat ;
  struct stat null_stat ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *userval ;
  char *tmp___41 ;
  int tmp___42 ;
  _Bool tmp___43 ;
  _Bool tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char eolbytes[3] ;
  size_t match_size ;
  size_t tmp___47 ;
  long psize ;
  long tmp___49 ;
  size_t tmp___50 ;
  void *tmp___51 ;
  char * const  *files ;
  _Bool status ;
  char * const  *tmp___52 ;
  _Bool tmp___53 ;
  int tmp___54 ;

  {
  {
#line 2438
  keys = (char *)((void *)0);
#line 2439
  keycc = (size_t )0;
#line 2439
  keyalloc = (size_t )0;
#line 2440
  matcher = -1;
#line 2441
  with_filenames = (_Bool)0;
#line 2448
  exit_failure = (int volatile   )2;
#line 2451
  eolbyte = (char )'\n';
#line 2452
  filename_mask = ~ 0;
#line 2454
  max_count = 9223372036854775807L;
#line 2457
  out_before = (intmax_t )-1;
#line 2457
  out_after = out_before;
#line 2459
  default_context = (intmax_t )-1;
#line 2461
  only_matching = (_Bool)0;
#line 2465
  setlocale(6, "");
#line 2468
  bindtextdomain("grep", "/usr/local/share/locale");
#line 2469
  textdomain("grep");
#line 2472
  init_localeinfo(& localeinfo);
#line 2474
  atexit(& clean_up_stdout);
#line 2476
  last_recursive = 0;
#line 2478
  tmp = getenv("GREP_OPTIONS");
#line 2478
  prepended = prepend_default_options((char const   *)tmp, & argc, & argv);
  }
#line 2479
  if (prepended) {
    {
#line 2480
    tmp___0 = gettext("warning: GREP_OPTIONS is deprecated; please use an alias or script");
#line 2480
    error(0, 0, (char const   *)tmp___0);
    }
  }
  {
#line 2483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2483
    prev_optind = optind;
#line 2483
    opt = get_nondigit_option(argc, (char * const  *)argv, & default_context);
    }
#line 2483
    if (! (opt != -1)) {
#line 2483
      goto while_break;
    }
    {
#line 2487
    if (opt == 65) {
#line 2487
      goto case_65;
    }
#line 2491
    if (opt == 66) {
#line 2491
      goto case_66;
    }
#line 2495
    if (opt == 67) {
#line 2495
      goto case_67;
    }
#line 2501
    if (opt == 68) {
#line 2501
      goto case_68;
    }
#line 2510
    if (opt == 69) {
#line 2510
      goto case_69;
    }
#line 2514
    if (opt == 70) {
#line 2514
      goto case_70;
    }
#line 2518
    if (opt == 80) {
#line 2518
      goto case_80;
    }
#line 2522
    if (opt == 71) {
#line 2522
      goto case_71;
    }
#line 2526
    if (opt == 88) {
#line 2526
      goto case_88;
    }
#line 2530
    if (opt == 72) {
#line 2530
      goto case_72;
    }
#line 2535
    if (opt == 73) {
#line 2535
      goto case_73;
    }
#line 2539
    if (opt == 84) {
#line 2539
      goto case_84;
    }
#line 2543
    if (opt == 85) {
#line 2543
      goto case_85;
    }
#line 2547
    if (opt == 117) {
#line 2547
      goto case_117;
    }
#line 2551
    if (opt == 86) {
#line 2551
      goto case_86;
    }
#line 2555
    if (opt == 97) {
#line 2555
      goto case_97;
    }
#line 2559
    if (opt == 98) {
#line 2559
      goto case_98;
    }
#line 2563
    if (opt == 99) {
#line 2563
      goto case_99;
    }
#line 2567
    if (opt == 100) {
#line 2567
      goto case_100;
    }
#line 2574
    if (opt == 101) {
#line 2574
      goto case_101;
    }
#line 2588
    if (opt == 102) {
#line 2588
      goto case_102;
    }
#line 2612
    if (opt == 104) {
#line 2612
      goto case_104;
    }
#line 2618
    if (opt == 121) {
#line 2618
      goto case_121;
    }
#line 2618
    if (opt == 105) {
#line 2618
      goto case_121;
    }
#line 2622
    if (opt == 76) {
#line 2622
      goto case_76;
    }
#line 2628
    if (opt == 108) {
#line 2628
      goto case_108;
    }
#line 2632
    if (opt == 109) {
#line 2632
      goto case_109;
    }
#line 2644
    if (opt == 110) {
#line 2644
      goto case_110;
    }
#line 2648
    if (opt == 111) {
#line 2648
      goto case_111;
    }
#line 2652
    if (opt == 113) {
#line 2652
      goto case_113;
    }
#line 2657
    if (opt == 82) {
#line 2657
      goto case_82;
    }
#line 2660
    if (opt == 114) {
#line 2660
      goto case_114;
    }
#line 2665
    if (opt == 115) {
#line 2665
      goto case_115;
    }
#line 2669
    if (opt == 118) {
#line 2669
      goto case_118;
    }
#line 2673
    if (opt == 119) {
#line 2673
      goto case_119;
    }
#line 2678
    if (opt == 120) {
#line 2678
      goto case_120;
    }
#line 2682
    if (opt == 90) {
#line 2682
      goto case_90;
    }
#line 2686
    if (opt == 122) {
#line 2686
      goto case_122;
    }
#line 2690
    if (opt == 128) {
#line 2690
      goto case_128;
    }
#line 2701
    if (opt == 129) {
#line 2701
      goto case_129;
    }
#line 2721
    if (opt == 134) {
#line 2721
      goto case_134;
    }
#line 2721
    if (opt == 131) {
#line 2721
      goto case_134;
    }
#line 2731
    if (opt == 132) {
#line 2731
      goto case_132;
    }
#line 2743
    if (opt == 130) {
#line 2743
      goto case_130;
    }
#line 2754
    if (opt == 133) {
#line 2754
      goto case_133;
    }
#line 2758
    if (opt == 135) {
#line 2758
      goto case_135;
    }
#line 2762
    if (opt == 136) {
#line 2762
      goto case_136;
    }
#line 2766
    if (opt == 0) {
#line 2766
      goto case_0___0;
    }
#line 2770
    goto switch_default___0;
    case_65: /* CIL Label */ 
    {
#line 2488
    context_length_arg((char const   *)optarg, & out_after);
    }
#line 2489
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 2492
    context_length_arg((char const   *)optarg, & out_before);
    }
#line 2493
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 2498
    context_length_arg((char const   *)optarg, & default_context);
    }
#line 2499
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 2502
    tmp___2 = strcmp((char const   *)optarg, "read");
    }
#line 2502
    if (tmp___2 == 0) {
#line 2503
      devices = (enum __anonenum_devices_473526324 )1;
    } else {
      {
#line 2504
      tmp___1 = strcmp((char const   *)optarg, "skip");
      }
#line 2504
      if (tmp___1 == 0) {
#line 2505
        devices = (enum __anonenum_devices_473526324 )2;
      } else {
        {
#line 2507
        exit(1);
        }
      }
    }
#line 2508
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 2511
    matcher = setmatcher("egrep", matcher);
    }
#line 2512
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 2515
    matcher = setmatcher("fgrep", matcher);
    }
#line 2516
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 2519
    matcher = setmatcher("perl", matcher);
    }
#line 2520
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 2523
    matcher = setmatcher("grep", matcher);
    }
#line 2524
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 2527
    matcher = setmatcher((char const   *)optarg, matcher);
    }
#line 2528
    goto switch_break;
    case_72: /* CIL Label */ 
#line 2531
    with_filenames = (_Bool)1;
#line 2532
    no_filenames = (_Bool)0;
#line 2533
    goto switch_break;
    case_73: /* CIL Label */ 
#line 2536
    binary_files = (enum __anonenum_binary_files_601436154 )2;
#line 2537
    goto switch_break;
    case_84: /* CIL Label */ 
#line 2540
    align_tabs = (_Bool)1;
#line 2541
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 2544
    dos_binary();
    }
#line 2545
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 2548
    dos_unix_byte_offsets();
    }
#line 2549
    goto switch_break;
    case_86: /* CIL Label */ 
#line 2552
    show_version = (_Bool)1;
#line 2553
    goto switch_break;
    case_97: /* CIL Label */ 
#line 2556
    binary_files = (enum __anonenum_binary_files_601436154 )1;
#line 2557
    goto switch_break;
    case_98: /* CIL Label */ 
#line 2560
    out_byte = (_Bool)1;
#line 2561
    goto switch_break;
    case_99: /* CIL Label */ 
#line 2564
    count_matches = (_Bool)1;
#line 2565
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 2568
    tmp___3 = __xargmatch_internal("--directories", (char const   *)optarg, directories_args,
                                   (char const   *)(directories_types), sizeof(directories_types[0]),
                                   argmatch_die);
#line 2568
    directories = (enum directories_type )directories_types[tmp___3];
    }
#line 2570
    if ((unsigned int )directories == 3U) {
#line 2571
      last_recursive = prev_optind;
    }
#line 2572
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 2575
    cc = strlen((char const   *)optarg);
    }
#line 2576
    if (keyalloc < (keycc + cc) + 1UL) {
      {
#line 2578
      keyalloc = (keycc + cc) + 1UL;
#line 2579
      tmp___4 = x2realloc((void *)keys, & keyalloc);
#line 2579
      keys = (char *)tmp___4;
      }
    }
    {
#line 2581
    oldcc = keycc;
#line 2582
    memcpy((void */* __restrict  */)(keys + oldcc), (void const   */* __restrict  */)optarg,
           cc);
#line 2583
    keycc += cc;
#line 2584
    tmp___5 = keycc;
#line 2584
    keycc ++;
#line 2584
    *(keys + tmp___5) = (char )'\n';
#line 2585
    fl_add((char const   *)(keys + oldcc), cc + 1UL, "");
    }
#line 2586
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 2589
    tmp___8 = strcmp((char const   *)optarg, "-");
    }
#line 2589
    if (tmp___8 == 0) {
#line 2589
      fp = stdin;
    } else {
      {
#line 2589
      tmp___7 = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
#line 2589
      fp = tmp___7;
      }
    }
#line 2590
    if (! fp) {
      {
#line 2591
      exit(1);
      }
    }
#line 2592
    oldcc = keycc;
    {
#line 2593
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2595
      if (keyalloc <= keycc + 1UL) {
        {
#line 2596
        tmp___9 = x2realloc((void *)keys, & keyalloc);
#line 2596
        keys = (char *)tmp___9;
        }
      }
      {
#line 2597
      cc = fread_unlocked((void */* __restrict  */)(keys + keycc), (size_t )1, keyalloc - (keycc + 1UL),
                          (FILE */* __restrict  */)fp);
      }
#line 2598
      if (cc == 0UL) {
#line 2599
        goto while_break___0;
      }
#line 2593
      keycc += cc;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2601
    tmp___10 = __errno_location();
#line 2601
    fread_errno = *tmp___10;
#line 2602
    tmp___11 = ferror_unlocked(fp);
    }
#line 2602
    if (tmp___11) {
      {
#line 2603
      exit(1);
      }
    }
#line 2604
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 2605
      fclose(fp);
      }
    }
#line 2607
    if (oldcc != keycc) {
#line 2607
      if ((int )*(keys + (keycc - 1UL)) != 10) {
#line 2608
        tmp___12 = keycc;
#line 2608
        keycc ++;
#line 2608
        *(keys + tmp___12) = (char )'\n';
      }
    }
    {
#line 2609
    fl_add((char const   *)(keys + oldcc), keycc - oldcc, (char const   *)optarg);
    }
#line 2610
    goto switch_break;
    case_104: /* CIL Label */ 
#line 2613
    with_filenames = (_Bool)0;
#line 2614
    no_filenames = (_Bool)1;
#line 2615
    goto switch_break;
    case_121: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 2619
    match_icase = (_Bool)1;
#line 2620
    goto switch_break;
    case_76: /* CIL Label */ 
#line 2625
    list_files = (enum __anonenum_list_files_328606374 )2;
#line 2626
    goto switch_break;
    case_108: /* CIL Label */ 
#line 2629
    list_files = (enum __anonenum_list_files_328606374 )1;
#line 2630
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 2633
    tmp___13 = xstrtoimax((char const   *)optarg, (char **)0, 10, & max_count, "");
    }
    {
#line 2636
    if ((unsigned int )tmp___13 == 1U) {
#line 2636
      goto case_1;
    }
#line 2636
    if ((unsigned int )tmp___13 == 0U) {
#line 2636
      goto case_1;
    }
#line 2639
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 2637
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2640
    exit(1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2642
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2645
    out_line = (_Bool)1;
#line 2646
    goto switch_break;
    case_111: /* CIL Label */ 
#line 2649
    only_matching = (_Bool)1;
#line 2650
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2653
    exit_on_match = (_Bool)1;
#line 2654
    exit_failure = (int volatile   )0;
#line 2655
    goto switch_break;
    case_82: /* CIL Label */ 
#line 2658
    fts_options = 778;
    case_114: /* CIL Label */ 
#line 2661
    directories = (enum directories_type )3;
#line 2662
    last_recursive = prev_optind;
#line 2663
    goto switch_break;
    case_115: /* CIL Label */ 
#line 2666
    suppress_errors = (_Bool)1;
#line 2667
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2670
    out_invert = (_Bool)1;
#line 2671
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 2674
    wordinit();
#line 2675
    match_words = (_Bool)1;
    }
#line 2676
    goto switch_break;
    case_120: /* CIL Label */ 
#line 2679
    match_lines = (_Bool)1;
#line 2680
    goto switch_break;
    case_90: /* CIL Label */ 
#line 2683
    filename_mask = 0;
#line 2684
    goto switch_break;
    case_122: /* CIL Label */ 
#line 2687
    eolbyte = (char )'\000';
#line 2688
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 2691
    tmp___16 = strcmp((char const   *)optarg, "binary");
    }
#line 2691
    if (tmp___16 == 0) {
#line 2692
      binary_files = (enum __anonenum_binary_files_601436154 )0;
    } else {
      {
#line 2693
      tmp___15 = strcmp((char const   *)optarg, "text");
      }
#line 2693
      if (tmp___15 == 0) {
#line 2694
        binary_files = (enum __anonenum_binary_files_601436154 )1;
      } else {
        {
#line 2695
        tmp___14 = strcmp((char const   *)optarg, "without-match");
        }
#line 2695
        if (tmp___14 == 0) {
#line 2696
          binary_files = (enum __anonenum_binary_files_601436154 )2;
        } else {
          {
#line 2698
          exit(1);
          }
        }
      }
    }
#line 2699
    goto switch_break;
    case_129: /* CIL Label */ 
#line 2702
    if (optarg) {
      {
#line 2704
      tmp___23 = strcasecmp((char const   *)optarg, "always");
      }
#line 2704
      if (tmp___23) {
        {
#line 2704
        tmp___24 = strcasecmp((char const   *)optarg, "yes");
        }
#line 2704
        if (tmp___24) {
          {
#line 2704
          tmp___25 = strcasecmp((char const   *)optarg, "force");
          }
#line 2704
          if (tmp___25) {
            {
#line 2707
            tmp___20 = strcasecmp((char const   *)optarg, "never");
            }
#line 2707
            if (tmp___20) {
              {
#line 2707
              tmp___21 = strcasecmp((char const   *)optarg, "no");
              }
#line 2707
              if (tmp___21) {
                {
#line 2707
                tmp___22 = strcasecmp((char const   *)optarg, "none");
                }
#line 2707
                if (tmp___22) {
                  {
#line 2710
                  tmp___17 = strcasecmp((char const   *)optarg, "auto");
                  }
#line 2710
                  if (tmp___17) {
                    {
#line 2710
                    tmp___18 = strcasecmp((char const   *)optarg, "tty");
                    }
#line 2710
                    if (tmp___18) {
                      {
#line 2710
                      tmp___19 = strcasecmp((char const   *)optarg, "if-tty");
                      }
#line 2710
                      if (tmp___19) {
#line 2714
                        show_help = 1;
                      } else {
#line 2712
                        color_option = 2;
                      }
                    } else {
#line 2712
                      color_option = 2;
                    }
                  } else {
#line 2712
                    color_option = 2;
                  }
                } else {
#line 2709
                  color_option = 0;
                }
              } else {
#line 2709
                color_option = 0;
              }
            } else {
#line 2709
              color_option = 0;
            }
          } else {
#line 2706
            color_option = 1;
          }
        } else {
#line 2706
          color_option = 1;
        }
      } else {
#line 2706
        color_option = 1;
      }
    } else {
#line 2717
      color_option = 2;
    }
#line 2718
    goto switch_break;
    case_134: /* CIL Label */ 
    case_131: /* CIL Label */ 
#line 2722
    cmd = 0;
    {
#line 2722
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2722
      if (! (cmd < 2)) {
#line 2722
        goto while_break___1;
      }
#line 2724
      if (! excluded_patterns[cmd]) {
        {
#line 2725
        excluded_patterns[cmd] = new_exclude();
        }
      }
#line 2726
      if (opt == 134) {
#line 2726
        tmp___26 = 1 << 29;
      } else {
#line 2726
        tmp___26 = 0;
      }
      {
#line 2726
      tmp___27 = exclude_options((_Bool )cmd);
#line 2726
      add_exclude(excluded_patterns[cmd], (char const   *)optarg, tmp___26 | tmp___27);
#line 2722
      cmd ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2730
    goto switch_break;
    case_132: /* CIL Label */ 
#line 2732
    cmd___0 = 0;
    {
#line 2732
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2732
      if (! (cmd___0 < 2)) {
#line 2732
        goto while_break___2;
      }
#line 2734
      if (! excluded_patterns[cmd___0]) {
        {
#line 2735
        excluded_patterns[cmd___0] = new_exclude();
        }
      }
      {
#line 2736
      tmp___28 = exclude_options((_Bool )cmd___0);
#line 2736
      tmp___29 = add_exclude_file(& add_exclude, excluded_patterns[cmd___0], (char const   *)optarg,
                                  tmp___28, (char )'\n');
      }
#line 2736
      if (tmp___29 != 0) {
        {
#line 2739
        exit(1);
        }
      }
#line 2732
      cmd___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2741
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 2744
    strip_trailing_slashes(optarg);
#line 2745
    cmd___1 = 0;
    }
    {
#line 2745
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2745
      if (! (cmd___1 < 2)) {
#line 2745
        goto while_break___3;
      }
#line 2747
      if (! excluded_directory_patterns[cmd___1]) {
        {
#line 2748
        excluded_directory_patterns[cmd___1] = new_exclude();
        }
      }
      {
#line 2749
      tmp___30 = exclude_options((_Bool )cmd___1);
#line 2749
      add_exclude(excluded_directory_patterns[cmd___1], (char const   *)optarg, tmp___30);
#line 2745
      cmd___1 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2752
    goto switch_break;
    case_133: /* CIL Label */ 
#line 2755
    group_separator = (char const   *)optarg;
#line 2756
    goto switch_break;
    case_135: /* CIL Label */ 
#line 2759
    line_buffered = (_Bool)1;
#line 2760
    goto switch_break;
    case_136: /* CIL Label */ 
#line 2763
    label = optarg;
#line 2764
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 2768
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 2771
    usage(2);
    }
#line 2772
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2776
  if (show_version) {
    {
#line 2778
    tmp___31 = gettext("others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>");
#line 2778
    tmp___32 = proper_name("Mike Haertel");
#line 2778
    tmp___33 = getprogname();
#line 2778
    version_etc(stdout, tmp___33, "GNU grep", "3.0", tmp___32, tmp___31, (char *)((void *)0));
    }
#line 2780
    return (0);
  }
#line 2783
  if (show_help) {
    {
#line 2784
    usage(0);
    }
  }
#line 2786
  if (keys) {
#line 2788
    if (keycc == 0UL) {
#line 2791
      out_invert = (_Bool )((int )out_invert ^ 1);
#line 2792
      match_words = (_Bool)0;
#line 2792
      match_lines = match_words;
    } else {
#line 2796
      keycc --;
    }
  } else
#line 2798
  if (optind < argc) {
    {
#line 2801
    keycc = strlen((char const   *)*(argv + optind));
#line 2802
    tmp___34 = optind;
#line 2802
    optind ++;
#line 2802
    tmp___35 = xmemdup((void const   *)*(argv + tmp___34), keycc + 1UL);
#line 2802
    keys = (char *)tmp___35;
#line 2803
    fl_add((char const   *)keys, keycc, "");
#line 2804
    n_patterns ++;
    }
  } else {
    {
#line 2807
    usage(2);
    }
  }
#line 2809
  possibly_tty = (_Bool)0;
#line 2811
  if (! exit_on_match) {
    {
#line 2811
    tmp___37 = fstat(1, & tmp_stat);
    }
#line 2811
    if (tmp___37 == 0) {
#line 2813
      if ((tmp_stat.st_mode & 61440U) == 32768U) {
#line 2814
        out_stat = tmp_stat;
      } else
#line 2815
      if ((tmp_stat.st_mode & 61440U) == 8192U) {
        {
#line 2818
        tmp___36 = stat((char const   */* __restrict  */)"/dev/null", (struct stat */* __restrict  */)(& null_stat));
        }
#line 2818
        if (tmp___36 == 0) {
#line 2818
          if (tmp_stat.st_ino == null_stat.st_ino) {
#line 2818
            if (tmp_stat.st_dev == null_stat.st_dev) {
#line 2820
              dev_null_output = (_Bool)1;
            } else {
#line 2822
              possibly_tty = (_Bool)1;
            }
          } else {
#line 2822
            possibly_tty = (_Bool)1;
          }
        } else {
#line 2822
          possibly_tty = (_Bool)1;
        }
      }
    }
  }
#line 2828
  if ((int )exit_on_match | (int )dev_null_output) {
#line 2829
    list_files = (enum __anonenum_list_files_328606374 )0;
  }
#line 2830
  if ((int )exit_on_match | (int )dev_null_output) {
#line 2832
    count_matches = (_Bool)0;
#line 2833
    done_on_match = (_Bool)1;
  } else
#line 2830
  if ((unsigned int )list_files != 0U) {
#line 2832
    count_matches = (_Bool)0;
#line 2833
    done_on_match = (_Bool)1;
  }
#line 2835
  out_quiet = (_Bool )((int )count_matches | (int )done_on_match);
#line 2837
  if (out_after < 0L) {
#line 2838
    out_after = default_context;
  }
#line 2839
  if (out_before < 0L) {
#line 2840
    out_before = default_context;
  }
#line 2844
  if (max_count == 0L) {
#line 2844
    goto _L;
  } else
#line 2844
  if (keycc == 0UL) {
#line 2844
    if (out_invert) {
#line 2844
      if (! match_lines) {
#line 2844
        if (! match_words) {
          _L: /* CIL Label */ 
#line 2844
          if ((unsigned int )list_files != 2U) {
#line 2847
            return (1);
          }
        }
      }
    }
  }
#line 2849
  if (color_option == 2) {
#line 2850
    if (possibly_tty) {
      {
#line 2850
      tmp___38 = should_colorize();
      }
#line 2850
      if (tmp___38) {
        {
#line 2850
        tmp___39 = isatty(1);
        }
#line 2850
        if (tmp___39) {
#line 2850
          tmp___40 = 1;
        } else {
#line 2850
          tmp___40 = 0;
        }
      } else {
#line 2850
        tmp___40 = 0;
      }
    } else {
#line 2850
      tmp___40 = 0;
    }
#line 2850
    color_option = tmp___40;
  }
  {
#line 2851
  init_colorize();
  }
#line 2853
  if (color_option) {
    {
#line 2856
    tmp___41 = getenv("GREP_COLOR");
#line 2856
    userval = tmp___41;
    }
#line 2857
    if ((unsigned long )userval != (unsigned long )((void *)0)) {
#line 2857
      if ((int )*userval != 0) {
#line 2858
        context_match_color = (char const   *)userval;
#line 2858
        selected_match_color = context_match_color;
      }
    }
    {
#line 2861
    parse_grep_colors();
    }
  }
  {
#line 2864
  initialize_unibyte_mask();
  }
#line 2866
  if (matcher < 0) {
#line 2867
    matcher = 0;
  }
#line 2874
  if (matcher == 2) {
#line 2874
    if (! localeinfo.multibyte) {
#line 2874
      if (n_patterns == 1UL) {
#line 2874
        if (match_words) {
#line 2874
          tmp___42 = 1;
        } else {
#line 2874
          tmp___42 = 0;
        }
      } else {
#line 2874
        tmp___42 = 0;
      }
#line 2874
      tmp___46 = tmp___42;
    } else {
      {
#line 2874
      tmp___43 = contains_encoding_error((char const   *)keys, keycc);
      }
#line 2874
      if (tmp___43) {
#line 2874
        tmp___45 = 1;
      } else
#line 2874
      if (match_icase) {
        {
#line 2874
        tmp___44 = fgrep_icase_available((char const   *)keys, keycc);
        }
#line 2874
        if (tmp___44) {
#line 2874
          tmp___45 = 0;
        } else {
#line 2874
          tmp___45 = 1;
        }
      } else {
#line 2874
        tmp___45 = 0;
      }
#line 2874
      tmp___46 = tmp___45;
    }
#line 2874
    if (tmp___46) {
      {
#line 2880
      fgrep_to_grep_pattern(& keys, & keycc);
#line 2881
      matcher = 0;
      }
    } else {
#line 2874
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2885
  if (matcher == 0) {
#line 2885
    goto _L___0;
  } else
#line 2885
  if (matcher == 1) {
    _L___0: /* CIL Label */ 
#line 2885
    if (1UL < n_patterns) {
      {
#line 2887
      matcher = try_fgrep_pattern(matcher, keys, & keycc);
      }
    }
  }
  {
#line 2889
  execute = (size_t (*)(void * , char const   * , size_t  , size_t * , char const   * ))matchers[matcher].execute;
#line 2890
  compiled_pattern = (*(matchers[matcher].compile))(keys, keycc, (reg_syntax_t )matchers[matcher].syntax);
#line 2893
  eolbytes[0] = (char)0;
#line 2893
  eolbytes[1] = eolbyte;
#line 2893
  eolbytes[2] = (char)0;
#line 2895
  tmp___47 = (*execute)(compiled_pattern, (char const   *)(eolbytes + 1), (size_t )1,
                        & match_size, (char const   *)((void *)0));
#line 2895
  skip_empty_lines = (_Bool )((tmp___47 == 0UL) == (int )out_invert);
  }
#line 2899
  if (argc - optind > 1) {
#line 2899
    if (! no_filenames) {
#line 2900
      out_file = 1;
    } else {
#line 2899
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2899
  if (with_filenames) {
#line 2900
    out_file = 1;
  }
  {
#line 2909
  tmp___49 = sysconf(30);
#line 2909
  psize = tmp___49;
  }
#line 2913
  if (0L < psize) {
#line 2913
    if (! ((unsigned long )psize <= (0xffffffffffffffffUL - sizeof(uword )) / 2UL)) {
      {
#line 2914
      abort();
      }
    }
  } else {
    {
#line 2914
    abort();
    }
  }
#line 2915
  pagesize = (size_t )psize;
#line 2916
  if (32768UL % pagesize == 0UL) {
#line 2916
    tmp___50 = (size_t )32768;
  } else {
#line 2916
    tmp___50 = 32768UL + (pagesize - 32768UL % pagesize);
  }
  {
#line 2916
  bufalloc = (tmp___50 + pagesize) + sizeof(uword );
#line 2917
  tmp___51 = xmalloc(bufalloc);
#line 2917
  buffer = (char *)tmp___51;
  }
#line 2919
  if (fts_options & 2) {
#line 2919
    if ((unsigned int )devices == 0U) {
#line 2920
      devices = (enum __anonenum_devices_473526324 )1;
    }
  }
#line 2923
  if (optind < argc) {
#line 2925
    files = (char * const  *)(argv + optind);
  } else
#line 2927
  if ((unsigned int )directories == 3U) {
#line 2927
    if (prepended < last_recursive) {
#line 2930
      files = cwd_only;
#line 2931
      omit_dot_slash = (_Bool)1;
    } else {
#line 2936
      files = stdin_only;
    }
  } else {
#line 2936
    files = stdin_only;
  }
#line 2939
  status = (_Bool)1;
  {
#line 2940
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 2941
    tmp___52 = files;
#line 2941
    files ++;
#line 2941
    tmp___53 = grep_command_line_arg((char const   *)*tmp___52);
#line 2941
    status = (_Bool )((int )status & (int )tmp___53);
    }
#line 2940
    if (! ((unsigned long )*files != (unsigned long )((void *)0))) {
#line 2940
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2945
  if (errseen) {
#line 2945
    tmp___54 = 2;
  } else {
#line 2945
    tmp___54 = (int )status;
  }
#line 2945
  return (tmp___54);
}
}
#line 80 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 529 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 539
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 554
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__String ,
                          regoff_t __length , regoff_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 572
extern regoff_t re_match(struct re_pattern_buffer *__buffer , char const   *__String ,
                         regoff_t __length , regoff_t __start , struct re_registers *__regs ) ;
#line 141 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 31 "../lib/binary-io.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 73
#pragma GCC diagnostic pop
#line 54 "/home/khheo/project/benchmark/grep-3.0/src/system.h"
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 54
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 70
#pragma GCC diagnostic pop
#line 29 "../lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/grep-3.0/src/search.h"
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 37
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 84
#pragma GCC diagnostic pop
#line 50 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
#line 53
  exit(1);
  }
}
}
#line 59 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
void dfawarn(char const   *mesg ) 
{ 
  char *tmp ;

  {
  {
#line 62
  tmp = getenv("POSIXLY_CORRECT");
  }
#line 62
  if (! tmp) {
    {
#line 63
    dfaerror(mesg);
    }
  }
#line 64
  return;
}
}
#line 70 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static void kwsmusts(struct dfa_comp *dc ) 
{ 
  struct dfamust *dm ;
  struct dfamust *tmp ;
  ptrdiff_t old_len ;
  size_t tmp___0 ;
  ptrdiff_t new_len ;
  char *must ;
  void *tmp___1 ;
  char *mp ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dfamust((struct dfa  const  *)dc->dfa);
#line 73
  dm = tmp;
  }
#line 74
  if (! dm) {
#line 75
    return;
  }
  {
#line 76
  dc->kwset = kwsinit((_Bool)0);
  }
#line 77
  if (dm->exact) {
    {
#line 82
    (dc->kwset_exact_matches) ++;
#line 83
    tmp___0 = strlen((char const   *)dm->must);
#line 83
    old_len = (ptrdiff_t )tmp___0;
#line 84
    new_len = (old_len + (ptrdiff_t )dm->begline) + (ptrdiff_t )dm->endline;
#line 85
    tmp___1 = xmalloc((size_t )new_len);
#line 85
    must = (char *)tmp___1;
#line 86
    mp = must;
#line 87
    *mp = eolbyte;
#line 88
    mp += (int )dm->begline;
#line 89
    dc->begline = (_Bool )((int )dc->begline | (int )dm->begline);
#line 90
    memcpy((void */* __restrict  */)mp, (void const   */* __restrict  */)dm->must,
           (size_t )old_len);
    }
#line 91
    if (dm->endline) {
#line 92
      *(mp + old_len) = eolbyte;
    }
    {
#line 93
    kwsincr(dc->kwset, (char const   *)must, new_len);
#line 94
    free((void *)must);
    }
  } else {
    {
#line 100
    tmp___2 = strlen((char const   *)dm->must);
#line 100
    kwsincr(dc->kwset, (char const   *)dm->must, (ptrdiff_t )tmp___2);
    }
  }
  {
#line 102
  kwsprep(dc->kwset);
#line 103
  dfamustfree(dm);
  }
#line 104
  return;
}
}
#line 180 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   line_beg_no_bk[3]  = {      (char const   )'^',      (char const   )'(',      (char const   )'\000'};
#line 181 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   line_end_no_bk[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 182 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   word_beg_no_bk[19]  = 
#line 182
  {      (char const   )'(',      (char const   )'^',      (char const   )'|',      (char const   )'[', 
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'a', 
        (char const   )'l',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )':',      (char const   )']',      (char const   )'_',      (char const   )']', 
        (char const   )')',      (char const   )'(',      (char const   )'\000'};
#line 183 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   word_end_no_bk[19]  = 
#line 183
  {      (char const   )')',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'a',      (char const   )'l', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )':', 
        (char const   )']',      (char const   )'_',      (char const   )']',      (char const   )'|', 
        (char const   )'$',      (char const   )')',      (char const   )'\000'};
#line 184 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   line_beg_bk[4]  = {      (char const   )'^',      (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 185 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   line_end_bk[4]  = {      (char const   )'\\',      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 186 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   word_beg_bk[23]  = 
#line 186
  {      (char const   )'\\',      (char const   )'(',      (char const   )'^',      (char const   )'\\', 
        (char const   )'|',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'a',      (char const   )'l',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )':',      (char const   )']', 
        (char const   )'_',      (char const   )']',      (char const   )'\\',      (char const   )')', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 187 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
static char const   word_end_bk[23]  = 
#line 187
  {      (char const   )'\\',      (char const   )')',      (char const   )'\\',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'a',      (char const   )'l',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )':',      (char const   )']',      (char const   )'_', 
        (char const   )']',      (char const   )'\\',      (char const   )'|',      (char const   )'$', 
        (char const   )'\\',      (char const   )')',      (char const   )'\000'};
#line 106 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
void *GEAcompile(char *pattern , size_t size , reg_syntax_t syntax_bits ) 
{ 
  char *motif ;
  struct dfa_comp *dc ;
  void *tmp ;
  int dfaopts ;
  int tmp___0 ;
  char const   *p ;
  char const   *patlim ;
  _Bool compilation_failed ;
  size_t palloc ;
  size_t len ;
  char const   *sep ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct re_pattern_buffer *pat ;
  void *tmp___3 ;
  char const   *err ;
  char const   *tmp___4 ;
  size_t lineno ;
  char const   *pat_filename ;
  char const   *tmp___5 ;
  int bk ;
  char *n ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  size_t total ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 110
  tmp = xcalloc((size_t )1, sizeof(*dc));
#line 110
  dc = (struct dfa_comp *)tmp;
#line 112
  dc->dfa = dfaalloc();
  }
#line 114
  if (match_icase) {
#line 115
    syntax_bits |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 116
  re_set_syntax(syntax_bits);
  }
#line 117
  if (eolbyte) {
#line 117
    tmp___0 = 0;
  } else {
#line 117
    tmp___0 = 2;
  }
  {
#line 117
  dfaopts = tmp___0;
#line 118
  dfasyntax(dc->dfa, (struct localeinfo  const  *)(& localeinfo), syntax_bits, dfaopts);
#line 124
  p = (char const   *)pattern;
#line 125
  patlim = (char const   *)(pattern + size);
#line 126
  compilation_failed = (_Bool)0;
#line 127
  palloc = (size_t )0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp___1 = memchr((void const   *)p, '\n', (size_t )(patlim - p));
#line 132
    sep = (char const   *)tmp___1;
    }
#line 133
    if (sep) {
#line 135
      len = (size_t )(sep - p);
#line 136
      sep ++;
    } else {
#line 139
      len = (size_t )(patlim - p);
    }
#line 141
    if (palloc <= dc->pcount) {
      {
#line 142
      tmp___2 = x2nrealloc((void *)dc->patterns, & palloc, sizeof(*(dc->patterns)));
#line 142
      dc->patterns = (struct re_pattern_buffer *)tmp___2;
      }
    }
#line 143
    pat = dc->patterns + dc->pcount;
#line 144
    pat->buffer = (struct re_dfa_t *)((void *)0);
#line 145
    pat->allocated = (__re_long_size_t )0;
#line 148
    if (match_icase) {
#line 148
      pat->fastmap = (char *)((void *)0);
    } else {
      {
#line 148
      tmp___3 = xmalloc((size_t )256);
#line 148
      pat->fastmap = (char *)tmp___3;
      }
    }
    {
#line 150
    pat->translate = (unsigned char *)((void *)0);
#line 152
    tmp___4 = re_compile_pattern(p, len, pat);
#line 152
    err = tmp___4;
    }
#line 153
    if (err) {
      {
#line 158
      tmp___5 = (char const   *)pattern_file_name(dc->pcount + 1UL, & lineno);
#line 158
      pat_filename = tmp___5;
      }
#line 160
      if ((int const   )*pat_filename == 0) {
        {
#line 161
        error(0, 0, "%s", err);
        }
      } else {
        {
#line 163
        error(0, 0, "%s:%zu: %s", pat_filename, lineno, err);
        }
      }
#line 164
      compilation_failed = (_Bool)1;
    }
#line 166
    (dc->pcount) ++;
#line 167
    p = sep;
#line 129
    if (! p) {
#line 129
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (compilation_failed) {
    {
#line 172
    exit(2);
    }
  }
#line 178
  if (match_words) {
#line 178
    goto _L;
  } else
#line 178
  if (match_lines) {
    _L: /* CIL Label */ 
    {
#line 188
    bk = ! (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 189
    tmp___6 = xmalloc(((sizeof(word_beg_bk) - 1UL) + size) + sizeof(word_end_bk));
#line 189
    n = (char *)tmp___6;
    }
#line 191
    if (match_lines) {
#line 191
      if (bk) {
#line 191
        tmp___7 = line_beg_bk;
      } else {
#line 191
        tmp___7 = line_beg_no_bk;
      }
#line 191
      tmp___9 = tmp___7;
    } else {
#line 191
      if (bk) {
#line 191
        tmp___8 = word_beg_bk;
      } else {
#line 191
        tmp___8 = word_beg_no_bk;
      }
#line 191
      tmp___9 = tmp___8;
    }
    {
#line 191
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___9);
#line 193
    tmp___10 = strlen((char const   *)n);
#line 193
    total = tmp___10;
#line 194
    memcpy((void */* __restrict  */)(n + total), (void const   */* __restrict  */)pattern,
           size);
#line 195
    total += size;
    }
#line 196
    if (match_lines) {
#line 196
      if (bk) {
#line 196
        tmp___11 = line_end_bk;
      } else {
#line 196
        tmp___11 = line_end_no_bk;
      }
#line 196
      tmp___13 = tmp___11;
    } else {
#line 196
      if (bk) {
#line 196
        tmp___12 = word_end_bk;
      } else {
#line 196
        tmp___12 = word_end_no_bk;
      }
#line 196
      tmp___13 = tmp___12;
    }
    {
#line 196
    strcpy((char */* __restrict  */)(n + total), (char const   */* __restrict  */)tmp___13);
#line 198
    tmp___14 = strlen((char const   *)(n + total));
#line 198
    total += tmp___14;
#line 199
    motif = n;
#line 199
    pattern = motif;
#line 200
    size = total;
    }
  } else {
#line 203
    motif = (char *)((void *)0);
  }
  {
#line 205
  dfacomp((char const   *)pattern, size, dc->dfa, (_Bool)1);
#line 206
  kwsmusts(dc);
#line 208
  free((void *)motif);
  }
#line 210
  return ((void *)dc);
}
}
#line 213 "/home/khheo/project/benchmark/grep-3.0/src/dfasearch.c"
size_t EGexecute(void *vdc , char const   *buf , size_t size , size_t *match_size ,
                 char const   *start_ptr ) 
{ 
  char const   *buflim___0 ;
  char const   *beg ;
  char const   *end ;
  char const   *ptr ;
  char const   *match ;
  char const   *best_match ;
  char const   *mb_start ;
  char eol ;
  regoff_t start ;
  size_t len ;
  size_t best_len ;
  struct kwsmatch kwsm ;
  size_t i ;
  struct dfa_comp *dc ;
  struct dfa *superset ;
  struct dfa *tmp ;
  _Bool dfafast ;
  _Bool tmp___0 ;
  char const   *next_beg ;
  char const   *dfa_beg ;
  size_t count ;
  _Bool exact_kwset_match ;
  _Bool backref ;
  char const   *prev_beg ;
  ptrdiff_t offset ;
  ptrdiff_t tmp___1 ;
  void *tmp___2 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  ptrdiff_t tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  regoff_t shorter_len ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t off ;

  {
  {
#line 218
  eol = eolbyte;
#line 223
  dc = (struct dfa_comp *)vdc;
#line 224
  tmp = dfasuperset((struct dfa  const  *)dc->dfa);
#line 224
  superset = tmp;
#line 225
  tmp___0 = dfaisfast((struct dfa  const  *)dc->dfa);
#line 225
  dfafast = tmp___0;
#line 227
  mb_start = buf;
#line 228
  buflim___0 = buf + size;
#line 230
  end = buf;
#line 230
  beg = end;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
#line 230
      goto while_break;
    }
#line 232
    end = buflim___0;
#line 234
    if (! start_ptr) {
#line 236
      dfa_beg = beg;
#line 237
      count = (size_t )0;
#line 238
      exact_kwset_match = (_Bool)0;
#line 239
      backref = (_Bool)0;
#line 242
      if (dc->kwset) {
        {
#line 247
        tmp___1 = kwsexec(dc->kwset, beg - (int )dc->begline, (buflim___0 - beg) + (long )dc->begline,
                          & kwsm, (_Bool)1);
#line 247
        offset = tmp___1;
        }
#line 250
        if (offset < 0L) {
#line 251
          goto failure;
        }
        {
#line 252
        match = beg + offset;
#line 253
        prev_beg = beg;
#line 256
        tmp___2 = memrchr((void const   *)buf, (int )eol, (size_t )(match - buf));
#line 256
        beg = (char const   *)tmp___2;
        }
#line 257
        if (beg) {
#line 257
          beg ++;
        } else {
#line 257
          beg = buf;
        }
#line 258
        dfa_beg = beg;
#line 266
        exact_kwset_match = (_Bool )(kwsm.index < dc->kwset_exact_matches);
#line 267
        if (exact_kwset_match) {
#line 267
          end = match;
        } else
#line 267
        if (! dfafast) {
#line 267
          end = match;
        } else {
#line 267
          if (16L > match - beg) {
#line 267
            tmp___8 = 16L;
          } else {
#line 267
            tmp___8 = match - beg;
          }
#line 267
          if (tmp___8 < (match - prev_beg) >> 2) {
#line 267
            end = match;
          } else {
#line 267
            if (16L > match - beg) {
#line 267
              tmp___7 = 16L;
            } else {
#line 267
              tmp___7 = match - beg;
            }
#line 267
            if (tmp___7 < (buflim___0 - prev_beg) >> 2) {
#line 267
              if (16L > match - beg) {
#line 267
                tmp___5 = 16L;
              } else {
#line 267
                tmp___5 = match - beg;
              }
#line 267
              tmp___6 = prev_beg + 4L * tmp___5;
            } else {
#line 267
              tmp___6 = buflim___0;
            }
#line 267
            end = tmp___6;
          }
        }
        {
#line 273
        tmp___9 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
#line 273
        end = (char const   *)tmp___9;
        }
#line 274
        if (end) {
#line 274
          end ++;
        } else {
#line 274
          end = buflim___0;
        }
#line 276
        if (exact_kwset_match) {
#line 278
          if (! localeinfo.multibyte | (int )localeinfo.using_utf8) {
#line 279
            goto success;
          }
#line 280
          if ((unsigned long )mb_start < (unsigned long )beg) {
#line 281
            mb_start = beg;
          }
          {
#line 282
          tmp___10 = mb_goback(& mb_start, match, buflim___0);
          }
#line 282
          if (tmp___10 == 0L) {
#line 283
            goto success;
          }
#line 287
          dfa_beg = mb_start;
        }
      }
#line 292
      if (superset) {
#line 292
        if (! exact_kwset_match) {
          {
#line 297
          tmp___11 = dfaexec(superset, dfa_beg, (char *)end, (_Bool)0, & count, (_Bool *)((void *)0));
#line 297
          next_beg = (char const   *)tmp___11;
          }
#line 299
          if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 300
            goto __Cont;
          } else
#line 299
          if ((unsigned long )next_beg == (unsigned long )end) {
#line 300
            goto __Cont;
          }
#line 303
          if (count != 0UL) {
            {
#line 305
            tmp___12 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 305
            beg = (char const   *)tmp___12;
#line 306
            beg ++;
#line 307
            dfa_beg = beg;
            }
          }
          {
#line 309
          tmp___13 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 309
          end = (char const   *)tmp___13;
          }
#line 310
          if (end) {
#line 310
            end ++;
          } else {
#line 310
            end = buflim___0;
          }
#line 312
          count = (size_t )0;
        }
      }
      {
#line 316
      tmp___14 = dfaexec(dc->dfa, dfa_beg, (char *)end, (_Bool)0, & count, & backref);
#line 316
      next_beg = (char const   *)tmp___14;
      }
#line 321
      if ((unsigned long )next_beg == (unsigned long )((void *)0)) {
#line 322
        goto __Cont;
      } else
#line 321
      if ((unsigned long )next_beg == (unsigned long )end) {
#line 322
        goto __Cont;
      }
#line 325
      if (count != 0UL) {
        {
#line 327
        tmp___15 = memrchr((void const   *)buf, (int )eol, (size_t )(next_beg - buf));
#line 327
        beg = (char const   *)tmp___15;
#line 328
        beg ++;
        }
      }
      {
#line 330
      tmp___16 = memchr((void const   *)next_beg, (int )eol, (size_t )(buflim___0 - next_beg));
#line 330
      end = (char const   *)tmp___16;
      }
#line 331
      if (end) {
#line 331
        end ++;
      } else {
#line 331
        end = buflim___0;
      }
#line 334
      if (! backref) {
#line 335
        goto success;
      }
#line 336
      ptr = beg;
    } else {
#line 342
      ptr = start_ptr;
    }
#line 347
    if ((long )(((1 << (sizeof(regoff_t ) * 8UL - 2UL)) - 1) * 2 + 1) < (end - beg) - 1L) {
      {
#line 348
      xalloc_die();
      }
    }
#line 351
    best_match = end;
#line 352
    best_len = (size_t )0;
#line 353
    i = (size_t )0;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! (i < dc->pcount)) {
#line 353
        goto while_break___0;
      }
      {
#line 355
      (dc->patterns + i)->not_eol = 0U;
#line 356
      (dc->patterns + i)->newline_anchor = (unsigned int )((int )eolbyte == 10);
#line 357
      start = re_search(dc->patterns + i, beg, (regoff_t )((end - beg) - 1L), (regoff_t )(ptr - beg),
                        (regoff_t )((end - ptr) - 1L), & dc->regs);
      }
#line 359
      if (start < -1) {
        {
#line 360
        xalloc_die();
        }
      } else
#line 361
      if (0 <= start) {
#line 363
        len = (size_t )(*(dc->regs.end + 0) - start);
#line 364
        match = beg + start;
#line 365
        if ((unsigned long )match > (unsigned long )best_match) {
#line 366
          goto __Cont___0;
        }
#line 367
        if (start_ptr) {
#line 367
          if (! match_words) {
#line 368
            goto assess_pattern_match;
          }
        }
#line 369
        if (! match_lines) {
#line 369
          if (! match_words) {
#line 372
            match = ptr;
#line 373
            len = (size_t )(end - ptr);
#line 374
            goto assess_pattern_match;
          } else {
#line 369
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 369
        if (match_lines) {
#line 369
          if (len == (size_t )((end - ptr) - 1L)) {
#line 372
            match = ptr;
#line 373
            len = (size_t )(end - ptr);
#line 374
            goto assess_pattern_match;
          }
        }
#line 383
        if (! match_lines) {
#line 383
          if (match_words) {
            {
#line 384
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 384
              if (! ((unsigned long )match <= (unsigned long )best_match)) {
#line 384
                goto while_break___1;
              }
              {
#line 386
              shorter_len = 0;
#line 387
              tmp___17 = wordchar_next(match + len, end - 1);
              }
#line 387
              if (! tmp___17) {
                {
#line 387
                tmp___18 = wordchar_prev(beg, match, end - 1);
                }
#line 387
                if (! tmp___18) {
#line 389
                  goto assess_pattern_match;
                }
              }
#line 390
              if (len > 0UL) {
                {
#line 393
                len --;
#line 394
                (dc->patterns + i)->not_eol = 1U;
#line 395
                shorter_len = re_match(dc->patterns + i, beg, (regoff_t )((match + len) - ptr),
                                       (regoff_t )(match - beg), & dc->regs);
                }
#line 398
                if (shorter_len < -1) {
                  {
#line 399
                  xalloc_die();
                  }
                }
              }
#line 401
              if (0 < shorter_len) {
#line 402
                len = (size_t )shorter_len;
              } else {
#line 406
                if ((unsigned long )match == (unsigned long )(end - 1)) {
#line 407
                  goto while_break___1;
                }
                {
#line 408
                match ++;
#line 409
                (dc->patterns + i)->not_eol = 0U;
#line 410
                start = re_search(dc->patterns + i, beg, (regoff_t )((end - beg) - 1L),
                                  (regoff_t )(match - beg), (regoff_t )((end - match) - 1L),
                                  & dc->regs);
                }
#line 413
                if (start < 0) {
#line 415
                  if (start < -1) {
                    {
#line 416
                    xalloc_die();
                    }
                  }
#line 417
                  goto while_break___1;
                }
#line 419
                len = (size_t )(*(dc->regs.end + 0) - start);
#line 420
                match = beg + start;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 423
        goto __Cont___0;
        assess_pattern_match: 
#line 425
        if (! start_ptr) {
#line 429
          goto success;
        }
#line 431
        if ((unsigned long )match < (unsigned long )best_match) {
#line 434
          best_match = match;
#line 435
          best_len = len;
        } else
#line 431
        if ((unsigned long )match == (unsigned long )best_match) {
#line 431
          if (len > best_len) {
#line 434
            best_match = match;
#line 435
            best_len = len;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 353
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    if ((unsigned long )best_match < (unsigned long )end) {
#line 443
      beg = best_match;
#line 444
      len = best_len;
#line 445
      goto success_in_len;
    }
    __Cont: /* CIL Label */ 
#line 230
    beg = end;
  }
  while_break: /* CIL Label */ ;
  }
  failure: 
#line 450
  return ((size_t )-1);
  success: 
#line 453
  len = (size_t )(end - beg);
  success_in_len: 
#line 455
  off = (size_t )(beg - buf);
#line 456
  *match_size = len;
#line 457
  return (off);
}
}
