/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 29 "../../include/bssignal.h"
struct signal ;
#line 29 "../../include/bssignal.h"
typedef struct signal signal_t;
#line 28 "../../include/bsbit.h"
struct bsbit ;
#line 28 "../../include/bsbit.h"
typedef struct bsbit bsbit_t;
#line 40 "../../include/bsbit.h"
struct bsbit {
   int bit ;
   char *name ;
   int type ;
   signal_t *signal ;
   int safe ;
   int control ;
   int control_value ;
   int control_state ;
};
#line 33 "../../include/bssignal.h"
struct signal {
   char *name ;
   char *pin ;
   signal_t *next ;
   bsbit_t *input ;
   bsbit_t *output ;
};
#line 41
struct salias ;
#line 41 "../../include/bssignal.h"
typedef struct salias salias_t;
#line 43 "../../include/bssignal.h"
struct salias {
   char *name ;
   salias_t *next ;
   signal_t *signal ;
};
#line 29 "../../include/register.h"
struct tap_register {
   char *data ;
   int len ;
   char *string ;
};
#line 29 "../../include/register.h"
typedef struct tap_register tap_register;
#line 32 "../../include/data_register.h"
struct data_register ;
#line 32 "../../include/data_register.h"
typedef struct data_register data_register;
#line 34 "../../include/data_register.h"
struct data_register {
   char name[33] ;
   tap_register *in ;
   tap_register *out ;
   data_register *next ;
};
#line 33 "../../include/instruction.h"
struct instruction ;
#line 33 "../../include/instruction.h"
typedef struct instruction instruction;
#line 35 "../../include/instruction.h"
struct instruction {
   char name[21] ;
   tap_register *value ;
   data_register *data_register ;
   instruction *next ;
};
#line 39 "../../include/part.h"
struct part ;
#line 39 "../../include/part.h"
typedef struct part part_t;
#line 41 "../../include/part.h"
struct part {
   tap_register *id ;
   char *alias ;
   char manufacturer[26] ;
   char part[21] ;
   char stepping[9] ;
   signal_t *signals ;
   salias_t *saliases ;
   int instruction_length ;
   instruction *instructions ;
   instruction *active_instruction ;
   data_register *data_registers ;
   int boundary_length ;
   bsbit_t **bsbits ;
};
#line 46 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct instr_elem {
   struct instr_elem *next ;
   char *instr ;
   char *opcode ;
};
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct ainfo_elem {
   struct ainfo_elem *next ;
   char *reg ;
   int reg_len ;
   struct instr_elem *instr_list ;
};
#line 70 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct access_data {
   struct ainfo_elem *ainfo_list ;
   char *reg ;
   int reg_len ;
   struct instr_elem *instr_list ;
};
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct cell_info {
   int bit_num ;
   char *port_name ;
   int cell_function ;
   char *basic_safe_value ;
   int ctrl_bit_num ;
   int disable_safe_value ;
};
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct string_elem {
   struct string_elem *next ;
   char *string ;
};
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct port_desc {
   struct string_elem *names_list ;
   int is_vector ;
   int low_idx ;
   int high_idx ;
};
#line 113 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct jtag_ctrl {
   int mode ;
   int debug ;
   char *idcode ;
   part_t *part ;
   struct port_desc port_desc ;
   struct cell_info cell_info ;
   struct instr_elem *instr_list ;
   struct access_data access_data ;
};
#line 126 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct parser_priv {
   char Package_File_Name[100] ;
   int Reading_Package ;
   char *buffer_for_switch ;
   size_t len_buffer_for_switch ;
   void *scanner ;
   struct jtag_ctrl jtag_ctrl ;
};
#line 134 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
typedef struct parser_priv parser_priv_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 68 "../../include/part.h"
struct parts ;
#line 68 "../../include/part.h"
typedef struct parts parts_t;
#line 70 "../../include/part.h"
struct parts {
   int len ;
   part_t **parts ;
};
#line 30 "../../include/chain.h"
struct chain_t ;
#line 30 "../../include/chain.h"
typedef struct chain_t chain_t;
#line 31 "../../include/cable.h"
struct cable_t ;
#line 31 "../../include/cable.h"
typedef struct cable_t cable_t;
#line 31 "../../include/parport.h"
struct parport_t ;
#line 31 "../../include/parport.h"
typedef struct parport_t parport_t;
#line 35 "../../include/parport.h"
struct __anonstruct_parport_driver_t_422815707 {
   char const   *type ;
   parport_t *(*connect)(char const   ** , int  ) ;
   void (*parport_free)(parport_t * ) ;
   int (*open)(parport_t * ) ;
   int (*close)(parport_t * ) ;
   int (*set_data)(parport_t * , uint8_t  ) ;
   int (*get_data)(parport_t * ) ;
   int (*get_status)(parport_t * ) ;
   int (*set_control)(parport_t * , uint8_t  ) ;
};
#line 35 "../../include/parport.h"
typedef struct __anonstruct_parport_driver_t_422815707 parport_driver_t;
#line 47 "../../include/parport.h"
struct parport_t {
   parport_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 36 "../../include/cable.h"
struct cable_driver_t ;
#line 36 "../../include/cable.h"
typedef struct cable_driver_t cable_driver_t;
#line 38
enum __anonenum_cable_flush_amount_t_729591679 {
    OPTIONALLY = 0,
    CONSERVATIVELY = 1,
    TO_OUTPUT = 2,
    COMPLETELY = 3
} ;
#line 38 "../../include/cable.h"
typedef enum __anonenum_cable_flush_amount_t_729591679 cable_flush_amount_t;
#line 47 "../../include/cable.h"
struct cable_driver_t {
   char const   *name ;
   char const   *description ;
   int (*connect)(char **params , cable_t *cable ) ;
   void (*disconnect)(cable_t *cable ) ;
   void (*cable_free)(cable_t *cable ) ;
   int (*init)(cable_t * ) ;
   void (*done)(cable_t * ) ;
   void (*set_frequency)(cable_t * , uint32_t freq ) ;
   void (*clock)(cable_t * , int  , int  , int  ) ;
   int (*get_tdo)(cable_t * ) ;
   int (*transfer)(cable_t * , int  , char * , char * ) ;
   int (*set_trst)(cable_t * , int  ) ;
   int (*get_trst)(cable_t * ) ;
   void (*flush)(cable_t * , cable_flush_amount_t  ) ;
   void (*help)(char const   * ) ;
};
#line 65
struct cable_queue_t ;
#line 65 "../../include/cable.h"
typedef struct cable_queue_t cable_queue_t;
#line 67
enum __anonenum_action_990402164 {
    CABLE_CLOCK = 0,
    CABLE_GET_TDO = 1,
    CABLE_TRANSFER = 2,
    CABLE_SET_TRST = 3,
    CABLE_GET_TRST = 4
} ;
#line 67 "../../include/cable.h"
struct __anonstruct_clock_582275743 {
   int tms ;
   int tdi ;
   int n ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_value_582275744 {
   int tdo ;
   int trst ;
   int val ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_transfer_255056401 {
   int len ;
   char *in ;
   char *out ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_xferred_478576807 {
   int len ;
   int res ;
   char *out ;
};
#line 67 "../../include/cable.h"
union __anonunion_arg_575623085 {
   struct __anonstruct_clock_582275743 clock ;
   struct __anonstruct_value_582275744 value ;
   struct __anonstruct_transfer_255056401 transfer ;
   struct __anonstruct_xferred_478576807 xferred ;
};
#line 67 "../../include/cable.h"
struct cable_queue_t {
   enum __anonenum_action_990402164 action ;
   union __anonunion_arg_575623085 arg ;
};
#line 99
struct cable_queue_info_t ;
#line 99 "../../include/cable.h"
typedef struct cable_queue_info_t cable_queue_info_t;
#line 101 "../../include/cable.h"
struct cable_queue_info_t {
   cable_queue_t *data ;
   int max_items ;
   int num_items ;
   int next_item ;
   int next_free ;
};
#line 109 "../../include/cable.h"
struct cable_t {
   cable_driver_t *driver ;
   parport_t *port ;
   void *params ;
   chain_t *chain ;
   cable_queue_info_t todo ;
   cable_queue_info_t done ;
   uint32_t delay ;
   uint32_t frequency ;
};
#line 38 "../../include/chain.h"
struct chain_t {
   int state ;
   parts_t *parts ;
   int active_part ;
   cable_t *cable ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 52 "bsdl_flex.c"
typedef short flex_int16_t;
#line 53 "bsdl_flex.c"
typedef int flex_int32_t;
#line 123 "bsdl_flex.c"
typedef void *yyscan_t;
#line 171
struct yy_buffer_state ;
#line 171 "bsdl_flex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 203 "bsdl_flex.c"
typedef unsigned int yy_size_t;
#line 208 "bsdl_flex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 334 "bsdl_flex.c"
typedef unsigned char YY_CHAR;
#line 336 "bsdl_flex.c"
typedef int yy_state_type;
#line 284 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_bison.h"
union YYSTYPE {
   int integer ;
   char *str ;
};
#line 284 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_bison.h"
typedef union YYSTYPE YYSTYPE;
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
struct scan_extra {
   int Compile_Errors ;
   int Base ;
};
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
typedef struct scan_extra scan_extra_t;
#line 1084 "bsdl_flex.c"
struct yyguts_t {
   scan_extra_t *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   yy_state_type *yy_state_buf ;
   yy_state_type *yy_state_ptr ;
   char *yy_full_match ;
   int yy_lp ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE *yylval_r ;
};
#line 400 "bsdl_bison.c"
typedef unsigned char yytype_uint8;
#line 415 "bsdl_bison.c"
typedef unsigned short yytype_uint16;
#line 421 "bsdl_bison.c"
typedef short yytype_int16;
#line 552 "bsdl_bison.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_514388770 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_490711015 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_514388770 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_279681333 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_490711015 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_815457742 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_279681333 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_815457742 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
enum generic_irdr_coding {
    generic_ir = 0,
    generic_dr = 1
} ;
#line 46 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
struct ths_params {
   double number ;
   char *tdi ;
   char *tdo ;
   char *mask ;
   char *smask ;
};
#line 54 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
struct path_states {
   int states[64] ;
   int num_states ;
};
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
struct runtest {
   int run_state ;
   uint32_t run_count ;
   int run_clk ;
   double min_time ;
   double max_time ;
   int end_state ;
};
#line 68
struct YYLTYPE ;
#line 187 "svf_bison.h"
struct YYLTYPE {
   int first_line ;
   int first_column ;
   int last_line ;
   int last_column ;
};
#line 187 "svf_bison.h"
typedef struct YYLTYPE YYLTYPE;
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
struct sxr {
   struct ths_params params ;
   int no_tdi ;
   int no_tdo ;
};
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
struct tdval {
   int token ;
   double dvalue ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
struct tcval {
   int token ;
   char *cvalue ;
   struct tcval *next ;
};
#line 166 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf_bison.h"
union YYSTYPE___0 {
   int token ;
   double dvalue ;
   char *cvalue ;
   int ivalue ;
   struct tdval tdval ;
   struct tcval *tcval ;
};
#line 166 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf_bison.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 220 "svf_flex.l"
struct rwtable {
   char *rw_name ;
   int rw_yylex ;
};
#line 41 "svf_bison.y"
struct svf_parser_params {
   struct ths_params ths_params ;
   struct path_states path_states ;
   struct runtest runtest ;
};
#line 295 "svf_bison.c"
typedef signed char yytype_int8;
#line 441 "svf_bison.c"
union yyalloc___0 {
   yytype_int16 yyss ;
   YYSTYPE___0 yyvs ;
   YYLTYPE yyls ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 40 "../../include/bus_driver.h"
struct __anonstruct_bus_area_t_36066931 {
   char const   *description ;
   uint32_t start ;
   uint64_t length ;
   unsigned int width ;
};
#line 40 "../../include/bus_driver.h"
typedef struct __anonstruct_bus_area_t_36066931 bus_area_t;
#line 47
struct bus ;
#line 47 "../../include/bus_driver.h"
typedef struct bus bus_t;
#line 49 "../../include/bus_driver.h"
struct bus_driver {
   char const   *name ;
   char const   *description ;
   bus_t *(*new_bus)(char **cmd_params ) ;
   void (*free_bus)(bus_t *bus ) ;
   void (*printinfo)(bus_t *bus ) ;
   void (*prepare)(bus_t *bus ) ;
   int (*area)(bus_t *bus , uint32_t adr , bus_area_t *area ) ;
   void (*read_start)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_next)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_end)(bus_t *bus ) ;
   uint32_t (*read)(bus_t *bus , uint32_t adr ) ;
   void (*write)(bus_t *bus , uint32_t adr , uint32_t data ) ;
   int (*init)(bus_t *bus ) ;
};
#line 49 "../../include/bus_driver.h"
typedef struct bus_driver bus_driver_t;
#line 65 "../../include/bus_driver.h"
struct bus {
   void *params ;
   bus_driver_t const   *driver ;
};
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
typedef int ctype_t;
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
struct __anonstruct_component_t_641410113 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[25] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *nbyte ;
   signal_t *sts ;
   signal_t *nrp ;
   signal_t *si ;
   signal_t *so ;
   signal_t *sck ;
};
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
typedef struct __anonstruct_component_t_641410113 component_t;
#line 119 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
struct __anonstruct_bus_params_t_385495642 {
   chain_t *chain ;
   part_t *part ;
   component_t flash ;
   component_t ram0 ;
   component_t ram1 ;
   component_t eeprom ;
   component_t eeprom_status ;
};
#line 119 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
typedef struct __anonstruct_bus_params_t_385495642 bus_params_t;
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
struct __anonstruct_bus_params_t_940822640 {
   chain_t *chain ;
   part_t *part ;
   signal_t *oe ;
   signal_t *swe ;
   signal_t *romce[4] ;
   signal_t *sdcs[4] ;
   signal_t *addr[20] ;
   signal_t *data[16] ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
typedef struct __anonstruct_bus_params_t_940822640 bus_params_t___0;
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
struct __anonstruct_bus_params_t_904733789 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ad[20] ;
   signal_t *dq[16] ;
   signal_t *nsdce ;
   signal_t *sdclk ;
   signal_t *noe ;
   signal_t *nsrce ;
   signal_t *nflce ;
   signal_t *nflbyte ;
   signal_t *nflby ;
   signal_t *nwe ;
   signal_t *lcde ;
   signal_t *lcdrs ;
   signal_t *lcdrw ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
typedef struct __anonstruct_bus_params_t_904733789 bus_params_t___1;
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
struct __anonstruct_bus_params_t_496203297 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ma[19] ;
   signal_t *md[8] ;
   signal_t *bms ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
typedef struct __anonstruct_bus_params_t_496203297 bus_params_t___2;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
struct __anonstruct_bus_params_t_68471003 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[8] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *bs ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
typedef struct __anonstruct_bus_params_t_68471003 bus_params_t___3;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
struct __anonstruct_bus_params_t_562361935 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[64] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *rdwr2 ;
   signal_t *rd2 ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
typedef struct __anonstruct_bus_params_t_562361935 bus_params_t___4;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
struct __anonstruct_bus_params_t_562361935___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *md3 ;
   signal_t *md4 ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
typedef struct __anonstruct_bus_params_t_562361935___0 bus_params_t___5;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
struct __anonstruct_bus_params_t_940822640___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *ncs[6] ;
   signal_t *rd_nwr ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
typedef struct __anonstruct_bus_params_t_940822640___0 bus_params_t___6;
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
struct __anonstruct_bus_params_t_587095632 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[22] ;
   signal_t *d[32] ;
   signal_t *nrcs[6] ;
   signal_t *necs[4] ;
   signal_t *nsdcs[4] ;
   signal_t *nwbe[4] ;
   signal_t *noe ;
   int dbuswidth ;
};
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
typedef struct __anonstruct_bus_params_t_587095632 bus_params_t___7;
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0_mc.h"
struct MC_registers {
   uint32_t mdcnfg ;
   uint32_t mdrefr ;
   uint32_t msc0 ;
   uint32_t msc1 ;
   uint32_t msc2 ;
   uint32_t mecr ;
   uint32_t __reserved1 ;
   uint32_t sxcnfg ;
   uint32_t __reserved2 ;
   uint32_t sxmrs ;
   uint32_t mcmem0 ;
   uint32_t mcmem1 ;
   uint32_t mcatt0 ;
   uint32_t mcatt1 ;
   uint32_t mcio0 ;
   uint32_t mcio1 ;
   uint32_t mdmrs ;
   uint32_t boot_def ;
   uint32_t __reserved3[4] ;
   uint32_t mdmrslp ;
   uint32_t __reserved4[2] ;
   uint32_t sa1111cr ;
};
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0_mc.h"
typedef struct MC_registers  volatile  MC_registers_t;
#line 60 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
struct __anonstruct_ncs_map_entry_788335240 {
   char *sig_name ;
   int enabled ;
   int bus_width ;
   char label_buf[81] ;
};
#line 60 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
typedef struct __anonstruct_ncs_map_entry_788335240 ncs_map_entry;
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
struct __anonstruct_bus_params_t_536293706 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ma[26] ;
   signal_t *md[32] ;
   signal_t *ncs[6] ;
   signal_t *dqm[4] ;
   signal_t *rdnwr ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *nsdcas ;
   MC_registers_t MC_registers ;
   int inited ;
   int proc ;
};
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
typedef struct __anonstruct_bus_params_t_536293706 bus_params_t___8;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
struct __anonstruct_bus_params_t_971962665 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[32] ;
   signal_t *d[32] ;
   signal_t *cs ;
   signal_t *we ;
   signal_t *oe ;
   int alsbi ;
   int amsbi ;
   int ai ;
   int aw ;
   int dlsbi ;
   int dmsbi ;
   int di ;
   int dw ;
   int csa ;
   int wea ;
   int oea ;
   int ashift ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
typedef struct __anonstruct_bus_params_t_971962665 bus_params_t___9;
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
struct __anonstruct_bus_params_t_594364645 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[32] ;
   signal_t *d[8] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
typedef struct __anonstruct_bus_params_t_594364645 bus_params_t___10;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
struct __anonstruct_bus_params_t_594364645___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[32] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
typedef struct __anonstruct_bus_params_t_594364645___0 bus_params_t___11;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
struct __anonstruct_bus_params_t_413197238 {
   chain_t *chain ;
   part_t *part ;
   int boot_nfoe ;
   int boot_sdma1 ;
   uint32_t last_adr ;
   signal_t *ar[23] ;
   signal_t *nrcs0 ;
   signal_t *nwe ;
   signal_t *nfoe ;
   signal_t *d[8] ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
typedef struct __anonstruct_bus_params_t_413197238 bus_params_t___12;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
struct __anonstruct_bus_params_t_496203297___0 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ad[24] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *d[8] ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
typedef struct __anonstruct_bus_params_t_496203297___0 bus_params_t___13;
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
struct __anonstruct_bus_params_t_940822640___1 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[24] ;
   signal_t *d[32] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *width[2] ;
};
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
typedef struct __anonstruct_bus_params_t_940822640___1 bus_params_t___14;
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
struct __anonstruct_component_t_604853148 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[19] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *ncs2 ;
   signal_t *nrdy ;
};
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
typedef struct __anonstruct_component_t_604853148 component_t___0;
#line 100 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
struct __anonstruct_bus_params_t_261477008 {
   chain_t *chain ;
   part_t *part ;
   component_t___0 rama ;
   component_t___0 ramb ;
   component_t___0 flash ;
   signal_t *ser_txd ;
   signal_t *ser_nrts ;
   signal_t *ser_rxd ;
   signal_t *ser_ncts ;
};
#line 100 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
typedef struct __anonstruct_bus_params_t_261477008 bus_params_t___15;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
struct __anonstruct_bus_params_t_594364645___1 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ex_cs[8] ;
   signal_t *ex_addr[24] ;
   signal_t *ex_data[16] ;
   signal_t *ex_wr ;
   signal_t *ex_rd ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
typedef struct __anonstruct_bus_params_t_594364645___1 bus_params_t___16;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
struct __anonstruct_bus_params_t_594364645___2 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[25] ;
   signal_t *d[32] ;
   signal_t *nRCS[4] ;
   signal_t *nRWE[4] ;
   signal_t *nROE ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
typedef struct __anonstruct_bus_params_t_594364645___2 bus_params_t___17;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
struct __anonstruct_bus_params_t_18421891 {
   chain_t *chain ;
   part_t *part ;
   int initialized ;
   uint32_t impcode ;
   uint16_t adr_hi ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
typedef struct __anonstruct_bus_params_t_18421891 bus_params_t___18;
#line 34 "../../include/bus.h"
struct __anonstruct_buses_t_1042349786 {
   int len ;
   bus_t **buses ;
};
#line 34 "../../include/bus.h"
typedef struct __anonstruct_buses_t_1042349786 buses_t;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
struct __anonstruct_bus_params_t_107014962 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *abe[4] ;
   signal_t *data[32] ;
   signal_t *awe ;
   signal_t *aoe ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms[4] ;
   signal_t *swe ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
typedef struct __anonstruct_bus_params_t_107014962 bus_params_t___19;
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
struct __anonstruct_bus_params_t_562361935___1 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *data[16] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *aoe ;
   signal_t *dcs0 ;
   signal_t *nce ;
};
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
typedef struct __anonstruct_bus_params_t_562361935___1 bus_params_t___20;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
struct __anonstruct_bus_params_t_107014962___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ams[4] ;
   signal_t *addr[19] ;
   signal_t *data[16] ;
   signal_t *abe[2] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms ;
   signal_t *swe ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
typedef struct __anonstruct_bus_params_t_107014962___0 bus_params_t___21;
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
struct __anonstruct_bus_params_t_594364645___3 {
   chain_t *chain ;
   part_t *part ;
   signal_t *io_ad[32] ;
   signal_t *io_cs_l[7] ;
   signal_t *io_rw ;
   signal_t *io_wr_l ;
   signal_t *io_oe_l ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
typedef struct __anonstruct_bus_params_t_594364645___3 bus_params_t___22;
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
struct __anonstruct_bus_params_t_594364645___4 {
   chain_t *chain ;
   part_t *part ;
   signal_t *rad[32] ;
   signal_t *nrcs[4] ;
   signal_t *nrwe ;
   signal_t *nroe ;
   signal_t *rd[32] ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
typedef struct __anonstruct_bus_params_t_594364645___4 bus_params_t___23;
#line 37 "../../include/cmd.h"
struct __anonstruct_cmd_t_148900231 {
   char *name ;
   char *desc ;
   void (*help)(void) ;
   int (*run)(char **params ) ;
};
#line 37 "../../include/cmd.h"
typedef struct __anonstruct_cmd_t_148900231 cmd_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 64 "../../include/flash/cfi.h"
struct cfi_query_identification_string {
   uint16_t pri_id_code ;
   void *pri_vendor_tbl ;
   uint16_t alt_id_code ;
   void *alt_vendor_tbl ;
};
#line 64 "../../include/flash/cfi.h"
typedef struct cfi_query_identification_string cfi_query_identification_string_t;
#line 99 "../../include/flash/cfi.h"
struct cfi_query_system_interface_information {
   uint16_t vcc_min_wev ;
   uint16_t vcc_max_wev ;
   uint16_t vpp_min_wev ;
   uint16_t vpp_max_wev ;
   uint32_t typ_single_write_timeout ;
   uint32_t typ_buffer_write_timeout ;
   uint32_t typ_block_erase_timeout ;
   uint32_t typ_chip_erase_timeout ;
   uint32_t max_single_write_timeout ;
   uint32_t max_buffer_write_timeout ;
   uint32_t max_block_erase_timeout ;
   uint32_t max_chip_erase_timeout ;
};
#line 99 "../../include/flash/cfi.h"
typedef struct cfi_query_system_interface_information cfi_query_system_interface_information_t;
#line 124
struct cfi_erase_block_region ;
#line 124 "../../include/flash/cfi.h"
typedef struct cfi_erase_block_region cfi_erase_block_region_t;
#line 126 "../../include/flash/cfi.h"
struct cfi_device_geometry {
   uint32_t device_size ;
   uint16_t device_interface ;
   uint32_t max_bytes_write ;
   uint8_t number_of_erase_regions ;
   cfi_erase_block_region_t *erase_block_regions ;
};
#line 126 "../../include/flash/cfi.h"
typedef struct cfi_device_geometry cfi_device_geometry_t;
#line 134 "../../include/flash/cfi.h"
struct cfi_erase_block_region {
   uint32_t erase_block_size ;
   uint32_t number_of_erase_blocks ;
};
#line 151 "../../include/flash/cfi.h"
struct cfi_query_structure {
   cfi_query_identification_string_t identification_string ;
   cfi_query_system_interface_information_t system_interface_info ;
   cfi_device_geometry_t device_geometry ;
};
#line 151 "../../include/flash/cfi.h"
typedef struct cfi_query_structure cfi_query_structure_t;
#line 46 "../../include/flash.h"
struct __anonstruct_cfi_chip_t_960872676 {
   int width ;
   cfi_query_structure_t cfi ;
};
#line 46 "../../include/flash.h"
typedef struct __anonstruct_cfi_chip_t_960872676 cfi_chip_t;
#line 51 "../../include/flash.h"
struct __anonstruct_cfi_array_t_656102674 {
   bus_t *bus ;
   uint32_t address ;
   int bus_width ;
   cfi_chip_t **cfi_chips ;
};
#line 51 "../../include/flash.h"
typedef struct __anonstruct_cfi_array_t_656102674 cfi_array_t;
#line 63 "../../include/flash.h"
struct __anonstruct_flash_driver_t_660044769 {
   unsigned int bus_width ;
   char const   *name ;
   char const   *description ;
   int (*autodetect)(cfi_array_t *cfi_array ) ;
   void (*print_info)(cfi_array_t *cfi_array ) ;
   int (*erase_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*unlock_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*program)(cfi_array_t *cfi_array , uint32_t adr , uint32_t data ) ;
   void (*readarray)(cfi_array_t *cfi_array ) ;
};
#line 63 "../../include/flash.h"
typedef struct __anonstruct_flash_driver_t_660044769 flash_driver_t;
#line 178 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 180 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/jedec.c"
struct mtd_erase_region_info {
   u_int32_t offset ;
   u_int32_t erasesize ;
   u_int32_t numblocks ;
};
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/jedec.c"
struct amd_flash_info {
   int const   mfr_id ;
   int const   dev_id ;
   char const   *name ;
   long const   size ;
   u_int8_t const   interface_width ;
   int const   as_method ;
   int const   numeraseregions ;
   struct mtd_erase_region_info  const  regions[4] ;
};
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 {
   unsigned long flash ;
   unsigned short algorithm ;
   unsigned short unlock_bypass ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 277 "/usr/include/usb.h"
struct usb_dev_handle ;
#line 278 "/usr/include/usb.h"
typedef struct usb_dev_handle usb_dev_handle;
#line 52 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
struct __anonstruct_xpcu_params_t_840885179 {
   char *serial ;
   unsigned int vendor_id ;
   unsigned int product_id ;
   usb_dev_handle *dev ;
};
#line 52 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
typedef struct __anonstruct_xpcu_params_t_840885179 xpcu_params_t;
#line 61
struct port_node_t ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
typedef struct port_node_t port_node_t;
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
struct port_node_t {
   parport_t *port ;
   port_node_t *next ;
};
#line 94 "/usr/include/usb.h"
struct usb_endpoint_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bEndpointAddress ;
   uint8_t bmAttributes ;
   uint16_t wMaxPacketSize ;
   uint8_t bInterval ;
   uint8_t bRefresh ;
   uint8_t bSynchAddress ;
   unsigned char *extra ;
   int extralen ;
};
#line 119 "/usr/include/usb.h"
struct usb_interface_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bInterfaceNumber ;
   uint8_t bAlternateSetting ;
   uint8_t bNumEndpoints ;
   uint8_t bInterfaceClass ;
   uint8_t bInterfaceSubClass ;
   uint8_t bInterfaceProtocol ;
   uint8_t iInterface ;
   struct usb_endpoint_descriptor *endpoint ;
   unsigned char *extra ;
   int extralen ;
};
#line 137 "/usr/include/usb.h"
struct usb_interface {
   struct usb_interface_descriptor *altsetting ;
   int num_altsetting ;
};
#line 145 "/usr/include/usb.h"
struct usb_config_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t wTotalLength ;
   uint8_t bNumInterfaces ;
   uint8_t bConfigurationValue ;
   uint8_t iConfiguration ;
   uint8_t bmAttributes ;
   uint8_t MaxPower ;
   struct usb_interface *interface ;
   unsigned char *extra ;
   int extralen ;
};
#line 162 "/usr/include/usb.h"
struct usb_device_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t bcdUSB ;
   uint8_t bDeviceClass ;
   uint8_t bDeviceSubClass ;
   uint8_t bDeviceProtocol ;
   uint8_t bMaxPacketSize0 ;
   uint16_t idVendor ;
   uint16_t idProduct ;
   uint16_t bcdDevice ;
   uint8_t iManufacturer ;
   uint8_t iProduct ;
   uint8_t iSerialNumber ;
   uint8_t bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 235
struct usb_device ;
#line 236
struct usb_bus ;
#line 248 "/usr/include/usb.h"
struct usb_device {
   struct usb_device *next ;
   struct usb_device *prev ;
   char filename[4097] ;
   struct usb_bus *bus ;
   struct usb_device_descriptor descriptor ;
   struct usb_config_descriptor *config ;
   void *dev ;
   uint8_t devnum ;
   unsigned char num_children ;
   struct usb_device **children ;
};
#line 266 "/usr/include/usb.h"
struct usb_bus {
   struct usb_bus *next ;
   struct usb_bus *prev ;
   char dirname[4097] ;
   struct usb_device *devices ;
   uint32_t location ;
   struct usb_device *root_dev ;
};
#line 31 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.h"
struct __anonstruct_generic_params_t_773697287 {
   int trst ;
   int sreset ;
};
#line 31 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.h"
typedef struct __anonstruct_generic_params_t_773697287 generic_params_t;
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
struct __anonstruct_wiggler_params_t_19145477 {
   int trst_lvl ;
   int srst_act ;
   int srst_inact ;
   int tms_act ;
   int tms_inact ;
   int tck_act ;
   int tck_inact ;
   int tdi_act ;
   int tdi_inact ;
   int tdo_act ;
   int tdo_inact ;
   int trst_act ;
   int trst_inact ;
   int unused_bits ;
};
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
typedef struct __anonstruct_wiggler_params_t_19145477 wiggler_params_t;
#line 56 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
struct __anonstruct_ppdev_params_t_990402165 {
   char *portname ;
   int fd ;
};
#line 56 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
typedef struct __anonstruct_ppdev_params_t_990402165 ppdev_params_t;
#line 107 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
struct __anonstruct_direct_params_t_422959015 {
   unsigned int port ;
};
#line 107 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
typedef struct __anonstruct_direct_params_t_422959015 direct_params_t;
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/detect.c"
struct id_record {
   char name[20] ;
   char fullname[100] ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 340
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 61 "../../include/part.h"
data_register *part_find_data_register(part_t *p , char const   *drname ) ;
#line 46 "../../include/cmd.h"
int cmd_run(char **params ) ;
#line 137 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
void bsdl_msg(int type , char const   *format  , ...) ;
#line 155
void bsdl_sem_init(parser_priv_t *priv ) ;
#line 156
void bsdl_sem_deinit(parser_priv_t *priv ) ;
#line 157
void bsdl_set_entity(parser_priv_t *priv , char *entityname ) ;
#line 158
void bsdl_set_instruction_length(parser_priv_t *priv , int len ) ;
#line 159
void bsdl_prt_add_name(parser_priv_t *priv , char *name ) ;
#line 160
void bsdl_prt_add_bit(parser_priv_t *priv ) ;
#line 161
void bsdl_prt_add_range(parser_priv_t *priv , int low , int high ) ;
#line 162
void bsdl_prt_apply_port(parser_priv_t *priv ) ;
#line 163
void bsdl_set_idcode(parser_priv_t *priv , char *idcode ) ;
#line 164
void bsdl_set_usercode(parser_priv_t *priv , char *usercode ) ;
#line 165
void bsdl_add_instruction(parser_priv_t *priv , char *instr , char *opcode ) ;
#line 166
void bsdl_set_bsr_length(parser_priv_t *priv , int len ) ;
#line 167
void bsdl_ci_no_disable(parser_priv_t *priv ) ;
#line 168
void bsdl_ci_set_cell_spec(parser_priv_t *priv , int function , char *safe_value ) ;
#line 169
void bsdl_ci_set_cell_spec_disable(parser_priv_t *priv , int ctrl_bit_num , int safe_value ,
                                   int disable_value ) ;
#line 170
void bsdl_ci_apply_cell_info(parser_priv_t *priv , int bit_num ) ;
#line 171
void bsdl_ac_set_register(parser_priv_t *priv , char *reg , int reg_len ) ;
#line 172
void bsdl_ac_add_instruction(parser_priv_t *priv , char *instr ) ;
#line 173
void bsdl_ac_apply_assoc(parser_priv_t *priv ) ;
#line 174
void bsdl_ac_finalize(parser_priv_t *priv ) ;
#line 52 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
static void print_cmd(char **cmd ) 
{ 
  int idx ;
  char *elem ;

  {
#line 54
  idx = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    elem = *(cmd + idx);
#line 57
    if (! elem) {
#line 57
      goto while_break;
    }
    {
#line 58
    printf((char const   */* __restrict  */)" %s", elem);
#line 59
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  printf((char const   */* __restrict  */)"\n");
  }
#line 62
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_sem_init(parser_priv_t *priv ) 
{ 
  struct access_data *ad ;
  struct port_desc *pd ;

  {
#line 79
  ad = & priv->jtag_ctrl.access_data;
#line 80
  pd = & priv->jtag_ctrl.port_desc;
#line 82
  ad->ainfo_list = (struct ainfo_elem *)((void *)0);
#line 83
  ad->instr_list = (struct instr_elem *)((void *)0);
#line 85
  pd->names_list = (struct string_elem *)((void *)0);
#line 87
  priv->jtag_ctrl.instr_list = (struct instr_elem *)((void *)0);
#line 88
  return;
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
static void free_instr_list(struct instr_elem *il ) 
{ 


  {
#line 104
  if (il) {
#line 105
    if (il->instr) {
      {
#line 106
      free((void *)il->instr);
      }
    }
#line 107
    if (il->opcode) {
      {
#line 108
      free((void *)il->opcode);
      }
    }
    {
#line 109
    free_instr_list(il->next);
#line 110
    free((void *)il);
    }
  }
#line 112
  return;
}
}
#line 126 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
static void free_ainfo_list(struct ainfo_elem *ai ) 
{ 


  {
#line 128
  if (ai) {
#line 129
    if (ai->reg) {
      {
#line 130
      free((void *)ai->reg);
      }
    }
    {
#line 131
    free_instr_list(ai->instr_list);
#line 132
    free_ainfo_list(ai->next);
#line 133
    free((void *)ai);
    }
  }
#line 135
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
static void free_string_list(struct string_elem *sl ) 
{ 


  {
#line 151
  if (sl) {
#line 152
    if (sl->string) {
      {
#line 153
      free((void *)sl->string);
      }
    }
    {
#line 154
    free_string_list(sl->next);
#line 155
    free((void *)sl);
    }
  }
#line 157
  return;
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_sem_deinit(parser_priv_t *priv ) 
{ 
  struct access_data *ad ;
  struct port_desc *pd ;

  {
#line 174
  ad = & priv->jtag_ctrl.access_data;
#line 175
  pd = & priv->jtag_ctrl.port_desc;
#line 177
  if (ad->ainfo_list) {
    {
#line 178
    free_ainfo_list(ad->ainfo_list);
#line 179
    ad->ainfo_list = (struct ainfo_elem *)((void *)0);
    }
  }
#line 182
  if (priv->jtag_ctrl.instr_list) {
    {
#line 183
    free_instr_list(priv->jtag_ctrl.instr_list);
#line 184
    priv->jtag_ctrl.instr_list = (struct instr_elem *)((void *)0);
    }
  }
#line 187
  if (pd->names_list) {
    {
#line 188
    free_string_list(pd->names_list);
#line 189
    pd->names_list = (struct string_elem *)((void *)0);
    }
  }
#line 191
  return;
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_set_entity(parser_priv_t *priv , char *entityname ) 
{ 


  {
#line 208
  if (priv->jtag_ctrl.mode >= 1) {
    {
#line 209
    strncpy((char */* __restrict  */)((priv->jtag_ctrl.part)->part), (char const   */* __restrict  */)entityname,
            (size_t )20);
#line 210
    (priv->jtag_ctrl.part)->part[20] = (char )'\000';
    }
  }
  {
#line 213
  free((void *)entityname);
  }
#line 214
  return;
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_set_instruction_length(parser_priv_t *priv , int len ) 
{ 
  char lenstring[6] ;
  char *cmd[4] ;

  {
#line 229
  if (priv->jtag_ctrl.mode >= 0) {
    {
#line 231
    cmd[0] = (char *)"instruction";
#line 231
    cmd[1] = (char *)"length";
#line 231
    cmd[2] = lenstring;
#line 231
    cmd[3] = (char *)((void *)0);
#line 236
    snprintf((char */* __restrict  */)(lenstring), (size_t )6, (char const   */* __restrict  */)"%i",
             len);
#line 237
    lenstring[5] = (char )'\000';
    }
#line 239
    if (priv->jtag_ctrl.mode >= 1) {
      {
#line 240
      cmd_run(cmd);
      }
    } else {
      {
#line 242
      print_cmd(cmd);
      }
    }
  }
#line 244
  return;
}
}
#line 261 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_prt_add_name(parser_priv_t *priv , char *name ) 
{ 
  struct port_desc *pd ;
  struct string_elem *new_string___0 ;
  void *tmp ;

  {
  {
#line 263
  pd = & priv->jtag_ctrl.port_desc;
#line 266
  tmp = malloc(sizeof(struct string_elem ));
#line 266
  new_string___0 = (struct string_elem *)tmp;
  }
#line 267
  if (new_string___0) {
#line 268
    new_string___0->next = pd->names_list;
#line 269
    new_string___0->string = name;
#line 271
    pd->names_list = new_string___0;
  } else {
    {
#line 273
    bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
             273);
    }
  }
#line 274
  return;
}
}
#line 291 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_prt_add_bit(parser_priv_t *priv ) 
{ 
  struct port_desc *pd ;

  {
#line 293
  pd = & priv->jtag_ctrl.port_desc;
#line 295
  pd->is_vector = 0;
#line 296
  pd->low_idx = 0;
#line 297
  pd->high_idx = 0;
#line 298
  return;
}
}
#line 316 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_prt_add_range(parser_priv_t *priv , int low , int high ) 
{ 
  struct port_desc *pd ;

  {
#line 318
  pd = & priv->jtag_ctrl.port_desc;
#line 320
  pd->is_vector = 1;
#line 321
  pd->low_idx = low;
#line 322
  pd->high_idx = high;
#line 323
  return;
}
}
#line 344 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_prt_apply_port(parser_priv_t *priv ) 
{ 
  struct port_desc *pd ;
  char *cmd[3] ;
  struct string_elem *name ;
  size_t str_len ;
  size_t name_len ;
  char *port_string ;
  int idx ;
  void *tmp ;

  {
#line 346
  pd = & priv->jtag_ctrl.port_desc;
#line 348
  if (priv->jtag_ctrl.mode >= 0) {
#line 349
    cmd[0] = (char *)"signal";
#line 349
    cmd[1] = (char *)((void *)0);
#line 349
    cmd[2] = (char *)((void *)0);
#line 357
    name = pd->names_list;
    {
#line 358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 358
      if (! name) {
#line 358
        goto while_break;
      }
      {
#line 365
      name_len = strlen((char const   *)name->string);
#line 366
      str_len = (((name_len + 1UL) + 10UL) + 1UL) + 1UL;
#line 367
      tmp = malloc(str_len);
#line 367
      port_string = (char *)tmp;
      }
#line 367
      if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 368
        cmd[1] = port_string;
#line 370
        idx = pd->low_idx;
        {
#line 370
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 370
          if (! (idx <= pd->high_idx)) {
#line 370
            goto while_break___0;
          }
#line 371
          if (pd->is_vector) {
            {
#line 372
            snprintf((char */* __restrict  */)port_string, str_len - 1UL, (char const   */* __restrict  */)"%s(%d)",
                     name->string, idx);
            }
          } else {
            {
#line 374
            strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
                    str_len - 1UL);
            }
          }
#line 375
          *(port_string + (str_len - 1UL)) = (char )'\000';
#line 377
          if (priv->jtag_ctrl.mode >= 1) {
            {
#line 378
            cmd_run(cmd);
            }
          } else {
            {
#line 380
            print_cmd(cmd);
            }
          }
#line 370
          idx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 383
        free((void *)port_string);
        }
      } else {
        {
#line 385
        bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
                 385);
        }
      }
#line 387
      name = name->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 391
  if (pd->names_list) {
    {
#line 392
    free_string_list(pd->names_list);
#line 393
    pd->names_list = (struct string_elem *)((void *)0);
    }
  }
#line 395
  return;
}
}
#line 412 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
static void create_register(parser_priv_t *priv , char *reg_name , size_t len ) 
{ 
  size_t str_len ;
  char *len_str ;
  unsigned long __lengthoflen_str ;
  void *tmp ;
  char *cmd[4] ;
  data_register *tmp___0 ;

  {
#line 414
  if (priv->jtag_ctrl.mode >= 0) {
    {
#line 415
    str_len = (size_t )10;
#line 416
    __lengthoflen_str = str_len + 1UL;
#line 416
    tmp = __builtin_alloca(sizeof(*len_str) * __lengthoflen_str);
#line 416
    len_str = (char *)tmp;
#line 417
    cmd[0] = (char *)"register";
#line 417
    cmd[1] = reg_name;
#line 417
    cmd[2] = len_str;
#line 417
    cmd[3] = (char *)((void *)0);
#line 422
    tmp___0 = part_find_data_register(priv->jtag_ctrl.part, (char const   *)reg_name);
    }
#line 422
    if (tmp___0) {
#line 423
      return;
    }
    {
#line 426
    snprintf((char */* __restrict  */)len_str, str_len, (char const   */* __restrict  */)"%i",
             len);
    }
#line 428
    if (priv->jtag_ctrl.mode >= 1) {
      {
#line 429
      cmd_run(cmd);
      }
    } else {
      {
#line 431
      print_cmd(cmd);
      }
    }
  }
#line 433
  return;
}
}
#line 449 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_set_idcode(parser_priv_t *priv , char *idcode ) 
{ 
  size_t tmp ;

  {
  {
#line 451
  priv->jtag_ctrl.idcode = idcode;
#line 453
  tmp = strlen((char const   *)idcode);
#line 453
  create_register(priv, (char *)"DIR", tmp);
  }
#line 454
  return;
}
}
#line 470 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_set_usercode(parser_priv_t *priv , char *usercode ) 
{ 
  size_t tmp ;

  {
  {
#line 472
  tmp = strlen((char const   *)usercode);
#line 472
  create_register(priv, (char *)"USERCODE", tmp);
#line 475
  free((void *)usercode);
  }
#line 476
  return;
}
}
#line 493 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_add_instruction(parser_priv_t *priv , char *instr , char *opcode ) 
{ 
  struct instr_elem *new_instr ;
  void *tmp ;

  {
  {
#line 497
  tmp = malloc(sizeof(struct instr_elem ));
#line 497
  new_instr = (struct instr_elem *)tmp;
  }
#line 498
  if (new_instr) {
#line 499
    new_instr->next = priv->jtag_ctrl.instr_list;
#line 500
    new_instr->instr = instr;
#line 501
    new_instr->opcode = opcode;
#line 503
    priv->jtag_ctrl.instr_list = new_instr;
  } else {
    {
#line 505
    bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
             505);
    }
  }
#line 506
  return;
}
}
#line 521 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_set_bsr_length(parser_priv_t *priv , int len ) 
{ 


  {
  {
#line 523
  create_register(priv, (char *)"BSR", (size_t )len);
  }
#line 524
  return;
}
}
#line 539 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ci_no_disable(parser_priv_t *priv ) 
{ 


  {
#line 541
  priv->jtag_ctrl.cell_info.ctrl_bit_num = -1;
#line 542
  return;
}
}
#line 563 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ci_set_cell_spec(parser_priv_t *priv , int function , char *safe_value ) 
{ 
  struct cell_info *ci ;
  struct port_desc *pd ;
  struct string_elem *name ;
  char *port_string ;
  size_t str_len ;
  size_t name_len ;
  void *tmp ;

  {
  {
#line 566
  ci = & priv->jtag_ctrl.cell_info;
#line 567
  pd = & priv->jtag_ctrl.port_desc;
#line 568
  name = priv->jtag_ctrl.port_desc.names_list;
#line 572
  ci->cell_function = function;
#line 573
  ci->basic_safe_value = safe_value;
#line 581
  name_len = strlen((char const   *)name->string);
#line 582
  str_len = (((name_len + 1UL) + 10UL) + 1UL) + 1UL;
#line 583
  tmp = malloc(str_len);
#line 583
  port_string = (char *)tmp;
  }
#line 583
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 584
    if (pd->is_vector) {
      {
#line 585
      snprintf((char */* __restrict  */)port_string, str_len - 1UL, (char const   */* __restrict  */)"%s(%d)",
               name->string, pd->low_idx);
      }
    } else {
      {
#line 587
      strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
              str_len - 1UL);
      }
    }
#line 588
    *(port_string + (str_len - 1UL)) = (char )'\000';
#line 590
    ci->port_name = port_string;
  } else {
    {
#line 592
    bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
             592);
#line 593
    ci->port_name = (char *)((void *)0);
    }
  }
  {
#line 596
  free((void *)name->string);
#line 597
  free((void *)name);
#line 598
  priv->jtag_ctrl.port_desc.names_list = (struct string_elem *)((void *)0);
  }
#line 599
  return;
}
}
#line 619 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ci_set_cell_spec_disable(parser_priv_t *priv , int ctrl_bit_num , int safe_value ,
                                   int disable_value ) 
{ 
  struct cell_info *ci ;

  {
#line 622
  ci = & priv->jtag_ctrl.cell_info;
#line 624
  ci->ctrl_bit_num = ctrl_bit_num;
#line 625
  ci->disable_safe_value = safe_value;
#line 627
  return;
}
}
#line 644 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ci_apply_cell_info(parser_priv_t *priv , int bit_num ) 
{ 
  struct cell_info *ci ;
  size_t str_len ;
  char *bit_num_str ;
  unsigned long __lengthofbit_num_str ;
  void *tmp ;
  char *ctrl_bit_num_str ;
  unsigned long __lengthofctrl_bit_num_str ;
  void *tmp___0 ;
  char *disable_safe_value_str ;
  unsigned long __lengthofdisable_safe_value_str ;
  void *tmp___1 ;
  char *cmd[9] ;
  int tmp___3 ;

  {
#line 646
  ci = & priv->jtag_ctrl.cell_info;
#line 648
  ci->bit_num = bit_num;
#line 650
  if (priv->jtag_ctrl.mode >= 0) {
    {
#line 651
    str_len = (size_t )10;
#line 652
    __lengthofbit_num_str = str_len + 1UL;
#line 652
    tmp = __builtin_alloca(sizeof(*bit_num_str) * __lengthofbit_num_str);
#line 652
    bit_num_str = (char *)tmp;
#line 653
    __lengthofctrl_bit_num_str = str_len + 1UL;
#line 653
    tmp___0 = __builtin_alloca(sizeof(*ctrl_bit_num_str) * __lengthofctrl_bit_num_str);
#line 653
    ctrl_bit_num_str = (char *)tmp___0;
#line 654
    __lengthofdisable_safe_value_str = str_len + 1UL;
#line 654
    tmp___1 = __builtin_alloca(sizeof(*disable_safe_value_str) * __lengthofdisable_safe_value_str);
#line 654
    disable_safe_value_str = (char *)tmp___1;
#line 655
    cmd[0] = (char *)"bit";
#line 655
    cmd[1] = bit_num_str;
#line 655
    cmd[2] = (char *)((void *)0);
#line 655
    cmd[3] = (char *)((void *)0);
#line 655
    cmd[4] = (char *)((void *)0);
#line 655
    cmd[5] = ctrl_bit_num_str;
#line 655
    cmd[6] = disable_safe_value_str;
#line 655
    cmd[7] = (char *)"Z";
#line 655
    cmd[8] = (char *)((void *)0);
#line 666
    snprintf((char */* __restrict  */)bit_num_str, str_len, (char const   */* __restrict  */)"%i",
             ci->bit_num);
#line 667
    *(bit_num_str + str_len) = (char )'\000';
    }
    {
#line 674
    if (ci->cell_function == 323) {
#line 674
      goto case_323;
    }
#line 674
    if (ci->cell_function == 322) {
#line 674
      goto case_323;
    }
#line 674
    if (ci->cell_function == 326) {
#line 674
      goto case_323;
    }
#line 681
    if (ci->cell_function == 327) {
#line 681
      goto case_327;
    }
#line 681
    if (ci->cell_function == 321) {
#line 681
      goto case_327;
    }
#line 681
    if (ci->cell_function == 374) {
#line 681
      goto case_327;
    }
#line 686
    if (ci->cell_function == 325) {
#line 686
      goto case_325;
    }
#line 686
    if (ci->cell_function == 324) {
#line 686
      goto case_325;
    }
#line 689
    if (ci->cell_function == 328) {
#line 689
      goto case_328;
    }
#line 692
    goto switch_default;
    case_323: /* CIL Label */ 
    case_322: /* CIL Label */ 
    case_326: /* CIL Label */ 
#line 675
    cmd[2] = (char *)"O";
#line 676
    goto switch_break;
    case_327: /* CIL Label */ 
    case_321: /* CIL Label */ 
    case_374: /* CIL Label */ 
#line 682
    cmd[2] = (char *)"I";
#line 683
    goto switch_break;
    case_325: /* CIL Label */ 
    case_324: /* CIL Label */ 
#line 687
    cmd[2] = (char *)"C";
#line 688
    goto switch_break;
    case_328: /* CIL Label */ 
#line 690
    cmd[2] = (char *)"B";
#line 691
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 694
    cmd[2] = (char *)"?";
#line 695
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 698
    tmp___3 = strcasecmp((char const   *)ci->basic_safe_value, "x");
    }
#line 698
    if (tmp___3 == 0) {
#line 698
      cmd[3] = (char *)"?";
    } else {
#line 698
      cmd[3] = ci->basic_safe_value;
    }
#line 700
    cmd[4] = ci->port_name;
#line 703
    if (ci->ctrl_bit_num >= 0) {
      {
#line 705
      snprintf((char */* __restrict  */)ctrl_bit_num_str, str_len, (char const   */* __restrict  */)"%i",
               ci->ctrl_bit_num);
#line 706
      *(ctrl_bit_num_str + str_len) = (char )'\000';
#line 708
      snprintf((char */* __restrict  */)disable_safe_value_str, str_len, (char const   */* __restrict  */)"%i",
               ci->disable_safe_value);
#line 709
      *(disable_safe_value_str + str_len) = (char )'\000';
      }
    } else {
#line 712
      cmd[5] = (char *)((void *)0);
    }
#line 714
    if (priv->jtag_ctrl.mode >= 1) {
      {
#line 715
      cmd_run(cmd);
      }
    } else {
      {
#line 717
      print_cmd(cmd);
      }
    }
  }
#line 721
  if (ci->port_name) {
    {
#line 722
    free((void *)ci->port_name);
#line 723
    ci->port_name = (char *)((void *)0);
    }
  }
#line 725
  if (ci->basic_safe_value) {
    {
#line 726
    free((void *)ci->basic_safe_value);
#line 727
    ci->basic_safe_value = (char *)((void *)0);
    }
  }
#line 729
  return;
}
}
#line 747 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ac_set_register(parser_priv_t *priv , char *reg , int reg_len ) 
{ 
  struct access_data *ad ;

  {
#line 749
  ad = & priv->jtag_ctrl.access_data;
#line 751
  ad->reg = reg;
#line 752
  ad->reg_len = reg_len;
#line 753
  return;
}
}
#line 771 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ac_add_instruction(parser_priv_t *priv , char *instr ) 
{ 
  struct access_data *ad ;
  struct instr_elem *new_instr ;
  void *tmp ;

  {
  {
#line 773
  ad = & priv->jtag_ctrl.access_data;
#line 776
  tmp = malloc(sizeof(struct instr_elem ));
#line 776
  new_instr = (struct instr_elem *)tmp;
  }
#line 777
  if (new_instr) {
#line 778
    new_instr->next = ad->instr_list;
#line 779
    new_instr->instr = instr;
#line 780
    new_instr->opcode = (char *)((void *)0);
#line 782
    ad->instr_list = new_instr;
  } else {
    {
#line 784
    bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
             784);
    }
  }
#line 785
  return;
}
}
#line 801 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ac_apply_assoc(parser_priv_t *priv ) 
{ 
  struct access_data *ad ;
  struct ainfo_elem *new_ainfo ;
  void *tmp ;

  {
  {
#line 803
  ad = & priv->jtag_ctrl.access_data;
#line 806
  tmp = malloc(sizeof(struct ainfo_elem ));
#line 806
  new_ainfo = (struct ainfo_elem *)tmp;
  }
#line 807
  if (new_ainfo) {
#line 808
    new_ainfo->next = ad->ainfo_list;
#line 809
    new_ainfo->reg = ad->reg;
#line 810
    new_ainfo->reg_len = ad->reg_len;
#line 811
    new_ainfo->instr_list = ad->instr_list;
#line 813
    ad->ainfo_list = new_ainfo;
  } else {
    {
#line 815
    bsdl_msg(3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c",
             815);
    }
  }
#line 818
  ad->reg = (char *)((void *)0);
#line 819
  ad->reg_len = 0;
#line 820
  ad->instr_list = (struct instr_elem *)((void *)0);
#line 821
  return;
}
}
#line 847 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl_sem.c"
void bsdl_ac_finalize(parser_priv_t *priv ) 
{ 
  struct ainfo_elem *ai ;
  struct instr_elem *cinst ;
  int is_std ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *reg_name ;
  char *instr_name ;
  struct instr_elem *tinst ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *cmd[5] ;

  {
  {
#line 855
  create_register(priv, (char *)"BYPASS", (size_t )1);
  }
#line 857
  if (priv->jtag_ctrl.mode >= 0) {
#line 863
    ai = priv->jtag_ctrl.access_data.ainfo_list;
    {
#line 864
    while (1) {
      while_continue: /* CIL Label */ ;
#line 864
      if (! ai) {
#line 864
        goto while_break;
      }
      {
#line 865
      is_std = 0;
#line 867
      tmp = strcasecmp((char const   *)ai->reg, "BOUNDARY");
      }
#line 867
      if (tmp == 0) {
#line 867
        is_std = 1;
      }
      {
#line 868
      tmp___0 = strcasecmp((char const   *)ai->reg, "BYPASS");
      }
#line 868
      if (tmp___0 == 0) {
#line 868
        is_std = 1;
      }
      {
#line 869
      tmp___1 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
      }
#line 869
      if (tmp___1 == 0) {
#line 869
        is_std = 1;
      }
      {
#line 870
      tmp___2 = strcasecmp((char const   *)ai->reg, "USERCODE");
      }
#line 870
      if (tmp___2 == 0) {
#line 870
        is_std = 1;
      }
#line 872
      if (! is_std) {
        {
#line 873
        create_register(priv, ai->reg, (size_t )ai->reg_len);
        }
      }
#line 875
      ai = ai->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 881
    cinst = priv->jtag_ctrl.instr_list;
    {
#line 882
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 882
      if (! cinst) {
#line 882
        goto while_break___0;
      }
#line 883
      reg_name = (char *)((void *)0);
#line 884
      instr_name = (char *)((void *)0);
#line 887
      ai = priv->jtag_ctrl.access_data.ainfo_list;
      {
#line 888
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 888
        if (ai) {
#line 888
          if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 888
            goto while_break___1;
          }
        } else {
#line 888
          goto while_break___1;
        }
#line 889
        tinst = ai->instr_list;
        {
#line 891
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 891
          if (tinst) {
#line 891
            if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 891
              goto while_break___2;
            }
          } else {
#line 891
            goto while_break___2;
          }
          {
#line 892
          tmp___5 = strcasecmp((char const   *)tinst->instr, (char const   *)cinst->instr);
          }
#line 892
          if (tmp___5 == 0) {
            {
#line 896
            tmp___4 = strcasecmp((char const   *)ai->reg, "BOUNDARY");
            }
#line 896
            if (tmp___4 == 0) {
#line 896
              reg_name = (char *)"BSR";
            } else {
              {
#line 897
              tmp___3 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
              }
#line 897
              if (tmp___3 == 0) {
#line 897
                reg_name = (char *)"DIR";
              } else {
#line 898
                reg_name = ai->reg;
              }
            }
          }
#line 901
          tinst = tinst->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 904
        ai = ai->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 907
      if ((unsigned long )reg_name == (unsigned long )((void *)0)) {
        {
#line 911
        tmp___14 = strcasecmp((char const   *)cinst->instr, "BYPASS");
        }
#line 911
        if (tmp___14 == 0) {
#line 911
          reg_name = (char *)"BYPASS";
        } else {
          {
#line 912
          tmp___13 = strcasecmp((char const   *)cinst->instr, "CLAMP");
          }
#line 912
          if (tmp___13 == 0) {
#line 912
            reg_name = (char *)"BYPASS";
          } else {
            {
#line 913
            tmp___12 = strcasecmp((char const   *)cinst->instr, "EXTEST");
            }
#line 913
            if (tmp___12 == 0) {
#line 913
              reg_name = (char *)"BSR";
            } else {
              {
#line 914
              tmp___11 = strcasecmp((char const   *)cinst->instr, "HIGHZ");
              }
#line 914
              if (tmp___11 == 0) {
#line 914
                reg_name = (char *)"BYPASS";
              } else {
                {
#line 915
                tmp___10 = strcasecmp((char const   *)cinst->instr, "IDCODE");
                }
#line 915
                if (tmp___10 == 0) {
#line 915
                  reg_name = (char *)"DIR";
                } else {
                  {
#line 916
                  tmp___9 = strcasecmp((char const   *)cinst->instr, "INTEST");
                  }
#line 916
                  if (tmp___9 == 0) {
#line 916
                    reg_name = (char *)"BSR";
                  } else {
                    {
#line 917
                    tmp___8 = strcasecmp((char const   *)cinst->instr, "PRELOAD");
                    }
#line 917
                    if (tmp___8 == 0) {
#line 917
                      reg_name = (char *)"BSR";
                    } else {
                      {
#line 918
                      tmp___7 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
                      }
#line 918
                      if (tmp___7 == 0) {
#line 918
                        reg_name = (char *)"BSR";
                      } else {
                        {
#line 919
                        tmp___6 = strcasecmp((char const   *)cinst->instr, "USERCODE");
                        }
#line 919
                        if (tmp___6 == 0) {
#line 919
                          reg_name = (char *)"USERCODE";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 922
      tmp___15 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
      }
#line 922
      if (tmp___15 == 0) {
#line 923
        instr_name = (char *)"SAMPLE/PRELOAD";
      } else {
#line 925
        instr_name = cinst->instr;
      }
#line 927
      if (reg_name) {
#line 928
        cmd[0] = (char *)"instruction";
#line 928
        cmd[1] = instr_name;
#line 928
        cmd[2] = cinst->opcode;
#line 928
        cmd[3] = reg_name;
#line 928
        cmd[4] = (char *)((void *)0);
#line 934
        if (priv->jtag_ctrl.mode >= 1) {
          {
#line 935
          cmd_run(cmd);
          }
        } else {
          {
#line 937
          print_cmd(cmd);
          }
        }
      }
#line 940
      cinst = cinst->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 943
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 174
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 37 "../../include/jtag.h"
chain_t *chain ;
#line 144 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
int bsdl_flex_get_compile_errors(void *scanner ) ;
#line 150
parser_priv_t *bsdl_parser_init(FILE *f ) ;
#line 151
void bsdl_parser_deinit(parser_priv_t *priv_data ) ;
#line 152
int bsdlparse(parser_priv_t *priv_data ) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
static char **bsdl_path_list  =    (char **)((void *)0);
#line 44 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
int bsdl_debug  =    0;
#line 47 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
void bsdl_msg(int type , char const   *format  , ...) 
{ 
  va_list lst ;

  {
  {
#line 51
  __builtin_va_start(lst, format);
  }
  {
#line 53
  if (type == 0) {
#line 53
    goto case_0;
  }
#line 56
  if (type == 1) {
#line 56
    goto case_1;
  }
#line 59
  if (type == 2) {
#line 59
    goto case_2;
  }
#line 62
  if (type == 3) {
#line 62
    goto case_3;
  }
#line 65
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 54
  printf((char const   */* __restrict  */)"-N- ");
  }
#line 55
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 57
  printf((char const   */* __restrict  */)"-W- ");
  }
#line 58
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 60
  printf((char const   */* __restrict  */)"-E- ");
  }
#line 61
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 63
  printf((char const   */* __restrict  */)"-F- ");
  }
#line 64
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 66
  printf((char const   */* __restrict  */)"-?- ");
  }
#line 67
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 69
  vprintf((char const   */* __restrict  */)format, lst);
#line 70
  __builtin_va_end(lst);
  }
#line 71
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
int bsdl_read_file(char const   *BSDL_File_Name , int mode , char const   *idcode ) 
{ 
  FILE *BSDL_File ;
  parser_priv_t *parser_priv ;
  int Compile_Errors ;
  int idcode_match ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int idx ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
  {
#line 94
  Compile_Errors = 1;
#line 95
  idcode_match = 0;
#line 97
  BSDL_File = fopen((char const   */* __restrict  */)BSDL_File_Name, (char const   */* __restrict  */)"r");
  }
#line 99
  if (bsdl_debug) {
    {
#line 100
    tmp = gettext("Reading file \'%s\'\n");
#line 100
    bsdl_msg(0, (char const   *)tmp, BSDL_File_Name);
    }
  } else
#line 99
  if (mode == 0) {
    {
#line 100
    tmp = gettext("Reading file \'%s\'\n");
#line 100
    bsdl_msg(0, (char const   *)tmp, BSDL_File_Name);
    }
  }
#line 102
  if ((unsigned long )BSDL_File == (unsigned long )((void *)0)) {
    {
#line 103
    tmp___0 = gettext("Unable to open BSDL_file \'%s\'\n");
#line 103
    bsdl_msg(2, (char const   *)tmp___0, BSDL_File_Name);
    }
#line 104
    return (-1);
  }
  {
#line 107
  parser_priv = bsdl_parser_init(BSDL_File);
  }
#line 107
  if (parser_priv) {
#line 108
    if (mode >= 0) {
#line 109
      if (mode >= 1) {
#line 110
        if ((unsigned long )chain == (unsigned long )((void *)0)) {
          {
#line 111
          tmp___1 = gettext("No JTAG chain available\n");
#line 111
          bsdl_msg(2, (char const   *)tmp___1);
#line 112
          bsdl_parser_deinit(parser_priv);
#line 113
          fclose(BSDL_File);
          }
#line 114
          return (-1);
        }
#line 116
        if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
          {
#line 117
          tmp___2 = gettext("Chain without any parts\n");
#line 117
          bsdl_msg(2, (char const   *)tmp___2);
#line 118
          bsdl_parser_deinit(parser_priv);
#line 119
          fclose(BSDL_File);
          }
#line 120
          return (-1);
        }
#line 122
        if (chain) {
#line 122
          if (! chain->parts) {
            {
#line 123
            bsdl_parser_deinit(parser_priv);
#line 124
            fclose(BSDL_File);
            }
#line 125
            return (-1);
          }
        } else {
          {
#line 123
          bsdl_parser_deinit(parser_priv);
#line 124
          fclose(BSDL_File);
          }
#line 125
          return (-1);
        }
#line 127
        parser_priv->jtag_ctrl.part = *((chain->parts)->parts + chain->active_part);
      } else {
#line 129
        parser_priv->jtag_ctrl.part = (part_t *)((void *)0);
      }
    } else {
#line 131
      parser_priv->jtag_ctrl.part = (part_t *)((void *)0);
    }
    {
#line 133
    parser_priv->jtag_ctrl.mode = mode;
#line 134
    parser_priv->jtag_ctrl.debug = bsdl_debug;
#line 135
    parser_priv->jtag_ctrl.idcode = (char *)((void *)0);
#line 137
    bsdlparse(parser_priv);
#line 139
    Compile_Errors = bsdl_flex_get_compile_errors(parser_priv->scanner);
    }
#line 140
    if (Compile_Errors == 0) {
#line 141
      if (bsdl_debug) {
        {
#line 142
        tmp___3 = gettext("BSDL file \'%s\' compiled correctly\n");
#line 142
        bsdl_msg(0, (char const   *)tmp___3, BSDL_File_Name);
        }
      }
    } else
#line 144
    if (bsdl_debug) {
      {
#line 145
      tmp___4 = gettext("BSDL file \'%s\' contains errors, stopping\n");
#line 145
      bsdl_msg(2, (char const   *)tmp___4, BSDL_File_Name);
      }
    } else
#line 144
    if (mode >= 0) {
      {
#line 145
      tmp___4 = gettext("BSDL file \'%s\' contains errors, stopping\n");
#line 145
      bsdl_msg(2, (char const   *)tmp___4, BSDL_File_Name);
      }
    }
#line 148
    if (Compile_Errors == 0) {
      {
#line 149
      bsdl_ac_finalize(parser_priv);
      }
    }
#line 151
    if (Compile_Errors == 0) {
#line 151
      if (parser_priv->jtag_ctrl.idcode) {
#line 152
        if (bsdl_debug) {
          {
#line 153
          tmp___5 = gettext("Got IDCODE: %s\n");
#line 153
          bsdl_msg(0, (char const   *)tmp___5, parser_priv->jtag_ctrl.idcode);
          }
        }
#line 156
        if (idcode) {
          {
#line 157
          tmp___9 = strlen(idcode);
#line 157
          tmp___10 = strlen((char const   *)parser_priv->jtag_ctrl.idcode);
          }
#line 157
          if (tmp___9 == tmp___10) {
#line 162
            idcode_match = 1;
#line 163
            idx = 0;
            {
#line 163
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 163
              tmp___6 = strlen(idcode);
              }
#line 163
              if (! ((size_t )idx <= tmp___6)) {
#line 163
                goto while_break;
              }
#line 164
              if ((int )*(parser_priv->jtag_ctrl.idcode + idx) != 88) {
#line 165
                if ((int const   )*(idcode + idx) != (int const   )*(parser_priv->jtag_ctrl.idcode + idx)) {
#line 166
                  idcode_match = 0;
                }
              }
#line 163
              idx ++;
            }
            while_break: /* CIL Label */ ;
            }
#line 168
            if (bsdl_debug) {
#line 169
              if (idcode_match) {
                {
#line 170
                tmp___7 = gettext("IDCODE matched\n");
#line 170
                bsdl_msg(0, (char const   *)tmp___7);
                }
              } else {
                {
#line 172
                tmp___8 = gettext("IDCODE mismatch\n");
#line 172
                bsdl_msg(0, (char const   *)tmp___8);
                }
              }
            }
          }
        }
#line 177
        if (parser_priv->jtag_ctrl.idcode) {
          {
#line 178
          free((void *)parser_priv->jtag_ctrl.idcode);
          }
        }
#line 179
        parser_priv->jtag_ctrl.idcode = (char *)((void *)0);
      }
    }
    {
#line 181
    bsdl_parser_deinit(parser_priv);
    }
  }
#line 184
  if (Compile_Errors == 0) {
#line 184
    tmp___11 = idcode_match;
  } else {
#line 184
    tmp___11 = -1;
  }
#line 184
  return (tmp___11);
}
}
#line 197 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
void bsdl_set_path(char const   *pathlist ) 
{ 
  char *delim ;
  char *elem ;
  int num ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 204
  if (bsdl_path_list) {
#line 205
    num = 0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      if (! *(bsdl_path_list + num)) {
#line 205
        goto while_break;
      }
#line 206
      if (*(bsdl_path_list + num)) {
        {
#line 207
        free((void *)*(bsdl_path_list + num));
        }
      }
#line 205
      num ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 208
    free((void *)bsdl_path_list);
#line 209
    bsdl_path_list = (char **)((void *)0);
    }
  }
#line 213
  num = 0;
#line 213
  elem = (char *)pathlist;
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 213
    tmp___1 = strlen((char const   *)elem);
    }
#line 213
    if (! (tmp___1 > 0UL)) {
#line 213
      goto while_break___0;
    }
    {
#line 214
    delim = strchr((char const   *)elem, ';');
    }
#line 215
    if (delim - elem > 0L) {
      {
#line 216
      num ++;
#line 218
      tmp = realloc((void *)bsdl_path_list, (unsigned long )(num + 1) * sizeof(char *));
#line 218
      bsdl_path_list = (char **)tmp;
#line 220
      *(bsdl_path_list + (num - 1)) = strndup((char const   *)elem, (size_t )(delim - elem));
#line 221
      *(bsdl_path_list + num) = (char *)((void *)0);
      }
    } else
#line 215
    if ((unsigned long )delim == (unsigned long )((void *)0)) {
      {
#line 216
      num ++;
#line 218
      tmp = realloc((void *)bsdl_path_list, (unsigned long )(num + 1) * sizeof(char *));
#line 218
      bsdl_path_list = (char **)tmp;
#line 220
      *(bsdl_path_list + (num - 1)) = strndup((char const   *)elem, (size_t )(delim - elem));
#line 221
      *(bsdl_path_list + num) = (char *)((void *)0);
      }
    }
#line 223
    if (delim) {
#line 223
      elem = delim + 1;
    } else {
      {
#line 223
      tmp___0 = strlen((char const   *)elem);
#line 223
      elem += tmp___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 226
  if (bsdl_debug) {
#line 227
    num = 0;
    {
#line 227
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 227
      if (! ((unsigned long )*(bsdl_path_list + num) != (unsigned long )((void *)0))) {
#line 227
        goto while_break___1;
      }
      {
#line 228
      bsdl_msg(0, "%s\n", *(bsdl_path_list + num));
#line 227
      num ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 230
  return;
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.c"
int bsdl_scan_files(char const   *idcode , int mode ) 
{ 
  int idx ;
  int result ;
  DIR *dir ;
  struct dirent *elem ;
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct stat buf ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 257
  idx = 0;
#line 258
  result = 0;
#line 261
  if ((unsigned long )bsdl_path_list == (unsigned long )((void *)0)) {
#line 262
    return (0);
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (*(bsdl_path_list + idx)) {
#line 264
      if (! (result <= 0)) {
#line 264
        goto while_break;
      }
    } else {
#line 264
      goto while_break;
    }
    {
#line 267
    dir = opendir((char const   *)*(bsdl_path_list + idx));
    }
#line 267
    if (dir) {
      {
#line 271
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 271
        elem = readdir(dir);
        }
#line 271
        if (elem) {
#line 271
          if (! (result <= 0)) {
#line 271
            goto while_break___0;
          }
        } else {
#line 271
          goto while_break___0;
        }
        {
#line 274
        tmp = strlen((char const   *)*(bsdl_path_list + idx));
#line 274
        tmp___0 = strlen((char const   *)(elem->d_name));
#line 274
        tmp___1 = malloc(((tmp + tmp___0) + 1UL) + 1UL);
#line 274
        name = (char *)tmp___1;
        }
#line 275
        if (name) {
          {
#line 278
          strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)*(bsdl_path_list + idx));
#line 279
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
#line 280
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)(elem->d_name));
#line 282
          tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& buf));
          }
#line 282
          if (tmp___3 == 0) {
#line 283
            if (buf.st_mode & 32768U) {
#line 284
              if (mode >= 1) {
                {
#line 287
                result = bsdl_read_file((char const   *)name, -1, idcode);
                }
#line 288
                if (result > 0) {
                  {
#line 290
                  tmp___2 = gettext("  Filename:     %s\n");
#line 290
                  printf((char const   */* __restrict  */)tmp___2, name);
#line 291
                  result = bsdl_read_file((char const   *)name, 1, idcode);
                  }
                }
              } else {
                {
#line 294
                result = bsdl_read_file((char const   *)name, mode, idcode);
                }
              }
            }
          }
          {
#line 298
          free((void *)name);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 302
      closedir(dir);
      }
    } else {
      {
#line 304
      tmp___4 = gettext("Cannot open directory %s\n");
#line 304
      bsdl_msg(1, (char const   *)tmp___4, *(bsdl_path_list + idx));
      }
    }
#line 306
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return (result);
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 137
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 757
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 137 "bsdl_flex.c"
int bsdllex_init(yyscan_t *ptr_yy_globals ) ;
#line 286
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 287
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 288
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 289
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 290
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 291
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 292
void bsdlpop_buffer_state(yyscan_t yyscanner ) ;
#line 294
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) ;
#line 295
static void bsdl_load_buffer_state(yyscan_t yyscanner ) ;
#line 296
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 300
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 301
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 302
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 304
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 305
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 306
void bsdlfree(void *ptr , yyscan_t yyscanner ) ;
#line 340
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) ;
#line 341
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 342
static int yy_get_next_buffer(yyscan_t yyscanner ) ;
#line 343
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) ;
#line 364 "bsdl_flex.c"
static flex_int16_t const   yy_acclist[803]  = 
#line 364
  {      (flex_int16_t const   )0,      (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110, 
        (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110, 
        (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )110,      (flex_int16_t const   )122, 
        (flex_int16_t const   )120,      (flex_int16_t const   )121,      (flex_int16_t const   )110,      (flex_int16_t const   )121, 
        (flex_int16_t const   )98,      (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )118, 
        (flex_int16_t const   )121,      (flex_int16_t const   )108,      (flex_int16_t const   )121,      (flex_int16_t const   )100, 
        (flex_int16_t const   )121,      (flex_int16_t const   )101,      (flex_int16_t const   )121,      (flex_int16_t const   )106, 
        (flex_int16_t const   )121,      (flex_int16_t const   )99,      (flex_int16_t const   )121,      (flex_int16_t const   )120, 
        (flex_int16_t const   )121,      (flex_int16_t const   )102,      (flex_int16_t const   )121,      (flex_int16_t const   )112, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )121,      (flex_int16_t const   )116, 
        (flex_int16_t const   )121,      (flex_int16_t const   )105,      (flex_int16_t const   )121,      (flex_int16_t const   )119, 
        (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )103, 
        (flex_int16_t const   )121,      (flex_int16_t const   )104,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )112, 
        (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121, 
        (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121, 
        (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121, 
        (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121, 
        (flex_int16_t const   )92,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )89, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )121,      (flex_int16_t const   )113, 
        (flex_int16_t const   )121,      (flex_int16_t const   )110,      (flex_int16_t const   )114,      (flex_int16_t const   )111, 
        (flex_int16_t const   )112,      (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )112,      (flex_int16_t const   )109,      (flex_int16_t const   )107,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )25, 
        (flex_int16_t const   )113,      (flex_int16_t const   )6,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )11,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )32, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )25,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )25,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )86,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )111,      (flex_int16_t const   )10,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )30,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )9,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )23, 
        (flex_int16_t const   )113,      (flex_int16_t const   )26,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )4,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )26, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )4,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )88, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )91, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )87, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )35,      (flex_int16_t const   )113,      (flex_int16_t const   )24, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )2,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )15, 
        (flex_int16_t const   )113,      (flex_int16_t const   )36,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )90,      (flex_int16_t const   )113,      (flex_int16_t const   )117, 
        (flex_int16_t const   )39,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )16,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )27,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )41,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )78,      (flex_int16_t const   )113, 
        (flex_int16_t const   )76,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )70, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )95,      (flex_int16_t const   )113,      (flex_int16_t const   )96, 
        (flex_int16_t const   )113,      (flex_int16_t const   )93,      (flex_int16_t const   )113,      (flex_int16_t const   )94, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )66,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )28,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )33,      (flex_int16_t const   )113,      (flex_int16_t const   )1,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )38,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )17,      (flex_int16_t const   )113, 
        (flex_int16_t const   )8,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )97, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )65,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )67, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )81, 
        (flex_int16_t const   )113,      (flex_int16_t const   )83,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )82,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )3, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )29,      (flex_int16_t const   )113,      (flex_int16_t const   )34,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )12,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )37, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )74, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )71, 
        (flex_int16_t const   )113,      (flex_int16_t const   )72,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )84,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )7,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )40,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )73,      (flex_int16_t const   )113,      (flex_int16_t const   )75,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )64,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )68,      (flex_int16_t const   )113,      (flex_int16_t const   )79,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )5,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )42,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )69,      (flex_int16_t const   )113, 
        (flex_int16_t const   )80,      (flex_int16_t const   )113,      (flex_int16_t const   )31,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )18,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )19,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )77,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )59, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )21,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )52,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )62,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )57,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )14,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )20,      (flex_int16_t const   )113,      (flex_int16_t const   )22, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )53,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )55, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )51, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )61,      (flex_int16_t const   )113, 
        (flex_int16_t const   )13,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )54,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )47,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )49,      (flex_int16_t const   )113,      (flex_int16_t const   )60,      (flex_int16_t const   )113, 
        (flex_int16_t const   )56,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )43,      (flex_int16_t const   )113, 
        (flex_int16_t const   )44,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )63,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )45, 
        (flex_int16_t const   )113,      (flex_int16_t const   )46,      (flex_int16_t const   )113,      (flex_int16_t const   )48, 
        (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )113,      (flex_int16_t const   )50, 
        (flex_int16_t const   )113,      (flex_int16_t const   )58,      (flex_int16_t const   )113};
#line 457 "bsdl_flex.c"
static flex_int16_t const   yy_accept[644]  = 
#line 457
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )14,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )25, 
        (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )33, 
        (flex_int16_t const   )35,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )43, 
        (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )49, 
        (flex_int16_t const   )51,      (flex_int16_t const   )53,      (flex_int16_t const   )55,      (flex_int16_t const   )57, 
        (flex_int16_t const   )59,      (flex_int16_t const   )61,      (flex_int16_t const   )63,      (flex_int16_t const   )65, 
        (flex_int16_t const   )67,      (flex_int16_t const   )69,      (flex_int16_t const   )71,      (flex_int16_t const   )73, 
        (flex_int16_t const   )75,      (flex_int16_t const   )77,      (flex_int16_t const   )79,      (flex_int16_t const   )81, 
        (flex_int16_t const   )83,      (flex_int16_t const   )86,      (flex_int16_t const   )88,      (flex_int16_t const   )90, 
        (flex_int16_t const   )92,      (flex_int16_t const   )94,      (flex_int16_t const   )96,      (flex_int16_t const   )98, 
        (flex_int16_t const   )100,      (flex_int16_t const   )103,      (flex_int16_t const   )105,      (flex_int16_t const   )107, 
        (flex_int16_t const   )109,      (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )115, 
        (flex_int16_t const   )117,      (flex_int16_t const   )119,      (flex_int16_t const   )121,      (flex_int16_t const   )123, 
        (flex_int16_t const   )125,      (flex_int16_t const   )127,      (flex_int16_t const   )129,      (flex_int16_t const   )131, 
        (flex_int16_t const   )135,      (flex_int16_t const   )137,      (flex_int16_t const   )138,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )143, 
        (flex_int16_t const   )144,      (flex_int16_t const   )145,      (flex_int16_t const   )146,      (flex_int16_t const   )147, 
        (flex_int16_t const   )148,      (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )151, 
        (flex_int16_t const   )152,      (flex_int16_t const   )153,      (flex_int16_t const   )154,      (flex_int16_t const   )155, 
        (flex_int16_t const   )156,      (flex_int16_t const   )157,      (flex_int16_t const   )158,      (flex_int16_t const   )159, 
        (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )162,      (flex_int16_t const   )163, 
        (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )168,      (flex_int16_t const   )169, 
        (flex_int16_t const   )171,      (flex_int16_t const   )172,      (flex_int16_t const   )173,      (flex_int16_t const   )174, 
        (flex_int16_t const   )175,      (flex_int16_t const   )176,      (flex_int16_t const   )177,      (flex_int16_t const   )178, 
        (flex_int16_t const   )179,      (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182, 
        (flex_int16_t const   )183,      (flex_int16_t const   )185,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )193,      (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205, 
        (flex_int16_t const   )206,      (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209, 
        (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )214,      (flex_int16_t const   )216, 
        (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )219,      (flex_int16_t const   )220, 
        (flex_int16_t const   )221,      (flex_int16_t const   )221,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )227,      (flex_int16_t const   )228,      (flex_int16_t const   )229, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )237, 
        (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )241,      (flex_int16_t const   )242, 
        (flex_int16_t const   )243,      (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )246, 
        (flex_int16_t const   )247,      (flex_int16_t const   )249,      (flex_int16_t const   )251,      (flex_int16_t const   )252, 
        (flex_int16_t const   )253,      (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )256, 
        (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )260, 
        (flex_int16_t const   )261,      (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )264, 
        (flex_int16_t const   )265,      (flex_int16_t const   )266,      (flex_int16_t const   )268,      (flex_int16_t const   )269, 
        (flex_int16_t const   )270,      (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )273, 
        (flex_int16_t const   )274,      (flex_int16_t const   )275,      (flex_int16_t const   )277,      (flex_int16_t const   )278, 
        (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )281,      (flex_int16_t const   )282, 
        (flex_int16_t const   )283,      (flex_int16_t const   )284,      (flex_int16_t const   )286,      (flex_int16_t const   )287, 
        (flex_int16_t const   )289,      (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )293, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )297,      (flex_int16_t const   )298, 
        (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )301, 
        (flex_int16_t const   )303,      (flex_int16_t const   )305,      (flex_int16_t const   )306,      (flex_int16_t const   )307, 
        (flex_int16_t const   )308,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311, 
        (flex_int16_t const   )312,      (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )315, 
        (flex_int16_t const   )316,      (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )319, 
        (flex_int16_t const   )320,      (flex_int16_t const   )321,      (flex_int16_t const   )322,      (flex_int16_t const   )323, 
        (flex_int16_t const   )324,      (flex_int16_t const   )326,      (flex_int16_t const   )327,      (flex_int16_t const   )328, 
        (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )332, 
        (flex_int16_t const   )333,      (flex_int16_t const   )334,      (flex_int16_t const   )335,      (flex_int16_t const   )337, 
        (flex_int16_t const   )339,      (flex_int16_t const   )340,      (flex_int16_t const   )341,      (flex_int16_t const   )342, 
        (flex_int16_t const   )343,      (flex_int16_t const   )344,      (flex_int16_t const   )345,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )349,      (flex_int16_t const   )350, 
        (flex_int16_t const   )351,      (flex_int16_t const   )352,      (flex_int16_t const   )353,      (flex_int16_t const   )354, 
        (flex_int16_t const   )355,      (flex_int16_t const   )356,      (flex_int16_t const   )357,      (flex_int16_t const   )358, 
        (flex_int16_t const   )359,      (flex_int16_t const   )360,      (flex_int16_t const   )361,      (flex_int16_t const   )363, 
        (flex_int16_t const   )363,      (flex_int16_t const   )364,      (flex_int16_t const   )366,      (flex_int16_t const   )367, 
        (flex_int16_t const   )368,      (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )371, 
        (flex_int16_t const   )372,      (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )375, 
        (flex_int16_t const   )376,      (flex_int16_t const   )377,      (flex_int16_t const   )378,      (flex_int16_t const   )380, 
        (flex_int16_t const   )381,      (flex_int16_t const   )382,      (flex_int16_t const   )384,      (flex_int16_t const   )385, 
        (flex_int16_t const   )386,      (flex_int16_t const   )387,      (flex_int16_t const   )388,      (flex_int16_t const   )389, 
        (flex_int16_t const   )390,      (flex_int16_t const   )391,      (flex_int16_t const   )392,      (flex_int16_t const   )394, 
        (flex_int16_t const   )395,      (flex_int16_t const   )396,      (flex_int16_t const   )397,      (flex_int16_t const   )398, 
        (flex_int16_t const   )399,      (flex_int16_t const   )400,      (flex_int16_t const   )401,      (flex_int16_t const   )402, 
        (flex_int16_t const   )404,      (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )409, 
        (flex_int16_t const   )410,      (flex_int16_t const   )411,      (flex_int16_t const   )412,      (flex_int16_t const   )413, 
        (flex_int16_t const   )415,      (flex_int16_t const   )417,      (flex_int16_t const   )419,      (flex_int16_t const   )421, 
        (flex_int16_t const   )422,      (flex_int16_t const   )423,      (flex_int16_t const   )424,      (flex_int16_t const   )426, 
        (flex_int16_t const   )427,      (flex_int16_t const   )428,      (flex_int16_t const   )429,      (flex_int16_t const   )430, 
        (flex_int16_t const   )431,      (flex_int16_t const   )432,      (flex_int16_t const   )433,      (flex_int16_t const   )434, 
        (flex_int16_t const   )435,      (flex_int16_t const   )436,      (flex_int16_t const   )437,      (flex_int16_t const   )439, 
        (flex_int16_t const   )440,      (flex_int16_t const   )441,      (flex_int16_t const   )442,      (flex_int16_t const   )443, 
        (flex_int16_t const   )444,      (flex_int16_t const   )446,      (flex_int16_t const   )448,      (flex_int16_t const   )449, 
        (flex_int16_t const   )450,      (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )453, 
        (flex_int16_t const   )454,      (flex_int16_t const   )455,      (flex_int16_t const   )456,      (flex_int16_t const   )457, 
        (flex_int16_t const   )458,      (flex_int16_t const   )460,      (flex_int16_t const   )461,      (flex_int16_t const   )462, 
        (flex_int16_t const   )464,      (flex_int16_t const   )466,      (flex_int16_t const   )467,      (flex_int16_t const   )468, 
        (flex_int16_t const   )469,      (flex_int16_t const   )470,      (flex_int16_t const   )471,      (flex_int16_t const   )473, 
        (flex_int16_t const   )474,      (flex_int16_t const   )475,      (flex_int16_t const   )476,      (flex_int16_t const   )478, 
        (flex_int16_t const   )479,      (flex_int16_t const   )481,      (flex_int16_t const   )482,      (flex_int16_t const   )483, 
        (flex_int16_t const   )485,      (flex_int16_t const   )487,      (flex_int16_t const   )488,      (flex_int16_t const   )490, 
        (flex_int16_t const   )491,      (flex_int16_t const   )492,      (flex_int16_t const   )493,      (flex_int16_t const   )494, 
        (flex_int16_t const   )495,      (flex_int16_t const   )496,      (flex_int16_t const   )497,      (flex_int16_t const   )498, 
        (flex_int16_t const   )499,      (flex_int16_t const   )501,      (flex_int16_t const   )502,      (flex_int16_t const   )503, 
        (flex_int16_t const   )504,      (flex_int16_t const   )506,      (flex_int16_t const   )508,      (flex_int16_t const   )509, 
        (flex_int16_t const   )511,      (flex_int16_t const   )512,      (flex_int16_t const   )513,      (flex_int16_t const   )514, 
        (flex_int16_t const   )515,      (flex_int16_t const   )517,      (flex_int16_t const   )518,      (flex_int16_t const   )519, 
        (flex_int16_t const   )521,      (flex_int16_t const   )522,      (flex_int16_t const   )523,      (flex_int16_t const   )525, 
        (flex_int16_t const   )527,      (flex_int16_t const   )528,      (flex_int16_t const   )529,      (flex_int16_t const   )530, 
        (flex_int16_t const   )531,      (flex_int16_t const   )532,      (flex_int16_t const   )534,      (flex_int16_t const   )535, 
        (flex_int16_t const   )536,      (flex_int16_t const   )537,      (flex_int16_t const   )538,      (flex_int16_t const   )539, 
        (flex_int16_t const   )540,      (flex_int16_t const   )541,      (flex_int16_t const   )543,      (flex_int16_t const   )544, 
        (flex_int16_t const   )545,      (flex_int16_t const   )546,      (flex_int16_t const   )547,      (flex_int16_t const   )548, 
        (flex_int16_t const   )549,      (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )553, 
        (flex_int16_t const   )554,      (flex_int16_t const   )555,      (flex_int16_t const   )556,      (flex_int16_t const   )558, 
        (flex_int16_t const   )560,      (flex_int16_t const   )561,      (flex_int16_t const   )563,      (flex_int16_t const   )564, 
        (flex_int16_t const   )566,      (flex_int16_t const   )568,      (flex_int16_t const   )569,      (flex_int16_t const   )571, 
        (flex_int16_t const   )572,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )576, 
        (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )579,      (flex_int16_t const   )580, 
        (flex_int16_t const   )581,      (flex_int16_t const   )582,      (flex_int16_t const   )583,      (flex_int16_t const   )584, 
        (flex_int16_t const   )585,      (flex_int16_t const   )586,      (flex_int16_t const   )587,      (flex_int16_t const   )588, 
        (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )592,      (flex_int16_t const   )594, 
        (flex_int16_t const   )596,      (flex_int16_t const   )597,      (flex_int16_t const   )598,      (flex_int16_t const   )599, 
        (flex_int16_t const   )600,      (flex_int16_t const   )601,      (flex_int16_t const   )602,      (flex_int16_t const   )603, 
        (flex_int16_t const   )604,      (flex_int16_t const   )605,      (flex_int16_t const   )606,      (flex_int16_t const   )607, 
        (flex_int16_t const   )608,      (flex_int16_t const   )609,      (flex_int16_t const   )610,      (flex_int16_t const   )611, 
        (flex_int16_t const   )612,      (flex_int16_t const   )613,      (flex_int16_t const   )614,      (flex_int16_t const   )615, 
        (flex_int16_t const   )616,      (flex_int16_t const   )617,      (flex_int16_t const   )618,      (flex_int16_t const   )619, 
        (flex_int16_t const   )620,      (flex_int16_t const   )621,      (flex_int16_t const   )622,      (flex_int16_t const   )623, 
        (flex_int16_t const   )624,      (flex_int16_t const   )625,      (flex_int16_t const   )626,      (flex_int16_t const   )627, 
        (flex_int16_t const   )628,      (flex_int16_t const   )629,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )632,      (flex_int16_t const   )633,      (flex_int16_t const   )634,      (flex_int16_t const   )636, 
        (flex_int16_t const   )637,      (flex_int16_t const   )638,      (flex_int16_t const   )639,      (flex_int16_t const   )640, 
        (flex_int16_t const   )641,      (flex_int16_t const   )642,      (flex_int16_t const   )643,      (flex_int16_t const   )644, 
        (flex_int16_t const   )645,      (flex_int16_t const   )646,      (flex_int16_t const   )647,      (flex_int16_t const   )648, 
        (flex_int16_t const   )649,      (flex_int16_t const   )650,      (flex_int16_t const   )651,      (flex_int16_t const   )652, 
        (flex_int16_t const   )653,      (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )656, 
        (flex_int16_t const   )657,      (flex_int16_t const   )658,      (flex_int16_t const   )660,      (flex_int16_t const   )661, 
        (flex_int16_t const   )662,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )666, 
        (flex_int16_t const   )667,      (flex_int16_t const   )668,      (flex_int16_t const   )669,      (flex_int16_t const   )670, 
        (flex_int16_t const   )671,      (flex_int16_t const   )672,      (flex_int16_t const   )673,      (flex_int16_t const   )674, 
        (flex_int16_t const   )675,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )678, 
        (flex_int16_t const   )679,      (flex_int16_t const   )680,      (flex_int16_t const   )681,      (flex_int16_t const   )682, 
        (flex_int16_t const   )683,      (flex_int16_t const   )685,      (flex_int16_t const   )686,      (flex_int16_t const   )687, 
        (flex_int16_t const   )688,      (flex_int16_t const   )690,      (flex_int16_t const   )691,      (flex_int16_t const   )692, 
        (flex_int16_t const   )694,      (flex_int16_t const   )695,      (flex_int16_t const   )696,      (flex_int16_t const   )698, 
        (flex_int16_t const   )699,      (flex_int16_t const   )700,      (flex_int16_t const   )702,      (flex_int16_t const   )703, 
        (flex_int16_t const   )704,      (flex_int16_t const   )705,      (flex_int16_t const   )706,      (flex_int16_t const   )707, 
        (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )710,      (flex_int16_t const   )711, 
        (flex_int16_t const   )712,      (flex_int16_t const   )713,      (flex_int16_t const   )715,      (flex_int16_t const   )716, 
        (flex_int16_t const   )717,      (flex_int16_t const   )719,      (flex_int16_t const   )721,      (flex_int16_t const   )722, 
        (flex_int16_t const   )724,      (flex_int16_t const   )725,      (flex_int16_t const   )726,      (flex_int16_t const   )727, 
        (flex_int16_t const   )729,      (flex_int16_t const   )730,      (flex_int16_t const   )731,      (flex_int16_t const   )732, 
        (flex_int16_t const   )733,      (flex_int16_t const   )734,      (flex_int16_t const   )735,      (flex_int16_t const   )736, 
        (flex_int16_t const   )737,      (flex_int16_t const   )738,      (flex_int16_t const   )739,      (flex_int16_t const   )741, 
        (flex_int16_t const   )742,      (flex_int16_t const   )743,      (flex_int16_t const   )744,      (flex_int16_t const   )745, 
        (flex_int16_t const   )746,      (flex_int16_t const   )747,      (flex_int16_t const   )748,      (flex_int16_t const   )749, 
        (flex_int16_t const   )750,      (flex_int16_t const   )751,      (flex_int16_t const   )752,      (flex_int16_t const   )753, 
        (flex_int16_t const   )754,      (flex_int16_t const   )756,      (flex_int16_t const   )758,      (flex_int16_t const   )759, 
        (flex_int16_t const   )760,      (flex_int16_t const   )762,      (flex_int16_t const   )763,      (flex_int16_t const   )764, 
        (flex_int16_t const   )765,      (flex_int16_t const   )766,      (flex_int16_t const   )768,      (flex_int16_t const   )769, 
        (flex_int16_t const   )770,      (flex_int16_t const   )771,      (flex_int16_t const   )772,      (flex_int16_t const   )774, 
        (flex_int16_t const   )776,      (flex_int16_t const   )778,      (flex_int16_t const   )779,      (flex_int16_t const   )780, 
        (flex_int16_t const   )781,      (flex_int16_t const   )782,      (flex_int16_t const   )784,      (flex_int16_t const   )786, 
        (flex_int16_t const   )787,      (flex_int16_t const   )788,      (flex_int16_t const   )790,      (flex_int16_t const   )791, 
        (flex_int16_t const   )793,      (flex_int16_t const   )795,      (flex_int16_t const   )797,      (flex_int16_t const   )798, 
        (flex_int16_t const   )799,      (flex_int16_t const   )801,      (flex_int16_t const   )803,      (flex_int16_t const   )803};
#line 532 "bsdl_flex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 532
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20, 
        (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )29, 
        (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )33, 
        (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36,      (flex_int32_t const   )37, 
        (flex_int32_t const   )38,      (flex_int32_t const   )39,      (flex_int32_t const   )40,      (flex_int32_t const   )41, 
        (flex_int32_t const   )42,      (flex_int32_t const   )43,      (flex_int32_t const   )44,      (flex_int32_t const   )45, 
        (flex_int32_t const   )46,      (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49, 
        (flex_int32_t const   )50,      (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )24, 
        (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )1,      (flex_int32_t const   )26, 
        (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )29, 
        (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )33, 
        (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36,      (flex_int32_t const   )37, 
        (flex_int32_t const   )38,      (flex_int32_t const   )39,      (flex_int32_t const   )40,      (flex_int32_t const   )41, 
        (flex_int32_t const   )42,      (flex_int32_t const   )43,      (flex_int32_t const   )44,      (flex_int32_t const   )45, 
        (flex_int32_t const   )46,      (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49, 
        (flex_int32_t const   )50,      (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 564 "bsdl_flex.c"
static flex_int32_t const   yy_meta[53]  = 
#line 564
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3};
#line 574 "bsdl_flex.c"
static flex_int16_t const   yy_base[646]  = 
#line 574
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )50,      (flex_int16_t const   )29, 
        (flex_int16_t const   )54,      (flex_int16_t const   )75,      (flex_int16_t const   )0,      (flex_int16_t const   )779, 
        (flex_int16_t const   )780,      (flex_int16_t const   )776,      (flex_int16_t const   )780,      (flex_int16_t const   )773, 
        (flex_int16_t const   )780,      (flex_int16_t const   )780,      (flex_int16_t const   )780,      (flex_int16_t const   )780, 
        (flex_int16_t const   )780,      (flex_int16_t const   )780,      (flex_int16_t const   )764,      (flex_int16_t const   )780, 
        (flex_int16_t const   )55,      (flex_int16_t const   )80,      (flex_int16_t const   )753,      (flex_int16_t const   )780, 
        (flex_int16_t const   )751,      (flex_int16_t const   )780,      (flex_int16_t const   )780,      (flex_int16_t const   )780, 
        (flex_int16_t const   )37,      (flex_int16_t const   )83,      (flex_int16_t const   )24,      (flex_int16_t const   )49, 
        (flex_int16_t const   )733,      (flex_int16_t const   )745,      (flex_int16_t const   )740,      (flex_int16_t const   )0, 
        (flex_int16_t const   )81,      (flex_int16_t const   )72,      (flex_int16_t const   )68,      (flex_int16_t const   )102, 
        (flex_int16_t const   )104,      (flex_int16_t const   )98,      (flex_int16_t const   )105,      (flex_int16_t const   )725, 
        (flex_int16_t const   )124,      (flex_int16_t const   )107,      (flex_int16_t const   )109,      (flex_int16_t const   )123, 
        (flex_int16_t const   )738,      (flex_int16_t const   )129,      (flex_int16_t const   )131,      (flex_int16_t const   )737, 
        (flex_int16_t const   )0,      (flex_int16_t const   )132,      (flex_int16_t const   )128,      (flex_int16_t const   )732, 
        (flex_int16_t const   )130,      (flex_int16_t const   )721,      (flex_int16_t const   )145,      (flex_int16_t const   )157, 
        (flex_int16_t const   )131,      (flex_int16_t const   )157,      (flex_int16_t const   )161,      (flex_int16_t const   )169, 
        (flex_int16_t const   )178,      (flex_int16_t const   )172,      (flex_int16_t const   )16,      (flex_int16_t const   )197, 
        (flex_int16_t const   )734,      (flex_int16_t const   )762,      (flex_int16_t const   )759,      (flex_int16_t const   )780, 
        (flex_int16_t const   )0,      (flex_int16_t const   )199,      (flex_int16_t const   )213,      (flex_int16_t const   )219, 
        (flex_int16_t const   )206,      (flex_int16_t const   )780,      (flex_int16_t const   )780,      (flex_int16_t const   )0, 
        (flex_int16_t const   )724,      (flex_int16_t const   )717,      (flex_int16_t const   )714,      (flex_int16_t const   )713, 
        (flex_int16_t const   )176,      (flex_int16_t const   )728,      (flex_int16_t const   )725,      (flex_int16_t const   )718, 
        (flex_int16_t const   )69,      (flex_int16_t const   )710,      (flex_int16_t const   )705,      (flex_int16_t const   )194, 
        (flex_int16_t const   )715,      (flex_int16_t const   )712,      (flex_int16_t const   )722,      (flex_int16_t const   )197, 
        (flex_int16_t const   )0,      (flex_int16_t const   )710,      (flex_int16_t const   )700,      (flex_int16_t const   )0, 
        (flex_int16_t const   )702,      (flex_int16_t const   )718,      (flex_int16_t const   )695,      (flex_int16_t const   )705, 
        (flex_int16_t const   )200,      (flex_int16_t const   )704,      (flex_int16_t const   )217,      (flex_int16_t const   )703, 
        (flex_int16_t const   )709,      (flex_int16_t const   )697,      (flex_int16_t const   )712,      (flex_int16_t const   )697, 
        (flex_int16_t const   )0,      (flex_int16_t const   )691,      (flex_int16_t const   )695,      (flex_int16_t const   )705, 
        (flex_int16_t const   )234,      (flex_int16_t const   )209,      (flex_int16_t const   )694,      (flex_int16_t const   )212, 
        (flex_int16_t const   )212,      (flex_int16_t const   )703,      (flex_int16_t const   )688,      (flex_int16_t const   )686, 
        (flex_int16_t const   )693,      (flex_int16_t const   )703,      (flex_int16_t const   )229,      (flex_int16_t const   )687, 
        (flex_int16_t const   )137,      (flex_int16_t const   )695,      (flex_int16_t const   )698,      (flex_int16_t const   )695, 
        (flex_int16_t const   )231,      (flex_int16_t const   )683,      (flex_int16_t const   )678,      (flex_int16_t const   )223, 
        (flex_int16_t const   )692,      (flex_int16_t const   )682,      (flex_int16_t const   )222,      (flex_int16_t const   )681, 
        (flex_int16_t const   )681,      (flex_int16_t const   )689,      (flex_int16_t const   )674,      (flex_int16_t const   )0, 
        (flex_int16_t const   )256,      (flex_int16_t const   )0,      (flex_int16_t const   )690,      (flex_int16_t const   )672, 
        (flex_int16_t const   )689,      (flex_int16_t const   )663,      (flex_int16_t const   )679,      (flex_int16_t const   )672, 
        (flex_int16_t const   )673,      (flex_int16_t const   )678,      (flex_int16_t const   )671,      (flex_int16_t const   )666, 
        (flex_int16_t const   )662,      (flex_int16_t const   )671,      (flex_int16_t const   )665,      (flex_int16_t const   )0, 
        (flex_int16_t const   )669,      (flex_int16_t const   )658,      (flex_int16_t const   )671,      (flex_int16_t const   )660, 
        (flex_int16_t const   )653,      (flex_int16_t const   )653,      (flex_int16_t const   )667,      (flex_int16_t const   )660, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )659,      (flex_int16_t const   )650, 
        (flex_int16_t const   )668,      (flex_int16_t const   )647,      (flex_int16_t const   )657,      (flex_int16_t const   )658, 
        (flex_int16_t const   )649,      (flex_int16_t const   )654,      (flex_int16_t const   )660,      (flex_int16_t const   )647, 
        (flex_int16_t const   )651,      (flex_int16_t const   )639,      (flex_int16_t const   )658,      (flex_int16_t const   )652, 
        (flex_int16_t const   )651,      (flex_int16_t const   )637,      (flex_int16_t const   )645,      (flex_int16_t const   )650, 
        (flex_int16_t const   )233,      (flex_int16_t const   )631,      (flex_int16_t const   )646,      (flex_int16_t const   )634, 
        (flex_int16_t const   )644,      (flex_int16_t const   )632,      (flex_int16_t const   )635,      (flex_int16_t const   )635, 
        (flex_int16_t const   )631,      (flex_int16_t const   )643,      (flex_int16_t const   )634,      (flex_int16_t const   )634, 
        (flex_int16_t const   )626,      (flex_int16_t const   )622,      (flex_int16_t const   )630,      (flex_int16_t const   )0, 
        (flex_int16_t const   )633,      (flex_int16_t const   )632,      (flex_int16_t const   )0,      (flex_int16_t const   )634, 
        (flex_int16_t const   )619,      (flex_int16_t const   )0,      (flex_int16_t const   )619,      (flex_int16_t const   )276, 
        (flex_int16_t const   )608,      (flex_int16_t const   )623,      (flex_int16_t const   )609,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )626,      (flex_int16_t const   )629,      (flex_int16_t const   )623, 
        (flex_int16_t const   )627,      (flex_int16_t const   )153,      (flex_int16_t const   )606,      (flex_int16_t const   )618, 
        (flex_int16_t const   )604,      (flex_int16_t const   )603,      (flex_int16_t const   )617,      (flex_int16_t const   )603, 
        (flex_int16_t const   )616,      (flex_int16_t const   )599,      (flex_int16_t const   )600,      (flex_int16_t const   )598, 
        (flex_int16_t const   )615,      (flex_int16_t const   )614,      (flex_int16_t const   )605,      (flex_int16_t const   )600, 
        (flex_int16_t const   )612,      (flex_int16_t const   )591,      (flex_int16_t const   )605,      (flex_int16_t const   )591, 
        (flex_int16_t const   )589,      (flex_int16_t const   )598,      (flex_int16_t const   )605,      (flex_int16_t const   )591, 
        (flex_int16_t const   )579,      (flex_int16_t const   )584,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )599,      (flex_int16_t const   )583,      (flex_int16_t const   )589,      (flex_int16_t const   )581, 
        (flex_int16_t const   )578,      (flex_int16_t const   )236,      (flex_int16_t const   )592,      (flex_int16_t const   )578, 
        (flex_int16_t const   )574,      (flex_int16_t const   )268,      (flex_int16_t const   )281,      (flex_int16_t const   )590, 
        (flex_int16_t const   )574,      (flex_int16_t const   )589,      (flex_int16_t const   )565,      (flex_int16_t const   )586, 
        (flex_int16_t const   )586,      (flex_int16_t const   )570,      (flex_int16_t const   )568,      (flex_int16_t const   )253, 
        (flex_int16_t const   )577,      (flex_int16_t const   )573,      (flex_int16_t const   )0,      (flex_int16_t const   )285, 
        (flex_int16_t const   )290,      (flex_int16_t const   )0,      (flex_int16_t const   )582,      (flex_int16_t const   )578, 
        (flex_int16_t const   )581,      (flex_int16_t const   )576,      (flex_int16_t const   )562,      (flex_int16_t const   )570, 
        (flex_int16_t const   )569,      (flex_int16_t const   )563,      (flex_int16_t const   )575,      (flex_int16_t const   )561, 
        (flex_int16_t const   )559,      (flex_int16_t const   )548,      (flex_int16_t const   )0,      (flex_int16_t const   )563, 
        (flex_int16_t const   )566,      (flex_int16_t const   )0,      (flex_int16_t const   )549,      (flex_int16_t const   )549, 
        (flex_int16_t const   )561,      (flex_int16_t const   )560,      (flex_int16_t const   )563,      (flex_int16_t const   )564, 
        (flex_int16_t const   )557,      (flex_int16_t const   )554,      (flex_int16_t const   )0,      (flex_int16_t const   )558, 
        (flex_int16_t const   )541,      (flex_int16_t const   )541,      (flex_int16_t const   )547,      (flex_int16_t const   )551, 
        (flex_int16_t const   )541,      (flex_int16_t const   )553,      (flex_int16_t const   )540,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )539,      (flex_int16_t const   )0,      (flex_int16_t const   )539, 
        (flex_int16_t const   )534,      (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )548, 
        (flex_int16_t const   )529,      (flex_int16_t const   )542,      (flex_int16_t const   )0,      (flex_int16_t const   )541, 
        (flex_int16_t const   )530,      (flex_int16_t const   )544,      (flex_int16_t const   )523,      (flex_int16_t const   )522, 
        (flex_int16_t const   )522,      (flex_int16_t const   )535,      (flex_int16_t const   )518,      (flex_int16_t const   )535, 
        (flex_int16_t const   )519,      (flex_int16_t const   )512,      (flex_int16_t const   )0,      (flex_int16_t const   )521, 
        (flex_int16_t const   )533,      (flex_int16_t const   )528,      (flex_int16_t const   )518,      (flex_int16_t const   )531, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )527,      (flex_int16_t const   )529, 
        (flex_int16_t const   )525,      (flex_int16_t const   )527,      (flex_int16_t const   )521,      (flex_int16_t const   )520, 
        (flex_int16_t const   )523,      (flex_int16_t const   )507,      (flex_int16_t const   )504,      (flex_int16_t const   )499, 
        (flex_int16_t const   )0,      (flex_int16_t const   )515,      (flex_int16_t const   )499,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )513,      (flex_int16_t const   )516,      (flex_int16_t const   )512, 
        (flex_int16_t const   )503,      (flex_int16_t const   )513,      (flex_int16_t const   )0,      (flex_int16_t const   )508, 
        (flex_int16_t const   )293,      (flex_int16_t const   )494,      (flex_int16_t const   )0,      (flex_int16_t const   )511, 
        (flex_int16_t const   )510,      (flex_int16_t const   )505,      (flex_int16_t const   )276,      (flex_int16_t const   )0, 
        (flex_int16_t const   )508,      (flex_int16_t const   )487,      (flex_int16_t const   )0,      (flex_int16_t const   )486, 
        (flex_int16_t const   )485,      (flex_int16_t const   )479,      (flex_int16_t const   )483,      (flex_int16_t const   )496, 
        (flex_int16_t const   )487,      (flex_int16_t const   )486,      (flex_int16_t const   )479,      (flex_int16_t const   )475, 
        (flex_int16_t const   )0,      (flex_int16_t const   )479,      (flex_int16_t const   )476,      (flex_int16_t const   )490, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )482,      (flex_int16_t const   )493, 
        (flex_int16_t const   )477,      (flex_int16_t const   )486,      (flex_int16_t const   )472,      (flex_int16_t const   )489, 
        (flex_int16_t const   )0,      (flex_int16_t const   )474,      (flex_int16_t const   )482,      (flex_int16_t const   )468, 
        (flex_int16_t const   )473,      (flex_int16_t const   )484,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )458,      (flex_int16_t const   )473,      (flex_int16_t const   )476,      (flex_int16_t const   )466, 
        (flex_int16_t const   )458,      (flex_int16_t const   )478,      (flex_int16_t const   )472,      (flex_int16_t const   )461, 
        (flex_int16_t const   )475,      (flex_int16_t const   )469,      (flex_int16_t const   )458,      (flex_int16_t const   )469, 
        (flex_int16_t const   )451,      (flex_int16_t const   )0,      (flex_int16_t const   )469,      (flex_int16_t const   )464, 
        (flex_int16_t const   )459,      (flex_int16_t const   )443,      (flex_int16_t const   )466,      (flex_int16_t const   )446, 
        (flex_int16_t const   )443,      (flex_int16_t const   )0,      (flex_int16_t const   )463,      (flex_int16_t const   )457, 
        (flex_int16_t const   )461,      (flex_int16_t const   )460,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )444,      (flex_int16_t const   )458,      (flex_int16_t const   )453,      (flex_int16_t const   )456, 
        (flex_int16_t const   )0,      (flex_int16_t const   )435,      (flex_int16_t const   )0,      (flex_int16_t const   )436, 
        (flex_int16_t const   )283,      (flex_int16_t const   )439,      (flex_int16_t const   )0,      (flex_int16_t const   )447, 
        (flex_int16_t const   )451,      (flex_int16_t const   )432,      (flex_int16_t const   )442,      (flex_int16_t const   )433, 
        (flex_int16_t const   )442,      (flex_int16_t const   )430,      (flex_int16_t const   )425,      (flex_int16_t const   )428, 
        (flex_int16_t const   )442,      (flex_int16_t const   )418,      (flex_int16_t const   )284,      (flex_int16_t const   )423, 
        (flex_int16_t const   )426,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )434,      (flex_int16_t const   )433,      (flex_int16_t const   )432,      (flex_int16_t const   )417, 
        (flex_int16_t const   )435,      (flex_int16_t const   )431,      (flex_int16_t const   )419,      (flex_int16_t const   )423, 
        (flex_int16_t const   )417,      (flex_int16_t const   )427,      (flex_int16_t const   )420,      (flex_int16_t const   )410, 
        (flex_int16_t const   )418,      (flex_int16_t const   )423,      (flex_int16_t const   )420,      (flex_int16_t const   )412, 
        (flex_int16_t const   )409,      (flex_int16_t const   )407,      (flex_int16_t const   )400,      (flex_int16_t const   )415, 
        (flex_int16_t const   )414,      (flex_int16_t const   )406,      (flex_int16_t const   )405,      (flex_int16_t const   )402, 
        (flex_int16_t const   )408,      (flex_int16_t const   )405,      (flex_int16_t const   )397,      (flex_int16_t const   )397, 
        (flex_int16_t const   )402,      (flex_int16_t const   )391,      (flex_int16_t const   )409,      (flex_int16_t const   )387, 
        (flex_int16_t const   )393,      (flex_int16_t const   )397,      (flex_int16_t const   )391,      (flex_int16_t const   )401, 
        (flex_int16_t const   )400,      (flex_int16_t const   )387,      (flex_int16_t const   )0,      (flex_int16_t const   )397, 
        (flex_int16_t const   )380,      (flex_int16_t const   )380,      (flex_int16_t const   )391,      (flex_int16_t const   )372, 
        (flex_int16_t const   )384,      (flex_int16_t const   )388,      (flex_int16_t const   )385,      (flex_int16_t const   )378, 
        (flex_int16_t const   )391,      (flex_int16_t const   )377,      (flex_int16_t const   )376,      (flex_int16_t const   )369, 
        (flex_int16_t const   )300,      (flex_int16_t const   )368,      (flex_int16_t const   )387,      (flex_int16_t const   )372, 
        (flex_int16_t const   )378,      (flex_int16_t const   )379,      (flex_int16_t const   )362,      (flex_int16_t const   )379, 
        (flex_int16_t const   )376,      (flex_int16_t const   )0,      (flex_int16_t const   )375,      (flex_int16_t const   )370, 
        (flex_int16_t const   )0,      (flex_int16_t const   )359,      (flex_int16_t const   )357,      (flex_int16_t const   )357, 
        (flex_int16_t const   )361,      (flex_int16_t const   )354,      (flex_int16_t const   )367,      (flex_int16_t const   )365, 
        (flex_int16_t const   )366,      (flex_int16_t const   )369,      (flex_int16_t const   )360,      (flex_int16_t const   )347, 
        (flex_int16_t const   )362,      (flex_int16_t const   )350,      (flex_int16_t const   )347,      (flex_int16_t const   )359, 
        (flex_int16_t const   )344,      (flex_int16_t const   )353,      (flex_int16_t const   )348,      (flex_int16_t const   )353, 
        (flex_int16_t const   )0,      (flex_int16_t const   )340,      (flex_int16_t const   )338,      (flex_int16_t const   )346, 
        (flex_int16_t const   )0,      (flex_int16_t const   )336,      (flex_int16_t const   )336,      (flex_int16_t const   )0, 
        (flex_int16_t const   )346,      (flex_int16_t const   )333,      (flex_int16_t const   )0,      (flex_int16_t const   )332, 
        (flex_int16_t const   )336,      (flex_int16_t const   )0,      (flex_int16_t const   )332,      (flex_int16_t const   )333, 
        (flex_int16_t const   )329,      (flex_int16_t const   )346,      (flex_int16_t const   )332,      (flex_int16_t const   )342, 
        (flex_int16_t const   )335,      (flex_int16_t const   )326,      (flex_int16_t const   )341,      (flex_int16_t const   )326, 
        (flex_int16_t const   )339,      (flex_int16_t const   )0,      (flex_int16_t const   )320,      (flex_int16_t const   )329, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )317,      (flex_int16_t const   )0, 
        (flex_int16_t const   )331,      (flex_int16_t const   )330,      (flex_int16_t const   )316,      (flex_int16_t const   )0, 
        (flex_int16_t const   )313,      (flex_int16_t const   )331,      (flex_int16_t const   )313,      (flex_int16_t const   )323, 
        (flex_int16_t const   )314,      (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )316, 
        (flex_int16_t const   )306,      (flex_int16_t const   )302,      (flex_int16_t const   )0,      (flex_int16_t const   )302, 
        (flex_int16_t const   )309,      (flex_int16_t const   )295,      (flex_int16_t const   )293,      (flex_int16_t const   )297, 
        (flex_int16_t const   )288,      (flex_int16_t const   )306,      (flex_int16_t const   )302,      (flex_int16_t const   )285, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )291,      (flex_int16_t const   )289, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )278,      (flex_int16_t const   )272, 
        (flex_int16_t const   )0,      (flex_int16_t const   )275,      (flex_int16_t const   )287,      (flex_int16_t const   )245, 
        (flex_int16_t const   )247,      (flex_int16_t const   )0,      (flex_int16_t const   )228,      (flex_int16_t const   )229, 
        (flex_int16_t const   )195,      (flex_int16_t const   )160,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )119,      (flex_int16_t const   )122,      (flex_int16_t const   )124, 
        (flex_int16_t const   )110,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )103, 
        (flex_int16_t const   )94,      (flex_int16_t const   )0,      (flex_int16_t const   )85,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )55, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )780,      (flex_int16_t const   )347, 
        (flex_int16_t const   )53,      (flex_int16_t const   )350};
#line 649 "bsdl_flex.c"
static flex_int16_t const   yy_def[646]  = 
#line 649
  {      (flex_int16_t const   )0,      (flex_int16_t const   )642,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )9,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )643, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )642,      (flex_int16_t const   )643,      (flex_int16_t const   )642, 
        (flex_int16_t const   )645,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )645, 
        (flex_int16_t const   )642,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )642, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )644, 
        (flex_int16_t const   )644,      (flex_int16_t const   )644,      (flex_int16_t const   )0,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642};
#line 724 "bsdl_flex.c"
static flex_int16_t const   yy_nxt[833]  = 
#line 724
  {      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )12,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )12,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )29,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )36, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )39, 
        (flex_int16_t const   )39,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )39, 
        (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )48,      (flex_int16_t const   )39, 
        (flex_int16_t const   )39,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )91, 
        (flex_int16_t const   )83,      (flex_int16_t const   )57,      (flex_int16_t const   )145,      (flex_int16_t const   )58, 
        (flex_int16_t const   )51,      (flex_int16_t const   )119,      (flex_int16_t const   )52,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )92,      (flex_int16_t const   )53,      (flex_int16_t const   )54, 
        (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )55,      (flex_int16_t const   )84, 
        (flex_int16_t const   )61,      (flex_int16_t const   )56,      (flex_int16_t const   )49,      (flex_int16_t const   )50, 
        (flex_int16_t const   )93,      (flex_int16_t const   )85,      (flex_int16_t const   )57,      (flex_int16_t const   )86, 
        (flex_int16_t const   )58,      (flex_int16_t const   )51,      (flex_int16_t const   )641,      (flex_int16_t const   )52, 
        (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )94,      (flex_int16_t const   )53, 
        (flex_int16_t const   )54,      (flex_int16_t const   )77,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )55, 
        (flex_int16_t const   )103,      (flex_int16_t const   )61,      (flex_int16_t const   )56,      (flex_int16_t const   )62, 
        (flex_int16_t const   )63,      (flex_int16_t const   )80,      (flex_int16_t const   )64,      (flex_int16_t const   )101, 
        (flex_int16_t const   )159,      (flex_int16_t const   )160,      (flex_int16_t const   )65,      (flex_int16_t const   )98, 
        (flex_int16_t const   )640,      (flex_int16_t const   )102,      (flex_int16_t const   )639,      (flex_int16_t const   )104, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )87,      (flex_int16_t const   )68, 
        (flex_int16_t const   )69,      (flex_int16_t const   )99,      (flex_int16_t const   )70,      (flex_int16_t const   )638, 
        (flex_int16_t const   )88,      (flex_int16_t const   )71,      (flex_int16_t const   )100,      (flex_int16_t const   )72, 
        (flex_int16_t const   )89,      (flex_int16_t const   )105,      (flex_int16_t const   )90,      (flex_int16_t const   )109, 
        (flex_int16_t const   )115,      (flex_int16_t const   )112,      (flex_int16_t const   )637,      (flex_int16_t const   )110, 
        (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )91,      (flex_int16_t const   )636,      (flex_int16_t const   )121,      (flex_int16_t const   )108, 
        (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )122, 
        (flex_int16_t const   )88,      (flex_int16_t const   )117,      (flex_int16_t const   )123,      (flex_int16_t const   )111, 
        (flex_int16_t const   )89,      (flex_int16_t const   )98,      (flex_int16_t const   )90,      (flex_int16_t const   )635, 
        (flex_int16_t const   )118,      (flex_int16_t const   )126,      (flex_int16_t const   )105,      (flex_int16_t const   )132, 
        (flex_int16_t const   )134,      (flex_int16_t const   )103,      (flex_int16_t const   )634,      (flex_int16_t const   )124, 
        (flex_int16_t const   )633,      (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )87, 
        (flex_int16_t const   )100,      (flex_int16_t const   )94,      (flex_int16_t const   )99,      (flex_int16_t const   )95, 
        (flex_int16_t const   )108,      (flex_int16_t const   )130,      (flex_int16_t const   )120,      (flex_int16_t const   )100, 
        (flex_int16_t const   )127,      (flex_int16_t const   )89,      (flex_int16_t const   )128,      (flex_int16_t const   )90, 
        (flex_int16_t const   )136,      (flex_int16_t const   )138,      (flex_int16_t const   )161,      (flex_int16_t const   )131, 
        (flex_int16_t const   )137,      (flex_int16_t const   )202,      (flex_int16_t const   )88,      (flex_int16_t const   )98, 
        (flex_int16_t const   )91,      (flex_int16_t const   )126,      (flex_int16_t const   )89,      (flex_int16_t const   )284, 
        (flex_int16_t const   )90,      (flex_int16_t const   )103,      (flex_int16_t const   )285,      (flex_int16_t const   )122, 
        (flex_int16_t const   )105,      (flex_int16_t const   )139,      (flex_int16_t const   )123,      (flex_int16_t const   )144, 
        (flex_int16_t const   )632,      (flex_int16_t const   )140,      (flex_int16_t const   )100,      (flex_int16_t const   )106, 
        (flex_int16_t const   )141,      (flex_int16_t const   )109,      (flex_int16_t const   )153,      (flex_int16_t const   )112, 
        (flex_int16_t const   )127,      (flex_int16_t const   )110,      (flex_int16_t const   )142,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )148, 
        (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )154,      (flex_int16_t const   )155, 
        (flex_int16_t const   )163,      (flex_int16_t const   )143,      (flex_int16_t const   )77,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )77,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )168,      (flex_int16_t const   )190, 
        (flex_int16_t const   )164,      (flex_int16_t const   )631,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )177,      (flex_int16_t const   )178,      (flex_int16_t const   )180,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )181,      (flex_int16_t const   )159, 
        (flex_int16_t const   )192,      (flex_int16_t const   )168,      (flex_int16_t const   )193,      (flex_int16_t const   )152, 
        (flex_int16_t const   )80,      (flex_int16_t const   )169,      (flex_int16_t const   )194,      (flex_int16_t const   )153, 
        (flex_int16_t const   )630,      (flex_int16_t const   )206,      (flex_int16_t const   )629,      (flex_int16_t const   )80, 
        (flex_int16_t const   )168,      (flex_int16_t const   )193,      (flex_int16_t const   )177,      (flex_int16_t const   )178, 
        (flex_int16_t const   )169,      (flex_int16_t const   )209,      (flex_int16_t const   )148,      (flex_int16_t const   )148, 
        (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )154, 
        (flex_int16_t const   )200,      (flex_int16_t const   )152,      (flex_int16_t const   )226,      (flex_int16_t const   )255, 
        (flex_int16_t const   )315,      (flex_int16_t const   )295,      (flex_int16_t const   )319,      (flex_int16_t const   )320, 
        (flex_int16_t const   )120,      (flex_int16_t const   )628,      (flex_int16_t const   )275,      (flex_int16_t const   )215, 
        (flex_int16_t const   )275,      (flex_int16_t const   )627,      (flex_int16_t const   )276,      (flex_int16_t const   )276, 
        (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )321, 
        (flex_int16_t const   )322,      (flex_int16_t const   )315,      (flex_int16_t const   )331,      (flex_int16_t const   )276, 
        (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276, 
        (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276, 
        (flex_int16_t const   )276,      (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )411, 
        (flex_int16_t const   )464,      (flex_int16_t const   )479,      (flex_int16_t const   )626,      (flex_int16_t const   )625, 
        (flex_int16_t const   )624,      (flex_int16_t const   )412,      (flex_int16_t const   )623,      (flex_int16_t const   )480, 
        (flex_int16_t const   )622,      (flex_int16_t const   )465,      (flex_int16_t const   )621,      (flex_int16_t const   )481, 
        (flex_int16_t const   )620,      (flex_int16_t const   )482,      (flex_int16_t const   )619,      (flex_int16_t const   )466, 
        (flex_int16_t const   )483,      (flex_int16_t const   )537,      (flex_int16_t const   )538,      (flex_int16_t const   )618, 
        (flex_int16_t const   )617,      (flex_int16_t const   )539,      (flex_int16_t const   )616,      (flex_int16_t const   )615, 
        (flex_int16_t const   )614,      (flex_int16_t const   )613,      (flex_int16_t const   )540,      (flex_int16_t const   )612, 
        (flex_int16_t const   )611,      (flex_int16_t const   )541,      (flex_int16_t const   )542,      (flex_int16_t const   )610, 
        (flex_int16_t const   )609,      (flex_int16_t const   )543,      (flex_int16_t const   )608,      (flex_int16_t const   )544, 
        (flex_int16_t const   )74,      (flex_int16_t const   )607,      (flex_int16_t const   )74,      (flex_int16_t const   )147, 
        (flex_int16_t const   )606,      (flex_int16_t const   )147,      (flex_int16_t const   )605,      (flex_int16_t const   )604, 
        (flex_int16_t const   )603,      (flex_int16_t const   )602,      (flex_int16_t const   )601,      (flex_int16_t const   )600, 
        (flex_int16_t const   )599,      (flex_int16_t const   )598,      (flex_int16_t const   )597,      (flex_int16_t const   )596, 
        (flex_int16_t const   )595,      (flex_int16_t const   )594,      (flex_int16_t const   )593,      (flex_int16_t const   )592, 
        (flex_int16_t const   )591,      (flex_int16_t const   )590,      (flex_int16_t const   )589,      (flex_int16_t const   )588, 
        (flex_int16_t const   )587,      (flex_int16_t const   )586,      (flex_int16_t const   )585,      (flex_int16_t const   )584, 
        (flex_int16_t const   )583,      (flex_int16_t const   )582,      (flex_int16_t const   )581,      (flex_int16_t const   )580, 
        (flex_int16_t const   )579,      (flex_int16_t const   )578,      (flex_int16_t const   )577,      (flex_int16_t const   )576, 
        (flex_int16_t const   )575,      (flex_int16_t const   )574,      (flex_int16_t const   )573,      (flex_int16_t const   )572, 
        (flex_int16_t const   )571,      (flex_int16_t const   )570,      (flex_int16_t const   )569,      (flex_int16_t const   )568, 
        (flex_int16_t const   )567,      (flex_int16_t const   )566,      (flex_int16_t const   )565,      (flex_int16_t const   )564, 
        (flex_int16_t const   )563,      (flex_int16_t const   )562,      (flex_int16_t const   )561,      (flex_int16_t const   )560, 
        (flex_int16_t const   )559,      (flex_int16_t const   )558,      (flex_int16_t const   )557,      (flex_int16_t const   )556, 
        (flex_int16_t const   )555,      (flex_int16_t const   )554,      (flex_int16_t const   )553,      (flex_int16_t const   )552, 
        (flex_int16_t const   )551,      (flex_int16_t const   )550,      (flex_int16_t const   )549,      (flex_int16_t const   )548, 
        (flex_int16_t const   )547,      (flex_int16_t const   )546,      (flex_int16_t const   )545,      (flex_int16_t const   )536, 
        (flex_int16_t const   )535,      (flex_int16_t const   )534,      (flex_int16_t const   )533,      (flex_int16_t const   )532, 
        (flex_int16_t const   )531,      (flex_int16_t const   )530,      (flex_int16_t const   )529,      (flex_int16_t const   )528, 
        (flex_int16_t const   )527,      (flex_int16_t const   )526,      (flex_int16_t const   )525,      (flex_int16_t const   )524, 
        (flex_int16_t const   )523,      (flex_int16_t const   )522,      (flex_int16_t const   )521,      (flex_int16_t const   )520, 
        (flex_int16_t const   )519,      (flex_int16_t const   )518,      (flex_int16_t const   )517,      (flex_int16_t const   )516, 
        (flex_int16_t const   )515,      (flex_int16_t const   )514,      (flex_int16_t const   )513,      (flex_int16_t const   )512, 
        (flex_int16_t const   )511,      (flex_int16_t const   )510,      (flex_int16_t const   )509,      (flex_int16_t const   )508, 
        (flex_int16_t const   )507,      (flex_int16_t const   )506,      (flex_int16_t const   )505,      (flex_int16_t const   )504, 
        (flex_int16_t const   )503,      (flex_int16_t const   )502,      (flex_int16_t const   )501,      (flex_int16_t const   )500, 
        (flex_int16_t const   )499,      (flex_int16_t const   )498,      (flex_int16_t const   )497,      (flex_int16_t const   )496, 
        (flex_int16_t const   )495,      (flex_int16_t const   )494,      (flex_int16_t const   )493,      (flex_int16_t const   )492, 
        (flex_int16_t const   )491,      (flex_int16_t const   )490,      (flex_int16_t const   )489,      (flex_int16_t const   )488, 
        (flex_int16_t const   )487,      (flex_int16_t const   )486,      (flex_int16_t const   )485,      (flex_int16_t const   )484, 
        (flex_int16_t const   )478,      (flex_int16_t const   )477,      (flex_int16_t const   )476,      (flex_int16_t const   )475, 
        (flex_int16_t const   )474,      (flex_int16_t const   )473,      (flex_int16_t const   )472,      (flex_int16_t const   )471, 
        (flex_int16_t const   )470,      (flex_int16_t const   )469,      (flex_int16_t const   )468,      (flex_int16_t const   )467, 
        (flex_int16_t const   )463,      (flex_int16_t const   )462,      (flex_int16_t const   )459,      (flex_int16_t const   )461, 
        (flex_int16_t const   )444,      (flex_int16_t const   )460,      (flex_int16_t const   )459,      (flex_int16_t const   )458, 
        (flex_int16_t const   )457,      (flex_int16_t const   )456,      (flex_int16_t const   )455,      (flex_int16_t const   )454, 
        (flex_int16_t const   )453,      (flex_int16_t const   )452,      (flex_int16_t const   )451,      (flex_int16_t const   )450, 
        (flex_int16_t const   )449,      (flex_int16_t const   )448,      (flex_int16_t const   )447,      (flex_int16_t const   )446, 
        (flex_int16_t const   )445,      (flex_int16_t const   )444,      (flex_int16_t const   )443,      (flex_int16_t const   )442, 
        (flex_int16_t const   )431,      (flex_int16_t const   )441,      (flex_int16_t const   )440,      (flex_int16_t const   )439, 
        (flex_int16_t const   )438,      (flex_int16_t const   )437,      (flex_int16_t const   )436,      (flex_int16_t const   )435, 
        (flex_int16_t const   )434,      (flex_int16_t const   )433,      (flex_int16_t const   )432,      (flex_int16_t const   )431, 
        (flex_int16_t const   )430,      (flex_int16_t const   )429,      (flex_int16_t const   )428,      (flex_int16_t const   )427, 
        (flex_int16_t const   )426,      (flex_int16_t const   )425,      (flex_int16_t const   )424,      (flex_int16_t const   )423, 
        (flex_int16_t const   )422,      (flex_int16_t const   )421,      (flex_int16_t const   )420,      (flex_int16_t const   )419, 
        (flex_int16_t const   )418,      (flex_int16_t const   )417,      (flex_int16_t const   )416,      (flex_int16_t const   )415, 
        (flex_int16_t const   )414,      (flex_int16_t const   )413,      (flex_int16_t const   )391,      (flex_int16_t const   )410, 
        (flex_int16_t const   )389,      (flex_int16_t const   )409,      (flex_int16_t const   )408,      (flex_int16_t const   )405, 
        (flex_int16_t const   )404,      (flex_int16_t const   )403,      (flex_int16_t const   )402,      (flex_int16_t const   )401, 
        (flex_int16_t const   )400,      (flex_int16_t const   )399,      (flex_int16_t const   )398,      (flex_int16_t const   )397, 
        (flex_int16_t const   )396,      (flex_int16_t const   )395,      (flex_int16_t const   )394,      (flex_int16_t const   )393, 
        (flex_int16_t const   )392,      (flex_int16_t const   )391,      (flex_int16_t const   )390,      (flex_int16_t const   )389, 
        (flex_int16_t const   )388,      (flex_int16_t const   )387,      (flex_int16_t const   )386,      (flex_int16_t const   )385, 
        (flex_int16_t const   )384,      (flex_int16_t const   )383,      (flex_int16_t const   )382,      (flex_int16_t const   )381, 
        (flex_int16_t const   )380,      (flex_int16_t const   )379,      (flex_int16_t const   )378,      (flex_int16_t const   )377, 
        (flex_int16_t const   )376,      (flex_int16_t const   )375,      (flex_int16_t const   )374,      (flex_int16_t const   )373, 
        (flex_int16_t const   )372,      (flex_int16_t const   )371,      (flex_int16_t const   )370,      (flex_int16_t const   )369, 
        (flex_int16_t const   )368,      (flex_int16_t const   )367,      (flex_int16_t const   )366,      (flex_int16_t const   )365, 
        (flex_int16_t const   )364,      (flex_int16_t const   )363,      (flex_int16_t const   )362,      (flex_int16_t const   )361, 
        (flex_int16_t const   )360,      (flex_int16_t const   )359,      (flex_int16_t const   )358,      (flex_int16_t const   )357, 
        (flex_int16_t const   )356,      (flex_int16_t const   )355,      (flex_int16_t const   )354,      (flex_int16_t const   )353, 
        (flex_int16_t const   )352,      (flex_int16_t const   )351,      (flex_int16_t const   )350,      (flex_int16_t const   )349, 
        (flex_int16_t const   )348,      (flex_int16_t const   )347,      (flex_int16_t const   )346,      (flex_int16_t const   )345, 
        (flex_int16_t const   )344,      (flex_int16_t const   )343,      (flex_int16_t const   )342,      (flex_int16_t const   )341, 
        (flex_int16_t const   )340,      (flex_int16_t const   )339,      (flex_int16_t const   )338,      (flex_int16_t const   )337, 
        (flex_int16_t const   )336,      (flex_int16_t const   )335,      (flex_int16_t const   )334,      (flex_int16_t const   )333, 
        (flex_int16_t const   )332,      (flex_int16_t const   )330,      (flex_int16_t const   )329,      (flex_int16_t const   )328, 
        (flex_int16_t const   )327,      (flex_int16_t const   )326,      (flex_int16_t const   )325,      (flex_int16_t const   )324, 
        (flex_int16_t const   )323,      (flex_int16_t const   )318,      (flex_int16_t const   )317,      (flex_int16_t const   )316, 
        (flex_int16_t const   )314,      (flex_int16_t const   )313,      (flex_int16_t const   )312,      (flex_int16_t const   )311, 
        (flex_int16_t const   )310,      (flex_int16_t const   )309,      (flex_int16_t const   )308,      (flex_int16_t const   )307, 
        (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )304,      (flex_int16_t const   )303, 
        (flex_int16_t const   )302,      (flex_int16_t const   )301,      (flex_int16_t const   )300,      (flex_int16_t const   )299, 
        (flex_int16_t const   )298,      (flex_int16_t const   )297,      (flex_int16_t const   )296,      (flex_int16_t const   )295, 
        (flex_int16_t const   )294,      (flex_int16_t const   )293,      (flex_int16_t const   )292,      (flex_int16_t const   )291, 
        (flex_int16_t const   )290,      (flex_int16_t const   )289,      (flex_int16_t const   )288,      (flex_int16_t const   )287, 
        (flex_int16_t const   )286,      (flex_int16_t const   )283,      (flex_int16_t const   )282,      (flex_int16_t const   )281, 
        (flex_int16_t const   )280,      (flex_int16_t const   )279,      (flex_int16_t const   )278,      (flex_int16_t const   )277, 
        (flex_int16_t const   )274,      (flex_int16_t const   )273,      (flex_int16_t const   )272,      (flex_int16_t const   )271, 
        (flex_int16_t const   )270,      (flex_int16_t const   )269,      (flex_int16_t const   )268,      (flex_int16_t const   )267, 
        (flex_int16_t const   )266,      (flex_int16_t const   )265,      (flex_int16_t const   )264,      (flex_int16_t const   )263, 
        (flex_int16_t const   )262,      (flex_int16_t const   )261,      (flex_int16_t const   )260,      (flex_int16_t const   )259, 
        (flex_int16_t const   )258,      (flex_int16_t const   )257,      (flex_int16_t const   )256,      (flex_int16_t const   )254, 
        (flex_int16_t const   )253,      (flex_int16_t const   )252,      (flex_int16_t const   )251,      (flex_int16_t const   )250, 
        (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )247,      (flex_int16_t const   )246, 
        (flex_int16_t const   )245,      (flex_int16_t const   )244,      (flex_int16_t const   )243,      (flex_int16_t const   )242, 
        (flex_int16_t const   )241,      (flex_int16_t const   )240,      (flex_int16_t const   )239,      (flex_int16_t const   )238, 
        (flex_int16_t const   )237,      (flex_int16_t const   )236,      (flex_int16_t const   )235,      (flex_int16_t const   )234, 
        (flex_int16_t const   )233,      (flex_int16_t const   )232,      (flex_int16_t const   )231,      (flex_int16_t const   )230, 
        (flex_int16_t const   )229,      (flex_int16_t const   )228,      (flex_int16_t const   )227,      (flex_int16_t const   )226, 
        (flex_int16_t const   )225,      (flex_int16_t const   )224,      (flex_int16_t const   )223,      (flex_int16_t const   )222, 
        (flex_int16_t const   )221,      (flex_int16_t const   )220,      (flex_int16_t const   )219,      (flex_int16_t const   )218, 
        (flex_int16_t const   )217,      (flex_int16_t const   )216,      (flex_int16_t const   )214,      (flex_int16_t const   )213, 
        (flex_int16_t const   )212,      (flex_int16_t const   )211,      (flex_int16_t const   )176,      (flex_int16_t const   )210, 
        (flex_int16_t const   )208,      (flex_int16_t const   )207,      (flex_int16_t const   )205,      (flex_int16_t const   )204, 
        (flex_int16_t const   )203,      (flex_int16_t const   )201,      (flex_int16_t const   )199,      (flex_int16_t const   )198, 
        (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )195,      (flex_int16_t const   )191, 
        (flex_int16_t const   )189,      (flex_int16_t const   )188,      (flex_int16_t const   )187,      (flex_int16_t const   )186, 
        (flex_int16_t const   )185,      (flex_int16_t const   )184,      (flex_int16_t const   )183,      (flex_int16_t const   )182, 
        (flex_int16_t const   )179,      (flex_int16_t const   )176,      (flex_int16_t const   )175,      (flex_int16_t const   )174, 
        (flex_int16_t const   )173,      (flex_int16_t const   )172,      (flex_int16_t const   )171,      (flex_int16_t const   )167, 
        (flex_int16_t const   )166,      (flex_int16_t const   )165,      (flex_int16_t const   )162,      (flex_int16_t const   )161, 
        (flex_int16_t const   )158,      (flex_int16_t const   )157,      (flex_int16_t const   )156,      (flex_int16_t const   )152, 
        (flex_int16_t const   )151,      (flex_int16_t const   )150,      (flex_int16_t const   )149,      (flex_int16_t const   )75, 
        (flex_int16_t const   )73,      (flex_int16_t const   )146,      (flex_int16_t const   )135,      (flex_int16_t const   )133, 
        (flex_int16_t const   )129,      (flex_int16_t const   )125,      (flex_int16_t const   )119,      (flex_int16_t const   )97, 
        (flex_int16_t const   )96,      (flex_int16_t const   )95,      (flex_int16_t const   )82,      (flex_int16_t const   )81, 
        (flex_int16_t const   )76,      (flex_int16_t const   )75,      (flex_int16_t const   )73,      (flex_int16_t const   )642, 
        (flex_int16_t const   )11,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642};
#line 820 "bsdl_flex.c"
static flex_int16_t const   yy_chk[833]  = 
#line 820
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )34, 
        (flex_int16_t const   )644,      (flex_int16_t const   )7,      (flex_int16_t const   )70,      (flex_int16_t const   )7, 
        (flex_int16_t const   )5,      (flex_int16_t const   )70,      (flex_int16_t const   )5,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )34,      (flex_int16_t const   )5,      (flex_int16_t const   )5, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )5,      (flex_int16_t const   )32, 
        (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )35,      (flex_int16_t const   )32,      (flex_int16_t const   )8,      (flex_int16_t const   )32, 
        (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )639,      (flex_int16_t const   )6, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )35,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )6, 
        (flex_int16_t const   )42,      (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )24,      (flex_int16_t const   )9,      (flex_int16_t const   )41, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )9,      (flex_int16_t const   )40, 
        (flex_int16_t const   )638,      (flex_int16_t const   )41,      (flex_int16_t const   )634,      (flex_int16_t const   )42, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )33,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )40,      (flex_int16_t const   )9,      (flex_int16_t const   )632, 
        (flex_int16_t const   )33,      (flex_int16_t const   )9,      (flex_int16_t const   )40,      (flex_int16_t const   )9, 
        (flex_int16_t const   )33,      (flex_int16_t const   )43,      (flex_int16_t const   )33,      (flex_int16_t const   )44, 
        (flex_int16_t const   )46,      (flex_int16_t const   )45,      (flex_int16_t const   )631,      (flex_int16_t const   )44, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )50,      (flex_int16_t const   )628,      (flex_int16_t const   )49,      (flex_int16_t const   )43, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )50, 
        (flex_int16_t const   )49,      (flex_int16_t const   )46,      (flex_int16_t const   )50,      (flex_int16_t const   )44, 
        (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )49,      (flex_int16_t const   )627, 
        (flex_int16_t const   )46,      (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )58, 
        (flex_int16_t const   )60,      (flex_int16_t const   )53,      (flex_int16_t const   )626,      (flex_int16_t const   )51, 
        (flex_int16_t const   )625,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )57, 
        (flex_int16_t const   )51,      (flex_int16_t const   )58,      (flex_int16_t const   )60,      (flex_int16_t const   )64, 
        (flex_int16_t const   )54,      (flex_int16_t const   )57,      (flex_int16_t const   )48,      (flex_int16_t const   )60, 
        (flex_int16_t const   )53,      (flex_int16_t const   )57,      (flex_int16_t const   )54,      (flex_int16_t const   )57, 
        (flex_int16_t const   )62,      (flex_int16_t const   )64,      (flex_int16_t const   )132,      (flex_int16_t const   )57, 
        (flex_int16_t const   )63,      (flex_int16_t const   )132,      (flex_int16_t const   )62,      (flex_int16_t const   )65, 
        (flex_int16_t const   )63,      (flex_int16_t const   )66,      (flex_int16_t const   )62,      (flex_int16_t const   )225, 
        (flex_int16_t const   )62,      (flex_int16_t const   )66,      (flex_int16_t const   )225,      (flex_int16_t const   )63, 
        (flex_int16_t const   )67,      (flex_int16_t const   )65,      (flex_int16_t const   )63,      (flex_int16_t const   )69, 
        (flex_int16_t const   )621,      (flex_int16_t const   )66,      (flex_int16_t const   )65,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )88,      (flex_int16_t const   )69, 
        (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )67,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )88,      (flex_int16_t const   )88, 
        (flex_int16_t const   )95,      (flex_int16_t const   )68,      (flex_int16_t const   )78,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )99,      (flex_int16_t const   )121, 
        (flex_int16_t const   )95,      (flex_int16_t const   )620,      (flex_int16_t const   )99,      (flex_int16_t const   )99, 
        (flex_int16_t const   )108,      (flex_int16_t const   )108,      (flex_int16_t const   )110,      (flex_int16_t const   )71, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )110,      (flex_int16_t const   )123, 
        (flex_int16_t const   )123,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )121, 
        (flex_int16_t const   )80,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )130, 
        (flex_int16_t const   )619,      (flex_int16_t const   )136,      (flex_int16_t const   )618,      (flex_int16_t const   )78, 
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )142,      (flex_int16_t const   )142, 
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )148,      (flex_int16_t const   )148, 
        (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )148,      (flex_int16_t const   )130, 
        (flex_int16_t const   )130,      (flex_int16_t const   )136,      (flex_int16_t const   )192,      (flex_int16_t const   )192, 
        (flex_int16_t const   )257,      (flex_int16_t const   )257,      (flex_int16_t const   )261,      (flex_int16_t const   )261, 
        (flex_int16_t const   )120,      (flex_int16_t const   )616,      (flex_int16_t const   )215,      (flex_int16_t const   )148, 
        (flex_int16_t const   )215,      (flex_int16_t const   )615,      (flex_int16_t const   )215,      (flex_int16_t const   )215, 
        (flex_int16_t const   )215,      (flex_int16_t const   )215,      (flex_int16_t const   )215,      (flex_int16_t const   )262, 
        (flex_int16_t const   )262,      (flex_int16_t const   )271,      (flex_int16_t const   )271,      (flex_int16_t const   )275, 
        (flex_int16_t const   )275,      (flex_int16_t const   )275,      (flex_int16_t const   )275,      (flex_int16_t const   )275, 
        (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276,      (flex_int16_t const   )276, 
        (flex_int16_t const   )276,      (flex_int16_t const   )368,      (flex_int16_t const   )368,      (flex_int16_t const   )374, 
        (flex_int16_t const   )444,      (flex_int16_t const   )458,      (flex_int16_t const   )614,      (flex_int16_t const   )613, 
        (flex_int16_t const   )611,      (flex_int16_t const   )374,      (flex_int16_t const   )610,      (flex_int16_t const   )458, 
        (flex_int16_t const   )607,      (flex_int16_t const   )444,      (flex_int16_t const   )606,      (flex_int16_t const   )458, 
        (flex_int16_t const   )605,      (flex_int16_t const   )458,      (flex_int16_t const   )604,      (flex_int16_t const   )444, 
        (flex_int16_t const   )458,      (flex_int16_t const   )516,      (flex_int16_t const   )516,      (flex_int16_t const   )603, 
        (flex_int16_t const   )602,      (flex_int16_t const   )516,      (flex_int16_t const   )601,      (flex_int16_t const   )600, 
        (flex_int16_t const   )599,      (flex_int16_t const   )598,      (flex_int16_t const   )516,      (flex_int16_t const   )597, 
        (flex_int16_t const   )596,      (flex_int16_t const   )516,      (flex_int16_t const   )516,      (flex_int16_t const   )595, 
        (flex_int16_t const   )593,      (flex_int16_t const   )516,      (flex_int16_t const   )592,      (flex_int16_t const   )516, 
        (flex_int16_t const   )643,      (flex_int16_t const   )591,      (flex_int16_t const   )643,      (flex_int16_t const   )645, 
        (flex_int16_t const   )590,      (flex_int16_t const   )645,      (flex_int16_t const   )589,      (flex_int16_t const   )588, 
        (flex_int16_t const   )587,      (flex_int16_t const   )586,      (flex_int16_t const   )585,      (flex_int16_t const   )584, 
        (flex_int16_t const   )582,      (flex_int16_t const   )581,      (flex_int16_t const   )580,      (flex_int16_t const   )578, 
        (flex_int16_t const   )575,      (flex_int16_t const   )574,      (flex_int16_t const   )572,      (flex_int16_t const   )571, 
        (flex_int16_t const   )570,      (flex_int16_t const   )569,      (flex_int16_t const   )568,      (flex_int16_t const   )567, 
        (flex_int16_t const   )566,      (flex_int16_t const   )565,      (flex_int16_t const   )564,      (flex_int16_t const   )563, 
        (flex_int16_t const   )562,      (flex_int16_t const   )560,      (flex_int16_t const   )559,      (flex_int16_t const   )557, 
        (flex_int16_t const   )556,      (flex_int16_t const   )554,      (flex_int16_t const   )553,      (flex_int16_t const   )551, 
        (flex_int16_t const   )550,      (flex_int16_t const   )549,      (flex_int16_t const   )547,      (flex_int16_t const   )546, 
        (flex_int16_t const   )545,      (flex_int16_t const   )544,      (flex_int16_t const   )543,      (flex_int16_t const   )542, 
        (flex_int16_t const   )541,      (flex_int16_t const   )540,      (flex_int16_t const   )539,      (flex_int16_t const   )538, 
        (flex_int16_t const   )537,      (flex_int16_t const   )536,      (flex_int16_t const   )535,      (flex_int16_t const   )534, 
        (flex_int16_t const   )533,      (flex_int16_t const   )532,      (flex_int16_t const   )531,      (flex_int16_t const   )530, 
        (flex_int16_t const   )529,      (flex_int16_t const   )527,      (flex_int16_t const   )526,      (flex_int16_t const   )524, 
        (flex_int16_t const   )523,      (flex_int16_t const   )522,      (flex_int16_t const   )521,      (flex_int16_t const   )520, 
        (flex_int16_t const   )519,      (flex_int16_t const   )518,      (flex_int16_t const   )517,      (flex_int16_t const   )515, 
        (flex_int16_t const   )514,      (flex_int16_t const   )513,      (flex_int16_t const   )512,      (flex_int16_t const   )511, 
        (flex_int16_t const   )510,      (flex_int16_t const   )509,      (flex_int16_t const   )508,      (flex_int16_t const   )507, 
        (flex_int16_t const   )506,      (flex_int16_t const   )505,      (flex_int16_t const   )504,      (flex_int16_t const   )503, 
        (flex_int16_t const   )501,      (flex_int16_t const   )500,      (flex_int16_t const   )499,      (flex_int16_t const   )498, 
        (flex_int16_t const   )497,      (flex_int16_t const   )496,      (flex_int16_t const   )495,      (flex_int16_t const   )494, 
        (flex_int16_t const   )493,      (flex_int16_t const   )492,      (flex_int16_t const   )491,      (flex_int16_t const   )490, 
        (flex_int16_t const   )489,      (flex_int16_t const   )488,      (flex_int16_t const   )487,      (flex_int16_t const   )486, 
        (flex_int16_t const   )485,      (flex_int16_t const   )484,      (flex_int16_t const   )483,      (flex_int16_t const   )482, 
        (flex_int16_t const   )481,      (flex_int16_t const   )480,      (flex_int16_t const   )479,      (flex_int16_t const   )478, 
        (flex_int16_t const   )477,      (flex_int16_t const   )476,      (flex_int16_t const   )475,      (flex_int16_t const   )474, 
        (flex_int16_t const   )473,      (flex_int16_t const   )472,      (flex_int16_t const   )471,      (flex_int16_t const   )470, 
        (flex_int16_t const   )469,      (flex_int16_t const   )468,      (flex_int16_t const   )467,      (flex_int16_t const   )466, 
        (flex_int16_t const   )465,      (flex_int16_t const   )464,      (flex_int16_t const   )460,      (flex_int16_t const   )459, 
        (flex_int16_t const   )457,      (flex_int16_t const   )456,      (flex_int16_t const   )455,      (flex_int16_t const   )454, 
        (flex_int16_t const   )453,      (flex_int16_t const   )452,      (flex_int16_t const   )451,      (flex_int16_t const   )450, 
        (flex_int16_t const   )449,      (flex_int16_t const   )448,      (flex_int16_t const   )447,      (flex_int16_t const   )445, 
        (flex_int16_t const   )443,      (flex_int16_t const   )441,      (flex_int16_t const   )439,      (flex_int16_t const   )438, 
        (flex_int16_t const   )437,      (flex_int16_t const   )436,      (flex_int16_t const   )433,      (flex_int16_t const   )432, 
        (flex_int16_t const   )431,      (flex_int16_t const   )430,      (flex_int16_t const   )428,      (flex_int16_t const   )427, 
        (flex_int16_t const   )426,      (flex_int16_t const   )425,      (flex_int16_t const   )424,      (flex_int16_t const   )423, 
        (flex_int16_t const   )422,      (flex_int16_t const   )420,      (flex_int16_t const   )419,      (flex_int16_t const   )418, 
        (flex_int16_t const   )417,      (flex_int16_t const   )416,      (flex_int16_t const   )415,      (flex_int16_t const   )414, 
        (flex_int16_t const   )413,      (flex_int16_t const   )412,      (flex_int16_t const   )411,      (flex_int16_t const   )410, 
        (flex_int16_t const   )409,      (flex_int16_t const   )408,      (flex_int16_t const   )405,      (flex_int16_t const   )404, 
        (flex_int16_t const   )403,      (flex_int16_t const   )402,      (flex_int16_t const   )401,      (flex_int16_t const   )399, 
        (flex_int16_t const   )398,      (flex_int16_t const   )397,      (flex_int16_t const   )396,      (flex_int16_t const   )395, 
        (flex_int16_t const   )394,      (flex_int16_t const   )391,      (flex_int16_t const   )390,      (flex_int16_t const   )389, 
        (flex_int16_t const   )387,      (flex_int16_t const   )386,      (flex_int16_t const   )385,      (flex_int16_t const   )384, 
        (flex_int16_t const   )383,      (flex_int16_t const   )382,      (flex_int16_t const   )381,      (flex_int16_t const   )380, 
        (flex_int16_t const   )379,      (flex_int16_t const   )377,      (flex_int16_t const   )376,      (flex_int16_t const   )373, 
        (flex_int16_t const   )372,      (flex_int16_t const   )371,      (flex_int16_t const   )369,      (flex_int16_t const   )367, 
        (flex_int16_t const   )365,      (flex_int16_t const   )364,      (flex_int16_t const   )363,      (flex_int16_t const   )362, 
        (flex_int16_t const   )361,      (flex_int16_t const   )358,      (flex_int16_t const   )357,      (flex_int16_t const   )355, 
        (flex_int16_t const   )354,      (flex_int16_t const   )353,      (flex_int16_t const   )352,      (flex_int16_t const   )351, 
        (flex_int16_t const   )350,      (flex_int16_t const   )349,      (flex_int16_t const   )348,      (flex_int16_t const   )347, 
        (flex_int16_t const   )346,      (flex_int16_t const   )343,      (flex_int16_t const   )342,      (flex_int16_t const   )341, 
        (flex_int16_t const   )340,      (flex_int16_t const   )339,      (flex_int16_t const   )337,      (flex_int16_t const   )336, 
        (flex_int16_t const   )335,      (flex_int16_t const   )334,      (flex_int16_t const   )333,      (flex_int16_t const   )332, 
        (flex_int16_t const   )331,      (flex_int16_t const   )330,      (flex_int16_t const   )329,      (flex_int16_t const   )328, 
        (flex_int16_t const   )327,      (flex_int16_t const   )325,      (flex_int16_t const   )324,      (flex_int16_t const   )323, 
        (flex_int16_t const   )318,      (flex_int16_t const   )317,      (flex_int16_t const   )316,      (flex_int16_t const   )315, 
        (flex_int16_t const   )313,      (flex_int16_t const   )310,      (flex_int16_t const   )309,      (flex_int16_t const   )308, 
        (flex_int16_t const   )307,      (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )304, 
        (flex_int16_t const   )303,      (flex_int16_t const   )301,      (flex_int16_t const   )300,      (flex_int16_t const   )299, 
        (flex_int16_t const   )298,      (flex_int16_t const   )297,      (flex_int16_t const   )296,      (flex_int16_t const   )295, 
        (flex_int16_t const   )294,      (flex_int16_t const   )292,      (flex_int16_t const   )291,      (flex_int16_t const   )289, 
        (flex_int16_t const   )288,      (flex_int16_t const   )287,      (flex_int16_t const   )286,      (flex_int16_t const   )285, 
        (flex_int16_t const   )284,      (flex_int16_t const   )283,      (flex_int16_t const   )282,      (flex_int16_t const   )281, 
        (flex_int16_t const   )280,      (flex_int16_t const   )279,      (flex_int16_t const   )278,      (flex_int16_t const   )273, 
        (flex_int16_t const   )272,      (flex_int16_t const   )270,      (flex_int16_t const   )269,      (flex_int16_t const   )268, 
        (flex_int16_t const   )267,      (flex_int16_t const   )266,      (flex_int16_t const   )265,      (flex_int16_t const   )264, 
        (flex_int16_t const   )263,      (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )258, 
        (flex_int16_t const   )256,      (flex_int16_t const   )255,      (flex_int16_t const   )254,      (flex_int16_t const   )253, 
        (flex_int16_t const   )252,      (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )247, 
        (flex_int16_t const   )246,      (flex_int16_t const   )245,      (flex_int16_t const   )244,      (flex_int16_t const   )243, 
        (flex_int16_t const   )242,      (flex_int16_t const   )241,      (flex_int16_t const   )240,      (flex_int16_t const   )239, 
        (flex_int16_t const   )238,      (flex_int16_t const   )237,      (flex_int16_t const   )236,      (flex_int16_t const   )235, 
        (flex_int16_t const   )234,      (flex_int16_t const   )233,      (flex_int16_t const   )232,      (flex_int16_t const   )231, 
        (flex_int16_t const   )230,      (flex_int16_t const   )229,      (flex_int16_t const   )228,      (flex_int16_t const   )227, 
        (flex_int16_t const   )226,      (flex_int16_t const   )224,      (flex_int16_t const   )223,      (flex_int16_t const   )222, 
        (flex_int16_t const   )221,      (flex_int16_t const   )218,      (flex_int16_t const   )217,      (flex_int16_t const   )216, 
        (flex_int16_t const   )214,      (flex_int16_t const   )212,      (flex_int16_t const   )211,      (flex_int16_t const   )209, 
        (flex_int16_t const   )208,      (flex_int16_t const   )206,      (flex_int16_t const   )205,      (flex_int16_t const   )204, 
        (flex_int16_t const   )203,      (flex_int16_t const   )202,      (flex_int16_t const   )201,      (flex_int16_t const   )200, 
        (flex_int16_t const   )199,      (flex_int16_t const   )198,      (flex_int16_t const   )197,      (flex_int16_t const   )196, 
        (flex_int16_t const   )195,      (flex_int16_t const   )194,      (flex_int16_t const   )193,      (flex_int16_t const   )191, 
        (flex_int16_t const   )190,      (flex_int16_t const   )189,      (flex_int16_t const   )188,      (flex_int16_t const   )187, 
        (flex_int16_t const   )186,      (flex_int16_t const   )185,      (flex_int16_t const   )184,      (flex_int16_t const   )183, 
        (flex_int16_t const   )182,      (flex_int16_t const   )181,      (flex_int16_t const   )180,      (flex_int16_t const   )179, 
        (flex_int16_t const   )178,      (flex_int16_t const   )177,      (flex_int16_t const   )176,      (flex_int16_t const   )175, 
        (flex_int16_t const   )174,      (flex_int16_t const   )171,      (flex_int16_t const   )170,      (flex_int16_t const   )169, 
        (flex_int16_t const   )168,      (flex_int16_t const   )167,      (flex_int16_t const   )166,      (flex_int16_t const   )165, 
        (flex_int16_t const   )164,      (flex_int16_t const   )162,      (flex_int16_t const   )161,      (flex_int16_t const   )160, 
        (flex_int16_t const   )159,      (flex_int16_t const   )158,      (flex_int16_t const   )157,      (flex_int16_t const   )156, 
        (flex_int16_t const   )155,      (flex_int16_t const   )154,      (flex_int16_t const   )153,      (flex_int16_t const   )152, 
        (flex_int16_t const   )151,      (flex_int16_t const   )150,      (flex_int16_t const   )146,      (flex_int16_t const   )145, 
        (flex_int16_t const   )144,      (flex_int16_t const   )143,      (flex_int16_t const   )141,      (flex_int16_t const   )140, 
        (flex_int16_t const   )138,      (flex_int16_t const   )137,      (flex_int16_t const   )135,      (flex_int16_t const   )134, 
        (flex_int16_t const   )133,      (flex_int16_t const   )131,      (flex_int16_t const   )129,      (flex_int16_t const   )128, 
        (flex_int16_t const   )127,      (flex_int16_t const   )126,      (flex_int16_t const   )125,      (flex_int16_t const   )122, 
        (flex_int16_t const   )119,      (flex_int16_t const   )118,      (flex_int16_t const   )117,      (flex_int16_t const   )115, 
        (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )112,      (flex_int16_t const   )111, 
        (flex_int16_t const   )109,      (flex_int16_t const   )107,      (flex_int16_t const   )106,      (flex_int16_t const   )105, 
        (flex_int16_t const   )104,      (flex_int16_t const   )102,      (flex_int16_t const   )101,      (flex_int16_t const   )98, 
        (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )94,      (flex_int16_t const   )93, 
        (flex_int16_t const   )91,      (flex_int16_t const   )90,      (flex_int16_t const   )89,      (flex_int16_t const   )87, 
        (flex_int16_t const   )86,      (flex_int16_t const   )85,      (flex_int16_t const   )84,      (flex_int16_t const   )74, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )61,      (flex_int16_t const   )59, 
        (flex_int16_t const   )55,      (flex_int16_t const   )52,      (flex_int16_t const   )47,      (flex_int16_t const   )38, 
        (flex_int16_t const   )37,      (flex_int16_t const   )36,      (flex_int16_t const   )28,      (flex_int16_t const   )26, 
        (flex_int16_t const   )22,      (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )11, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642,      (flex_int16_t const   )642, 
        (flex_int16_t const   )642};
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/bsdl/bsdl.h"
void *bsdl_flex_init(FILE *f ) ;
#line 141
void bsdl_flex_deinit(void *scanner ) ;
#line 142
void bsdl_flex_switch_file(void *scanner , char *filename ) ;
#line 143
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer ) ;
#line 145
int bsdl_flex_postinc_compile_errors(void *scanner ) ;
#line 146
int bsdl_flex_get_lineno(void *scanner ) ;
#line 147
void bsdl_flex_set_bin_x(void *scanner ) ;
#line 137 "bsdl_flex.l"
static char *new_string(char const   *str ) ;
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 1124 "bsdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) ;
#line 1133
int bsdllex_destroy(yyscan_t yyscanner ) ;
#line 1135
int bsdlget_debug(yyscan_t yyscanner ) ;
#line 1137
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 1139
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) ;
#line 1141
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 1143
FILE *bsdlget_in(yyscan_t yyscanner ) ;
#line 1145
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 1147
FILE *bsdlget_out(yyscan_t yyscanner ) ;
#line 1149
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 1151
int bsdlget_leng(yyscan_t yyscanner ) ;
#line 1153
char *bsdlget_text(yyscan_t yyscanner ) ;
#line 1155
int bsdlget_lineno(yyscan_t yyscanner ) ;
#line 1157
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 1159
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) ;
#line 1161
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1171
int bsdlwrap(yyscan_t scanner ) ;
#line 1270
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1294 "bsdl_flex.c"
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t *yyg ;
  void *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1299
  yyg = (struct yyguts_t *)yyscanner;
#line 1305
  yyg->yylval_r = yylval_param;
#line 1307
  if (! yyg->yy_init) {
#line 1309
    yyg->yy_init = 1;
#line 1316
    if (! yyg->yy_state_buf) {
      {
#line 1317
      tmp = bsdlalloc((yy_size_t )(16386UL * sizeof(yy_state_type )), yyscanner);
#line 1317
      yyg->yy_state_buf = (yy_state_type *)tmp;
      }
    }
#line 1319
    if (! yyg->yy_start) {
#line 1320
      yyg->yy_start = 1;
    }
#line 1322
    if (! yyg->yyin_r) {
#line 1323
      yyg->yyin_r = stdin;
    }
#line 1325
    if (! yyg->yyout_r) {
#line 1326
      yyg->yyout_r = stdout;
    }
#line 1328
    if (yyg->yy_buffer_stack) {
#line 1328
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1328
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1328
    if (! tmp___0) {
      {
#line 1329
      bsdlensure_buffer_stack(yyscanner);
#line 1330
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                              16384,
                                                                              yyscanner);
      }
    }
    {
#line 1334
    bsdl_load_buffer_state(yyscanner);
    }
  }
  {
#line 1337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1339
    yy_cp = yyg->yy_c_buf_p;
#line 1342
    *yy_cp = yyg->yy_hold_char;
#line 1347
    yy_bp = yy_cp;
#line 1349
    yy_current_state = yyg->yy_start;
#line 1351
    yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1352
    tmp___1 = yyg->yy_state_ptr;
#line 1352
    (yyg->yy_state_ptr) ++;
#line 1352
    *tmp___1 = yy_current_state;
    yy_match: 
    {
#line 1355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1357
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 1358
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1358
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1358
          goto while_break___1;
        }
#line 1360
        yy_current_state = (int )yy_def[yy_current_state];
#line 1361
        if (yy_current_state >= 643) {
#line 1362
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1364
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1365
      tmp___2 = yyg->yy_state_ptr;
#line 1365
      (yyg->yy_state_ptr) ++;
#line 1365
      *tmp___2 = yy_current_state;
#line 1366
      yy_cp ++;
#line 1355
      if (! ((int const   )yy_base[yy_current_state] != 780)) {
#line 1355
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1371
    (yyg->yy_state_ptr) --;
#line 1371
    yy_current_state = *(yyg->yy_state_ptr);
#line 1372
    yyg->yy_lp = (int )yy_accept[yy_current_state];
    find_rule: 
    {
#line 1374
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1376
      if (yyg->yy_lp) {
#line 1376
        if (yyg->yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 1378
          yy_act = (int )yy_acclist[yyg->yy_lp];
#line 1380
          yyg->yy_full_match = yy_cp;
#line 1381
          goto while_break___2;
        }
      }
#line 1384
      yy_cp --;
#line 1385
      (yyg->yy_state_ptr) --;
#line 1385
      yy_current_state = *(yyg->yy_state_ptr);
#line 1386
      yyg->yy_lp = (int )yy_accept[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1389
    yyg->yytext_r = yy_bp;
#line 1389
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 1389
    yyg->yy_hold_char = *yy_cp;
#line 1389
    *yy_cp = (char )'\000';
#line 1389
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1395
    if (yy_act == 1) {
#line 1395
      goto case_1;
    }
#line 276
    if (yy_act == 2) {
#line 276 "bsdl_flex.l"
      goto case_2;
    }
#line 278
    if (yy_act == 3) {
#line 278
      goto case_3;
    }
#line 279
    if (yy_act == 4) {
#line 279
      goto case_4;
    }
#line 280
    if (yy_act == 5) {
#line 280
      goto case_5;
    }
#line 281
    if (yy_act == 6) {
#line 281
      goto case_6;
    }
#line 282
    if (yy_act == 7) {
#line 282
      goto case_7;
    }
#line 283
    if (yy_act == 8) {
#line 283
      goto case_8;
    }
#line 284
    if (yy_act == 9) {
#line 284
      goto case_9;
    }
#line 287
    if (yy_act == 10) {
#line 287
      goto case_10;
    }
#line 288
    if (yy_act == 11) {
#line 288
      goto case_11;
    }
#line 289
    if (yy_act == 12) {
#line 289
      goto case_12;
    }
#line 290
    if (yy_act == 13) {
#line 290
      goto case_13;
    }
#line 291
    if (yy_act == 14) {
#line 291
      goto case_14;
    }
#line 292
    if (yy_act == 15) {
#line 292
      goto case_15;
    }
#line 293
    if (yy_act == 16) {
#line 293
      goto case_16;
    }
#line 294
    if (yy_act == 17) {
#line 294
      goto case_17;
    }
#line 295
    if (yy_act == 18) {
#line 295
      goto case_18;
    }
#line 296
    if (yy_act == 19) {
#line 296
      goto case_19;
    }
#line 297
    if (yy_act == 20) {
#line 297
      goto case_20;
    }
#line 298
    if (yy_act == 21) {
#line 298
      goto case_21;
    }
#line 299
    if (yy_act == 22) {
#line 299
      goto case_22;
    }
#line 300
    if (yy_act == 23) {
#line 300
      goto case_23;
    }
#line 301
    if (yy_act == 24) {
#line 301
      goto case_24;
    }
#line 302
    if (yy_act == 25) {
#line 302
      goto case_25;
    }
#line 303
    if (yy_act == 26) {
#line 303
      goto case_26;
    }
#line 304
    if (yy_act == 27) {
#line 304
      goto case_27;
    }
#line 305
    if (yy_act == 28) {
#line 305
      goto case_28;
    }
#line 306
    if (yy_act == 29) {
#line 306
      goto case_29;
    }
#line 307
    if (yy_act == 30) {
#line 307
      goto case_30;
    }
#line 308
    if (yy_act == 31) {
#line 308
      goto case_31;
    }
#line 309
    if (yy_act == 32) {
#line 309
      goto case_32;
    }
#line 310
    if (yy_act == 33) {
#line 310
      goto case_33;
    }
#line 311
    if (yy_act == 34) {
#line 311
      goto case_34;
    }
#line 312
    if (yy_act == 35) {
#line 312
      goto case_35;
    }
#line 313
    if (yy_act == 36) {
#line 313
      goto case_36;
    }
#line 314
    if (yy_act == 37) {
#line 314
      goto case_37;
    }
#line 315
    if (yy_act == 38) {
#line 315
      goto case_38;
    }
#line 316
    if (yy_act == 39) {
#line 316
      goto case_39;
    }
#line 317
    if (yy_act == 40) {
#line 317
      goto case_40;
    }
#line 318
    if (yy_act == 41) {
#line 318
      goto case_41;
    }
#line 319
    if (yy_act == 42) {
#line 319
      goto case_42;
    }
#line 320
    if (yy_act == 43) {
#line 320
      goto case_43;
    }
#line 321
    if (yy_act == 44) {
#line 321
      goto case_44;
    }
#line 323
    if (yy_act == 45) {
#line 323
      goto case_45;
    }
#line 325
    if (yy_act == 46) {
#line 325
      goto case_46;
    }
#line 326
    if (yy_act == 47) {
#line 326
      goto case_47;
    }
#line 327
    if (yy_act == 48) {
#line 327
      goto case_48;
    }
#line 328
    if (yy_act == 49) {
#line 328
      goto case_49;
    }
#line 329
    if (yy_act == 50) {
#line 329
      goto case_50;
    }
#line 330
    if (yy_act == 51) {
#line 330
      goto case_51;
    }
#line 331
    if (yy_act == 52) {
#line 331
      goto case_52;
    }
#line 332
    if (yy_act == 53) {
#line 332
      goto case_53;
    }
#line 333
    if (yy_act == 54) {
#line 333
      goto case_54;
    }
#line 334
    if (yy_act == 55) {
#line 334
      goto case_55;
    }
#line 335
    if (yy_act == 56) {
#line 335
      goto case_56;
    }
#line 336
    if (yy_act == 57) {
#line 336
      goto case_57;
    }
#line 337
    if (yy_act == 58) {
#line 337
      goto case_58;
    }
#line 338
    if (yy_act == 59) {
#line 338
      goto case_59;
    }
#line 339
    if (yy_act == 60) {
#line 339
      goto case_60;
    }
#line 340
    if (yy_act == 61) {
#line 340
      goto case_61;
    }
#line 341
    if (yy_act == 62) {
#line 341
      goto case_62;
    }
#line 342
    if (yy_act == 63) {
#line 342
      goto case_63;
    }
#line 343
    if (yy_act == 64) {
#line 343
      goto case_64;
    }
#line 344
    if (yy_act == 65) {
#line 344
      goto case_65;
    }
#line 345
    if (yy_act == 66) {
#line 345
      goto case_66;
    }
#line 346
    if (yy_act == 67) {
#line 346
      goto case_67;
    }
#line 347
    if (yy_act == 68) {
#line 347
      goto case_68;
    }
#line 348
    if (yy_act == 69) {
#line 348
      goto case_69;
    }
#line 349
    if (yy_act == 70) {
#line 349
      goto case_70;
    }
#line 350
    if (yy_act == 71) {
#line 350
      goto case_71;
    }
#line 351
    if (yy_act == 72) {
#line 351
      goto case_72;
    }
#line 352
    if (yy_act == 73) {
#line 352
      goto case_73;
    }
#line 353
    if (yy_act == 74) {
#line 353
      goto case_74;
    }
#line 354
    if (yy_act == 75) {
#line 354
      goto case_75;
    }
#line 355
    if (yy_act == 76) {
#line 355
      goto case_76;
    }
#line 356
    if (yy_act == 77) {
#line 356
      goto case_77;
    }
#line 357
    if (yy_act == 78) {
#line 357
      goto case_78;
    }
#line 358
    if (yy_act == 79) {
#line 358
      goto case_79;
    }
#line 359
    if (yy_act == 80) {
#line 359
      goto case_80;
    }
#line 360
    if (yy_act == 81) {
#line 360
      goto case_81;
    }
#line 361
    if (yy_act == 82) {
#line 361
      goto case_82;
    }
#line 362
    if (yy_act == 83) {
#line 362
      goto case_83;
    }
#line 363
    if (yy_act == 84) {
#line 363
      goto case_84;
    }
#line 364
    if (yy_act == 85) {
#line 364
      goto case_85;
    }
#line 365
    if (yy_act == 86) {
#line 365
      goto case_86;
    }
#line 366
    if (yy_act == 87) {
#line 366
      goto case_87;
    }
#line 367
    if (yy_act == 88) {
#line 367
      goto case_88;
    }
#line 368
    if (yy_act == 89) {
#line 368
      goto case_89;
    }
#line 369
    if (yy_act == 90) {
#line 369
      goto case_90;
    }
#line 370
    if (yy_act == 91) {
#line 370
      goto case_91;
    }
#line 371
    if (yy_act == 92) {
#line 371
      goto case_92;
    }
#line 372
    if (yy_act == 93) {
#line 372
      goto case_93;
    }
#line 373
    if (yy_act == 94) {
#line 373
      goto case_94;
    }
#line 374
    if (yy_act == 95) {
#line 374
      goto case_95;
    }
#line 375
    if (yy_act == 96) {
#line 375
      goto case_96;
    }
#line 376
    if (yy_act == 97) {
#line 376
      goto case_97;
    }
#line 377
    if (yy_act == 98) {
#line 377
      goto case_98;
    }
#line 378
    if (yy_act == 99) {
#line 378
      goto case_99;
    }
#line 379
    if (yy_act == 100) {
#line 379
      goto case_100;
    }
#line 380
    if (yy_act == 101) {
#line 380
      goto case_101;
    }
#line 381
    if (yy_act == 102) {
#line 381
      goto case_102;
    }
#line 382
    if (yy_act == 103) {
#line 382
      goto case_103;
    }
#line 383
    if (yy_act == 104) {
#line 383
      goto case_104;
    }
#line 384
    if (yy_act == 105) {
#line 384
      goto case_105;
    }
#line 385
    if (yy_act == 106) {
#line 385
      goto case_106;
    }
#line 386
    if (yy_act == 107) {
#line 386
      goto case_107;
    }
#line 387
    if (yy_act == 108) {
#line 387
      goto case_108;
    }
#line 388
    if (yy_act == 109) {
#line 388
      goto case_109;
    }
#line 389
    if (yy_act == 110) {
#line 389
      goto case_110;
    }
#line 390
    if (yy_act == 111) {
#line 390
      goto case_111;
    }
#line 391
    if (yy_act == 112) {
#line 391
      goto case_112;
    }
#line 394
    if (yy_act == 113) {
#line 394
      goto case_113;
    }
#line 396
    if (yy_act == 114) {
#line 396
      goto case_114;
    }
#line 398
    if (yy_act == 115) {
#line 398
      goto case_115;
    }
#line 401
    if (yy_act == 116) {
#line 401
      goto case_116;
    }
#line 404
    if (yy_act == 117) {
#line 404
      goto case_117;
    }
#line 406
    if (yy_act == 118) {
#line 406
      goto case_118;
    }
#line 407
    if (yy_act == 119) {
#line 407
      goto case_119;
    }
#line 408
    if (yy_act == 120) {
#line 408
      goto case_120;
    }
#line 418
    if (yy_act == 127) {
#line 418
      goto case_127;
    }
#line 418
    if (yy_act == 126) {
#line 418
      goto case_127;
    }
#line 418
    if (yy_act == 125) {
#line 418
      goto case_127;
    }
#line 418
    if (yy_act == 124) {
#line 418
      goto case_127;
    }
#line 418
    if (yy_act == 123) {
#line 418
      goto case_127;
    }
#line 419
    if (yy_act == 121) {
#line 419
      goto case_121;
    }
#line 2034
    if (yy_act == 122) {
#line 2034 "bsdl_flex.c"
      goto case_122;
    }
#line 2156
    goto switch_default;
    case_1: /* CIL Label */ 
#line 274 "bsdl_flex.l"
    return (258);
#line 275
    goto switch_break;
    case_2: /* CIL Label */ 
#line 275
    (yyg->yyextra_r)->Base = 1;
#line 276
    return (259);
#line 277
    goto switch_break;
    case_3: /* CIL Label */ 
#line 277
    (yyg->yyextra_r)->Base = 1;
#line 277
    return (260);
#line 278
    goto switch_break;
    case_4: /* CIL Label */ 
#line 278
    (yyg->yyextra_r)->Base = 1;
#line 278
    return (261);
#line 279
    goto switch_break;
    case_5: /* CIL Label */ 
#line 279
    (yyg->yyextra_r)->Base = 1;
#line 279
    return (262);
#line 280
    goto switch_break;
    case_6: /* CIL Label */ 
#line 280
    return (263);
#line 281
    goto switch_break;
    case_7: /* CIL Label */ 
#line 281
    (yyg->yyextra_r)->Base = 1;
#line 281
    return (265);
#line 282
    goto switch_break;
    case_8: /* CIL Label */ 
#line 282
    return (266);
#line 283
    goto switch_break;
    case_9: /* CIL Label */ 
#line 283
    (yyg->yyextra_r)->Base = 1;
#line 284
    yyg->yy_start = 1;
#line 285
    return (267);
#line 286
    goto switch_break;
    case_10: /* CIL Label */ 
#line 286
    return (268);
#line 287
    goto switch_break;
    case_11: /* CIL Label */ 
#line 287
    return (264);
#line 288
    goto switch_break;
    case_12: /* CIL Label */ 
#line 288
    return (269);
#line 289
    goto switch_break;
    case_13: /* CIL Label */ 
#line 289
    return (270);
#line 290
    goto switch_break;
    case_14: /* CIL Label */ 
#line 290
    return (271);
#line 291
    goto switch_break;
    case_15: /* CIL Label */ 
#line 291
    return (272);
#line 292
    goto switch_break;
    case_16: /* CIL Label */ 
#line 292
    return (273);
#line 293
    goto switch_break;
    case_17: /* CIL Label */ 
#line 293
    return (274);
#line 294
    goto switch_break;
    case_18: /* CIL Label */ 
#line 294
    return (275);
#line 295
    goto switch_break;
    case_19: /* CIL Label */ 
#line 295
    return (276);
#line 296
    goto switch_break;
    case_20: /* CIL Label */ 
#line 296
    return (279);
#line 297
    goto switch_break;
    case_21: /* CIL Label */ 
#line 297
    return (277);
#line 298
    goto switch_break;
    case_22: /* CIL Label */ 
#line 298
    return (278);
#line 299
    goto switch_break;
    case_23: /* CIL Label */ 
#line 299
    return (280);
#line 300
    goto switch_break;
    case_24: /* CIL Label */ 
#line 300
    return (281);
#line 301
    goto switch_break;
    case_25: /* CIL Label */ 
#line 301
    return (282);
#line 302
    goto switch_break;
    case_26: /* CIL Label */ 
#line 302
    return (283);
#line 303
    goto switch_break;
    case_27: /* CIL Label */ 
#line 303
    return (284);
#line 304
    goto switch_break;
    case_28: /* CIL Label */ 
#line 304
    return (285);
#line 305
    goto switch_break;
    case_29: /* CIL Label */ 
#line 305
    return (286);
#line 306
    goto switch_break;
    case_30: /* CIL Label */ 
#line 306
    return (287);
#line 307
    goto switch_break;
    case_31: /* CIL Label */ 
#line 307
    return (288);
#line 308
    goto switch_break;
    case_32: /* CIL Label */ 
#line 308
    return (289);
#line 309
    goto switch_break;
    case_33: /* CIL Label */ 
#line 309
    return (290);
#line 310
    goto switch_break;
    case_34: /* CIL Label */ 
#line 310
    return (291);
#line 311
    goto switch_break;
    case_35: /* CIL Label */ 
#line 311
    return (292);
#line 312
    goto switch_break;
    case_36: /* CIL Label */ 
#line 312
    return (293);
#line 313
    goto switch_break;
    case_37: /* CIL Label */ 
#line 313
    return (294);
#line 314
    goto switch_break;
    case_38: /* CIL Label */ 
#line 314
    return (295);
#line 315
    goto switch_break;
    case_39: /* CIL Label */ 
#line 315
    (yyg->yyextra_r)->Base = 1;
#line 315
    return (296);
#line 316
    goto switch_break;
    case_40: /* CIL Label */ 
#line 316
    return (297);
#line 317
    goto switch_break;
    case_41: /* CIL Label */ 
#line 317
    return (298);
#line 318
    goto switch_break;
    case_42: /* CIL Label */ 
#line 318
    yyg->yy_start = 9;
#line 318
    return (299);
#line 319
    goto switch_break;
    case_43: /* CIL Label */ 
#line 319
    return (300);
#line 320
    goto switch_break;
    case_44: /* CIL Label */ 
#line 320
    (yyg->yyextra_r)->Base = 0;
#line 321
    return (301);
#line 322
    goto switch_break;
    case_45: /* CIL Label */ 
#line 322
    (yyg->yyextra_r)->Base = 2;
#line 323
    return (302);
#line 324
    goto switch_break;
    case_46: /* CIL Label */ 
#line 324
    return (303);
#line 325
    goto switch_break;
    case_47: /* CIL Label */ 
#line 325
    return (304);
#line 326
    goto switch_break;
    case_48: /* CIL Label */ 
#line 326
    return (305);
#line 327
    goto switch_break;
    case_49: /* CIL Label */ 
#line 327
    return (306);
#line 328
    goto switch_break;
    case_50: /* CIL Label */ 
#line 328
    return (307);
#line 329
    goto switch_break;
    case_51: /* CIL Label */ 
#line 329
    yyg->yy_start = 7;
#line 329
    return (308);
#line 330
    goto switch_break;
    case_52: /* CIL Label */ 
#line 330
    return (309);
#line 331
    goto switch_break;
    case_53: /* CIL Label */ 
#line 331
    return (310);
#line 332
    goto switch_break;
    case_54: /* CIL Label */ 
#line 332
    yyg->yy_start = 5;
#line 332
    return (311);
#line 333
    goto switch_break;
    case_55: /* CIL Label */ 
#line 333
    (yyg->yyextra_r)->Base = 2;
#line 333
    return (312);
#line 334
    goto switch_break;
    case_56: /* CIL Label */ 
#line 334
    (yyg->yyextra_r)->Base = 2;
#line 334
    return (313);
#line 335
    goto switch_break;
    case_57: /* CIL Label */ 
#line 335
    return (314);
#line 336
    goto switch_break;
    case_58: /* CIL Label */ 
#line 336
    return (368);
#line 337
    goto switch_break;
    case_59: /* CIL Label */ 
#line 337
    return (369);
#line 338
    goto switch_break;
    case_60: /* CIL Label */ 
#line 338
    return (370);
#line 339
    goto switch_break;
    case_61: /* CIL Label */ 
#line 339
    return (371);
#line 340
    goto switch_break;
    case_62: /* CIL Label */ 
#line 340
    return (372);
#line 341
    goto switch_break;
    case_63: /* CIL Label */ 
#line 341
    (yyg->yyextra_r)->Base = 1;
#line 341
    return (373);
#line 342
    goto switch_break;
    case_64: /* CIL Label */ 
#line 342
    return (315);
#line 343
    goto switch_break;
    case_65: /* CIL Label */ 
#line 343
    return (316);
#line 344
    goto switch_break;
    case_66: /* CIL Label */ 
#line 344
    return (317);
#line 345
    goto switch_break;
    case_67: /* CIL Label */ 
#line 345
    return (318);
#line 346
    goto switch_break;
    case_68: /* CIL Label */ 
#line 346
    return (320);
#line 347
    goto switch_break;
    case_69: /* CIL Label */ 
#line 347
    return (319);
#line 348
    goto switch_break;
    case_70: /* CIL Label */ 
#line 348
    return (321);
#line 349
    goto switch_break;
    case_71: /* CIL Label */ 
#line 349
    return (322);
#line 350
    goto switch_break;
    case_72: /* CIL Label */ 
#line 350
    return (323);
#line 351
    goto switch_break;
    case_73: /* CIL Label */ 
#line 351
    return (325);
#line 352
    goto switch_break;
    case_74: /* CIL Label */ 
#line 352
    return (324);
#line 353
    goto switch_break;
    case_75: /* CIL Label */ 
#line 353
    return (326);
#line 354
    goto switch_break;
    case_76: /* CIL Label */ 
#line 354
    return (327);
#line 355
    goto switch_break;
    case_77: /* CIL Label */ 
#line 355
    return (374);
#line 356
    goto switch_break;
    case_78: /* CIL Label */ 
#line 356
    return (328);
#line 357
    goto switch_break;
    case_79: /* CIL Label */ 
#line 357
    return (329);
#line 358
    goto switch_break;
    case_80: /* CIL Label */ 
#line 358
    return (330);
#line 359
    goto switch_break;
    case_81: /* CIL Label */ 
#line 359
    return (331);
#line 360
    goto switch_break;
    case_82: /* CIL Label */ 
#line 360
    return (332);
#line 361
    goto switch_break;
    case_83: /* CIL Label */ 
#line 361
    return (333);
#line 362
    goto switch_break;
    case_84: /* CIL Label */ 
#line 362
    return (334);
#line 363
    goto switch_break;
    case_85: /* CIL Label */ 
#line 363
    return (335);
#line 364
    goto switch_break;
    case_86: /* CIL Label */ 
#line 364
    return (336);
#line 365
    goto switch_break;
    case_87: /* CIL Label */ 
#line 365
    return (337);
#line 366
    goto switch_break;
    case_88: /* CIL Label */ 
#line 366
    return (338);
#line 367
    goto switch_break;
    case_89: /* CIL Label */ 
#line 367
    return (339);
#line 368
    goto switch_break;
    case_90: /* CIL Label */ 
#line 368
    return (340);
#line 369
    goto switch_break;
    case_91: /* CIL Label */ 
#line 369
    return (341);
#line 370
    goto switch_break;
    case_92: /* CIL Label */ 
#line 370
    return (342);
#line 371
    goto switch_break;
    case_93: /* CIL Label */ 
#line 371
    return (343);
#line 372
    goto switch_break;
    case_94: /* CIL Label */ 
#line 372
    return (344);
#line 373
    goto switch_break;
    case_95: /* CIL Label */ 
#line 373
    return (346);
#line 374
    goto switch_break;
    case_96: /* CIL Label */ 
#line 374
    return (347);
#line 375
    goto switch_break;
    case_97: /* CIL Label */ 
#line 375
    return (348);
#line 376
    goto switch_break;
    case_98: /* CIL Label */ 
#line 376
    ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno) ++;
#line 377
    goto switch_break;
    case_99: /* CIL Label */ 
#line 377
    return (357);
#line 378
    goto switch_break;
    case_100: /* CIL Label */ 
#line 378
    return (358);
#line 379
    goto switch_break;
    case_101: /* CIL Label */ 
#line 379
    return (359);
#line 380
    goto switch_break;
    case_102: /* CIL Label */ 
#line 380
    return (366);
#line 381
    goto switch_break;
    case_103: /* CIL Label */ 
#line 381
    return (360);
#line 382
    goto switch_break;
    case_104: /* CIL Label */ 
#line 382
    return (361);
#line 383
    goto switch_break;
    case_105: /* CIL Label */ 
#line 383
    return (362);
#line 384
    goto switch_break;
    case_106: /* CIL Label */ 
#line 384
    return (363);
#line 385
    goto switch_break;
    case_107: /* CIL Label */ 
#line 385
    return (364);
#line 386
    goto switch_break;
    case_108: /* CIL Label */ 
#line 386
    (yyg->yyextra_r)->Base = 2;
#line 386
    return (349);
#line 387
    goto switch_break;
    case_109: /* CIL Label */ 
#line 387
    return (365);
#line 388
    goto switch_break;
    case_110: /* CIL Label */ ;
#line 389
    goto switch_break;
    case_111: /* CIL Label */ ;
#line 390
    goto switch_break;
    case_112: /* CIL Label */ 
#line 390
    if ((yyg->yyextra_r)->Base != 2) {
#line 390
      *yy_cp = yyg->yy_hold_char;
#line 390
      yy_cp = yyg->yy_full_match;
#line 390
      (yyg->yy_lp) ++;
#line 390
      goto find_rule;
    }
    {
#line 391
    (yyg->yylval_r)->str = new_string((char const   *)yyg->yytext_r);
    }
#line 392
    return (353);
#line 393
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 393
    (yyg->yylval_r)->str = new_string((char const   *)yyg->yytext_r);
    }
#line 394
    return (345);
#line 395
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 395
    (yyg->yylval_r)->str = new_string((char const   *)yyg->yytext_r);
    }
#line 396
    return (350);
#line 397
    goto switch_break;
    case_115: /* CIL Label */ 
#line 397
    if ((yyg->yyextra_r)->Base != 0) {
#line 397
      *yy_cp = yyg->yy_hold_char;
#line 397
      yy_cp = yyg->yy_full_match;
#line 397
      (yyg->yy_lp) ++;
#line 397
      goto find_rule;
    }
    {
#line 398
    (yyg->yylval_r)->str = new_string((char const   *)yyg->yytext_r);
    }
#line 399
    return (352);
#line 400
    goto switch_break;
    case_116: /* CIL Label */ 
#line 400
    if ((yyg->yyextra_r)->Base != 1) {
#line 400
      *yy_cp = yyg->yy_hold_char;
#line 400
      yy_cp = yyg->yy_full_match;
#line 400
      (yyg->yy_lp) ++;
#line 400
      goto find_rule;
    }
    {
#line 401
    (yyg->yylval_r)->integer = atoi((char const   *)yyg->yytext_r);
    }
#line 402
    return (351);
#line 403
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 403
    (yyg->yylval_r)->str = new_string((char const   *)yyg->yytext_r);
    }
#line 404
    return (354);
#line 405
    goto switch_break;
    case_118: /* CIL Label */ 
#line 405
    return (355);
#line 406
    goto switch_break;
    case_119: /* CIL Label */ 
#line 406
    return (356);
#line 407
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 407
    bsdl_msg(2, "Error: Illegal character %c (/%03o) at line %d:\n", (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)),
             (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)), (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
#line 411
    ((yyg->yyextra_r)->Compile_Errors) ++;
    }
#line 412
    return (367);
#line 413
    goto switch_break;
    case_127: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    {
#line 414
    bsdlpop_buffer_state(yyscanner);
    }
#line 415
    if (yyg->yy_buffer_stack) {
#line 415
      tmp___3 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 415
      tmp___3 = (YY_BUFFER_STATE )((void *)0);
    }
#line 415
    if (! tmp___3) {
#line 416
      return (0);
    }
#line 418
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 418
    fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
           (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
    }
#line 419
    goto switch_break;
    case_122: /* CIL Label */ 
#line 2037 "bsdl_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 2040
    *yy_cp = yyg->yy_hold_char;
#line 2043
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 2054
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2055
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 2056
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 2066
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 2070
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2072
      yy_current_state = yy_get_previous_state(yyscanner);
#line 2083
      yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);
#line 2085
      yy_bp = yyg->yytext_r + 0;
      }
#line 2087
      if (yy_next_state) {
#line 2090
        (yyg->yy_c_buf_p) ++;
#line 2090
        yy_cp = yyg->yy_c_buf_p;
#line 2091
        yy_current_state = yy_next_state;
#line 2092
        goto yy_match;
      } else {
#line 2097
        yy_cp = yyg->yy_c_buf_p;
#line 2098
        goto yy_find_action;
      }
    } else {
      {
#line 2102
      tmp___4 = yy_get_next_buffer(yyscanner);
      }
      {
#line 2104
      if (tmp___4 == 1) {
#line 2104
        goto case_1___0;
      }
#line 2133
      if (tmp___4 == 0) {
#line 2133
        goto case_0;
      }
#line 2143
      if (tmp___4 == 2) {
#line 2143
        goto case_2___0;
      }
#line 2102
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 2106
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 2108
      tmp___5 = bsdlwrap(yyscanner);
      }
#line 2108
      if (tmp___5) {
#line 2119
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 2121
        yy_act = (122 + (yyg->yy_start - 1) / 2) + 1;
#line 2122
        goto do_action;
      } else
#line 2127
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 2128
        bsdlrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 2130
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 2134
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2137
      yy_current_state = yy_get_previous_state(yyscanner);
#line 2139
      yy_cp = yyg->yy_c_buf_p;
#line 2140
      yy_bp = yyg->yytext_r + 0;
      }
#line 2141
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 2144
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 2147
      yy_current_state = yy_get_previous_state(yyscanner);
#line 2149
      yy_cp = yyg->yy_c_buf_p;
#line 2150
      yy_bp = yyg->yytext_r + 0;
      }
#line 2151
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2153
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2157
    yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2170 "bsdl_flex.c"
static int yy_get_next_buffer(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  int c ;
  size_t n ;
  size_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 2172
  yyg = (struct yyguts_t *)yyscanner;
#line 2173
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 2174
  source = yyg->yytext_r;
#line 2178
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 2179
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed", yyscanner);
    }
  }
#line 2182
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 2184
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 2189
      return (1);
    } else {
#line 2197
      return (2);
    }
  }
#line 2204
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 2206
  i = 0;
  {
#line 2206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2206
    if (! (i < number_to_move)) {
#line 2206
      goto while_break;
    }
#line 2207
    tmp = dest;
#line 2207
    dest ++;
#line 2207
    tmp___0 = source;
#line 2207
    source ++;
#line 2207
    *tmp = *tmp___0;
#line 2206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2209
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 2213
    tmp___1 = 0;
#line 2213
    yyg->yy_n_chars = tmp___1;
#line 2213
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 2217
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 2220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2220
      if (! (num_to_read <= 0)) {
#line 2220
        goto while_break___0;
      }
      {
#line 2223
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT",
                     yyscanner);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2228
    if (num_to_read > 8192) {
#line 2229
      num_to_read = 8192;
    }
#line 2232
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 2232
      c = '*';
#line 2232
      n = (size_t )0;
      {
#line 2232
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2232
        if (n < (size_t )num_to_read) {
          {
#line 2232
          c = _IO_getc(yyg->yyin_r);
          }
#line 2232
          if (c != -1) {
#line 2232
            if (! (c != 10)) {
#line 2232
              goto while_break___1;
            }
          } else {
#line 2232
            goto while_break___1;
          }
        } else {
#line 2232
          goto while_break___1;
        }
#line 2232
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 2232
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2232
      if (c == 10) {
#line 2232
        tmp___2 = n;
#line 2232
        n ++;
#line 2232
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 2232
      if (c == -1) {
        {
#line 2232
        tmp___3 = ferror(yyg->yyin_r);
        }
#line 2232
        if (tmp___3) {
          {
#line 2232
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 2232
      yyg->yy_n_chars = (int )n;
    } else {
      {
#line 2232
      tmp___4 = __errno_location();
#line 2232
      *tmp___4 = 0;
      }
      {
#line 2232
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2232
        tmp___8 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 2232
        tmp___7 = (int )tmp___8;
#line 2232
        yyg->yy_n_chars = tmp___7;
        }
#line 2232
        if (tmp___7 == 0) {
          {
#line 2232
          tmp___9 = ferror(yyg->yyin_r);
          }
#line 2232
          if (! tmp___9) {
#line 2232
            goto while_break___2;
          }
        } else {
#line 2232
          goto while_break___2;
        }
        {
#line 2232
        tmp___5 = __errno_location();
        }
#line 2232
        if (*tmp___5 != 4) {
          {
#line 2232
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
#line 2232
          goto while_break___2;
        }
        {
#line 2232
        tmp___6 = __errno_location();
#line 2232
        *tmp___6 = 0;
#line 2232
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2235
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2238
  if (yyg->yy_n_chars == 0) {
#line 2240
    if (number_to_move == 0) {
      {
#line 2242
      ret_val = 1;
#line 2243
      bsdlrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 2248
      ret_val = 2;
#line 2249
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 2255
    ret_val = 0;
  }
#line 2257
  yyg->yy_n_chars += number_to_move;
#line 2258
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 2259
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 2261
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 2263
  return (ret_val);
}
}
#line 2268 "bsdl_flex.c"
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t *yyg ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 2272
  yyg = (struct yyguts_t *)yyscanner;
#line 2274
  yy_current_state = yyg->yy_start;
#line 2276
  yyg->yy_state_ptr = yyg->yy_state_buf;
#line 2277
  tmp = yyg->yy_state_ptr;
#line 2277
  (yyg->yy_state_ptr) ++;
#line 2277
  *tmp = yy_current_state;
#line 2279
  yy_cp = yyg->yytext_r + 0;
  {
#line 2279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2279
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 2279
      goto while_break;
    }
#line 2281
    if (*yy_cp) {
#line 2281
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 2281
      tmp___0 = (flex_int32_t const   )1;
    }
#line 2281
    yy_c = (YY_CHAR )tmp___0;
    {
#line 2282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2282
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2282
        goto while_break___0;
      }
#line 2284
      yy_current_state = (int )yy_def[yy_current_state];
#line 2285
      if (yy_current_state >= 643) {
#line 2286
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2288
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2289
    tmp___1 = yyg->yy_state_ptr;
#line 2289
    (yyg->yy_state_ptr) ++;
#line 2289
    *tmp___1 = yy_current_state;
#line 2279
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2292
  return (yy_current_state);
}
}
#line 2300 "bsdl_flex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t *yyg ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 2303
  yyg = (struct yyguts_t *)yyscanner;
#line 2305
  yy_c = (YY_CHAR )1;
  {
#line 2306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2306
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2306
      goto while_break;
    }
#line 2308
    yy_current_state = (int )yy_def[yy_current_state];
#line 2309
    if (yy_current_state >= 643) {
#line 2310
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2312
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2313
  yy_is_jam = yy_current_state == 642;
#line 2314
  if (! yy_is_jam) {
#line 2315
    tmp = yyg->yy_state_ptr;
#line 2315
    (yyg->yy_state_ptr) ++;
#line 2315
    *tmp = yy_current_state;
  }
#line 2317
  if (yy_is_jam) {
#line 2317
    tmp___0 = 0;
  } else {
#line 2317
    tmp___0 = yy_current_state;
  }
#line 2317
  return (tmp___0);
}
}
#line 2438 "bsdl_flex.c"
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2440
  yyg = (struct yyguts_t *)yyscanner;
#line 2442
  if (yyg->yy_buffer_stack) {
#line 2442
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2442
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2442
  if (! tmp) {
    {
#line 2443
    bsdlensure_buffer_stack(yyscanner);
#line 2444
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                            16384,
                                                                            yyscanner);
    }
  }
#line 2448
  if (yyg->yy_buffer_stack) {
#line 2448
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2448
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2448
  bsdl_init_buffer(tmp___0, input_file, yyscanner);
#line 2449
  bsdl_load_buffer_state(yyscanner);
  }
#line 2450
  return;
}
}
#line 2456 "bsdl_flex.c"
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2458
  yyg = (struct yyguts_t *)yyscanner;
#line 2465
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2466
  if (yyg->yy_buffer_stack) {
#line 2466
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2466
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2466
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2467
    return;
  }
#line 2469
  if (yyg->yy_buffer_stack) {
#line 2469
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2469
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2469
  if (tmp___0) {
#line 2472
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2473
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2474
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 2477
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2478
  bsdl_load_buffer_state(yyscanner);
#line 2485
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2486
  return;
}
}
#line 2488 "bsdl_flex.c"
static void bsdl_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2490
  yyg = (struct yyguts_t *)yyscanner;
#line 2491
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2492
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2492
  yyg->yy_c_buf_p = tmp;
#line 2492
  yyg->yytext_r = tmp;
#line 2493
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2494
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2495
  return;
}
}
#line 2503 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2507
  tmp = bsdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2507
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2508
  if (! b) {
    {
#line 2509
    yy_fatal_error("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2511
  b->yy_buf_size = (yy_size_t )size;
#line 2516
  tmp___0 = bsdlalloc(b->yy_buf_size + 2U, yyscanner);
#line 2516
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2517
  if (! b->yy_ch_buf) {
    {
#line 2518
    yy_fatal_error("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2520
  b->yy_is_our_buffer = 1;
#line 2522
  bsdl_init_buffer(b, file, yyscanner);
  }
#line 2524
  return (b);
}
}
#line 2531 "bsdl_flex.c"
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2533
  yyg = (struct yyguts_t *)yyscanner;
#line 2535
  if (! b) {
#line 2536
    return;
  }
#line 2538
  if (yyg->yy_buffer_stack) {
#line 2538
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2538
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2538
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2539
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2541
  if (b->yy_is_our_buffer) {
    {
#line 2542
    bsdlfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2544
  bsdlfree((void *)b, yyscanner);
  }
#line 2545
  return;
}
}
#line 2555 "bsdl_flex.c"
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2558
  tmp = __errno_location();
#line 2558
  oerrno = *tmp;
#line 2559
  yyg = (struct yyguts_t *)yyscanner;
#line 2561
  bsdl_flush_buffer(b, yyscanner);
#line 2563
  b->yy_input_file = file;
#line 2564
  b->yy_fill_buffer = 1;
  }
#line 2570
  if (yyg->yy_buffer_stack) {
#line 2570
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2570
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2570
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2571
    b->yy_bs_lineno = 1;
#line 2572
    b->yy_bs_column = 0;
  }
#line 2575
  if (file) {
    {
#line 2575
    tmp___1 = fileno(file);
#line 2575
    tmp___2 = isatty(tmp___1);
#line 2575
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2575
    b->yy_is_interactive = 0;
  }
  {
#line 2577
  tmp___3 = __errno_location();
#line 2577
  *tmp___3 = oerrno;
  }
#line 2578
  return;
}
}
#line 2584 "bsdl_flex.c"
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2586
  yyg = (struct yyguts_t *)yyscanner;
#line 2587
  if (! b) {
#line 2588
    return;
  }
#line 2590
  b->yy_n_chars = 0;
#line 2596
  *(b->yy_ch_buf + 0) = (char)0;
#line 2597
  *(b->yy_ch_buf + 1) = (char)0;
#line 2599
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2601
  b->yy_at_bol = 1;
#line 2602
  b->yy_buffer_status = 0;
#line 2604
  if (yyg->yy_buffer_stack) {
#line 2604
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2604
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2604
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2605
    bsdl_load_buffer_state(yyscanner);
    }
  }
#line 2606
  return;
}
}
#line 2614 "bsdl_flex.c"
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2616
  yyg = (struct yyguts_t *)yyscanner;
#line 2617
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2618
    return;
  }
  {
#line 2620
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2623
  if (yyg->yy_buffer_stack) {
#line 2623
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2623
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2623
  if (tmp) {
#line 2626
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2627
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2628
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2632
  if (yyg->yy_buffer_stack) {
#line 2632
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2632
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2632
  if (tmp___0) {
#line 2633
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2634
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2637
  bsdl_load_buffer_state(yyscanner);
#line 2638
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2639
  return;
}
}
#line 2645 "bsdl_flex.c"
void bsdlpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2647
  yyg = (struct yyguts_t *)yyscanner;
#line 2648
  if (yyg->yy_buffer_stack) {
#line 2648
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2648
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2648
  if (! tmp) {
#line 2649
    return;
  }
#line 2651
  if (yyg->yy_buffer_stack) {
#line 2651
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2651
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2651
  bsdl_delete_buffer(tmp___0, yyscanner);
#line 2652
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2653
  if (yyg->yy_buffer_stack_top > 0UL) {
#line 2654
    (yyg->yy_buffer_stack_top) --;
  }
#line 2656
  if (yyg->yy_buffer_stack) {
#line 2656
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2656
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2656
  if (tmp___1) {
    {
#line 2657
    bsdl_load_buffer_state(yyscanner);
#line 2658
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2660
  return;
}
}
#line 2665 "bsdl_flex.c"
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2668
  yyg = (struct yyguts_t *)yyscanner;
#line 2670
  if (! yyg->yy_buffer_stack) {
    {
#line 2676
    num_to_alloc = 1;
#line 2677
    tmp = bsdlalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                    yyscanner);
#line 2677
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
#line 2681
    memset((void *)yyg->yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2683
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2684
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2685
    return;
  }
#line 2688
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1UL) {
    {
#line 2691
    grow_size = 8;
#line 2693
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 2694
    tmp___0 = bsdlrealloc((void *)yyg->yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                          yyscanner);
#line 2694
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 2700
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2701
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2703
  return;
}
}
#line 2711 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2715
  if (size < 2U) {
#line 2719
    return ((YY_BUFFER_STATE )0);
  } else
#line 2715
  if ((int )*(base + (size - 2U)) != 0) {
#line 2719
    return ((YY_BUFFER_STATE )0);
  } else
#line 2715
  if ((int )*(base + (size - 1U)) != 0) {
#line 2719
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2721
  tmp = bsdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2721
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2722
  if (! b) {
    {
#line 2723
    yy_fatal_error("out of dynamic memory in bsdl_scan_buffer()", yyscanner);
    }
  }
  {
#line 2725
  b->yy_buf_size = size - 2U;
#line 2726
  tmp___0 = base;
#line 2726
  b->yy_ch_buf = tmp___0;
#line 2726
  b->yy_buf_pos = tmp___0;
#line 2727
  b->yy_is_our_buffer = 0;
#line 2728
  b->yy_input_file = (FILE *)0;
#line 2729
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2730
  b->yy_is_interactive = 0;
#line 2731
  b->yy_at_bol = 1;
#line 2732
  b->yy_fill_buffer = 0;
#line 2733
  b->yy_buffer_status = 0;
#line 2735
  bsdl_switch_to_buffer(b, yyscanner);
  }
#line 2737
  return (b);
}
}
#line 2748 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2751
  tmp = strlen(yystr);
#line 2751
  tmp___0 = bsdl_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2751
  return (tmp___0);
}
}
#line 2761 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2769
  n = (yy_size_t )(_yybytes_len + 2);
#line 2770
  tmp = bsdlalloc(n, yyscanner);
#line 2770
  buf = (char *)tmp;
  }
#line 2771
  if (! buf) {
    {
#line 2772
    yy_fatal_error("out of dynamic memory in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 2774
  i = 0;
  {
#line 2774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2774
    if (! (i < _yybytes_len)) {
#line 2774
      goto while_break;
    }
#line 2775
    *(buf + i) = (char )*(yybytes + i);
#line 2774
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2777
  tmp___0 = (char)0;
#line 2777
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2777
  *(buf + _yybytes_len) = tmp___0;
#line 2779
  b = bsdl_scan_buffer(buf, n, yyscanner);
  }
#line 2780
  if (! b) {
    {
#line 2781
    yy_fatal_error("bad buffer in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 2786
  b->yy_is_our_buffer = 1;
#line 2788
  return (b);
}
}
#line 2795 "bsdl_flex.c"
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2797
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2798
  exit(2);
  }
}
}
#line 2823 "bsdl_flex.c"
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2825
  yyg = (struct yyguts_t *)yyscanner;
#line 2826
  return (yyg->yyextra_r);
}
}
#line 2832 "bsdl_flex.c"
int bsdlget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2834
  yyg = (struct yyguts_t *)yyscanner;
#line 2836
  if (yyg->yy_buffer_stack) {
#line 2836
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2836
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2836
  if (! tmp) {
#line 2837
    return (0);
  }
#line 2839
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 2845 "bsdl_flex.c"
int bsdlget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2847
  yyg = (struct yyguts_t *)yyscanner;
#line 2849
  if (yyg->yy_buffer_stack) {
#line 2849
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2849
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2849
  if (! tmp) {
#line 2850
    return (0);
  }
#line 2852
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 2858 "bsdl_flex.c"
FILE *bsdlget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2860
  yyg = (struct yyguts_t *)yyscanner;
#line 2861
  return (yyg->yyin_r);
}
}
#line 2867 "bsdl_flex.c"
FILE *bsdlget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2869
  yyg = (struct yyguts_t *)yyscanner;
#line 2870
  return (yyg->yyout_r);
}
}
#line 2876 "bsdl_flex.c"
int bsdlget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2878
  yyg = (struct yyguts_t *)yyscanner;
#line 2879
  return (yyg->yyleng_r);
}
}
#line 2886 "bsdl_flex.c"
char *bsdlget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2888
  yyg = (struct yyguts_t *)yyscanner;
#line 2889
  return (yyg->yytext_r);
}
}
#line 2896 "bsdl_flex.c"
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2898
  yyg = (struct yyguts_t *)yyscanner;
#line 2899
  yyg->yyextra_r = user_defined;
#line 2900
  return;
}
}
#line 2906 "bsdl_flex.c"
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2908
  yyg = (struct yyguts_t *)yyscanner;
#line 2911
  if (yyg->yy_buffer_stack) {
#line 2911
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2911
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2911
  if (! tmp) {
    {
#line 2912
    yy_fatal_error("bsdlset_lineno called with no buffer", yyscanner);
    }
  }
#line 2914
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 2915
  return;
}
}
#line 2921 "bsdl_flex.c"
void bsdlset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2923
  yyg = (struct yyguts_t *)yyscanner;
#line 2926
  if (yyg->yy_buffer_stack) {
#line 2926
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2926
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2926
  if (! tmp) {
    {
#line 2927
    yy_fatal_error("bsdlset_column called with no buffer", yyscanner);
    }
  }
#line 2929
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 2930
  return;
}
}
#line 2938 "bsdl_flex.c"
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2940
  yyg = (struct yyguts_t *)yyscanner;
#line 2941
  yyg->yyin_r = in_str;
#line 2942
  return;
}
}
#line 2944 "bsdl_flex.c"
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2946
  yyg = (struct yyguts_t *)yyscanner;
#line 2947
  yyg->yyout_r = out_str;
#line 2948
  return;
}
}
#line 2950 "bsdl_flex.c"
int bsdlget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2952
  yyg = (struct yyguts_t *)yyscanner;
#line 2953
  return (yyg->yy_flex_debug_r);
}
}
#line 2956 "bsdl_flex.c"
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2958
  yyg = (struct yyguts_t *)yyscanner;
#line 2959
  yyg->yy_flex_debug_r = bdebug;
#line 2960
  return;
}
}
#line 2964 "bsdl_flex.c"
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2966
  yyg = (struct yyguts_t *)yyscanner;
#line 2967
  return (yyg->yylval_r);
}
}
#line 2970 "bsdl_flex.c"
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2972
  yyg = (struct yyguts_t *)yyscanner;
#line 2973
  yyg->yylval_r = yylval_param;
#line 2974
  return;
}
}
#line 2983 "bsdl_flex.c"
int bsdllex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2986
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2987
    tmp = __errno_location();
#line 2987
    *tmp = 22;
    }
#line 2988
    return (1);
  }
  {
#line 2991
  tmp___0 = bsdlalloc((yy_size_t )sizeof(struct yyguts_t ), (void *)0);
#line 2991
  *ptr_yy_globals = tmp___0;
  }
#line 2993
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2994
    tmp___1 = __errno_location();
#line 2994
    *tmp___1 = 12;
    }
#line 2995
    return (1);
  }
  {
#line 2999
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 3001
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 3001
  return (tmp___2);
}
}
#line 3004 "bsdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3006
  yyg = (struct yyguts_t *)yyscanner;
#line 3011
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 3012
  yyg->yy_buffer_stack_top = (size_t )0;
#line 3013
  yyg->yy_buffer_stack_max = (size_t )0;
#line 3014
  yyg->yy_c_buf_p = (char *)0;
#line 3015
  yyg->yy_init = 0;
#line 3016
  yyg->yy_start = 0;
#line 3018
  yyg->yy_start_stack_ptr = 0;
#line 3019
  yyg->yy_start_stack_depth = 0;
#line 3020
  yyg->yy_start_stack = (int *)((void *)0);
#line 3022
  yyg->yy_state_buf = (yy_state_type *)0;
#line 3023
  yyg->yy_state_ptr = (yy_state_type *)0;
#line 3024
  yyg->yy_full_match = (char *)0;
#line 3025
  yyg->yy_lp = 0;
#line 3032
  yyg->yyin_r = (FILE *)0;
#line 3033
  yyg->yyout_r = (FILE *)0;
#line 3039
  return (0);
}
}
#line 3043 "bsdl_flex.c"
int bsdllex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 3045
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 3048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3048
    if (yyg->yy_buffer_stack) {
#line 3048
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3048
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 3048
    if (! tmp___0) {
#line 3048
      goto while_break;
    }
#line 3049
    if (yyg->yy_buffer_stack) {
#line 3049
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3049
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 3049
    bsdl_delete_buffer(tmp, yyscanner);
#line 3050
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 3051
    bsdlpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3055
  bsdlfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 3056
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 3059
  bsdlfree((void *)yyg->yy_start_stack, yyscanner);
#line 3060
  yyg->yy_start_stack = (int *)((void *)0);
#line 3062
  bsdlfree((void *)yyg->yy_state_buf, yyscanner);
#line 3063
  yyg->yy_state_buf = (yy_state_type *)((void *)0);
#line 3067
  yy_init_globals(yyscanner);
#line 3070
  bsdlfree(yyscanner, yyscanner);
#line 3071
  yyscanner = (void *)0;
  }
#line 3072
  return (0);
}
}
#line 3099 "bsdl_flex.c"
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3101
  tmp = malloc((size_t )size);
  }
#line 3101
  return (tmp);
}
}
#line 3104 "bsdl_flex.c"
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3113
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 3113
  return (tmp);
}
}
#line 3116 "bsdl_flex.c"
void bsdlfree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 3118
  free((void *)((char *)ptr));
  }
#line 3119
  return;
}
}
#line 420 "bsdl_flex.l"
void *bsdl_flex_init(FILE *f ) 
{ 
  scan_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 426
  tmp = bsdllex_init(& scanner);
  }
#line 426
  if (tmp != 0) {
    {
#line 427
    bsdl_msg(3, "Scanner could not be initialized\n");
    }
#line 428
    return ((void *)0);
  }
  {
#line 430
  bsdlset_in(f, scanner);
#line 432
  tmp___0 = malloc(sizeof(scan_extra_t ));
#line 432
  extra = (scan_extra_t *)tmp___0;
  }
#line 432
  if (! extra) {
    {
#line 433
    bsdl_msg(3, "Out of memory, %s line %i\n", "bsdl_flex.l", 433);
#line 434
    bsdllex_destroy(scanner);
    }
#line 435
    return ((void *)0);
  }
  {
#line 438
  extra->Compile_Errors = 0;
#line 439
  extra->Base = 1;
#line 441
  bsdlset_extra(extra, scanner);
  }
#line 443
  return (scanner);
}
}
#line 446 "bsdl_flex.l"
void bsdl_flex_deinit(void *scanner ) 
{ 
  scan_extra_t *tmp ;

  {
  {
#line 448
  tmp = bsdlget_extra(scanner);
#line 448
  free((void *)tmp);
#line 449
  bsdllex_destroy(scanner);
  }
#line 450
  return;
}
}
#line 453 "bsdl_flex.l"
int bsdlwrap(yyscan_t scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 455
  tmp___0 = bsdlget_in(scanner);
  }
#line 455
  if (tmp___0) {
    {
#line 456
    tmp = bsdlget_in(scanner);
#line 456
    fclose(tmp);
#line 457
    bsdlset_in((FILE *)((void *)0), scanner);
    }
  }
#line 459
  return (1);
}
}
#line 463 "bsdl_flex.l"
static char *new_string(char const   *str ) 
{ 
  char *n_str ;
  size_t n_str_size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 468
  tmp = strlen(str);
#line 468
  n_str_size = tmp + 1UL;
#line 469
  tmp___0 = malloc(n_str_size);
#line 469
  n_str = (char *)tmp___0;
  }
#line 469
  if (n_str) {
    {
#line 470
    strncpy((char */* __restrict  */)n_str, (char const   */* __restrict  */)str,
            n_str_size - 1UL);
#line 471
    *(n_str + (n_str_size - 1UL)) = (char )'\000';
    }
  } else {
    {
#line 473
    bsdl_msg(3, "Out of memory, %s line %i\n", "bsdl_flex.l", 473);
    }
  }
#line 475
  return (n_str);
}
}
#line 479 "bsdl_flex.l"
void bsdl_flex_switch_file(void *scanner , char *filename ) 
{ 
  scan_extra_t *extra ;
  FILE *f ;
  char *s ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char db_path[24] ;
  char *db_file ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  YY_BUFFER_STATE tmp___4 ;

  {
#line 486
  s = filename;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! *s) {
#line 487
      goto while_break;
    }
    {
#line 488
    tmp___0 = __ctype_b_loc();
    }
#line 488
    if ((int const   )*(*tmp___0 + (int )*s) & 512) {
      {
#line 489
      tmp = toupper((int )*s);
#line 489
      *s = (char )tmp;
      }
    }
#line 490
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 494
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 495
  if (! f) {
    {
#line 496
    db_path[0] = (char )'/';
#line 496
    db_path[1] = (char )'u';
#line 496
    db_path[2] = (char )'s';
#line 496
    db_path[3] = (char )'r';
#line 496
    db_path[4] = (char )'/';
#line 496
    db_path[5] = (char )'l';
#line 496
    db_path[6] = (char )'o';
#line 496
    db_path[7] = (char )'c';
#line 496
    db_path[8] = (char )'a';
#line 496
    db_path[9] = (char )'l';
#line 496
    db_path[10] = (char )'/';
#line 496
    db_path[11] = (char )'s';
#line 496
    db_path[12] = (char )'h';
#line 496
    db_path[13] = (char )'a';
#line 496
    db_path[14] = (char )'r';
#line 496
    db_path[15] = (char )'e';
#line 496
    db_path[16] = (char )'/';
#line 496
    db_path[17] = (char )'u';
#line 496
    db_path[18] = (char )'r';
#line 496
    db_path[19] = (char )'j';
#line 496
    db_path[20] = (char )'t';
#line 496
    db_path[21] = (char )'a';
#line 496
    db_path[22] = (char )'g';
#line 496
    db_path[23] = (char )'\000';
#line 499
    tmp___1 = strlen((char const   *)(db_path));
#line 499
    tmp___2 = strlen((char const   *)filename);
#line 499
    tmp___3 = malloc(((((tmp___1 + 1UL) + 4UL) + 1UL) + tmp___2) + 1UL);
#line 499
    db_file = (char *)tmp___3;
    }
#line 499
    if (db_file) {
      {
#line 505
      strcpy((char */* __restrict  */)db_file, (char const   */* __restrict  */)(db_path));
#line 506
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 507
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"bsdl");
#line 508
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 509
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)filename);
#line 510
      f = fopen((char const   */* __restrict  */)db_file, (char const   */* __restrict  */)"r");
      }
#line 512
      if (! f) {
        {
#line 513
        bsdl_msg(3, "Cannot open file %s or %s.\n", filename, db_file);
        }
      }
      {
#line 514
      free((void *)db_file);
      }
#line 515
      if (! f) {
#line 516
        return;
      }
    }
  }
  {
#line 520
  tmp___4 = bsdl_create_buffer(f, 16384, scanner);
#line 520
  bsdlpush_buffer_state(tmp___4, scanner);
#line 521
  extra = bsdlget_extra(scanner);
#line 522
  bsdlset_lineno(1, scanner);
  }
#line 523
  return;
}
}
#line 525 "bsdl_flex.l"
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer ) 
{ 
  struct yyguts_t *yyg ;
  int lineno ;
  YY_BUFFER_STATE tmp ;

  {
  {
#line 529
  yyg = (struct yyguts_t *)scanner;
#line 532
  lineno = bsdlget_lineno(scanner);
  }
#line 539
  if (yyg->yy_buffer_stack) {
#line 539
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 539
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 539
  bsdlpush_buffer_state(tmp, scanner);
#line 540
  bsdl_scan_string(buffer, scanner);
#line 541
  bsdlset_lineno(lineno, scanner);
  }
#line 542
  return;
}
}
#line 544 "bsdl_flex.l"
int bsdl_flex_get_compile_errors(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 546
  tmp = bsdlget_extra(scanner);
#line 546
  extra = tmp;
  }
#line 547
  return (extra->Compile_Errors);
}
}
#line 550 "bsdl_flex.l"
static void bsdl_flex_set_compile_errors(int n , yyscan_t scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 552
  tmp = bsdlget_extra(scanner);
#line 552
  extra = tmp;
#line 553
  extra->Compile_Errors = n;
  }
#line 554
  return;
}
}
#line 556 "bsdl_flex.l"
int bsdl_flex_postinc_compile_errors(void *scanner ) 
{ 
  int errors ;
  int tmp ;

  {
  {
#line 558
  tmp = bsdl_flex_get_compile_errors(scanner);
#line 558
  errors = tmp;
#line 560
  bsdl_flex_set_compile_errors(errors + 1, scanner);
  }
#line 561
  return (errors);
}
}
#line 564 "bsdl_flex.l"
int bsdl_flex_get_lineno(void *scanner ) 
{ 
  int tmp ;

  {
  {
#line 566
  tmp = bsdlget_lineno(scanner);
  }
#line 566
  return (tmp);
}
}
#line 569 "bsdl_flex.l"
void bsdl_flex_set_bin_x(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 571
  tmp = bsdlget_extra(scanner);
#line 571
  extra = tmp;
#line 572
  extra->Base = 2;
  }
#line 573
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 148 "bsdl_bison.y"
static void Init_Text(parser_priv_t *priv_data ) ;
#line 149
static void Store_Text(parser_priv_t *priv_data , char *Source ) ;
#line 150
static void Print_Error(parser_priv_t *priv_data , char const   *Errmess ) ;
#line 151
static void Print_Warning(parser_priv_t *priv_data , char const   *Warnmess ) ;
#line 152
static void Give_Up_And_Quit(parser_priv_t *priv_data ) ;
#line 154
void bsdlerror(parser_priv_t *priv_data , char const   *error_string ) ;
#line 625 "bsdl_bison.c"
static yytype_uint8 const   yytranslate[375]  = 
#line 625 "bsdl_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )117,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119};
#line 929 "bsdl_bison.c"
static yytype_uint8 const   yyr1[287]  = 
#line 929
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )123,      (yytype_uint8 const   )123,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )124,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )127,      (yytype_uint8 const   )126,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )128,      (yytype_uint8 const   )129,      (yytype_uint8 const   )129,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )131,      (yytype_uint8 const   )132,      (yytype_uint8 const   )132, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )132,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )134,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )135,      (yytype_uint8 const   )137,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )139,      (yytype_uint8 const   )139,      (yytype_uint8 const   )140, 
        (yytype_uint8 const   )140,      (yytype_uint8 const   )141,      (yytype_uint8 const   )141,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )141,      (yytype_uint8 const   )141,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )143, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )143,      (yytype_uint8 const   )144,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )144,      (yytype_uint8 const   )144,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )145,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )146,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )148,      (yytype_uint8 const   )149,      (yytype_uint8 const   )149,      (yytype_uint8 const   )150, 
        (yytype_uint8 const   )150,      (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )152, 
        (yytype_uint8 const   )153,      (yytype_uint8 const   )153,      (yytype_uint8 const   )155,      (yytype_uint8 const   )154, 
        (yytype_uint8 const   )154,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )157, 
        (yytype_uint8 const   )157,      (yytype_uint8 const   )158,      (yytype_uint8 const   )158,      (yytype_uint8 const   )159, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )161,      (yytype_uint8 const   )161,      (yytype_uint8 const   )161,      (yytype_uint8 const   )161, 
        (yytype_uint8 const   )161,      (yytype_uint8 const   )162,      (yytype_uint8 const   )162,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )162,      (yytype_uint8 const   )162,      (yytype_uint8 const   )162,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )162,      (yytype_uint8 const   )164,      (yytype_uint8 const   )165,      (yytype_uint8 const   )163, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )166,      (yytype_uint8 const   )167,      (yytype_uint8 const   )167, 
        (yytype_uint8 const   )168,      (yytype_uint8 const   )168,      (yytype_uint8 const   )169,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )170,      (yytype_uint8 const   )170,      (yytype_uint8 const   )172,      (yytype_uint8 const   )172, 
        (yytype_uint8 const   )173,      (yytype_uint8 const   )174,      (yytype_uint8 const   )174,      (yytype_uint8 const   )175, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )176,      (yytype_uint8 const   )176, 
        (yytype_uint8 const   )177,      (yytype_uint8 const   )177,      (yytype_uint8 const   )178,      (yytype_uint8 const   )178, 
        (yytype_uint8 const   )178,      (yytype_uint8 const   )178,      (yytype_uint8 const   )178,      (yytype_uint8 const   )179, 
        (yytype_uint8 const   )180,      (yytype_uint8 const   )181,      (yytype_uint8 const   )182,      (yytype_uint8 const   )183, 
        (yytype_uint8 const   )184,      (yytype_uint8 const   )184,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )188,      (yytype_uint8 const   )187,      (yytype_uint8 const   )189, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191, 
        (yytype_uint8 const   )191,      (yytype_uint8 const   )192,      (yytype_uint8 const   )193,      (yytype_uint8 const   )193, 
        (yytype_uint8 const   )194,      (yytype_uint8 const   )194,      (yytype_uint8 const   )194,      (yytype_uint8 const   )194, 
        (yytype_uint8 const   )194,      (yytype_uint8 const   )194,      (yytype_uint8 const   )194,      (yytype_uint8 const   )194, 
        (yytype_uint8 const   )194,      (yytype_uint8 const   )196,      (yytype_uint8 const   )195,      (yytype_uint8 const   )198, 
        (yytype_uint8 const   )197,      (yytype_uint8 const   )200,      (yytype_uint8 const   )199,      (yytype_uint8 const   )202, 
        (yytype_uint8 const   )201,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203, 
        (yytype_uint8 const   )204,      (yytype_uint8 const   )205,      (yytype_uint8 const   )206,      (yytype_uint8 const   )208, 
        (yytype_uint8 const   )207,      (yytype_uint8 const   )210,      (yytype_uint8 const   )209,      (yytype_uint8 const   )212, 
        (yytype_uint8 const   )211,      (yytype_uint8 const   )213,      (yytype_uint8 const   )213,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )215,      (yytype_uint8 const   )215,      (yytype_uint8 const   )216,      (yytype_uint8 const   )216, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )217, 
        (yytype_uint8 const   )217,      (yytype_uint8 const   )218,      (yytype_uint8 const   )218,      (yytype_uint8 const   )218, 
        (yytype_uint8 const   )218,      (yytype_uint8 const   )218,      (yytype_uint8 const   )219,      (yytype_uint8 const   )219, 
        (yytype_uint8 const   )220,      (yytype_uint8 const   )220,      (yytype_uint8 const   )221,      (yytype_uint8 const   )221, 
        (yytype_uint8 const   )223,      (yytype_uint8 const   )222,      (yytype_uint8 const   )224,      (yytype_uint8 const   )224, 
        (yytype_uint8 const   )225,      (yytype_uint8 const   )226,      (yytype_uint8 const   )228,      (yytype_uint8 const   )227, 
        (yytype_uint8 const   )229,      (yytype_uint8 const   )229,      (yytype_uint8 const   )229,      (yytype_uint8 const   )230, 
        (yytype_uint8 const   )231,      (yytype_uint8 const   )231,      (yytype_uint8 const   )232,      (yytype_uint8 const   )233, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )233,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )235, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )236,      (yytype_uint8 const   )237,      (yytype_uint8 const   )237, 
        (yytype_uint8 const   )237,      (yytype_uint8 const   )237,      (yytype_uint8 const   )237,      (yytype_uint8 const   )237, 
        (yytype_uint8 const   )238,      (yytype_uint8 const   )238,      (yytype_uint8 const   )239,      (yytype_uint8 const   )241, 
        (yytype_uint8 const   )240,      (yytype_uint8 const   )243,      (yytype_uint8 const   )242,      (yytype_uint8 const   )244, 
        (yytype_uint8 const   )244,      (yytype_uint8 const   )245,      (yytype_uint8 const   )245};
#line 963 "bsdl_bison.c"
static yytype_uint8 const   yyr2[287]  = 
#line 963
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3};
#line 999 "bsdl_bison.c"
static yytype_uint16 const   yydefact[679]  = 
#line 999
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )4,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )1,      (yytype_uint16 const   )7, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )10,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )160,      (yytype_uint16 const   )162,      (yytype_uint16 const   )163, 
        (yytype_uint16 const   )165,      (yytype_uint16 const   )166,      (yytype_uint16 const   )164,      (yytype_uint16 const   )16, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )0,      (yytype_uint16 const   )2,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )161,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )33,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )31,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )20, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )17,      (yytype_uint16 const   )0,      (yytype_uint16 const   )34, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )32,      (yytype_uint16 const   )100,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )186,      (yytype_uint16 const   )188,      (yytype_uint16 const   )189,      (yytype_uint16 const   )190, 
        (yytype_uint16 const   )191,      (yytype_uint16 const   )193,      (yytype_uint16 const   )194,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )192,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )6, 
        (yytype_uint16 const   )144,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )101,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )11,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )187,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )236,      (yytype_uint16 const   )238,      (yytype_uint16 const   )239,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )18,      (yytype_uint16 const   )15,      (yytype_uint16 const   )21,      (yytype_uint16 const   )22, 
        (yytype_uint16 const   )23,      (yytype_uint16 const   )24,      (yytype_uint16 const   )25,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )149,      (yytype_uint16 const   )0,      (yytype_uint16 const   )146,      (yytype_uint16 const   )145, 
        (yytype_uint16 const   )5,      (yytype_uint16 const   )0,      (yytype_uint16 const   )285,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )237,      (yytype_uint16 const   )9,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )27,      (yytype_uint16 const   )0,      (yytype_uint16 const   )19,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )8, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )35,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )286,      (yytype_uint16 const   )13, 
        (yytype_uint16 const   )174,      (yytype_uint16 const   )175,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )138,      (yytype_uint16 const   )0,      (yytype_uint16 const   )167, 
        (yytype_uint16 const   )168,      (yytype_uint16 const   )169,      (yytype_uint16 const   )170,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )28,      (yytype_uint16 const   )38, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )36,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )14,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )277,      (yytype_uint16 const   )176,      (yytype_uint16 const   )279,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )30,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )147,      (yytype_uint16 const   )141,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )139,      (yytype_uint16 const   )172,      (yytype_uint16 const   )173,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )177,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )142, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )280,      (yytype_uint16 const   )0,      (yytype_uint16 const   )197, 
        (yytype_uint16 const   )199,      (yytype_uint16 const   )201,      (yytype_uint16 const   )203,      (yytype_uint16 const   )209, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )215,      (yytype_uint16 const   )211,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )46, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )39,      (yytype_uint16 const   )0,      (yytype_uint16 const   )148,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )171,      (yytype_uint16 const   )157,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )155,      (yytype_uint16 const   )181,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )178,      (yytype_uint16 const   )179,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )240,      (yytype_uint16 const   )245,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )73,      (yytype_uint16 const   )47,      (yytype_uint16 const   )48,      (yytype_uint16 const   )49, 
        (yytype_uint16 const   )51,      (yytype_uint16 const   )52,      (yytype_uint16 const   )50,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )59,      (yytype_uint16 const   )60,      (yytype_uint16 const   )61,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )64,      (yytype_uint16 const   )65,      (yytype_uint16 const   )68, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )70,      (yytype_uint16 const   )71,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )67,      (yytype_uint16 const   )72,      (yytype_uint16 const   )53,      (yytype_uint16 const   )54, 
        (yytype_uint16 const   )55,      (yytype_uint16 const   )56,      (yytype_uint16 const   )57,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )40,      (yytype_uint16 const   )0,      (yytype_uint16 const   )95, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )281,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )198,      (yytype_uint16 const   )200,      (yytype_uint16 const   )202,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )208,      (yytype_uint16 const   )204,      (yytype_uint16 const   )205,      (yytype_uint16 const   )222, 
        (yytype_uint16 const   )223,      (yytype_uint16 const   )224,      (yytype_uint16 const   )226,      (yytype_uint16 const   )225, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )216,      (yytype_uint16 const   )217,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )212,      (yytype_uint16 const   )214,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )246,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )99,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )97,      (yytype_uint16 const   )0,      (yytype_uint16 const   )96,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )153,      (yytype_uint16 const   )151,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )156,      (yytype_uint16 const   )0,      (yytype_uint16 const   )185, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )183,      (yytype_uint16 const   )180,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )242,      (yytype_uint16 const   )0,      (yytype_uint16 const   )77, 
        (yytype_uint16 const   )75,      (yytype_uint16 const   )74,      (yytype_uint16 const   )76,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )84,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )158,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )206,      (yytype_uint16 const   )0,      (yytype_uint16 const   )218,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )231,      (yytype_uint16 const   )232,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )0,      (yytype_uint16 const   )235,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )250,      (yytype_uint16 const   )0,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )41,      (yytype_uint16 const   )0,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )91,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )90,      (yytype_uint16 const   )0,      (yytype_uint16 const   )87,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )85,      (yytype_uint16 const   )42, 
        (yytype_uint16 const   )44,      (yytype_uint16 const   )45,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )154,      (yytype_uint16 const   )0,      (yytype_uint16 const   )283,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )221,      (yytype_uint16 const   )0,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )92,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )78, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )79,      (yytype_uint16 const   )98,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )104,      (yytype_uint16 const   )0,      (yytype_uint16 const   )140,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )282,      (yytype_uint16 const   )228,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )249,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )83,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )89,      (yytype_uint16 const   )86,      (yytype_uint16 const   )88,      (yytype_uint16 const   )37, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )284,      (yytype_uint16 const   )0,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )93,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )80,      (yytype_uint16 const   )0,      (yytype_uint16 const   )255, 
        (yytype_uint16 const   )257,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )253, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )108,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )105,      (yytype_uint16 const   )0,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )265,      (yytype_uint16 const   )266, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )106, 
        (yytype_uint16 const   )256,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )43, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )102,      (yytype_uint16 const   )267,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )254,      (yytype_uint16 const   )270,      (yytype_uint16 const   )271,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )273,      (yytype_uint16 const   )274,      (yytype_uint16 const   )275,      (yytype_uint16 const   )269, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )112,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )109,      (yytype_uint16 const   )123,      (yytype_uint16 const   )113,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )117,      (yytype_uint16 const   )118,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )119,      (yytype_uint16 const   )120,      (yytype_uint16 const   )121,      (yytype_uint16 const   )122, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )107,      (yytype_uint16 const   )128,      (yytype_uint16 const   )124, 
        (yytype_uint16 const   )125,      (yytype_uint16 const   )126,      (yytype_uint16 const   )127,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )136,      (yytype_uint16 const   )129,      (yytype_uint16 const   )130, 
        (yytype_uint16 const   )131,      (yytype_uint16 const   )132,      (yytype_uint16 const   )133,      (yytype_uint16 const   )134, 
        (yytype_uint16 const   )135,      (yytype_uint16 const   )0,      (yytype_uint16 const   )111};
#line 1072 "bsdl_bison.c"
static yytype_int16 const   yydefgoto[126]  = 
#line 1072
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )9, 
        (yytype_int16 const   )15,      (yytype_int16 const   )34,      (yytype_int16 const   )10,      (yytype_int16 const   )250, 
        (yytype_int16 const   )25,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62, 
        (yytype_int16 const   )144,      (yytype_int16 const   )182,      (yytype_int16 const   )244,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )99,      (yytype_int16 const   )245,      (yytype_int16 const   )277, 
        (yytype_int16 const   )351,      (yytype_int16 const   )352,      (yytype_int16 const   )403,      (yytype_int16 const   )475, 
        (yytype_int16 const   )481,      (yytype_int16 const   )520,      (yytype_int16 const   )521,      (yytype_int16 const   )522, 
        (yytype_int16 const   )513,      (yytype_int16 const   )514,      (yytype_int16 const   )410,      (yytype_int16 const   )411, 
        (yytype_int16 const   )448,      (yytype_int16 const   )69,      (yytype_int16 const   )554,      (yytype_int16 const   )637, 
        (yytype_int16 const   )600,      (yytype_int16 const   )601,      (yytype_int16 const   )643,      (yytype_int16 const   )644, 
        (yytype_int16 const   )656,      (yytype_int16 const   )667,      (yytype_int16 const   )677,      (yytype_int16 const   )70, 
        (yytype_int16 const   )153,      (yytype_int16 const   )281,      (yytype_int16 const   )308,      (yytype_int16 const   )66, 
        (yytype_int16 const   )103,      (yytype_int16 const   )104,      (yytype_int16 const   )150,      (yytype_int16 const   )329, 
        (yytype_int16 const   )354,      (yytype_int16 const   )355,      (yytype_int16 const   )452,      (yytype_int16 const   )360, 
        (yytype_int16 const   )361,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )311,      (yytype_int16 const   )222,      (yytype_int16 const   )38,      (yytype_int16 const   )56, 
        (yytype_int16 const   )334,      (yytype_int16 const   )364,      (yytype_int16 const   )365,      (yytype_int16 const   )460, 
        (yytype_int16 const   )461,      (yytype_int16 const   )83,      (yytype_int16 const   )84,      (yytype_int16 const   )85, 
        (yytype_int16 const   )366,      (yytype_int16 const   )86,      (yytype_int16 const   )367,      (yytype_int16 const   )87, 
        (yytype_int16 const   )368,      (yytype_int16 const   )88,      (yytype_int16 const   )369,      (yytype_int16 const   )425, 
        (yytype_int16 const   )426,      (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91, 
        (yytype_int16 const   )371,      (yytype_int16 const   )92,      (yytype_int16 const   )372,      (yytype_int16 const   )93, 
        (yytype_int16 const   )370,      (yytype_int16 const   )433,      (yytype_int16 const   )434,      (yytype_int16 const   )435, 
        (yytype_int16 const   )436,      (yytype_int16 const   )501,      (yytype_int16 const   )502,      (yytype_int16 const   )503, 
        (yytype_int16 const   )131,      (yytype_int16 const   )132,      (yytype_int16 const   )133,      (yytype_int16 const   )439, 
        (yytype_int16 const   )468,      (yytype_int16 const   )469,      (yytype_int16 const   )134,      (yytype_int16 const   )178, 
        (yytype_int16 const   )470,      (yytype_int16 const   )507,      (yytype_int16 const   )508,      (yytype_int16 const   )559, 
        (yytype_int16 const   )560,      (yytype_int16 const   )585,      (yytype_int16 const   )612,      (yytype_int16 const   )628, 
        (yytype_int16 const   )587,      (yytype_int16 const   )635,      (yytype_int16 const   )35,      (yytype_int16 const   )67, 
        (yytype_int16 const   )39,      (yytype_int16 const   )312,      (yytype_int16 const   )333,      (yytype_int16 const   )458, 
        (yytype_int16 const   )531,      (yytype_int16 const   )155};
#line 1092 "bsdl_bison.c"
static yytype_int16 const   yypact[679]  = 
#line 1092
  {      (yytype_int16 const   )182,      (yytype_int16 const   )-348,      (yytype_int16 const   )-67,      (yytype_int16 const   )51, 
        (yytype_int16 const   )49,      (yytype_int16 const   )103,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )15,      (yytype_int16 const   )163,      (yytype_int16 const   )30,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )106,      (yytype_int16 const   )-348,      (yytype_int16 const   )225,      (yytype_int16 const   )179, 
        (yytype_int16 const   )127,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )60,      (yytype_int16 const   )29,      (yytype_int16 const   )40,      (yytype_int16 const   )206, 
        (yytype_int16 const   )218,      (yytype_int16 const   )231,      (yytype_int16 const   )235,      (yytype_int16 const   )246, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )143,      (yytype_int16 const   )-348,      (yytype_int16 const   )248, 
        (yytype_int16 const   )-8,      (yytype_int16 const   )-348,      (yytype_int16 const   )268,      (yytype_int16 const   )312, 
        (yytype_int16 const   )230,      (yytype_int16 const   )-348,      (yytype_int16 const   )232,      (yytype_int16 const   )177, 
        (yytype_int16 const   )315,      (yytype_int16 const   )313,      (yytype_int16 const   )233,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )238,      (yytype_int16 const   )239,      (yytype_int16 const   )316, 
        (yytype_int16 const   )240,      (yytype_int16 const   )322,      (yytype_int16 const   )323,      (yytype_int16 const   )287, 
        (yytype_int16 const   )327,      (yytype_int16 const   )290,      (yytype_int16 const   )268,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )131,      (yytype_int16 const   )-348,      (yytype_int16 const   )93,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-7,      (yytype_int16 const   )326,      (yytype_int16 const   )180, 
        (yytype_int16 const   )250,      (yytype_int16 const   )315,      (yytype_int16 const   )-348,      (yytype_int16 const   )227, 
        (yytype_int16 const   )234,      (yytype_int16 const   )241,      (yytype_int16 const   )242,      (yytype_int16 const   )243, 
        (yytype_int16 const   )244,      (yytype_int16 const   )252,      (yytype_int16 const   )251,      (yytype_int16 const   )253, 
        (yytype_int16 const   )254,      (yytype_int16 const   )329,      (yytype_int16 const   )171,      (yytype_int16 const   )332, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )327,      (yytype_int16 const   )230, 
        (yytype_int16 const   )255,      (yytype_int16 const   )256,      (yytype_int16 const   )223,      (yytype_int16 const   )257, 
        (yytype_int16 const   )336,      (yytype_int16 const   )338,      (yytype_int16 const   )9,      (yytype_int16 const   )326, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )339,      (yytype_int16 const   )326,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )259,      (yytype_int16 const   )340,      (yytype_int16 const   )341, 
        (yytype_int16 const   )342,      (yytype_int16 const   )343,      (yytype_int16 const   )344,      (yytype_int16 const   )258, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )260,      (yytype_int16 const   )263,      (yytype_int16 const   )265, 
        (yytype_int16 const   )348,      (yytype_int16 const   )349,      (yytype_int16 const   )355,      (yytype_int16 const   )357, 
        (yytype_int16 const   )360,      (yytype_int16 const   )362,      (yytype_int16 const   )363,      (yytype_int16 const   )364, 
        (yytype_int16 const   )365,      (yytype_int16 const   )159,      (yytype_int16 const   )-348,      (yytype_int16 const   )368, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )332, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )245,      (yytype_int16 const   )366,      (yytype_int16 const   )286,      (yytype_int16 const   )288, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )270,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )326,      (yytype_int16 const   )269,      (yytype_int16 const   )-348,      (yytype_int16 const   )99, 
        (yytype_int16 const   )373,      (yytype_int16 const   )374,      (yytype_int16 const   )375,      (yytype_int16 const   )376, 
        (yytype_int16 const   )377,      (yytype_int16 const   )383,      (yytype_int16 const   )384,      (yytype_int16 const   )385, 
        (yytype_int16 const   )282,      (yytype_int16 const   )300,      (yytype_int16 const   )301,      (yytype_int16 const   )302, 
        (yytype_int16 const   )303,      (yytype_int16 const   )304,      (yytype_int16 const   )305,      (yytype_int16 const   )306, 
        (yytype_int16 const   )307,      (yytype_int16 const   )308,      (yytype_int16 const   )390,      (yytype_int16 const   )391, 
        (yytype_int16 const   )77,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )368, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )298,      (yytype_int16 const   )-348,      (yytype_int16 const   )309, 
        (yytype_int16 const   )295,      (yytype_int16 const   )296,      (yytype_int16 const   )388,      (yytype_int16 const   )392, 
        (yytype_int16 const   )311,      (yytype_int16 const   )310,      (yytype_int16 const   )262,      (yytype_int16 const   )262, 
        (yytype_int16 const   )262,      (yytype_int16 const   )262,      (yytype_int16 const   )314,      (yytype_int16 const   )399, 
        (yytype_int16 const   )400,      (yytype_int16 const   )401,      (yytype_int16 const   )409,      (yytype_int16 const   )317, 
        (yytype_int16 const   )318,      (yytype_int16 const   )319,      (yytype_int16 const   )320,      (yytype_int16 const   )321, 
        (yytype_int16 const   )324,      (yytype_int16 const   )325,      (yytype_int16 const   )328,      (yytype_int16 const   )330, 
        (yytype_int16 const   )331,      (yytype_int16 const   )333,      (yytype_int16 const   )404,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )334,      (yytype_int16 const   )-348,      (yytype_int16 const   )411,      (yytype_int16 const   )412, 
        (yytype_int16 const   )335,      (yytype_int16 const   )337,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )345,      (yytype_int16 const   )346, 
        (yytype_int16 const   )347,      (yytype_int16 const   )350,      (yytype_int16 const   )351,      (yytype_int16 const   )259, 
        (yytype_int16 const   )353,      (yytype_int16 const   )259,      (yytype_int16 const   )408,      (yytype_int16 const   )415, 
        (yytype_int16 const   )416,      (yytype_int16 const   )417,      (yytype_int16 const   )419,      (yytype_int16 const   )426, 
        (yytype_int16 const   )430,      (yytype_int16 const   )431,      (yytype_int16 const   )433,      (yytype_int16 const   )436, 
        (yytype_int16 const   )352,      (yytype_int16 const   )354,      (yytype_int16 const   )367,      (yytype_int16 const   )247, 
        (yytype_int16 const   )356,      (yytype_int16 const   )17,      (yytype_int16 const   )432,      (yytype_int16 const   )434, 
        (yytype_int16 const   )259,      (yytype_int16 const   )-348,      (yytype_int16 const   )372,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )361, 
        (yytype_int16 const   )183,      (yytype_int16 const   )369,      (yytype_int16 const   )185,      (yytype_int16 const   )259, 
        (yytype_int16 const   )435,      (yytype_int16 const   )444,      (yytype_int16 const   )445,      (yytype_int16 const   )446, 
        (yytype_int16 const   )447,      (yytype_int16 const   )448,      (yytype_int16 const   )450,      (yytype_int16 const   )456, 
        (yytype_int16 const   )457,      (yytype_int16 const   )438,      (yytype_int16 const   )441,      (yytype_int16 const   )359, 
        (yytype_int16 const   )371,      (yytype_int16 const   )378,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )379,      (yytype_int16 const   )-348,      (yytype_int16 const   )453,      (yytype_int16 const   )259, 
        (yytype_int16 const   )187,      (yytype_int16 const   )119,      (yytype_int16 const   )-348,      (yytype_int16 const   )264, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )191, 
        (yytype_int16 const   )259,      (yytype_int16 const   )259,      (yytype_int16 const   )259,      (yytype_int16 const   )259, 
        (yytype_int16 const   )259,      (yytype_int16 const   )259,      (yytype_int16 const   )259,      (yytype_int16 const   )259, 
        (yytype_int16 const   )259,      (yytype_int16 const   )463,      (yytype_int16 const   )464,      (yytype_int16 const   )470, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )467,      (yytype_int16 const   )380, 
        (yytype_int16 const   )193,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )386, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )381, 
        (yytype_int16 const   )387,      (yytype_int16 const   )-348,      (yytype_int16 const   )195,      (yytype_int16 const   )197, 
        (yytype_int16 const   )199,      (yytype_int16 const   )201,      (yytype_int16 const   )203,      (yytype_int16 const   )205, 
        (yytype_int16 const   )207,      (yytype_int16 const   )209,      (yytype_int16 const   )211,      (yytype_int16 const   )259, 
        (yytype_int16 const   )382,      (yytype_int16 const   )469,      (yytype_int16 const   )158,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )389,      (yytype_int16 const   )472,      (yytype_int16 const   )393, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-348,      (yytype_int16 const   )24,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )213,      (yytype_int16 const   )394,      (yytype_int16 const   )259,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )35,      (yytype_int16 const   )64,      (yytype_int16 const   )-10,      (yytype_int16 const   )151, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )395,      (yytype_int16 const   )396,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )473,      (yytype_int16 const   )-348,      (yytype_int16 const   )397,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )129,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )398, 
        (yytype_int16 const   )402,      (yytype_int16 const   )-348,      (yytype_int16 const   )405,      (yytype_int16 const   )403, 
        (yytype_int16 const   )406,      (yytype_int16 const   )25,      (yytype_int16 const   )108,      (yytype_int16 const   )407, 
        (yytype_int16 const   )410,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )215, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )413, 
        (yytype_int16 const   )474,      (yytype_int16 const   )476,      (yytype_int16 const   )478,      (yytype_int16 const   )479, 
        (yytype_int16 const   )26,      (yytype_int16 const   )-348,      (yytype_int16 const   )151,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-57,      (yytype_int16 const   )389,      (yytype_int16 const   )249,      (yytype_int16 const   )414, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-348,      (yytype_int16 const   )418,      (yytype_int16 const   )421, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )420,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )422,      (yytype_int16 const   )423,      (yytype_int16 const   )-348,      (yytype_int16 const   )425, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )424, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )8,      (yytype_int16 const   )451,      (yytype_int16 const   )0, 
        (yytype_int16 const   )477,      (yytype_int16 const   )480,      (yytype_int16 const   )-348,      (yytype_int16 const   )427, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )155,      (yytype_int16 const   )-348,      (yytype_int16 const   )70, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )428, 
        (yytype_int16 const   )429,      (yytype_int16 const   )-348,      (yytype_int16 const   )437,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )160,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )439, 
        (yytype_int16 const   )440,      (yytype_int16 const   )108,      (yytype_int16 const   )114,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )442,      (yytype_int16 const   )-348,      (yytype_int16 const   )16,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )449, 
        (yytype_int16 const   )443,      (yytype_int16 const   )-348,      (yytype_int16 const   )27,      (yytype_int16 const   )452, 
        (yytype_int16 const   )19,      (yytype_int16 const   )455,      (yytype_int16 const   )458,      (yytype_int16 const   )459, 
        (yytype_int16 const   )462,      (yytype_int16 const   )461,      (yytype_int16 const   )161,      (yytype_int16 const   )460, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )454,      (yytype_int16 const   )418,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )465,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )164,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )424,      (yytype_int16 const   )-348,      (yytype_int16 const   )466,      (yytype_int16 const   )468, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )471,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )475,      (yytype_int16 const   )10,      (yytype_int16 const   )-348,      (yytype_int16 const   )481, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )482,      (yytype_int16 const   )-348,      (yytype_int16 const   )483, 
        (yytype_int16 const   )165,      (yytype_int16 const   )168,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )484,      (yytype_int16 const   )485, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )121,      (yytype_int16 const   )-348,      (yytype_int16 const   )169, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )114,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )486,      (yytype_int16 const   )487,      (yytype_int16 const   )488, 
        (yytype_int16 const   )489,      (yytype_int16 const   )490,      (yytype_int16 const   )-348,      (yytype_int16 const   )283, 
        (yytype_int16 const   )491,      (yytype_int16 const   )493,      (yytype_int16 const   )7,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )498,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )121, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )495,      (yytype_int16 const   )-348,      (yytype_int16 const   )492, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )494,      (yytype_int16 const   )496, 
        (yytype_int16 const   )497,      (yytype_int16 const   )-348,      (yytype_int16 const   )499,      (yytype_int16 const   )500, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )501,      (yytype_int16 const   )502,      (yytype_int16 const   )503, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )504,      (yytype_int16 const   )-348,      (yytype_int16 const   )-66,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )506,      (yytype_int16 const   )505,      (yytype_int16 const   )-348,      (yytype_int16 const   )507, 
        (yytype_int16 const   )508,      (yytype_int16 const   )-348,      (yytype_int16 const   )511,      (yytype_int16 const   )510, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )512,      (yytype_int16 const   )513,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )514,      (yytype_int16 const   )515,      (yytype_int16 const   )517,      (yytype_int16 const   )37, 
        (yytype_int16 const   )509,      (yytype_int16 const   )73,      (yytype_int16 const   )520,      (yytype_int16 const   )516, 
        (yytype_int16 const   )527,      (yytype_int16 const   )528,      (yytype_int16 const   )-348,      (yytype_int16 const   )529, 
        (yytype_int16 const   )224,      (yytype_int16 const   )-348,      (yytype_int16 const   )518,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )519,      (yytype_int16 const   )521,      (yytype_int16 const   )523,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )522,      (yytype_int16 const   )530,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )92,      (yytype_int16 const   )150,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )524,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )525,      (yytype_int16 const   )526,      (yytype_int16 const   )531,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )2,      (yytype_int16 const   )-348,      (yytype_int16 const   )4,      (yytype_int16 const   )172, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )534,      (yytype_int16 const   )2,      (yytype_int16 const   )532,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )535, 
        (yytype_int16 const   )44,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )536,      (yytype_int16 const   )-348};
#line 1165 "bsdl_bison.c"
static yytype_int16 const   yypgoto[126]  = 
#line 1165
  {      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )533,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )79,      (yytype_int16 const   )-347,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-49, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-14,      (yytype_int16 const   )153,      (yytype_int16 const   )-209, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-44,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-88,      (yytype_int16 const   )-348,      (yytype_int16 const   )-141, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )541, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )537, 
        (yytype_int16 const   )538,      (yytype_int16 const   )-55,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )122,      (yytype_int16 const   )-348,      (yytype_int16 const   )86, 
        (yytype_int16 const   )-186,      (yytype_int16 const   )-348,      (yytype_int16 const   )542,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )65,      (yytype_int16 const   )539,      (yytype_int16 const   )545, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )102,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )48,      (yytype_int16 const   )544,      (yytype_int16 const   )-40,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )76,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )78,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )11, 
        (yytype_int16 const   )540,      (yytype_int16 const   )-102,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )38,      (yytype_int16 const   )-348,      (yytype_int16 const   )370, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )3,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348,      (yytype_int16 const   )-348, 
        (yytype_int16 const   )-348,      (yytype_int16 const   )-227};
#line 1187 "bsdl_bison.c"
static yytype_int16 const   yytable[676]  = 
#line 1187
  {      (yytype_int16 const   )256,      (yytype_int16 const   )477,      (yytype_int16 const   )258,      (yytype_int16 const   )641, 
        (yytype_int16 const   )409,      (yytype_int16 const   )645,      (yytype_int16 const   )406,      (yytype_int16 const   )100, 
        (yytype_int16 const   )516,      (yytype_int16 const   )471,      (yytype_int16 const   )148,      (yytype_int16 const   )511, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )505,      (yytype_int16 const   )275,      (yytype_int16 const   )472, 
        (yytype_int16 const   )516,      (yytype_int16 const   )280,      (yytype_int16 const   )541,      (yytype_int16 const   )5, 
        (yytype_int16 const   )583,      (yytype_int16 const   )362,      (yytype_int16 const   )423,      (yytype_int16 const   )446, 
        (yytype_int16 const   )511,      (yytype_int16 const   )177,      (yytype_int16 const   )41,      (yytype_int16 const   )23, 
        (yytype_int16 const   )287,      (yytype_int16 const   )358,      (yytype_int16 const   )24,      (yytype_int16 const   )42, 
        (yytype_int16 const   )376,      (yytype_int16 const   )53,      (yytype_int16 const   )598,      (yytype_int16 const   )359, 
        (yytype_int16 const   )478,      (yytype_int16 const   )479,      (yytype_int16 const   )584,      (yytype_int16 const   )130, 
        (yytype_int16 const   )517,      (yytype_int16 const   )669,      (yytype_int16 const   )451,      (yytype_int16 const   )599, 
        (yytype_int16 const   )151,      (yytype_int16 const   )377,      (yytype_int16 const   )7,      (yytype_int16 const   )6, 
        (yytype_int16 const   )304,      (yytype_int16 const   )276,      (yytype_int16 const   )8,      (yytype_int16 const   )378, 
        (yytype_int16 const   )379,      (yytype_int16 const   )380,      (yytype_int16 const   )381,      (yytype_int16 const   )382, 
        (yytype_int16 const   )662,      (yytype_int16 const   )314,      (yytype_int16 const   )315,      (yytype_int16 const   )316, 
        (yytype_int16 const   )317,      (yytype_int16 const   )318,      (yytype_int16 const   )319,      (yytype_int16 const   )320, 
        (yytype_int16 const   )321,      (yytype_int16 const   )322,      (yytype_int16 const   )646,      (yytype_int16 const   )647, 
        (yytype_int16 const   )648,      (yytype_int16 const   )649,      (yytype_int16 const   )650,      (yytype_int16 const   )651, 
        (yytype_int16 const   )652,      (yytype_int16 const   )177,      (yytype_int16 const   )653,      (yytype_int16 const   )654, 
        (yytype_int16 const   )383,      (yytype_int16 const   )384,      (yytype_int16 const   )385,      (yytype_int16 const   )386, 
        (yytype_int16 const   )387,      (yytype_int16 const   )388,      (yytype_int16 const   )389,      (yytype_int16 const   )390, 
        (yytype_int16 const   )391,      (yytype_int16 const   )392,      (yytype_int16 const   )393,      (yytype_int16 const   )394, 
        (yytype_int16 const   )395,      (yytype_int16 const   )396,      (yytype_int16 const   )397,      (yytype_int16 const   )130, 
        (yytype_int16 const   )344,      (yytype_int16 const   )151,      (yytype_int16 const   )473,      (yytype_int16 const   )149, 
        (yytype_int16 const   )512,      (yytype_int16 const   )519,      (yytype_int16 const   )409,      (yytype_int16 const   )480, 
        (yytype_int16 const   )474,      (yytype_int16 const   )642,      (yytype_int16 const   )101,      (yytype_int16 const   )407, 
        (yytype_int16 const   )404,      (yytype_int16 const   )518,      (yytype_int16 const   )54,      (yytype_int16 const   )11, 
        (yytype_int16 const   )506,      (yytype_int16 const   )519,      (yytype_int16 const   )363,      (yytype_int16 const   )424, 
        (yytype_int16 const   )447,      (yytype_int16 const   )512,      (yytype_int16 const   )12,      (yytype_int16 const   )375, 
        (yytype_int16 const   )306,      (yytype_int16 const   )26,      (yytype_int16 const   )552,      (yytype_int16 const   )655, 
        (yytype_int16 const   )670,      (yytype_int16 const   )671,      (yytype_int16 const   )672,      (yytype_int16 const   )673, 
        (yytype_int16 const   )674,      (yytype_int16 const   )675,      (yytype_int16 const   )676,      (yytype_int16 const   )174, 
        (yytype_int16 const   )175,      (yytype_int16 const   )210,      (yytype_int16 const   )36,      (yytype_int16 const   )663, 
        (yytype_int16 const   )664,      (yytype_int16 const   )665,      (yytype_int16 const   )666,      (yytype_int16 const   )603, 
        (yytype_int16 const   )604,      (yytype_int16 const   )605,      (yytype_int16 const   )606,      (yytype_int16 const   )607, 
        (yytype_int16 const   )608,      (yytype_int16 const   )609,      (yytype_int16 const   )610,      (yytype_int16 const   )45, 
        (yytype_int16 const   )398,      (yytype_int16 const   )399,      (yytype_int16 const   )400,      (yytype_int16 const   )401, 
        (yytype_int16 const   )347,      (yytype_int16 const   )402,      (yytype_int16 const   )405,      (yytype_int16 const   )307, 
        (yytype_int16 const   )347,      (yytype_int16 const   )553,      (yytype_int16 const   )348,      (yytype_int16 const   )347, 
        (yytype_int16 const   )358,      (yytype_int16 const   )408,      (yytype_int16 const   )348,      (yytype_int16 const   )40, 
        (yytype_int16 const   )13,      (yytype_int16 const   )348,      (yytype_int16 const   )359,      (yytype_int16 const   )485, 
        (yytype_int16 const   )427,      (yytype_int16 const   )428,      (yytype_int16 const   )14,      (yytype_int16 const   )429, 
        (yytype_int16 const   )430,      (yytype_int16 const   )431,      (yytype_int16 const   )495,      (yytype_int16 const   )496, 
        (yytype_int16 const   )497,      (yytype_int16 const   )498,      (yytype_int16 const   )64,      (yytype_int16 const   )499, 
        (yytype_int16 const   )32,      (yytype_int16 const   )64,      (yytype_int16 const   )626,      (yytype_int16 const   )1, 
        (yytype_int16 const   )65,      (yytype_int16 const   )2,      (yytype_int16 const   )33,      (yytype_int16 const   )105, 
        (yytype_int16 const   )627,      (yytype_int16 const   )349,      (yytype_int16 const   )350,      (yytype_int16 const   )-276, 
        (yytype_int16 const   )611,      (yytype_int16 const   )349,      (yytype_int16 const   )350,      (yytype_int16 const   )97, 
        (yytype_int16 const   )349,      (yytype_int16 const   )350,      (yytype_int16 const   )432,      (yytype_int16 const   )188, 
        (yytype_int16 const   )98,      (yytype_int16 const   )450,      (yytype_int16 const   )51,      (yytype_int16 const   )189, 
        (yytype_int16 const   )500,      (yytype_int16 const   )450,      (yytype_int16 const   )120,      (yytype_int16 const   )121, 
        (yytype_int16 const   )122,      (yytype_int16 const   )123,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )126,      (yytype_int16 const   )174,      (yytype_int16 const   )175,      (yytype_int16 const   )46, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )120,      (yytype_int16 const   )121, 
        (yytype_int16 const   )122,      (yytype_int16 const   )123,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )126,      (yytype_int16 const   )598,      (yytype_int16 const   )453,      (yytype_int16 const   )47, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )457,      (yytype_int16 const   )416, 
        (yytype_int16 const   )95,      (yytype_int16 const   )417,      (yytype_int16 const   )599,      (yytype_int16 const   )96, 
        (yytype_int16 const   )618,      (yytype_int16 const   )629,      (yytype_int16 const   )630,      (yytype_int16 const   )631, 
        (yytype_int16 const   )48,      (yytype_int16 const   )632,      (yytype_int16 const   )633,      (yytype_int16 const   )634, 
        (yytype_int16 const   )49,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )139,      (yytype_int16 const   )140, 
        (yytype_int16 const   )141,      (yytype_int16 const   )142,      (yytype_int16 const   )143,      (yytype_int16 const   )50, 
        (yytype_int16 const   )223,      (yytype_int16 const   )224,      (yytype_int16 const   )225,      (yytype_int16 const   )408, 
        (yytype_int16 const   )52,      (yytype_int16 const   )455,      (yytype_int16 const   )490,      (yytype_int16 const   )416, 
        (yytype_int16 const   )491,      (yytype_int16 const   )528,      (yytype_int16 const   )534,      (yytype_int16 const   )546, 
        (yytype_int16 const   )535,      (yytype_int16 const   )547,      (yytype_int16 const   )548,      (yytype_int16 const   )555, 
        (yytype_int16 const   )549,      (yytype_int16 const   )556,      (yytype_int16 const   )657,      (yytype_int16 const   )55, 
        (yytype_int16 const   )658,      (yytype_int16 const   )180,      (yytype_int16 const   )181,      (yytype_int16 const   )220, 
        (yytype_int16 const   )221,      (yytype_int16 const   )272,      (yytype_int16 const   )273,      (yytype_int16 const   )188, 
        (yytype_int16 const   )284,      (yytype_int16 const   )188,      (yytype_int16 const   )286,      (yytype_int16 const   )188, 
        (yytype_int16 const   )305,      (yytype_int16 const   )309,      (yytype_int16 const   )310,      (yytype_int16 const   )188, 
        (yytype_int16 const   )313,      (yytype_int16 const   )188,      (yytype_int16 const   )328,      (yytype_int16 const   )188, 
        (yytype_int16 const   )335,      (yytype_int16 const   )188,      (yytype_int16 const   )336,      (yytype_int16 const   )188, 
        (yytype_int16 const   )337,      (yytype_int16 const   )188,      (yytype_int16 const   )338,      (yytype_int16 const   )188, 
        (yytype_int16 const   )339,      (yytype_int16 const   )188,      (yytype_int16 const   )340,      (yytype_int16 const   )188, 
        (yytype_int16 const   )341,      (yytype_int16 const   )188,      (yytype_int16 const   )342,      (yytype_int16 const   )188, 
        (yytype_int16 const   )343,      (yytype_int16 const   )188,      (yytype_int16 const   )373,      (yytype_int16 const   )188, 
        (yytype_int16 const   )440,      (yytype_int16 const   )565,      (yytype_int16 const   )566,      (yytype_int16 const   )57, 
        (yytype_int16 const   )59,      (yytype_int16 const   )68,      (yytype_int16 const   )63,      (yytype_int16 const   )72, 
        (yytype_int16 const   )71,      (yytype_int16 const   )77,      (yytype_int16 const   )73,      (yytype_int16 const   )74, 
        (yytype_int16 const   )75,      (yytype_int16 const   )76,      (yytype_int16 const   )78,      (yytype_int16 const   )79, 
        (yytype_int16 const   )80,      (yytype_int16 const   )81,      (yytype_int16 const   )82,      (yytype_int16 const   )53, 
        (yytype_int16 const   )102,      (yytype_int16 const   )109,      (yytype_int16 const   )119,      (yytype_int16 const   )129, 
        (yytype_int16 const   )107,      (yytype_int16 const   )110,      (yytype_int16 const   )115,      (yytype_int16 const   )117, 
        (yytype_int16 const   )118,      (yytype_int16 const   )146,      (yytype_int16 const   )138,      (yytype_int16 const   )147, 
        (yytype_int16 const   )111,      (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )114, 
        (yytype_int16 const   )116,      (yytype_int16 const   )100,      (yytype_int16 const   )154,      (yytype_int16 const   )164, 
        (yytype_int16 const   )137,      (yytype_int16 const   )165,      (yytype_int16 const   )166,      (yytype_int16 const   )156, 
        (yytype_int16 const   )157,      (yytype_int16 const   )158,      (yytype_int16 const   )159,      (yytype_int16 const   )160, 
        (yytype_int16 const   )167,      (yytype_int16 const   )161,      (yytype_int16 const   )168,      (yytype_int16 const   )162, 
        (yytype_int16 const   )145,      (yytype_int16 const   )169,      (yytype_int16 const   )163,      (yytype_int16 const   )170, 
        (yytype_int16 const   )171,      (yytype_int16 const   )172,      (yytype_int16 const   )173,      (yytype_int16 const   )176, 
        (yytype_int16 const   )184,      (yytype_int16 const   )186,      (yytype_int16 const   )185,      (yytype_int16 const   )183, 
        (yytype_int16 const   )187,      (yytype_int16 const   )190,      (yytype_int16 const   )191,      (yytype_int16 const   )192, 
        (yytype_int16 const   )193,      (yytype_int16 const   )194,      (yytype_int16 const   )195,      (yytype_int16 const   )196, 
        (yytype_int16 const   )197,      (yytype_int16 const   )198,      (yytype_int16 const   )199,      (yytype_int16 const   )200, 
        (yytype_int16 const   )201,      (yytype_int16 const   )202,      (yytype_int16 const   )203,      (yytype_int16 const   )204, 
        (yytype_int16 const   )205,      (yytype_int16 const   )206,      (yytype_int16 const   )207,      (yytype_int16 const   )208, 
        (yytype_int16 const   )209,      (yytype_int16 const   )212,      (yytype_int16 const   )214,      (yytype_int16 const   )215, 
        (yytype_int16 const   )216,      (yytype_int16 const   )217,      (yytype_int16 const   )218,      (yytype_int16 const   )227, 
        (yytype_int16 const   )228,      (yytype_int16 const   )229,      (yytype_int16 const   )213,      (yytype_int16 const   )219, 
        (yytype_int16 const   )230,      (yytype_int16 const   )242,      (yytype_int16 const   )246,      (yytype_int16 const   )247, 
        (yytype_int16 const   )259,      (yytype_int16 const   )226,      (yytype_int16 const   )260,      (yytype_int16 const   )261, 
        (yytype_int16 const   )262,      (yytype_int16 const   )240,      (yytype_int16 const   )263,      (yytype_int16 const   )241, 
        (yytype_int16 const   )231,      (yytype_int16 const   )232,      (yytype_int16 const   )233,      (yytype_int16 const   )234, 
        (yytype_int16 const   )235,      (yytype_int16 const   )264,      (yytype_int16 const   )243,      (yytype_int16 const   )236, 
        (yytype_int16 const   )237,      (yytype_int16 const   )265,      (yytype_int16 const   )266,      (yytype_int16 const   )238, 
        (yytype_int16 const   )267,      (yytype_int16 const   )239,      (yytype_int16 const   )249,      (yytype_int16 const   )268, 
        (yytype_int16 const   )278,      (yytype_int16 const   )297,      (yytype_int16 const   )279,      (yytype_int16 const   )288, 
        (yytype_int16 const   )298,      (yytype_int16 const   )248,      (yytype_int16 const   )251,      (yytype_int16 const   )252, 
        (yytype_int16 const   )253,      (yytype_int16 const   )257,      (yytype_int16 const   )255,      (yytype_int16 const   )254, 
        (yytype_int16 const   )289,      (yytype_int16 const   )290,      (yytype_int16 const   )291,      (yytype_int16 const   )292, 
        (yytype_int16 const   )293,      (yytype_int16 const   )271,      (yytype_int16 const   )294,      (yytype_int16 const   )269, 
        (yytype_int16 const   )274,      (yytype_int16 const   )270,      (yytype_int16 const   )282,      (yytype_int16 const   )283, 
        (yytype_int16 const   )295,      (yytype_int16 const   )296,      (yytype_int16 const   )299,      (yytype_int16 const   )300, 
        (yytype_int16 const   )303,      (yytype_int16 const   )302,      (yytype_int16 const   )285,      (yytype_int16 const   )323, 
        (yytype_int16 const   )324,      (yytype_int16 const   )325,      (yytype_int16 const   )301,      (yytype_int16 const   )326, 
        (yytype_int16 const   )330,      (yytype_int16 const   )346,      (yytype_int16 const   )345,      (yytype_int16 const   )353, 
        (yytype_int16 const   )356,      (yytype_int16 const   )327,      (yytype_int16 const   )442,      (yytype_int16 const   )408, 
        (yytype_int16 const   )443,      (yytype_int16 const   )331,      (yytype_int16 const   )444,      (yytype_int16 const   )445, 
        (yytype_int16 const   )482,      (yytype_int16 const   )449,      (yytype_int16 const   )332,      (yytype_int16 const   )483, 
        (yytype_int16 const   )476,      (yytype_int16 const   )421,      (yytype_int16 const   )357,      (yytype_int16 const   )374, 
        (yytype_int16 const   )422,      (yytype_int16 const   )569,      (yytype_int16 const   )413,      (yytype_int16 const   )542, 
        (yytype_int16 const   )415,      (yytype_int16 const   )418,      (yytype_int16 const   )412,      (yytype_int16 const   )420, 
        (yytype_int16 const   )419,      (yytype_int16 const   )437,      (yytype_int16 const   )526,      (yytype_int16 const   )571, 
        (yytype_int16 const   )438,      (yytype_int16 const   )414,      (yytype_int16 const   )456,      (yytype_int16 const   )363, 
        (yytype_int16 const   )619,      (yytype_int16 const   )539,      (yytype_int16 const   )467,      (yytype_int16 const   )459, 
        (yytype_int16 const   )660,      (yytype_int16 const   )567,      (yytype_int16 const   )487,      (yytype_int16 const   )591, 
        (yytype_int16 const   )441,      (yytype_int16 const   )462,      (yytype_int16 const   )463,      (yytype_int16 const   )595, 
        (yytype_int16 const   )596,      (yytype_int16 const   )465,      (yytype_int16 const   )597,      (yytype_int16 const   )464, 
        (yytype_int16 const   )466,      (yytype_int16 const   )424,      (yytype_int16 const   )564,      (yytype_int16 const   )562, 
        (yytype_int16 const   )572,      (yytype_int16 const   )488,      (yytype_int16 const   )484,      (yytype_int16 const   )454, 
        (yytype_int16 const   )493,      (yytype_int16 const   )486,      (yytype_int16 const   )532,      (yytype_int16 const   )492, 
        (yytype_int16 const   )489,      (yytype_int16 const   )561,      (yytype_int16 const   )536,      (yytype_int16 const   )494, 
        (yytype_int16 const   )504,      (yytype_int16 const   )557,      (yytype_int16 const   )510,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )211,      (yytype_int16 const   )509,      (yytype_int16 const   )527, 
        (yytype_int16 const   )530,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )515, 
        (yytype_int16 const   )523,      (yytype_int16 const   )0,      (yytype_int16 const   )37,      (yytype_int16 const   )524, 
        (yytype_int16 const   )525,      (yytype_int16 const   )529,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )636,      (yytype_int16 const   )537,      (yytype_int16 const   )538,      (yytype_int16 const   )533, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )558,      (yytype_int16 const   )543,      (yytype_int16 const   )58,      (yytype_int16 const   )563, 
        (yytype_int16 const   )0,      (yytype_int16 const   )545,      (yytype_int16 const   )540,      (yytype_int16 const   )506, 
        (yytype_int16 const   )544,      (yytype_int16 const   )550,      (yytype_int16 const   )551,      (yytype_int16 const   )568, 
        (yytype_int16 const   )570,      (yytype_int16 const   )0,      (yytype_int16 const   )573,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )582,      (yytype_int16 const   )0, 
        (yytype_int16 const   )574,      (yytype_int16 const   )579,      (yytype_int16 const   )580,      (yytype_int16 const   )576, 
        (yytype_int16 const   )575,      (yytype_int16 const   )578,      (yytype_int16 const   )586,      (yytype_int16 const   )94, 
        (yytype_int16 const   )106,      (yytype_int16 const   )602,      (yytype_int16 const   )614,      (yytype_int16 const   )581, 
        (yytype_int16 const   )577,      (yytype_int16 const   )588,      (yytype_int16 const   )108,      (yytype_int16 const   )589, 
        (yytype_int16 const   )590,      (yytype_int16 const   )592,      (yytype_int16 const   )593,      (yytype_int16 const   )594, 
        (yytype_int16 const   )613,      (yytype_int16 const   )615,      (yytype_int16 const   )616,      (yytype_int16 const   )617, 
        (yytype_int16 const   )625,      (yytype_int16 const   )621,      (yytype_int16 const   )620,      (yytype_int16 const   )622, 
        (yytype_int16 const   )623,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )639, 
        (yytype_int16 const   )136,      (yytype_int16 const   )624,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )661,      (yytype_int16 const   )640,      (yytype_int16 const   )638, 
        (yytype_int16 const   )659,      (yytype_int16 const   )668,      (yytype_int16 const   )135,      (yytype_int16 const   )0, 
        (yytype_int16 const   )678,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )152,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )179};
#line 1259 "bsdl_bison.c"
static yytype_int16 const   yycheck[676]  = 
#line 1259
  {      (yytype_int16 const   )227,      (yytype_int16 const   )1,      (yytype_int16 const   )229,      (yytype_int16 const   )1, 
        (yytype_int16 const   )351,      (yytype_int16 const   )1,      (yytype_int16 const   )16,      (yytype_int16 const   )14, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )11, 
        (yytype_int16 const   )1,      (yytype_int16 const   )248,      (yytype_int16 const   )12,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )131,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )259,      (yytype_int16 const   )90,      (yytype_int16 const   )4,      (yytype_int16 const   )6, 
        (yytype_int16 const   )1,      (yytype_int16 const   )45,      (yytype_int16 const   )1,      (yytype_int16 const   )96, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )108,      (yytype_int16 const   )83, 
        (yytype_int16 const   )25,      (yytype_int16 const   )1,      (yytype_int16 const   )103,      (yytype_int16 const   )10, 
        (yytype_int16 const   )103,      (yytype_int16 const   )14,      (yytype_int16 const   )1,      (yytype_int16 const   )0, 
        (yytype_int16 const   )279,      (yytype_int16 const   )36,      (yytype_int16 const   )5,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )1,      (yytype_int16 const   )288,      (yytype_int16 const   )289,      (yytype_int16 const   )290, 
        (yytype_int16 const   )291,      (yytype_int16 const   )292,      (yytype_int16 const   )293,      (yytype_int16 const   )294, 
        (yytype_int16 const   )295,      (yytype_int16 const   )296,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )70,      (yytype_int16 const   )71, 
        (yytype_int16 const   )72,      (yytype_int16 const   )179,      (yytype_int16 const   )74,      (yytype_int16 const   )75, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )135, 
        (yytype_int16 const   )323,      (yytype_int16 const   )152,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )94,      (yytype_int16 const   )449,      (yytype_int16 const   )103, 
        (yytype_int16 const   )96,      (yytype_int16 const   )103,      (yytype_int16 const   )113,      (yytype_int16 const   )117, 
        (yytype_int16 const   )44,      (yytype_int16 const   )90,      (yytype_int16 const   )118,      (yytype_int16 const   )8, 
        (yytype_int16 const   )96,      (yytype_int16 const   )94,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )103,      (yytype_int16 const   )346, 
        (yytype_int16 const   )1,      (yytype_int16 const   )15,      (yytype_int16 const   )1,      (yytype_int16 const   )119, 
        (yytype_int16 const   )80,      (yytype_int16 const   )81,      (yytype_int16 const   )82,      (yytype_int16 const   )83, 
        (yytype_int16 const   )84,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )7,      (yytype_int16 const   )76, 
        (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )79,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )70, 
        (yytype_int16 const   )71,      (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )107, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )115,      (yytype_int16 const   )116, 
        (yytype_int16 const   )1,      (yytype_int16 const   )118,      (yytype_int16 const   )90,      (yytype_int16 const   )36, 
        (yytype_int16 const   )1,      (yytype_int16 const   )36,      (yytype_int16 const   )7,      (yytype_int16 const   )1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )10,      (yytype_int16 const   )7,      (yytype_int16 const   )103, 
        (yytype_int16 const   )1,      (yytype_int16 const   )7,      (yytype_int16 const   )96,      (yytype_int16 const   )12, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )7,      (yytype_int16 const   )63, 
        (yytype_int16 const   )64,      (yytype_int16 const   )65,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )1,      (yytype_int16 const   )65, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )90,      (yytype_int16 const   )1, 
        (yytype_int16 const   )7,      (yytype_int16 const   )3,      (yytype_int16 const   )7,      (yytype_int16 const   )7, 
        (yytype_int16 const   )96,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )12, 
        (yytype_int16 const   )119,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )102, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )90,      (yytype_int16 const   )100, 
        (yytype_int16 const   )107,      (yytype_int16 const   )410,      (yytype_int16 const   )59,      (yytype_int16 const   )104, 
        (yytype_int16 const   )90,      (yytype_int16 const   )414,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )9, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )1,      (yytype_int16 const   )412,      (yytype_int16 const   )9, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )416,      (yytype_int16 const   )102, 
        (yytype_int16 const   )101,      (yytype_int16 const   )104,      (yytype_int16 const   )10,      (yytype_int16 const   )104, 
        (yytype_int16 const   )12,      (yytype_int16 const   )87,      (yytype_int16 const   )88,      (yytype_int16 const   )89, 
        (yytype_int16 const   )9,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )9,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )27,      (yytype_int16 const   )28, 
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )9, 
        (yytype_int16 const   )191,      (yytype_int16 const   )192,      (yytype_int16 const   )193,      (yytype_int16 const   )10, 
        (yytype_int16 const   )12,      (yytype_int16 const   )12,      (yytype_int16 const   )102,      (yytype_int16 const   )102, 
        (yytype_int16 const   )104,      (yytype_int16 const   )104,      (yytype_int16 const   )102,      (yytype_int16 const   )102, 
        (yytype_int16 const   )104,      (yytype_int16 const   )104,      (yytype_int16 const   )102,      (yytype_int16 const   )102, 
        (yytype_int16 const   )104,      (yytype_int16 const   )104,      (yytype_int16 const   )102,      (yytype_int16 const   )7, 
        (yytype_int16 const   )104,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )7, 
        (yytype_int16 const   )90,      (yytype_int16 const   )6,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )11,      (yytype_int16 const   )9,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )9, 
        (yytype_int16 const   )9,      (yytype_int16 const   )46,      (yytype_int16 const   )7,      (yytype_int16 const   )45, 
        (yytype_int16 const   )10,      (yytype_int16 const   )110,      (yytype_int16 const   )9,      (yytype_int16 const   )7, 
        (yytype_int16 const   )90,      (yytype_int16 const   )107,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )9,      (yytype_int16 const   )90,      (yytype_int16 const   )9, 
        (yytype_int16 const   )107,      (yytype_int16 const   )107,      (yytype_int16 const   )107,      (yytype_int16 const   )107, 
        (yytype_int16 const   )101,      (yytype_int16 const   )14,      (yytype_int16 const   )95,      (yytype_int16 const   )90, 
        (yytype_int16 const   )101,      (yytype_int16 const   )9,      (yytype_int16 const   )9,      (yytype_int16 const   )19, 
        (yytype_int16 const   )19,      (yytype_int16 const   )19,      (yytype_int16 const   )19,      (yytype_int16 const   )19, 
        (yytype_int16 const   )9,      (yytype_int16 const   )107,      (yytype_int16 const   )9,      (yytype_int16 const   )107, 
        (yytype_int16 const   )111,      (yytype_int16 const   )9,      (yytype_int16 const   )107,      (yytype_int16 const   )9, 
        (yytype_int16 const   )9,      (yytype_int16 const   )9,      (yytype_int16 const   )9,      (yytype_int16 const   )7, 
        (yytype_int16 const   )90,      (yytype_int16 const   )107,      (yytype_int16 const   )90,      (yytype_int16 const   )13, 
        (yytype_int16 const   )111,      (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )3,      (yytype_int16 const   )3, 
        (yytype_int16 const   )3,      (yytype_int16 const   )107,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )9, 
        (yytype_int16 const   )9,      (yytype_int16 const   )103,      (yytype_int16 const   )107,      (yytype_int16 const   )107, 
        (yytype_int16 const   )16,      (yytype_int16 const   )13,      (yytype_int16 const   )95,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )101,      (yytype_int16 const   )101, 
        (yytype_int16 const   )3,      (yytype_int16 const   )9,      (yytype_int16 const   )3,      (yytype_int16 const   )3, 
        (yytype_int16 const   )8,      (yytype_int16 const   )103,      (yytype_int16 const   )3,      (yytype_int16 const   )3, 
        (yytype_int16 const   )3,      (yytype_int16 const   )90,      (yytype_int16 const   )3,      (yytype_int16 const   )90, 
        (yytype_int16 const   )107,      (yytype_int16 const   )107,      (yytype_int16 const   )107,      (yytype_int16 const   )107, 
        (yytype_int16 const   )107,      (yytype_int16 const   )3,      (yytype_int16 const   )96,      (yytype_int16 const   )107, 
        (yytype_int16 const   )107,      (yytype_int16 const   )3,      (yytype_int16 const   )3,      (yytype_int16 const   )107, 
        (yytype_int16 const   )3,      (yytype_int16 const   )107,      (yytype_int16 const   )101,      (yytype_int16 const   )3, 
        (yytype_int16 const   )8,      (yytype_int16 const   )3,      (yytype_int16 const   )8,      (yytype_int16 const   )8, 
        (yytype_int16 const   )3,      (yytype_int16 const   )110,      (yytype_int16 const   )101,      (yytype_int16 const   )101, 
        (yytype_int16 const   )101,      (yytype_int16 const   )96,      (yytype_int16 const   )99,      (yytype_int16 const   )101, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )90,      (yytype_int16 const   )8,      (yytype_int16 const   )107, 
        (yytype_int16 const   )104,      (yytype_int16 const   )107,      (yytype_int16 const   )90,      (yytype_int16 const   )102, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )107,      (yytype_int16 const   )96, 
        (yytype_int16 const   )15,      (yytype_int16 const   )90,      (yytype_int16 const   )101,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )3,      (yytype_int16 const   )96,      (yytype_int16 const   )8, 
        (yytype_int16 const   )90,      (yytype_int16 const   )8,      (yytype_int16 const   )96,      (yytype_int16 const   )90, 
        (yytype_int16 const   )8,      (yytype_int16 const   )101,      (yytype_int16 const   )8,      (yytype_int16 const   )10, 
        (yytype_int16 const   )8,      (yytype_int16 const   )104,      (yytype_int16 const   )8,      (yytype_int16 const   )8, 
        (yytype_int16 const   )11,      (yytype_int16 const   )410,      (yytype_int16 const   )103,      (yytype_int16 const   )11, 
        (yytype_int16 const   )41,      (yytype_int16 const   )90,      (yytype_int16 const   )101,      (yytype_int16 const   )101, 
        (yytype_int16 const   )90,      (yytype_int16 const   )546,      (yytype_int16 const   )102,      (yytype_int16 const   )513, 
        (yytype_int16 const   )103,      (yytype_int16 const   )103,      (yytype_int16 const   )107,      (yytype_int16 const   )98, 
        (yytype_int16 const   )102,      (yytype_int16 const   )98,      (yytype_int16 const   )44,      (yytype_int16 const   )551, 
        (yytype_int16 const   )98,      (yytype_int16 const   )356,      (yytype_int16 const   )96,      (yytype_int16 const   )90, 
        (yytype_int16 const   )600,      (yytype_int16 const   )42,      (yytype_int16 const   )90,      (yytype_int16 const   )97, 
        (yytype_int16 const   )657,      (yytype_int16 const   )26,      (yytype_int16 const   )90,      (yytype_int16 const   )8, 
        (yytype_int16 const   )107,      (yytype_int16 const   )419,      (yytype_int16 const   )102,      (yytype_int16 const   )9, 
        (yytype_int16 const   )9,      (yytype_int16 const   )102,      (yytype_int16 const   )9,      (yytype_int16 const   )105, 
        (yytype_int16 const   )103,      (yytype_int16 const   )90,      (yytype_int16 const   )40,      (yytype_int16 const   )43, 
        (yytype_int16 const   )37,      (yytype_int16 const   )104,      (yytype_int16 const   )107,      (yytype_int16 const   )413, 
        (yytype_int16 const   )96,      (yytype_int16 const   )451,      (yytype_int16 const   )490,      (yytype_int16 const   )463, 
        (yytype_int16 const   )103,      (yytype_int16 const   )538,      (yytype_int16 const   )504,      (yytype_int16 const   )465, 
        (yytype_int16 const   )102,      (yytype_int16 const   )534,      (yytype_int16 const   )103,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )179,      (yytype_int16 const   )101,      (yytype_int16 const   )90, 
        (yytype_int16 const   )98,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )103, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )16,      (yytype_int16 const   )101, 
        (yytype_int16 const   )101,      (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )44,      (yytype_int16 const   )103,      (yytype_int16 const   )102,      (yytype_int16 const   )106, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )90,      (yytype_int16 const   )96,      (yytype_int16 const   )39,      (yytype_int16 const   )90, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )107,      (yytype_int16 const   )96, 
        (yytype_int16 const   )102,      (yytype_int16 const   )101,      (yytype_int16 const   )101,      (yytype_int16 const   )94, 
        (yytype_int16 const   )90,      (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )90,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )102,      (yytype_int16 const   )96,      (yytype_int16 const   )96,      (yytype_int16 const   )102, 
        (yytype_int16 const   )104,      (yytype_int16 const   )101,      (yytype_int16 const   )96,      (yytype_int16 const   )58, 
        (yytype_int16 const   )67,      (yytype_int16 const   )96,      (yytype_int16 const   )90,      (yytype_int16 const   )104, 
        (yytype_int16 const   )109,      (yytype_int16 const   )104,      (yytype_int16 const   )69,      (yytype_int16 const   )104, 
        (yytype_int16 const   )104,      (yytype_int16 const   )103,      (yytype_int16 const   )102,      (yytype_int16 const   )102, 
        (yytype_int16 const   )96,      (yytype_int16 const   )90,      (yytype_int16 const   )90,      (yytype_int16 const   )90, 
        (yytype_int16 const   )90,      (yytype_int16 const   )102,      (yytype_int16 const   )104,      (yytype_int16 const   )102, 
        (yytype_int16 const   )101,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )101, 
        (yytype_int16 const   )95,      (yytype_int16 const   )107,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )101,      (yytype_int16 const   )103,      (yytype_int16 const   )110, 
        (yytype_int16 const   )102,      (yytype_int16 const   )102,      (yytype_int16 const   )94,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )104,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )106,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )135};
#line 1333 "bsdl_bison.c"
static yytype_uint8 const   yystos[679]  = 
#line 1333
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )121, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )123,      (yytype_uint8 const   )126,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )124, 
        (yytype_uint8 const   )177,      (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )180, 
        (yytype_uint8 const   )181,      (yytype_uint8 const   )182,      (yytype_uint8 const   )183,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )128,      (yytype_uint8 const   )15,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )125,      (yytype_uint8 const   )238, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )178,      (yytype_uint8 const   )186,      (yytype_uint8 const   )240, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )107,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )45,      (yytype_uint8 const   )118,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )7,      (yytype_uint8 const   )186,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )167,      (yytype_uint8 const   )239, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )153,      (yytype_uint8 const   )163,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )9,      (yytype_uint8 const   )90,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )46,      (yytype_uint8 const   )7,      (yytype_uint8 const   )193, 
        (yytype_uint8 const   )194,      (yytype_uint8 const   )195,      (yytype_uint8 const   )197,      (yytype_uint8 const   )199, 
        (yytype_uint8 const   )201,      (yytype_uint8 const   )205,      (yytype_uint8 const   )206,      (yytype_uint8 const   )207, 
        (yytype_uint8 const   )209,      (yytype_uint8 const   )211,      (yytype_uint8 const   )187,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )102,      (yytype_uint8 const   )107,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )113,      (yytype_uint8 const   )10,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )169,      (yytype_uint8 const   )7,      (yytype_uint8 const   )167,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )163,      (yytype_uint8 const   )110,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )7,      (yytype_uint8 const   )194,      (yytype_uint8 const   )220, 
        (yytype_uint8 const   )221,      (yytype_uint8 const   )222,      (yytype_uint8 const   )226,      (yytype_uint8 const   )193, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )101,      (yytype_uint8 const   )90,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )111,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )90,      (yytype_uint8 const   )170,      (yytype_uint8 const   )169, 
        (yytype_uint8 const   )168,      (yytype_uint8 const   )164,      (yytype_uint8 const   )95,      (yytype_uint8 const   )245, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )19,      (yytype_uint8 const   )19,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )221,      (yytype_uint8 const   )227,      (yytype_uint8 const   )220, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )133,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )107,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )104,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )107,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )56,      (yytype_uint8 const   )227, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )101,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )13,      (yytype_uint8 const   )95,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )103,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )3,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )9,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )138,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )101,      (yytype_uint8 const   )127,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )96,      (yytype_uint8 const   )245,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )104,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )139,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )165,      (yytype_uint8 const   )90,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )245, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )96,      (yytype_uint8 const   )90,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )101,      (yytype_uint8 const   )1,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )184, 
        (yytype_uint8 const   )241,      (yytype_uint8 const   )101,      (yytype_uint8 const   )245,      (yytype_uint8 const   )245, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )245,      (yytype_uint8 const   )245,      (yytype_uint8 const   )245, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )245,      (yytype_uint8 const   )245,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )3,      (yytype_uint8 const   )8,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )171,      (yytype_uint8 const   )90,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )242,      (yytype_uint8 const   )188,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )245,      (yytype_uint8 const   )96,      (yytype_uint8 const   )8,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )140, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )90,      (yytype_uint8 const   )172,      (yytype_uint8 const   )173, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )101,      (yytype_uint8 const   )90,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )1,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )196,      (yytype_uint8 const   )198, 
        (yytype_uint8 const   )200,      (yytype_uint8 const   )202,      (yytype_uint8 const   )212,      (yytype_uint8 const   )208, 
        (yytype_uint8 const   )210,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )245, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )14,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )113,      (yytype_uint8 const   )114, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )118,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )90,      (yytype_uint8 const   )16,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )141,      (yytype_uint8 const   )150,      (yytype_uint8 const   )151, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )102,      (yytype_uint8 const   )150,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )104,      (yytype_uint8 const   )103,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )203,      (yytype_uint8 const   )204,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )213,      (yytype_uint8 const   )214,      (yytype_uint8 const   )215, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )223, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )107,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )152,      (yytype_uint8 const   )140,      (yytype_uint8 const   )151,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )174,      (yytype_uint8 const   )176,      (yytype_uint8 const   )173,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )176,      (yytype_uint8 const   )243,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )191,      (yytype_uint8 const   )192,      (yytype_uint8 const   )190,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )224,      (yytype_uint8 const   )225,      (yytype_uint8 const   )228,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )90,      (yytype_uint8 const   )96,      (yytype_uint8 const   )143, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )1,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )144,      (yytype_uint8 const   )11,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )12,      (yytype_uint8 const   )175,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )103,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )204,      (yytype_uint8 const   )96,      (yytype_uint8 const   )214,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )217,      (yytype_uint8 const   )218,      (yytype_uint8 const   )219, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )1,      (yytype_uint8 const   )96,      (yytype_uint8 const   )229, 
        (yytype_uint8 const   )230,      (yytype_uint8 const   )101,      (yytype_uint8 const   )103,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )148,      (yytype_uint8 const   )149,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )25,      (yytype_uint8 const   )90,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )146,      (yytype_uint8 const   )147,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )44,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )101,      (yytype_uint8 const   )98,      (yytype_uint8 const   )244, 
        (yytype_uint8 const   )192,      (yytype_uint8 const   )106,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )225,      (yytype_uint8 const   )103,      (yytype_uint8 const   )102,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )12,      (yytype_uint8 const   )149,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )98,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )104,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )36,      (yytype_uint8 const   )154,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )219,      (yytype_uint8 const   )90,      (yytype_uint8 const   )231, 
        (yytype_uint8 const   )232,      (yytype_uint8 const   )230,      (yytype_uint8 const   )43,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )147,      (yytype_uint8 const   )90,      (yytype_uint8 const   )154, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )98,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )104,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )233,      (yytype_uint8 const   )96,      (yytype_uint8 const   )236, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )104,      (yytype_uint8 const   )104,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )157,      (yytype_uint8 const   )96,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )96,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )12,      (yytype_uint8 const   )157, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )93,      (yytype_uint8 const   )237, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )155,      (yytype_uint8 const   )110,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )1,      (yytype_uint8 const   )103,      (yytype_uint8 const   )158, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )1,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )101,      (yytype_uint8 const   )1,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )161, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )1,      (yytype_uint8 const   )80,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )162,      (yytype_uint8 const   )104};
#line 1896 "bsdl_bison.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_priv_t *priv_data ) 
{ 


  {
#line 1910
  if (! yymsg) {
#line 1911
    yymsg = "Deleting";
  }
  {
#line 1917
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1918
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1920
  return;
}
}
#line 1961 "bsdl_bison.c"
int bsdlparse(parser_priv_t *priv_data ) 
{ 
  int bsdlchar ;
  YYSTYPE bsdllval ;
  int bsdlnerrs ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;

  {
#line 1985
  yytoken = 0;
#line 2003
  yyss = yyssa;
#line 2008
  yyvs = yyvsa;
#line 2015
  yystacksize = 200UL;
#line 2024
  yylen = 0;
#line 2028
  yystate = 0;
#line 2029
  yyerrstatus = 0;
#line 2030
  bsdlnerrs = 0;
#line 2031
  bsdlchar = -2;
#line 2038
  yyssp = yyss;
#line 2039
  yyvsp = yyvs;
#line 2041
  goto yysetstate;
  yynewstate: 
#line 2049
  yyssp ++;
  yysetstate: 
#line 2052
  *yyssp = (yytype_int16 )yystate;
#line 2054
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 2057
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 2086
    if (10000UL <= yystacksize) {
#line 2087
      goto yyexhaustedlab;
    }
#line 2088
    yystacksize *= 2UL;
#line 2089
    if (10000UL < yystacksize) {
#line 2090
      yystacksize = 10000UL;
    }
    {
#line 2093
    yyss1 = yyss;
#line 2094
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 2094
    yyptr = (union yyalloc *)tmp;
    }
#line 2096
    if (! yyptr) {
#line 2097
      goto yyexhaustedlab;
    }
    {
#line 2098
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2098
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 2098
      yyss = & yyptr->yyss;
#line 2098
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 2098
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 2098
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2099
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2099
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 2099
      yyvs = & yyptr->yyvs;
#line 2099
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 2099
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 2099
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2102
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 2103
      free((void *)yyss1);
      }
    }
#line 2108
    yyssp = (yyss + yysize) - 1;
#line 2109
    yyvsp = (yyvs + yysize) - 1;
#line 2115
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 2116
      goto yyabortlab;
    }
  }
#line 2121
  goto yybackup;
  yybackup: 
#line 2132
  yyn = (int )yypact[yystate];
#line 2133
  if (yyn == -348) {
#line 2134
    goto yydefault;
  }
#line 2139
  if (bsdlchar == -2) {
    {
#line 2142
    bsdlchar = bsdllex(& bsdllval, priv_data->scanner);
    }
  }
#line 2145
  if (bsdlchar <= 0) {
#line 2147
    yytoken = 0;
#line 2147
    bsdlchar = yytoken;
  } else
#line 2152
  if ((unsigned int )bsdlchar <= 374U) {
#line 2152
    yytoken = (int )yytranslate[bsdlchar];
  } else {
#line 2152
    yytoken = 2;
  }
#line 2158
  yyn += yytoken;
#line 2159
  if (yyn < 0) {
#line 2160
    goto yydefault;
  } else
#line 2159
  if (675 < yyn) {
#line 2160
    goto yydefault;
  } else
#line 2159
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 2160
    goto yydefault;
  }
#line 2161
  yyn = (int )yytable[yyn];
#line 2162
  if (yyn <= 0) {
#line 2164
    if (yyn == 0) {
#line 2165
      goto yyerrlab;
    } else
#line 2164
    if (yyn == -277) {
#line 2165
      goto yyerrlab;
    }
#line 2166
    yyn = - yyn;
#line 2167
    goto yyreduce;
  }
#line 2170
  if (yyn == 6) {
#line 2171
    goto yyacceptlab;
  }
#line 2175
  if (yyerrstatus) {
#line 2176
    yyerrstatus --;
  }
#line 2182
  if (bsdlchar != 0) {
#line 2183
    bsdlchar = -2;
  }
#line 2185
  yystate = yyn;
#line 2186
  yyvsp ++;
#line 2186
  *yyvsp = bsdllval;
#line 2188
  goto yynewstate;
  yydefault: 
#line 2195
  yyn = (int )yydefact[yystate];
#line 2196
  if (yyn == 0) {
#line 2197
    goto yyerrlab;
  }
#line 2198
  goto yyreduce;
  yyreduce: 
#line 2206
  yylen = (int )yyr2[yyn];
#line 2216
  yyval = *(yyvsp + (1 - yylen));
  {
#line 2222
  if (yyn == 3) {
#line 2222
    goto case_3;
  }
#line 213
  if (yyn == 4) {
#line 213 "bsdl_bison.y"
    goto case_4;
  }
#line 218
  if (yyn == 7) {
#line 218
    goto case_7;
  }
#line 233
  if (yyn == 10) {
#line 233
    goto case_10;
  }
#line 250
  if (yyn == 11) {
#line 250
    goto case_11;
  }
#line 253
  if (yyn == 12) {
#line 253
    goto case_12;
  }
#line 256
  if (yyn == 13) {
#line 256
    goto case_13;
  }
#line 263
  if (yyn == 14) {
#line 263
    goto case_14;
  }
#line 265
  if (yyn == 16) {
#line 265
    goto case_16;
  }
#line 270
  if (yyn == 19) {
#line 270
    goto case_19;
  }
#line 278
  if (yyn == 20) {
#line 278
    goto case_20;
  }
#line 281
  if (yyn == 21) {
#line 281
    goto case_21;
  }
#line 285
  if (yyn == 27) {
#line 285
    goto case_27;
  }
#line 290
  if (yyn == 29) {
#line 290
    goto case_29;
  }
#line 294
  if (yyn == 30) {
#line 294
    goto case_30;
  }
#line 296
  if (yyn == 33) {
#line 296
    goto case_33;
  }
#line 302
  if (yyn == 34) {
#line 302
    goto case_34;
  }
#line 308
  if (yyn == 35) {
#line 308
    goto case_35;
  }
#line 314
  if (yyn == 36) {
#line 314
    goto case_36;
  }
#line 318
  if (yyn == 37) {
#line 318
    goto case_37;
  }
#line 322
  if (yyn == 38) {
#line 322
    goto case_38;
  }
#line 325
  if (yyn == 42) {
#line 325
    goto case_42;
  }
#line 332
  if (yyn == 43) {
#line 332
    goto case_43;
  }
#line 335
  if (yyn == 46) {
#line 335
    goto case_46;
  }
#line 340
  if (yyn == 73) {
#line 340
    goto case_73;
  }
#line 356
  if (yyn == 74) {
#line 356
    goto case_74;
  }
#line 359
  if (yyn == 77) {
#line 359
    goto case_77;
  }
#line 364
  if (yyn == 81) {
#line 364
    goto case_81;
  }
#line 371
  if (yyn == 82) {
#line 371
    goto case_82;
  }
#line 374
  if (yyn == 84) {
#line 374
    goto case_84;
  }
#line 378
  if (yyn == 87) {
#line 378
    goto case_87;
  }
#line 384
  if (yyn == 88) {
#line 384
    goto case_88;
  }
#line 386
  if (yyn == 89) {
#line 386
    goto case_89;
  }
#line 389
  if (yyn == 90) {
#line 389
    goto case_90;
  }
#line 392
  if (yyn == 93) {
#line 392
    goto case_93;
  }
#line 398
  if (yyn == 94) {
#line 398
    goto case_94;
  }
#line 401
  if (yyn == 98) {
#line 401
    goto case_98;
  }
#line 409
  if (yyn == 99) {
#line 409
    goto case_99;
  }
#line 412
  if (yyn == 102) {
#line 412
    goto case_102;
  }
#line 418
  if (yyn == 104) {
#line 418
    goto case_104;
  }
#line 422
  if (yyn == 107) {
#line 422
    goto case_107;
  }
#line 429
  if (yyn == 108) {
#line 429
    goto case_108;
  }
#line 432
  if (yyn == 112) {
#line 432
    goto case_112;
  }
#line 441
  if (yyn == 123) {
#line 441
    goto case_123;
  }
#line 448
  if (yyn == 128) {
#line 448
    goto case_128;
  }
#line 453
  if (yyn == 136) {
#line 453
    goto case_136;
  }
#line 458
  if (yyn == 137) {
#line 458
    goto case_137;
  }
#line 464
  if (yyn == 138) {
#line 464
    goto case_138;
  }
#line 470
  if (yyn == 139) {
#line 470
    goto case_139;
  }
#line 474
  if (yyn == 140) {
#line 474
    goto case_140;
  }
#line 478
  if (yyn == 141) {
#line 478
    goto case_141;
  }
#line 481
  if (yyn == 142) {
#line 481
    goto case_142;
  }
#line 485
  if (yyn == 143) {
#line 485
    goto case_143;
  }
#line 488
  if (yyn == 147) {
#line 488
    goto case_147;
  }
#line 500
  if (yyn == 148) {
#line 500
    goto case_148;
  }
#line 502
  if (yyn == 149) {
#line 502
    goto case_149;
  }
#line 505
  if (yyn == 152) {
#line 505
    goto case_152;
  }
#line 511
  if (yyn == 157) {
#line 511
    goto case_157;
  }
#line 520
  if (yyn == 158) {
#line 520
    goto case_158;
  }
#line 522
  if (yyn == 167) {
#line 522
    goto case_167;
  }
#line 536
  if (yyn == 168) {
#line 536
    goto case_168;
  }
#line 540
  if (yyn == 169) {
#line 540
    goto case_169;
  }
#line 544
  if (yyn == 170) {
#line 544
    goto case_170;
  }
#line 548
  if (yyn == 171) {
#line 548
    goto case_171;
  }
#line 552
  if (yyn == 176) {
#line 552
    goto case_176;
  }
#line 563
  if (yyn == 177) {
#line 563
    goto case_177;
  }
#line 570
  if (yyn == 178) {
#line 570
    goto case_178;
  }
#line 572
  if (yyn == 181) {
#line 572
    goto case_181;
  }
#line 580
  if (yyn == 182) {
#line 580
    goto case_182;
  }
#line 583
  if (yyn == 183) {
#line 583
    goto case_183;
  }
#line 586
  if (yyn == 184) {
#line 586
    goto case_184;
  }
#line 593
  if (yyn == 185) {
#line 593
    goto case_185;
  }
#line 596
  if (yyn == 197) {
#line 596
    goto case_197;
  }
#line 616
  if (yyn == 198) {
#line 616
    goto case_198;
  }
#line 618
  if (yyn == 199) {
#line 618
    goto case_199;
  }
#line 625
  if (yyn == 200) {
#line 625
    goto case_200;
  }
#line 627
  if (yyn == 201) {
#line 627
    goto case_201;
  }
#line 634
  if (yyn == 202) {
#line 634
    goto case_202;
  }
#line 636
  if (yyn == 203) {
#line 636
    goto case_203;
  }
#line 643
  if (yyn == 204) {
#line 643
    goto case_204;
  }
#line 645
  if (yyn == 207) {
#line 645
    goto case_207;
  }
#line 652
  if (yyn == 208) {
#line 652
    goto case_208;
  }
#line 655
  if (yyn == 209) {
#line 655
    goto case_209;
  }
#line 660
  if (yyn == 210) {
#line 660
    goto case_210;
  }
#line 665
  if (yyn == 211) {
#line 665
    goto case_211;
  }
#line 672
  if (yyn == 212) {
#line 672
    goto case_212;
  }
#line 677
  if (yyn == 213) {
#line 677
    goto case_213;
  }
#line 684
  if (yyn == 214) {
#line 684
    goto case_214;
  }
#line 689
  if (yyn == 215) {
#line 689
    goto case_215;
  }
#line 696
  if (yyn == 216) {
#line 696
    goto case_216;
  }
#line 698
  if (yyn == 219) {
#line 698
    goto case_219;
  }
#line 704
  if (yyn == 220) {
#line 704
    goto case_220;
  }
#line 707
  if (yyn == 221) {
#line 707
    goto case_221;
  }
#line 709
  if (yyn == 222) {
#line 709
    goto case_222;
  }
#line 712
  if (yyn == 223) {
#line 712
    goto case_223;
  }
#line 714
  if (yyn == 224) {
#line 714
    goto case_224;
  }
#line 716
  if (yyn == 225) {
#line 716
    goto case_225;
  }
#line 718
  if (yyn == 226) {
#line 718
    goto case_226;
  }
#line 720
  if (yyn == 229) {
#line 720
    goto case_229;
  }
#line 726
  if (yyn == 230) {
#line 726
    goto case_230;
  }
#line 728
  if (yyn == 231) {
#line 728
    goto case_231;
  }
#line 730
  if (yyn == 232) {
#line 730
    goto case_232;
  }
#line 732
  if (yyn == 233) {
#line 732
    goto case_233;
  }
#line 734
  if (yyn == 234) {
#line 734
    goto case_234;
  }
#line 737
  if (yyn == 235) {
#line 737
    goto case_235;
  }
#line 739
  if (yyn == 240) {
#line 739
    goto case_240;
  }
#line 752
  if (yyn == 241) {
#line 752
    goto case_241;
  }
#line 754
  if (yyn == 244) {
#line 754
    goto case_244;
  }
#line 760
  if (yyn == 245) {
#line 760
    goto case_245;
  }
#line 767
  if (yyn == 246) {
#line 767
    goto case_246;
  }
#line 774
  if (yyn == 247) {
#line 774
    goto case_247;
  }
#line 776
  if (yyn == 250) {
#line 776
    goto case_250;
  }
#line 782
  if (yyn == 251) {
#line 782
    goto case_251;
  }
#line 785
  if (yyn == 252) {
#line 785
    goto case_252;
  }
#line 788
  if (yyn == 254) {
#line 788
    goto case_254;
  }
#line 796
  if (yyn == 255) {
#line 796
    goto case_255;
  }
#line 802
  if (yyn == 256) {
#line 802
    goto case_256;
  }
#line 807
  if (yyn == 257) {
#line 807
    goto case_257;
  }
#line 812
  if (yyn == 258) {
#line 812
    goto case_258;
  }
#line 815
  if (yyn == 259) {
#line 815
    goto case_259;
  }
#line 817
  if (yyn == 260) {
#line 817
    goto case_260;
  }
#line 819
  if (yyn == 261) {
#line 819
    goto case_261;
  }
#line 821
  if (yyn == 262) {
#line 821
    goto case_262;
  }
#line 823
  if (yyn == 263) {
#line 823
    goto case_263;
  }
#line 825
  if (yyn == 264) {
#line 825
    goto case_264;
  }
#line 827
  if (yyn == 265) {
#line 827
    goto case_265;
  }
#line 829
  if (yyn == 266) {
#line 829
    goto case_266;
  }
#line 831
  if (yyn == 267) {
#line 831
    goto case_267;
  }
#line 834
  if (yyn == 268) {
#line 834
    goto case_268;
  }
#line 842
  if (yyn == 269) {
#line 842
    goto case_269;
  }
#line 845
  if (yyn == 270) {
#line 845
    goto case_270;
  }
#line 848
  if (yyn == 271) {
#line 848
    goto case_271;
  }
#line 850
  if (yyn == 272) {
#line 850
    goto case_272;
  }
#line 852
  if (yyn == 273) {
#line 852
    goto case_273;
  }
#line 854
  if (yyn == 274) {
#line 854
    goto case_274;
  }
#line 856
  if (yyn == 275) {
#line 856
    goto case_275;
  }
#line 858
  if (yyn == 277) {
#line 858
    goto case_277;
  }
#line 863
  if (yyn == 278) {
#line 863
    goto case_278;
  }
#line 867
  if (yyn == 279) {
#line 867
    goto case_279;
  }
#line 874
  if (yyn == 280) {
#line 874
    goto case_280;
  }
#line 876
  if (yyn == 281) {
#line 876
    goto case_281;
  }
#line 879
  if (yyn == 283) {
#line 879
    goto case_283;
  }
#line 883
  if (yyn == 284) {
#line 883
    goto case_284;
  }
#line 885
  if (yyn == 285) {
#line 885
    goto case_285;
  }
#line 890
  if (yyn == 286) {
#line 890
    goto case_286;
  }
#line 3082 "bsdl_bison.c"
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 210 "bsdl_bison.y"
  bsdl_set_entity(priv_data, (yyvsp + -1)->str);
  }
#line 211
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 212
  Print_Error(priv_data, "Improper Entity declaration");
#line 213
  Print_Error(priv_data, "Check if source file is BSDL");
#line 214
  tmp___0 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 214
  if (tmp___0 > 15) {
    {
#line 214
    Give_Up_And_Quit(priv_data);
    }
#line 214
    goto yyabortlab;
  }
#line 214
  goto yyabortlab;
#line 216
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 229
  Print_Error(priv_data, "Syntax Error");
#line 230
  tmp___1 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 230
  if (tmp___1 > 15) {
    {
#line 230
    Give_Up_And_Quit(priv_data);
    }
#line 230
    goto yyabortlab;
  }
#line 230
  goto yyabortlab;
#line 231
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 246
  Print_Error(priv_data, "Syntax Error");
#line 247
  tmp___2 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 247
  if (tmp___2 > 15) {
    {
#line 247
    Give_Up_And_Quit(priv_data);
    }
#line 247
    goto yyabortlab;
  }
#line 247
  goto yyabortlab;
#line 248
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 250
  free((void *)(yyvsp + -1)->str);
  }
#line 251
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 252
  Print_Error(priv_data, "Syntax Error");
#line 253
  tmp___3 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 253
  if (tmp___3 > 15) {
    {
#line 253
    Give_Up_And_Quit(priv_data);
    }
#line 253
    goto yyabortlab;
  }
#line 253
  goto yyabortlab;
#line 254
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 258
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 261
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 262
  free((void *)(yyvsp + 0)->str);
  }
#line 263
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 266
  Print_Error(priv_data, "Improper Port declaration");
#line 267
  tmp___4 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 267
  if (tmp___4 > 15) {
    {
#line 267
    Give_Up_And_Quit(priv_data);
    }
#line 267
    goto yyabortlab;
  }
#line 267
  goto yyabortlab;
#line 268
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 274
  bsdl_prt_apply_port(priv_data);
  }
#line 276
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 278
  bsdl_prt_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 279
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 281
  bsdl_prt_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 283
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 287
  bsdl_prt_add_bit(priv_data);
  }
#line 288
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 291
  bsdl_prt_add_range(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->integer);
  }
#line 292
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 293
  bsdl_prt_add_range(priv_data, (yyvsp + 0)->integer, (yyvsp + -2)->integer);
  }
#line 294
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 298
  Print_Error(priv_data, "Error in Package declaration(s)");
#line 299
  tmp___5 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 299
  if (tmp___5 > 15) {
    {
#line 299
    Give_Up_And_Quit(priv_data);
    }
#line 299
    goto yyabortlab;
  }
#line 299
  goto yyabortlab;
#line 300
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 303
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 304
  free((void *)(yyvsp + 0)->str);
  }
#line 306
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 308
  priv_data->Reading_Package = 1;
#line 309
  bsdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 312
  goto switch_break;
  case_36: /* CIL Label */ 
#line 314
  priv_data->Reading_Package = 0;
#line 316
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 319
  free((void *)(yyvsp + -8)->str);
#line 319
  free((void *)(yyvsp + -2)->str);
  }
#line 320
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 321
  Print_Error(priv_data, "Error in Standard Package");
#line 322
  tmp___6 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 322
  if (tmp___6 > 15) {
    {
#line 322
    Give_Up_And_Quit(priv_data);
    }
#line 322
    goto yyabortlab;
  }
#line 322
  goto yyabortlab;
#line 323
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 329
  free((void *)(yyvsp + -3)->str);
  }
#line 330
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 332
  free((void *)(yyvsp + -1)->str);
  }
#line 333
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 336
  Print_Error(priv_data, "Error in Standard Declarations");
#line 337
  tmp___7 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 337
  if (tmp___7 > 15) {
    {
#line 337
    Give_Up_And_Quit(priv_data);
    }
#line 337
    goto yyabortlab;
  }
#line 337
  goto yyabortlab;
#line 338
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 352
  Print_Error(priv_data, "Error in Attribute identifier");
#line 353
  tmp___8 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 353
  if (tmp___8 > 15) {
    {
#line 353
    Give_Up_And_Quit(priv_data);
    }
#line 353
    goto yyabortlab;
  }
#line 353
  goto yyabortlab;
#line 354
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 356
  free((void *)(yyvsp + 0)->str);
  }
#line 357
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 360
  Print_Error(priv_data, "Error in Attribute type identification");
#line 361
  tmp___9 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 361
  if (tmp___9 > 15) {
    {
#line 361
    Give_Up_And_Quit(priv_data);
    }
#line 361
    goto yyabortlab;
  }
#line 361
  goto yyabortlab;
#line 362
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 368
  free((void *)(yyvsp + 0)->str);
  }
#line 369
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 371
  free((void *)(yyvsp + 0)->str);
  }
#line 372
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 374
  Print_Error(priv_data, "Error in Type definition");
#line 375
  tmp___10 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 375
  if (tmp___10 > 15) {
    {
#line 375
    Give_Up_And_Quit(priv_data);
    }
#line 375
    goto yyabortlab;
  }
#line 375
  goto yyabortlab;
#line 376
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 381
  free((void *)(yyvsp + 0)->str);
  }
#line 382
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 383
  free((void *)(yyvsp + 0)->str);
  }
#line 384
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 386
  free((void *)(yyvsp + -1)->str);
  }
#line 387
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 388
  Print_Error(priv_data, "Error in Bit definition");
#line 389
  tmp___11 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 389
  if (tmp___11 > 15) {
    {
#line 389
    Give_Up_And_Quit(priv_data);
    }
#line 389
    goto yyabortlab;
  }
#line 389
  goto yyabortlab;
#line 390
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 395
  free((void *)(yyvsp + -3)->str);
#line 395
  free((void *)(yyvsp + -1)->str);
  }
#line 396
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 397
  Print_Error(priv_data, "Error in Record Definition");
#line 398
  tmp___12 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 398
  if (tmp___12 > 15) {
    {
#line 398
    Give_Up_And_Quit(priv_data);
    }
#line 398
    goto yyabortlab;
  }
#line 398
  goto yyabortlab;
#line 399
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 406
  free((void *)(yyvsp + -3)->str);
  }
#line 407
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 408
  Print_Error(priv_data, "Error in defered constant");
#line 409
  tmp___13 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 409
  if (tmp___13 > 15) {
    {
#line 409
    Give_Up_And_Quit(priv_data);
    }
#line 409
    goto yyabortlab;
  }
#line 409
  goto yyabortlab;
#line 410
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 415
  free((void *)(yyvsp + -4)->str);
#line 415
  free((void *)(yyvsp + 0)->str);
  }
#line 416
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 418
  Print_Error(priv_data, "Error in Package Body definition");
#line 419
  tmp___14 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 419
  if (tmp___14 > 15) {
    {
#line 419
    Give_Up_And_Quit(priv_data);
    }
#line 419
    goto yyabortlab;
  }
#line 419
  goto yyabortlab;
#line 420
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 426
  free((void *)(yyvsp + -7)->str);
  }
#line 427
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 428
  Print_Error(priv_data, "Error in Cell Constant definition");
#line 429
  tmp___15 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 429
  if (tmp___15 > 15) {
    {
#line 429
    Give_Up_And_Quit(priv_data);
    }
#line 429
    goto yyabortlab;
  }
#line 429
  goto yyabortlab;
#line 430
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 437
  Print_Error(priv_data, "Error in Cell Data Record");
#line 438
  tmp___16 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 438
  if (tmp___16 > 15) {
    {
#line 438
    Give_Up_And_Quit(priv_data);
    }
#line 438
    goto yyabortlab;
  }
#line 438
  goto yyabortlab;
#line 439
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 444
  Print_Error(priv_data, "Error in Cell_Type Function field");
#line 445
  tmp___17 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 445
  if (tmp___17 > 15) {
    {
#line 445
    Give_Up_And_Quit(priv_data);
    }
#line 445
    goto yyabortlab;
  }
#line 445
  goto yyabortlab;
#line 446
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 449
  Print_Error(priv_data, "Error in BScan_Inst Instruction field");
#line 450
  tmp___18 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 450
  if (tmp___18 > 15) {
    {
#line 450
    Give_Up_And_Quit(priv_data);
    }
#line 450
    goto yyabortlab;
  }
#line 450
  goto yyabortlab;
#line 451
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 454
  Print_Error(priv_data, "Error in Constant CAP data source field");
#line 455
  tmp___19 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 455
  if (tmp___19 > 15) {
    {
#line 455
    Give_Up_And_Quit(priv_data);
    }
#line 455
    goto yyabortlab;
  }
#line 455
  goto yyabortlab;
#line 456
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 459
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 460
  free((void *)(yyvsp + 0)->str);
  }
#line 462
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 464
  priv_data->Reading_Package = 1;
#line 465
  bsdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 468
  goto switch_break;
  case_139: /* CIL Label */ 
#line 470
  priv_data->Reading_Package = 0;
#line 472
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 475
  free((void *)(yyvsp + -6)->str);
#line 475
  free((void *)(yyvsp + -2)->str);
  }
#line 476
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 477
  Print_Error(priv_data, "Error in User-Defined Package declarations");
#line 478
  tmp___20 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 478
  if (tmp___20 > 15) {
    {
#line 478
    Give_Up_And_Quit(priv_data);
    }
#line 478
    goto yyabortlab;
  }
#line 478
  goto yyabortlab;
#line 479
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 482
  free((void *)(yyvsp + -5)->str);
  }
#line 483
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 484
  Print_Error(priv_data, "Error in Pin_Map Attribute");
#line 485
  tmp___21 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 485
  if (tmp___21 > 15) {
    {
#line 485
    Give_Up_And_Quit(priv_data);
    }
#line 485
    goto yyabortlab;
  }
#line 485
  goto yyabortlab;
#line 486
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 495
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 498
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 499
  free((void *)(yyvsp + -7)->str);
  }
#line 500
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 501
  Print_Error(priv_data, "Error in Pin_Map_String constant declaration");
#line 502
  tmp___22 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 502
  if (tmp___22 > 15) {
    {
#line 502
    Give_Up_And_Quit(priv_data);
    }
#line 502
    goto yyabortlab;
  }
#line 502
  goto yyabortlab;
#line 503
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 508
  free((void *)(yyvsp + -2)->str);
  }
#line 509
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 517
  free((void *)(yyvsp + 0)->str);
  }
#line 518
  goto switch_break;
  case_158: /* CIL Label */ 
  {
#line 519
  free((void *)(yyvsp + -3)->str);
  }
#line 520
  goto switch_break;
  case_167: /* CIL Label */ 
  {
#line 533
  free((void *)(yyvsp + -5)->str);
  }
#line 534
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 537
  free((void *)(yyvsp + -5)->str);
  }
#line 538
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 541
  free((void *)(yyvsp + -5)->str);
  }
#line 542
  goto switch_break;
  case_170: /* CIL Label */ 
  {
#line 545
  free((void *)(yyvsp + -5)->str);
  }
#line 546
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 549
  free((void *)(yyvsp + -9)->str);
#line 549
  free((void *)(yyvsp + -4)->str);
  }
#line 550
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 558
  bsdl_set_instruction_length(priv_data, (yyvsp + -1)->integer);
#line 559
  free((void *)(yyvsp + -5)->str);
  }
#line 561
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 565
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 568
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 569
  free((void *)(yyvsp + -7)->str);
  }
#line 570
  goto switch_break;
  case_181: /* CIL Label */ 
  {
#line 574
  Print_Error(priv_data, "Error in Instruction_Opcode attribute statement");
#line 576
  tmp___23 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 576
  if (tmp___23 > 15) {
    {
#line 576
    Give_Up_And_Quit(priv_data);
    }
#line 576
    goto yyabortlab;
  }
#line 577
  goto yyabortlab;
#line 578
  goto switch_break;
  case_182: /* CIL Label */ 
  {
#line 580
  bsdl_add_instruction(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->str);
  }
#line 581
  goto switch_break;
  case_183: /* CIL Label */ 
#line 583
  yyval.str = (yyvsp + 0)->str;
#line 584
  goto switch_break;
  case_184: /* CIL Label */ 
  {
#line 586
  Print_Warning(priv_data, "Multiple opcode patterns are not supported, first pattern will be used");
#line 588
  yyval.str = (yyvsp + -2)->str;
#line 589
  free((void *)(yyvsp + 0)->str);
  }
#line 591
  goto switch_break;
  case_185: /* CIL Label */ 
#line 593
  yyval.str = (yyvsp + 0)->str;
#line 594
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 611
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 614
  goto switch_break;
  case_198: /* CIL Label */ 
  {
#line 615
  free((void *)(yyvsp + -7)->str);
#line 615
  free((void *)(yyvsp + 0)->str);
  }
#line 616
  goto switch_break;
  case_199: /* CIL Label */ 
  {
#line 620
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 623
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 624
  free((void *)(yyvsp + -7)->str);
#line 624
  free((void *)(yyvsp + 0)->str);
  }
#line 625
  goto switch_break;
  case_201: /* CIL Label */ 
  {
#line 629
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 632
  goto switch_break;
  case_202: /* CIL Label */ 
  {
#line 633
  free((void *)(yyvsp + -7)->str);
#line 633
  free((void *)(yyvsp + 0)->str);
  }
#line 634
  goto switch_break;
  case_203: /* CIL Label */ 
  {
#line 638
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 641
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 642
  free((void *)(yyvsp + -7)->str);
  }
#line 643
  goto switch_break;
  case_207: /* CIL Label */ 
  {
#line 647
  Print_Error(priv_data, "Error in Opcode List");
#line 648
  tmp___24 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 648
  if (tmp___24 > 15) {
    {
#line 648
    Give_Up_And_Quit(priv_data);
    }
#line 648
    goto yyabortlab;
  }
#line 649
  goto yyabortlab;
#line 650
  goto switch_break;
  case_208: /* CIL Label */ 
  {
#line 652
  free((void *)(yyvsp + 0)->str);
  }
#line 653
  goto switch_break;
  case_209: /* CIL Label */ 
  {
#line 657
  free((void *)(yyvsp + -5)->str);
  }
#line 658
  goto switch_break;
  case_210: /* CIL Label */ 
  {
#line 662
  free((void *)(yyvsp + -5)->str);
  }
#line 663
  goto switch_break;
  case_211: /* CIL Label */ 
  {
#line 667
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 670
  goto switch_break;
  case_212: /* CIL Label */ 
  {
#line 672
  bsdl_set_idcode(priv_data, (yyvsp + 0)->str);
#line 673
  free((void *)(yyvsp + -7)->str);
  }
#line 675
  goto switch_break;
  case_213: /* CIL Label */ 
  {
#line 679
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 682
  goto switch_break;
  case_214: /* CIL Label */ 
  {
#line 684
  bsdl_set_usercode(priv_data, (yyvsp + 0)->str);
#line 685
  free((void *)(yyvsp + -7)->str);
  }
#line 687
  goto switch_break;
  case_215: /* CIL Label */ 
  {
#line 691
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 694
  goto switch_break;
  case_216: /* CIL Label */ 
  {
#line 695
  free((void *)(yyvsp + -7)->str);
  }
#line 696
  goto switch_break;
  case_219: /* CIL Label */ 
  {
#line 701
  bsdl_ac_apply_assoc(priv_data);
  }
#line 702
  goto switch_break;
  case_220: /* CIL Label */ 
  {
#line 704
  bsdl_ac_set_register(priv_data, (yyvsp + 0)->str, 0);
  }
#line 705
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 706
  bsdl_ac_set_register(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->integer);
  }
#line 707
  goto switch_break;
  case_222: /* CIL Label */ 
  {
#line 709
  yyval.str = strdup("BOUNDARY");
  }
#line 710
  goto switch_break;
  case_223: /* CIL Label */ 
  {
#line 711
  yyval.str = strdup("BYPASS");
  }
#line 712
  goto switch_break;
  case_224: /* CIL Label */ 
  {
#line 713
  yyval.str = strdup("IDCODE");
  }
#line 714
  goto switch_break;
  case_225: /* CIL Label */ 
  {
#line 715
  yyval.str = strdup("USERCODE");
  }
#line 716
  goto switch_break;
  case_226: /* CIL Label */ 
  {
#line 717
  yyval.str = strdup("DEVICE_ID");
  }
#line 718
  goto switch_break;
  case_229: /* CIL Label */ 
  {
#line 723
  yyval.str = strdup("BOUNDARY");
  }
#line 724
  goto switch_break;
  case_230: /* CIL Label */ 
  {
#line 725
  yyval.str = strdup("BYPASS");
  }
#line 726
  goto switch_break;
  case_231: /* CIL Label */ 
  {
#line 727
  yyval.str = strdup("HIGHZ");
  }
#line 728
  goto switch_break;
  case_232: /* CIL Label */ 
  {
#line 729
  yyval.str = strdup("IDCODE");
  }
#line 730
  goto switch_break;
  case_233: /* CIL Label */ 
  {
#line 731
  yyval.str = strdup("USERCODE");
  }
#line 732
  goto switch_break;
  case_234: /* CIL Label */ 
  {
#line 734
  bsdl_ac_add_instruction(priv_data, (yyvsp + 0)->str);
  }
#line 735
  goto switch_break;
  case_235: /* CIL Label */ 
  {
#line 736
  bsdl_ac_add_instruction(priv_data, (yyvsp + 0)->str);
  }
#line 737
  goto switch_break;
  case_240: /* CIL Label */ 
  {
#line 747
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 750
  goto switch_break;
  case_241: /* CIL Label */ 
  {
#line 751
  free((void *)(yyvsp + -7)->str);
  }
#line 752
  goto switch_break;
  case_244: /* CIL Label */ 
  {
#line 757
  free((void *)(yyvsp + 0)->str);
  }
#line 758
  goto switch_break;
  case_245: /* CIL Label */ 
  {
#line 762
  bsdl_set_bsr_length(priv_data, (yyvsp + -1)->integer);
#line 763
  free((void *)(yyvsp + -5)->str);
  }
#line 765
  goto switch_break;
  case_246: /* CIL Label */ 
  {
#line 769
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 772
  goto switch_break;
  case_247: /* CIL Label */ 
  {
#line 773
  free((void *)(yyvsp + -7)->str);
  }
#line 774
  goto switch_break;
  case_250: /* CIL Label */ 
  {
#line 778
  Print_Error(priv_data, "Error in Boundary Cell description");
#line 779
  tmp___25 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 779
  if (tmp___25 > 15) {
    {
#line 779
    Give_Up_And_Quit(priv_data);
    }
#line 779
    goto yyabortlab;
  }
#line 779
  goto yyabortlab;
#line 780
  goto switch_break;
  case_251: /* CIL Label */ 
  {
#line 782
  bsdl_ci_apply_cell_info(priv_data, (yyvsp + -3)->integer);
  }
#line 783
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 785
  bsdl_ci_no_disable(priv_data);
  }
#line 786
  goto switch_break;
  case_254: /* CIL Label */ 
  {
#line 791
  free((void *)(yyvsp + -6)->str);
#line 792
  bsdl_ci_set_cell_spec(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->str);
  }
#line 794
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 797
  bsdl_prt_add_name(priv_data, (yyvsp + 0)->str);
#line 798
  bsdl_prt_add_bit(priv_data);
  }
#line 800
  goto switch_break;
  case_256: /* CIL Label */ 
  {
#line 802
  bsdl_prt_add_name(priv_data, (yyvsp + -3)->str);
#line 803
  bsdl_prt_add_range(priv_data, (yyvsp + -1)->integer, (yyvsp + -1)->integer);
  }
#line 805
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 807
  tmp___26 = strdup("*");
#line 807
  bsdl_prt_add_name(priv_data, tmp___26);
#line 808
  bsdl_prt_add_bit(priv_data);
  }
#line 810
  goto switch_break;
  case_258: /* CIL Label */ 
#line 812
  yyval.integer = 321;
#line 813
  goto switch_break;
  case_259: /* CIL Label */ 
#line 814
  yyval.integer = 322;
#line 815
  goto switch_break;
  case_260: /* CIL Label */ 
#line 816
  yyval.integer = 323;
#line 817
  goto switch_break;
  case_261: /* CIL Label */ 
#line 818
  yyval.integer = 324;
#line 819
  goto switch_break;
  case_262: /* CIL Label */ 
#line 820
  yyval.integer = 325;
#line 821
  goto switch_break;
  case_263: /* CIL Label */ 
#line 822
  yyval.integer = 326;
#line 823
  goto switch_break;
  case_264: /* CIL Label */ 
#line 824
  yyval.integer = 327;
#line 825
  goto switch_break;
  case_265: /* CIL Label */ 
#line 826
  yyval.integer = 328;
#line 827
  goto switch_break;
  case_266: /* CIL Label */ 
#line 828
  yyval.integer = 374;
#line 829
  goto switch_break;
  case_267: /* CIL Label */ 
#line 831
  yyval.str = (yyvsp + 0)->str;
#line 832
  goto switch_break;
  case_268: /* CIL Label */ 
  {
#line 835
  tmp___28 = malloc((size_t )2);
#line 835
  tmp___27 = (char *)tmp___28;
#line 836
  snprintf((char */* __restrict  */)tmp___27, (size_t )2, (char const   */* __restrict  */)"%i",
           (yyvsp + 0)->integer);
#line 837
  *(tmp___27 + 1) = (char )'\000';
#line 838
  yyval.str = tmp___27;
  }
#line 840
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 842
  bsdl_ci_set_cell_spec_disable(priv_data, (yyvsp + -4)->integer, (yyvsp + -2)->integer,
                                (yyvsp + 0)->integer);
  }
#line 843
  goto switch_break;
  case_270: /* CIL Label */ 
#line 845
  yyval.integer = 342;
#line 846
  goto switch_break;
  case_271: /* CIL Label */ 
#line 847
  yyval.integer = 343;
#line 848
  goto switch_break;
  case_272: /* CIL Label */ 
#line 849
  yyval.integer = 344;
#line 850
  goto switch_break;
  case_273: /* CIL Label */ 
#line 851
  yyval.integer = 346;
#line 852
  goto switch_break;
  case_274: /* CIL Label */ 
#line 853
  yyval.integer = 347;
#line 854
  goto switch_break;
  case_275: /* CIL Label */ 
#line 855
  yyval.integer = 348;
#line 856
  goto switch_break;
  case_277: /* CIL Label */ 
  {
#line 860
  free((void *)(yyvsp + -5)->str);
  }
#line 861
  goto switch_break;
  case_278: /* CIL Label */ 
  {
#line 864
  free((void *)(yyvsp + -5)->str);
  }
#line 865
  goto switch_break;
  case_279: /* CIL Label */ 
  {
#line 869
  bsdl_flex_switch_buffer(priv_data->scanner, (char const   *)priv_data->buffer_for_switch);
  }
#line 872
  goto switch_break;
  case_280: /* CIL Label */ 
  {
#line 873
  free((void *)(yyvsp + -7)->str);
  }
#line 874
  goto switch_break;
  case_281: /* CIL Label */ 
  {
#line 876
  bsdl_flex_set_bin_x(priv_data->scanner);
  }
#line 877
  goto switch_break;
  case_283: /* CIL Label */ 
  {
#line 880
  free((void *)(yyvsp + 0)->str);
  }
#line 881
  goto switch_break;
  case_284: /* CIL Label */ 
  {
#line 882
  free((void *)(yyvsp + 0)->str);
  }
#line 883
  goto switch_break;
  case_285: /* CIL Label */ 
  {
#line 885
  Init_Text(priv_data);
#line 886
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 887
  free((void *)(yyvsp + 0)->str);
  }
#line 888
  goto switch_break;
  case_286: /* CIL Label */ 
  {
#line 889
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 890
  free((void *)(yyvsp + 0)->str);
  }
#line 891
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3082 "bsdl_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3086
  yyvsp -= yylen;
#line 3086
  yyssp -= yylen;
#line 3087
  yylen = 0;
#line 3090
  yyvsp ++;
#line 3090
  *yyvsp = yyval;
#line 3097
  yyn = (int )yyr1[yyn];
#line 3099
  yystate = (int )((int const   )yypgoto[yyn - 120] + (int const   )*yyssp);
#line 3100
  if (0 <= yystate) {
#line 3100
    if (yystate <= 675) {
#line 3100
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 3101
        yystate = (int )yytable[yystate];
      } else {
#line 3103
        yystate = (int )yydefgoto[yyn - 120];
      }
    } else {
#line 3103
      yystate = (int )yydefgoto[yyn - 120];
    }
  } else {
#line 3103
    yystate = (int )yydefgoto[yyn - 120];
  }
#line 3105
  goto yynewstate;
  yyerrlab: 
#line 3113
  if (! yyerrstatus) {
    {
#line 3115
    bsdlnerrs ++;
#line 3117
    bsdlerror(priv_data, "syntax error");
    }
  }
#line 3155
  if (yyerrstatus == 3) {
#line 3160
    if (bsdlchar <= 0) {
#line 3163
      if (bsdlchar == 0) {
#line 3164
        goto yyabortlab;
      }
    } else {
      {
#line 3168
      yydestruct("Error: discarding", yytoken, & bsdllval, priv_data);
#line 3170
      bsdlchar = -2;
      }
    }
  }
#line 3176
  goto yyerrlab1;
#line 3192
  yyvsp -= yylen;
#line 3192
  yyssp -= yylen;
#line 3193
  yylen = 0;
#line 3195
  yystate = (int )*yyssp;
#line 3196
  goto yyerrlab1;
  yyerrlab1: 
#line 3203
  yyerrstatus = 3;
  {
#line 3205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3207
    yyn = (int )yypact[yystate];
#line 3208
    if (yyn != -348) {
#line 3210
      yyn ++;
#line 3211
      if (0 <= yyn) {
#line 3211
        if (yyn <= 675) {
#line 3211
          if ((int const   )yycheck[yyn] == 1) {
#line 3213
            yyn = (int )yytable[yyn];
#line 3214
            if (0 < yyn) {
#line 3215
              goto while_break___1;
            }
          }
        }
      }
    }
#line 3220
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 3221
      goto yyabortlab;
    }
    {
#line 3224
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, priv_data);
#line 3226
    yyvsp --;
#line 3226
    yyssp --;
#line 3227
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3231
  if (yyn == 6) {
#line 3232
    goto yyacceptlab;
  }
#line 3234
  yyvsp ++;
#line 3234
  *yyvsp = bsdllval;
#line 3240
  yystate = yyn;
#line 3241
  goto yynewstate;
  yyacceptlab: 
#line 3248
  yyresult = 0;
#line 3249
  goto yyreturn;
  yyabortlab: 
#line 3255
  yyresult = 1;
#line 3256
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 3263
  bsdlerror(priv_data, "memory exhausted");
#line 3264
  yyresult = 2;
  }
  yyreturn: 
#line 3269
  if (bsdlchar != 0) {
#line 3269
    if (bsdlchar != -2) {
      {
#line 3270
      yydestruct("Cleanup: discarding lookahead", yytoken, & bsdllval, priv_data);
      }
    }
  }
#line 3274
  yyvsp -= yylen;
#line 3274
  yyssp -= yylen;
  {
#line 3276
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3276
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 3276
      goto while_break___2;
    }
    {
#line 3278
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, priv_data);
#line 3280
    yyvsp --;
#line 3280
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3283
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 3284
    free((void *)yyss);
    }
  }
#line 3291
  return (yyresult);
}
}
#line 894 "bsdl_bison.y"
static void Init_Text(parser_priv_t *priv_data ) 
{ 
  void *tmp ;

  {
#line 896
  if (priv_data->len_buffer_for_switch == 0UL) {
    {
#line 897
    tmp = malloc((size_t )160);
#line 897
    priv_data->buffer_for_switch = (char *)tmp;
#line 898
    priv_data->len_buffer_for_switch = (size_t )160;
    }
  }
#line 900
  *(priv_data->buffer_for_switch + 0) = (char )'\000';
#line 901
  return;
}
}
#line 903 "bsdl_bison.y"
static void Store_Text(parser_priv_t *priv_data , char *Source ) 
{ 
  size_t req_len ;
  char *SourceEnd ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 908
  Source ++;
#line 908
  SourceEnd = Source;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if (*SourceEnd) {
#line 909
      if ((int )*SourceEnd != 34) {
#line 909
        if (! ((int )*SourceEnd != 10)) {
#line 909
          goto while_break;
        }
      } else {
#line 909
        goto while_break;
      }
    } else {
#line 909
      goto while_break;
    }
#line 910
    SourceEnd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 912
  *SourceEnd = (char )'\000';
#line 914
  tmp = strlen((char const   *)priv_data->buffer_for_switch);
#line 914
  tmp___0 = strlen((char const   *)Source);
#line 914
  req_len = (tmp + tmp___0) + 1UL;
  }
#line 915
  if (req_len > priv_data->len_buffer_for_switch) {
    {
#line 916
    tmp___1 = realloc((void *)priv_data->buffer_for_switch, req_len);
#line 916
    priv_data->buffer_for_switch = (char *)tmp___1;
#line 918
    priv_data->len_buffer_for_switch = req_len;
    }
  }
  {
#line 920
  strcat((char */* __restrict  */)priv_data->buffer_for_switch, (char const   */* __restrict  */)Source);
  }
#line 921
  return;
}
}
#line 923 "bsdl_bison.y"
static void Print_Error(parser_priv_t *priv_data , char const   *Errmess ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 925
  if (priv_data->Reading_Package) {
    {
#line 926
    tmp = bsdl_flex_get_lineno(priv_data->scanner);
#line 926
    bsdl_msg(2, "In Package %s, Line %d, %s.\n", priv_data->Package_File_Name, tmp,
             Errmess);
    }
  } else
#line 931
  if (priv_data->jtag_ctrl.debug) {
    {
#line 932
    tmp___0 = bsdl_flex_get_lineno(priv_data->scanner);
#line 932
    bsdl_msg(2, "Line %d, %s.\n", tmp___0, Errmess);
    }
  } else
#line 931
  if (priv_data->jtag_ctrl.mode >= 0) {
    {
#line 932
    tmp___0 = bsdl_flex_get_lineno(priv_data->scanner);
#line 932
    bsdl_msg(2, "Line %d, %s.\n", tmp___0, Errmess);
    }
  }
#line 935
  return;
}
}
#line 937 "bsdl_bison.y"
static void Print_Warning(parser_priv_t *priv_data , char const   *Warnmess ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 939
  if (priv_data->Reading_Package) {
    {
#line 940
    tmp = bsdl_flex_get_lineno(priv_data->scanner);
#line 940
    bsdl_msg(1, "In Package %s, Line %d, %s.\n", priv_data->Package_File_Name, tmp,
             Warnmess);
    }
  } else
#line 945
  if (priv_data->jtag_ctrl.debug) {
    {
#line 946
    tmp___0 = bsdl_flex_get_lineno(priv_data->scanner);
#line 946
    bsdl_msg(1, "Line %d, %s.\n", tmp___0, Warnmess);
    }
  } else
#line 945
  if (priv_data->jtag_ctrl.mode >= 0) {
    {
#line 946
    tmp___0 = bsdl_flex_get_lineno(priv_data->scanner);
#line 946
    bsdl_msg(1, "Line %d, %s.\n", tmp___0, Warnmess);
    }
  }
#line 949
  return;
}
}
#line 951 "bsdl_bison.y"
static void Give_Up_And_Quit(parser_priv_t *priv_data ) 
{ 


  {
  {
#line 953
  Print_Error(priv_data, "Too many errors");
  }
#line 954
  return;
}
}
#line 956 "bsdl_bison.y"
void bsdlerror(parser_priv_t *priv_data , char const   *error_string ) 
{ 


  {
#line 958
  return;
}
}
#line 960 "bsdl_bison.y"
parser_priv_t *bsdl_parser_init(FILE *f ) 
{ 
  parser_priv_t *new_priv ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 964
  tmp = malloc(sizeof(parser_priv_t ));
#line 964
  new_priv = (parser_priv_t *)tmp;
  }
#line 964
  if (! new_priv) {
    {
#line 965
    bsdl_msg(2, "Out of memory, %s line %i\n", "bsdl_bison.y", 965);
    }
#line 966
    return ((parser_priv_t *)((void *)0));
  }
  {
#line 969
  new_priv->Reading_Package = 0;
#line 970
  new_priv->buffer_for_switch = (char *)((void *)0);
#line 971
  new_priv->len_buffer_for_switch = (size_t )0;
#line 973
  tmp___0 = bsdl_flex_init(f);
#line 973
  new_priv->scanner = tmp___0;
  }
#line 973
  if (! tmp___0) {
    {
#line 974
    free((void *)new_priv);
#line 975
    new_priv = (parser_priv_t *)((void *)0);
    }
  }
  {
#line 978
  bsdl_sem_init(new_priv);
  }
#line 980
  return (new_priv);
}
}
#line 983 "bsdl_bison.y"
void bsdl_parser_deinit(parser_priv_t *priv_data ) 
{ 


  {
  {
#line 985
  bsdl_sem_deinit(priv_data);
#line 986
  bsdl_flex_deinit(priv_data->scanner);
#line 987
  free((void *)priv_data);
  }
#line 988
  return;
}
}
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 775 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 159 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 165
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 455 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value ,
                                                                                      __useconds_t __interval ) ;
#line 35 "../../include/register.h"
tap_register *register_alloc(int len ) ;
#line 37
void register_free(tap_register *tr ) ;
#line 39
char const   *register_get_string(tap_register const   *tr ) ;
#line 41
tap_register *register_init(tap_register *tr , char const   *value ) ;
#line 60 "../../include/part.h"
instruction *part_find_instruction(part_t *p , char const   *iname ) ;
#line 63
void part_set_instruction(part_t *p , char const   *iname ) ;
#line 129 "../../include/cable.h"
int cable_set_trst(cable_t *cable , int trst ) ;
#line 138
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 139
uint32_t cable_get_frequency(cable_t *cable ) ;
#line 48 "../../include/chain.h"
void chain_clock(chain_t *chain___0 , int tms , int tdi , int n ) ;
#line 53
void chain_shift_instructions_mode(chain_t *chain___0 , int capture , int exit___0 ) ;
#line 55
void chain_shift_data_registers_mode(chain_t *chain___0 , int capture_output , int capture ,
                                     int exit___0 ) ;
#line 59 "../../include/state.h"
int tap_state(chain_t *chain___0 ) ;
#line 62
int tap_state_reset(chain_t *chain___0 ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.h"
void svf_endxr(enum generic_irdr_coding ir_dr , int state ) ;
#line 71
void svf_frequency(double freq ) ;
#line 72
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 73
int svf_runtest(struct runtest *params ) ;
#line 74
int svf_state(struct path_states *path_states , int stable_state ) ;
#line 75
int svf_sxr(enum generic_irdr_coding ir_dr , struct ths_params *params , struct YYLTYPE *loc ) ;
#line 76
int svf_trst(int trst_mode ) ;
#line 77
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int yyparse(void) ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
FILE *yyin  =    (FILE *)0;
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
FILE *yyout  =    (FILE *)0;
#line 66 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_stop_on_mismatch  ;
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static part_t *part  ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static instruction *ir  ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static data_register *dr  ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static struct sxr sir_params  ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static struct sxr sdr_params  ;
#line 76 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int endir  ;
#line 76 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int enddr  ;
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int runtest_run_state  ;
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int runtest_end_state  ;
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_trst_absent  ;
#line 83 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_state_executed  ;
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int issued_sir_tdo  ;
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int issued_runtest_maxtime  ;
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static void svf_force_reset_state(void) 
{ 


  {
  {
#line 98
  chain_clock(chain, 1, 0, 5);
#line 99
  tap_state_reset(chain);
  }
#line 100
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static void svf_goto_state(int new_state ) 
{ 
  int current_state ;

  {
  {
#line 120
  current_state = tap_state(chain);
  }
#line 123
  if (new_state == 1 << 7) {
#line 124
    new_state = (1 << 7) | (1 << 3);
  }
#line 127
  if (current_state == new_state) {
#line 128
    return;
  }
  {
#line 131
  if (current_state == ((1 << 7) | (1 << 3))) {
#line 131
    goto case_exp;
  }
#line 135
  if (current_state == 1 << 3) {
#line 135
    goto case_exp___0;
  }
#line 140
  if (current_state == 1 << 1) {
#line 140
    goto case_exp___1;
  }
#line 140
  if (current_state == 1) {
#line 140
    goto case_exp___1;
  }
#line 152
  if (current_state == ((1 | (1 << 2)) | (1 << 4))) {
#line 152
    goto case_exp___2;
  }
#line 161
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 161
    goto case_exp___3;
  }
#line 171
  if (current_state == ((1 << 1) | (1 << 2))) {
#line 171
    goto case_exp___4;
  }
#line 171
  if (current_state == (1 | (1 << 2))) {
#line 171
    goto case_exp___4;
  }
#line 176
  if (current_state == ((1 | (1 << 5)) | (1 << 6))) {
#line 176
    goto case_exp___6;
  }
#line 185
  if (current_state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 185
    goto case_exp___7;
  }
#line 195
  if (current_state == ((1 << 1) | (1 << 6))) {
#line 195
    goto case_exp___8;
  }
#line 195
  if (current_state == (1 | (1 << 6))) {
#line 195
    goto case_exp___8;
  }
#line 200
  if (current_state == ((1 | (1 << 2)) | (1 << 5))) {
#line 200
    goto case_exp___10;
  }
#line 209
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 209
    goto case_exp___11;
  }
#line 219
  if (current_state == ((1 << 1) | (1 << 3))) {
#line 219
    goto case_exp___12;
  }
#line 219
  if (current_state == (1 | (1 << 3))) {
#line 219
    goto case_exp___12;
  }
#line 228
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 132
  chain_clock(chain, 0, 0, 1);
  }
#line 133
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 136
  chain_clock(chain, 1, 0, 1);
  }
#line 137
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 141
  if (new_state == ((1 << 7) | (1 << 3))) {
    {
#line 146
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 141
  if (new_state == 1 << 3) {
    {
#line 146
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 141
  if (current_state & 1) {
#line 141
    if (new_state & (1 << 1)) {
      {
#line 146
      chain_clock(chain, 1, 0, 1);
      }
    } else {
#line 141
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 141
  if (current_state & (1 << 1)) {
#line 141
    if (new_state & 1) {
      {
#line 146
      chain_clock(chain, 1, 0, 1);
      }
    } else {
      {
#line 149
      chain_clock(chain, 0, 0, 1);
      }
    }
  } else {
    {
#line 149
    chain_clock(chain, 0, 0, 1);
    }
  }
#line 150
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 153
  if (new_state == (1 | (1 << 2))) {
    {
#line 155
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 158
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 159
  goto switch_break;
  case_exp___3: /* CIL Label */ 
#line 162
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 164
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 167
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 168
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  {
#line 173
  chain_clock(chain, 1, 0, 1);
  }
#line 174
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 177
  if (new_state == (1 | (1 << 6))) {
    {
#line 179
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 182
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 183
  goto switch_break;
  case_exp___7: /* CIL Label */ 
#line 186
  if (new_state == ((1 << 1) | (1 << 6))) {
    {
#line 188
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 191
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 192
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  {
#line 197
  chain_clock(chain, 1, 0, 1);
  }
#line 198
  goto switch_break;
  case_exp___10: /* CIL Label */ 
#line 201
  if (new_state == (1 | (1 << 2))) {
    {
#line 203
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 206
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 207
  goto switch_break;
  case_exp___11: /* CIL Label */ 
#line 210
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 212
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 215
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 216
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
#line 220
  if (new_state == 1 << 3) {
    {
#line 222
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 225
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 226
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 229
  svf_force_reset_state();
  }
#line 230
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  svf_goto_state(new_state);
  }
#line 235
  return;
}
}
#line 250 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_map_state(int state ) 
{ 
  int jtag_state ;

  {
  {
#line 256
  if (state == 268) {
#line 256
    goto case_268;
  }
#line 259
  if (state == 269) {
#line 259
    goto case_269;
  }
#line 262
  if (state == 311) {
#line 262
    goto case_311;
  }
#line 265
  if (state == 314) {
#line 265
    goto case_314;
  }
#line 268
  if (state == 309) {
#line 268
    goto case_309;
  }
#line 271
  if (state == 312) {
#line 271
    goto case_312;
  }
#line 274
  if (state == 308) {
#line 274
    goto case_308;
  }
#line 277
  if (state == 313) {
#line 277
    goto case_313;
  }
#line 280
  if (state == 310) {
#line 280
    goto case_310;
  }
#line 284
  if (state == 304) {
#line 284
    goto case_304;
  }
#line 287
  if (state == 307) {
#line 287
    goto case_307;
  }
#line 290
  if (state == 302) {
#line 290
    goto case_302;
  }
#line 293
  if (state == 305) {
#line 293
    goto case_305;
  }
#line 296
  if (state == 301) {
#line 296
    goto case_301;
  }
#line 299
  if (state == 306) {
#line 299
    goto case_306;
  }
#line 302
  if (state == 303) {
#line 302
    goto case_303;
  }
#line 306
  goto switch_default;
  case_268: /* CIL Label */ 
#line 257
  jtag_state = (1 << 7) | (1 << 3);
#line 258
  goto switch_break;
  case_269: /* CIL Label */ 
#line 260
  jtag_state = 1 << 3;
#line 261
  goto switch_break;
  case_311: /* CIL Label */ 
#line 263
  jtag_state = 1;
#line 264
  goto switch_break;
  case_314: /* CIL Label */ 
#line 266
  jtag_state = (1 | (1 << 2)) | (1 << 4);
#line 267
  goto switch_break;
  case_309: /* CIL Label */ 
#line 269
  jtag_state = 1 | (1 << 2);
#line 270
  goto switch_break;
  case_312: /* CIL Label */ 
#line 272
  jtag_state = (1 | (1 << 5)) | (1 << 6);
#line 273
  goto switch_break;
  case_308: /* CIL Label */ 
#line 275
  jtag_state = 1 | (1 << 6);
#line 276
  goto switch_break;
  case_313: /* CIL Label */ 
#line 278
  jtag_state = (1 | (1 << 2)) | (1 << 5);
#line 279
  goto switch_break;
  case_310: /* CIL Label */ 
#line 281
  jtag_state = 1 | (1 << 3);
#line 282
  goto switch_break;
  case_304: /* CIL Label */ 
#line 285
  jtag_state = 1 << 1;
#line 286
  goto switch_break;
  case_307: /* CIL Label */ 
#line 288
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 289
  goto switch_break;
  case_302: /* CIL Label */ 
#line 291
  jtag_state = (1 << 1) | (1 << 2);
#line 292
  goto switch_break;
  case_305: /* CIL Label */ 
#line 294
  jtag_state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 295
  goto switch_break;
  case_301: /* CIL Label */ 
#line 297
  jtag_state = (1 << 1) | (1 << 6);
#line 298
  goto switch_break;
  case_306: /* CIL Label */ 
#line 300
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 301
  goto switch_break;
  case_303: /* CIL Label */ 
#line 303
  jtag_state = (1 << 1) | (1 << 3);
#line 304
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 307
  jtag_state = 1 << 7;
#line 308
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 311
  return (jtag_state);
}
}
#line 326 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_hex2dec(char nibble ) 
{ 
  int lower ;

  {
#line 331
  if ((int )nibble >= 48) {
#line 331
    if ((int )nibble <= 57) {
#line 332
      return ((int )nibble - 48);
    }
  }
  {
#line 334
  lower = tolower((int )nibble);
  }
#line 335
  if (lower >= 97) {
#line 335
    if (lower <= 102) {
#line 336
      return ((lower - 97) + 10);
    }
  }
#line 338
  return (0);
}
}
#line 367 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static char *svf_build_bit_string(char *hex_string , int len ) 
{ 
  char *bit_string ;
  char *bit_string_pos ;
  int nibble ;
  char *hex_string_pos ;
  int hex_string_idx ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 375
  tmp___0 = calloc((size_t )(len + 1), sizeof(char ));
#line 375
  bit_string = (char *)tmp___0;
  }
#line 375
  if (! bit_string) {
    {
#line 376
    tmp = gettext("out of memory");
#line 376
    printf((char const   */* __restrict  */)tmp);
    }
#line 377
    return ((char *)((void *)0));
  }
  {
#line 381
  tmp___1 = strlen((char const   *)hex_string);
#line 381
  hex_string_idx = (int )tmp___1;
#line 382
  hex_string_pos = hex_string + hex_string_idx;
#line 383
  nibble = 3;
#line 384
  bit_string_pos = bit_string + len;
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    bit_string_pos --;
#line 387
    if (nibble == 3) {
#line 388
      nibble = 0;
#line 389
      hex_string_pos --;
#line 390
      hex_string_idx --;
    } else {
#line 392
      nibble ++;
    }
#line 394
    if (hex_string_idx >= 0) {
#line 394
      tmp___4 = (int )*hex_string_pos;
    } else {
#line 394
      tmp___4 = '0';
    }
    {
#line 394
    tmp___5 = svf_hex2dec((char )tmp___4);
    }
#line 394
    if (tmp___5 & (1 << nibble)) {
#line 394
      *bit_string_pos = (char )'1';
    } else {
#line 394
      *bit_string_pos = (char )'0';
    }
#line 385
    if (! ((unsigned long )bit_string_pos != (unsigned long )bit_string)) {
#line 385
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  *(bit_string + len) = (char )'\000';
#line 399
  return (bit_string);
}
}
#line 417 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_copy_hex_to_register(char *hex_string , tap_register *reg ) 
{ 
  char *bit_string ;

  {
  {
#line 422
  bit_string = svf_build_bit_string(hex_string, reg->len);
  }
#line 422
  if (! bit_string) {
#line 423
    return (0);
  }
  {
#line 425
  register_init(reg, (char const   *)bit_string);
#line 428
  free((void *)bit_string);
  }
#line 430
  return (1);
}
}
#line 452 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_compare_tdo(char *tdo , char *mask , tap_register *reg , YYLTYPE *loc ) 
{ 
  char *tdo_bit ;
  char *mask_bit ;
  int pos ;
  int mismatch ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 456
  result = 1;
#line 458
  tdo_bit = svf_build_bit_string(tdo, reg->len);
  }
#line 458
  if (! tdo_bit) {
#line 459
    return (0);
  }
  {
#line 460
  mask_bit = svf_build_bit_string(mask, reg->len);
  }
#line 460
  if (! mask_bit) {
    {
#line 461
    free((void *)tdo_bit);
    }
#line 462
    return (0);
  }
  {
#line 466
  register_get_string((tap_register const   *)reg);
#line 468
  mismatch = -1;
#line 469
  pos = 0;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (pos < reg->len)) {
#line 469
      goto while_break;
    }
    {
#line 470
    tmp = svf_hex2dec(*(tdo_bit + pos));
#line 470
    tmp___0 = svf_hex2dec(*(mask_bit + pos));
    }
#line 470
    if ((tmp ^ (int )*(reg->string + pos)) & tmp___0) {
#line 471
      mismatch = pos;
    }
#line 469
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  if (mismatch >= 0) {
    {
#line 474
    tmp___1 = gettext("Error %s: mismatch at position %d for TDO\n");
#line 474
    printf((char const   */* __restrict  */)tmp___1, "svf", mismatch);
    }
#line 475
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 476
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 482
    if (svf_stop_on_mismatch) {
#line 483
      result = 0;
    }
  }
  {
#line 486
  free((void *)mask_bit);
#line 487
  free((void *)tdo_bit);
  }
#line 489
  return (result);
}
}
#line 507 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static void svf_remember_param(char **rem , char *new ) 
{ 


  {
#line 510
  if (new) {
#line 511
    if (*rem) {
      {
#line 512
      free((void *)*rem);
      }
    }
#line 514
    *rem = new;
  }
#line 516
  return;
}
}
#line 534 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int svf_all_care(char **string , double number ) 
{ 
  char *ptr ;
  int num ;
  int result ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 540
  result = 1;
#line 542
  num = (int )number;
#line 543
  if (num % 4 == 0) {
#line 543
    num /= 4;
  } else {
#line 543
    num = num / 4 + 1;
  }
  {
#line 546
  tmp___0 = calloc((size_t )(num + 1), sizeof(char ));
#line 546
  ptr = (char *)tmp___0;
  }
#line 546
  if (! ptr) {
    {
#line 547
    tmp = gettext("out of memory");
#line 547
    printf((char const   */* __restrict  */)tmp);
    }
#line 548
    return (0);
  }
  {
#line 550
  memset((void *)ptr, 'F', (size_t )num);
#line 551
  *(ptr + num) = (char )'\000';
#line 553
  svf_remember_param(string, ptr);
  }
#line 557
  return (result);
}
}
#line 570 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
void svf_endxr(enum generic_irdr_coding ir_dr , int state ) 
{ 


  {
  {
#line 574
  if ((unsigned int )ir_dr == 0U) {
#line 574
    goto case_0;
  }
#line 577
  if ((unsigned int )ir_dr == 1U) {
#line 577
    goto case_1;
  }
#line 573
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 575
  endir = svf_map_state(state);
  }
#line 576
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 578
  enddr = svf_map_state(state);
  }
#line 579
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 581
  return;
}
}
#line 592 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
void svf_frequency(double freq ) 
{ 


  {
  {
#line 595
  cable_set_frequency(chain->cable, (uint32_t )freq);
  }
#line 596
  return;
}
}
#line 615 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 618
  if (params->number != 0.0) {
#line 619
    if ((unsigned int )ir_dr == 0U) {
#line 619
      tmp = "HIR";
    } else {
#line 619
      tmp = "HDR";
    }
    {
#line 619
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 619
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 622
  return (1);
}
}
#line 626 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static int max_time_reached  ;
#line 627 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
static void sigalrm_handler(int signal___0 ) 
{ 


  {
#line 629
  max_time_reached = 1;
#line 630
  return;
}
}
#line 645 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_runtest(struct runtest *params ) 
{ 
  uint32_t run_count ;
  uint32_t frequency ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t min_time_run_count ;
  double tmp___3 ;
  struct sigaction sa ;
  unsigned int max_time ;
  int tmp___5 ;
  double tmp___6 ;
  uint32_t tmp___7 ;
  struct sigaction sa___0 ;
  int tmp___8 ;

  {
#line 651
  if (params->run_count > 0U) {
#line 651
    if (params->run_clk != 298) {
      {
#line 652
      tmp = gettext("Error %s: only TCK is supported for RUNTEST.\n");
#line 652
      printf((char const   */* __restrict  */)tmp, "svf");
      }
#line 653
      return (0);
    }
  }
#line 655
  if (params->max_time > 0.0) {
#line 655
    if (params->max_time < params->min_time) {
      {
#line 656
      tmp___0 = gettext("Error %s: maximum time must be larger or equal to minimum time.\n");
#line 656
      printf((char const   */* __restrict  */)tmp___0, "svf");
      }
#line 658
      return (0);
    }
  }
#line 660
  if (params->max_time > 0.0) {
#line 661
    if (! issued_runtest_maxtime) {
      {
#line 662
      tmp___1 = gettext("Warning %s: maximum time for RUNTEST not guaranteed.\n");
#line 662
      printf((char const   */* __restrict  */)tmp___1, "svf");
#line 663
      tmp___2 = gettext(" This message is only displayed once.\n");
#line 663
      printf((char const   */* __restrict  */)tmp___2);
#line 664
      issued_runtest_maxtime = 1;
      }
    }
  }
#line 668
  if (params->run_state != 0) {
    {
#line 669
    runtest_run_state = svf_map_state(params->run_state);
    }
#line 671
    if (params->end_state == 0) {
      {
#line 672
      runtest_end_state = svf_map_state(params->run_state);
      }
    }
  }
#line 674
  if (params->end_state != 0) {
    {
#line 675
    runtest_end_state = svf_map_state(params->end_state);
    }
  }
  {
#line 678
  run_count = params->run_count;
#line 679
  frequency = cable_get_frequency(chain->cable);
  }
#line 680
  if (frequency > 0U) {
    {
#line 681
    tmp___3 = ceil(params->min_time * (double )frequency);
#line 681
    min_time_run_count = (uint32_t )tmp___3;
    }
#line 682
    if (min_time_run_count > run_count) {
#line 683
      run_count = min_time_run_count;
    }
  }
#line 686
  if (! (run_count > 0U)) {
    {
#line 686
    __assert_fail("run_count > 0", "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c",
                  686U, "svf_runtest");
    }
  }
  {
#line 688
  svf_goto_state(runtest_run_state);
  }
#line 691
  if (params->max_time > 0.0) {
    {
#line 695
    sa.__sigaction_handler.sa_handler = & sigalrm_handler;
#line 696
    sa.sa_flags = (-0x7FFFFFFF-1);
#line 697
    sigemptyset(& sa.sa_mask);
#line 698
    tmp___5 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
    }
#line 698
    if (tmp___5 != 0) {
      {
#line 699
      perror("sigaction");
#line 700
      exit(1);
      }
    }
    {
#line 703
    tmp___6 = floor(params->max_time / (double )1000000);
#line 703
    max_time = (unsigned int )tmp___6;
    }
#line 704
    if (max_time == 0U) {
#line 705
      max_time = 1U;
    }
    {
#line 707
    ualarm(max_time, (__useconds_t )0);
    }
  }
#line 710
  if (params->max_time > 0.0) {
    {
#line 711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 711
      tmp___7 = run_count;
#line 711
      run_count --;
#line 711
      if (tmp___7 > 0U) {
#line 711
        if (! (! max_time_reached)) {
#line 711
          goto while_break;
        }
      } else {
#line 711
        goto while_break;
      }
      {
#line 712
      chain_clock(chain, 0, 0, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 715
    chain_clock(chain, 0, 0, (int )run_count);
    }
  }
  {
#line 717
  svf_goto_state(runtest_end_state);
  }
#line 720
  if (params->max_time > 0.0) {
    {
#line 722
    sa___0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 723
    sa___0.sa_flags = 0;
#line 724
    sigemptyset(& sa___0.sa_mask);
#line 725
    tmp___8 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa___0),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 725
    if (tmp___8 != 0) {
      {
#line 726
      perror("sigaction");
#line 727
      exit(1);
      }
    }
  }
#line 731
  return (1);
}
}
#line 750 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_state(struct path_states *path_states , int stable_state ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 755
  svf_state_executed = 1;
#line 757
  i = 0;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (i < path_states->num_states)) {
#line 757
      goto while_break;
    }
    {
#line 758
    tmp = svf_map_state(path_states->states[i]);
#line 758
    svf_goto_state(tmp);
#line 757
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if (stable_state) {
    {
#line 761
    tmp___0 = svf_map_state(stable_state);
#line 761
    svf_goto_state(tmp___0);
    }
  }
#line 763
  return (1);
}
}
#line 780 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_sxr(enum generic_irdr_coding ir_dr , struct ths_params *params , struct YYLTYPE *loc ) 
{ 
  struct sxr *sxr_params ;
  int len ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  tap_register *tmp___7 ;
  tap_register *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 784
  result = 1;
#line 786
  if ((unsigned int )ir_dr == 0U) {
#line 786
    sxr_params = & sir_params;
  } else {
#line 786
    sxr_params = & sdr_params;
  }
  {
#line 789
  svf_remember_param(& sxr_params->params.tdi, params->tdi);
#line 791
  sxr_params->params.tdo = params->tdo;
#line 793
  svf_remember_param(& sxr_params->params.mask, params->mask);
#line 795
  svf_remember_param(& sxr_params->params.smask, params->smask);
  }
#line 799
  if (sxr_params->params.number != params->number) {
#line 800
    sxr_params->no_tdi = 1;
#line 801
    sxr_params->no_tdo = 1;
#line 803
    if (! params->mask) {
      {
#line 804
      tmp = svf_all_care(& sxr_params->params.mask, params->number);
      }
#line 804
      if (! tmp) {
#line 805
        result = 0;
      }
    }
#line 806
    if (! params->smask) {
      {
#line 807
      tmp___0 = svf_all_care(& sxr_params->params.smask, params->number);
      }
#line 807
      if (! tmp___0) {
#line 808
        result = 0;
      }
    }
  }
#line 811
  sxr_params->params.number = params->number;
#line 814
  if (sxr_params->no_tdi) {
#line 815
    if (! params->tdi) {
#line 816
      if ((unsigned int )ir_dr == 0U) {
#line 816
        tmp___1 = "SIR";
      } else {
#line 816
        tmp___1 = "SDR";
      }
      {
#line 816
      tmp___2 = gettext("Error %s: first %s command after length change must have a TDI value.\n");
#line 816
      printf((char const   */* __restrict  */)tmp___2, "svf", tmp___1);
#line 818
      result = 0;
      }
    }
#line 820
    sxr_params->no_tdi = 0;
  }
#line 824
  if (! result) {
#line 825
    return (0);
  }
#line 828
  params->tdi = (char *)((void *)0);
#line 829
  params->mask = (char *)((void *)0);
#line 830
  params->smask = (char *)((void *)0);
#line 836
  len = (int )sxr_params->params.number;
  {
#line 838
  if ((unsigned int )ir_dr == 0U) {
#line 838
    goto case_0;
  }
#line 854
  if ((unsigned int )ir_dr == 1U) {
#line 854
    goto case_1;
  }
#line 837
  goto switch_break;
  case_0: /* CIL Label */ 
#line 840
  if ((ir->value)->len != len) {
    {
#line 841
    tmp___3 = gettext("Error %s: SIR command length inconsistent.\n");
#line 841
    printf((char const   */* __restrict  */)tmp___3, "svf");
    }
#line 843
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 844
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 850
    return (0);
  }
#line 852
  goto switch_break;
  case_1: /* CIL Label */ 
#line 856
  if ((dr->in)->len != len) {
    {
#line 858
    register_free(dr->in);
#line 859
    dr->in = (tap_register *)((void *)0);
#line 860
    register_free(dr->out);
#line 861
    dr->out = (tap_register *)((void *)0);
#line 863
    tmp___5 = register_alloc(len);
#line 863
    dr->in = tmp___5;
    }
#line 863
    if (! tmp___5) {
      {
#line 864
      tmp___4 = gettext("out of memory");
#line 864
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 865
      return (0);
    }
    {
#line 867
    tmp___7 = register_alloc(len);
#line 867
    dr->out = tmp___7;
    }
#line 867
    if (! tmp___7) {
      {
#line 868
      tmp___6 = gettext("out of memory");
#line 868
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 869
      return (0);
    }
  }
#line 872
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 877
  if ((unsigned int )ir_dr == 0U) {
#line 877
    tmp___8 = ir->value;
  } else {
#line 877
    tmp___8 = dr->in;
  }
  {
#line 877
  tmp___9 = svf_copy_hex_to_register(sxr_params->params.tdi, tmp___8);
  }
#line 877
  if (! tmp___9) {
#line 880
    return (0);
  }
  {
#line 885
  if ((unsigned int )ir_dr == 0U) {
#line 885
    goto case_0___0;
  }
#line 898
  if ((unsigned int )ir_dr == 1U) {
#line 898
    goto case_1___0;
  }
#line 884
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 886
  svf_goto_state((1 << 1) | (1 << 2));
#line 887
  chain_shift_instructions_mode(chain, 0, 2);
#line 888
  svf_goto_state(endir);
  }
#line 890
  if (sxr_params->params.tdo) {
#line 891
    if (! issued_sir_tdo) {
      {
#line 892
      tmp___10 = gettext("Warning %s: checking of TDO not supported for SIR.\n");
#line 892
      printf((char const   */* __restrict  */)tmp___10, "svf");
#line 893
      tmp___11 = gettext(" This message is only displayed once.\n");
#line 893
      printf((char const   */* __restrict  */)tmp___11);
#line 894
      issued_sir_tdo = 1;
      }
    }
  }
#line 896
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 899
  svf_goto_state(1 | (1 << 2));
  }
#line 900
  if (sxr_params->params.tdo) {
#line 900
    tmp___12 = 1;
  } else {
#line 900
    tmp___12 = 0;
  }
  {
#line 900
  chain_shift_data_registers_mode(chain, tmp___12, 0, 2);
#line 904
  svf_goto_state(enddr);
  }
#line 906
  if (sxr_params->params.tdo) {
    {
#line 907
    result = svf_compare_tdo(sxr_params->params.tdo, sxr_params->params.mask, dr->out,
                             loc);
    }
  }
#line 908
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 911
  return (result);
}
}
#line 932 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_trst(int trst_mode ) 
{ 
  int trst_cable ;
  char *unimplemented_mode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 935
  trst_cable = -1;
#line 938
  if (svf_trst_absent) {
    {
#line 939
    tmp = gettext("Error %s: no further TRST command allowed after mode ABSENT\n");
#line 939
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 941
    return (0);
  }
  {
#line 945
  if (trst_mode == 275) {
#line 945
    goto case_275;
  }
#line 948
  if (trst_mode == 276) {
#line 948
    goto case_276;
  }
#line 951
  if (trst_mode == 277) {
#line 951
    goto case_277;
  }
#line 954
  if (trst_mode == 278) {
#line 954
    goto case_278;
  }
#line 969
  goto switch_default;
  case_275: /* CIL Label */ 
#line 946
  trst_cable = 0;
#line 947
  goto switch_break;
  case_276: /* CIL Label */ 
#line 949
  trst_cable = 1;
#line 950
  goto switch_break;
  case_277: /* CIL Label */ 
#line 952
  unimplemented_mode = (char *)"Z";
#line 953
  goto switch_break;
  case_278: /* CIL Label */ 
#line 955
  unimplemented_mode = (char *)"ABSENT";
#line 956
  svf_trst_absent = 1;
#line 958
  if (svf_state_executed) {
    {
#line 959
    tmp___0 = gettext("Error %s: TRST ABSENT must not be issued after a STATE command\n");
#line 959
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 961
    return (0);
  }
#line 963
  if (sir_params.params.number > 0.0) {
    {
#line 965
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 965
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  } else
#line 963
  if (sdr_params.params.number > 0.0) {
    {
#line 965
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 965
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  }
#line 968
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 970
  unimplemented_mode = (char *)"UNKNOWN";
#line 971
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 974
  if (trst_cable < 0) {
    {
#line 975
    tmp___2 = gettext("Warning %s: unimplemented mode \'%s\' for TRST\n");
#line 975
    printf((char const   */* __restrict  */)tmp___2, "svf", unimplemented_mode);
    }
  } else {
    {
#line 978
    cable_set_trst(chain->cable, trst_cable);
    }
  }
#line 980
  return (1);
}
}
#line 1000 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 1003
  if (params->number != 0.0) {
#line 1004
    if ((unsigned int )ir_dr == 0U) {
#line 1004
      tmp = "TIR";
    } else {
#line 1004
      tmp = "TDR";
    }
    {
#line 1004
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 1004
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 1007
  return (1);
}
}
#line 1029 "/home/khheo/project/benchmark/urjtag-0.8/src/svf/svf.c"
void svf_run(FILE *SVF_FILE , int stop_on_mismatch ) 
{ 
  struct sxr sxr_default ;
  char *tmp ;
  char *tmp___0 ;
  char *register_cmd[4] ;
  int tmp___1 ;
  char *tmp___2 ;
  char *instruction_cmd[5] ;
  char *instruction_string ;
  int len ;
  int result ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1032
  sxr_default.params.number = 0.0;
#line 1032
  sxr_default.params.tdi = (char *)((void *)0);
#line 1032
  sxr_default.params.tdo = (char *)((void *)0);
#line 1032
  sxr_default.params.mask = (char *)((void *)0);
#line 1032
  sxr_default.params.smask = (char *)((void *)0);
#line 1032
  sxr_default.no_tdi = 1;
#line 1032
  sxr_default.no_tdo = 1;
#line 1039
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 1040
    tmp = gettext("Error %s: no JTAG chain available\n");
#line 1040
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 1041
    return;
  }
#line 1043
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 1044
    tmp___0 = gettext("Error %s: chain without any parts\n");
#line 1044
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 1045
    return;
  }
  {
#line 1047
  part = *((chain->parts)->parts + chain->active_part);
#line 1050
  dr = part_find_data_register(part, "SDR");
  }
#line 1050
  if (! dr) {
    {
#line 1051
    register_cmd[0] = (char *)"register";
#line 1051
    register_cmd[1] = (char *)"SDR";
#line 1051
    register_cmd[2] = (char *)"32";
#line 1051
    register_cmd[3] = (char *)((void *)0);
#line 1056
    tmp___1 = cmd_run(register_cmd);
    }
#line 1056
    if (tmp___1 < 1) {
#line 1057
      return;
    }
    {
#line 1059
    dr = part_find_data_register(part, "SDR");
    }
#line 1059
    if (! dr) {
      {
#line 1060
      tmp___2 = gettext("Error %s: could not establish SDR register\n");
#line 1060
      printf((char const   */* __restrict  */)tmp___2, "svf");
      }
#line 1061
      return;
    }
  }
  {
#line 1066
  ir = part_find_instruction(part, "SIR");
  }
#line 1066
  if (! ir) {
#line 1067
    instruction_cmd[0] = (char *)"instruction";
#line 1067
    instruction_cmd[1] = (char *)"SIR";
#line 1067
    instruction_cmd[2] = (char *)"";
#line 1067
    instruction_cmd[3] = (char *)"SDR";
#line 1067
    instruction_cmd[4] = (char *)((void *)0);
#line 1075
    len = part->instruction_length;
#line 1076
    if (len > 0) {
      {
#line 1077
      tmp___3 = calloc((size_t )(len + 1), sizeof(char ));
#line 1077
      instruction_string = (char *)tmp___3;
      }
#line 1077
      if ((unsigned long )instruction_string != (unsigned long )((void *)0)) {
        {
#line 1078
        memset((void *)instruction_string, '1', (size_t )len);
#line 1079
        *(instruction_string + len) = (char )'\000';
#line 1080
        instruction_cmd[2] = instruction_string;
#line 1082
        result = cmd_run(instruction_cmd);
#line 1084
        free((void *)instruction_string);
        }
#line 1086
        if (result < 1) {
#line 1087
          return;
        }
      }
    }
    {
#line 1091
    ir = part_find_instruction(part, "SIR");
    }
#line 1091
    if (! ir) {
      {
#line 1092
      tmp___4 = gettext("Error %s: could not establish SIR instruction\n");
#line 1092
      printf((char const   */* __restrict  */)tmp___4, "svf");
      }
#line 1093
      return;
    }
  }
  {
#line 1098
  svf_stop_on_mismatch = stop_on_mismatch;
#line 1100
  sdr_params = sxr_default;
#line 1100
  sir_params = sdr_params;
#line 1102
  enddr = 1 << 3;
#line 1102
  endir = enddr;
#line 1104
  runtest_end_state = 1 << 3;
#line 1104
  runtest_run_state = runtest_end_state;
#line 1106
  svf_trst_absent = 0;
#line 1107
  svf_state_executed = 0;
#line 1110
  issued_sir_tdo = 0;
#line 1111
  issued_runtest_maxtime = 0;
#line 1115
  part_set_instruction(part, "SIR");
#line 1117
  yyin = SVF_FILE;
#line 1118
  yyparse();
  }
#line 1122
  if (sir_params.params.tdi) {
    {
#line 1123
    free((void *)sir_params.params.tdi);
    }
  }
#line 1124
  if (sir_params.params.mask) {
    {
#line 1125
    free((void *)sir_params.params.mask);
    }
  }
#line 1126
  if (sir_params.params.smask) {
    {
#line 1127
    free((void *)sir_params.params.smask);
    }
  }
#line 1129
  if (sdr_params.params.tdi) {
    {
#line 1130
    free((void *)sdr_params.params.tdi);
    }
  }
#line 1131
  if (sdr_params.params.mask) {
    {
#line 1132
    free((void *)sdr_params.params.mask);
    }
  }
#line 1133
  if (sdr_params.params.smask) {
    {
#line 1134
    free((void *)sdr_params.params.smask);
    }
  }
#line 1135
  return;
}
}
#line 117 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 154 "svf_flex.c"
int yyleng  ;
#line 256 "svf_flex.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 257 "svf_flex.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 258 "svf_flex.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 276 "svf_flex.c"
static char yy_hold_char  ;
#line 277 "svf_flex.c"
static int yy_n_chars  ;
#line 281 "svf_flex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 282 "svf_flex.c"
static int yy_init  =    0;
#line 283 "svf_flex.c"
static int yy_start  =    0;
#line 288 "svf_flex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 290
void yyrestart(FILE *input_file ) ;
#line 291
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 292
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 293
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 294
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 295
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 296
void yypop_buffer_state(void) ;
#line 298
static void yyensure_buffer_stack(void) ;
#line 299
static void yy_load_buffer_state(void) ;
#line 300
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 304
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 305
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 306
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 308
void *yyalloc(yy_size_t size ) ;
#line 309
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 310
void yyfree(void *ptr ) ;
#line 340 "svf_flex.c"
FILE *yyin  =    (FILE *)0;
#line 340 "svf_flex.c"
FILE *yyout  =    (FILE *)0;
#line 344
int yylineno ;
#line 346 "svf_flex.c"
int yylineno  =    1;
#line 348 "svf_flex.c"
char *yytext  ;
#line 351
static yy_state_type yy_get_previous_state___0(void) ;
#line 352
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 353
static int yy_get_next_buffer___0(void) ;
#line 354
static void yy_fatal_error___0(char const   *msg ) ;
#line 375 "svf_flex.c"
static flex_int16_t const   yy_accept___0[43]  = 
#line 375
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5, 
        (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )10,      (flex_int16_t const   )2,      (flex_int16_t const   )9,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )4, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0};
#line 384 "svf_flex.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 384
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )17, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 416 "svf_flex.c"
static flex_int32_t const   yy_meta___0[18]  = 
#line 416
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )5,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )7};
#line 422 "svf_flex.c"
static flex_int16_t const   yy_base___0[49]  = 
#line 422
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )86,      (flex_int16_t const   )89,      (flex_int16_t const   )83, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )89, 
        (flex_int16_t const   )72,      (flex_int16_t const   )10,      (flex_int16_t const   )89,      (flex_int16_t const   )9, 
        (flex_int16_t const   )25,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )19, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )41,      (flex_int16_t const   )0, 
        (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )34, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )89, 
        (flex_int16_t const   )32,      (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )23, 
        (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )20, 
        (flex_int16_t const   )42,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )48, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )65,      (flex_int16_t const   )69, 
        (flex_int16_t const   )76};
#line 431 "svf_flex.c"
static flex_int16_t const   yy_def___0[49]  = 
#line 431
  {      (flex_int16_t const   )0,      (flex_int16_t const   )42,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )45, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )13, 
        (flex_int16_t const   )42,      (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )48,      (flex_int16_t const   )19,      (flex_int16_t const   )42, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )27,      (flex_int16_t const   )42,      (flex_int16_t const   )27, 
        (flex_int16_t const   )48,      (flex_int16_t const   )42,      (flex_int16_t const   )0,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42};
#line 440 "svf_flex.c"
static flex_int16_t const   yy_nxt___0[107]  = 
#line 440
  {      (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )15,      (flex_int16_t const   )6,      (flex_int16_t const   )22,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )25, 
        (flex_int16_t const   )24,      (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )25,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )32,      (flex_int16_t const   )20, 
        (flex_int16_t const   )37,      (flex_int16_t const   )20,      (flex_int16_t const   )28,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )29,      (flex_int16_t const   )40,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )24, 
        (flex_int16_t const   )41,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )34, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )17,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )21,      (flex_int16_t const   )29,      (flex_int16_t const   )19, 
        (flex_int16_t const   )29,      (flex_int16_t const   )17,      (flex_int16_t const   )42,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )5,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 456 "svf_flex.c"
static flex_int16_t const   yy_chk___0[107]  = 
#line 456
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )13,      (flex_int16_t const   )15, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )39,      (flex_int16_t const   )26, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )36, 
        (flex_int16_t const   )24,      (flex_int16_t const   )35,      (flex_int16_t const   )32,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )22, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )20, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )17,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )12,      (flex_int16_t const   )48,      (flex_int16_t const   )10, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 472 "svf_flex.c"
static yy_state_type yy_last_accepting_state  ;
#line 473 "svf_flex.c"
static char *yy_last_accepting_cpos  ;
#line 475
int yy_flex_debug ;
#line 476 "svf_flex.c"
int yy_flex_debug  =    0;
#line 46 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *yylval , char *str ) ;
#line 47
static void align_string(char *str ) ;
#line 61
static void fix_yylloc(YYLTYPE *yylloc , char *str ) ;
#line 62
static void fix_yylloc_nl(YYLTYPE *yylloc , char *str ) ;
#line 76 "svf_flex.l"
int yywrap(void) 
{ 


  {
#line 78
  return (1);
}
}
#line 585 "svf_flex.c"
static int yy_init_globals___0(void) ;
#line 694
int yylex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param ) ;
#line 718 "svf_flex.c"
int yylex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YYSTYPE___0 *yylval ;
  YYLTYPE *yylloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;
  register YY_CHAR yy_c ;
  int keyw ;
  char *cstring ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *cstring___0 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 734
  yylval = yylval_param;
#line 736
  yylloc = yylloc_param;
#line 738
  if (! yy_init) {
#line 740
    yy_init = 1;
    {
#line 743
    while (1) {
      while_continue: /* CIL Label */ ;
#line 743
      tmp___1 = 0;
#line 743
      yylloc->last_column = tmp___1;
#line 743
      tmp___0 = tmp___1;
#line 743
      yylloc->first_column = tmp___0;
#line 743
      tmp = tmp___0;
#line 743
      yylloc->last_line = tmp;
#line 743
      yylloc->first_line = tmp;
#line 743
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 746
    if (! yy_start) {
#line 747
      yy_start = 1;
    }
#line 749
    if (! yyin) {
#line 750
      yyin = stdin;
    }
#line 752
    if (! yyout) {
#line 753
      yyout = stdout;
    }
#line 755
    if (yy_buffer_stack) {
#line 755
      tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 755
      tmp___2 = (YY_BUFFER_STATE )((void *)0);
    }
#line 755
    if (! tmp___2) {
      {
#line 756
      yyensure_buffer_stack();
#line 757
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 761
    yy_load_buffer_state();
    }
  }
  {
#line 764
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 766
    yy_cp = yy_c_buf_p;
#line 769
    *yy_cp = yy_hold_char;
#line 774
    yy_bp = yy_cp;
#line 776
    yy_current_state = yy_start;
    yy_match: 
    {
#line 778
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 780
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
#line 781
      if (yy_accept___0[yy_current_state]) {
#line 783
        yy_last_accepting_state = yy_current_state;
#line 784
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 786
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 786
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 786
          goto while_break___2;
        }
#line 788
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 789
        if (yy_current_state >= 43) {
#line 790
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 792
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 793
      yy_cp ++;
#line 778
      if (! ((int const   )yy_base___0[yy_current_state] != 89)) {
#line 778
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    yy_find_action: 
#line 798
    yy_act = (int )yy_accept___0[yy_current_state];
#line 799
    if (yy_act == 0) {
#line 801
      yy_cp = yy_last_accepting_cpos;
#line 802
      yy_current_state = yy_last_accepting_state;
#line 803
      yy_act = (int )yy_accept___0[yy_current_state];
    }
#line 806
    yytext = yy_bp;
#line 806
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 806
    yy_hold_char = *yy_cp;
#line 806
    *yy_cp = (char )'\000';
#line 806
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 812
    if (yy_act == 0) {
#line 812
      goto case_0;
    }
#line 819
    if (yy_act == 1) {
#line 819
      goto case_1;
    }
#line 115
    if (yy_act == 2) {
#line 115 "svf_flex.l"
      goto case_2;
    }
#line 125
    if (yy_act == 3) {
#line 125
      goto case_3;
    }
#line 144
    if (yy_act == 4) {
#line 144
      goto case_4;
    }
#line 158
    if (yy_act == 5) {
#line 158
      goto case_5;
    }
#line 164
    if (yy_act == 6) {
#line 164
      goto case_6;
    }
#line 170
    if (yy_act == 7) {
#line 170
      goto case_7;
    }
#line 177
    if (yy_act == 8) {
#line 177
      goto case_8;
    }
#line 188
    if (yy_act == 9) {
#line 188
      goto case_9;
    }
#line 200
    if (yy_act == 14) {
#line 200
      goto case_14;
    }
#line 200
    if (yy_act == 13) {
#line 200
      goto case_14;
    }
#line 205
    if (yy_act == 10) {
#line 205
      goto case_10;
    }
#line 213
    if (yy_act == 11) {
#line 213
      goto case_11;
    }
#line 965
    if (yy_act == 12) {
#line 965 "svf_flex.c"
      goto case_12;
    }
#line 1087
    goto switch_default;
    case_0: /* CIL Label */ 
#line 814
    *yy_cp = yy_hold_char;
#line 815
    yy_cp = yy_last_accepting_cpos;
#line 816
    yy_current_state = yy_last_accepting_state;
#line 817
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 104 "svf_flex.l"
    fix_yylloc(yylloc, yytext);
#line 105
    keyw = map_keyw_ident(yylval, yytext);
    }
#line 108
    if (keyw == 285) {
#line 109
      yy_start = 3;
    }
#line 112
    return (keyw);
#line 114
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 119
    yylval->dvalue = strtod((char const   */* __restrict  */)yytext, (char **/* __restrict  */)((char **)((void *)0)));
#line 120
    fix_yylloc(yylloc, yytext);
    }
#line 122
    return (259);
#line 124
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 135
    fix_yylloc_nl(yylloc, yytext);
#line 136
    align_string(yytext);
#line 138
    tmp___3 = strlen((char const   *)yytext);
#line 138
    tmp___4 = calloc(tmp___3 + 1UL, sizeof(char ));
#line 138
    cstring = (char *)tmp___4;
#line 139
    strcpy((char */* __restrict  */)cstring, (char const   */* __restrict  */)yytext);
#line 140
    yylval->cvalue = cstring;
    }
#line 141
    return (261);
#line 143
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 149
    fix_yylloc_nl(yylloc, yytext);
#line 150
    align_string(yytext);
#line 152
    tmp___5 = strlen((char const   *)yytext);
#line 152
    tmp___6 = calloc(tmp___5 + 1UL, sizeof(char ));
#line 152
    cstring___0 = (char *)tmp___6;
#line 153
    strcpy((char */* __restrict  */)cstring___0, (char const   */* __restrict  */)yytext);
#line 154
    yylval->cvalue = cstring___0;
    }
#line 155
    return (260);
#line 157
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 161
    fix_yylloc(yylloc, yytext);
    }
#line 163
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 167
    fix_yylloc(yylloc, yytext);
    }
#line 169
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 173
    fix_yylloc(yylloc, yytext);
    }
#line 174
    return ((int )*(yytext + 0));
#line 176
    goto switch_break;
    case_8: /* CIL Label */ 
#line 181
    yylloc->first_line = yylloc->last_line;
#line 182
    yylloc->first_column = yylloc->last_column;
#line 183
    (yylloc->last_line) ++;
#line 184
    yylloc->last_column = 0;
#line 187
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 193
    yy_start = 1;
#line 195
    fix_yylloc(yylloc, yytext);
    }
#line 196
    return ((int )*(yytext + 0));
#line 198
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 202
    return (-1);
#line 204
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s\" is not a legal SVF language token\n",
            yytext);
    }
#line 212
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 213
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 214
    goto switch_break;
    case_12: /* CIL Label */ 
#line 968 "svf_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 971
    *yy_cp = yy_hold_char;
#line 974
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 985
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 986
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 987
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 997
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1001
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1003
      yy_current_state = yy_get_previous_state___0();
#line 1014
      yy_next_state = yy_try_NUL_trans___0(yy_current_state);
#line 1016
      yy_bp = yytext + 0;
      }
#line 1018
      if (yy_next_state) {
#line 1021
        yy_c_buf_p ++;
#line 1021
        yy_cp = yy_c_buf_p;
#line 1022
        yy_current_state = yy_next_state;
#line 1023
        goto yy_match;
      } else {
#line 1028
        yy_cp = yy_c_buf_p;
#line 1029
        goto yy_find_action;
      }
    } else {
      {
#line 1033
      tmp___7 = yy_get_next_buffer___0();
      }
      {
#line 1035
      if (tmp___7 == 1) {
#line 1035
        goto case_1___0;
      }
#line 1064
      if (tmp___7 == 0) {
#line 1064
        goto case_0___0;
      }
#line 1074
      if (tmp___7 == 2) {
#line 1074
        goto case_2___0;
      }
#line 1033
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1037
      yy_did_buffer_switch_on_eof = 0;
#line 1039
      tmp___8 = yywrap();
      }
#line 1039
      if (tmp___8) {
#line 1050
        yy_c_buf_p = yytext + 0;
#line 1052
        yy_act = (12 + (yy_start - 1) / 2) + 1;
#line 1053
        goto do_action;
      } else
#line 1058
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1059
        yyrestart(yyin);
        }
      }
#line 1061
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1065
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1068
      yy_current_state = yy_get_previous_state___0();
#line 1070
      yy_cp = yy_c_buf_p;
#line 1071
      yy_bp = yytext + 0;
      }
#line 1072
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1075
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1078
      yy_current_state = yy_get_previous_state___0();
#line 1080
      yy_cp = yy_c_buf_p;
#line 1081
      yy_bp = yytext + 0;
      }
#line 1082
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1084
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1088
    yy_fatal_error___0("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1101 "svf_flex.c"
static int yy_get_next_buffer___0(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 1103
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1104
  source = yytext;
#line 1108
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1109
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1112
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1114
    if (yy_c_buf_p - yytext == 1L) {
#line 1119
      return (1);
    } else {
#line 1127
      return (2);
    }
  }
#line 1134
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1136
  i = 0;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i < number_to_move)) {
#line 1136
      goto while_break;
    }
#line 1137
    tmp = dest;
#line 1137
    dest ++;
#line 1137
    tmp___0 = source;
#line 1137
    source ++;
#line 1137
    *tmp = *tmp___0;
#line 1136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1143
    yy_n_chars = 0;
#line 1143
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1147
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1150
      if (! (num_to_read <= 0)) {
#line 1150
        goto while_break___0;
      }
#line 1154
      if (yy_buffer_stack) {
#line 1154
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1154
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1154
      b = tmp___1;
#line 1156
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1159
      if (b->yy_is_our_buffer) {
#line 1161
        new_size = (int )(b->yy_buf_size * 2U);
#line 1163
        if (new_size <= 0) {
#line 1164
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1166
          b->yy_buf_size *= 2U;
        }
        {
#line 1168
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1168
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1174
        b->yy_ch_buf = (char *)0;
      }
#line 1176
      if (! b->yy_ch_buf) {
        {
#line 1177
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
        }
      }
#line 1180
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1182
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1187
    if (num_to_read > 8192) {
#line 1188
      num_to_read = 8192;
    }
#line 1191
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1191
      c = '*';
#line 1191
      n = (size_t )0;
      {
#line 1191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1191
        if (n < (size_t )num_to_read) {
          {
#line 1191
          c = _IO_getc(yyin);
          }
#line 1191
          if (c != -1) {
#line 1191
            if (! (c != 10)) {
#line 1191
              goto while_break___1;
            }
          } else {
#line 1191
            goto while_break___1;
          }
        } else {
#line 1191
          goto while_break___1;
        }
#line 1191
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1191
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1191
      if (c == 10) {
#line 1191
        tmp___3 = n;
#line 1191
        n ++;
#line 1191
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1191
      if (c == -1) {
        {
#line 1191
        tmp___4 = ferror(yyin);
        }
#line 1191
        if (tmp___4) {
          {
#line 1191
          yy_fatal_error___0("input in flex scanner failed");
          }
        }
      }
#line 1191
      yy_n_chars = (int )n;
    } else {
      {
#line 1191
      tmp___5 = __errno_location();
#line 1191
      *tmp___5 = 0;
      }
      {
#line 1191
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1191
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1191
        yy_n_chars = (int )tmp___8;
        }
#line 1191
        if (yy_n_chars == 0) {
          {
#line 1191
          tmp___9 = ferror(yyin);
          }
#line 1191
          if (! tmp___9) {
#line 1191
            goto while_break___2;
          }
        } else {
#line 1191
          goto while_break___2;
        }
        {
#line 1191
        tmp___6 = __errno_location();
        }
#line 1191
        if (*tmp___6 != 4) {
          {
#line 1191
          yy_fatal_error___0("input in flex scanner failed");
          }
#line 1191
          goto while_break___2;
        }
        {
#line 1191
        tmp___7 = __errno_location();
#line 1191
        *tmp___7 = 0;
#line 1191
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1194
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1197
  if (yy_n_chars == 0) {
#line 1199
    if (number_to_move == 0) {
      {
#line 1201
      ret_val = 1;
#line 1202
      yyrestart(yyin);
      }
    } else {
#line 1207
      ret_val = 2;
#line 1208
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1214
    ret_val = 0;
  }
#line 1216
  yy_n_chars += number_to_move;
#line 1217
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1218
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1220
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1222
  return (ret_val);
}
}
#line 1227 "svf_flex.c"
static yy_state_type yy_get_previous_state___0(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1232
  yy_current_state = yy_start;
#line 1234
  yy_cp = yytext + 0;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1234
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1234
      goto while_break;
    }
#line 1236
    if (*yy_cp) {
#line 1236
      tmp = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1236
      tmp = (flex_int32_t const   )1;
    }
#line 1236
    yy_c = (YY_CHAR )tmp;
#line 1237
    if (yy_accept___0[yy_current_state]) {
#line 1239
      yy_last_accepting_state = yy_current_state;
#line 1240
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1242
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1242
        goto while_break___0;
      }
#line 1244
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 1245
      if (yy_current_state >= 43) {
#line 1246
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1248
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1234
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1251
  return (yy_current_state);
}
}
#line 1259 "svf_flex.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1262
  yy_cp = yy_c_buf_p;
#line 1264
  yy_c = (YY_CHAR )1;
#line 1265
  if (yy_accept___0[yy_current_state]) {
#line 1267
    yy_last_accepting_state = yy_current_state;
#line 1268
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1270
      goto while_break;
    }
#line 1272
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 1273
    if (yy_current_state >= 43) {
#line 1274
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1276
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1277
  yy_is_jam = yy_current_state == 42;
#line 1279
  if (yy_is_jam) {
#line 1279
    tmp = 0;
  } else {
#line 1279
    tmp = yy_current_state;
  }
#line 1279
  return (tmp);
}
}
#line 1398 "svf_flex.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1401
  if (yy_buffer_stack) {
#line 1401
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1401
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1401
  if (! tmp) {
    {
#line 1402
    yyensure_buffer_stack();
#line 1403
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1407
  if (yy_buffer_stack) {
#line 1407
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1407
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1407
  yy_init_buffer(tmp___0, input_file);
#line 1408
  yy_load_buffer_state();
  }
#line 1409
  return;
}
}
#line 1415 "svf_flex.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1423
  yyensure_buffer_stack();
  }
#line 1424
  if (yy_buffer_stack) {
#line 1424
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1424
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1424
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1425
    return;
  }
#line 1427
  if (yy_buffer_stack) {
#line 1427
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1427
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1427
  if (tmp___0) {
#line 1430
    *yy_c_buf_p = yy_hold_char;
#line 1431
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1432
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1435
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1436
  yy_load_buffer_state();
#line 1443
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1444
  return;
}
}
#line 1446 "svf_flex.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1448
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1449
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1449
  yytext = yy_c_buf_p;
#line 1450
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1451
  yy_hold_char = *yy_c_buf_p;
#line 1452
  return;
}
}
#line 1460 "svf_flex.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1464
  tmp = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1464
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1465
  if (! b) {
    {
#line 1466
    yy_fatal_error___0("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1468
  b->yy_buf_size = (yy_size_t )size;
#line 1473
  tmp___0 = yyalloc(b->yy_buf_size + 2U);
#line 1473
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1474
  if (! b->yy_ch_buf) {
    {
#line 1475
    yy_fatal_error___0("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1477
  b->yy_is_our_buffer = 1;
#line 1479
  yy_init_buffer(b, file);
  }
#line 1481
  return (b);
}
}
#line 1488 "svf_flex.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1491
  if (! b) {
#line 1492
    return;
  }
#line 1494
  if (yy_buffer_stack) {
#line 1494
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1494
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1494
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1495
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1497
  if (b->yy_is_our_buffer) {
    {
#line 1498
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1500
  yyfree((void *)b);
  }
#line 1501
  return;
}
}
#line 1511 "svf_flex.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1514
  tmp = __errno_location();
#line 1514
  oerrno = *tmp;
#line 1516
  yy_flush_buffer(b);
#line 1518
  b->yy_input_file = file;
#line 1519
  b->yy_fill_buffer = 1;
  }
#line 1525
  if (yy_buffer_stack) {
#line 1525
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1525
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1525
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1526
    b->yy_bs_lineno = 1;
#line 1527
    b->yy_bs_column = 0;
  }
#line 1530
  if (file) {
    {
#line 1530
    tmp___1 = fileno(file);
#line 1530
    tmp___2 = isatty(tmp___1);
#line 1530
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1530
    b->yy_is_interactive = 0;
  }
  {
#line 1532
  tmp___3 = __errno_location();
#line 1532
  *tmp___3 = oerrno;
  }
#line 1533
  return;
}
}
#line 1539 "svf_flex.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1541
  if (! b) {
#line 1542
    return;
  }
#line 1544
  b->yy_n_chars = 0;
#line 1550
  *(b->yy_ch_buf + 0) = (char)0;
#line 1551
  *(b->yy_ch_buf + 1) = (char)0;
#line 1553
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1555
  b->yy_at_bol = 1;
#line 1556
  b->yy_buffer_status = 0;
#line 1558
  if (yy_buffer_stack) {
#line 1558
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1558
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1558
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1559
    yy_load_buffer_state();
    }
  }
#line 1560
  return;
}
}
#line 1568 "svf_flex.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1570
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1571
    return;
  }
  {
#line 1573
  yyensure_buffer_stack();
  }
#line 1576
  if (yy_buffer_stack) {
#line 1576
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1576
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1576
  if (tmp) {
#line 1579
    *yy_c_buf_p = yy_hold_char;
#line 1580
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1581
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1585
  if (yy_buffer_stack) {
#line 1585
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1585
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1585
  if (tmp___0) {
#line 1586
    yy_buffer_stack_top ++;
  }
  {
#line 1587
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1590
  yy_load_buffer_state();
#line 1591
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1592
  return;
}
}
#line 1598 "svf_flex.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1600
  if (yy_buffer_stack) {
#line 1600
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1600
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1600
  if (! tmp) {
#line 1601
    return;
  }
#line 1603
  if (yy_buffer_stack) {
#line 1603
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1603
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1603
  yy_delete_buffer(tmp___0);
#line 1604
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1605
  if (yy_buffer_stack_top > 0UL) {
#line 1606
    yy_buffer_stack_top --;
  }
#line 1608
  if (yy_buffer_stack) {
#line 1608
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1608
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1608
  if (tmp___1) {
    {
#line 1609
    yy_load_buffer_state();
#line 1610
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1612
  return;
}
}
#line 1617 "svf_flex.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1621
  if (! yy_buffer_stack) {
    {
#line 1627
    num_to_alloc = 1;
#line 1628
    tmp = yyalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1628
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
#line 1632
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1634
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1635
    yy_buffer_stack_top = (size_t )0;
    }
#line 1636
    return;
  }
#line 1639
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1642
    grow_size = 8;
#line 1644
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1645
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1645
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 1651
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1652
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1654
  return;
}
}
#line 1662 "svf_flex.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1666
  if (size < 2U) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  } else
#line 1666
  if ((int )*(base + (size - 2U)) != 0) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  } else
#line 1666
  if ((int )*(base + (size - 1U)) != 0) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1672
  tmp = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1672
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1673
  if (! b) {
    {
#line 1674
    yy_fatal_error___0("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1676
  b->yy_buf_size = size - 2U;
#line 1677
  tmp___0 = base;
#line 1677
  b->yy_ch_buf = tmp___0;
#line 1677
  b->yy_buf_pos = tmp___0;
#line 1678
  b->yy_is_our_buffer = 0;
#line 1679
  b->yy_input_file = (FILE *)0;
#line 1680
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1681
  b->yy_is_interactive = 0;
#line 1682
  b->yy_at_bol = 1;
#line 1683
  b->yy_fill_buffer = 0;
#line 1684
  b->yy_buffer_status = 0;
#line 1686
  yy_switch_to_buffer(b);
  }
#line 1688
  return (b);
}
}
#line 1699 "svf_flex.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1702
  tmp = strlen(yystr);
#line 1702
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 1702
  return (tmp___0);
}
}
#line 1712 "svf_flex.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1720
  n = (yy_size_t )(_yybytes_len + 2);
#line 1721
  tmp = yyalloc(n);
#line 1721
  buf = (char *)tmp;
  }
#line 1722
  if (! buf) {
    {
#line 1723
    yy_fatal_error___0("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1725
  i = 0;
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1725
    if (! (i < _yybytes_len)) {
#line 1725
      goto while_break;
    }
#line 1726
    *(buf + i) = (char )*(yybytes + i);
#line 1725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1728
  tmp___0 = (char)0;
#line 1728
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1728
  *(buf + _yybytes_len) = tmp___0;
#line 1730
  b = yy_scan_buffer(buf, n);
  }
#line 1731
  if (! b) {
    {
#line 1732
    yy_fatal_error___0("bad buffer in yy_scan_bytes()");
    }
  }
#line 1737
  b->yy_is_our_buffer = 1;
#line 1739
  return (b);
}
}
#line 1746 "svf_flex.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 


  {
  {
#line 1748
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1749
  exit(2);
  }
}
}
#line 1774 "svf_flex.c"
int yyget_lineno(void) 
{ 


  {
#line 1777
  return (yylineno);
}
}
#line 1783 "svf_flex.c"
FILE *yyget_in(void) 
{ 


  {
#line 1785
  return (yyin);
}
}
#line 1791 "svf_flex.c"
FILE *yyget_out(void) 
{ 


  {
#line 1793
  return (yyout);
}
}
#line 1799 "svf_flex.c"
int yyget_leng(void) 
{ 


  {
#line 1801
  return (yyleng);
}
}
#line 1808 "svf_flex.c"
char *yyget_text(void) 
{ 


  {
#line 1810
  return (yytext);
}
}
#line 1817 "svf_flex.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 1820
  yylineno = line_number;
#line 1821
  return;
}
}
#line 1829 "svf_flex.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 1831
  yyin = in_str;
#line 1832
  return;
}
}
#line 1834 "svf_flex.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 1836
  yyout = out_str;
#line 1837
  return;
}
}
#line 1839 "svf_flex.c"
int yyget_debug(void) 
{ 


  {
#line 1841
  return (yy_flex_debug);
}
}
#line 1844 "svf_flex.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 1846
  yy_flex_debug = bdebug;
#line 1847
  return;
}
}
#line 1849 "svf_flex.c"
static int yy_init_globals___0(void) 
{ 


  {
#line 1855
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 1856
  yy_buffer_stack_top = (size_t )0;
#line 1857
  yy_buffer_stack_max = (size_t )0;
#line 1858
  yy_c_buf_p = (char *)0;
#line 1859
  yy_init = 0;
#line 1860
  yy_start = 0;
#line 1867
  yyin = (FILE *)0;
#line 1868
  yyout = (FILE *)0;
#line 1874
  return (0);
}
}
#line 1878 "svf_flex.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1882
    if (yy_buffer_stack) {
#line 1882
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1882
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1882
    if (! tmp___0) {
#line 1882
      goto while_break;
    }
#line 1883
    if (yy_buffer_stack) {
#line 1883
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1883
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1883
    yy_delete_buffer(tmp);
#line 1884
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 1885
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1889
  yyfree((void *)yy_buffer_stack);
#line 1890
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 1894
  yy_init_globals___0();
  }
#line 1896
  return (0);
}
}
#line 1923 "svf_flex.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1925
  tmp = malloc((size_t )size);
  }
#line 1925
  return (tmp);
}
}
#line 1928 "svf_flex.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1937
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 1937
  return (tmp);
}
}
#line 1940 "svf_flex.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 1942
  free((void *)((char *)ptr));
  }
#line 1943
  return;
}
}
#line 220 "svf_flex.l"
static struct rwtable rwtable[53]  = 
#line 220 "svf_flex.l"
  {      {(char *)"ABSENT", 278}, 
        {(char *)"D", 293}, 
        {(char *)"DRCAPTURE", 314}, 
        {(char *)"DREXIT1", 312}, 
        {(char *)"DREXIT2", 313}, 
        {(char *)"DRPAUSE", 308}, 
        {(char *)"DRSELECT", 311}, 
        {(char *)"DRSHIFT", 309}, 
        {(char *)"DRUPDATE", 310}, 
        {(char *)"EMPTY", 262}, 
        {(char *)"ENDDR", 263}, 
        {(char *)"ENDIR", 264}, 
        {(char *)"ENDSTATE", 300}, 
        {(char *)"FREQUENCY", 265}, 
        {(char *)"H", 290}, 
        {(char *)"HDR", 279}, 
        {(char *)"HIR", 280}, 
        {(char *)"HZ", 266}, 
        {(char *)"IDLE", 269}, 
        {(char *)"IN", 287}, 
        {(char *)"INOUT", 289}, 
        {(char *)"IRCAPTURE", 307}, 
        {(char *)"IREXIT1", 305}, 
        {(char *)"IREXIT2", 306}, 
        {(char *)"IRPAUSE", 301}, 
        {(char *)"IRSELECT", 304}, 
        {(char *)"IRSHIFT", 302}, 
        {(char *)"IRUPDATE", 303}, 
        {(char *)"L", 291}, 
        {(char *)"MASK", 272}, 
        {(char *)"MAXIMUM", 296}, 
        {(char *)"OFF", 276}, 
        {(char *)"ON", 275}, 
        {(char *)"OUT", 288}, 
        {(char *)"PIO", 285}, 
        {(char *)"PIOMAP", 286}, 
        {(char *)"RESET", 268}, 
        {(char *)"RUNTEST", 295}, 
        {(char *)"SCK", 299}, 
        {(char *)"SDR", 281}, 
        {(char *)"SEC", 297}, 
        {(char *)"SIR", 282}, 
        {(char *)"SMASK", 273}, 
        {(char *)"STATE", 267}, 
        {(char *)"TCK", 298}, 
        {(char *)"TDI", 270}, 
        {(char *)"TDO", 271}, 
        {(char *)"TDR", 283}, 
        {(char *)"TIR", 284}, 
        {(char *)"TRST", 274}, 
        {(char *)"U", 292}, 
        {(char *)"X", 294}, 
        {(char *)"Z", 277}};
#line 282 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *yylval , char *str ) 
{ 
  int idx ;
  int rw ;
  int tmp ;

  {
#line 286
  rw = 258;
#line 288
  yylval->cvalue = str;
#line 290
  idx = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! ((unsigned long )idx <= sizeof(rwtable) / sizeof(rwtable[0]) - 1UL)) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = strcasecmp((char const   *)rwtable[idx].rw_name, (char const   *)str);
    }
#line 291
    if (tmp == 0) {
#line 293
      rw = rwtable[idx].rw_yylex;
#line 294
      yylval->token = rw;
    }
#line 290
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (rw);
}
}
#line 302 "svf_flex.l"
static void align_string(char *str ) 
{ 
  int src ;
  int dst ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 307
  dst = 0;
#line 308
  tmp = strlen((char const   *)str);
#line 308
  len = (int )tmp;
#line 310
  src = 0;
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (src < len)) {
#line 310
      goto while_break;
    }
    {
#line 311
    tmp___1 = __ctype_b_loc();
    }
#line 311
    if ((int const   )*(*tmp___1 + (int )*(str + src)) & 4096) {
#line 312
      tmp___0 = dst;
#line 312
      dst ++;
#line 312
      *(str + tmp___0) = *(str + src);
    }
#line 310
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  *(str + dst) = (char )'\000';
#line 315
  return;
}
}
#line 319 "svf_flex.l"
static void fix_yylloc(YYLTYPE *yylloc , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 322
  yylloc->first_line = yylloc->last_line;
#line 323
  yylloc->first_column = yylloc->last_column;
#line 324
  tmp = strlen((char const   *)str);
#line 324
  yylloc->last_column = (int )((size_t )yylloc->last_column + tmp);
  }
#line 325
  return;
}
}
#line 328 "svf_flex.l"
static void fix_yylloc_nl(YYLTYPE *yylloc , char *str ) 
{ 
  char *p ;

  {
#line 333
  yylloc->first_line = yylloc->last_line;
#line 334
  yylloc->first_column = yylloc->last_column;
#line 335
  p = str;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! *p) {
#line 335
      goto while_break;
    }
#line 336
    if ((int )*p == 10) {
#line 337
      yylloc->last_column = 0;
#line 338
      (yylloc->last_line) ++;
    } else {
#line 340
      (yylloc->last_column) ++;
    }
#line 335
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 48 "svf_bison.y"
static struct svf_parser_params parser_params  =    {{0.0, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, {0, (uint32_t )0.0, 0, (double )0,
                                                (double )0, 0}};
#line 54
void yyerror(char const   *error_string ) ;
#line 56
static void svf_free_ths_params(struct ths_params *params ) ;
#line 515 "svf_bison.c"
static yytype_uint8 const   yytranslate___0[315]  = 
#line 515 "svf_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59};
#line 606 "svf_bison.c"
static char const   * const  yytname[81]  = 
#line 606
  {      (char const   */* const  */)"SVF_EOF",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENTIFIER", 
        (char const   */* const  */)"NUMBER",      (char const   */* const  */)"HEXA_NUM",      (char const   */* const  */)"VECTOR_STRING",      (char const   */* const  */)"EMPTY", 
        (char const   */* const  */)"ENDDR",      (char const   */* const  */)"ENDIR",      (char const   */* const  */)"FREQUENCY",      (char const   */* const  */)"HZ", 
        (char const   */* const  */)"STATE",      (char const   */* const  */)"RESET",      (char const   */* const  */)"IDLE",      (char const   */* const  */)"TDI", 
        (char const   */* const  */)"TDO",      (char const   */* const  */)"MASK",      (char const   */* const  */)"SMASK",      (char const   */* const  */)"TRST", 
        (char const   */* const  */)"ON",      (char const   */* const  */)"OFF",      (char const   */* const  */)"Z",      (char const   */* const  */)"ABSENT", 
        (char const   */* const  */)"HDR",      (char const   */* const  */)"HIR",      (char const   */* const  */)"SDR",      (char const   */* const  */)"SIR", 
        (char const   */* const  */)"TDR",      (char const   */* const  */)"TIR",      (char const   */* const  */)"PIO",      (char const   */* const  */)"PIOMAP", 
        (char const   */* const  */)"IN",      (char const   */* const  */)"OUT",      (char const   */* const  */)"INOUT",      (char const   */* const  */)"H", 
        (char const   */* const  */)"L",      (char const   */* const  */)"U",      (char const   */* const  */)"D",      (char const   */* const  */)"X", 
        (char const   */* const  */)"RUNTEST",      (char const   */* const  */)"MAXIMUM",      (char const   */* const  */)"SEC",      (char const   */* const  */)"TCK", 
        (char const   */* const  */)"SCK",      (char const   */* const  */)"ENDSTATE",      (char const   */* const  */)"IRPAUSE",      (char const   */* const  */)"IRSHIFT", 
        (char const   */* const  */)"IRUPDATE",      (char const   */* const  */)"IRSELECT",      (char const   */* const  */)"IREXIT1",      (char const   */* const  */)"IREXIT2", 
        (char const   */* const  */)"IRCAPTURE",      (char const   */* const  */)"DRPAUSE",      (char const   */* const  */)"DRSHIFT",      (char const   */* const  */)"DRUPDATE", 
        (char const   */* const  */)"DRSELECT",      (char const   */* const  */)"DREXIT1",      (char const   */* const  */)"DREXIT2",      (char const   */* const  */)"DRCAPTURE", 
        (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"line",      (char const   */* const  */)"svf_statement",      (char const   */* const  */)"ths_param_list",      (char const   */* const  */)"ths_opt_param", 
        (char const   */* const  */)"stable_state",      (char const   */* const  */)"runtest_run_state_opt",      (char const   */* const  */)"runtest_clk_count",      (char const   */* const  */)"runtest_time_opt", 
        (char const   */* const  */)"runtest_time",      (char const   */* const  */)"runtest_max_time_opt",      (char const   */* const  */)"runtest_end_state_opt",      (char const   */* const  */)"all_states", 
        (char const   */* const  */)"path_states",      (char const   */* const  */)"piomap_rec",      (char const   */* const  */)"trst_mode",      (char const   */* const  */)"direction", 
        (char const   */* const  */)0};
#line 640 "svf_bison.c"
static yytype_uint8 const   yyr1___0[69]  = 
#line 640
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79};
#line 652 "svf_bison.c"
static yytype_uint8 const   yyr2___0[69]  = 
#line 652
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1};
#line 666 "svf_bison.c"
static yytype_uint8 const   yydefact___0[119]  = 
#line 666
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )50,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )60,      (yytype_uint8 const   )38,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )61,      (yytype_uint8 const   )39};
#line 683 "svf_bison.c"
static yytype_int8 const   yydefgoto___0[17]  = 
#line 683
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )19,      (yytype_int8 const   )66, 
        (yytype_int8 const   )87,      (yytype_int8 const   )24,      (yytype_int8 const   )43,      (yytype_int8 const   )78, 
        (yytype_int8 const   )98,      (yytype_int8 const   )79,      (yytype_int8 const   )108,      (yytype_int8 const   )101, 
        (yytype_int8 const   )64,      (yytype_int8 const   )28,      (yytype_int8 const   )106,      (yytype_int8 const   )33, 
        (yytype_int8 const   )76};
#line 692 "svf_bison.c"
static yytype_int16 const   yypact___0[119]  = 
#line 692
  {      (yytype_int16 const   )55,      (yytype_int16 const   )4,      (yytype_int16 const   )88,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )-3, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )31,      (yytype_int16 const   )17,      (yytype_int16 const   )45, 
        (yytype_int16 const   )57,      (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )73, 
        (yytype_int16 const   )67,      (yytype_int16 const   )26,      (yytype_int16 const   )46,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )18,      (yytype_int16 const   )29,      (yytype_int16 const   )79,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-11,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )33,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )44,      (yytype_int16 const   )-23,      (yytype_int16 const   )-24,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )65,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )66, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-10,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )2,      (yytype_int16 const   )8,      (yytype_int16 const   )12,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )102,      (yytype_int16 const   )27,      (yytype_int16 const   )123,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )93,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )94,      (yytype_int16 const   )61,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )46,      (yytype_int16 const   )75,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )78,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )80,      (yytype_int16 const   )136,      (yytype_int16 const   )99,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24};
#line 709 "svf_bison.c"
static yytype_int8 const   yypgoto___0[17]  = 
#line 709
  {      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )85, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-6,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )64,      (yytype_int8 const   )-24,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )37};
#line 720 "svf_bison.c"
static yytype_int8 const   yytable___0[146]  = 
#line 720
  {      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )3,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )42,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )34,      (yytype_int8 const   )63,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )49, 
        (yytype_int8 const   )50,      (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53, 
        (yytype_int8 const   )54,      (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57, 
        (yytype_int8 const   )58,      (yytype_int8 const   )59,      (yytype_int8 const   )60,      (yytype_int8 const   )61, 
        (yytype_int8 const   )62,      (yytype_int8 const   )35,      (yytype_int8 const   )86,      (yytype_int8 const   )29, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )1,      (yytype_int8 const   )27,      (yytype_int8 const   )88,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )36,      (yytype_int8 const   )89,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )37,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )90,      (yytype_int8 const   )94,      (yytype_int8 const   )95,      (yytype_int8 const   )96, 
        (yytype_int8 const   )91,      (yytype_int8 const   )40,      (yytype_int8 const   )-2,      (yytype_int8 const   )38, 
        (yytype_int8 const   )92,      (yytype_int8 const   )39,      (yytype_int8 const   )44,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )41, 
        (yytype_int8 const   )4,      (yytype_int8 const   )45,      (yytype_int8 const   )46,      (yytype_int8 const   )77, 
        (yytype_int8 const   )22,      (yytype_int8 const   )65,      (yytype_int8 const   )110,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )8,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )72,      (yytype_int8 const   )93,      (yytype_int8 const   )100,      (yytype_int8 const   )9, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-27,      (yytype_int8 const   )-28,      (yytype_int8 const   )-30, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-29,      (yytype_int8 const   )81,      (yytype_int8 const   )97, 
        (yytype_int8 const   )18,      (yytype_int8 const   )102,      (yytype_int8 const   )103,      (yytype_int8 const   )112, 
        (yytype_int8 const   )104,      (yytype_int8 const   )105,      (yytype_int8 const   )107,      (yytype_int8 const   )111, 
        (yytype_int8 const   )94,      (yytype_int8 const   )114,      (yytype_int8 const   )115,      (yytype_int8 const   )117, 
        (yytype_int8 const   )116,      (yytype_int8 const   )118,      (yytype_int8 const   )99,      (yytype_int8 const   )113, 
        (yytype_int8 const   )0,      (yytype_int8 const   )109};
#line 739 "svf_bison.c"
static yytype_int8 const   yycheck___0[146]  = 
#line 739
  {      (yytype_int8 const   )6,      (yytype_int8 const   )4,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )0,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )4,      (yytype_int8 const   )28,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )46, 
        (yytype_int8 const   )47,      (yytype_int8 const   )48,      (yytype_int8 const   )49,      (yytype_int8 const   )50, 
        (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53,      (yytype_int8 const   )54, 
        (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )58, 
        (yytype_int8 const   )59,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )0, 
        (yytype_int8 const   )1,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4,      (yytype_int8 const   )12, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )60,      (yytype_int8 const   )6,      (yytype_int8 const   )19,      (yytype_int8 const   )4, 
        (yytype_int8 const   )60,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )61, 
        (yytype_int8 const   )0,      (yytype_int8 const   )60,      (yytype_int8 const   )11,      (yytype_int8 const   )4, 
        (yytype_int8 const   )46,      (yytype_int8 const   )60,      (yytype_int8 const   )100,      (yytype_int8 const   )40, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )53, 
        (yytype_int8 const   )12,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )60,      (yytype_int8 const   )3,      (yytype_int8 const   )45,      (yytype_int8 const   )19, 
        (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60, 
        (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27, 
        (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31, 
        (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37,      (yytype_int8 const   )38, 
        (yytype_int8 const   )39,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )4, 
        (yytype_int8 const   )40,      (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )41,      (yytype_int8 const   )60, 
        (yytype_int8 const   )42,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )3, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )78,      (yytype_int8 const   )106, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )98};
#line 760 "svf_bison.c"
static yytype_uint8 const   yystos___0[119]  = 
#line 760
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )64,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )78,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )61,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )11,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )60,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )70,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )60,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )74,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )68,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42};
#line 1060 "svf_bison.c"
static unsigned long yystrlen(char const   *yystr ) 
{ 
  unsigned long yylen ;

  {
#line 1069
  yylen = 0UL;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! *(yystr + yylen)) {
#line 1069
      goto while_break;
    }
#line 1070
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1069
    yylen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1071
  return (yylen);
}
}
#line 1084 "svf_bison.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1093
  yyd = yydest;
#line 1094
  yys = yysrc;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    tmp = yyd;
#line 1096
    yyd ++;
#line 1096
    tmp___1 = yys;
#line 1096
    yys ++;
#line 1096
    tmp___0 = (char )*tmp___1;
#line 1096
    *tmp = tmp___0;
#line 1096
    if (! ((int )tmp___0 != 0)) {
#line 1096
      goto while_break;
    }
#line 1097
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  return (yyd - 1);
}
}
#line 1112 "svf_bison.c"
static unsigned long yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned long yyn ;
  char const   *yyp ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 1115
  if ((int const   )*yystr == 34) {
#line 1117
    yyn = 0UL;
#line 1118
    yyp = yystr;
    {
#line 1120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1121
      yyp ++;
      {
#line 1124
      if ((int const   )*yyp == 44) {
#line 1124
        goto case_44;
      }
#line 1124
      if ((int const   )*yyp == 39) {
#line 1124
        goto case_44;
      }
#line 1127
      if ((int const   )*yyp == 92) {
#line 1127
        goto case_92;
      }
#line 1137
      if ((int const   )*yyp == 34) {
#line 1137
        goto case_34;
      }
#line 1131
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1125
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1128
      yyp ++;
#line 1128
      if ((int const   )*yyp != 92) {
#line 1129
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1132
      if (yyres) {
#line 1133
        *(yyres + yyn) = (char )*yyp;
      }
#line 1134
      yyn ++;
#line 1135
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1138
      if (yyres) {
#line 1139
        *(yyres + yyn) = (char )'\000';
      }
#line 1140
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1145
  if (! yyres) {
    {
#line 1146
    tmp = yystrlen(yystr);
    }
#line 1146
    return (tmp);
  }
  {
#line 1148
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 1148
  return ((unsigned long )(tmp___0 - yyres));
}
}
#line 1188
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar ) ;
#line 1188 "svf_bison.c"
static char const   yyunexpected[28]  = 
#line 1188
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1189 "svf_bison.c"
static char const   yyexpecting[15]  = 
#line 1189
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1190 "svf_bison.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1159 "svf_bison.c"
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned long yysize0 ;
  unsigned long tmp___0 ;
  unsigned long yysize ;
  unsigned long yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char tmp___8 ;

  {
#line 1162
  yyn = (int )yypact___0[yystate];
#line 1164
  if (-24 < yyn) {
#line 1164
    if (yyn <= 145) {
#line 1168
      if ((unsigned int )yychar <= 314U) {
#line 1168
        tmp = (int const   )yytranslate___0[yychar];
      } else {
#line 1168
        tmp = (int const   )2;
      }
      {
#line 1168
      yytype = (int )tmp;
#line 1169
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1169
      yysize0 = tmp___0;
#line 1170
      yysize = yysize0;
#line 1172
      yysize_overflow = 0;
#line 1195
      yyprefix = yyexpecting;
      }
#line 1199
      if (yyn < 0) {
#line 1199
        tmp___1 = - yyn;
      } else {
#line 1199
        tmp___1 = 0;
      }
#line 1199
      yyxbegin = tmp___1;
#line 1202
      yychecklim = (145 - yyn) + 1;
#line 1203
      if (yychecklim < 63) {
#line 1203
        tmp___2 = yychecklim;
      } else {
#line 1203
        tmp___2 = 63;
      }
      {
#line 1203
      yyxend = tmp___2;
#line 1204
      yycount = 1;
#line 1206
      yyarg[0] = (char const   *)yytname[yytype];
#line 1207
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1209
      yyx = yyxbegin;
      }
      {
#line 1209
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1209
        if (! (yyx < yyxend)) {
#line 1209
          goto while_break;
        }
#line 1210
        if ((int const   )yycheck___0[yyx + yyn] == (int const   )yyx) {
#line 1210
          if (yyx != 1) {
#line 1212
            if (yycount == 5) {
#line 1214
              yycount = 1;
#line 1215
              yysize = yysize0;
#line 1216
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1217
              goto while_break;
            }
            {
#line 1219
            tmp___3 = yycount;
#line 1219
            yycount ++;
#line 1219
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1220
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1220
            yysize1 = yysize + tmp___4;
#line 1221
            yysize_overflow |= yysize1 < yysize;
#line 1222
            yysize = yysize1;
#line 1223
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1224
            yyprefix = yyor;
            }
          }
        }
#line 1209
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1227
      yyf = (char const   *)(yyformat);
#line 1228
      tmp___5 = yystrlen(yyf);
#line 1228
      yysize1 = yysize + tmp___5;
#line 1229
      yysize_overflow |= yysize1 < yysize;
#line 1230
      yysize = yysize1;
      }
#line 1232
      if (yysize_overflow) {
#line 1233
        return (0xffffffffffffffffUL);
      }
#line 1235
      if (yyresult) {
#line 1240
        yyp = yyresult;
#line 1241
        yyi = 0;
        {
#line 1242
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1242
          tmp___8 = (char )*yyf;
#line 1242
          *yyp = tmp___8;
#line 1242
          if (! ((int )tmp___8 != 0)) {
#line 1242
            goto while_break___0;
          }
#line 1244
          if ((int )*yyp == 37) {
#line 1244
            if ((int const   )*(yyf + 1) == 115) {
#line 1244
              if (yyi < yycount) {
                {
#line 1246
                tmp___6 = yyi;
#line 1246
                yyi ++;
#line 1246
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1246
                yyp += tmp___7;
#line 1247
                yyf += 2;
                }
              } else {
#line 1251
                yyp ++;
#line 1252
                yyf ++;
              }
            } else {
#line 1251
              yyp ++;
#line 1252
              yyf ++;
            }
          } else {
#line 1251
            yyp ++;
#line 1252
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1256
      return (yysize);
    } else {
#line 1165
      return (0UL);
    }
  } else {
#line 1165
    return (0UL);
  }
}
}
#line 1269 "svf_bison.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ,
                           YYLTYPE *yylocationp ) 
{ 


  {
#line 1283
  if (! yymsg) {
#line 1284
    yymsg = "Deleting";
  }
  {
#line 1290
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1293
  return;
}
}
#line 1334 "svf_bison.c"
int yyparse(void) 
{ 
  int yychar ;
  YYSTYPE___0 yylval ;
  int yynerrs ;
  YYLTYPE yylloc ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned long yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  YYLTYPE yylsa[200] ;
  YYLTYPE *yyls ;
  YYLTYPE *yylsp ;
  YYLTYPE yyerror_range[2] ;
  unsigned long yystacksize ;
  YYSTYPE___0 yyval ;
  YYLTYPE yyloc ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  unsigned long yynewbytes___1 ;
  struct ths_params *p ;
  struct ths_params *p___0 ;
  struct runtest *rt ;
  int tmp___0 ;
  struct runtest *rt___0 ;
  int tmp___1 ;
  struct ths_params *p___1 ;
  int result ;
  struct ths_params *p___2 ;
  int result___0 ;
  int tmp___2 ;
  struct ths_params *p___3 ;
  int result___1 ;
  struct ths_params *p___4 ;
  int result___2 ;
  int tmp___3 ;
  struct path_states *ps ;
  unsigned long yysize___0 ;
  unsigned long tmp___4 ;
  unsigned long yyalloc___0 ;
  void *tmp___5 ;

  {
#line 1360
  yytoken = 0;
#line 1364
  yymsg = yymsgbuf;
#line 1365
  yymsg_alloc = sizeof(yymsgbuf);
#line 1378
  yyss = yyssa;
#line 1383
  yyvs = yyvsa;
#line 1388
  yyls = yylsa;
#line 1395
  yystacksize = 200UL;
#line 1404
  yylen = 0;
#line 1408
  yystate = 0;
#line 1409
  yyerrstatus = 0;
#line 1410
  yynerrs = 0;
#line 1411
  yychar = -2;
#line 1418
  yyssp = yyss;
#line 1419
  yyvsp = yyvs;
#line 1420
  yylsp = yyls;
#line 1423
  yylloc.last_line = 1;
#line 1423
  yylloc.first_line = yylloc.last_line;
#line 1424
  yylloc.last_column = 0;
#line 1424
  yylloc.first_column = yylloc.last_column;
#line 1427
  goto yysetstate;
  yynewstate: 
#line 1435
  yyssp ++;
  yysetstate: 
#line 1438
  *yyssp = (yytype_int16 )yystate;
#line 1440
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1443
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1472
    if (10000UL <= yystacksize) {
#line 1473
      goto yyexhaustedlab;
    }
#line 1474
    yystacksize *= 2UL;
#line 1475
    if (10000UL < yystacksize) {
#line 1476
      yystacksize = 10000UL;
    }
    {
#line 1479
    yyss1 = yyss;
#line 1480
    tmp = malloc(yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + sizeof(YYLTYPE )) + 2UL * (sizeof(union yyalloc___0 ) - 1UL));
#line 1480
    yyptr = (union yyalloc___0 *)tmp;
    }
#line 1482
    if (! yyptr) {
#line 1483
      goto yyexhaustedlab;
    }
    {
#line 1484
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1484
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1484
      yyss = & yyptr->yyss;
#line 1484
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1484
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1484
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1485
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1485
      yyvs = & yyptr->yyvs;
#line 1485
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1485
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1486
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1486
      __builtin_memcpy((void *)(& yyptr->yyls), (void const   *)yyls, yysize * sizeof(*yyls));
#line 1486
      yyls = & yyptr->yyls;
#line 1486
      yynewbytes___1 = yystacksize * sizeof(*yyls) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1486
      yyptr += yynewbytes___1 / sizeof(*yyptr);
      }
#line 1486
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1488
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1489
      free((void *)yyss1);
      }
    }
#line 1494
    yyssp = (yyss + yysize) - 1;
#line 1495
    yyvsp = (yyvs + yysize) - 1;
#line 1496
    yylsp = (yyls + yysize) - 1;
#line 1501
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1502
      goto yyabortlab;
    }
  }
#line 1507
  goto yybackup;
  yybackup: 
#line 1518
  yyn = (int )yypact___0[yystate];
#line 1519
  if (yyn == -24) {
#line 1520
    goto yydefault;
  }
#line 1525
  if (yychar == -2) {
    {
#line 1528
    yychar = yylex(& yylval, & yylloc);
    }
  }
#line 1531
  if (yychar <= 0) {
#line 1533
    yytoken = 0;
#line 1533
    yychar = yytoken;
  } else
#line 1538
  if ((unsigned int )yychar <= 314U) {
#line 1538
    yytoken = (int )yytranslate___0[yychar];
  } else {
#line 1538
    yytoken = 2;
  }
#line 1544
  yyn += yytoken;
#line 1545
  if (yyn < 0) {
#line 1546
    goto yydefault;
  } else
#line 1545
  if (145 < yyn) {
#line 1546
    goto yydefault;
  } else
#line 1545
  if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
#line 1546
    goto yydefault;
  }
#line 1547
  yyn = (int )yytable___0[yyn];
#line 1548
  if (yyn <= 0) {
#line 1550
    if (yyn == 0) {
#line 1551
      goto yyerrlab;
    } else
#line 1550
    if (yyn == -31) {
#line 1551
      goto yyerrlab;
    }
#line 1552
    yyn = - yyn;
#line 1553
    goto yyreduce;
  }
#line 1556
  if (yyn == 4) {
#line 1557
    goto yyacceptlab;
  }
#line 1561
  if (yyerrstatus) {
#line 1562
    yyerrstatus --;
  }
#line 1568
  if (yychar != 0) {
#line 1569
    yychar = -2;
  }
#line 1571
  yystate = yyn;
#line 1572
  yyvsp ++;
#line 1572
  *yyvsp = yylval;
#line 1573
  yylsp ++;
#line 1573
  *yylsp = yylloc;
#line 1574
  goto yynewstate;
  yydefault: 
#line 1581
  yyn = (int )yydefact___0[yystate];
#line 1582
  if (yyn == 0) {
#line 1583
    goto yyerrlab;
  }
#line 1584
  goto yyreduce;
  yyreduce: 
#line 1592
  yylen = (int )yyr2___0[yyn];
#line 1602
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1605
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1605
    if (yylen) {
#line 1605
      yyloc.first_line = ((yylsp - yylen) + 1)->first_line;
#line 1605
      yyloc.first_column = ((yylsp - yylen) + 1)->first_column;
#line 1605
      yyloc.last_line = ((yylsp - yylen) + yylen)->last_line;
#line 1605
      yyloc.last_column = ((yylsp - yylen) + yylen)->last_column;
    } else {
#line 1605
      yyloc.last_line = ((yylsp - yylen) + 0)->last_line;
#line 1605
      yyloc.first_line = yyloc.last_line;
#line 1605
      yyloc.last_column = ((yylsp - yylen) + 0)->last_column;
#line 1605
      yyloc.first_column = yyloc.last_column;
    }
#line 1605
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1609
  if (yyn == 5) {
#line 1609
    goto case_5;
  }
#line 112
  if (yyn == 6) {
#line 112 "svf_bison.y"
    goto case_6;
  }
#line 117
  if (yyn == 7) {
#line 117
    goto case_7;
  }
#line 122
  if (yyn == 8) {
#line 122
    goto case_8;
  }
#line 127
  if (yyn == 9) {
#line 127
    goto case_9;
  }
#line 136
  if (yyn == 10) {
#line 136
    goto case_10;
  }
#line 145
  if (yyn == 11) {
#line 145
    goto case_11;
  }
#line 152
  if (yyn == 12) {
#line 152
    goto case_12;
  }
#line 160
  if (yyn == 13) {
#line 160
    goto case_13;
  }
#line 175
  if (yyn == 14) {
#line 175
    goto case_14;
  }
#line 190
  if (yyn == 15) {
#line 190
    goto case_15;
  }
#line 205
  if (yyn == 16) {
#line 205
    goto case_16;
  }
#line 220
  if (yyn == 17) {
#line 220
    goto case_17;
  }
#line 228
  if (yyn == 18) {
#line 228
    goto case_18;
  }
#line 243
  if (yyn == 19) {
#line 243
    goto case_19;
  }
#line 258
  if (yyn == 20) {
#line 258
    goto case_20;
  }
#line 266
  if (yyn == 23) {
#line 266
    goto case_23;
  }
#line 279
  if (yyn == 24) {
#line 279
    goto case_24;
  }
#line 284
  if (yyn == 25) {
#line 284
    goto case_25;
  }
#line 289
  if (yyn == 26) {
#line 289
    goto case_26;
  }
#line 294
  if (yyn == 31) {
#line 294
    goto case_31;
  }
#line 305
  if (yyn == 32) {
#line 305
    goto case_32;
  }
#line 309
  if (yyn == 33) {
#line 309
    goto case_33;
  }
#line 317
  if (yyn == 34) {
#line 317
    goto case_34;
  }
#line 323
  if (yyn == 35) {
#line 323
    goto case_35;
  }
#line 331
  if (yyn == 37) {
#line 331
    goto case_37;
  }
#line 340
  if (yyn == 39) {
#line 340
    goto case_39;
  }
#line 348
  if (yyn == 40) {
#line 348
    goto case_40;
  }
#line 352
  if (yyn == 41) {
#line 352
    goto case_41;
  }
#line 356
  if (yyn == 58) {
#line 356
    goto case_58;
  }
#line 382
  if (yyn == 59) {
#line 382
    goto case_59;
  }
#line 1914 "svf_bison.c"
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 108 "svf_bison.y"
  svf_endxr((enum generic_irdr_coding )0, (yyvsp + -1)->token);
  }
#line 110
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 113
  svf_endxr((enum generic_irdr_coding )1, (yyvsp + -1)->token);
  }
#line 115
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 118
  svf_frequency(0.0);
  }
#line 120
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 123
  svf_frequency((yyvsp + -2)->dvalue);
  }
#line 125
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 128
  p = & parser_params.ths_params;
#line 130
  p->number = (yyvsp + -2)->dvalue;
#line 131
  svf_hxr((enum generic_irdr_coding )1, p);
#line 132
  svf_free_ths_params(p);
  }
#line 134
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 137
  p___0 = & parser_params.ths_params;
#line 139
  p___0->number = (yyvsp + -2)->dvalue;
#line 140
  svf_hxr((enum generic_irdr_coding )0, p___0);
#line 141
  svf_free_ths_params(p___0);
  }
#line 143
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"PIOMAP not implemented\n");
#line 147
  yyerror("PIOMAP");
  }
#line 148
  goto yyerrorlab;
#line 150
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 153
  free((void *)(yyvsp + -1)->cvalue);
#line 154
  printf((char const   */* __restrict  */)"PIO not implemented\n");
#line 155
  yyerror("PIO");
  }
#line 156
  goto yyerrorlab;
#line 158
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 161
  rt = & parser_params.runtest;
#line 163
  rt->run_state = (yyvsp + -4)->token;
#line 164
  rt->run_count = (uint32_t )(yyvsp + -3)->tdval.dvalue;
#line 165
  rt->run_clk = (yyvsp + -3)->tdval.token;
#line 166
  rt->end_state = (yyvsp + -1)->token;
#line 168
  tmp___0 = svf_runtest(rt);
  }
#line 168
  if (! tmp___0) {
    {
#line 169
    yyerror("RUNTEST");
    }
#line 170
    goto yyerrorlab;
  }
#line 173
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 176
  rt___0 = & parser_params.runtest;
#line 178
  rt___0->run_state = (yyvsp + -3)->token;
#line 179
  rt___0->run_count = (uint32_t )0;
#line 180
  rt___0->run_clk = 0;
#line 181
  rt___0->end_state = (yyvsp + -1)->token;
#line 183
  tmp___1 = svf_runtest(rt___0);
  }
#line 183
  if (! tmp___1) {
    {
#line 184
    yyerror("RUNTEST");
    }
#line 185
    goto yyerrorlab;
  }
#line 188
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 191
  p___1 = & parser_params.ths_params;
#line 194
  p___1->number = (yyvsp + -2)->dvalue;
#line 195
  result = svf_sxr((enum generic_irdr_coding )1, p___1, & yyloc);
#line 196
  svf_free_ths_params(p___1);
  }
#line 198
  if (! result) {
    {
#line 199
    yyerror("SDR");
    }
#line 200
    goto yyerrorlab;
  }
#line 203
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 206
  p___2 = & parser_params.ths_params;
#line 209
  p___2->number = (yyvsp + -2)->dvalue;
#line 210
  result___0 = svf_sxr((enum generic_irdr_coding )0, p___2, & yyloc);
#line 211
  svf_free_ths_params(p___2);
  }
#line 213
  if (! result___0) {
    {
#line 214
    yyerror("SIR");
    }
#line 215
    goto yyerrorlab;
  }
#line 218
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 221
  tmp___2 = svf_state(& parser_params.path_states, (yyvsp + -1)->token);
  }
#line 221
  if (! tmp___2) {
    {
#line 222
    yyerror("STATE");
    }
#line 223
    goto yyerrorlab;
  }
#line 226
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 229
  p___3 = & parser_params.ths_params;
#line 232
  p___3->number = (yyvsp + -2)->dvalue;
#line 233
  result___1 = svf_txr((enum generic_irdr_coding )1, p___3);
#line 234
  svf_free_ths_params(p___3);
  }
#line 236
  if (! result___1) {
    {
#line 237
    yyerror("TDR");
    }
#line 238
    goto yyerrorlab;
  }
#line 241
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 244
  p___4 = & parser_params.ths_params;
#line 247
  p___4->number = (yyvsp + -2)->dvalue;
#line 248
  result___2 = svf_txr((enum generic_irdr_coding )0, p___4);
#line 249
  svf_free_ths_params(p___4);
  }
#line 251
  if (! result___2) {
    {
#line 252
    yyerror("TIR");
    }
#line 253
    goto yyerrorlab;
  }
#line 256
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 259
  tmp___3 = svf_trst((yyvsp + -1)->token);
  }
#line 259
  if (! tmp___3) {
    {
#line 260
    yyerror("TRST");
    }
#line 261
    goto yyerrorlab;
  }
#line 264
  goto switch_break;
  case_23: /* CIL Label */ 
#line 275
  parser_params.ths_params.tdi = (yyvsp + 0)->cvalue;
#line 277
  goto switch_break;
  case_24: /* CIL Label */ 
#line 280
  parser_params.ths_params.tdo = (yyvsp + 0)->cvalue;
#line 282
  goto switch_break;
  case_25: /* CIL Label */ 
#line 285
  parser_params.ths_params.mask = (yyvsp + 0)->cvalue;
#line 287
  goto switch_break;
  case_26: /* CIL Label */ 
#line 290
  parser_params.ths_params.smask = (yyvsp + 0)->cvalue;
#line 292
  goto switch_break;
  case_31: /* CIL Label */ 
#line 302
  yyval.token = 0;
#line 303
  goto switch_break;
  case_32: /* CIL Label */ 
#line 305
  yyval.token = (yyvsp + 0)->token;
#line 307
  goto switch_break;
  case_33: /* CIL Label */ 
#line 312
  yyval.tdval.token = (yyvsp + 0)->token;
#line 313
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 315
  goto switch_break;
  case_34: /* CIL Label */ 
#line 318
  yyval.tdval.token = (yyvsp + 0)->token;
#line 319
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 321
  goto switch_break;
  case_35: /* CIL Label */ 
#line 326
  parser_params.runtest.min_time = 0.0;
#line 327
  parser_params.runtest.max_time = 0.0;
#line 329
  goto switch_break;
  case_37: /* CIL Label */ 
#line 336
  parser_params.runtest.min_time = (yyvsp + -2)->dvalue;
#line 338
  goto switch_break;
  case_39: /* CIL Label */ 
#line 344
  parser_params.runtest.max_time = (yyvsp + -1)->dvalue;
#line 346
  goto switch_break;
  case_40: /* CIL Label */ 
#line 349
  yyval.token = 0;
#line 350
  goto switch_break;
  case_41: /* CIL Label */ 
#line 352
  yyval.token = (yyvsp + 0)->token;
#line 354
  goto switch_break;
  case_58: /* CIL Label */ 
#line 378
  parser_params.path_states.num_states = 0;
#line 380
  goto switch_break;
  case_59: /* CIL Label */ 
#line 383
  ps = & parser_params.path_states;
#line 385
  if (ps->num_states < 64) {
#line 386
    ps->states[ps->num_states] = (yyvsp + 0)->token;
#line 387
    (ps->num_states) ++;
  } else {
    {
#line 389
    printf((char const   */* __restrict  */)"Error %s: maximum number of %d path states reached.\n",
           "svf", 64);
    }
  }
#line 392
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1914 "svf_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1918
  yyvsp -= yylen;
#line 1918
  yyssp -= yylen;
#line 1918
  yylsp -= yylen;
#line 1919
  yylen = 0;
#line 1922
  yyvsp ++;
#line 1922
  *yyvsp = yyval;
#line 1923
  yylsp ++;
#line 1923
  *yylsp = yyloc;
#line 1929
  yyn = (int )yyr1___0[yyn];
#line 1931
  yystate = (int )((int const   )yypgoto___0[yyn - 63] + (int const   )*yyssp);
#line 1932
  if (0 <= yystate) {
#line 1932
    if (yystate <= 145) {
#line 1932
      if ((int const   )yycheck___0[yystate] == (int const   )*yyssp) {
#line 1933
        yystate = (int )yytable___0[yystate];
      } else {
#line 1935
        yystate = (int )yydefgoto___0[yyn - 63];
      }
    } else {
#line 1935
      yystate = (int )yydefgoto___0[yyn - 63];
    }
  } else {
#line 1935
    yystate = (int )yydefgoto___0[yyn - 63];
  }
#line 1937
  goto yynewstate;
  yyerrlab: 
#line 1945
  if (! yyerrstatus) {
    {
#line 1947
    yynerrs ++;
#line 1952
    tmp___4 = yysyntax_error((char *)0, yystate, yychar);
#line 1952
    yysize___0 = tmp___4;
    }
#line 1953
    if (yymsg_alloc < yysize___0) {
#line 1953
      if (yymsg_alloc < 0xffffffffffffffffUL) {
#line 1955
        yyalloc___0 = 2UL * yysize___0;
#line 1956
        if (yysize___0 <= yyalloc___0) {
#line 1956
          if (! (yyalloc___0 <= 0xffffffffffffffffUL)) {
#line 1957
            yyalloc___0 = 0xffffffffffffffffUL;
          }
        } else {
#line 1957
          yyalloc___0 = 0xffffffffffffffffUL;
        }
#line 1958
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 1959
          free((void *)yymsg);
          }
        }
        {
#line 1960
        tmp___5 = malloc(yyalloc___0);
#line 1960
        yymsg = (char *)tmp___5;
        }
#line 1961
        if (yymsg) {
#line 1962
          yymsg_alloc = yyalloc___0;
        } else {
#line 1965
          yymsg = yymsgbuf;
#line 1966
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 1970
    if (0UL < yysize___0) {
#line 1970
      if (yysize___0 <= yymsg_alloc) {
        {
#line 1972
        yysyntax_error(yymsg, yystate, yychar);
#line 1973
        yyerror((char const   *)yymsg);
        }
      } else {
#line 1970
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1977
      yyerror("syntax error");
      }
#line 1978
      if (yysize___0 != 0UL) {
#line 1979
        goto yyexhaustedlab;
      }
    }
  }
#line 1985
  yyerror_range[0] = yylloc;
#line 1987
  if (yyerrstatus == 3) {
#line 1992
    if (yychar <= 0) {
#line 1995
      if (yychar == 0) {
#line 1996
        goto yyabortlab;
      }
    } else {
      {
#line 2000
      yydestruct___0("Error: discarding", yytoken, & yylval, & yylloc);
#line 2002
      yychar = -2;
      }
    }
  }
#line 2008
  goto yyerrlab1;
  yyerrorlab: 
#line 2022
  yyerror_range[0] = *(yylsp + (1 - yylen));
#line 2025
  yyvsp -= yylen;
#line 2025
  yyssp -= yylen;
#line 2025
  yylsp -= yylen;
#line 2026
  yylen = 0;
#line 2028
  yystate = (int )*yyssp;
#line 2029
  goto yyerrlab1;
  yyerrlab1: 
#line 2036
  yyerrstatus = 3;
  {
#line 2038
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2040
    yyn = (int )yypact___0[yystate];
#line 2041
    if (yyn != -24) {
#line 2043
      yyn ++;
#line 2044
      if (0 <= yyn) {
#line 2044
        if (yyn <= 145) {
#line 2044
          if ((int const   )yycheck___0[yyn] == 1) {
#line 2046
            yyn = (int )yytable___0[yyn];
#line 2047
            if (0 < yyn) {
#line 2048
              goto while_break___3;
            }
          }
        }
      }
    }
#line 2053
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2054
      goto yyabortlab;
    }
    {
#line 2056
    yyerror_range[0] = *yylsp;
#line 2057
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp, yylsp);
#line 2059
    yyvsp --;
#line 2059
    yyssp --;
#line 2059
    yylsp --;
#line 2060
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2064
  if (yyn == 4) {
#line 2065
    goto yyacceptlab;
  }
#line 2067
  yyvsp ++;
#line 2067
  *yyvsp = yylval;
#line 2069
  yyerror_range[1] = yylloc;
  {
#line 2072
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2072
    yyloc.first_line = ((yyerror_range - 1) + 1)->first_line;
#line 2072
    yyloc.first_column = ((yyerror_range - 1) + 1)->first_column;
#line 2072
    yyloc.last_line = ((yyerror_range - 1) + 2)->last_line;
#line 2072
    yyloc.last_column = ((yyerror_range - 1) + 2)->last_column;
#line 2072
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2073
  yylsp ++;
#line 2073
  *yylsp = yyloc;
#line 2078
  yystate = yyn;
#line 2079
  goto yynewstate;
  yyacceptlab: 
#line 2086
  yyresult = 0;
#line 2087
  goto yyreturn;
  yyabortlab: 
#line 2093
  yyresult = 1;
#line 2094
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2101
  yyerror("memory exhausted");
#line 2102
  yyresult = 2;
  }
  yyreturn: 
#line 2107
  if (yychar != 0) {
#line 2107
    if (yychar != -2) {
      {
#line 2108
      yydestruct___0("Cleanup: discarding lookahead", yytoken, & yylval, & yylloc);
      }
    }
  }
#line 2112
  yyvsp -= yylen;
#line 2112
  yyssp -= yylen;
#line 2112
  yylsp -= yylen;
  {
#line 2114
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2114
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2114
      goto while_break___5;
    }
    {
#line 2116
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp, yylsp);
#line 2118
    yyvsp --;
#line 2118
    yyssp --;
#line 2118
    yylsp --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2121
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2122
    free((void *)yyss);
    }
  }
#line 2125
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2126
    free((void *)yymsg);
    }
  }
#line 2129
  return (yyresult);
}
}
#line 415 "svf_bison.y"
void yyerror(char const   *error_string ) 
{ 


  {
  {
#line 418
  printf((char const   */* __restrict  */)"Error occured for SVF command %s.\n", error_string);
  }
#line 419
  return;
}
}
#line 422 "svf_bison.y"
static void svf_free_ths_params(struct ths_params *params ) 
{ 


  {
#line 425
  params->number = 0.0;
#line 427
  if (params->tdi) {
    {
#line 428
    free((void *)params->tdi);
#line 429
    params->tdi = (char *)((void *)0);
    }
  }
#line 431
  if (params->tdo) {
    {
#line 432
    free((void *)params->tdo);
#line 433
    params->tdo = (char *)((void *)0);
    }
  }
#line 435
  if (params->mask) {
    {
#line 436
    free((void *)params->mask);
#line 437
    params->mask = (char *)((void *)0);
    }
  }
#line 439
  if (params->smask) {
    {
#line 440
    free((void *)params->smask);
#line 441
    params->smask = (char *)((void *)0);
    }
  }
#line 443
  return;
}
}
#line 62 "../../include/part.h"
signal_t *part_find_signal(part_t *p , char const   *signalname ) ;
#line 64
void part_set_signal(part_t *p , signal_t *s , int out , int val ) ;
#line 65
int part_get_signal(part_t *p , signal_t *s ) ;
#line 52 "../../include/chain.h"
void chain_shift_instructions(chain_t *chain___0 ) ;
#line 54
void chain_shift_data_registers(chain_t *chain___0 , int capture_output ) ;
#line 55 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  zefant_xs3_bus ;
#line 152 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static uint32_t last_address  =    (uint32_t )0;
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void setup_address(bus_t *bus___0 , uint32_t a , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 158
  p = ((bus_params_t *)bus___0->params)->part;
#line 161
  last_address = a;
  {
#line 164
  if ((unsigned int )comp->ctype == 1U) {
#line 164
    goto case_1;
  }
#line 169
  if ((unsigned int )comp->ctype == 0U) {
#line 169
    goto case_0;
  }
#line 176
  if ((unsigned int )comp->ctype == 3U) {
#line 176
    goto case_3;
  }
#line 176
  if ((unsigned int )comp->ctype == 2U) {
#line 176
    goto case_3;
  }
#line 179
  goto switch_default;
  case_1: /* CIL Label */ 
#line 165
  addr_width = 25;
#line 168
  goto switch_break;
  case_0: /* CIL Label */ 
#line 170
  addr_width = 18;
#line 173
  a >>= 1;
#line 174
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 177
  addr_width = 16;
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 180
  addr_width = 0;
#line 181
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < addr_width)) {
#line 184
      goto while_break;
    }
    {
#line 185
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 184
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static int detect_data_width(component_t *comp ) 
{ 
  int width ;

  {
  {
#line 194
  if ((unsigned int )comp->ctype == 0U) {
#line 194
    goto case_0;
  }
#line 197
  if ((unsigned int )comp->ctype == 1U) {
#line 197
    goto case_1;
  }
#line 201
  if ((unsigned int )comp->ctype == 3U) {
#line 201
    goto case_3;
  }
#line 201
  if ((unsigned int )comp->ctype == 2U) {
#line 201
    goto case_3;
  }
#line 204
  goto switch_default;
  case_0: /* CIL Label */ 
#line 195
  width = 16;
#line 196
  goto switch_break;
  case_1: /* CIL Label */ 
#line 198
  width = 16;
#line 199
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 202
  width = 8;
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 205
  width = 0;
#line 206
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 209
  return (width);
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void set_data_in(bus_t *bus___0 , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 216
  p = ((bus_params_t *)bus___0->params)->part;
#line 219
  width = detect_data_width(comp);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < width)) {
#line 221
      goto while_break;
    }
    {
#line 222
    part_set_signal(p, comp->d[i], 0, 0);
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void setup_data(bus_t *bus___0 , uint32_t d , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 229
  p = ((bus_params_t *)bus___0->params)->part;
#line 232
  width = detect_data_width(comp);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < width)) {
#line 234
      goto while_break;
    }
    {
#line 235
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 238
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t **comp ) ;
#line 244 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 249
  i = 0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i < ((((bus_params_t *)bus___0->params)->chain)->parts)->len)) {
#line 249
      goto while_break;
    }
#line 250
    if ((unsigned long )((bus_params_t *)bus___0->params)->part == (unsigned long )*(((((bus_params_t *)bus___0->params)->chain)->parts)->parts + i)) {
#line 251
      goto while_break;
    }
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  tmp = gettext("Simple Solutions Zefant-XS3 Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 252
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 253
  return;
}
}
#line 259 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_prepare(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  component_t *comp ;

  {
  {
#line 262
  p = ((bus_params_t *)bus___0->params)->part;
#line 263
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 269
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 270
  chain_shift_instructions(chain___0);
#line 273
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 274
  setup_data(bus___0, (uint32_t )0, comp);
#line 275
  part_set_signal(p, comp->ncs, 1, 1);
#line 276
  part_set_signal(p, comp->nwe, 1, 1);
#line 277
  part_set_signal(p, comp->noe, 1, 1);
#line 278
  part_set_signal(p, comp->nrp, 1, 1);
#line 279
  part_set_signal(p, comp->nbyte, 1, 1);
#line 280
  part_set_signal(p, comp->sts, 0, 0);
#line 283
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 284
  setup_data(bus___0, (uint32_t )0, comp);
#line 285
  part_set_signal(p, comp->ncs, 1, 1);
#line 286
  part_set_signal(p, comp->nwe, 1, 1);
#line 287
  part_set_signal(p, comp->noe, 1, 1);
#line 288
  part_set_signal(p, comp->nlb, 1, 1);
#line 289
  part_set_signal(p, comp->nub, 1, 1);
#line 292
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 293
  setup_data(bus___0, (uint32_t )0, comp);
#line 294
  part_set_signal(p, comp->ncs, 1, 1);
#line 295
  part_set_signal(p, comp->nwe, 1, 1);
#line 296
  part_set_signal(p, comp->noe, 1, 1);
#line 297
  part_set_signal(p, comp->nlb, 1, 1);
#line 298
  part_set_signal(p, comp->nub, 1, 1);
#line 301
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 302
  part_set_signal(p, comp->si, 1, 0);
#line 303
  part_set_signal(p, comp->so, 0, 0);
#line 304
  part_set_signal(p, comp->sck, 1, 0);
#line 305
  part_set_signal(p, comp->ncs, 1, 1);
#line 308
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 309
  part_set_signal(p, comp->si, 1, 0);
#line 310
  part_set_signal(p, comp->so, 0, 0);
#line 311
  part_set_signal(p, comp->sck, 1, 0);
#line 312
  part_set_signal(p, comp->ncs, 1, 1);
#line 314
  chain_shift_data_registers(chain___0, 0);
#line 316
  part_set_instruction(p, "EXTEST");
#line 317
  chain_shift_instructions(chain___0);
  }
#line 318
  return;
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static uint8_t eeprom_shift_byte(chain_t *chain___0 , part_t *p , component_t *comp ,
                                 uint8_t byte ) 
{ 
  int pos ;
  uint8_t so_data ;
  int tmp ;

  {
#line 325
  so_data = (uint8_t )0;
#line 327
  pos = 7;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (pos >= 0)) {
#line 327
      goto while_break;
    }
    {
#line 329
    part_set_signal(p, comp->sck, 1, 0);
#line 331
    part_set_signal(p, comp->si, 1, ((int )byte >> pos) & 1);
#line 333
    chain_shift_data_registers(chain___0, 1);
#line 336
    part_set_signal(p, comp->sck, 1, 1);
#line 338
    chain_shift_data_registers(chain___0, 1);
#line 341
    tmp = part_get_signal(p, comp->so);
#line 341
    so_data = (uint8_t )((int )so_data | (int )((uint8_t )(tmp << pos)));
#line 327
    pos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (so_data);
}
}
#line 348 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void eeprom_disable_device(chain_t *chain___0 , part_t *p , component_t *comp ) 
{ 


  {
  {
#line 352
  part_set_signal(p, comp->sck, 1, 0);
#line 353
  chain_shift_data_registers(chain___0, 0);
#line 356
  part_set_signal(p, comp->ncs, 1, 1);
#line 357
  chain_shift_data_registers(chain___0, 0);
  }
#line 358
  return;
}
}
#line 364 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 367
  p = ((bus_params_t *)bus___0->params)->part;
#line 368
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 371
  cmd = (uint8_t )3;
#line 373
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 374
  if (! comp) {
    {
#line 375
    tmp = gettext("Address out of range\n");
#line 375
    printf((char const   */* __restrict  */)tmp);
#line 376
    last_address = adr;
    }
#line 377
    return;
  }
  {
#line 383
  if ((unsigned int )comp->ctype == 0U) {
#line 383
    goto case_0;
  }
#line 383
  if ((unsigned int )comp->ctype == 1U) {
#line 383
    goto case_0;
  }
#line 399
  if ((unsigned int )comp->ctype == 3U) {
#line 399
    goto case_3;
  }
#line 402
  if ((unsigned int )comp->ctype == 2U) {
#line 402
    goto case_2;
  }
#line 419
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 384
  part_set_signal(p, comp->ncs, 1, 0);
#line 385
  part_set_signal(p, comp->nwe, 1, 1);
#line 386
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 387
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 388
    part_set_signal(p, comp->nlb, 1, 0);
#line 389
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 392
  setup_address(bus___0, adr, comp);
#line 393
  set_data_in(bus___0, comp);
#line 395
  chain_shift_data_registers(chain___0, 0);
  }
#line 397
  goto switch_break;
  case_3: /* CIL Label */ 
#line 400
  cmd = (uint8_t )5;
  case_2: /* CIL Label */ 
  {
#line 404
  part_set_signal(p, comp->ncs, 1, 0);
#line 407
  eeprom_shift_byte(chain___0, p, comp, cmd);
  }
#line 409
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 411
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 413
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )(adr & 255U));
    }
  }
#line 416
  last_address = adr;
#line 417
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 420
  tmp___0 = gettext("Component type not supported\n");
#line 420
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 421
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 430 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 433
  p = ((bus_params_t *)bus___0->params)->part;
#line 434
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 436
  d = (uint32_t )0;
#line 440
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 441
  if (! comp) {
    {
#line 442
    tmp = gettext("Address out of range\n");
#line 442
    printf((char const   */* __restrict  */)tmp);
#line 443
    last_address = adr;
    }
#line 444
    return ((uint32_t )0);
  }
  {
#line 450
  if ((unsigned int )comp->ctype == 0U) {
#line 450
    goto case_0;
  }
#line 450
  if ((unsigned int )comp->ctype == 1U) {
#line 450
    goto case_0;
  }
#line 460
  if ((unsigned int )comp->ctype == 2U) {
#line 460
    goto case_2;
  }
#line 460
  if ((unsigned int )comp->ctype == 3U) {
#line 460
    goto case_2;
  }
#line 465
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 451
  setup_address(bus___0, adr, comp);
#line 452
  chain_shift_data_registers(chain___0, 1);
#line 454
  i = 0;
  }
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! ((unsigned int )i < area.width)) {
#line 454
      goto while_break;
    }
    {
#line 455
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 455
    d |= (uint32_t )(tmp___0 << i);
#line 454
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 462
  tmp___1 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
#line 462
  d = (uint32_t )tmp___1;
  }
#line 463
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 466
  tmp___2 = gettext("Component type not supported\n");
#line 466
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 467
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 470
  return (d);
}
}
#line 477 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 480
  p = ((bus_params_t *)bus___0->params)->part;
#line 481
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 483
  d = (uint32_t )0;
#line 488
  comp_bus_area(bus___0, last_address, & area, & comp);
  }
#line 489
  if (! comp) {
    {
#line 490
    tmp = gettext("Address out of range\n");
#line 490
    printf((char const   */* __restrict  */)tmp);
    }
#line 491
    return ((uint32_t )0);
  }
  {
#line 497
  if ((unsigned int )comp->ctype == 0U) {
#line 497
    goto case_0;
  }
#line 497
  if ((unsigned int )comp->ctype == 1U) {
#line 497
    goto case_0;
  }
#line 512
  if ((unsigned int )comp->ctype == 2U) {
#line 512
    goto case_2;
  }
#line 512
  if ((unsigned int )comp->ctype == 3U) {
#line 512
    goto case_2;
  }
#line 519
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 498
  part_set_signal(p, comp->ncs, 1, 1);
#line 499
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 500
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 501
    part_set_signal(p, comp->nlb, 1, 1);
#line 502
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 504
  chain_shift_data_registers(chain___0, 1);
#line 506
  i = 0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! ((unsigned int )i < area.width)) {
#line 506
      goto while_break;
    }
    {
#line 507
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 507
    d |= (uint32_t )(tmp___0 << i);
#line 506
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 514
  tmp___1 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
#line 514
  d = (uint32_t )tmp___1;
#line 515
  eeprom_disable_device(chain___0, p, comp);
  }
#line 517
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 520
  tmp___2 = gettext("Component type not supported\n");
#line 520
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 521
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 524
  return (d);
}
}
#line 531 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 534
  zefant_xs3_bus_read_start(bus___0, adr);
#line 535
  tmp = zefant_xs3_bus_read_end(bus___0);
  }
#line 535
  return (tmp);
}
}
#line 542 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  uint8_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 545
  p = ((bus_params_t *)bus___0->params)->part;
#line 546
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 549
  cmd = (uint8_t )2;
#line 551
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 552
  if (! comp) {
    {
#line 553
    tmp = gettext("Address out of range\n");
#line 553
    printf((char const   */* __restrict  */)tmp);
    }
#line 554
    return;
  }
  {
#line 559
  if ((unsigned int )comp->ctype == 0U) {
#line 559
    goto case_0;
  }
#line 559
  if ((unsigned int )comp->ctype == 1U) {
#line 559
    goto case_0;
  }
#line 585
  if ((unsigned int )comp->ctype == 3U) {
#line 585
    goto case_3;
  }
#line 588
  if ((unsigned int )comp->ctype == 2U) {
#line 588
    goto case_2;
  }
#line 639
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 560
  part_set_signal(p, comp->ncs, 1, 0);
#line 561
  part_set_signal(p, comp->nwe, 1, 1);
#line 562
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 563
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 564
    part_set_signal(p, comp->nlb, 1, 0);
#line 565
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 568
  setup_address(bus___0, adr, comp);
#line 569
  setup_data(bus___0, data, comp);
#line 571
  chain_shift_data_registers(chain___0, 0);
#line 573
  part_set_signal(p, comp->nwe, 1, 0);
#line 574
  chain_shift_data_registers(chain___0, 0);
#line 575
  part_set_signal(p, comp->nwe, 1, 1);
#line 576
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 577
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 578
    part_set_signal(p, comp->nlb, 1, 1);
#line 579
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 581
  chain_shift_data_registers(chain___0, 0);
  }
#line 583
  goto switch_break;
  case_3: /* CIL Label */ 
#line 586
  cmd = (uint8_t )1;
  case_2: /* CIL Label */ 
  {
#line 593
  part_set_signal(p, comp->ncs, 1, 0);
  }
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 597
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )5);
#line 596
    tmp___0 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
    }
#line 596
    if (! ((int )tmp___0 & 1)) {
#line 596
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 600
  eeprom_disable_device(chain___0, p, comp);
#line 607
  part_set_signal(p, comp->ncs, 1, 0);
#line 610
  eeprom_shift_byte(chain___0, p, comp, (uint8_t )6);
#line 612
  eeprom_disable_device(chain___0, p, comp);
#line 619
  part_set_signal(p, comp->ncs, 1, 0);
#line 623
  eeprom_shift_byte(chain___0, p, comp, cmd);
  }
#line 625
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 627
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 629
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )(adr & 255U));
    }
  }
  {
#line 633
  eeprom_shift_byte(chain___0, p, comp, (uint8_t )(data & 255U));
#line 635
  eeprom_disable_device(chain___0, p, comp);
  }
#line 637
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 640
  tmp___1 = gettext("Component type not supported\n");
#line 640
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 641
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 643
  return;
}
}
#line 650 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t **comp ) 
{ 


  {
#line 653
  if (adr < (uint32_t )(1 << 25)) {
#line 654
    area->description = "FLASH Component";
#line 655
    area->start = (uint32_t )0;
#line 656
    area->length = (uint64_t )(1 << 25);
#line 657
    area->width = 16U;
#line 658
    *comp = & ((bus_params_t *)bus___0->params)->flash;
  } else
#line 659
  if (adr < (uint32_t )((1 << 25) + (1 << 19))) {
#line 660
    area->description = "SO-DIMM RAM0 Component";
#line 661
    area->start = (uint32_t )(1 << 25);
#line 662
    area->length = (uint64_t )(1 << 19);
#line 663
    area->width = 16U;
#line 664
    *comp = & ((bus_params_t *)bus___0->params)->ram0;
  } else
#line 665
  if (adr < (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19))) {
#line 666
    area->description = "SO-DIMM RAM1 Component";
#line 667
    area->start = (uint32_t )((1 << 25) + (1 << 19));
#line 668
    area->length = (uint64_t )(1 << 19);
#line 669
    area->width = 16U;
#line 670
    *comp = & ((bus_params_t *)bus___0->params)->ram1;
  } else
#line 671
  if (adr < (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16))) {
#line 672
    area->description = "EEPROM Component";
#line 673
    area->start = (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19));
#line 674
    area->length = (uint64_t )(1 << 16);
#line 675
    area->width = 8U;
#line 676
    *comp = & ((bus_params_t *)bus___0->params)->eeprom;
  } else
#line 677
  if (adr < (uint32_t )(((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16)) + 3)) {
#line 678
    area->description = "EEPROM Component Status";
#line 679
    area->start = (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16));
#line 680
    area->length = (uint64_t )(1 << 16);
#line 681
    area->width = 8U;
#line 682
    *comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
  } else {
#line 684
    area->description = "Dummy";
#line 685
    area->start = (uint32_t )(((1 << 25) + 2 * (1 << 19)) + 2 * (1 << 16));
#line 686
    area->length = 4294967296UL;
#line 687
    area->width = 0U;
#line 688
    *comp = (component_t *)((void *)0);
  }
#line 691
  return (0);
}
}
#line 695 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t *comp ;
  int tmp ;

  {
  {
#line 700
  tmp = comp_bus_area(bus___0, adr, area, & comp);
  }
#line 700
  return (tmp);
}
}
#line 704 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 707
  free(bus___0->params);
#line 708
  free((void *)bus___0);
  }
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static int attach_sig(bus_t *bus___0 , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;

  {
  {
#line 714
  failed = 0;
#line 716
  *sig = part_find_signal(((bus_params_t *)bus___0->params)->part, (char const   *)id);
  }
#line 717
  if (! *sig) {
    {
#line 718
    tmp = gettext("signal \'%s\' not found\n");
#line 718
    printf((char const   */* __restrict  */)tmp, id);
#line 719
    failed = 1;
    }
  }
#line 722
  return (failed);
}
}
#line 725 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
static bus_t *zefant_xs3_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  component_t *comp ;
  int idx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;

  {
#line 729
  failed = 0;
#line 733
  if (! chain) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if (! chain->parts) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if ((chain->parts)->len <= chain->active_part) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if (chain->active_part < 0) {
#line 734
    return ((bus_t *)((void *)0));
  }
  {
#line 736
  tmp = malloc(sizeof(bus_t ));
#line 736
  bus___0 = (bus_t *)tmp;
  }
#line 737
  if (! bus___0) {
#line 738
    return ((bus_t *)((void *)0));
  }
  {
#line 740
  bus___0->driver = & zefant_xs3_bus;
#line 741
  bus___0->params = malloc(sizeof(bus_params_t ));
  }
#line 742
  if (! bus___0->params) {
    {
#line 743
    free((void *)bus___0);
    }
#line 744
    return ((bus_t *)((void *)0));
  }
  {
#line 747
  ((bus_params_t *)bus___0->params)->chain = chain;
#line 748
  ((bus_params_t *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 753
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 754
  comp->ctype = (ctype_t )1;
#line 755
  comp->cname = (char *)"FLASH";
#line 757
  tmp___0 = attach_sig(bus___0, & comp->a[0], (char *)"IO_V9");
#line 757
  failed |= tmp___0;
#line 758
  tmp___1 = attach_sig(bus___0, & comp->a[1], (char *)"IO_U10");
#line 758
  failed |= tmp___1;
#line 759
  tmp___2 = attach_sig(bus___0, & comp->a[2], (char *)"IO_V10");
#line 759
  failed |= tmp___2;
#line 760
  tmp___3 = attach_sig(bus___0, & comp->a[3], (char *)"IO_W10");
#line 760
  failed |= tmp___3;
#line 761
  tmp___4 = attach_sig(bus___0, & comp->a[4], (char *)"IO_Y10");
#line 761
  failed |= tmp___4;
#line 762
  tmp___5 = attach_sig(bus___0, & comp->a[5], (char *)"IO_W8");
#line 762
  failed |= tmp___5;
#line 763
  tmp___6 = attach_sig(bus___0, & comp->a[6], (char *)"IO_W9");
#line 763
  failed |= tmp___6;
#line 764
  tmp___7 = attach_sig(bus___0, & comp->a[7], (char *)"IO_V8");
#line 764
  failed |= tmp___7;
#line 765
  tmp___8 = attach_sig(bus___0, & comp->a[8], (char *)"IO_V6");
#line 765
  failed |= tmp___8;
#line 766
  tmp___9 = attach_sig(bus___0, & comp->a[9], (char *)"IO_AA8");
#line 766
  failed |= tmp___9;
#line 767
  tmp___10 = attach_sig(bus___0, & comp->a[10], (char *)"IO_AB8");
#line 767
  failed |= tmp___10;
#line 768
  tmp___11 = attach_sig(bus___0, & comp->a[11], (char *)"IO_U7");
#line 768
  failed |= tmp___11;
#line 769
  tmp___12 = attach_sig(bus___0, & comp->a[12], (char *)"IO_V7");
#line 769
  failed |= tmp___12;
#line 770
  tmp___13 = attach_sig(bus___0, & comp->a[13], (char *)"IO_U6");
#line 770
  failed |= tmp___13;
#line 771
  tmp___14 = attach_sig(bus___0, & comp->a[14], (char *)"IO_Y6");
#line 771
  failed |= tmp___14;
#line 772
  tmp___15 = attach_sig(bus___0, & comp->a[15], (char *)"IO_AB11");
#line 772
  failed |= tmp___15;
#line 773
  tmp___16 = attach_sig(bus___0, & comp->a[16], (char *)"IO_AB10");
#line 773
  failed |= tmp___16;
#line 774
  tmp___17 = attach_sig(bus___0, & comp->a[17], (char *)"IO_AA10");
#line 774
  failed |= tmp___17;
#line 775
  tmp___18 = attach_sig(bus___0, & comp->a[18], (char *)"IO_W6");
#line 775
  failed |= tmp___18;
#line 776
  tmp___19 = attach_sig(bus___0, & comp->a[19], (char *)"IO_AA6");
#line 776
  failed |= tmp___19;
#line 777
  tmp___20 = attach_sig(bus___0, & comp->a[20], (char *)"IO_U11");
#line 777
  failed |= tmp___20;
#line 778
  tmp___21 = attach_sig(bus___0, & comp->a[21], (char *)"IO_Y13");
#line 778
  failed |= tmp___21;
#line 779
  tmp___22 = attach_sig(bus___0, & comp->a[22], (char *)"IO_AB13");
#line 779
  failed |= tmp___22;
#line 780
  tmp___23 = attach_sig(bus___0, & comp->a[23], (char *)"IO_U13");
#line 780
  failed |= tmp___23;
#line 781
  tmp___24 = attach_sig(bus___0, & comp->a[24], (char *)"IO_AA13");
#line 781
  failed |= tmp___24;
#line 783
  tmp___25 = attach_sig(bus___0, & comp->d[0], (char *)"IO_AA14");
#line 783
  failed |= tmp___25;
#line 784
  tmp___26 = attach_sig(bus___0, & comp->d[1], (char *)"IO_AB14");
#line 784
  failed |= tmp___26;
#line 785
  tmp___27 = attach_sig(bus___0, & comp->d[2], (char *)"IO_U12");
#line 785
  failed |= tmp___27;
#line 786
  tmp___28 = attach_sig(bus___0, & comp->d[3], (char *)"IO_V12");
#line 786
  failed |= tmp___28;
#line 787
  tmp___29 = attach_sig(bus___0, & comp->d[4], (char *)"IO_W11");
#line 787
  failed |= tmp___29;
#line 788
  tmp___30 = attach_sig(bus___0, & comp->d[5], (char *)"IO_V11");
#line 788
  failed |= tmp___30;
#line 789
  tmp___31 = attach_sig(bus___0, & comp->d[6], (char *)"IO_AB9");
#line 789
  failed |= tmp___31;
#line 790
  tmp___32 = attach_sig(bus___0, & comp->d[7], (char *)"IO_AA9");
#line 790
  failed |= tmp___32;
#line 791
  tmp___33 = attach_sig(bus___0, & comp->d[8], (char *)"IO_U16");
#line 791
  failed |= tmp___33;
#line 792
  tmp___34 = attach_sig(bus___0, & comp->d[9], (char *)"IO_AB15");
#line 792
  failed |= tmp___34;
#line 793
  tmp___35 = attach_sig(bus___0, & comp->d[10], (char *)"IO_AA15");
#line 793
  failed |= tmp___35;
#line 794
  tmp___36 = attach_sig(bus___0, & comp->d[11], (char *)"IO_W14");
#line 794
  failed |= tmp___36;
#line 795
  tmp___37 = attach_sig(bus___0, & comp->d[12], (char *)"IO_V14");
#line 795
  failed |= tmp___37;
#line 796
  tmp___38 = attach_sig(bus___0, & comp->d[13], (char *)"IO_U14");
#line 796
  failed |= tmp___38;
#line 797
  tmp___39 = attach_sig(bus___0, & comp->d[14], (char *)"IO_W13");
#line 797
  failed |= tmp___39;
#line 798
  tmp___40 = attach_sig(bus___0, & comp->d[15], (char *)"IO_V13");
#line 798
  failed |= tmp___40;
#line 800
  tmp___41 = attach_sig(bus___0, & comp->nwe, (char *)"IO_Y17");
#line 800
  failed |= tmp___41;
#line 801
  tmp___42 = attach_sig(bus___0, & comp->noe, (char *)"IO_AA17");
#line 801
  failed |= tmp___42;
#line 802
  tmp___43 = attach_sig(bus___0, & comp->ncs, (char *)"IO_U17");
#line 802
  failed |= tmp___43;
#line 803
  comp->nlb = (signal_t *)((void *)0);
#line 804
  comp->nub = (signal_t *)((void *)0);
#line 806
  tmp___44 = attach_sig(bus___0, & comp->nrp, (char *)"IO_V16");
#line 806
  failed |= tmp___44;
#line 807
  tmp___45 = attach_sig(bus___0, & comp->nbyte, (char *)"IO_Y16");
#line 807
  failed |= tmp___45;
#line 808
  tmp___46 = attach_sig(bus___0, & comp->sts, (char *)"IO_W16");
#line 808
  failed |= tmp___46;
#line 810
  comp->si = (signal_t *)((void *)0);
#line 811
  comp->so = (signal_t *)((void *)0);
#line 812
  comp->sck = (signal_t *)((void *)0);
#line 817
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 818
  comp->ctype = (ctype_t )0;
#line 819
  comp->cname = (char *)"RAM0";
#line 821
  tmp___47 = attach_sig(bus___0, & comp->a[0], (char *)"IO_AA4");
#line 821
  failed |= tmp___47;
#line 822
  tmp___48 = attach_sig(bus___0, & comp->a[1], (char *)"IO_AB4");
#line 822
  failed |= tmp___48;
#line 823
  tmp___49 = attach_sig(bus___0, & comp->a[2], (char *)"IO_W5");
#line 823
  failed |= tmp___49;
#line 824
  tmp___50 = attach_sig(bus___0, & comp->a[3], (char *)"IO_Y3");
#line 824
  failed |= tmp___50;
#line 825
  tmp___51 = attach_sig(bus___0, & comp->a[4], (char *)"IO_Y1");
#line 825
  failed |= tmp___51;
#line 826
  tmp___52 = attach_sig(bus___0, & comp->a[5], (char *)"IO_M1");
#line 826
  failed |= tmp___52;
#line 827
  tmp___53 = attach_sig(bus___0, & comp->a[6], (char *)"IO_N2");
#line 827
  failed |= tmp___53;
#line 828
  tmp___54 = attach_sig(bus___0, & comp->a[7], (char *)"IO_L2");
#line 828
  failed |= tmp___54;
#line 829
  tmp___55 = attach_sig(bus___0, & comp->a[8], (char *)"IO_L1");
#line 829
  failed |= tmp___55;
#line 830
  tmp___56 = attach_sig(bus___0, & comp->a[9], (char *)"IO_K1");
#line 830
  failed |= tmp___56;
#line 831
  tmp___57 = attach_sig(bus___0, & comp->a[10], (char *)"IO_K3");
#line 831
  failed |= tmp___57;
#line 832
  tmp___58 = attach_sig(bus___0, & comp->a[11], (char *)"IO_L6");
#line 832
  failed |= tmp___58;
#line 833
  tmp___59 = attach_sig(bus___0, & comp->a[12], (char *)"IO_L4");
#line 833
  failed |= tmp___59;
#line 834
  tmp___60 = attach_sig(bus___0, & comp->a[13], (char *)"IO_L3");
#line 834
  failed |= tmp___60;
#line 835
  tmp___61 = attach_sig(bus___0, & comp->a[14], (char *)"IO_K4");
#line 835
  failed |= tmp___61;
#line 836
  tmp___62 = attach_sig(bus___0, & comp->a[15], (char *)"IO_AB5");
#line 836
  failed |= tmp___62;
#line 837
  tmp___63 = attach_sig(bus___0, & comp->a[16], (char *)"IO_AA5");
#line 837
  failed |= tmp___63;
#line 838
  tmp___64 = attach_sig(bus___0, & comp->a[17], (char *)"IO_Y5");
#line 838
  failed |= tmp___64;
#line 839
  comp->a[18] = (signal_t *)((void *)0);
#line 840
  comp->a[19] = (signal_t *)((void *)0);
#line 841
  comp->a[20] = (signal_t *)((void *)0);
#line 842
  comp->a[21] = (signal_t *)((void *)0);
#line 843
  comp->a[22] = (signal_t *)((void *)0);
#line 844
  comp->a[23] = (signal_t *)((void *)0);
#line 845
  comp->a[24] = (signal_t *)((void *)0);
#line 847
  tmp___65 = attach_sig(bus___0, & comp->d[0], (char *)"IO_W1");
#line 847
  failed |= tmp___65;
#line 848
  tmp___66 = attach_sig(bus___0, & comp->d[1], (char *)"IO_V5");
#line 848
  failed |= tmp___66;
#line 849
  tmp___67 = attach_sig(bus___0, & comp->d[2], (char *)"IO_V3");
#line 849
  failed |= tmp___67;
#line 850
  tmp___68 = attach_sig(bus___0, & comp->d[3], (char *)"IO_V1");
#line 850
  failed |= tmp___68;
#line 851
  tmp___69 = attach_sig(bus___0, & comp->d[4], (char *)"IO_N1");
#line 851
  failed |= tmp___69;
#line 852
  tmp___70 = attach_sig(bus___0, & comp->d[5], (char *)"IO_N3");
#line 852
  failed |= tmp___70;
#line 853
  tmp___71 = attach_sig(bus___0, & comp->d[6], (char *)"IO_M2");
#line 853
  failed |= tmp___71;
#line 854
  tmp___72 = attach_sig(bus___0, & comp->d[7], (char *)"IO_M5");
#line 854
  failed |= tmp___72;
#line 855
  tmp___73 = attach_sig(bus___0, & comp->d[8], (char *)"IO_M4");
#line 855
  failed |= tmp___73;
#line 856
  tmp___74 = attach_sig(bus___0, & comp->d[9], (char *)"IO_M6");
#line 856
  failed |= tmp___74;
#line 857
  tmp___75 = attach_sig(bus___0, & comp->d[10], (char *)"IO_L5");
#line 857
  failed |= tmp___75;
#line 858
  tmp___76 = attach_sig(bus___0, & comp->d[11], (char *)"IO_N4");
#line 858
  failed |= tmp___76;
#line 859
  tmp___77 = attach_sig(bus___0, & comp->d[12], (char *)"IO_T6");
#line 859
  failed |= tmp___77;
#line 860
  tmp___78 = attach_sig(bus___0, & comp->d[13], (char *)"IO_V2");
#line 860
  failed |= tmp___78;
#line 861
  tmp___79 = attach_sig(bus___0, & comp->d[14], (char *)"IO_V4");
#line 861
  failed |= tmp___79;
#line 862
  tmp___80 = attach_sig(bus___0, & comp->d[15], (char *)"IO_U5");
#line 862
  failed |= tmp___80;
#line 864
  tmp___81 = attach_sig(bus___0, & comp->ncs, (char *)"IO_W3");
#line 864
  failed |= tmp___81;
#line 865
  tmp___82 = attach_sig(bus___0, & comp->noe, (char *)"IO_Y2");
#line 865
  failed |= tmp___82;
#line 866
  tmp___83 = attach_sig(bus___0, & comp->nwe, (char *)"IO_M3");
#line 866
  failed |= tmp___83;
#line 867
  tmp___84 = attach_sig(bus___0, & comp->nlb, (char *)"IO_W2");
#line 867
  failed |= tmp___84;
#line 868
  tmp___85 = attach_sig(bus___0, & comp->nub, (char *)"IO_W4");
#line 868
  failed |= tmp___85;
#line 869
  comp->nrp = (signal_t *)((void *)0);
#line 870
  comp->nbyte = (signal_t *)((void *)0);
#line 871
  comp->sts = (signal_t *)((void *)0);
#line 873
  comp->si = (signal_t *)((void *)0);
#line 874
  comp->so = (signal_t *)((void *)0);
#line 875
  comp->sck = (signal_t *)((void *)0);
#line 880
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 881
  comp->ctype = (ctype_t )0;
#line 882
  comp->cname = (char *)"RAM1";
#line 884
  tmp___86 = attach_sig(bus___0, & comp->a[0], (char *)"IO_H5");
#line 884
  failed |= tmp___86;
#line 885
  tmp___87 = attach_sig(bus___0, & comp->a[1], (char *)"IO_F5");
#line 885
  failed |= tmp___87;
#line 886
  tmp___88 = attach_sig(bus___0, & comp->a[2], (char *)"IO_F2");
#line 886
  failed |= tmp___88;
#line 887
  tmp___89 = attach_sig(bus___0, & comp->a[3], (char *)"IO_D1");
#line 887
  failed |= tmp___89;
#line 888
  tmp___90 = attach_sig(bus___0, & comp->a[4], (char *)"IO_E1");
#line 888
  failed |= tmp___90;
#line 889
  tmp___91 = attach_sig(bus___0, & comp->a[5], (char *)"IO_F10");
#line 889
  failed |= tmp___91;
#line 890
  tmp___92 = attach_sig(bus___0, & comp->a[6], (char *)"IO_C7");
#line 890
  failed |= tmp___92;
#line 891
  tmp___93 = attach_sig(bus___0, & comp->a[7], (char *)"IO_C10");
#line 891
  failed |= tmp___93;
#line 892
  tmp___94 = attach_sig(bus___0, & comp->a[8], (char *)"IO_A10");
#line 892
  failed |= tmp___94;
#line 893
  tmp___95 = attach_sig(bus___0, & comp->a[9], (char *)"IO_B10");
#line 893
  failed |= tmp___95;
#line 894
  tmp___96 = attach_sig(bus___0, & comp->a[10], (char *)"IO_F11");
#line 894
  failed |= tmp___96;
#line 895
  tmp___97 = attach_sig(bus___0, & comp->a[11], (char *)"IO_A9");
#line 895
  failed |= tmp___97;
#line 896
  tmp___98 = attach_sig(bus___0, & comp->a[12], (char *)"IO_B9");
#line 896
  failed |= tmp___98;
#line 897
  tmp___99 = attach_sig(bus___0, & comp->a[13], (char *)"IO_B8");
#line 897
  failed |= tmp___99;
#line 898
  tmp___100 = attach_sig(bus___0, & comp->a[14], (char *)"IO_F9");
#line 898
  failed |= tmp___100;
#line 899
  tmp___101 = attach_sig(bus___0, & comp->a[15], (char *)"IO_F4");
#line 899
  failed |= tmp___101;
#line 900
  tmp___102 = attach_sig(bus___0, & comp->a[16], (char *)"IO_G6");
#line 900
  failed |= tmp___102;
#line 901
  tmp___103 = attach_sig(bus___0, & comp->a[17], (char *)"IO_G5");
#line 901
  failed |= tmp___103;
#line 902
  comp->a[18] = (signal_t *)((void *)0);
#line 903
  comp->a[19] = (signal_t *)((void *)0);
#line 904
  comp->a[20] = (signal_t *)((void *)0);
#line 905
  comp->a[21] = (signal_t *)((void *)0);
#line 906
  comp->a[22] = (signal_t *)((void *)0);
#line 907
  comp->a[23] = (signal_t *)((void *)0);
#line 908
  comp->a[24] = (signal_t *)((void *)0);
#line 910
  tmp___104 = attach_sig(bus___0, & comp->d[0], (char *)"IO_C1");
#line 910
  failed |= tmp___104;
#line 911
  tmp___105 = attach_sig(bus___0, & comp->d[1], (char *)"IO_E2");
#line 911
  failed |= tmp___105;
#line 912
  tmp___106 = attach_sig(bus___0, & comp->d[2], (char *)"IO_C2");
#line 912
  failed |= tmp___106;
#line 913
  tmp___107 = attach_sig(bus___0, & comp->d[3], (char *)"IO_C3");
#line 913
  failed |= tmp___107;
#line 914
  tmp___108 = attach_sig(bus___0, & comp->d[4], (char *)"IO_B5");
#line 914
  failed |= tmp___108;
#line 915
  tmp___109 = attach_sig(bus___0, & comp->d[5], (char *)"IO_A5");
#line 915
  failed |= tmp___109;
#line 916
  tmp___110 = attach_sig(bus___0, & comp->d[6], (char *)"IO_B6");
#line 916
  failed |= tmp___110;
#line 917
  tmp___111 = attach_sig(bus___0, & comp->d[7], (char *)"IO_D7");
#line 917
  failed |= tmp___111;
#line 918
  tmp___112 = attach_sig(bus___0, & comp->d[8], (char *)"IO_D9");
#line 918
  failed |= tmp___112;
#line 919
  tmp___113 = attach_sig(bus___0, & comp->d[9], (char *)"IO_E9");
#line 919
  failed |= tmp___113;
#line 920
  tmp___114 = attach_sig(bus___0, & comp->d[10], (char *)"IO_F7");
#line 920
  failed |= tmp___114;
#line 921
  tmp___115 = attach_sig(bus___0, & comp->d[11], (char *)"IO_E7");
#line 921
  failed |= tmp___115;
#line 922
  tmp___116 = attach_sig(bus___0, & comp->d[12], (char *)"IO_D5");
#line 922
  failed |= tmp___116;
#line 923
  tmp___117 = attach_sig(bus___0, & comp->d[13], (char *)"IO_C4");
#line 923
  failed |= tmp___117;
#line 924
  tmp___118 = attach_sig(bus___0, & comp->d[14], (char *)"IO_D3");
#line 924
  failed |= tmp___118;
#line 925
  tmp___119 = attach_sig(bus___0, & comp->d[15], (char *)"IO_D4");
#line 925
  failed |= tmp___119;
#line 927
  tmp___120 = attach_sig(bus___0, & comp->ncs, (char *)"IO_D2");
#line 927
  failed |= tmp___120;
#line 928
  tmp___121 = attach_sig(bus___0, & comp->noe, (char *)"IO_F3");
#line 928
  failed |= tmp___121;
#line 929
  tmp___122 = attach_sig(bus___0, & comp->nwe, (char *)"IO_E10");
#line 929
  failed |= tmp___122;
#line 930
  tmp___123 = attach_sig(bus___0, & comp->nlb, (char *)"IO_E4");
#line 930
  failed |= tmp___123;
#line 931
  tmp___124 = attach_sig(bus___0, & comp->nub, (char *)"IO_E3");
#line 931
  failed |= tmp___124;
#line 932
  comp->nrp = (signal_t *)((void *)0);
#line 933
  comp->nbyte = (signal_t *)((void *)0);
#line 934
  comp->sts = (signal_t *)((void *)0);
#line 936
  comp->si = (signal_t *)((void *)0);
#line 937
  comp->so = (signal_t *)((void *)0);
#line 938
  comp->sck = (signal_t *)((void *)0);
#line 943
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 944
  comp->ctype = (ctype_t )2;
#line 945
  comp->cname = (char *)"EEPROM";
#line 947
  tmp___125 = attach_sig(bus___0, & comp->si, (char *)"IO_H19");
#line 947
  failed |= tmp___125;
#line 948
  tmp___126 = attach_sig(bus___0, & comp->so, (char *)"IO_J21");
#line 948
  failed |= tmp___126;
#line 949
  tmp___127 = attach_sig(bus___0, & comp->sck, (char *)"IO_H21");
#line 949
  failed |= tmp___127;
#line 950
  tmp___128 = attach_sig(bus___0, & comp->ncs, (char *)"IO_K22");
#line 950
  failed |= tmp___128;
#line 952
  idx = 0;
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (idx < 25)) {
#line 952
      goto while_break;
    }
#line 953
    comp->a[idx] = (signal_t *)((void *)0);
#line 952
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  idx = 0;
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    if (! (idx < 16)) {
#line 954
      goto while_break___0;
    }
#line 955
    comp->d[idx] = (signal_t *)((void *)0);
#line 954
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 956
  comp->noe = (signal_t *)((void *)0);
#line 957
  comp->nwe = (signal_t *)((void *)0);
#line 958
  comp->nlb = (signal_t *)((void *)0);
#line 959
  comp->nub = (signal_t *)((void *)0);
#line 960
  comp->nrp = (signal_t *)((void *)0);
#line 961
  comp->nbyte = (signal_t *)((void *)0);
#line 962
  comp->sts = (signal_t *)((void *)0);
#line 968
  ((bus_params_t *)bus___0->params)->eeprom_status = ((bus_params_t *)bus___0->params)->eeprom;
#line 969
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 970
  comp->ctype = (ctype_t )3;
#line 971
  comp->cname = (char *)"EEPROM Status";
#line 974
  if (failed) {
    {
#line 975
    free(bus___0->params);
#line 976
    free((void *)bus___0);
    }
#line 977
    return ((bus_t *)((void *)0));
  }
#line 980
  return (bus___0);
}
}
#line 983 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/zefant-xs3.c"
struct bus_driver  const  zefant_xs3_bus  = 
#line 983
     {"zefant-xs3", "Simple Solutions Zefant-XS3 Board compatible bus driver via BSR",
    & zefant_xs3_bus_new, & zefant_xs3_bus_free, & zefant_xs3_bus_printinfo, & zefant_xs3_bus_prepare,
    & zefant_xs3_bus_area, & zefant_xs3_bus_read_start, & zefant_xs3_bus_read_next,
    & zefant_xs3_bus_read_end, & zefant_xs3_bus_read, & zefant_xs3_bus_write, (int (*)(bus_t *bus ))0};
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 52 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  tx4925_bus ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void select_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 69
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 71
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 0);
#line 72
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 73
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 76
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void unselect_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 84
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 86
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 1);
#line 87
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 88
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 89
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 90
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 91
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 92
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 93
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 94
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void setup_address___0(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  int addr_shift ;

  {
#line 108
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 109
  addr_shift = 1;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 20)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->addr[i], 1, (int )((a >> (i + addr_shift)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void set_data_in___0(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void setup_data___0(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void tx4925_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < ((((bus_params_t___0 *)bus___0->params)->chain)->parts)->len)) {
#line 140
      goto while_break;
    }
#line 141
    if ((unsigned long )((bus_params_t___0 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___0 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 142
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp = gettext("Toshiba TX4925 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 143
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void tx4925_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 149
  part_set_instruction(((bus_params_t___0 *)bus___0->params)->part, "EXTEST");
#line 150
  chain_shift_instructions(((bus_params_t___0 *)bus___0->params)->chain);
  }
#line 151
  return;
}
}
#line 153 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void tx4925_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 156
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 157
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 159
  select_flash(bus___0);
#line 160
  setup_address___0(bus___0, adr);
#line 161
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 164
  set_data_in___0(bus___0);
#line 166
  chain_shift_data_registers(chain___0, 0);
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 172
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 173
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 175
  d = (uint32_t )0;
#line 177
  setup_address___0(bus___0, adr);
#line 178
  chain_shift_data_registers(chain___0, 1);
#line 180
  i = 0;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < 16)) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 181
    d |= (uint32_t )(tmp << i);
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return (d);
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 189
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 190
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 192
  d = (uint32_t )0;
#line 194
  unselect_flash(bus___0);
#line 195
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 198
  chain_shift_data_registers(chain___0, 1);
#line 200
  i = 0;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 16)) {
#line 200
      goto while_break;
    }
    {
#line 201
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 201
    d |= (uint32_t )(tmp << i);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (d);
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static uint32_t tx4925_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 209
  tx4925_bus_read_start(bus___0, adr);
#line 210
  tmp = tx4925_bus_read_end(bus___0);
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void tx4925_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 216
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 217
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 219
  select_flash(bus___0);
#line 220
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 222
  setup_address___0(bus___0, adr);
#line 223
  setup_data___0(bus___0, data);
#line 225
  chain_shift_data_registers(chain___0, 0);
#line 227
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 0);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 230
  unselect_flash(bus___0);
#line 231
  chain_shift_data_registers(chain___0, 0);
  }
#line 232
  return;
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static int tx4925_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 237
  area->description = (char const   *)((void *)0);
#line 238
  area->start = 0U;
#line 239
  area->length = 4294967296UL;
#line 240
  area->width = 16U;
#line 242
  return (0);
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static void tx4925_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 248
  free(bus___0->params);
#line 249
  free((void *)bus___0);
  }
#line 250
  return;
}
}
#line 252
static bus_t *tx4925_bus_new(char **cmd_params___0 ) ;
#line 254 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
struct bus_driver  const  tx4925_bus  = 
#line 254
     {"tx4925", "Toshiba TX4925 compatible bus driver via BSR", & tx4925_bus_new, & tx4925_bus_free,
    & tx4925_bus_printinfo, & tx4925_bus_prepare, & tx4925_bus_area, & tx4925_bus_read_start,
    & tx4925_bus_read_next, & tx4925_bus_read_end, & tx4925_bus_read, & tx4925_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 271 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/tx4925.c"
static bus_t *tx4925_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 277
  failed = 0;
#line 279
  if (! chain) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if (! chain->parts) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if ((chain->parts)->len <= chain->active_part) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if (chain->active_part < 0) {
#line 280
    return ((bus_t *)((void *)0));
  }
  {
#line 282
  tmp = malloc(sizeof(bus_t ));
#line 282
  bus___0 = (bus_t *)tmp;
  }
#line 283
  if (! bus___0) {
#line 284
    return ((bus_t *)((void *)0));
  }
  {
#line 286
  bus___0->driver = & tx4925_bus;
#line 287
  bus___0->params = malloc(sizeof(bus_params_t___0 ));
  }
#line 288
  if (! bus___0->params) {
    {
#line 289
    free((void *)bus___0);
    }
#line 290
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  ((bus_params_t___0 *)bus___0->params)->chain = chain;
#line 294
  ((bus_params_t___0 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 296
  ((bus_params_t___0 *)bus___0->params)->oe = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                               "OE");
  }
#line 297
  if (! ((bus_params_t___0 *)bus___0->params)->oe) {
    {
#line 298
    tmp___0 = gettext("signal \'%s\' not found\n");
#line 298
    printf((char const   */* __restrict  */)tmp___0, "OE");
#line 299
    failed = 1;
    }
  }
  {
#line 302
  ((bus_params_t___0 *)bus___0->params)->swe = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                "SWE");
  }
#line 303
  if (! ((bus_params_t___0 *)bus___0->params)->swe) {
    {
#line 304
    tmp___1 = gettext("signal \'%s\' not found\n");
#line 304
    printf((char const   */* __restrict  */)tmp___1, "SWE");
#line 305
    failed = 1;
    }
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 4)) {
#line 308
      goto while_break;
    }
    {
#line 309
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ROMCE_%d",
            i);
#line 310
    ((bus_params_t___0 *)bus___0->params)->romce[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 311
    if (! ((bus_params_t___0 *)bus___0->params)->romce[i]) {
      {
#line 312
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 312
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 313
      failed = 1;
      }
#line 314
      goto while_break;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (i < 4)) {
#line 318
      goto while_break___0;
    }
    {
#line 319
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDCS_%d",
            i);
#line 320
    ((bus_params_t___0 *)bus___0->params)->sdcs[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 321
    if (! ((bus_params_t___0 *)bus___0->params)->sdcs[i]) {
      {
#line 322
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 322
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 323
      failed = 1;
      }
#line 324
      goto while_break___0;
    }
#line 318
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if (! (i < 20)) {
#line 328
      goto while_break___1;
    }
    {
#line 329
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR_%d",
            i);
#line 330
    ((bus_params_t___0 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 331
    if (! ((bus_params_t___0 *)bus___0->params)->addr[i]) {
      {
#line 332
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 332
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 333
      failed = 1;
      }
#line 334
      goto while_break___1;
    }
#line 328
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 338
  i = 0;
  {
#line 338
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 338
    if (! (i < 16)) {
#line 338
      goto while_break___2;
    }
    {
#line 339
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA_%d",
            i);
#line 340
    ((bus_params_t___0 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 341
    if (! ((bus_params_t___0 *)bus___0->params)->data[i]) {
      {
#line 342
      tmp___5 = gettext("signal \'%s\' not found\n");
#line 342
      printf((char const   */* __restrict  */)tmp___5, buff);
#line 343
      failed = 1;
      }
#line 344
      goto while_break___2;
    }
#line 338
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 348
  if (failed) {
    {
#line 349
    free(bus___0->params);
#line 350
    free((void *)bus___0);
    }
#line 351
    return ((bus_t *)((void *)0));
  }
#line 354
  return (bus___0);
}
}
#line 51 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  slsup3_bus ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
int databusio[16]  = 
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
  {      94,      96,      98,      100, 
        102,      104,      106,      113, 
        95,      97,      99,      101, 
        103,      105,      107,      114};
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
int addrbusio[20]  = 
#line 42
  {      93,      88,      87,      86, 
        85,      84,      83,      63, 
        64,      65,      66,      67, 
        68,      74,      75,      76, 
        77,      82,      81,      78};
#line 90
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 92 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void setup_address___1(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 96
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 99
  slsup3_bus_area(bus___0, a, & area);
  }
#line 100
  if (area.width > 16U) {
#line 101
    return;
  }
  {
#line 103
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrs, 1, (int )(a & 1U));
  }
#line 106
  if (a >= 0U) {
#line 106
    if ((unsigned long )a < 2097152UL) {
#line 107
      i = 0;
      {
#line 107
      while (1) {
        while_continue: /* CIL Label */ ;
#line 107
        if (! (i < 20)) {
#line 107
          goto while_break;
        }
        {
#line 108
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (i + 1)) & 1U));
#line 107
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 109
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 0);
#line 110
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[15], 1, (int )(a & 1U));
      }
    } else {
      {
#line 112
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
      }
    }
  } else {
    {
#line 112
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
    }
  }
#line 115
  if (a >= 2097152U) {
#line 115
    if (a < 2228224U) {
      {
#line 116
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 0);
#line 117
      i = 0;
      }
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! (i < 20)) {
#line 117
          goto while_break___0;
        }
        {
#line 118
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (((unsigned int )i + area.width / 8U) - 1U)) & 1U));
#line 117
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 120
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
      }
    }
  } else {
    {
#line 120
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void set_data_in___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 129
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 132
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 133
  if (area.width > 16U) {
#line 134
    return;
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned int )i < area.width)) {
#line 136
      goto while_break;
    }
    {
#line 137
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 0, 0);
#line 136
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void setup_data___1(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 144
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 147
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 148
  if (area.width > 16U) {
#line 149
    return;
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned int )i < area.width)) {
#line 151
      goto while_break;
    }
    {
#line 152
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 1, (int )((d >> i) & 1U));
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 155 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static uint32_t get_data(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 160
  d = (uint32_t )0;
#line 161
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 163
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 164
  if (area.width > 16U) {
#line 165
    return ((uint32_t )0);
  }
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((unsigned int )i < area.width)) {
#line 167
      goto while_break;
    }
    {
#line 168
    tmp = part_get_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i]);
#line 168
    d |= (uint32_t )(tmp << i);
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (d);
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void slsup3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < ((((bus_params_t___1 *)bus___0->params)->chain)->parts)->len)) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )((bus_params_t___1 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___1 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 180
      goto while_break;
    }
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  tmp = gettext("SLS UP3 bus driver via BSR (JTAG part No. %d)\n");
#line 181
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 182
  return;
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void slsup3_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 187
  part_set_instruction(((bus_params_t___1 *)bus___0->params)->part, "EXTEST");
#line 188
  chain_shift_instructions(((bus_params_t___1 *)bus___0->params)->chain);
  }
#line 189
  return;
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void slsup3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 194
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 196
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
#line 198
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 0);
#line 200
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 205
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 206
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 1);
#line 208
  setup_address___1(bus___0, adr);
  }
#line 210
  if (adr >= 3145728U) {
#line 210
    if (adr < 4194304U) {
      {
#line 211
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 212
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 213
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 216
  set_data_in___1(bus___0, adr);
#line 218
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
  }
#line 220
  return;
}
}
#line 222 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  part_t *p ;

  {
  {
#line 227
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 229
  setup_address___1(bus___0, adr);
  }
#line 231
  if (adr >= 3145728U) {
#line 231
    if (adr < 4194304U) {
      {
#line 232
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 233
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 234
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 237
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 1);
#line 239
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
#line 241
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
  }
#line 243
  return (d);
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t d ;

  {
#line 249
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 252
  if (((bus_params_t___1 *)bus___0->params)->last_adr >= 3145728U) {
#line 252
    if (((bus_params_t___1 *)bus___0->params)->last_adr < 4194304U) {
      {
#line 253
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 254
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 255
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 258
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 260
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 1);
#line 262
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
  }
#line 264
  return (d);
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static uint32_t slsup3_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 272
  slsup3_bus_read_start(bus___0, adr);
#line 273
  d = slsup3_bus_read_end(bus___0);
  }
#line 274
  return (d);
}
}
#line 277 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void slsup3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 280
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 281
  chain___0 = ((bus_params_t___1 *)bus___0->params)->chain;
#line 283
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 284
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 287
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 288
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 290
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 291
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 0);
#line 293
  setup_address___1(bus___0, adr);
#line 294
  setup_data___1(bus___0, adr, data);
  }
#line 296
  if (adr >= 3145728U) {
#line 296
    if (adr < 4194304U) {
      {
#line 297
      chain_shift_data_registers(chain___0, 0);
#line 298
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 299
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 300
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 301
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
      }
    } else {
      {
#line 304
      chain_shift_data_registers(chain___0, 0);
#line 306
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 307
      chain_shift_data_registers(chain___0, 0);
#line 308
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 309
      chain_shift_data_registers(chain___0, 0);
      }
    }
  } else {
    {
#line 304
    chain_shift_data_registers(chain___0, 0);
#line 306
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 307
    chain_shift_data_registers(chain___0, 0);
#line 308
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 309
    chain_shift_data_registers(chain___0, 0);
    }
  }
#line 311
  return;
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 316
  if (adr >= 0U) {
#line 316
    if ((unsigned long )adr < 2097152UL) {
#line 317
      area->description = "Flash Memory (2 MByte) byte mode";
#line 318
      area->start = 0U;
#line 319
      area->length = 2097152UL;
#line 320
      area->width = 8U;
#line 322
      return (0);
    }
  }
#line 325
  if (adr >= 2097152U) {
#line 325
    if (adr < 2228224U) {
#line 326
      area->description = "SRAM 128KByte (64K x 16)";
#line 327
      area->start = (uint32_t )2097152;
#line 328
      area->length = (uint64_t )131072;
#line 329
      area->width = 16U;
#line 331
      return (0);
    }
  }
#line 334
  if (adr >= 3145728U) {
#line 334
    if (adr < 4194304U) {
#line 335
      area->description = "LCD Display (RS select by A0)";
#line 336
      area->start = (uint32_t )3145728;
#line 337
      area->length = (uint64_t )1048576;
#line 338
      area->width = 8U;
#line 340
      return (0);
    }
  }
#line 343
  area->description = (char const   *)((void *)0);
#line 344
  area->start = 4194304U;
#line 345
  area->length = 4290772992UL;
#line 346
  area->width = 0U;
#line 348
  return (0);
}
}
#line 351 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static void slsup3_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 354
  free(bus___0->params);
#line 355
  free((void *)bus___0);
  }
#line 356
  return;
}
}
#line 358 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
static bus_t *slsup3_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 364
  failed = 0;
#line 367
  if (! chain) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if (! chain->parts) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if ((chain->parts)->len <= chain->active_part) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if (chain->active_part < 0) {
#line 368
    return ((bus_t *)((void *)0));
  }
  {
#line 370
  tmp = malloc(sizeof(bus_t ));
#line 370
  bus___0 = (bus_t *)tmp;
  }
#line 371
  if (! bus___0) {
#line 372
    return ((bus_t *)((void *)0));
  }
  {
#line 374
  bus___0->driver = & slsup3_bus;
#line 375
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___1 ));
  }
#line 376
  if (! bus___0->params) {
    {
#line 377
    free((void *)bus___0);
    }
#line 378
    return ((bus_t *)((void *)0));
  }
#line 381
  ((bus_params_t___1 *)bus___0->params)->chain = chain;
#line 382
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 382
  ((bus_params_t___1 *)bus___0->params)->part = part___0;
#line 384
  i = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (i < 20)) {
#line 384
      goto while_break;
    }
    {
#line 385
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            addrbusio[i]);
#line 386
    ((bus_params_t___1 *)bus___0->params)->ad[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 387
    if (! ((bus_params_t___1 *)bus___0->params)->ad[i]) {
      {
#line 388
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 388
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 389
      failed = 1;
      }
#line 390
      goto while_break;
    }
#line 384
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (i < 16)) {
#line 394
      goto while_break___0;
    }
    {
#line 395
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            databusio[i]);
#line 396
    ((bus_params_t___1 *)bus___0->params)->dq[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 397
    if (! ((bus_params_t___1 *)bus___0->params)->dq[i]) {
      {
#line 398
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 398
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 399
      failed = 1;
      }
#line 400
      goto while_break___0;
    }
#line 394
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 404
  ((bus_params_t___1 *)bus___0->params)->noe = part_find_signal(part___0, "IO118");
  }
#line 405
  if (! ((bus_params_t___1 *)bus___0->params)->noe) {
    {
#line 406
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 406
    printf((char const   */* __restrict  */)tmp___2, "nOE");
#line 407
    failed = 1;
    }
  }
  {
#line 410
  ((bus_params_t___1 *)bus___0->params)->nsrce = part_find_signal(part___0, "IO116");
  }
#line 411
  if (! ((bus_params_t___1 *)bus___0->params)->nsrce) {
    {
#line 412
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 412
    printf((char const   */* __restrict  */)tmp___3, "nSRce");
#line 413
    failed = 1;
    }
  }
  {
#line 416
  ((bus_params_t___1 *)bus___0->params)->nsdce = part_find_signal(part___0, "IO119");
  }
#line 417
  if (! ((bus_params_t___1 *)bus___0->params)->nsdce) {
    {
#line 418
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 418
    printf((char const   */* __restrict  */)tmp___4, "nSDce");
#line 419
    failed = 1;
    }
  }
  {
#line 422
  ((bus_params_t___1 *)bus___0->params)->nflce = part_find_signal(part___0, "IO117");
  }
#line 423
  if (! ((bus_params_t___1 *)bus___0->params)->nflce) {
    {
#line 424
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 424
    printf((char const   */* __restrict  */)tmp___5, "nFLce");
#line 425
    failed = 1;
    }
  }
  {
#line 428
  ((bus_params_t___1 *)bus___0->params)->nflbyte = part_find_signal(part___0, "IO115");
  }
#line 429
  if (! ((bus_params_t___1 *)bus___0->params)->nflbyte) {
    {
#line 430
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 430
    printf((char const   */* __restrict  */)tmp___6, "nFLbyte");
#line 431
    failed = 1;
    }
  }
  {
#line 434
  ((bus_params_t___1 *)bus___0->params)->nflby = part_find_signal(part___0, "IO80");
  }
#line 435
  if (! ((bus_params_t___1 *)bus___0->params)->nflby) {
    {
#line 436
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 436
    printf((char const   */* __restrict  */)tmp___7, "nFLby");
#line 437
    failed = 1;
    }
  }
  {
#line 440
  ((bus_params_t___1 *)bus___0->params)->nwe = part_find_signal(part___0, "IO79");
  }
#line 441
  if (! ((bus_params_t___1 *)bus___0->params)->nwe) {
    {
#line 442
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 442
    printf((char const   */* __restrict  */)tmp___8, "nWE");
#line 443
    failed = 1;
    }
  }
  {
#line 446
  ((bus_params_t___1 *)bus___0->params)->sdclk = part_find_signal(part___0, "IO11");
  }
#line 447
  if (! ((bus_params_t___1 *)bus___0->params)->sdclk) {
    {
#line 448
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 448
    printf((char const   */* __restrict  */)tmp___9, "SDclk");
#line 449
    failed = 1;
    }
  }
  {
#line 452
  ((bus_params_t___1 *)bus___0->params)->lcde = part_find_signal(part___0, "IO50");
  }
#line 453
  if (! ((bus_params_t___1 *)bus___0->params)->lcde) {
    {
#line 454
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 454
    printf((char const   */* __restrict  */)tmp___10, "LCDe");
#line 455
    failed = 1;
    }
  }
  {
#line 458
  ((bus_params_t___1 *)bus___0->params)->lcdrs = part_find_signal(part___0, "IO108");
  }
#line 459
  if (! ((bus_params_t___1 *)bus___0->params)->lcdrs) {
    {
#line 460
    tmp___11 = gettext("signal \'%s\' not found\n");
#line 460
    printf((char const   */* __restrict  */)tmp___11, "LCDrs");
#line 461
    failed = 1;
    }
  }
  {
#line 464
  ((bus_params_t___1 *)bus___0->params)->lcdrw = part_find_signal(part___0, "IO73");
  }
#line 465
  if (! ((bus_params_t___1 *)bus___0->params)->lcdrw) {
    {
#line 466
    tmp___12 = gettext("signal \'%s\' not found\n");
#line 466
    printf((char const   */* __restrict  */)tmp___12, "LCDrw");
#line 467
    failed = 1;
    }
  }
#line 470
  if (failed) {
    {
#line 471
    free(bus___0->params);
#line 472
    free((void *)bus___0);
    }
#line 473
    return ((bus_t *)((void *)0));
  }
#line 476
  return (bus___0);
}
}
#line 479 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/slsup3.c"
struct bus_driver  const  slsup3_bus  = 
#line 479
     {"slsup3", "SLS UP3 compatible bus driver via BSR", & slsup3_bus_new, & slsup3_bus_free,
    & slsup3_bus_printinfo, & slsup3_bus_prepare, & slsup3_bus_area, & slsup3_bus_read_start,
    & slsup3_bus_read_next, & slsup3_bus_read_end, & slsup3_bus_read, & slsup3_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 54 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  sharc_21065L_bus ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void setup_address___2(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 72
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < 19)) {
#line 74
      goto while_break;
    }
    {
#line 75
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 74
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 78
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 81 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void set_data_in___2(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 84
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 87
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 0, 0);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void setup_data___2(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 97
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 100
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 102
  i = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned int )i < area.width)) {
#line 102
      goto while_break;
    }
    {
#line 103
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 102
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void sharc_21065L_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < ((((bus_params_t___2 *)bus___0->params)->chain)->parts)->len)) {
#line 111
      goto while_break;
    }
#line 112
    if ((unsigned long )((bus_params_t___2 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___2 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 113
      goto while_break;
    }
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp = gettext("Analog Device\'s SHARC 21065L compatible bus driver via BSR (JTAG part No. %d)\n");
#line 114
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void sharc_21065L_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 119
  part_set_instruction(((bus_params_t___2 *)bus___0->params)->part, "EXTEST");
#line 120
  chain_shift_instructions(((bus_params_t___2 *)bus___0->params)->chain);
  }
#line 121
  return;
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void sharc_21065L_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;

  {
#line 126
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 127
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 129
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 130
  if (adr >= 524288U) {
#line 131
    return;
  }
  {
#line 134
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 135
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 136
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 0);
#line 138
  setup_address___2(bus___0, adr);
#line 139
  set_data_in___2(bus___0, adr);
#line 141
  chain_shift_data_registers(chain___0, 0);
  }
#line 142
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t d ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 147
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 148
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 152
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 154
  if (adr < 524288U) {
    {
#line 158
    sharc_21065L_bus_area(bus___0, adr, & area);
#line 161
    setup_address___2(bus___0, adr);
#line 162
    chain_shift_data_registers(chain___0, 1);
#line 164
    d = (uint32_t )0;
#line 165
    i = 0;
    }
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 165
      if (! ((unsigned int )i < area.width)) {
#line 165
        goto while_break;
      }
      {
#line 166
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 166
      d |= (uint32_t )(tmp << i);
#line 165
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 168
    return (d);
  }
#line 170
  return ((uint32_t )0);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 176
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 177
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 179
  if (((bus_params_t___2 *)bus___0->params)->last_adr < 524288U) {
    {
#line 181
    d = (uint32_t )0;
#line 184
    sharc_21065L_bus_area(bus___0, ((bus_params_t___2 *)bus___0->params)->last_adr,
                          & area);
#line 187
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 1);
#line 188
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 189
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 191
    chain_shift_data_registers(chain___0, 1);
#line 193
    i = 0;
    }
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 193
      if (! ((unsigned int )i < area.width)) {
#line 193
        goto while_break;
      }
      {
#line 194
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 194
      d |= (uint32_t )(tmp << i);
#line 193
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 196
    return (d);
  }
#line 199
  return ((uint32_t )0);
}
}
#line 202 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 204
  sharc_21065L_bus_read_start(bus___0, adr);
#line 205
  tmp = sharc_21065L_bus_read_end(bus___0);
  }
#line 205
  return (tmp);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void sharc_21065L_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
#line 212
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 213
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 215
  if (adr >= 524288U) {
#line 216
    return;
  }
  {
#line 219
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 220
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 223
  setup_address___2(bus___0, adr);
#line 224
  setup_data___2(bus___0, adr, data);
#line 226
  chain_shift_data_registers(chain___0, 0);
#line 228
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 0);
#line 229
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 231
  chain_shift_data_registers(chain___0, 0);
  }
#line 232
  return;
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 238
  if (adr < 524288U) {
#line 239
    area->description = "Boot Memory Select";
#line 240
    area->start = 0U;
#line 241
    area->length = 524288UL;
#line 242
    area->width = 8U;
#line 244
    return (0);
  }
#line 247
  area->description = (char const   *)((void *)0);
#line 248
  area->start = 4294967295U;
#line 249
  area->length = 524288UL;
#line 250
  area->width = 0U;
#line 251
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static void sharc_21065L_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 257
  free(bus___0->params);
#line 258
  free((void *)bus___0);
  }
#line 259
  return;
}
}
#line 261
static bus_t *sharc_21065L_bus_new(char **cmd_params___0 ) ;
#line 263 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
struct bus_driver  const  sharc_21065L_bus  = 
#line 263
     {"SHARC_21065L", "SHARC_21065L compatible bus driver via BSR", & sharc_21065L_bus_new,
    & sharc_21065L_bus_free, & sharc_21065L_bus_printinfo, & sharc_21065L_bus_prepare,
    & sharc_21065L_bus_area, & sharc_21065L_bus_read_start, & sharc_21065L_bus_read_next,
    & sharc_21065L_bus_read_end, & sharc_21065L_bus_read, & sharc_21065L_bus_write,
    (int (*)(bus_t *bus ))0};
#line 279 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sharc21065l.c"
static bus_t *sharc_21065L_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 284
  failed = 0;
#line 286
  if (! chain) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (! chain->parts) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if ((chain->parts)->len <= chain->active_part) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (chain->active_part < 0) {
#line 287
    return ((bus_t *)((void *)0));
  }
  {
#line 289
  tmp = malloc(sizeof(bus_t ));
#line 289
  bus___0 = (bus_t *)tmp;
  }
#line 290
  if (! bus___0) {
#line 291
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  bus___0->driver = & sharc_21065L_bus;
#line 294
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___2 ));
  }
#line 295
  if (! bus___0->params) {
    {
#line 296
    free((void *)bus___0);
    }
#line 297
    return ((bus_t *)((void *)0));
  }
#line 300
  ((bus_params_t___2 *)bus___0->params)->chain = chain;
#line 301
  ((bus_params_t___2 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 19)) {
#line 303
      goto while_break;
    }
    {
#line 304
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 305
    ((bus_params_t___2 *)bus___0->params)->ma[i] = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 306
    if (! ((bus_params_t___2 *)bus___0->params)->ma[i]) {
      {
#line 307
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 307
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 308
      failed = 1;
      }
#line 309
      goto while_break;
    }
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < 8)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 314
    ((bus_params_t___2 *)bus___0->params)->md[i] = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 315
    if (! ((bus_params_t___2 *)bus___0->params)->md[i]) {
      {
#line 316
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 316
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 317
      failed = 1;
      }
#line 318
      goto while_break___0;
    }
#line 312
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 322
  ((bus_params_t___2 *)bus___0->params)->bms = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "BMS_B");
  }
#line 323
  if (! ((bus_params_t___2 *)bus___0->params)->bms) {
    {
#line 324
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 324
    printf((char const   */* __restrict  */)tmp___2, "BMS_B");
#line 325
    failed = 1;
    }
  }
  {
#line 327
  ((bus_params_t___2 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "WR_B");
  }
#line 328
  if (! ((bus_params_t___2 *)bus___0->params)->nwe) {
    {
#line 329
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 329
    printf((char const   */* __restrict  */)tmp___3, "WR_B");
#line 330
    failed = 1;
    }
  }
  {
#line 332
  ((bus_params_t___2 *)bus___0->params)->noe = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "RD_B");
  }
#line 333
  if (! ((bus_params_t___2 *)bus___0->params)->noe) {
    {
#line 334
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___4, "RD_B");
#line 335
    failed = 1;
    }
  }
#line 339
  if (failed) {
    {
#line 340
    free(bus___0->params);
#line 341
    free((void *)bus___0);
    }
#line 342
    return ((bus_t *)((void *)0));
  }
#line 345
  return (bus___0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  sh7751r_bus ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void setup_address___3(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 65
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < 26)) {
#line 67
      goto while_break;
    }
    {
#line 68
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 67
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void set_data_in___3(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 75
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 32)) {
#line 77
      goto while_break;
    }
    {
#line 78
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 0, 0);
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void setup_data___3(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 85
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 32)) {
#line 87
      goto while_break;
    }
    {
#line 88
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void sh7751r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < ((((bus_params_t___3 *)bus___0->params)->chain)->parts)->len)) {
#line 96
      goto while_break;
    }
#line 97
    if ((unsigned long )((bus_params_t___3 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___3 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 98
      goto while_break;
    }
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  tmp = gettext("Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 99
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 100
  return;
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void sh7751r_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 106
  part_set_instruction(((bus_params_t___3 *)bus___0->params)->part, "EXTEST");
#line 107
  chain_shift_instructions(((bus_params_t___3 *)bus___0->params)->chain);
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void sh7751r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 113
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 8)) {
#line 117
      goto while_break;
    }
#line 118
    cs[i] = 1;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  cs[(adr & 469762048U) >> 26] = 0;
#line 121
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 122
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 123
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 124
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 125
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 126
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 127
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 128
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 1);
#line 129
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 130
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 131
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 0);
#line 135
  setup_address___3(bus___0, adr);
#line 136
  set_data_in___3(bus___0);
#line 137
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 0);
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 143
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 145
  d = (uint32_t )0;
#line 147
  setup_address___3(bus___0, adr);
#line 148
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 1);
#line 150
  i = 0;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < 32)) {
#line 150
      goto while_break;
    }
    {
#line 151
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 151
    d |= (uint32_t )(tmp << i);
#line 150
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (d);
}
}
#line 156 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 159
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 162
  d = (uint32_t )0;
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < 8)) {
#line 164
      goto while_break;
    }
#line 165
    cs[i] = 1;
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 168
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 169
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 170
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 171
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 172
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 173
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 175
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 176
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 1);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < 32)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 179
    d |= (uint32_t )(tmp << i);
#line 178
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  return (d);
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 187
  sh7751r_bus_read_start(bus___0, adr);
#line 188
  tmp = sh7751r_bus_read_end(bus___0);
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void sh7751r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 194
  chain___0 = ((bus_params_t___3 *)bus___0->params)->chain;
#line 195
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 199
  i = 0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < 8)) {
#line 199
      goto while_break;
    }
#line 200
    cs[i] = 1;
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  cs[(adr & 469762048U) >> 26] = 0;
#line 203
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 204
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 205
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 206
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 207
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 208
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 209
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 211
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 0);
#line 212
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 213
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 216
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 218
  setup_address___3(bus___0, adr);
#line 219
  setup_data___3(bus___0, data);
#line 220
  chain_shift_data_registers(chain___0, 0);
#line 222
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 0);
#line 223
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 0);
#line 224
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 0);
#line 225
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 0);
#line 227
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 231
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static int sh7751r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static void sh7751r_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *sh7751r_bus_new(char **cmd_params___0 ) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
struct bus_driver  const  sh7751r_bus  = 
#line 257
     {"sh7751r", "Hitachi SH7751R compatible bus driver via BSR", & sh7751r_bus_new,
    & sh7751r_bus_free, & sh7751r_bus_printinfo, & sh7751r_bus_prepare, & sh7751r_bus_area,
    & sh7751r_bus_read_start, & sh7751r_bus_read_next, & sh7751r_bus_read_end, & sh7751r_bus_read,
    & sh7751r_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 273 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7751r.c"
static bus_t *sh7751r_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 279
  failed = 0;
#line 281
  if (! chain) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if (! chain->parts) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if ((chain->parts)->len <= chain->active_part) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if (chain->active_part < 0) {
#line 282
    return ((bus_t *)((void *)0));
  }
  {
#line 284
  tmp = malloc(sizeof(bus_t ));
#line 284
  bus___0 = (bus_t *)tmp;
  }
#line 285
  if (! bus___0) {
#line 286
    return ((bus_t *)((void *)0));
  }
  {
#line 288
  bus___0->driver = & sh7751r_bus;
#line 289
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___3 ));
  }
#line 290
  if (! bus___0->params) {
    {
#line 291
    free((void *)bus___0);
    }
#line 292
    return ((bus_t *)((void *)0));
  }
#line 295
  ((bus_params_t___3 *)bus___0->params)->chain = chain;
#line 296
  ((bus_params_t___3 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 298
  i = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < 26)) {
#line 298
      goto while_break;
    }
    {
#line 299
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 300
    ((bus_params_t___3 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 301
    if (! ((bus_params_t___3 *)bus___0->params)->a[i]) {
      {
#line 302
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 302
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 303
      failed = 1;
      }
#line 304
      goto while_break;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 32)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 309
    ((bus_params_t___3 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___3 *)bus___0->params)->d[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 316
    if (! (i < 7)) {
#line 316
      goto while_break___1;
    }
    {
#line 317
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 318
    ((bus_params_t___3 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 319
    if (! ((bus_params_t___3 *)bus___0->params)->cs[i]) {
      {
#line 320
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 320
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 321
      failed = 1;
      }
#line 322
      goto while_break___1;
    }
#line 316
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 325
    if (! (i < 4)) {
#line 325
      goto while_break___2;
    }
    {
#line 326
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 327
    ((bus_params_t___3 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 328
    if (! ((bus_params_t___3 *)bus___0->params)->we[i]) {
      {
#line 329
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 329
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 330
      failed = 1;
      }
#line 331
      goto while_break___2;
    }
#line 325
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 334
  ((bus_params_t___3 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                 "RD_WR");
  }
#line 335
  if (! ((bus_params_t___3 *)bus___0->params)->rdwr) {
    {
#line 336
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 336
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 337
    failed = 1;
    }
  }
  {
#line 339
  ((bus_params_t___3 *)bus___0->params)->rd = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                               "RD_CASS_FRAME");
  }
#line 340
  if (! ((bus_params_t___3 *)bus___0->params)->rd) {
    {
#line 341
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 341
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 342
    failed = 1;
    }
  }
#line 345
  if (failed) {
    {
#line 346
    free(bus___0->params);
#line 347
    free((void *)bus___0);
    }
#line 348
    return ((bus_t *)((void *)0));
  }
#line 351
  return (bus___0);
}
}
#line 48 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  sh7750r_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void setup_address___4(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 67
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < 26)) {
#line 69
      goto while_break;
    }
    {
#line 70
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 69
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void set_data_in___4(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 32)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 0, 0);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void setup_data___4(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 87
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 32)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void sh7750r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < ((((bus_params_t___4 *)bus___0->params)->chain)->parts)->len)) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )((bus_params_t___4 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___4 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 100
      goto while_break;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = gettext("Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 101
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void sh7750r_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 107
  part_set_instruction(((bus_params_t___4 *)bus___0->params)->part, "EXTEST");
#line 108
  chain_shift_instructions(((bus_params_t___4 *)bus___0->params)->chain);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void sh7750r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 114
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 8)) {
#line 118
      goto while_break;
    }
#line 119
    cs[i] = 1;
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  cs[(adr & 469762048U) >> 26] = 0;
#line 122
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 123
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 124
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 125
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 126
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 127
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 128
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 129
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 1);
#line 130
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 1);
#line 131
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 134
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 135
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 0);
#line 136
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 0);
#line 138
  setup_address___4(bus___0, adr);
#line 139
  set_data_in___4(bus___0);
#line 140
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 0);
  }
#line 141
  return;
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 146
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 148
  d = (uint32_t )0;
#line 150
  setup_address___4(bus___0, adr);
#line 151
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 1);
#line 153
  i = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < 32)) {
#line 153
      goto while_break;
    }
    {
#line 154
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 154
    d |= (uint32_t )(tmp << i);
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return (d);
}
}
#line 159 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 162
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 165
  d = (uint32_t )0;
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < 8)) {
#line 167
      goto while_break;
    }
#line 168
    cs[i] = 1;
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 171
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 172
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 173
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 174
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 175
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 176
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 178
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 180
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 1);
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (i < 32)) {
#line 182
      goto while_break___0;
    }
    {
#line 183
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 183
    d |= (uint32_t )(tmp << i);
#line 182
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  return (d);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  sh7750r_bus_read_start(bus___0, adr);
#line 192
  tmp = sh7750r_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void sh7750r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 198
  chain___0 = ((bus_params_t___4 *)bus___0->params)->chain;
#line 199
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 8)) {
#line 203
      goto while_break;
    }
#line 204
    cs[i] = 1;
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  cs[(adr & 469762048U) >> 26] = 0;
#line 207
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 208
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 209
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 210
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 211
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 212
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 213
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 215
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 0);
#line 216
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 0);
#line 217
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 218
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 219
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 220
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 224
  setup_address___4(bus___0, adr);
#line 225
  setup_data___4(bus___0, data);
#line 227
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 0);
#line 230
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 0);
#line 231
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 0);
#line 232
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 0);
#line 234
  chain_shift_data_registers(chain___0, 0);
#line 236
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 237
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 238
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 239
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 241
  chain_shift_data_registers(chain___0, 0);
  }
#line 242
  return;
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static int sh7750r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 247
  area->description = (char const   *)((void *)0);
#line 248
  area->start = 0U;
#line 249
  area->length = 4294967296UL;
#line 250
  area->width = 32U;
#line 252
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static void sh7750r_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 258
  free(bus___0->params);
#line 259
  free((void *)bus___0);
  }
#line 260
  return;
}
}
#line 262
static bus_t *sh7750r_bus_new(char **cmd_params___0 ) ;
#line 264 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
struct bus_driver  const  sh7750r_bus  = 
#line 264
     {"sh7750r", "Hitachi SH7750R compatible bus driver via BSR", & sh7750r_bus_new,
    & sh7750r_bus_free, & sh7750r_bus_printinfo, & sh7750r_bus_prepare, & sh7750r_bus_area,
    & sh7750r_bus_read_start, & sh7750r_bus_read_next, & sh7750r_bus_read_end, & sh7750r_bus_read,
    & sh7750r_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 280 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7750r.c"
static bus_t *sh7750r_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 286
  failed = 0;
#line 288
  if (! chain) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (! chain->parts) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if ((chain->parts)->len <= chain->active_part) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (chain->active_part < 0) {
#line 289
    return ((bus_t *)((void *)0));
  }
  {
#line 291
  tmp = malloc(sizeof(bus_t ));
#line 291
  bus___0 = (bus_t *)tmp;
  }
#line 292
  if (! bus___0) {
#line 293
    return ((bus_t *)((void *)0));
  }
  {
#line 295
  bus___0->driver = & sh7750r_bus;
#line 296
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___4 ));
  }
#line 297
  if (! bus___0->params) {
    {
#line 298
    free((void *)bus___0);
    }
#line 299
    return ((bus_t *)((void *)0));
  }
#line 302
  ((bus_params_t___4 *)bus___0->params)->chain = chain;
#line 303
  ((bus_params_t___4 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 305
  i = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < 26)) {
#line 305
      goto while_break;
    }
    {
#line 306
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 307
    ((bus_params_t___4 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 308
    if (! ((bus_params_t___4 *)bus___0->params)->a[i]) {
      {
#line 309
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 309
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 310
      failed = 1;
      }
#line 311
      goto while_break;
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if (! (i < 32)) {
#line 314
      goto while_break___0;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 316
    ((bus_params_t___4 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___4 *)bus___0->params)->d[i]) {
      {
#line 318
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 318
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 319
      failed = 1;
      }
#line 320
      goto while_break___0;
    }
#line 314
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < 7)) {
#line 323
      goto while_break___1;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 325
    ((bus_params_t___4 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___4 *)bus___0->params)->cs[i]) {
      {
#line 327
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break___1;
    }
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 332
    if (! (i < 8)) {
#line 332
      goto while_break___2;
    }
    {
#line 333
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 334
    ((bus_params_t___4 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 335
    if (! ((bus_params_t___4 *)bus___0->params)->we[i]) {
      {
#line 336
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 336
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 337
      failed = 1;
      }
#line 338
      goto while_break___2;
    }
#line 332
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 341
  ((bus_params_t___4 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                 "RDWR");
  }
#line 342
  if (! ((bus_params_t___4 *)bus___0->params)->rdwr) {
    {
#line 343
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 343
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 344
    failed = 1;
    }
  }
  {
#line 346
  ((bus_params_t___4 *)bus___0->params)->rd = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                               "RD");
  }
#line 347
  if (! ((bus_params_t___4 *)bus___0->params)->rd) {
    {
#line 348
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 348
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 349
    failed = 1;
    }
  }
  {
#line 351
  ((bus_params_t___4 *)bus___0->params)->rdwr2 = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                  "RDWR2");
  }
#line 352
  if (! ((bus_params_t___4 *)bus___0->params)->rdwr2) {
    {
#line 353
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 353
    printf((char const   */* __restrict  */)tmp___6, "RDWR2");
#line 354
    failed = 1;
    }
  }
  {
#line 356
  ((bus_params_t___4 *)bus___0->params)->rd2 = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                "RD2");
  }
#line 357
  if (! ((bus_params_t___4 *)bus___0->params)->rd2) {
    {
#line 358
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 358
    printf((char const   */* __restrict  */)tmp___7, "RD2");
#line 359
    failed = 1;
    }
  }
#line 362
  if (failed) {
    {
#line 363
    free(bus___0->params);
#line 364
    free((void *)bus___0);
    }
#line 365
    return ((bus_t *)((void *)0));
  }
#line 368
  return (bus___0);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  sh7727_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 65 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void setup_address___5(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 69
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < 26)) {
#line 71
      goto while_break;
    }
    {
#line 72
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 71
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void set_data_in___5(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 79
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 82
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((unsigned int )i < area.width)) {
#line 84
      goto while_break;
    }
    {
#line 85
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 0, 0);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void setup_data___5(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 92
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 95
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 97
  i = 0;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned int )i < area.width)) {
#line 97
      goto while_break;
    }
    {
#line 98
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 97
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void sh7727_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < ((((bus_params_t___5 *)bus___0->params)->chain)->parts)->len)) {
#line 106
      goto while_break;
    }
#line 107
    if ((unsigned long )((bus_params_t___5 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___5 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 108
      goto while_break;
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  tmp = gettext("Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 109
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void sh7727_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 115
  part_set_instruction(((bus_params_t___5 *)bus___0->params)->part, "EXTEST");
#line 116
  chain_shift_instructions(((bus_params_t___5 *)bus___0->params)->chain);
  }
#line 117
  return;
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void sh7727_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 122
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < 8)) {
#line 126
      goto while_break;
    }
#line 127
    cs[i] = 1;
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  cs[(adr & 469762048U) >> 26] = 0;
#line 130
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 131
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 132
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 133
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 134
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 135
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 136
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 1);
#line 137
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 138
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 139
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 140
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 141
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 0);
#line 143
  setup_address___5(bus___0, adr);
#line 144
  set_data_in___5(bus___0);
#line 146
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 0);
  }
#line 147
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 152
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 154
  d = (uint32_t )0;
#line 157
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 159
  setup_address___5(bus___0, adr);
#line 160
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 171
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 173
  d = (uint32_t )0;
#line 176
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 178
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 186
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 1);
#line 188
  i = 0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned int )i < area.width)) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 189
    d |= (uint32_t )(tmp << i);
#line 188
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (d);
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static uint32_t sh7727_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 197
  sh7727_bus_read_start(bus___0, adr);
#line 198
  tmp = sh7727_bus_read_end(bus___0);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void sh7727_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 204
  chain___0 = ((bus_params_t___5 *)bus___0->params)->chain;
#line 205
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < 8)) {
#line 209
      goto while_break;
    }
#line 210
    cs[i] = 1;
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  cs[(adr & 469762048U) >> 26] = 0;
#line 213
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 214
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 215
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 216
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 217
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 218
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 220
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 0);
#line 221
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 223
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 224
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 225
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 227
  setup_address___5(bus___0, adr);
#line 228
  setup_data___5(bus___0, data);
#line 230
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 0);
#line 233
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 0);
#line 234
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 0);
#line 235
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 0);
#line 237
  chain_shift_data_registers(chain___0, 0);
#line 239
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 240
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 241
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 242
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 244
  chain_shift_data_registers(chain___0, 0);
  }
#line 245
  return;
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 250
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 252
  area->description = (char const   *)((void *)0);
#line 253
  area->start = 0U;
#line 254
  area->length = 4294967296UL;
#line 256
  tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md4);
#line 256
  tmp___0 = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md3);
  }
  {
#line 257
  if (((tmp << 1) | tmp___0) == 1) {
#line 257
    goto case_1;
  }
#line 260
  if (((tmp << 1) | tmp___0) == 2) {
#line 260
    goto case_2;
  }
#line 263
  if (((tmp << 1) | tmp___0) == 3) {
#line 263
    goto case_3;
  }
#line 266
  goto switch_default;
  case_1: /* CIL Label */ 
#line 258
  area->width = 8U;
#line 259
  return (0);
  case_2: /* CIL Label */ 
#line 261
  area->width = 16U;
#line 262
  return (0);
  case_3: /* CIL Label */ 
#line 264
  area->width = 32U;
#line 265
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 267
  tmp___1 = gettext("Error: Invalid bus width (MD3 = MD4 = 0)!\n");
#line 267
  printf((char const   */* __restrict  */)tmp___1);
#line 268
  area->width = 0U;
  }
#line 269
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static void sh7727_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 276
  free(bus___0->params);
#line 277
  free((void *)bus___0);
  }
#line 278
  return;
}
}
#line 280
static bus_t *sh7727_bus_new(char **cmd_params___0 ) ;
#line 282 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
struct bus_driver  const  sh7727_bus  = 
#line 282
     {"sh7727", "Hitachi SH7727 compatible bus driver via BSR", & sh7727_bus_new, & sh7727_bus_free,
    & sh7727_bus_printinfo, & sh7727_bus_prepare, & sh7727_bus_area, & sh7727_bus_read_start,
    & sh7727_bus_read_next, & sh7727_bus_read_end, & sh7727_bus_read, & sh7727_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 298 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sh7727.c"
static bus_t *sh7727_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 304
  failed = 0;
#line 306
  if (! chain) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if (! chain->parts) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if ((chain->parts)->len <= chain->active_part) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if (chain->active_part < 0) {
#line 307
    return ((bus_t *)((void *)0));
  }
  {
#line 309
  tmp = malloc(sizeof(bus_t ));
#line 309
  bus___0 = (bus_t *)tmp;
  }
#line 310
  if (! bus___0) {
#line 311
    return ((bus_t *)((void *)0));
  }
  {
#line 313
  bus___0->driver = & sh7727_bus;
#line 314
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___5 ));
  }
#line 315
  if (! bus___0->params) {
    {
#line 316
    free((void *)bus___0);
    }
#line 317
    return ((bus_t *)((void *)0));
  }
#line 320
  ((bus_params_t___5 *)bus___0->params)->chain = chain;
#line 321
  ((bus_params_t___5 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < 26)) {
#line 323
      goto while_break;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 325
    ((bus_params_t___5 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___5 *)bus___0->params)->a[i]) {
      {
#line 327
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break;
    }
#line 323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (i < 32)) {
#line 332
      goto while_break___0;
    }
    {
#line 333
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 334
    ((bus_params_t___5 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 335
    if (! ((bus_params_t___5 *)bus___0->params)->d[i]) {
      {
#line 336
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 336
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 337
      failed = 1;
      }
#line 338
      goto while_break___0;
    }
#line 332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 341
    if (! (i < 7)) {
#line 341
      goto while_break___1;
    }
#line 342
    if (i == 1) {
#line 343
      goto __Cont;
    }
    {
#line 344
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 345
    ((bus_params_t___5 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 346
    if (! ((bus_params_t___5 *)bus___0->params)->cs[i]) {
      {
#line 347
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 347
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 348
      failed = 1;
      }
#line 349
      goto while_break___1;
    }
    __Cont: /* CIL Label */ 
#line 341
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 352
    if (! (i < 4)) {
#line 352
      goto while_break___2;
    }
    {
#line 353
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 354
    ((bus_params_t___5 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 355
    if (! ((bus_params_t___5 *)bus___0->params)->we[i]) {
      {
#line 356
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 356
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 357
      failed = 1;
      }
#line 358
      goto while_break___2;
    }
#line 352
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 361
  ((bus_params_t___5 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                 "RDWR");
  }
#line 362
  if (! ((bus_params_t___5 *)bus___0->params)->rdwr) {
    {
#line 363
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 363
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 364
    failed = 1;
    }
  }
  {
#line 366
  ((bus_params_t___5 *)bus___0->params)->rd = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                               "RD");
  }
#line 367
  if (! ((bus_params_t___5 *)bus___0->params)->rd) {
    {
#line 368
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 368
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 369
    failed = 1;
    }
  }
  {
#line 371
  ((bus_params_t___5 *)bus___0->params)->md3 = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                "MD3");
  }
#line 372
  if (! ((bus_params_t___5 *)bus___0->params)->md3) {
    {
#line 373
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 373
    printf((char const   */* __restrict  */)tmp___6, "MD3");
#line 374
    failed = 1;
    }
  }
  {
#line 376
  ((bus_params_t___5 *)bus___0->params)->md4 = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                "MD4");
  }
#line 377
  if (! ((bus_params_t___5 *)bus___0->params)->md4) {
    {
#line 378
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 378
    printf((char const   */* __restrict  */)tmp___7, "MD4");
#line 379
    failed = 1;
    }
  }
#line 382
  if (failed) {
    {
#line 383
    free(bus___0->params);
#line 384
    free((void *)bus___0);
    }
#line 385
    return ((bus_t *)((void *)0));
  }
#line 388
  return (bus___0);
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  sa1110_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void setup_address___6(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 26)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void set_data_in___6(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 81
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned int )i < area.width)) {
#line 83
      goto while_break;
    }
    {
#line 84
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 0, 0);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void setup_data___6(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 91
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 94
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 96
  i = 0;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ((unsigned int )i < area.width)) {
#line 96
      goto while_break;
    }
    {
#line 97
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 96
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void sa1110_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < ((((bus_params_t___6 *)bus___0->params)->chain)->parts)->len)) {
#line 105
      goto while_break;
    }
#line 106
    if ((unsigned long )((bus_params_t___6 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___6 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 107
      goto while_break;
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp = gettext("Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 108
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void sa1110_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 114
  part_set_instruction(((bus_params_t___6 *)bus___0->params)->part, "EXTEST");
#line 115
  chain_shift_instructions(((bus_params_t___6 *)bus___0->params)->chain);
  }
#line 116
  return;
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void sa1110_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 122
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 123
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 125
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 126
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 127
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 128
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 129
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 130
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 131
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 0);
#line 135
  setup_address___6(bus___0, adr);
#line 136
  set_data_in___6(bus___0);
#line 138
  chain_shift_data_registers(chain___0, 0);
  }
#line 139
  return;
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 145
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 146
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 148
  d = (uint32_t )0;
#line 151
  sa1110_bus_area(bus___0, adr, & area);
#line 153
  setup_address___6(bus___0, adr);
#line 154
  chain_shift_data_registers(chain___0, 1);
#line 156
  i = 0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! ((unsigned int )i < area.width)) {
#line 156
      goto while_break;
    }
    {
#line 157
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 157
    d |= (uint32_t )(tmp << i);
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (d);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 166
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 167
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 169
  d = (uint32_t )0;
#line 172
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 174
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 181
  chain_shift_data_registers(chain___0, 1);
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((unsigned int )i < area.width)) {
#line 183
      goto while_break;
    }
    {
#line 184
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 184
    d |= (uint32_t )(tmp << i);
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (d);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static uint32_t sa1110_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 192
  sa1110_bus_read_start(bus___0, adr);
#line 193
  tmp = sa1110_bus_read_end(bus___0);
  }
#line 193
  return (tmp);
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void sa1110_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 200
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 201
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 203
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 204
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 205
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 206
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 207
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 208
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 209
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 0);
#line 210
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 211
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 213
  setup_address___6(bus___0, adr);
#line 214
  setup_data___6(bus___0, data);
#line 216
  chain_shift_data_registers(chain___0, 0);
#line 218
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 0);
#line 219
  chain_shift_data_registers(chain___0, 0);
#line 220
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 223
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 224
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 225
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 226
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 227
  chain_shift_data_registers(chain___0, 0);
  }
#line 228
  return;
}
}
#line 230 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 233
  area->description = (char const   *)((void *)0);
#line 234
  area->start = 0U;
#line 235
  area->length = 4294967296UL;
#line 236
  tmp___1 = part_find_signal(((bus_params_t___6 *)bus___0->params)->part, "ROM_SEL");
#line 236
  tmp___2 = part_get_signal(((bus_params_t___6 *)bus___0->params)->part, tmp___1);
  }
#line 236
  if (tmp___2) {
#line 236
    area->width = 32U;
  } else {
#line 236
    area->width = 16U;
  }
#line 238
  return (0);
}
}
#line 241 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static void sa1110_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 244
  free(bus___0->params);
#line 245
  free((void *)bus___0);
  }
#line 246
  return;
}
}
#line 248
static bus_t *sa1110_bus_new(char **cmd_params___0 ) ;
#line 250 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
struct bus_driver  const  sa1110_bus  = 
#line 250
     {"sa1110", "Intel SA-1110 compatible bus driver via BSR", & sa1110_bus_new, & sa1110_bus_free,
    & sa1110_bus_printinfo, & sa1110_bus_prepare, & sa1110_bus_area, & sa1110_bus_read_start,
    & sa1110_bus_read_next, & sa1110_bus_read_end, & sa1110_bus_read, & sa1110_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 266 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/sa1110.c"
static bus_t *sa1110_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 272
  failed = 0;
#line 274
  if (! chain) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if (! chain->parts) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if ((chain->parts)->len <= chain->active_part) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if (chain->active_part < 0) {
#line 275
    return ((bus_t *)((void *)0));
  }
  {
#line 277
  tmp = malloc(sizeof(bus_t ));
#line 277
  bus___0 = (bus_t *)tmp;
  }
#line 278
  if (! bus___0) {
#line 279
    return ((bus_t *)((void *)0));
  }
  {
#line 281
  bus___0->driver = & sa1110_bus;
#line 282
  bus___0->params = malloc(sizeof(bus_params_t___6 ));
  }
#line 283
  if (! bus___0->params) {
    {
#line 284
    free((void *)bus___0);
    }
#line 285
    return ((bus_t *)((void *)0));
  }
#line 288
  ((bus_params_t___6 *)bus___0->params)->chain = chain;
#line 289
  ((bus_params_t___6 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 291
  i = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (i < 26)) {
#line 291
      goto while_break;
    }
    {
#line 292
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 293
    ((bus_params_t___6 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 294
    if (! ((bus_params_t___6 *)bus___0->params)->a[i]) {
      {
#line 295
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 295
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 296
      failed = 1;
      }
#line 297
      goto while_break;
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (! (i < 32)) {
#line 300
      goto while_break___0;
    }
    {
#line 301
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 302
    ((bus_params_t___6 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 303
    if (! ((bus_params_t___6 *)bus___0->params)->d[i]) {
      {
#line 304
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 304
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 305
      failed = 1;
      }
#line 306
      goto while_break___0;
    }
#line 300
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 309
    if (! (i < 6)) {
#line 309
      goto while_break___1;
    }
    {
#line 310
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 311
    ((bus_params_t___6 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 312
    if (! ((bus_params_t___6 *)bus___0->params)->ncs[i]) {
      {
#line 313
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 313
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 314
      failed = 1;
      }
#line 315
      goto while_break___1;
    }
#line 309
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 318
  ((bus_params_t___6 *)bus___0->params)->rd_nwr = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   "RD_nWR");
  }
#line 319
  if (! ((bus_params_t___6 *)bus___0->params)->rd_nwr) {
    {
#line 320
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 320
    printf((char const   */* __restrict  */)tmp___3, "RD_nWR");
#line 321
    failed = 1;
    }
  }
  {
#line 323
  ((bus_params_t___6 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                "nWE");
  }
#line 324
  if (! ((bus_params_t___6 *)bus___0->params)->nwe) {
    {
#line 325
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 325
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 326
    failed = 1;
    }
  }
  {
#line 328
  ((bus_params_t___6 *)bus___0->params)->noe = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 329
  if (! ((bus_params_t___6 *)bus___0->params)->noe) {
    {
#line 330
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 330
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 331
    failed = 1;
    }
  }
#line 334
  if (failed) {
    {
#line 335
    free(bus___0->params);
#line 336
    free((void *)bus___0);
    }
#line 337
    return ((bus_t *)((void *)0));
  }
#line 340
  return (bus___0);
}
}
#line 45 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  s3c4510_bus ;
#line 103 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void setup_address___7(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int so ;
  part_t *p ;

  {
#line 107
  p = ((bus_params_t___7 *)bus___0->params)->part;
  {
#line 111
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 111
    goto case_32;
  }
#line 112
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 112
    goto case_16;
  }
#line 113
  goto switch_default;
  case_32: /* CIL Label */ 
#line 111
  so = 2;
#line 111
  goto switch_break;
  case_16: /* CIL Label */ 
#line 112
  so = 1;
#line 112
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 113
  so = 0;
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < 22)) {
#line 116
      goto while_break;
    }
    {
#line 117
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->a[i], 1, (int )((a >> (i + so)) & 1U));
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void set_data_in___7(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 124
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 126
      goto while_break;
    }
    {
#line 127
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 0, 0);
#line 126
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void setup_data___7(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 134
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 136
      goto while_break;
    }
    {
#line 137
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 136
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  i = ((bus_params_t___7 *)bus___0->params)->dbuswidth;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (i < 32)) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, 0);
#line 139
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < ((((bus_params_t___7 *)bus___0->params)->chain)->parts)->len)) {
#line 148
      goto while_break;
    }
#line 149
    if ((unsigned long )((bus_params_t___7 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___7 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 150
      goto while_break;
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  tmp = gettext("Samsung S3C4510B compatibile bus driver via BSR (JTAG part No. %d) RCS0=%ubit\n");
#line 151
  printf((char const   */* __restrict  */)tmp, i, ((bus_params_t___7 *)bus___0->params)->dbuswidth);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_setup_ctrl(bus_t *bus___0 , int mode ) 
{ 
  int k ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 157
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 159
  k = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (k < 6)) {
#line 159
      goto while_break;
    }
#line 160
    if (mode & (1 << k)) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
    {
#line 160
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nrcs[k], 1, tmp);
#line 159
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  k = 0;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! (k < 4)) {
#line 162
      goto while_break___0;
    }
    {
#line 163
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->necs[k], 1, 1);
#line 162
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  k = 0;
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 165
    if (! (k < 4)) {
#line 165
      goto while_break___1;
    }
    {
#line 166
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nsdcs[k], 1, 1);
#line 165
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 168
  k = 0;
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 168
    if (! (k < 4)) {
#line 168
      goto while_break___2;
    }
#line 169
    if (mode & (1 << (k + 8))) {
#line 169
      tmp___0 = 1;
    } else {
#line 169
      tmp___0 = 0;
    }
    {
#line 169
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nwbe[k], 1, tmp___0);
#line 168
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 171
  if (mode & (1 << 16)) {
#line 171
    tmp___1 = 1;
  } else {
#line 171
    tmp___1 = 0;
  }
  {
#line 171
  part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->noe, 1, tmp___1);
  }
#line 172
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_prepare(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 177
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 178
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 180
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 181
  chain_shift_instructions(chain___0);
#line 182
  chain_shift_data_registers(chain___0, 0);
#line 184
  part_set_instruction(p, "EXTEST");
#line 185
  chain_shift_instructions(chain___0);
  }
#line 186
  return;
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;

  {
  {
#line 193
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 195
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 196
  setup_address___7(bus___0, adr);
#line 197
  set_data_in___7(bus___0);
#line 198
  chain_shift_data_registers(chain___0, 0);
  }
#line 199
  return;
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 205
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 206
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 208
  d = (uint32_t )0;
#line 210
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 211
  setup_address___7(bus___0, adr);
#line 212
  set_data_in___7(bus___0);
#line 213
  chain_shift_data_registers(chain___0, 1);
#line 215
  i = 0;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 216
    d |= (uint32_t )(tmp << i);
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return (d);
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 225
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 226
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 228
  d = (uint32_t )0;
#line 230
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 231
  chain_shift_data_registers(chain___0, 1);
#line 233
  i = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 233
      goto while_break;
    }
    {
#line 234
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 234
    d |= (uint32_t )(tmp << i);
#line 233
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (d);
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 242
  s3c4510_bus_read_start(bus___0, adr);
#line 243
  tmp = s3c4510_bus_read_end(bus___0);
  }
#line 243
  return (tmp);
}
}
#line 252 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;

  {
  {
#line 256
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 258
  s3c4510_bus_setup_ctrl(bus___0, 131070);
#line 259
  setup_address___7(bus___0, adr);
#line 260
  setup_data___7(bus___0, data);
#line 262
  chain_shift_data_registers(chain___0, 0);
  }
  {
#line 270
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 270
    goto case_16;
  }
#line 274
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 274
    goto case_32;
  }
#line 266
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 268
  s3c4510_bus_setup_ctrl(bus___0, 130814);
  }
#line 269
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 271
  s3c4510_bus_setup_ctrl(bus___0, 130302);
  }
#line 272
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 275
  s3c4510_bus_setup_ctrl(bus___0, 127230);
  }
#line 276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 279
  setup_address___7(bus___0, adr);
#line 280
  setup_data___7(bus___0, data);
#line 282
  chain_shift_data_registers(chain___0, 0);
#line 284
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 285
  chain_shift_data_registers(chain___0, 0);
  }
#line 288
  return;
}
}
#line 291 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static int s3c4510_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  int b0size0 ;
  int b0size1 ;
  signal_t *tmp ;
  signal_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  area->description = (char const   *)((void *)0);
#line 297
  area->start = 0U;
#line 298
  area->length = 4294967296UL;
#line 301
  tmp = part_find_signal(((bus_params_t___7 *)bus___0->params)->part, "B0SIZE0");
#line 301
  b0size0 = part_get_signal(((bus_params_t___7 *)bus___0->params)->part, tmp);
#line 302
  tmp___0 = part_find_signal(((bus_params_t___7 *)bus___0->params)->part, "B0SIZE1");
#line 302
  b0size1 = part_get_signal(((bus_params_t___7 *)bus___0->params)->part, tmp___0);
  }
  {
#line 305
  if (((b0size1 << 1) | b0size0) == 1) {
#line 305
    goto case_1;
  }
#line 308
  if (((b0size1 << 1) | b0size0) == 2) {
#line 308
    goto case_2;
  }
#line 311
  if (((b0size1 << 1) | b0size0) == 3) {
#line 311
    goto case_3;
  }
#line 314
  goto switch_default;
  case_1: /* CIL Label */ 
#line 306
  tmp___1 = 8;
#line 306
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___1;
#line 306
  area->width = (unsigned int )tmp___1;
#line 307
  return (0);
  case_2: /* CIL Label */ 
#line 309
  tmp___2 = 16;
#line 309
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___2;
#line 309
  area->width = (unsigned int )tmp___2;
#line 310
  return (0);
  case_3: /* CIL Label */ 
#line 312
  tmp___3 = 32;
#line 312
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___3;
#line 312
  area->width = (unsigned int )tmp___3;
#line 313
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 315
  printf((char const   */* __restrict  */)"B0SIZE[1:0]: Unknown\n");
#line 316
  area->width = 0U;
  }
#line 317
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static void s3c4510_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 324
  free(bus___0->params);
#line 325
  free((void *)bus___0);
  }
#line 326
  return;
}
}
#line 328
static bus_t *s3c4510_bus_new(char **cmd_params___0 ) ;
#line 330 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
struct bus_driver  const  s3c4510_bus  = 
#line 330
     {"s3c4510x", "Samsung S3C4510B compatible bus driver via BSR", & s3c4510_bus_new,
    & s3c4510_bus_free, & s3c4510_bus_printinfo, & s3c4510_bus_prepare, & s3c4510_bus_area,
    & s3c4510_bus_read_start, & s3c4510_bus_read_next, & s3c4510_bus_read_end, & s3c4510_bus_read,
    & s3c4510_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 346 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/s3c4510x.c"
static bus_t *s3c4510_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 352
  failed = 0;
#line 354
  if (! chain) {
#line 355
    return ((bus_t *)((void *)0));
  } else
#line 354
  if (! chain->parts) {
#line 355
    return ((bus_t *)((void *)0));
  } else
#line 354
  if ((chain->parts)->len <= chain->active_part) {
#line 355
    return ((bus_t *)((void *)0));
  } else
#line 354
  if (chain->active_part < 0) {
#line 355
    return ((bus_t *)((void *)0));
  }
  {
#line 357
  tmp = malloc(sizeof(bus_t ));
#line 357
  bus___0 = (bus_t *)tmp;
  }
#line 358
  if (! bus___0) {
#line 359
    return ((bus_t *)((void *)0));
  }
  {
#line 361
  bus___0->driver = & s3c4510_bus;
#line 362
  bus___0->params = malloc(sizeof(bus_params_t___7 ));
  }
#line 363
  if (! bus___0->params) {
    {
#line 364
    free((void *)bus___0);
    }
#line 365
    return ((bus_t *)((void *)0));
  }
#line 369
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = 16;
#line 370
  ((bus_params_t___7 *)bus___0->params)->chain = chain;
#line 371
  ((bus_params_t___7 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < 22)) {
#line 373
      goto while_break;
    }
    {
#line 374
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 375
    ((bus_params_t___7 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 376
    if (! ((bus_params_t___7 *)bus___0->params)->a[i]) {
      {
#line 377
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 377
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 378
      failed = 1;
      }
#line 379
      goto while_break;
    }
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  i = 0;
  {
#line 382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 382
    if (! (i < 32)) {
#line 382
      goto while_break___0;
    }
    {
#line 383
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"XDATA%d",
            i);
#line 384
    ((bus_params_t___7 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 385
    if (! ((bus_params_t___7 *)bus___0->params)->d[i]) {
      {
#line 386
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 386
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 387
      failed = 1;
      }
#line 388
      goto while_break___0;
    }
#line 382
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 391
  i = 0;
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (! (i < 6)) {
#line 391
      goto while_break___1;
    }
    {
#line 392
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 393
    ((bus_params_t___7 *)bus___0->params)->nrcs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 394
    if (! ((bus_params_t___7 *)bus___0->params)->nrcs[i]) {
      {
#line 395
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 395
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 396
      failed = 1;
      }
#line 397
      goto while_break___1;
    }
#line 391
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 401
  i = 0;
  {
#line 401
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 401
    if (! (i < 4)) {
#line 401
      goto while_break___2;
    }
    {
#line 402
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nECS%d",
            i);
#line 403
    ((bus_params_t___7 *)bus___0->params)->necs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 404
    if (! ((bus_params_t___7 *)bus___0->params)->necs[i]) {
      {
#line 405
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 405
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 406
      failed = 1;
      }
#line 407
      goto while_break___2;
    }
#line 401
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 410
    if (! (i < 4)) {
#line 410
      goto while_break___3;
    }
    {
#line 411
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRAS%d",
            i);
#line 412
    ((bus_params_t___7 *)bus___0->params)->nsdcs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 413
    if (! ((bus_params_t___7 *)bus___0->params)->nsdcs[i]) {
      {
#line 414
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 414
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 415
      failed = 1;
      }
#line 416
      goto while_break___3;
    }
#line 410
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 419
  i = 0;
  {
#line 419
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 419
    if (! (i < 4)) {
#line 419
      goto while_break___4;
    }
    {
#line 420
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nWBE%d",
            i);
#line 421
    ((bus_params_t___7 *)bus___0->params)->nwbe[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 422
    if (! ((bus_params_t___7 *)bus___0->params)->nwbe[i]) {
      {
#line 423
      tmp___5 = gettext("signal \'%s\' not found\n");
#line 423
      printf((char const   */* __restrict  */)tmp___5, buff);
#line 424
      failed = 1;
      }
#line 425
      goto while_break___4;
    }
#line 419
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 429
  ((bus_params_t___7 *)bus___0->params)->noe = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 430
  if (! ((bus_params_t___7 *)bus___0->params)->noe) {
    {
#line 431
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 431
    printf((char const   */* __restrict  */)tmp___6, "nOE");
#line 432
    failed = 1;
    }
  }
#line 435
  if (failed) {
    {
#line 436
    free(bus___0->params);
#line 437
    free((void *)bus___0);
    }
#line 438
    return ((bus_t *)((void *)0));
  }
#line 441
  return (bus___0);
}
}
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  pxa2x0_bus ;
#line 44
struct bus_driver  const  pxa27x_bus ;
#line 83 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static ncs_map_entry pxa25x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static ncs_map_entry pxa27x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[15]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[78]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[79]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[80]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[33]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void setup_address___8(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 144
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < 26)) {
#line 146
      goto while_break;
    }
    {
#line 147
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 146
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void set_data_in___8(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 154
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 157
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((unsigned int )i < area.width)) {
#line 159
      goto while_break;
    }
    {
#line 160
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 0, 0);
#line 159
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 163 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void setup_data___8(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 167
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 170
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 172
  i = 0;
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned int )i < area.width)) {
#line 172
      goto while_break;
    }
    {
#line 173
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 172
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa2x0_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < ((((bus_params_t___8 *)bus___0->params)->chain)->parts)->len)) {
#line 181
      goto while_break;
    }
#line 182
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___8 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 183
      goto while_break;
    }
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  tmp = gettext("Intel PXA2x0 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 184
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 185
  return;
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa27x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < ((((bus_params_t___8 *)bus___0->params)->chain)->parts)->len)) {
#line 192
      goto while_break;
    }
#line 193
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___8 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 194
      goto while_break;
    }
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  tmp = gettext("Intel PXA27x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 195
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static int pxa2xx_bus_init(bus_t *bus___0 ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  signal_t *tmp___3 ;
  int tmp___4 ;
  signal_t *tmp___5 ;
  int tmp___6 ;

  {
#line 201
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 202
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 204
  if (((bus_params_t___8 *)bus___0->params)->inited == 1) {
#line 205
    return (0);
  }
  {
#line 207
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 208
  chain_shift_instructions(chain___0);
#line 209
  chain_shift_data_registers(chain___0, 1);
  }
#line 211
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
    {
#line 213
    tmp = part_find_signal(p, "BOOT_SEL[2]");
#line 213
    tmp___0 = part_get_signal(p, tmp);
#line 213
    tmp___1 = part_find_signal(p, "BOOT_SEL[1]");
#line 213
    tmp___2 = part_get_signal(p, tmp___1);
#line 213
    tmp___3 = part_find_signal(p, "BOOT_SEL[0]");
#line 213
    tmp___4 = part_get_signal(p, tmp___3);
#line 213
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | ((((tmp___0 << 2) | (tmp___2 << 1)) | tmp___4) & ((2 << 2) - 1)));
    }
  } else
#line 218
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
    {
#line 220
    tmp___5 = part_find_signal(p, "BOOT_SEL");
#line 220
    tmp___6 = part_get_signal(p, tmp___5);
#line 220
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | (tmp___6 & ((2 << 2) - 1)));
    }
  } else {
    {
#line 224
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
           "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c", 224);
    }
  }
  {
#line 226
  part_set_instruction(p, "BYPASS");
#line 227
  chain_shift_instructions(chain___0);
#line 229
  ((bus_params_t___8 *)bus___0->params)->inited = 1;
  }
#line 231
  return (0);
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa2xx_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 237
  pxa2xx_bus_init(bus___0);
#line 239
  part_set_instruction(((bus_params_t___8 *)bus___0->params)->part, "EXTEST");
#line 240
  chain_shift_instructions(((bus_params_t___8 *)bus___0->params)->chain);
  }
#line 241
  return;
}
}
#line 243 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa2xx_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  int cs_index ;
  chain_t *chain___0 ;
  part_t *p ;

  {
#line 246
  cs_index = 0;
#line 248
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 249
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 251
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 252
  if (adr >= 402653184U) {
#line 253
    return;
  }
#line 255
  cs_index = (int )(adr >> 26);
#line 256
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 257
    return;
  }
  {
#line 260
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 261
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 262
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 263
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 264
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 265
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 1);
#line 266
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 267
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 0);
#line 268
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 270
  setup_address___8(bus___0, adr);
#line 271
  set_data_in___8(bus___0, adr);
#line 273
  chain_shift_data_registers(chain___0, 0);
  }
#line 274
  return;
}
}
#line 276 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t d ;
  uint32_t old_last_adr ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 279
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 280
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 282
  old_last_adr = ((bus_params_t___8 *)bus___0->params)->last_adr;
#line 284
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 286
  if (adr < 402653184U) {
#line 290
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[adr >> 26] == (unsigned long )((void *)0)) {
#line 291
      return ((uint32_t )0);
    }
    {
#line 293
    (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 296
    setup_address___8(bus___0, adr);
#line 297
    chain_shift_data_registers(chain___0, 1);
#line 299
    d = (uint32_t )0;
#line 300
    i = 0;
    }
    {
#line 300
    while (1) {
      while_continue: /* CIL Label */ ;
#line 300
      if (! ((unsigned int )i < area.width)) {
#line 300
        goto while_break;
      }
      {
#line 301
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 301
      d |= (uint32_t )(tmp << i);
#line 300
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 303
    return (d);
  }
#line 307
  if (adr < 1207959552U) {
#line 308
    return ((uint32_t )0);
  }
#line 310
  if (adr < 1275068416U) {
#line 311
    if (old_last_adr == 1207959620U) {
#line 312
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 314
    return ((uint32_t )0);
  }
#line 317
  return ((uint32_t )0);
}
}
#line 320 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 323
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 324
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 326
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 402653184U) {
#line 328
    d = (uint32_t )0;
#line 331
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[((bus_params_t___8 *)bus___0->params)->last_adr >> 26] == (unsigned long )((void *)0)) {
#line 332
      return ((uint32_t )0);
    }
    {
#line 334
    (*((bus___0->driver)->area))(bus___0, ((bus_params_t___8 *)bus___0->params)->last_adr,
                                 & area);
#line 337
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[0], 1, 1);
#line 338
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 339
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 1);
#line 341
    chain_shift_data_registers(chain___0, 1);
#line 343
    i = 0;
    }
    {
#line 343
    while (1) {
      while_continue: /* CIL Label */ ;
#line 343
      if (! ((unsigned int )i < area.width)) {
#line 343
        goto while_break;
      }
      {
#line 344
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 344
      d |= (uint32_t )(tmp << i);
#line 343
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 346
    return (d);
  }
#line 350
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1207959552U) {
#line 351
    return ((uint32_t )0);
  }
#line 353
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1275068416U) {
#line 354
    if (((bus_params_t___8 *)bus___0->params)->last_adr == 1207959620U) {
#line 355
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 357
    return ((uint32_t )0);
  }
#line 360
  return ((uint32_t )0);
}
}
#line 363 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 366
  pxa2xx_bus_read_start(bus___0, adr);
#line 367
  tmp = pxa2xx_bus_read_end(bus___0);
  }
#line 367
  return (tmp);
}
}
#line 370 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa2xx_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  int cs_index ;
  part_t *p ;
  chain_t *chain___0 ;

  {
#line 373
  cs_index = 0;
#line 376
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 377
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 379
  if (adr >= 402653184U) {
#line 380
    return;
  }
#line 382
  cs_index = (int )(adr >> 26);
#line 383
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 384
    return;
  }
  {
#line 386
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 387
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 388
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 389
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 390
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 391
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 0);
#line 392
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 393
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 394
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 396
  setup_address___8(bus___0, adr);
#line 397
  setup_data___8(bus___0, adr, data);
#line 399
  chain_shift_data_registers(chain___0, 0);
#line 401
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 0);
#line 402
  chain_shift_data_registers(chain___0, 0);
#line 403
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 404
  chain_shift_data_registers(chain___0, 0);
  }
#line 405
  return;
}
}
#line 407 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static int pxa2xx_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
  {
#line 412
  pxa2xx_bus_init(bus___0);
  }
#line 415
  if (adr < 67108864U) {
#line 416
    area->description = "Static Chip Select 0";
#line 417
    area->start = 0U;
#line 418
    area->length = 67108864UL;
#line 420
    if (pxa25x_ncs_map[0].bus_width > 0) {
#line 422
      area->width = (unsigned int )pxa25x_ncs_map[0].bus_width;
    } else {
      {
#line 428
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 428
        goto case_0;
      }
#line 431
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 431
        goto case_1;
      }
#line 435
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 435
        goto case_3;
      }
#line 435
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 435
        goto case_3;
      }
#line 441
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 441
        goto case_7;
      }
#line 441
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 441
        goto case_7;
      }
#line 441
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 441
        goto case_7;
      }
#line 441
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 441
        goto case_7;
      }
#line 444
      goto switch_default;
      case_0: /* CIL Label */ 
#line 429
      area->width = 32U;
#line 430
      goto switch_break;
      case_1: /* CIL Label */ 
#line 432
      area->width = 16U;
#line 433
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 436
      area->width = 0U;
#line 437
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 442
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 443
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 445
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c", 445);
      }
#line 446
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 449
    return (0);
  }
#line 453
  ncs_index = 1;
#line 453
  tmp_addr = (uint32_t )67108864;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (ncs_index <= 5)) {
#line 453
      goto while_break;
    }
#line 455
    if (adr >= tmp_addr) {
#line 455
      if (adr < tmp_addr + 67108864U) {
#line 456
        if (pxa25x_ncs_map[ncs_index].enabled) {
#line 456
          tmp = "";
        } else {
#line 456
          tmp = "(disabled)";
        }
        {
#line 456
        sprintf((char */* __restrict  */)(pxa25x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa25x_ncs_map[ncs_index].sig_name, tmp);
#line 459
        area->description = (char const   *)(pxa25x_ncs_map[ncs_index].label_buf);
#line 460
        area->start = tmp_addr;
#line 461
        area->length = 67108864UL;
#line 462
        area->width = (unsigned int )pxa25x_ncs_map[ncs_index].bus_width;
        }
#line 464
        return (0);
      }
    }
#line 453
    ncs_index ++;
#line 453
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  if (adr < 1207959552U) {
#line 469
    area->description = (char const   *)((void *)0);
#line 470
    area->start = 402653184U;
#line 471
    area->length = 805306368UL;
#line 472
    area->width = 0U;
#line 474
    return (0);
  }
#line 477
  if (adr < 1275068416U) {
#line 478
    area->description = "Memory Mapped registers (Memory Ctl)";
#line 479
    area->start = 1207959552U;
#line 480
    area->length = 67108864UL;
#line 481
    area->width = 32U;
#line 483
    return (0);
  }
#line 486
  area->description = (char const   *)((void *)0);
#line 487
  area->start = 1275068416U;
#line 488
  area->length = 3019898880UL;
#line 489
  area->width = 0U;
#line 491
  return (0);
}
}
#line 494 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static int pxa27x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
  {
#line 499
  pxa2xx_bus_init(bus___0);
  }
#line 502
  if (adr < 67108864U) {
#line 503
    area->description = "Static Chip Select 0";
#line 504
    area->start = 0U;
#line 505
    area->length = 67108864UL;
#line 507
    if (pxa27x_ncs_map[0].bus_width > 0) {
#line 509
      area->width = (unsigned int )pxa27x_ncs_map[0].bus_width;
    } else {
      {
#line 515
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 515
        goto case_0;
      }
#line 518
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 518
        goto case_1;
      }
#line 522
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 522
        goto case_3;
      }
#line 522
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 522
        goto case_3;
      }
#line 528
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 528
        goto case_7;
      }
#line 528
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 528
        goto case_7;
      }
#line 528
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 528
        goto case_7;
      }
#line 528
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 528
        goto case_7;
      }
#line 531
      goto switch_default;
      case_0: /* CIL Label */ 
#line 516
      area->width = 32U;
#line 517
      goto switch_break;
      case_1: /* CIL Label */ 
#line 519
      area->width = 16U;
#line 520
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 523
      area->width = 0U;
#line 524
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 529
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 530
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 532
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c", 532);
      }
#line 533
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 536
    return (0);
  }
#line 540
  ncs_index = 1;
#line 540
  tmp_addr = (uint32_t )67108864;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (ncs_index <= 5)) {
#line 540
      goto while_break;
    }
#line 543
    if (adr >= tmp_addr) {
#line 543
      if (adr < tmp_addr + 67108864U) {
#line 545
        if (pxa27x_ncs_map[ncs_index].enabled) {
#line 545
          tmp = "";
        } else {
#line 545
          tmp = "(disabled)";
        }
        {
#line 545
        sprintf((char */* __restrict  */)(pxa27x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa27x_ncs_map[ncs_index].sig_name, tmp);
#line 548
        area->description = (char const   *)(pxa27x_ncs_map[ncs_index].label_buf);
#line 549
        area->start = tmp_addr;
#line 550
        area->length = 67108864UL;
#line 551
        area->width = (unsigned int )pxa27x_ncs_map[ncs_index].bus_width;
        }
#line 553
        return (0);
      }
    }
#line 540
    ncs_index ++;
#line 540
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  if (adr < 1073741824U) {
#line 559
    area->description = (char const   *)((void *)0);
#line 560
    area->start = 402653184U;
#line 561
    area->length = 671088640UL;
#line 562
    area->width = 0U;
#line 564
    return (0);
  }
#line 567
  if (adr < 1610612736U) {
#line 568
    area->description = "PXA270 internal address space (cfg, SRAM)";
#line 569
    area->start = 1073741824U;
#line 570
    area->length = 536870912UL;
#line 571
    area->width = 32U;
#line 573
    return (0);
  }
#line 576
  if (adr < 2684354560U) {
#line 577
    area->description = (char const   *)((void *)0);
#line 578
    area->start = 1610612736U;
#line 579
    area->length = 1073741824UL;
#line 580
    area->width = 0U;
#line 582
    return (0);
  }
#line 585
  if (adr < 2952790016U) {
#line 586
    area->description = "PXA270 SDRAM space (4x 64MB)";
#line 587
    area->start = 2684354560U;
#line 588
    area->length = 268435456UL;
#line 589
    area->width = 32U;
#line 591
    return (0);
  }
#line 594
  area->description = (char const   *)((void *)0);
#line 595
  area->start = 2952790016U;
#line 596
  area->length = 1342177280UL;
#line 597
  area->width = 0U;
#line 599
  return (0);
}
}
#line 602 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static void pxa2xx_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 606
  free(bus___0->params);
#line 607
  free((void *)bus___0);
  }
#line 608
  return;
}
}
#line 610
static bus_t *pxa2x0_bus_new(char **cmd_params___0 ) ;
#line 611
static bus_t *pxa27x_bus_new(char **cmd_params___0 ) ;
#line 613 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
struct bus_driver  const  pxa2x0_bus  = 
#line 613
     {"pxa2x0", "Intel PXA2x0 compatible bus driver via BSR", & pxa2x0_bus_new, & pxa2xx_bus_free,
    & pxa2x0_bus_printinfo, & pxa2xx_bus_prepare, & pxa2xx_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & pxa2xx_bus_read, & pxa2xx_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 629 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
struct bus_driver  const  pxa27x_bus  = 
#line 629
     {"pxa27x", "Intel PXA27x compatible bus driver via BSR", & pxa27x_bus_new, & pxa2xx_bus_free,
    & pxa27x_bus_printinfo, & pxa2xx_bus_prepare, & pxa27x_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & pxa2xx_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 647 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static int pxa2xx_bus_new_common(bus_t *bus___0 ) 
{ 
  int failed ;
  ncs_map_entry *ncs_map ;
  int i ;
  char buff[10] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 650
  failed = 0;
#line 651
  ncs_map = (ncs_map_entry *)((void *)0);
#line 677
  i = 0;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (i < 26)) {
#line 677
      goto while_break;
    }
    {
#line 678
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MA[%d]",
            i);
#line 679
    ((bus_params_t___8 *)bus___0->params)->ma[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 680
    if (! ((bus_params_t___8 *)bus___0->params)->ma[i]) {
      {
#line 681
      tmp = gettext("signal \'%s\' not found\n");
#line 681
      printf((char const   */* __restrict  */)tmp, buff);
#line 682
      failed = 1;
      }
#line 683
      goto while_break;
    }
#line 677
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  i = 0;
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    if (! (i < 32)) {
#line 686
      goto while_break___0;
    }
    {
#line 687
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MD[%d]",
            i);
#line 688
    ((bus_params_t___8 *)bus___0->params)->md[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 689
    if (! ((bus_params_t___8 *)bus___0->params)->md[i]) {
      {
#line 690
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 690
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 691
      failed = 1;
      }
#line 692
      goto while_break___0;
    }
#line 686
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 696
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
#line 697
    ncs_map = pxa25x_ncs_map;
  } else
#line 699
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
#line 700
    ncs_map = pxa27x_ncs_map;
  } else {
    {
#line 704
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d: unknown PROC\n",
           "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c", 704);
#line 705
    ncs_map = pxa25x_ncs_map;
    }
  }
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 707
    if (! (i < 6)) {
#line 707
      goto while_break___1;
    }
#line 708
    if ((ncs_map + i)->enabled > 0) {
      {
#line 710
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                       (char const   *)(ncs_map + i)->sig_name);
      }
#line 711
      if (! ((bus_params_t___8 *)bus___0->params)->ncs[i]) {
        {
#line 712
        tmp___1 = gettext("signal \'%s\' not found\n");
#line 712
        printf((char const   */* __restrict  */)tmp___1, buff);
#line 713
        failed = 1;
        }
#line 714
        goto while_break___1;
      }
    } else {
#line 719
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = (signal_t *)((void *)0);
    }
#line 707
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 723
  i = 0;
  {
#line 723
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 723
    if (! (i < 4)) {
#line 723
      goto while_break___2;
    }
    {
#line 724
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DQM[%d]",
            i);
#line 725
    ((bus_params_t___8 *)bus___0->params)->dqm[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 726
    if (! ((bus_params_t___8 *)bus___0->params)->dqm[i]) {
      {
#line 727
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 727
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 728
      failed = 1;
      }
#line 729
      goto while_break___2;
    }
#line 723
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 732
  ((bus_params_t___8 *)bus___0->params)->rdnwr = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                  "RDnWR");
  }
#line 733
  if (! ((bus_params_t___8 *)bus___0->params)->rdnwr) {
    {
#line 734
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 734
    printf((char const   */* __restrict  */)tmp___3, "RDnWR");
#line 735
    failed = 1;
    }
  }
  {
#line 737
  ((bus_params_t___8 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                "nWE");
  }
#line 738
  if (! ((bus_params_t___8 *)bus___0->params)->nwe) {
    {
#line 739
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 739
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 740
    failed = 1;
    }
  }
  {
#line 742
  ((bus_params_t___8 *)bus___0->params)->noe = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 743
  if (! ((bus_params_t___8 *)bus___0->params)->noe) {
    {
#line 744
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 744
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 745
    failed = 1;
    }
  }
  {
#line 747
  ((bus_params_t___8 *)bus___0->params)->nsdcas = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                   "nSDCAS");
  }
#line 748
  if (! ((bus_params_t___8 *)bus___0->params)->nsdcas) {
    {
#line 749
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 749
    printf((char const   */* __restrict  */)tmp___6, "nSDCAS");
#line 750
    failed = 1;
    }
  }
#line 753
  return (failed);
}
}
#line 756 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static bus_t *pxa2x0_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  void *tmp ;

  {
#line 760
  failed = 0;
#line 762
  if (! chain) {
#line 763
    return ((bus_t *)((void *)0));
  } else
#line 762
  if (! chain->parts) {
#line 763
    return ((bus_t *)((void *)0));
  } else
#line 762
  if ((chain->parts)->len <= chain->active_part) {
#line 763
    return ((bus_t *)((void *)0));
  } else
#line 762
  if (chain->active_part < 0) {
#line 763
    return ((bus_t *)((void *)0));
  }
  {
#line 765
  tmp = malloc(sizeof(bus_t ));
#line 765
  bus___0 = (bus_t *)tmp;
  }
#line 766
  if (! bus___0) {
#line 767
    return ((bus_t *)((void *)0));
  }
  {
#line 769
  bus___0->driver = & pxa2x0_bus;
#line 770
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___8 ));
  }
#line 771
  if (! bus___0->params) {
    {
#line 772
    free((void *)bus___0);
    }
#line 773
    return ((bus_t *)((void *)0));
  }
  {
#line 776
  ((bus_params_t___8 *)bus___0->params)->chain = chain;
#line 777
  ((bus_params_t___8 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 778
  ((bus_params_t___8 *)bus___0->params)->proc = 1;
#line 780
  failed = pxa2xx_bus_new_common(bus___0);
  }
#line 782
  if (failed) {
    {
#line 783
    free(bus___0->params);
#line 784
    free((void *)bus___0);
    }
#line 785
    return ((bus_t *)((void *)0));
  }
#line 788
  ((bus_params_t___8 *)bus___0->params)->inited = 0;
#line 790
  return (bus___0);
}
}
#line 793 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/pxa2x0.c"
static bus_t *pxa27x_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  void *tmp ;

  {
#line 797
  failed = 0;
#line 799
  if (! chain) {
#line 800
    return ((bus_t *)((void *)0));
  } else
#line 799
  if (! chain->parts) {
#line 800
    return ((bus_t *)((void *)0));
  } else
#line 799
  if ((chain->parts)->len <= chain->active_part) {
#line 800
    return ((bus_t *)((void *)0));
  } else
#line 799
  if (chain->active_part < 0) {
#line 800
    return ((bus_t *)((void *)0));
  }
  {
#line 802
  tmp = malloc(sizeof(bus_t ));
#line 802
  bus___0 = (bus_t *)tmp;
  }
#line 803
  if (! bus___0) {
#line 804
    return ((bus_t *)((void *)0));
  }
  {
#line 806
  bus___0->driver = & pxa27x_bus;
#line 807
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___8 ));
  }
#line 808
  if (! bus___0->params) {
    {
#line 809
    free((void *)bus___0);
    }
#line 810
    return ((bus_t *)((void *)0));
  }
  {
#line 813
  ((bus_params_t___8 *)bus___0->params)->chain = chain;
#line 814
  ((bus_params_t___8 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 815
  ((bus_params_t___8 *)bus___0->params)->proc = 2;
#line 817
  failed = pxa2xx_bus_new_common(bus___0);
  }
#line 819
  if (failed) {
    {
#line 820
    free(bus___0->params);
#line 821
    free((void *)bus___0);
    }
#line 822
    return ((bus_t *)((void *)0));
  }
#line 825
  ((bus_params_t___8 *)bus___0->params)->inited = 0;
#line 827
  return (bus___0);
}
}
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  prototype_bus ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void setup_address___9(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int j ;
  part_t *p ;

  {
#line 78
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 80
  a >>= ((bus_params_t___9 *)bus___0->params)->ashift;
#line 82
  i = 0;
#line 82
  j = ((bus_params_t___9 *)bus___0->params)->alsbi;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 82
      goto while_break;
    }
    {
#line 83
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->a[j], 1, (int )((a >> i) & 1U));
#line 82
    i ++;
#line 82
    j += ((bus_params_t___9 *)bus___0->params)->ai;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static int prototype_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 89
  area->description = (char const   *)((void *)0);
#line 90
  area->start = 0U;
#line 91
  area->length = 4294967296UL;
#line 92
  area->width = (unsigned int )((bus_params_t___9 *)bus___0->params)->dw;
#line 94
  return (0);
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void set_data_in___9(bus_t *bus___0 ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 101
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 104
  prototype_bus_area(bus___0, (uint32_t )0, & area);
#line 106
  i = 0;
#line 106
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 106
      goto while_break;
    }
    {
#line 107
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 0, 0);
#line 106
    i ++;
#line 106
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void setup_data___9(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 114
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 117
  prototype_bus_area(bus___0, (uint32_t )0, & area);
#line 119
  i = 0;
#line 119
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 119
      goto while_break;
    }
    {
#line 120
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 1, (int )((d >> i) & 1U));
#line 119
    i ++;
#line 119
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < ((((bus_params_t___9 *)bus___0->params)->chain)->parts)->len)) {
#line 128
      goto while_break;
    }
#line 129
    if ((unsigned long )((bus_params_t___9 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___9 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 130
      goto while_break;
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp = gettext("Configurable prototype bus driver via BSR (JTAG part No. %d)\n");
#line 131
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 132
  return;
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 137
  part_set_instruction(((bus_params_t___9 *)bus___0->params)->part, "EXTEST");
#line 138
  chain_shift_instructions(((bus_params_t___9 *)bus___0->params)->chain);
  }
#line 139
  return;
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int tmp ;

  {
  {
#line 144
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 145
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 147
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 148
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 148
    tmp = 0;
  } else {
#line 148
    tmp = 1;
  }
  {
#line 148
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
#line 149
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, ((bus_params_t___9 *)bus___0->params)->oea);
#line 151
  setup_address___9(bus___0, adr);
#line 152
  set_data_in___9(bus___0);
#line 154
  chain_shift_data_registers(chain___0, 0);
  }
#line 155
  return;
}
}
#line 157 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static uint32_t prototype_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 160
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 161
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 163
  d = (uint32_t )0;
#line 166
  prototype_bus_area(bus___0, adr, & area);
#line 168
  setup_address___9(bus___0, adr);
#line 169
  chain_shift_data_registers(chain___0, 1);
#line 171
  i = 0;
#line 171
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 172
    d |= (uint32_t )(tmp << i);
#line 171
    i ++;
#line 171
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (d);
}
}
#line 177 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static uint32_t prototype_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 180
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 181
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 183
  d = (uint32_t )0;
#line 186
  prototype_bus_area(bus___0, (uint32_t )0, & area);
  }
#line 188
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 188
    tmp = 0;
  } else {
#line 188
    tmp = 1;
  }
  {
#line 188
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp);
  }
#line 189
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 189
    tmp___0 = 0;
  } else {
#line 189
    tmp___0 = 1;
  }
  {
#line 189
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 190
  chain_shift_data_registers(chain___0, 1);
#line 192
  i = 0;
#line 192
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 192
      goto while_break;
    }
    {
#line 193
    tmp___1 = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 193
    d |= (uint32_t )(tmp___1 << i);
#line 192
    i ++;
#line 192
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (d);
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static uint32_t prototype_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  int res ;
  uint32_t tmp ;

  {
  {
#line 203
  prototype_bus_read_start(bus___0, adr);
#line 204
  tmp = prototype_bus_read_end(bus___0);
#line 204
  res = (int )tmp;
  }
#line 206
  return ((uint32_t )res);
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 212
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 213
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 215
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 216
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 216
    tmp = 0;
  } else {
#line 216
    tmp = 1;
  }
  {
#line 216
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
  }
#line 217
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 217
    tmp___0 = 0;
  } else {
#line 217
    tmp___0 = 1;
  }
  {
#line 217
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 219
  setup_address___9(bus___0, adr);
#line 220
  setup_data___9(bus___0, data);
#line 222
  chain_shift_data_registers(chain___0, 0);
#line 224
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, ((bus_params_t___9 *)bus___0->params)->wea);
#line 225
  chain_shift_data_registers(chain___0, 0);
  }
#line 226
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 226
    tmp___1 = 0;
  } else {
#line 226
    tmp___1 = 1;
  }
  {
#line 226
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp___1);
  }
#line 227
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 227
    tmp___2 = 0;
  } else {
#line 227
    tmp___2 = 1;
  }
  {
#line 227
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp___2);
#line 228
  chain_shift_data_registers(chain___0, 0);
  }
#line 229
  return;
}
}
#line 231 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 234
  free(bus___0->params);
#line 235
  free((void *)bus___0);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static void prototype_bus_signal_parse(char *str , char *fmt , int *inst ) 
{ 
  char pre[16] ;
  char suf[16] ;
  int tmp ;

  {
  {
#line 243
  tmp = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%[^0-9]%d%s",
               pre, inst, suf);
  }
  {
#line 244
  if (tmp == 1) {
#line 244
    goto case_1;
  }
#line 247
  if (tmp == 2) {
#line 247
    goto case_2;
  }
#line 250
  if (tmp == 3) {
#line 250
    goto case_3;
  }
#line 243
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 245
  strcpy((char */* __restrict  */)fmt, (char const   */* __restrict  */)str);
  }
#line 246
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 248
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s", pre,
          "%d");
  }
#line 249
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 251
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s%s",
          pre, "%d", suf);
  }
  switch_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
static bus_t *prototype_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  signal_t *sig ;
  char buff[16] ;
  char fmt[16] ;
  char afmt[16] ;
  char dfmt[16] ;
  char param[16] ;
  char value[16] ;
  int i ;
  int j ;
  int inst ;
  int max ;
  int min ;
  int failed ;
  int ashift ;
  void *tmp ;
  signal_t *tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int nbytes ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;

  {
#line 262
  failed = 0;
#line 263
  ashift = -1;
#line 265
  if (! chain) {
#line 266
    return ((bus_t *)((void *)0));
  } else
#line 265
  if (! chain->parts) {
#line 266
    return ((bus_t *)((void *)0));
  } else
#line 265
  if ((chain->parts)->len <= chain->active_part) {
#line 266
    return ((bus_t *)((void *)0));
  } else
#line 265
  if (chain->active_part < 0) {
#line 266
    return ((bus_t *)((void *)0));
  }
  {
#line 268
  tmp = malloc(sizeof(bus_t ));
#line 268
  bus___0 = (bus_t *)tmp;
  }
#line 269
  if (! bus___0) {
#line 270
    return ((bus_t *)((void *)0));
  }
  {
#line 272
  bus___0->driver = & prototype_bus;
#line 273
  bus___0->params = malloc(sizeof(bus_params_t___9 ));
  }
#line 274
  if (! bus___0->params) {
    {
#line 275
    free((void *)bus___0);
    }
#line 276
    return ((bus_t *)((void *)0));
  }
#line 279
  ((bus_params_t___9 *)bus___0->params)->chain = chain;
#line 280
  ((bus_params_t___9 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 282
  tmp___1 = (signal_t *)((void *)0);
#line 282
  ((bus_params_t___9 *)bus___0->params)->we = tmp___1;
#line 282
  tmp___0 = tmp___1;
#line 282
  ((bus_params_t___9 *)bus___0->params)->oe = tmp___0;
#line 282
  ((bus_params_t___9 *)bus___0->params)->cs = tmp___0;
#line 283
  tmp___4 = -1;
#line 283
  ((bus_params_t___9 *)bus___0->params)->dmsbi = tmp___4;
#line 283
  tmp___3 = tmp___4;
#line 283
  ((bus_params_t___9 *)bus___0->params)->dlsbi = tmp___3;
#line 283
  tmp___2 = tmp___3;
#line 283
  ((bus_params_t___9 *)bus___0->params)->amsbi = tmp___2;
#line 283
  ((bus_params_t___9 *)bus___0->params)->alsbi = tmp___2;
#line 284
  i = 2;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! *(cmd_params___0 + i)) {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp___5 = strstr((char const   *)*(cmd_params___0 + i), "=");
    }
#line 285
    if (! tmp___5) {
#line 285
      goto __Cont;
    }
    {
#line 286
    sscanf((char const   */* __restrict  */)*(cmd_params___0 + i), (char const   */* __restrict  */)"%[^=]%*c%s",
           param, value);
#line 288
    tmp___11 = strcmp("amode", (char const   *)(param));
    }
#line 288
    if (! tmp___11) {
      {
#line 289
      tmp___10 = strcmp("x8", (char const   *)(value));
      }
#line 289
      if (tmp___10) {
        {
#line 291
        tmp___9 = strcmp("x16", (char const   *)(value));
        }
#line 291
        if (tmp___9) {
          {
#line 293
          tmp___8 = strcmp("x32", (char const   *)(value));
          }
#line 293
          if (tmp___8) {
            {
#line 295
            tmp___7 = strcmp("auto", (char const   *)(value));
            }
#line 295
            if (tmp___7) {
              {
#line 296
              tmp___6 = gettext("value %s not defined for parameter %s\n");
#line 296
              printf((char const   */* __restrict  */)tmp___6, value, param);
              }
            }
          } else {
#line 294
            ashift = 2;
          }
        } else {
#line 292
          ashift = 1;
        }
      } else {
#line 290
        ashift = 0;
      }
#line 297
      goto __Cont;
    }
    {
#line 300
    prototype_bus_signal_parse(value, fmt, & inst);
    }
#line 301
    if (inst > 31) {
#line 301
      goto __Cont;
    }
    {
#line 303
    sig = part_find_signal(((bus_params_t___9 *)bus___0->params)->part, (char const   *)(value));
    }
#line 304
    if (! sig) {
      {
#line 305
      tmp___12 = gettext("signal \'%s\' is not found\n");
#line 305
      printf((char const   */* __restrict  */)tmp___12, value);
#line 306
      failed = 1;
      }
    } else {
      {
#line 307
      tmp___23 = strcmp("alsb", (char const   *)(param));
      }
#line 307
      if (tmp___23) {
        {
#line 311
        tmp___22 = strcmp("amsb", (char const   *)(param));
        }
#line 311
        if (tmp___22) {
          {
#line 315
          tmp___21 = strcmp("dlsb", (char const   *)(param));
          }
#line 315
          if (tmp___21) {
            {
#line 319
            tmp___20 = strcmp("dmsb", (char const   *)(param));
            }
#line 319
            if (tmp___20) {
              {
#line 323
              tmp___18 = strcmp("cs", (char const   *)(param));
              }
#line 323
              if (tmp___18) {
                {
#line 323
                tmp___19 = strcmp("ncs", (char const   *)(param));
                }
#line 323
                if (tmp___19) {
                  {
#line 326
                  tmp___16 = strcmp("oe", (char const   *)(param));
                  }
#line 326
                  if (tmp___16) {
                    {
#line 326
                    tmp___17 = strcmp("noe", (char const   *)(param));
                    }
#line 326
                    if (tmp___17) {
                      {
#line 329
                      tmp___14 = strcmp("we", (char const   *)(param));
                      }
#line 329
                      if (tmp___14) {
                        {
#line 329
                        tmp___15 = strcmp("nwe", (char const   *)(param));
                        }
#line 329
                        if (tmp___15) {
                          {
#line 333
                          tmp___13 = gettext("parameter %s is unknown\n");
#line 333
                          printf((char const   */* __restrict  */)tmp___13, param);
#line 334
                          failed = 1;
                          }
                        } else {
#line 329
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
#line 330
                        ((bus_params_t___9 *)bus___0->params)->we = sig;
#line 331
                        if ((int )param[0] == 110) {
#line 331
                          ((bus_params_t___9 *)bus___0->params)->wea = 0;
                        } else {
#line 331
                          ((bus_params_t___9 *)bus___0->params)->wea = 1;
                        }
                      }
                    } else {
#line 326
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 327
                    ((bus_params_t___9 *)bus___0->params)->oe = sig;
#line 328
                    if ((int )param[0] == 110) {
#line 328
                      ((bus_params_t___9 *)bus___0->params)->oea = 0;
                    } else {
#line 328
                      ((bus_params_t___9 *)bus___0->params)->oea = 1;
                    }
                  }
                } else {
#line 323
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 324
                ((bus_params_t___9 *)bus___0->params)->cs = sig;
#line 325
                if ((int )param[0] == 110) {
#line 325
                  ((bus_params_t___9 *)bus___0->params)->csa = 0;
                } else {
#line 325
                  ((bus_params_t___9 *)bus___0->params)->csa = 1;
                }
              }
            } else {
              {
#line 320
              ((bus_params_t___9 *)bus___0->params)->dmsbi = inst;
#line 321
              ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 322
              strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
              }
            }
          } else {
            {
#line 316
            ((bus_params_t___9 *)bus___0->params)->dlsbi = inst;
#line 317
            ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 318
            strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
            }
          }
        } else {
          {
#line 312
          ((bus_params_t___9 *)bus___0->params)->amsbi = inst;
#line 313
          ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 314
          strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
          }
        }
      } else {
        {
#line 308
        ((bus_params_t___9 *)bus___0->params)->alsbi = inst;
#line 309
        ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 310
        strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 284
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  if (((bus_params_t___9 *)bus___0->params)->alsbi >= 0) {
#line 338
    goto _L___3;
  } else
#line 338
  if (((bus_params_t___9 *)bus___0->params)->amsbi >= 0) {
    _L___3: /* CIL Label */ 
#line 339
    if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 339
      goto _L___2;
    } else
#line 339
    if (((bus_params_t___9 *)bus___0->params)->amsbi == -1) {
      _L___2: /* CIL Label */ 
#line 340
      min = 0;
      {
#line 340
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 340
        if (! (min <= 31)) {
#line 340
          goto while_break___0;
        }
        {
#line 341
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                min);
#line 342
        ((bus_params_t___9 *)bus___0->params)->a[min] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                         (char const   *)(buff));
        }
#line 343
        if (((bus_params_t___9 *)bus___0->params)->a[min]) {
#line 343
          goto while_break___0;
        }
#line 340
        min ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 345
      max = 31;
      {
#line 345
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 345
        if (! (max >= 0)) {
#line 345
          goto while_break___1;
        }
        {
#line 346
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                max);
#line 347
        ((bus_params_t___9 *)bus___0->params)->a[max] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                         (char const   *)(buff));
        }
#line 348
        if (((bus_params_t___9 *)bus___0->params)->a[max]) {
#line 348
          goto while_break___1;
        }
#line 345
        max --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 350
      if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 351
        if (max - ((bus_params_t___9 *)bus___0->params)->amsbi < ((bus_params_t___9 *)bus___0->params)->amsbi - min) {
#line 351
          ((bus_params_t___9 *)bus___0->params)->alsbi = min;
        } else {
#line 351
          ((bus_params_t___9 *)bus___0->params)->alsbi = max;
        }
      } else
#line 353
      if (max - ((bus_params_t___9 *)bus___0->params)->alsbi < ((bus_params_t___9 *)bus___0->params)->alsbi - min) {
#line 353
        ((bus_params_t___9 *)bus___0->params)->amsbi = min;
      } else {
#line 353
        ((bus_params_t___9 *)bus___0->params)->amsbi = max;
      }
    }
#line 355
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 355
      ((bus_params_t___9 *)bus___0->params)->ai = 1;
    } else {
#line 355
      ((bus_params_t___9 *)bus___0->params)->ai = -1;
    }
#line 356
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 356
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->amsbi - ((bus_params_t___9 *)bus___0->params)->alsbi;
    } else {
#line 356
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->alsbi - ((bus_params_t___9 *)bus___0->params)->amsbi;
    }
#line 356
    ((bus_params_t___9 *)bus___0->params)->aw = tmp___24 + 1;
#line 357
    i = 0;
#line 357
    j = ((bus_params_t___9 *)bus___0->params)->alsbi;
    {
#line 357
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 357
      if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 357
        goto while_break___2;
      }
      {
#line 358
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
              j);
#line 359
      ((bus_params_t___9 *)bus___0->params)->a[j] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
#line 357
      i ++;
#line 357
      j += ((bus_params_t___9 *)bus___0->params)->ai;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 362
    tmp___25 = gettext("parameters alsb=<signal> and/or amsb=<signal> are not defined\n");
#line 362
    printf((char const   */* __restrict  */)tmp___25);
#line 363
    failed = 1;
    }
  }
#line 366
  if (((bus_params_t___9 *)bus___0->params)->dlsbi >= 0) {
#line 366
    goto _L___5;
  } else
#line 366
  if (((bus_params_t___9 *)bus___0->params)->dmsbi >= 0) {
    _L___5: /* CIL Label */ 
#line 367
    if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 367
      goto _L___4;
    } else
#line 367
    if (((bus_params_t___9 *)bus___0->params)->dmsbi == -1) {
      _L___4: /* CIL Label */ 
#line 368
      min = 0;
      {
#line 368
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 368
        if (! (min <= 31)) {
#line 368
          goto while_break___3;
        }
        {
#line 369
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                min);
#line 370
        ((bus_params_t___9 *)bus___0->params)->d[min] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                         (char const   *)(buff));
        }
#line 371
        if (((bus_params_t___9 *)bus___0->params)->d[min]) {
#line 371
          goto while_break___3;
        }
#line 368
        min ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 373
      max = 31;
      {
#line 373
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 373
        if (! (max >= 0)) {
#line 373
          goto while_break___4;
        }
        {
#line 374
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                max);
#line 375
        ((bus_params_t___9 *)bus___0->params)->d[max] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                         (char const   *)(buff));
        }
#line 376
        if (((bus_params_t___9 *)bus___0->params)->d[max]) {
#line 376
          goto while_break___4;
        }
#line 373
        max --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 379
        if (max - ((bus_params_t___9 *)bus___0->params)->dmsbi < ((bus_params_t___9 *)bus___0->params)->dmsbi - min) {
#line 379
          ((bus_params_t___9 *)bus___0->params)->dlsbi = min;
        } else {
#line 379
          ((bus_params_t___9 *)bus___0->params)->dlsbi = max;
        }
      } else
#line 381
      if (max - ((bus_params_t___9 *)bus___0->params)->dlsbi < ((bus_params_t___9 *)bus___0->params)->dlsbi - min) {
#line 381
        ((bus_params_t___9 *)bus___0->params)->dmsbi = min;
      } else {
#line 381
        ((bus_params_t___9 *)bus___0->params)->dmsbi = max;
      }
    }
#line 383
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 383
      ((bus_params_t___9 *)bus___0->params)->di = 1;
    } else {
#line 383
      ((bus_params_t___9 *)bus___0->params)->di = -1;
    }
#line 384
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 384
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dmsbi - ((bus_params_t___9 *)bus___0->params)->dlsbi;
    } else {
#line 384
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dlsbi - ((bus_params_t___9 *)bus___0->params)->dmsbi;
    }
#line 384
    ((bus_params_t___9 *)bus___0->params)->dw = tmp___26 + 1;
#line 385
    i = 0;
#line 385
    j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
    {
#line 385
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 385
      if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 385
        goto while_break___5;
      }
      {
#line 386
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
              j);
#line 387
      ((bus_params_t___9 *)bus___0->params)->d[j] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
#line 385
      i ++;
#line 385
      j += ((bus_params_t___9 *)bus___0->params)->di;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 392
    if (ashift < 0) {
#line 397
      nbytes = ((bus_params_t___9 *)bus___0->params)->dw / 8;
#line 398
      if (((bus_params_t___9 *)bus___0->params)->dw % 8 > 0) {
#line 399
        nbytes ++;
      }
#line 401
      ashift = 0;
      {
#line 402
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 402
        if (! (nbytes != 1)) {
#line 402
          goto while_break___6;
        }
#line 403
        nbytes >>= 1;
#line 404
        ashift ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 406
      ((bus_params_t___9 *)bus___0->params)->ashift = ashift;
    }
  } else {
    {
#line 410
    tmp___27 = gettext("parameters dlsb=<signal> and/or dmsb=<signal> are not defined\n");
#line 410
    printf((char const   */* __restrict  */)tmp___27);
#line 411
    failed = 1;
    }
  }
#line 414
  if (! ((bus_params_t___9 *)bus___0->params)->cs) {
    {
#line 415
    tmp___28 = gettext("parameter cs=<signal> or ncs=<signal> is not defined\n");
#line 415
    printf((char const   */* __restrict  */)tmp___28);
#line 416
    failed = 1;
    }
  }
#line 419
  if (! ((bus_params_t___9 *)bus___0->params)->oe) {
    {
#line 420
    tmp___29 = gettext("parameter oe=<signal> or noe=<signal> is not defined\n");
#line 420
    printf((char const   */* __restrict  */)tmp___29);
#line 421
    failed = 1;
    }
  }
#line 424
  if (! ((bus_params_t___9 *)bus___0->params)->we) {
    {
#line 425
    tmp___30 = gettext("parameter we=<signal> or nwe=<signal> is not defined\n");
#line 425
    printf((char const   */* __restrict  */)tmp___30);
#line 426
    failed = 1;
    }
  }
#line 429
  if (failed) {
    {
#line 430
    free(bus___0->params);
#line 431
    free((void *)bus___0);
    }
#line 432
    return ((bus_t *)((void *)0));
  }
#line 435
  return (bus___0);
}
}
#line 439 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/prototype.c"
struct bus_driver  const  prototype_bus  = 
#line 439
     {"prototype", "Configurable prototype bus driver via BSR, requires parameters:\n           amsb=<addr MSB> alsb=<addr LSB> dmsb=<data MSB> dlsb=<data LSB>\n           ncs=<CS#>|cs=<CS> noe=<OE#>|oe=<OE> nwe=<WE#>|we=<WE> [amode=auto|x8|x16|x32]",
    & prototype_bus_new, & prototype_bus_free, & prototype_bus_printinfo, & prototype_bus_prepare,
    & prototype_bus_area, & prototype_bus_read_start, & prototype_bus_read_next, & prototype_bus_read_end,
    & prototype_bus_read, & prototype_bus_write, (int (*)(bus_t *bus ))0};
#line 40 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  ppc440gx_ebc8_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void setup_address___10(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 61
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 32)) {
#line 63
      goto while_break;
    }
    {
#line 64
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void set_data_in___10(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 73
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 76
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned int )i < area.width)) {
#line 78
      goto while_break;
    }
    {
#line 79
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[i], 0, 0);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void setup_data___10(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 86
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 89
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )i < area.width)) {
#line 91
      goto while_break;
    }
    {
#line 92
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i], 1, (int )((d >> i) & 1U));
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < ((((bus_params_t___10 *)bus___0->params)->chain)->parts)->len)) {
#line 100
      goto while_break;
    }
#line 101
    if ((unsigned long )((bus_params_t___10 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___10 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 102
      goto while_break;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  tmp = gettext("IBM PowerPC 440GX 8-bit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 103
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 109
  part_set_instruction(((bus_params_t___10 *)bus___0->params)->part, "EXTEST");
#line 110
  chain_shift_instructions(((bus_params_t___10 *)bus___0->params)->chain);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 116
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 117
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 119
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 120
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 121
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 123
  setup_address___10(bus___0, adr);
#line 124
  set_data_in___10(bus___0);
#line 126
  chain_shift_data_registers(chain___0, 0);
  }
#line 127
  return;
}
}
#line 129 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 132
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 133
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 135
  d = (uint32_t )0;
#line 138
  ppc440gx_ebc8_bus_area(bus___0, adr, & area);
#line 140
  setup_address___10(bus___0, adr);
#line 141
  chain_shift_data_registers(chain___0, 1);
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned int )i < area.width)) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 144
    d |= (uint32_t )(tmp << i);
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (d);
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 152
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 153
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 155
  d = (uint32_t )0;
#line 158
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 160
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 162
  chain_shift_data_registers(chain___0, 1);
#line 164
  i = 0;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! ((unsigned int )i < area.width)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 165
    d |= (uint32_t )(tmp << i);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (d);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 173
  ppc440gx_ebc8_bus_read_start(bus___0, adr);
#line 174
  tmp = ppc440gx_ebc8_bus_read_end(bus___0);
  }
#line 174
  return (tmp);
}
}
#line 177 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 180
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 181
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 183
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 184
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 187
  setup_address___10(bus___0, adr);
#line 188
  setup_data___10(bus___0, data);
#line 190
  chain_shift_data_registers(chain___0, 0);
#line 192
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 193
  chain_shift_data_registers(chain___0, 0);
#line 194
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 196
  chain_shift_data_registers(chain___0, 0);
  }
#line 197
  return;
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 202
  area->description = (char const   *)((void *)0);
#line 203
  area->start = 0U;
#line 204
  area->length = 4294967296UL;
#line 205
  area->width = 8U;
#line 207
  return (0);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 213
  free(bus___0->params);
#line 214
  free((void *)bus___0);
  }
#line 215
  return;
}
}
#line 217
static bus_t *ppc440gx_ebc8_bus_new(char **cmd_params___0 ) ;
#line 219 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
struct bus_driver  const  ppc440gx_ebc8_bus  = 
#line 219
     {"ppc440gx_ebc8", "IBM PowerPC 440GX 8-bit EBC compatible bus driver via BSR",
    & ppc440gx_ebc8_bus_new, & ppc440gx_ebc8_bus_free, & ppc440gx_ebc8_bus_printinfo,
    & ppc440gx_ebc8_bus_prepare, & ppc440gx_ebc8_bus_area, & ppc440gx_ebc8_bus_read_start,
    & ppc440gx_ebc8_bus_read_next, & ppc440gx_ebc8_bus_read_end, & ppc440gx_ebc8_bus_read,
    & ppc440gx_ebc8_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 235 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc440gx_ebc8.c"
static bus_t *ppc440gx_ebc8_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 241
  failed = 0;
#line 243
  if (! chain) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if (! chain->parts) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if ((chain->parts)->len <= chain->active_part) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if (chain->active_part < 0) {
#line 244
    return ((bus_t *)((void *)0));
  }
  {
#line 246
  tmp = malloc(sizeof(bus_t ));
#line 246
  bus___0 = (bus_t *)tmp;
  }
#line 247
  if (! bus___0) {
#line 248
    return ((bus_t *)((void *)0));
  }
  {
#line 250
  bus___0->driver = & ppc440gx_ebc8_bus;
#line 251
  bus___0->params = malloc(sizeof(bus_params_t___10 ));
  }
#line 252
  if (! bus___0->params) {
    {
#line 253
    free((void *)bus___0);
    }
#line 254
    return ((bus_t *)((void *)0));
  }
#line 257
  ((bus_params_t___10 *)bus___0->params)->chain = chain;
#line 258
  ((bus_params_t___10 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 32)) {
#line 260
      goto while_break;
    }
    {
#line 261
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCADR%d",
            i);
#line 262
    ((bus_params_t___10 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 263
    if (! ((bus_params_t___10 *)bus___0->params)->a[i]) {
      {
#line 264
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 264
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 265
      failed = 1;
      }
#line 266
      goto while_break;
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i < 8)) {
#line 269
      goto while_break___0;
    }
    {
#line 270
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCDATA%d",
            i);
#line 271
    ((bus_params_t___10 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 272
    if (! ((bus_params_t___10 *)bus___0->params)->d[i]) {
      {
#line 273
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 273
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 274
      failed = 1;
      }
#line 275
      goto while_break___0;
    }
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 278
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCCS0_N");
#line 279
  ((bus_params_t___10 *)bus___0->params)->ncs = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 (char const   *)(buff));
  }
#line 280
  if (! ((bus_params_t___10 *)bus___0->params)->ncs) {
    {
#line 281
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 281
    printf((char const   */* __restrict  */)tmp___2, buff);
#line 282
    failed = 1;
    }
  }
  {
#line 284
  ((bus_params_t___10 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 "EBCWE_N");
  }
#line 285
  if (! ((bus_params_t___10 *)bus___0->params)->nwe) {
    {
#line 286
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 286
    printf((char const   */* __restrict  */)tmp___3, "nWE");
#line 287
    failed = 1;
    }
  }
  {
#line 289
  ((bus_params_t___10 *)bus___0->params)->noe = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 "EBCOE_N");
  }
#line 290
  if (! ((bus_params_t___10 *)bus___0->params)->noe) {
    {
#line 291
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 291
    printf((char const   */* __restrict  */)tmp___4, "nOE");
#line 292
    failed = 1;
    }
  }
#line 295
  if (failed) {
    {
#line 296
    free(bus___0->params);
#line 297
    free((void *)bus___0);
    }
#line 298
    return ((bus_t *)((void *)0));
  }
#line 301
  return (bus___0);
}
}
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  ppc405ep_bus ;
#line 55 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void setup_address___11(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 59
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 61
  i = 6;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 32)) {
#line 61
      goto while_break;
    }
    {
#line 62
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 61
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void set_data_in___11(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 71
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 74
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned int )i < area.width)) {
#line 76
      goto while_break;
    }
    {
#line 77
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i], 0, 0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void setup_data___11(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 84
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 87
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i], 1, (int )((d >> i) & 1U));
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void ppc405ep_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < ((((bus_params_t___11 *)bus___0->params)->chain)->parts)->len)) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )((bus_params_t___11 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___11 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 100
      goto while_break;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = gettext("IBM PowerPC 405EP compatible bus driver via BSR (JTAG part No. %d)\n");
#line 101
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void ppc405ep_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 107
  part_set_instruction(((bus_params_t___11 *)bus___0->params)->part, "EXTEST");
#line 108
  chain_shift_instructions(((bus_params_t___11 *)bus___0->params)->chain);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void ppc405ep_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 114
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 115
  chain___0 = ((bus_params_t___11 *)bus___0->params)->chain;
#line 117
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 118
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 119
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 0);
#line 121
  setup_address___11(bus___0, adr);
#line 122
  set_data_in___11(bus___0);
#line 124
  chain_shift_data_registers(chain___0, 0);
  }
#line 125
  return;
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 130
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 131
  chain___0 = ((bus_params_t___11 *)bus___0->params)->chain;
#line 133
  d = (uint32_t )0;
#line 136
  ppc405ep_bus_area(bus___0, adr, & area);
#line 138
  setup_address___11(bus___0, adr);
#line 139
  chain_shift_data_registers(chain___0, 1);
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned int )i < area.width)) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 142
    d |= (uint32_t )(tmp << i);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (d);
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 150
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 151
  chain___0 = ((bus_params_t___11 *)bus___0->params)->chain;
#line 153
  d = (uint32_t )0;
#line 156
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 158
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 159
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  int res ;
  uint32_t tmp ;

  {
  {
#line 173
  ppc405ep_bus_read_start(bus___0, adr);
#line 174
  tmp = ppc405ep_bus_read_end(bus___0);
#line 174
  res = (int )tmp;
  }
#line 176
  return ((uint32_t )res);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void ppc405ep_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 182
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 183
  chain___0 = ((bus_params_t___11 *)bus___0->params)->chain;
#line 185
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 186
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 189
  setup_address___11(bus___0, adr);
#line 190
  setup_data___11(bus___0, data);
#line 192
  chain_shift_data_registers(chain___0, 0);
#line 194
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 0);
#line 195
  chain_shift_data_registers(chain___0, 0);
#line 196
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 198
  chain_shift_data_registers(chain___0, 0);
  }
#line 199
  return;
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 204
  area->description = (char const   *)((void *)0);
#line 205
  area->start = 0U;
#line 206
  area->length = 4294967296UL;
#line 207
  area->width = 16U;
#line 209
  return (0);
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static void ppc405ep_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 215
  free(bus___0->params);
#line 216
  free((void *)bus___0);
  }
#line 217
  return;
}
}
#line 219
static bus_t *ppc405ep_bus_new(char **cmd_params___0 ) ;
#line 221 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
struct bus_driver  const  ppc405ep_bus  = 
#line 221
     {"ppc405ep", "IBM PowerPC 405EP compatible bus driver via BSR", & ppc405ep_bus_new,
    & ppc405ep_bus_free, & ppc405ep_bus_printinfo, & ppc405ep_bus_prepare, & ppc405ep_bus_area,
    & ppc405ep_bus_read_start, & ppc405ep_bus_read_next, & ppc405ep_bus_read_end,
    & ppc405ep_bus_read, & ppc405ep_bus_write, (int (*)(bus_t *bus ))0};
#line 236 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ppc405ep.c"
static bus_t *ppc405ep_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 242
  failed = 0;
#line 244
  if (! chain) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if (! chain->parts) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if ((chain->parts)->len <= chain->active_part) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if (chain->active_part < 0) {
#line 245
    return ((bus_t *)((void *)0));
  }
  {
#line 247
  tmp = malloc(sizeof(bus_t ));
#line 247
  bus___0 = (bus_t *)tmp;
  }
#line 248
  if (! bus___0) {
#line 249
    return ((bus_t *)((void *)0));
  }
  {
#line 251
  bus___0->driver = & ppc405ep_bus;
#line 252
  bus___0->params = malloc(sizeof(bus_params_t___11 ));
  }
#line 253
  if (! bus___0->params) {
    {
#line 254
    free((void *)bus___0);
    }
#line 255
    return ((bus_t *)((void *)0));
  }
#line 258
  ((bus_params_t___11 *)bus___0->params)->chain = chain;
#line 259
  ((bus_params_t___11 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 261
  i = 6;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 32)) {
#line 261
      goto while_break;
    }
    {
#line 262
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerAddr%d",
            i);
#line 263
    ((bus_params_t___11 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___11 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 264
    if (! ((bus_params_t___11 *)bus___0->params)->a[i]) {
      {
#line 265
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 265
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 266
      failed = 1;
      }
#line 267
      goto while_break;
    }
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (i < 16)) {
#line 270
      goto while_break___0;
    }
    {
#line 271
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerData%d",
            i);
#line 272
    ((bus_params_t___11 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___11 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 273
    if (! ((bus_params_t___11 *)bus___0->params)->d[i]) {
      {
#line 274
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 274
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 275
      failed = 1;
      }
#line 276
      goto while_break___0;
    }
#line 270
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 279
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerCS0");
#line 280
  ((bus_params_t___11 *)bus___0->params)->ncs = part_find_signal(((bus_params_t___11 *)bus___0->params)->part,
                                                                 (char const   *)(buff));
  }
#line 281
  if (! ((bus_params_t___11 *)bus___0->params)->ncs) {
    {
#line 282
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 282
    printf((char const   */* __restrict  */)tmp___2, "nCS0");
#line 283
    failed = 1;
    }
  }
  {
#line 285
  ((bus_params_t___11 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___11 *)bus___0->params)->part,
                                                                 "PerWBE1");
  }
#line 286
  if (! ((bus_params_t___11 *)bus___0->params)->nwe) {
    {
#line 287
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 287
    printf((char const   */* __restrict  */)tmp___3, "nWE");
#line 288
    failed = 1;
    }
  }
  {
#line 290
  ((bus_params_t___11 *)bus___0->params)->noe = part_find_signal(((bus_params_t___11 *)bus___0->params)->part,
                                                                 "PerOE");
  }
#line 291
  if (! ((bus_params_t___11 *)bus___0->params)->noe) {
    {
#line 292
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 292
    printf((char const   */* __restrict  */)tmp___4, "nOE");
#line 293
    failed = 1;
    }
  }
#line 296
  if (failed) {
    {
#line 297
    free(bus___0->params);
#line 298
    free((void *)bus___0);
    }
#line 299
    return ((bus_t *)((void *)0));
  }
#line 302
  return (bus___0);
}
}
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  mpc824x_bus ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void setup_address___12(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 70
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < 23)) {
#line 72
      goto while_break;
    }
    {
#line 73
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> i) & 1U));
#line 72
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 78 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void set_data_in___12(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 82
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 85
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 86
  if (area.width > 8U) {
#line 87
    return;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 0, 0);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void setup_data___12(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 97
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 100
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 101
  if (area.width > 8U) {
#line 102
    return;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned int )i < area.width)) {
#line 104
      goto while_break;
    }
    {
#line 105
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 104
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static uint32_t get_data___0(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 113
  d = (uint32_t )0;
#line 114
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 116
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 117
  if (area.width > 8U) {
#line 118
    return ((uint32_t )0);
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned int )i < area.width)) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp = part_get_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i]);
#line 121
    d |= (uint32_t )(tmp << i);
#line 120
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (d);
}
}
#line 126 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void mpc824x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < ((((bus_params_t___12 *)bus___0->params)->chain)->parts)->len)) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned long )((bus_params_t___12 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___12 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 133
      goto while_break;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp = gettext("Motorola MPC824x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 134
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void mpc824x_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 140
  part_set_instruction(((bus_params_t___12 *)bus___0->params)->part, "EXTEST");
#line 141
  chain_shift_instructions(((bus_params_t___12 *)bus___0->params)->chain);
  }
#line 142
  return;
}
}
#line 144 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void mpc824x_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 147
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 149
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 152
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 153
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 154
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 0);
#line 156
  setup_address___12(bus___0, adr);
#line 157
  set_data_in___12(bus___0, adr);
#line 159
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 0);
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 167
  setup_address___12(bus___0, adr);
#line 168
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 1);
#line 170
  d = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
#line 171
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
  }
#line 172
  return (d);
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 178
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 180
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 183
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 1);
#line 185
  tmp = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
  }
#line 185
  return (tmp);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  mpc824x_bus_read_start(bus___0, adr);
#line 192
  tmp = mpc824x_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void mpc824x_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 199
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 200
  chain___0 = ((bus_params_t___12 *)bus___0->params)->chain;
#line 202
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 206
  setup_address___12(bus___0, adr);
#line 207
  setup_data___12(bus___0, adr, data);
#line 209
  chain_shift_data_registers(chain___0, 0);
#line 211
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 0);
#line 212
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 214
  chain_shift_data_registers(chain___0, 0);
  }
#line 215
  return;
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 220
  if (adr < 4278190080U) {
#line 221
    area->description = (char const   *)((void *)0);
#line 222
    area->start = 0U;
#line 223
    area->length = 4278190080UL;
#line 224
    area->width = 0U;
#line 226
    return (0);
  }
#line 229
  if (adr < 4286578688U) {
#line 230
    area->description = "Base ROM Interface (Bank 1)";
#line 231
    area->start = 4278190080U;
#line 232
    area->length = 8388608UL;
#line 233
    area->width = 0U;
#line 235
    return (0);
  }
#line 238
  if (((bus_params_t___12 *)bus___0->params)->boot_sdma1 == 0) {
#line 239
    area->description = "Base ROM Interface (Bank 0)";
#line 240
    area->start = 4286578688U;
#line 241
    area->length = 8388608UL;
#line 242
    if (((bus_params_t___12 *)bus___0->params)->boot_nfoe != 0) {
#line 242
      area->width = 8U;
    } else {
#line 242
      area->width = 0U;
    }
#line 244
    return (0);
  }
#line 248
  if (adr < 4290772992U) {
#line 249
    area->description = (char const   *)((void *)0);
#line 250
    area->start = 4286578688U;
#line 251
    area->length = 4194304UL;
#line 252
    area->width = 0U;
#line 254
    return (0);
  }
#line 257
  area->description = "Base ROM Interface (Bank 0)";
#line 258
  area->start = 4290772992U;
#line 259
  area->length = 4194304UL;
#line 260
  if (((bus_params_t___12 *)bus___0->params)->boot_nfoe != 0) {
#line 260
    area->width = 8U;
  } else {
#line 260
    area->width = 0U;
  }
#line 262
  return (0);
}
}
#line 265 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static void mpc824x_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 268
  free(bus___0->params);
#line 269
  free((void *)bus___0);
  }
#line 270
  return;
}
}
#line 272 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
static bus_t *mpc824x_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  signal_t *s_nfoe ;
  signal_t *s_sdma1 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 278
  failed = 0;
#line 283
  if (! chain) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if (! chain->parts) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if ((chain->parts)->len <= chain->active_part) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if (chain->active_part < 0) {
#line 284
    return ((bus_t *)((void *)0));
  }
  {
#line 286
  tmp = malloc(sizeof(bus_t ));
#line 286
  bus___0 = (bus_t *)tmp;
  }
#line 287
  if (! bus___0) {
#line 288
    return ((bus_t *)((void *)0));
  }
  {
#line 290
  bus___0->driver = & mpc824x_bus;
#line 291
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___12 ));
  }
#line 292
  if (! bus___0->params) {
    {
#line 293
    free((void *)bus___0);
    }
#line 294
    return ((bus_t *)((void *)0));
  }
  {
#line 297
  ((bus_params_t___12 *)bus___0->params)->chain = chain;
#line 298
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 298
  ((bus_params_t___12 *)bus___0->params)->part = part___0;
#line 300
  s_nfoe = part_find_signal(part___0, "nFOE");
#line 301
  s_sdma1 = part_find_signal(part___0, "SDMA1");
#line 302
  part_set_signal(part___0, s_nfoe, 0, 0);
#line 303
  part_set_signal(part___0, s_sdma1, 0, 0);
#line 305
  part_set_instruction(part___0, "SAMPLE/PRELOAD");
#line 306
  chain_shift_instructions(chain);
#line 307
  chain_shift_data_registers(chain, 0);
#line 308
  part_set_instruction(part___0, "EXTEST");
#line 309
  chain_shift_instructions(chain);
#line 310
  chain_shift_data_registers(chain, 1);
#line 312
  ((bus_params_t___12 *)bus___0->params)->boot_nfoe = part_get_signal(part___0, s_nfoe);
#line 313
  ((bus_params_t___12 *)bus___0->params)->boot_sdma1 = part_get_signal(part___0, s_sdma1);
#line 315
  i = 0;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i <= 10)) {
#line 315
      goto while_break;
    }
    {
#line 316
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDMA%d",
            i);
#line 317
    ((bus_params_t___12 *)bus___0->params)->ar[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 318
    if (! ((bus_params_t___12 *)bus___0->params)->ar[i]) {
      {
#line 319
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 319
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 320
      failed = 1;
      }
#line 321
      goto while_break;
    }
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  ((bus_params_t___12 *)bus___0->params)->ar[11] = part_find_signal(part___0, "SDBA0");
  }
#line 325
  if (! ((bus_params_t___12 *)bus___0->params)->ar[11]) {
    {
#line 326
    tmp___1 = gettext("signal \'%s\' not found\n");
#line 326
    printf((char const   */* __restrict  */)tmp___1, "SDBA0");
#line 327
    failed = 1;
    }
  }
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 329
    if (! (i < 8)) {
#line 329
      goto while_break___0;
    }
    {
#line 330
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PAR%d",
            i);
#line 331
    ((bus_params_t___12 *)bus___0->params)->ar[19 - i] = part_find_signal(part___0,
                                                                          (char const   *)(buff));
    }
#line 332
    if (! ((bus_params_t___12 *)bus___0->params)->ar[19 - i]) {
      {
#line 333
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 333
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 334
      failed = 1;
      }
#line 335
      goto while_break___0;
    }
#line 329
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  ((bus_params_t___12 *)bus___0->params)->ar[20] = part_find_signal(part___0, "SDBA1");
  }
#line 339
  if (! ((bus_params_t___12 *)bus___0->params)->ar[20]) {
    {
#line 340
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 340
    printf((char const   */* __restrict  */)tmp___3, "SDBA1");
#line 341
    failed = 1;
    }
  }
  {
#line 343
  ((bus_params_t___12 *)bus___0->params)->ar[21] = part_find_signal(part___0, "SDMA11");
  }
#line 344
  if (! ((bus_params_t___12 *)bus___0->params)->ar[21]) {
    {
#line 345
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 345
    printf((char const   */* __restrict  */)tmp___4, "SDMA11");
#line 346
    failed = 1;
    }
  }
  {
#line 348
  ((bus_params_t___12 *)bus___0->params)->ar[22] = part_find_signal(part___0, "SDMA12");
  }
#line 349
  if (! ((bus_params_t___12 *)bus___0->params)->ar[22]) {
    {
#line 350
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 350
    printf((char const   */* __restrict  */)tmp___5, "SDMA12");
#line 351
    failed = 1;
    }
  }
  {
#line 353
  ((bus_params_t___12 *)bus___0->params)->nrcs0 = part_find_signal(part___0, "nRCS0");
  }
#line 354
  if (! ((bus_params_t___12 *)bus___0->params)->nrcs0) {
    {
#line 355
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 355
    printf((char const   */* __restrict  */)tmp___6, "nRCS0");
#line 356
    failed = 1;
    }
  }
  {
#line 358
  ((bus_params_t___12 *)bus___0->params)->nwe = part_find_signal(part___0, "nWE");
  }
#line 359
  if (! ((bus_params_t___12 *)bus___0->params)->nwe) {
    {
#line 360
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 360
    printf((char const   */* __restrict  */)tmp___7, "nWE");
#line 361
    failed = 1;
    }
  }
  {
#line 363
  ((bus_params_t___12 *)bus___0->params)->nfoe = part_find_signal(part___0, "nFOE");
  }
#line 364
  if (! ((bus_params_t___12 *)bus___0->params)->nwe) {
    {
#line 365
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 365
    printf((char const   */* __restrict  */)tmp___8, "nFOE");
#line 366
    failed = 1;
    }
  }
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (i < 8)) {
#line 368
      goto while_break___1;
    }
    {
#line 369
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MDH%d",
            i);
#line 370
    ((bus_params_t___12 *)bus___0->params)->d[7 - i] = part_find_signal(part___0,
                                                                        (char const   *)(buff));
    }
#line 371
    if (! ((bus_params_t___12 *)bus___0->params)->d[7 - i]) {
      {
#line 372
      tmp___9 = gettext("signal \'%s\' not found\n");
#line 372
      printf((char const   */* __restrict  */)tmp___9, buff);
#line 373
      failed = 1;
      }
#line 374
      goto while_break___1;
    }
#line 368
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 378
  if (failed) {
    {
#line 379
    free(bus___0->params);
#line 380
    free((void *)bus___0);
    }
#line 381
    return ((bus_t *)((void *)0));
  }
#line 384
  return (bus___0);
}
}
#line 387 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc824x.c"
struct bus_driver  const  mpc824x_bus  = 
#line 387
     {"mpc824x", "Motorola MPC824x compatible bus driver via BSR", & mpc824x_bus_new,
    & mpc824x_bus_free, & mpc824x_bus_printinfo, & mpc824x_bus_prepare, & mpc824x_bus_area,
    & mpc824x_bus_read_start, & mpc824x_bus_read_next, & mpc824x_bus_read_end, & mpc824x_bus_read,
    & mpc824x_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  mpc5200_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void setup_address___13(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 24)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void set_data_in___13(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 81
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 82
  if (area.width > 8U) {
#line 83
    return;
  }
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned int )i < area.width)) {
#line 85
      goto while_break;
    }
    {
#line 86
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 0, 0);
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void setup_data___13(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 93
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 96
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 97
  if (area.width > 8U) {
#line 98
    return;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((unsigned int )i < area.width)) {
#line 100
      goto while_break;
    }
    {
#line 101
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static uint32_t get_data___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 109
  d = (uint32_t )0;
#line 110
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 112
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 113
  if (area.width > 8U) {
#line 114
    return ((uint32_t )0);
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned int )i < area.width)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp = part_get_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i]);
#line 117
    d |= (uint32_t )(tmp << i);
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (d);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void mpc5200_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < ((((bus_params_t___13 *)bus___0->params)->chain)->parts)->len)) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )((bus_params_t___13 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___13 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 129
      goto while_break;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = gettext("Freescale MPC5200 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 130
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void mpc5200_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 136
  part_set_instruction(((bus_params_t___13 *)bus___0->params)->part, "EXTEST");
#line 137
  chain_shift_instructions(((bus_params_t___13 *)bus___0->params)->chain);
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void mpc5200_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 143
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 145
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
#line 148
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 0);
#line 149
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[1], 1, 1);
#line 150
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[2], 1, 1);
#line 151
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[3], 1, 1);
#line 152
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 153
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 0);
#line 155
  setup_address___13(bus___0, adr);
#line 156
  set_data_in___13(bus___0, adr);
#line 158
  chain_shift_data_registers(((bus_params_t___13 *)bus___0->params)->chain, 0);
  }
#line 159
  return;
}
}
#line 161 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 166
  setup_address___13(bus___0, adr);
#line 167
  chain_shift_data_registers(((bus_params_t___13 *)bus___0->params)->chain, 1);
#line 169
  d = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
#line 170
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
  }
#line 171
  return (d);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 177
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 179
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 182
  chain_shift_data_registers(((bus_params_t___13 *)bus___0->params)->chain, 1);
#line 184
  tmp = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 190
  mpc5200_bus_read_start(bus___0, adr);
#line 191
  tmp = mpc5200_bus_read_end(bus___0);
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void mpc5200_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 198
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 199
  chain___0 = ((bus_params_t___13 *)bus___0->params)->chain;
#line 201
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 0);
#line 202
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[1], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[2], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[3], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 208
  setup_address___13(bus___0, adr);
#line 209
  setup_data___13(bus___0, adr, data);
#line 211
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 0);
#line 214
  chain_shift_data_registers(chain___0, 0);
#line 215
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 216
  chain_shift_data_registers(chain___0, 0);
  }
#line 217
  return;
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 222
  if (adr < 16777216U) {
#line 224
    area->description = "LocalPlus Bus";
#line 225
    area->start = 0U;
#line 226
    area->length = 16777216UL;
#line 227
    area->width = 8U;
#line 228
    return (0);
  }
#line 231
  area->description = (char const   *)((void *)0);
#line 232
  area->start = (uint32_t )16777216;
#line 233
  area->length = (uint64_t )4278190080U;
#line 234
  area->width = 0U;
#line 235
  return (0);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static void mpc5200_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 241
  free(bus___0->params);
#line 242
  free((void *)bus___0);
  }
#line 243
  return;
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
static bus_t *mpc5200_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 251
  failed = 0;
#line 254
  if (! chain) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if (! chain->parts) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if ((chain->parts)->len <= chain->active_part) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if (chain->active_part < 0) {
#line 255
    return ((bus_t *)((void *)0));
  }
  {
#line 257
  tmp = malloc(sizeof(bus_t ));
#line 257
  bus___0 = (bus_t *)tmp;
  }
#line 258
  if (! bus___0) {
#line 259
    return ((bus_t *)((void *)0));
  }
  {
#line 261
  bus___0->driver = & mpc5200_bus;
#line 262
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___13 ));
  }
#line 263
  if (! bus___0->params) {
    {
#line 264
    free((void *)bus___0);
    }
#line 265
    return ((bus_t *)((void *)0));
  }
#line 268
  ((bus_params_t___13 *)bus___0->params)->chain = chain;
#line 269
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 269
  ((bus_params_t___13 *)bus___0->params)->part = part___0;
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < 24)) {
#line 272
      goto while_break;
    }
    {
#line 273
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i);
#line 274
    ((bus_params_t___13 *)bus___0->params)->ad[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 275
    if (! ((bus_params_t___13 *)bus___0->params)->ad[i]) {
      {
#line 276
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 276
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 277
      failed = 1;
      }
#line 278
      goto while_break;
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < 4)) {
#line 281
      goto while_break___0;
    }
    {
#line 282
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"LP_CS%d_B",
            i);
#line 283
    ((bus_params_t___13 *)bus___0->params)->ncs[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 284
    if (! ((bus_params_t___13 *)bus___0->params)->ncs[i]) {
      {
#line 285
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 285
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 286
      failed = 1;
      }
#line 287
      goto while_break___0;
    }
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 290
  ((bus_params_t___13 *)bus___0->params)->nwe = part_find_signal(part___0, "LP_RW");
  }
#line 291
  if (! ((bus_params_t___13 *)bus___0->params)->nwe) {
    {
#line 292
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 292
    printf((char const   */* __restrict  */)tmp___2, "LP_RW");
#line 293
    failed = 1;
    }
  }
  {
#line 295
  ((bus_params_t___13 *)bus___0->params)->noe = part_find_signal(part___0, "LP_OE");
  }
#line 296
  if (! ((bus_params_t___13 *)bus___0->params)->noe) {
    {
#line 297
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 297
    printf((char const   */* __restrict  */)tmp___3, "LP_OE");
#line 298
    failed = 1;
    }
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 300
    if (! (i < 8)) {
#line 300
      goto while_break___1;
    }
    {
#line 301
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i + 24);
#line 302
    ((bus_params_t___13 *)bus___0->params)->d[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 303
    if (! ((bus_params_t___13 *)bus___0->params)->d[i]) {
      {
#line 304
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 304
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 305
      failed = 1;
      }
#line 306
      goto while_break___1;
    }
#line 300
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 310
  if (failed) {
    {
#line 311
    free(bus___0->params);
#line 312
    free((void *)bus___0);
    }
#line 313
    return ((bus_t *)((void *)0));
  }
#line 316
  return (bus___0);
}
}
#line 319 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/mpc5200.c"
struct bus_driver  const  mpc5200_bus  = 
#line 319
     {"mpc5200", "Freescale MPC5200 compatible bus driver via BSR", & mpc5200_bus_new,
    & mpc5200_bus_free, & mpc5200_bus_printinfo, & mpc5200_bus_prepare, & mpc5200_bus_area,
    & mpc5200_bus_read_start, & mpc5200_bus_read_next, & mpc5200_bus_read_end, & mpc5200_bus_read,
    & mpc5200_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  lh7a400_bus ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void setup_address___14(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 24)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void set_data_in___14(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 89
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 92
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 94
  i = 0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((unsigned int )i < area.width)) {
#line 94
      goto while_break;
    }
    {
#line 95
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 0, 0);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void setup_data___14(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 103
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 106
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 108
  i = 0;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned int )i < area.width)) {
#line 108
      goto while_break;
    }
    {
#line 109
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void lh7a400_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < ((((bus_params_t___14 *)bus___0->params)->chain)->parts)->len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )((bus_params_t___14 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___14 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 119
      goto while_break;
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp = gettext("Sharp LH7A400 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 120
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 121
  return;
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void lh7a400_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 126
  part_set_instruction(((bus_params_t___14 *)bus___0->params)->part, "EXTEST");
#line 127
  chain_shift_instructions(((bus_params_t___14 *)bus___0->params)->chain);
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void lh7a400_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 134
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 135
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 137
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 138
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 139
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 0);
#line 141
  setup_address___14(bus___0, adr);
#line 142
  set_data_in___14(bus___0);
#line 144
  chain_shift_data_registers(chain___0, 0);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 151
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 152
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 154
  d = (uint32_t )0;
#line 157
  lh7a400_bus_area(bus___0, adr, & area);
#line 159
  setup_address___14(bus___0, adr);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 172
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 173
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 175
  d = (uint32_t )0;
#line 178
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 180
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 183
  chain_shift_data_registers(chain___0, 1);
#line 185
  i = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! ((unsigned int )i < area.width)) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 186
    d |= (uint32_t )(tmp << i);
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (d);
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 194
  lh7a400_bus_read_start(bus___0, adr);
#line 195
  tmp = lh7a400_bus_read_end(bus___0);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void lh7a400_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 202
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 203
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 205
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 206
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 209
  setup_address___14(bus___0, adr);
#line 210
  setup_data___14(bus___0, data);
#line 212
  chain_shift_data_registers(chain___0, 0);
#line 214
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 0);
#line 215
  chain_shift_data_registers(chain___0, 0);
#line 217
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 218
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 219
  chain_shift_data_registers(chain___0, 0);
  }
#line 220
  return;
}
}
#line 222 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  unsigned int width ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 227
  area->description = (char const   *)((void *)0);
#line 228
  area->start = 0U;
#line 229
  area->length = 268435456UL;
#line 232
  tmp = part_find_signal(((bus_params_t___14 *)bus___0->params)->part, "WIDTH0");
#line 232
  tmp___0 = part_get_signal(((bus_params_t___14 *)bus___0->params)->part, tmp);
#line 232
  width = (unsigned int )tmp___0;
#line 233
  tmp___1 = part_find_signal(((bus_params_t___14 *)bus___0->params)->part, "WIDTH1");
#line 233
  tmp___2 = part_get_signal(((bus_params_t___14 *)bus___0->params)->part, tmp___1);
#line 233
  width |= (unsigned int )(tmp___2 << 1);
  }
#line 235
  if (width < 0U) {
#line 236
    return (-1);
  }
  {
#line 239
  if (width == 0U) {
#line 239
    goto case_0;
  }
#line 242
  if (width == 1U) {
#line 242
    goto case_1;
  }
#line 246
  if (width == 3U) {
#line 246
    goto case_3;
  }
#line 246
  if (width == 2U) {
#line 246
    goto case_3;
  }
#line 238
  goto switch_break;
  case_0: /* CIL Label */ 
#line 240
  area->width = 8U;
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
#line 243
  area->width = 16U;
#line 244
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 247
  area->width = 32U;
  switch_break: /* CIL Label */ ;
  }
#line 250
  return (0);
}
}
#line 253 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static void lh7a400_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 256
  free(bus___0->params);
#line 257
  free((void *)bus___0);
  }
#line 258
  return;
}
}
#line 260
static bus_t *lh7a400_bus_new(char **cmd_params___0 ) ;
#line 262 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
struct bus_driver  const  lh7a400_bus  = 
#line 262
     {"lh7a400", "Sharp LH7A400 compatible bus driver via BSR (flash access only!)",
    & lh7a400_bus_new, & lh7a400_bus_free, & lh7a400_bus_printinfo, & lh7a400_bus_prepare,
    & lh7a400_bus_area, & lh7a400_bus_read_start, & lh7a400_bus_read_next, & lh7a400_bus_read_end,
    & lh7a400_bus_read, & lh7a400_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 278 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/lh7a400.c"
static bus_t *lh7a400_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 284
  failed = 0;
#line 286
  if (! chain) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (! chain->parts) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if ((chain->parts)->len <= chain->active_part) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (chain->active_part < 0) {
#line 287
    return ((bus_t *)((void *)0));
  }
  {
#line 289
  tmp = malloc(sizeof(bus_t ));
#line 289
  bus___0 = (bus_t *)tmp;
  }
#line 290
  if (! bus___0) {
#line 291
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  bus___0->driver = & lh7a400_bus;
#line 294
  bus___0->params = malloc(sizeof(bus_params_t___14 ));
  }
#line 295
  if (! bus___0->params) {
    {
#line 296
    free((void *)bus___0);
    }
#line 297
    return ((bus_t *)((void *)0));
  }
#line 300
  ((bus_params_t___14 *)bus___0->params)->chain = chain;
#line 301
  ((bus_params_t___14 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 24)) {
#line 303
      goto while_break;
    }
    {
#line 304
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 305
    ((bus_params_t___14 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 306
    if (! ((bus_params_t___14 *)bus___0->params)->a[i]) {
      {
#line 307
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 307
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 308
      failed = 1;
      }
#line 309
      goto while_break;
    }
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < 32)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 314
    ((bus_params_t___14 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 315
    if (! ((bus_params_t___14 *)bus___0->params)->d[i]) {
      {
#line 316
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 316
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 317
      failed = 1;
      }
#line 318
      goto while_break___0;
    }
#line 312
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 321
  i = 0;
  {
#line 321
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 321
    if (! (i < 4)) {
#line 321
      goto while_break___1;
    }
    {
#line 322
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 323
    ((bus_params_t___14 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 324
    if (! ((bus_params_t___14 *)bus___0->params)->ncs[i]) {
      {
#line 325
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 325
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 326
      failed = 1;
      }
#line 327
      goto while_break___1;
    }
#line 321
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 330
    if (! (i < 2)) {
#line 330
      goto while_break___2;
    }
    {
#line 331
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WIDTH%d",
            i);
#line 332
    ((bus_params_t___14 *)bus___0->params)->width[i] = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 333
    if (! ((bus_params_t___14 *)bus___0->params)->width[i]) {
      {
#line 334
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 334
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 335
      failed = 1;
      }
#line 336
      goto while_break___2;
    }
#line 330
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 339
  ((bus_params_t___14 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                 "nWE0");
  }
#line 340
  if (! ((bus_params_t___14 *)bus___0->params)->nwe) {
    {
#line 341
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 341
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 342
    failed = 1;
    }
  }
  {
#line 344
  ((bus_params_t___14 *)bus___0->params)->noe = part_find_signal(((bus_params_t___14 *)bus___0->params)->part,
                                                                 "nOE");
  }
#line 345
  if (! ((bus_params_t___14 *)bus___0->params)->noe) {
    {
#line 346
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 346
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 347
    failed = 1;
    }
  }
#line 350
  if (failed) {
    {
#line 351
    free(bus___0->params);
#line 352
    free((void *)bus___0);
    }
#line 353
    return ((bus_t *)((void *)0));
  }
#line 356
  return (bus___0);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  jopcyc_bus ;
#line 134 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static uint32_t last_address___0  =    (uint32_t )0;
#line 136 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void setup_address___15(bus_t *bus___0 , uint32_t a , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 140
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 143
  last_address___0 = a;
  {
#line 146
  if ((unsigned int )comp->ctype == 0U) {
#line 146
    goto case_0;
  }
#line 152
  if ((unsigned int )comp->ctype == 1U) {
#line 152
    goto case_1;
  }
#line 155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 147
  addr_width = 18;
#line 150
  a >>= 1;
#line 151
  goto switch_break;
  case_1: /* CIL Label */ 
#line 153
  addr_width = 19;
#line 154
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 156
  addr_width = 0;
#line 157
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < addr_width)) {
#line 160
      goto while_break;
    }
    {
#line 161
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static int detect_data_width___0(component_t___0 *comp ) 
{ 
  int width ;

  {
  {
#line 170
  if ((unsigned int )comp->ctype == 0U) {
#line 170
    goto case_0;
  }
#line 173
  if ((unsigned int )comp->ctype == 1U) {
#line 173
    goto case_1;
  }
#line 176
  goto switch_default;
  case_0: /* CIL Label */ 
#line 171
  width = 16;
#line 172
  goto switch_break;
  case_1: /* CIL Label */ 
#line 174
  width = 8;
#line 175
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 177
  width = 0;
#line 178
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 181
  return (width);
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void set_data_in___15(bus_t *bus___0 , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 188
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 191
  width = detect_data_width___0(comp);
#line 193
  i = 0;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (i < width)) {
#line 193
      goto while_break;
    }
    {
#line 194
    part_set_signal(p, comp->d[i], 0, 0);
#line 193
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return;
}
}
#line 197 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void setup_data___15(bus_t *bus___0 , uint32_t d , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 201
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 204
  width = detect_data_width___0(comp);
#line 206
  i = 0;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < width)) {
#line 206
      goto while_break;
    }
    {
#line 207
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t___0 **comp ) ;
#line 216 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void jopcyc_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 221
  i = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < ((((bus_params_t___15 *)bus___0->params)->chain)->parts)->len)) {
#line 221
      goto while_break;
    }
#line 222
    if ((unsigned long )((bus_params_t___15 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___15 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 223
      goto while_break;
    }
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  tmp = gettext("JOP.design Cyclone Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 224
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 225
  return;
}
}
#line 231 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void jopcyc_bus_prepare(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  component_t___0 *comp ;

  {
  {
#line 234
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 235
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 241
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 242
  chain_shift_instructions(chain___0);
#line 245
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 246
  set_data_in___15(bus___0, comp);
#line 247
  part_set_signal(p, comp->ncs, 1, 1);
#line 248
  part_set_signal(p, comp->nwe, 1, 1);
#line 249
  part_set_signal(p, comp->noe, 1, 1);
#line 250
  part_set_signal(p, comp->nlb, 1, 1);
#line 251
  part_set_signal(p, comp->nub, 1, 1);
#line 254
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 255
  set_data_in___15(bus___0, comp);
#line 256
  part_set_signal(p, comp->ncs, 1, 1);
#line 257
  part_set_signal(p, comp->nwe, 1, 1);
#line 258
  part_set_signal(p, comp->noe, 1, 1);
#line 259
  part_set_signal(p, comp->nlb, 1, 1);
#line 260
  part_set_signal(p, comp->nub, 1, 1);
#line 263
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 264
  set_data_in___15(bus___0, comp);
#line 265
  part_set_signal(p, comp->ncs, 1, 1);
#line 266
  part_set_signal(p, comp->nwe, 1, 1);
#line 267
  part_set_signal(p, comp->noe, 1, 1);
#line 268
  part_set_signal(p, comp->ncs2, 1, 1);
#line 269
  part_set_signal(p, comp->nrdy, 0, 0);
#line 272
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_rxd, 0, 0);
#line 273
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_nrts, 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_txd, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_ncts, 0, 0);
#line 277
  chain_shift_data_registers(chain___0, 0);
#line 279
  part_set_instruction(p, "EXTEST");
#line 280
  chain_shift_instructions(chain___0);
  }
#line 281
  return;
}
}
#line 287 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void jopcyc_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 290
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 291
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 295
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 296
  if (! comp) {
    {
#line 297
    tmp = gettext("Address out of range\n");
#line 297
    printf((char const   */* __restrict  */)tmp);
#line 298
    last_address___0 = adr;
    }
#line 299
    return;
  }
  {
#line 302
  part_set_signal(p, comp->ncs, 1, 0);
#line 303
  part_set_signal(p, comp->nwe, 1, 1);
#line 304
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 305
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 306
    part_set_signal(p, comp->nlb, 1, 0);
#line 307
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 310
  setup_address___15(bus___0, adr, comp);
#line 311
  set_data_in___15(bus___0, comp);
#line 313
  chain_shift_data_registers(chain___0, 0);
  }
#line 314
  return;
}
}
#line 320 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 323
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 324
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 326
  d = (uint32_t )0;
#line 330
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 331
  if (! comp) {
    {
#line 332
    tmp = gettext("Address out of range\n");
#line 332
    printf((char const   */* __restrict  */)tmp);
#line 333
    last_address___0 = adr;
    }
#line 334
    return ((uint32_t )0);
  }
  {
#line 337
  setup_address___15(bus___0, adr, comp);
#line 338
  chain_shift_data_registers(chain___0, 1);
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! ((unsigned int )i < area.width)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 341
    d |= (uint32_t )(tmp___0 << i);
#line 340
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (d);
}
}
#line 350 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 353
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 354
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 356
  d = (uint32_t )0;
#line 361
  comp_bus_area___0(bus___0, last_address___0, & area, & comp);
  }
#line 362
  if (! comp) {
    {
#line 363
    tmp = gettext("Address out of range\n");
#line 363
    printf((char const   */* __restrict  */)tmp);
    }
#line 364
    return ((uint32_t )0);
  }
  {
#line 367
  part_set_signal(p, comp->ncs, 1, 1);
#line 368
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 369
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 370
    part_set_signal(p, comp->nlb, 1, 1);
#line 371
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 373
  chain_shift_data_registers(chain___0, 1);
#line 375
  i = 0;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned int )i < area.width)) {
#line 375
      goto while_break;
    }
    {
#line 376
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 376
    d |= (uint32_t )(tmp___0 << i);
#line 375
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return (d);
}
}
#line 385 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 388
  jopcyc_bus_read_start(bus___0, adr);
#line 389
  tmp = jopcyc_bus_read_end(bus___0);
  }
#line 389
  return (tmp);
}
}
#line 396 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void jopcyc_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 399
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 400
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 404
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 405
  if (! comp) {
    {
#line 406
    tmp = gettext("Address out of range\n");
#line 406
    printf((char const   */* __restrict  */)tmp);
    }
#line 407
    return;
  }
  {
#line 410
  part_set_signal(p, comp->ncs, 1, 0);
#line 411
  part_set_signal(p, comp->nwe, 1, 1);
#line 412
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 413
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 414
    part_set_signal(p, comp->nlb, 1, 0);
#line 415
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 418
  setup_address___15(bus___0, adr, comp);
#line 419
  setup_data___15(bus___0, data, comp);
#line 421
  chain_shift_data_registers(chain___0, 0);
#line 423
  part_set_signal(p, comp->nwe, 1, 0);
#line 424
  chain_shift_data_registers(chain___0, 0);
#line 425
  part_set_signal(p, comp->nwe, 1, 1);
#line 426
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 427
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 428
    part_set_signal(p, comp->nlb, 1, 1);
#line 429
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 431
  chain_shift_data_registers(chain___0, 0);
  }
#line 432
  return;
}
}
#line 439 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t___0 **comp ) 
{ 


  {
#line 442
  if (adr < (uint32_t )(1 << 19)) {
#line 443
    area->description = "RAMA Component";
#line 444
    area->start = (uint32_t )0;
#line 445
    area->length = (uint64_t )(1 << 19);
#line 446
    area->width = 16U;
#line 447
    *comp = & ((bus_params_t___15 *)bus___0->params)->rama;
  } else
#line 448
  if (adr < (uint32_t )(2 * (1 << 19))) {
#line 449
    area->description = "RAMB Component";
#line 450
    area->start = (uint32_t )(1 << 19);
#line 451
    area->length = (uint64_t )(1 << 19);
#line 452
    area->width = 16U;
#line 453
    *comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
  } else
#line 454
  if (adr < (uint32_t )(2 * (1 << 19) + (1 << 19))) {
#line 455
    area->description = "FLASH Component";
#line 456
    area->start = (uint32_t )(2 * (1 << 19));
#line 457
    area->length = (uint64_t )(1 << 19);
#line 458
    area->width = 8U;
#line 459
    *comp = & ((bus_params_t___15 *)bus___0->params)->flash;
  } else {
#line 461
    area->description = "Dummy";
#line 462
    area->start = (uint32_t )(2 * (1 << 19) + (1 << 19));
#line 463
    area->length = 4294967296UL;
#line 464
    area->width = 0U;
#line 465
    *comp = (component_t___0 *)((void *)0);
  }
#line 468
  return (0);
}
}
#line 472 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static int jopcyc_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t___0 *comp ;
  int tmp ;

  {
  {
#line 477
  tmp = comp_bus_area___0(bus___0, adr, area, & comp);
  }
#line 477
  return (tmp);
}
}
#line 481 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static void jopcyc_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 484
  free(bus___0->params);
#line 485
  free((void *)bus___0);
  }
#line 486
  return;
}
}
#line 488 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static int attach_sig___0(bus_t *bus___0 , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;

  {
  {
#line 491
  failed = 0;
#line 493
  *sig = part_find_signal(((bus_params_t___15 *)bus___0->params)->part, (char const   *)id);
  }
#line 494
  if (! *sig) {
    {
#line 495
    tmp = gettext("signal \'%s\' not found\n");
#line 495
    printf((char const   */* __restrict  */)tmp, id);
#line 496
    failed = 1;
    }
  }
#line 499
  return (failed);
}
}
#line 502 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
static bus_t *jopcyc_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  component_t___0 *comp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;

  {
#line 506
  failed = 0;
#line 509
  if (! chain) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if (! chain->parts) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if ((chain->parts)->len <= chain->active_part) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if (chain->active_part < 0) {
#line 510
    return ((bus_t *)((void *)0));
  }
  {
#line 512
  tmp = malloc(sizeof(bus_t ));
#line 512
  bus___0 = (bus_t *)tmp;
  }
#line 513
  if (! bus___0) {
#line 514
    return ((bus_t *)((void *)0));
  }
  {
#line 516
  bus___0->driver = & jopcyc_bus;
#line 517
  bus___0->params = malloc(sizeof(bus_params_t___15 ));
  }
#line 518
  if (! bus___0->params) {
    {
#line 519
    free((void *)bus___0);
    }
#line 520
    return ((bus_t *)((void *)0));
  }
  {
#line 523
  ((bus_params_t___15 *)bus___0->params)->chain = chain;
#line 524
  ((bus_params_t___15 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 529
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 530
  comp->ctype = (ctype_t )0;
#line 531
  comp->cname = (char *)"RAMA";
#line 533
  tmp___0 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO64");
#line 533
  failed |= tmp___0;
#line 534
  tmp___1 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO66");
#line 534
  failed |= tmp___1;
#line 535
  tmp___2 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO68");
#line 535
  failed |= tmp___2;
#line 536
  tmp___3 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO74");
#line 536
  failed |= tmp___3;
#line 537
  tmp___4 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO76");
#line 537
  failed |= tmp___4;
#line 538
  tmp___5 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO107");
#line 538
  failed |= tmp___5;
#line 539
  tmp___6 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO113");
#line 539
  failed |= tmp___6;
#line 540
  tmp___7 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO115");
#line 540
  failed |= tmp___7;
#line 541
  tmp___8 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO117");
#line 541
  failed |= tmp___8;
#line 542
  tmp___9 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO119");
#line 542
  failed |= tmp___9;
#line 543
  tmp___10 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO118");
#line 543
  failed |= tmp___10;
#line 544
  tmp___11 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO116");
#line 544
  failed |= tmp___11;
#line 545
  tmp___12 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO114");
#line 545
  failed |= tmp___12;
#line 546
  tmp___13 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO108");
#line 546
  failed |= tmp___13;
#line 547
  tmp___14 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO106");
#line 547
  failed |= tmp___14;
#line 548
  tmp___15 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO67");
#line 548
  failed |= tmp___15;
#line 549
  tmp___16 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO65");
#line 549
  failed |= tmp___16;
#line 550
  tmp___17 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO63");
#line 550
  failed |= tmp___17;
#line 551
  comp->a[18] = (signal_t *)((void *)0);
#line 553
  tmp___18 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO82");
#line 553
  failed |= tmp___18;
#line 554
  tmp___19 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO84");
#line 554
  failed |= tmp___19;
#line 555
  tmp___20 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO86");
#line 555
  failed |= tmp___20;
#line 556
  tmp___21 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO88");
#line 556
  failed |= tmp___21;
#line 557
  tmp___22 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO94");
#line 557
  failed |= tmp___22;
#line 558
  tmp___23 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO98");
#line 558
  failed |= tmp___23;
#line 559
  tmp___24 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO100");
#line 559
  failed |= tmp___24;
#line 560
  tmp___25 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO104");
#line 560
  failed |= tmp___25;
#line 561
  tmp___26 = attach_sig___0(bus___0, & comp->d[8], (char *)"IO101");
#line 561
  failed |= tmp___26;
#line 562
  tmp___27 = attach_sig___0(bus___0, & comp->d[9], (char *)"IO99");
#line 562
  failed |= tmp___27;
#line 563
  tmp___28 = attach_sig___0(bus___0, & comp->d[10], (char *)"IO95");
#line 563
  failed |= tmp___28;
#line 564
  tmp___29 = attach_sig___0(bus___0, & comp->d[11], (char *)"IO93");
#line 564
  failed |= tmp___29;
#line 565
  tmp___30 = attach_sig___0(bus___0, & comp->d[12], (char *)"IO87");
#line 565
  failed |= tmp___30;
#line 566
  tmp___31 = attach_sig___0(bus___0, & comp->d[13], (char *)"IO85");
#line 566
  failed |= tmp___31;
#line 567
  tmp___32 = attach_sig___0(bus___0, & comp->d[14], (char *)"IO83");
#line 567
  failed |= tmp___32;
#line 568
  tmp___33 = attach_sig___0(bus___0, & comp->d[15], (char *)"IO79");
#line 568
  failed |= tmp___33;
#line 570
  tmp___34 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO78");
#line 570
  failed |= tmp___34;
#line 571
  tmp___35 = attach_sig___0(bus___0, & comp->noe, (char *)"IO73");
#line 571
  failed |= tmp___35;
#line 572
  tmp___36 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO105");
#line 572
  failed |= tmp___36;
#line 573
  tmp___37 = attach_sig___0(bus___0, & comp->nlb, (char *)"IO77");
#line 573
  failed |= tmp___37;
#line 574
  tmp___38 = attach_sig___0(bus___0, & comp->nub, (char *)"IO75");
#line 574
  failed |= tmp___38;
#line 575
  comp->ncs2 = (signal_t *)((void *)0);
#line 576
  comp->nrdy = (signal_t *)((void *)0);
#line 581
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 582
  comp->ctype = (ctype_t )0;
#line 583
  comp->cname = (char *)"RAMB";
#line 585
  tmp___39 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO237");
#line 585
  failed |= tmp___39;
#line 586
  tmp___40 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO235");
#line 586
  failed |= tmp___40;
#line 587
  tmp___41 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO233");
#line 587
  failed |= tmp___41;
#line 588
  tmp___42 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO227");
#line 588
  failed |= tmp___42;
#line 589
  tmp___43 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO225");
#line 589
  failed |= tmp___43;
#line 590
  tmp___44 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO194");
#line 590
  failed |= tmp___44;
#line 591
  tmp___45 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO188");
#line 591
  failed |= tmp___45;
#line 592
  tmp___46 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO186");
#line 592
  failed |= tmp___46;
#line 593
  tmp___47 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO184");
#line 593
  failed |= tmp___47;
#line 594
  tmp___48 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO182");
#line 594
  failed |= tmp___48;
#line 595
  tmp___49 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO183");
#line 595
  failed |= tmp___49;
#line 596
  tmp___50 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO185");
#line 596
  failed |= tmp___50;
#line 597
  tmp___51 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO187");
#line 597
  failed |= tmp___51;
#line 598
  tmp___52 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO193");
#line 598
  failed |= tmp___52;
#line 599
  tmp___53 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO195");
#line 599
  failed |= tmp___53;
#line 600
  tmp___54 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO234");
#line 600
  failed |= tmp___54;
#line 601
  tmp___55 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO236");
#line 601
  failed |= tmp___55;
#line 602
  tmp___56 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO238");
#line 602
  failed |= tmp___56;
#line 603
  comp->a[18] = (signal_t *)((void *)0);
#line 605
  tmp___57 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO219");
#line 605
  failed |= tmp___57;
#line 606
  tmp___58 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO217");
#line 606
  failed |= tmp___58;
#line 607
  tmp___59 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO215");
#line 607
  failed |= tmp___59;
#line 608
  tmp___60 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO213");
#line 608
  failed |= tmp___60;
#line 609
  tmp___61 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO207");
#line 609
  failed |= tmp___61;
#line 610
  tmp___62 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO203");
#line 610
  failed |= tmp___62;
#line 611
  tmp___63 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO201");
#line 611
  failed |= tmp___63;
#line 612
  tmp___64 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO197");
#line 612
  failed |= tmp___64;
#line 613
  tmp___65 = attach_sig___0(bus___0, & comp->d[8], (char *)"IO200");
#line 613
  failed |= tmp___65;
#line 614
  tmp___66 = attach_sig___0(bus___0, & comp->d[9], (char *)"IO202");
#line 614
  failed |= tmp___66;
#line 615
  tmp___67 = attach_sig___0(bus___0, & comp->d[10], (char *)"IO206");
#line 615
  failed |= tmp___67;
#line 616
  tmp___68 = attach_sig___0(bus___0, & comp->d[11], (char *)"IO208");
#line 616
  failed |= tmp___68;
#line 617
  tmp___69 = attach_sig___0(bus___0, & comp->d[12], (char *)"IO214");
#line 617
  failed |= tmp___69;
#line 618
  tmp___70 = attach_sig___0(bus___0, & comp->d[13], (char *)"IO216");
#line 618
  failed |= tmp___70;
#line 619
  tmp___71 = attach_sig___0(bus___0, & comp->d[14], (char *)"IO218");
#line 619
  failed |= tmp___71;
#line 620
  tmp___72 = attach_sig___0(bus___0, & comp->d[15], (char *)"IO222");
#line 620
  failed |= tmp___72;
#line 622
  tmp___73 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO223");
#line 622
  failed |= tmp___73;
#line 623
  tmp___74 = attach_sig___0(bus___0, & comp->noe, (char *)"IO228");
#line 623
  failed |= tmp___74;
#line 624
  tmp___75 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO196");
#line 624
  failed |= tmp___75;
#line 625
  tmp___76 = attach_sig___0(bus___0, & comp->nlb, (char *)"IO224");
#line 625
  failed |= tmp___76;
#line 626
  tmp___77 = attach_sig___0(bus___0, & comp->nub, (char *)"IO226");
#line 626
  failed |= tmp___77;
#line 627
  comp->ncs2 = (signal_t *)((void *)0);
#line 628
  comp->nrdy = (signal_t *)((void *)0);
#line 633
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 634
  comp->ctype = (ctype_t )1;
#line 635
  comp->cname = (char *)"FLASH";
#line 637
  tmp___78 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO47");
#line 637
  failed |= tmp___78;
#line 638
  tmp___79 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO48");
#line 638
  failed |= tmp___79;
#line 639
  tmp___80 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO49");
#line 639
  failed |= tmp___80;
#line 640
  tmp___81 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO50");
#line 640
  failed |= tmp___81;
#line 641
  tmp___82 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO125");
#line 641
  failed |= tmp___82;
#line 642
  tmp___83 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO127");
#line 642
  failed |= tmp___83;
#line 643
  tmp___84 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO131");
#line 643
  failed |= tmp___84;
#line 644
  tmp___85 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO133");
#line 644
  failed |= tmp___85;
#line 645
  tmp___86 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO158");
#line 645
  failed |= tmp___86;
#line 646
  tmp___87 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO16");
#line 646
  failed |= tmp___87;
#line 647
  tmp___88 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO20");
#line 647
  failed |= tmp___88;
#line 648
  tmp___89 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO14");
#line 648
  failed |= tmp___89;
#line 649
  tmp___90 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO135");
#line 649
  failed |= tmp___90;
#line 650
  tmp___91 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO156");
#line 650
  failed |= tmp___91;
#line 651
  tmp___92 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO144");
#line 651
  failed |= tmp___92;
#line 652
  tmp___93 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO137");
#line 652
  failed |= tmp___93;
#line 653
  tmp___94 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO139");
#line 653
  failed |= tmp___94;
#line 654
  tmp___95 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO143");
#line 654
  failed |= tmp___95;
#line 655
  tmp___96 = attach_sig___0(bus___0, & comp->a[18], (char *)"IO141");
#line 655
  failed |= tmp___96;
#line 657
  tmp___97 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO46");
#line 657
  failed |= tmp___97;
#line 658
  tmp___98 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO45");
#line 658
  failed |= tmp___98;
#line 659
  tmp___99 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO44");
#line 659
  failed |= tmp___99;
#line 660
  tmp___100 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO165");
#line 660
  failed |= tmp___100;
#line 661
  tmp___101 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO164");
#line 661
  failed |= tmp___101;
#line 662
  tmp___102 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO17");
#line 662
  failed |= tmp___102;
#line 663
  tmp___103 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO18");
#line 663
  failed |= tmp___103;
#line 664
  tmp___104 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO19");
#line 664
  failed |= tmp___104;
#line 665
  comp->d[8] = (signal_t *)((void *)0);
#line 666
  comp->d[9] = (signal_t *)((void *)0);
#line 667
  comp->d[10] = (signal_t *)((void *)0);
#line 668
  comp->d[11] = (signal_t *)((void *)0);
#line 669
  comp->d[12] = (signal_t *)((void *)0);
#line 670
  comp->d[13] = (signal_t *)((void *)0);
#line 671
  comp->d[14] = (signal_t *)((void *)0);
#line 672
  comp->d[15] = (signal_t *)((void *)0);
#line 674
  tmp___105 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO15");
#line 674
  failed |= tmp___105;
#line 675
  tmp___106 = attach_sig___0(bus___0, & comp->noe, (char *)"IO24");
#line 675
  failed |= tmp___106;
#line 676
  tmp___107 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO37");
#line 676
  failed |= tmp___107;
#line 677
  tmp___108 = attach_sig___0(bus___0, & comp->ncs2, (char *)"IO23");
#line 677
  failed |= tmp___108;
#line 682
  comp->nrdy = (signal_t *)((void *)0);
#line 684
  comp->nlb = (signal_t *)((void *)0);
#line 685
  comp->nub = (signal_t *)((void *)0);
#line 690
  tmp___109 = attach_sig___0(bus___0, & ((bus_params_t___15 *)bus___0->params)->ser_rxd,
                             (char *)"CLK2");
#line 690
  failed |= tmp___109;
#line 691
  tmp___110 = attach_sig___0(bus___0, & ((bus_params_t___15 *)bus___0->params)->ser_nrts,
                             (char *)"IO177");
#line 691
  failed |= tmp___110;
#line 692
  tmp___111 = attach_sig___0(bus___0, & ((bus_params_t___15 *)bus___0->params)->ser_txd,
                             (char *)"IO178");
#line 692
  failed |= tmp___111;
#line 693
  tmp___112 = attach_sig___0(bus___0, & ((bus_params_t___15 *)bus___0->params)->ser_ncts,
                             (char *)"CLK0");
#line 693
  failed |= tmp___112;
  }
#line 695
  if (failed) {
    {
#line 696
    free(bus___0->params);
#line 697
    free((void *)bus___0);
    }
#line 698
    return ((bus_t *)((void *)0));
  }
#line 701
  return (bus___0);
}
}
#line 704 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/jopcyc.c"
struct bus_driver  const  jopcyc_bus  = 
#line 704
     {"jopcyc", "JOP.design Cyclone Board compatible bus driver via BSR", & jopcyc_bus_new,
    & jopcyc_bus_free, & jopcyc_bus_printinfo, & jopcyc_bus_prepare, & jopcyc_bus_area,
    & jopcyc_bus_read_start, & jopcyc_bus_read_next, & jopcyc_bus_read_end, & jopcyc_bus_read,
    & jopcyc_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  ixp425_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void select_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 60
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 62
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 0);
#line 63
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 64
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 65
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 66
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 67
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 68
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 69
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 70
  return;
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void unselect_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 75
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 77
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 79
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 80
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 84
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void setup_address___16(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 91
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 24)) {
#line 93
      goto while_break;
    }
    {
#line 94
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_addr[i], 1, (int )((a >> i) & 1U));
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void set_data_in___16(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 101
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 16)) {
#line 103
      goto while_break;
    }
    {
#line 104
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 0, 0);
#line 103
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void setup_data___16(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 111
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < 16)) {
#line 113
      goto while_break;
    }
    {
#line 114
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 1, (int )((d >> i) & 1U));
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void ixp425_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < ((((bus_params_t___16 *)bus___0->params)->chain)->parts)->len)) {
#line 122
      goto while_break;
    }
#line 123
    if ((unsigned long )((bus_params_t___16 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___16 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 124
      goto while_break;
    }
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp = gettext("Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 125
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 126
  return;
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void ixp425_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 131
  part_set_instruction(((bus_params_t___16 *)bus___0->params)->part, "EXTEST");
#line 132
  chain_shift_instructions(((bus_params_t___16 *)bus___0->params)->chain);
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void ixp425_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 138
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 139
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 141
  select_flash___0(bus___0);
#line 142
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 0);
#line 143
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 145
  setup_address___16(bus___0, adr);
#line 146
  set_data_in___16(bus___0);
#line 148
  chain_shift_data_registers(chain___0, 0);
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 154
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 155
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 157
  d = (uint32_t )0;
#line 159
  setup_address___16(bus___0, adr);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < 16)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 171
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 172
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 174
  d = (uint32_t )0;
#line 176
  unselect_flash___0(bus___0);
#line 177
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 180
  chain_shift_data_registers(chain___0, 1);
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 16)) {
#line 182
      goto while_break;
    }
    {
#line 183
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 183
    d |= (uint32_t )(tmp << i);
#line 182
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (d);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static uint32_t ixp425_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  ixp425_bus_read_start(bus___0, adr);
#line 192
  tmp = ixp425_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void ixp425_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 198
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 199
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 201
  select_flash___0(bus___0);
#line 202
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 204
  setup_address___16(bus___0, adr);
#line 205
  setup_data___16(bus___0, data);
#line 207
  chain_shift_data_registers(chain___0, 0);
#line 209
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 0);
#line 210
  chain_shift_data_registers(chain___0, 0);
#line 211
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 212
  unselect_flash___0(bus___0);
#line 213
  chain_shift_data_registers(chain___0, 0);
  }
#line 214
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static int ixp425_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 219
  area->description = (char const   *)((void *)0);
#line 220
  area->start = 0U;
#line 221
  area->length = 4294967296UL;
#line 222
  area->width = 16U;
#line 224
  return (0);
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static void ixp425_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 230
  free(bus___0->params);
#line 231
  free((void *)bus___0);
  }
#line 232
  return;
}
}
#line 234
static bus_t *ixp425_bus_new(char **cmd_params___0 ) ;
#line 236 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
struct bus_driver  const  ixp425_bus  = 
#line 236
     {"ixp425", "Intel IXP425 compatible bus driver via BSR", & ixp425_bus_new, & ixp425_bus_free,
    & ixp425_bus_printinfo, & ixp425_bus_prepare, & ixp425_bus_area, & ixp425_bus_read_start,
    & ixp425_bus_read_next, & ixp425_bus_read_end, & ixp425_bus_read, & ixp425_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 252 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ixp425.c"
static bus_t *ixp425_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 258
  failed = 0;
#line 260
  if (! chain) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if (! chain->parts) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if ((chain->parts)->len <= chain->active_part) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if (chain->active_part < 0) {
#line 261
    return ((bus_t *)((void *)0));
  }
  {
#line 263
  tmp = malloc(sizeof(bus_t ));
#line 263
  bus___0 = (bus_t *)tmp;
  }
#line 264
  if (! bus___0) {
#line 265
    return ((bus_t *)((void *)0));
  }
  {
#line 267
  bus___0->driver = & ixp425_bus;
#line 268
  bus___0->params = malloc(sizeof(bus_params_t___16 ));
  }
#line 269
  if (! bus___0->params) {
    {
#line 270
    free((void *)bus___0);
    }
#line 271
    return ((bus_t *)((void *)0));
  }
#line 274
  ((bus_params_t___16 *)bus___0->params)->chain = chain;
#line 275
  ((bus_params_t___16 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < 8)) {
#line 277
      goto while_break;
    }
    {
#line 278
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_CS[%d]",
            i);
#line 279
    ((bus_params_t___16 *)bus___0->params)->ex_cs[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 280
    if (! ((bus_params_t___16 *)bus___0->params)->ex_cs[i]) {
      {
#line 281
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 281
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 282
      failed = 1;
      }
#line 283
      goto while_break;
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    if (! (i < 24)) {
#line 286
      goto while_break___0;
    }
    {
#line 287
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_ADDR[%d]",
            i);
#line 288
    ((bus_params_t___16 *)bus___0->params)->ex_addr[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 289
    if (! ((bus_params_t___16 *)bus___0->params)->ex_addr[i]) {
      {
#line 290
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 290
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 291
      failed = 1;
      }
#line 292
      goto while_break___0;
    }
#line 286
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 295
    if (! (i < 16)) {
#line 295
      goto while_break___1;
    }
    {
#line 296
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_DATA[%d]",
            i);
#line 297
    ((bus_params_t___16 *)bus___0->params)->ex_data[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 298
    if (! ((bus_params_t___16 *)bus___0->params)->ex_data[i]) {
      {
#line 299
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 299
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 300
      failed = 1;
      }
#line 301
      goto while_break___1;
    }
#line 295
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 304
  ((bus_params_t___16 *)bus___0->params)->ex_wr = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                   "EX_WR");
  }
#line 305
  if (! ((bus_params_t___16 *)bus___0->params)->ex_wr) {
    {
#line 306
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 306
    printf((char const   */* __restrict  */)tmp___3, "EX_WR");
#line 307
    failed = 1;
    }
  }
  {
#line 309
  ((bus_params_t___16 *)bus___0->params)->ex_rd = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                   "EX_RD");
  }
#line 310
  if (! ((bus_params_t___16 *)bus___0->params)->ex_rd) {
    {
#line 311
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 311
    printf((char const   */* __restrict  */)tmp___4, "EX_RD");
#line 312
    failed = 1;
    }
  }
#line 315
  if (failed) {
    {
#line 316
    free(bus___0->params);
#line 317
    free((void *)bus___0);
    }
#line 318
    return ((bus_t *)((void *)0));
  }
#line 321
  return (bus___0);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  h7202_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void setup_address___17(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 61
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 26)) {
#line 63
      goto while_break;
    }
    {
#line 64
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void set_data_in___17(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 73
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 76
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned int )i < area.width)) {
#line 78
      goto while_break;
    }
    {
#line 79
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 0, 0);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void setup_data___17(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 86
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 89
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )i < area.width)) {
#line 91
      goto while_break;
    }
    {
#line 92
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void h7202_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < ((((bus_params_t___17 *)bus___0->params)->chain)->parts)->len)) {
#line 100
      goto while_break;
    }
#line 101
    if ((unsigned long )((bus_params_t___17 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___17 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 102
      goto while_break;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  printf((char const   */* __restrict  */)"H7202 compatible bus driver via BSR (JTAG part No. %d)\n",
         i);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void h7202_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 109
  part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EXTEST");
#line 110
  chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void h7202_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 117
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 118
  chain___0 = ((bus_params_t___17 *)bus___0->params)->chain;
#line 120
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 121
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 122
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 123
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 124
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 125
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 0);
#line 127
  setup_address___17(bus___0, adr);
#line 128
  set_data_in___17(bus___0);
#line 130
  chain_shift_data_registers(chain___0, 0);
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static uint32_t h7202_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 137
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 138
  chain___0 = ((bus_params_t___17 *)bus___0->params)->chain;
#line 140
  d = (uint32_t )0;
#line 143
  h7202_bus_area(bus___0, adr, & area);
#line 145
  setup_address___17(bus___0, adr);
#line 146
  chain_shift_data_registers(chain___0, 1);
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned int )i < area.width)) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 149
    d |= (uint32_t )(tmp << i);
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (d);
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static uint32_t h7202_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 158
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 159
  chain___0 = ((bus_params_t___17 *)bus___0->params)->chain;
#line 161
  d = (uint32_t )0;
#line 164
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 166
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 171
  chain_shift_data_registers(chain___0, 1);
#line 173
  i = 0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned int )i < area.width)) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 174
    d |= (uint32_t )(tmp << i);
#line 173
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (d);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static uint32_t h7202_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 182
  h7202_bus_read_start(bus___0, adr);
#line 183
  tmp = h7202_bus_read_end(bus___0);
  }
#line 183
  return (tmp);
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void h7202_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 190
  p = ((bus_params_t___17 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___17 *)bus___0->params)->chain;
#line 197
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 198
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[1], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[2], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[3], 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 208
  setup_address___17(bus___0, adr);
#line 209
  setup_data___17(bus___0, data);
#line 211
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 216
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 217
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 218
  chain_shift_data_registers(chain___0, 0);
  }
#line 219
  return;
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 224
  area->description = (char const   *)((void *)0);
#line 225
  area->start = 0U;
#line 226
  area->length = 4294967296UL;
#line 227
  area->width = 16U;
#line 229
  return (0);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static void h7202_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 235
  free(bus___0->params);
#line 236
  free((void *)bus___0);
  }
#line 237
  return;
}
}
#line 239
static bus_t *h7202_bus_new(char **cmd_params___0 ) ;
#line 241 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
struct bus_driver  const  h7202_bus  = 
#line 241
     {"h7202", "H7202 compatible bus driver via BSR", & h7202_bus_new, & h7202_bus_free,
    & h7202_bus_printinfo, & h7202_bus_prepare, & h7202_bus_area, & h7202_bus_read_start,
    & h7202_bus_read_next, & h7202_bus_read_end, & h7202_bus_read, & h7202_bus_write,
    (int (*)(bus_t *bus ))0};
#line 256 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/h7202.c"
static bus_t *h7202_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;

  {
#line 262
  failed = 0;
#line 264
  if (! chain) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if (! chain->parts) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if ((chain->parts)->len <= chain->active_part) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if (chain->active_part < 0) {
#line 265
    return ((bus_t *)((void *)0));
  }
  {
#line 267
  tmp = malloc(sizeof(bus_t ));
#line 267
  bus___0 = (bus_t *)tmp;
  }
#line 268
  if (! bus___0) {
#line 269
    return ((bus_t *)((void *)0));
  }
  {
#line 271
  bus___0->driver = & h7202_bus;
#line 272
  bus___0->params = malloc(sizeof(bus_params_t___17 ));
  }
#line 273
  if (! bus___0->params) {
    {
#line 274
    free((void *)bus___0);
    }
#line 275
    return ((bus_t *)((void *)0));
  }
#line 278
  ((bus_params_t___17 *)bus___0->params)->chain = chain;
#line 279
  ((bus_params_t___17 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (i < 25)) {
#line 281
      goto while_break;
    }
    {
#line 282
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RA%d",
            i);
#line 283
    ((bus_params_t___17 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___17 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 284
    if (! ((bus_params_t___17 *)bus___0->params)->a[i]) {
      {
#line 285
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 286
      failed = 1;
      }
#line 287
      goto while_break;
    }
#line 281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (i < 32)) {
#line 290
      goto while_break___0;
    }
    {
#line 291
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 292
    ((bus_params_t___17 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___17 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 293
    if (! ((bus_params_t___17 *)bus___0->params)->d[i]) {
      {
#line 294
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 295
      failed = 1;
      }
#line 296
      goto while_break___0;
    }
#line 290
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 299
    if (! (i < 4)) {
#line 299
      goto while_break___1;
    }
    {
#line 300
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 301
    ((bus_params_t___17 *)bus___0->params)->nRCS[i] = part_find_signal(((bus_params_t___17 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 302
    if (! ((bus_params_t___17 *)bus___0->params)->nRCS[i]) {
      {
#line 303
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 304
      failed = 1;
      }
#line 305
      goto while_break___1;
    }
#line 299
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 308
  ((bus_params_t___17 *)bus___0->params)->nROE = part_find_signal(((bus_params_t___17 *)bus___0->params)->part,
                                                                  "nROE");
  }
#line 309
  if (! ((bus_params_t___17 *)bus___0->params)->nROE) {
    {
#line 310
    printf((char const   */* __restrict  */)"signal \'%s\' not found\n", "nROE");
#line 311
    failed = 1;
    }
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 314
    if (! (i < 4)) {
#line 314
      goto while_break___2;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRWE%d",
            i);
#line 316
    ((bus_params_t___17 *)bus___0->params)->nRWE[i] = part_find_signal(((bus_params_t___17 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___17 *)bus___0->params)->nRWE[i]) {
      {
#line 318
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 319
      failed = 1;
      }
    }
#line 314
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 323
  if (failed) {
    {
#line 324
    free(bus___0->params);
#line 325
    free((void *)bus___0);
    }
#line 326
    return ((bus_t *)((void *)0));
  }
#line 329
  return (bus___0);
}
}
#line 38 "../../include/register.h"
tap_register *register_fill(tap_register *tr , int val ) ;
#line 70 "../../include/bus_driver.h"
bus_t *bus ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  ejtag_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < ((((bus_params_t___18 *)bus___0->params)->chain)->parts)->len)) {
#line 69
      goto while_break;
    }
#line 70
    if ((unsigned long )((bus_params_t___18 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___18 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 71
      goto while_break;
    }
#line 69
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  tmp = gettext("EJTAG compatible bus driver via PrAcc (JTAG part No. %d)\n");
#line 72
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 73
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t reg_value(tap_register *reg ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 91
  retval = (uint32_t )0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < reg->len)) {
#line 94
      goto while_break;
    }
#line 95
    if (*(reg->data + i)) {
#line 96
      retval |= (unsigned int )(1 << i);
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (retval);
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t ejtag_run_pracc(bus_t *bus___0 , uint32_t const   *code___0 , unsigned int len ) 
{ 
  data_register *ejaddr ;
  data_register *ejdata ;
  data_register *ejctrl ;
  int i ;
  int pass ;
  uint32_t addr ;
  uint32_t data ;
  uint32_t retval ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 108
  ejaddr = part_find_data_register(((bus_params_t___18 *)bus___0->params)->part, "EJADDRESS");
#line 109
  ejdata = part_find_data_register(((bus_params_t___18 *)bus___0->params)->part, "EJDATA");
#line 110
  ejctrl = part_find_data_register(((bus_params_t___18 *)bus___0->params)->part, "EJCONTROL");
  }
#line 111
  if (ejaddr) {
#line 111
    if (ejdata) {
#line 111
      if (! ejctrl) {
        {
#line 112
        tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
        printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
               113);
        }
#line 114
        return ((uint32_t )0);
      }
    } else {
      {
#line 112
      tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
             113);
      }
#line 114
      return ((uint32_t )0);
    }
  } else {
    {
#line 112
    tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
           113);
    }
#line 114
    return ((uint32_t )0);
  }
  {
#line 117
  part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 118
  chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 120
  pass = 0;
#line 121
  retval = (uint32_t )0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    *((ejctrl->in)->data + 18) = (char)1;
#line 125
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 126
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
    }
#line 130
    if (*((ejctrl->out)->data + 31)) {
      {
#line 131
      tmp___0 = register_get_string((tap_register const   *)ejctrl->out);
#line 131
      tmp___1 = gettext("%s(%d) Reset occurred, ctrl=%s\n");
#line 131
      printf((char const   */* __restrict  */)tmp___1, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
             132, tmp___0);
#line 134
      ((bus_params_t___18 *)bus___0->params)->initialized = 0;
      }
#line 135
      goto while_break;
    }
#line 137
    if (! *((ejctrl->out)->data + 18)) {
      {
#line 138
      tmp___2 = register_get_string((tap_register const   *)ejctrl->out);
#line 138
      tmp___3 = gettext("%s(%d) No processor access, ctrl=%s\n");
#line 138
      printf((char const   */* __restrict  */)tmp___3, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
             139, tmp___2);
#line 141
      ((bus_params_t___18 *)bus___0->params)->initialized = 0;
      }
#line 142
      goto while_break;
    }
    {
#line 145
    part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_ADDRESS");
#line 146
    chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 148
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
#line 149
    addr = reg_value(ejaddr->out);
    }
#line 150
    if (addr & 3U) {
      {
#line 151
      tmp___4 = gettext("%s(%d) PrAcc bad alignment: addr=0x%08x\n");
#line 151
      printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
             152, addr);
#line 153
      addr &= 4294967292U;
      }
    }
    {
#line 156
    part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_DATA");
#line 157
    chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 159
    register_fill(ejdata->in, 0);
    }
#line 161
    if (*((ejctrl->out)->data + 19)) {
      {
#line 162
      chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
#line 163
      data = reg_value(ejdata->out);
      }
#line 168
      if (addr == 4280287232U) {
#line 170
        retval = data;
      } else {
        {
#line 172
        tmp___5 = gettext("%s(%d) Unknown write addr=0x%08x data=0x%08x\n");
#line 172
        printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
               173, addr, data);
        }
      }
    } else {
#line 176
      if (addr == 4280287744U) {
#line 176
        tmp___6 = pass;
#line 176
        pass ++;
#line 176
        if (tmp___6) {
#line 177
          goto while_break;
        }
      }
#line 179
      data = (uint32_t )0;
#line 180
      if (addr >= 4280287744U) {
#line 180
        if (addr < 4280287744U + (len << 2)) {
#line 181
          data = (uint32_t )*(code___0 + ((addr - 4280287744U) >> 2));
#line 183
          i = 0;
          {
#line 183
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 183
            if (! (i < 32)) {
#line 183
              goto while_break___0;
            }
#line 184
            *((ejdata->in)->data + i) = (char )((data >> i) & 1U);
#line 183
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 190
      chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
      }
    }
    {
#line 193
    part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 194
    chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 196
    *((ejctrl->in)->data + 18) = (char)0;
#line 197
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (retval);
}
}
#line 202 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_init(bus_t *bus___0 ) 
{ 
  data_register *ejctrl ;
  data_register *ejimpl ;
  uint32_t code___0[4] ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 206
  code___0[0] = (uint32_t )1006960416;
#line 206
  code___0[1] = (uint32_t )882835968;
#line 206
  code___0[2] = (uint32_t )65011720;
#line 206
  code___0[3] = (uint32_t )1006829568;
#line 213
  ejctrl = part_find_data_register(((bus_params_t___18 *)bus___0->params)->part, "EJCONTROL");
#line 214
  ejimpl = part_find_data_register(((bus_params_t___18 *)bus___0->params)->part, "EJIMPCODE");
  }
#line 215
  if (ejctrl) {
#line 215
    if (! ejimpl) {
      {
#line 216
      tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 216
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
             217);
      }
#line 218
      return;
    }
  } else {
    {
#line 216
    tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 216
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
           217);
    }
#line 218
    return;
  }
  {
#line 221
  part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_IMPCODE");
#line 222
  chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 223
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 224
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
#line 225
  tmp___0 = register_get_string((tap_register const   *)ejimpl->out);
#line 225
  printf((char const   */* __restrict  */)"ImpCode=%s\n", tmp___0);
#line 226
  ((bus_params_t___18 *)bus___0->params)->impcode = reg_value(ejimpl->out);
  }
  {
#line 229
  if (((((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
#line 229
    goto case_0;
  }
#line 230
  if (((((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U) == 1U) {
#line 230
    goto case_1;
  }
#line 231
  if (((((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U) == 2U) {
#line 231
    goto case_2;
  }
#line 232
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 229
  printf((char const   */* __restrict  */)"EJTAG version: <= 2.0\n");
  }
#line 229
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 230
  printf((char const   */* __restrict  */)"EJTAG version: 2.5\n");
  }
#line 230
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 231
  printf((char const   */* __restrict  */)"EJTAG version: 2.6\n");
  }
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 233
  printf((char const   */* __restrict  */)"EJTAG version: unknown (%d)\n", (((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U);
  }
  switch_break: /* CIL Label */ ;
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & 1U) {
#line 235
    tmp___1 = " MIPS64";
  } else {
#line 235
    tmp___1 = " MIPS32";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
#line 235
    tmp___2 = " NoDMA";
  } else {
#line 235
    tmp___2 = "";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 16)) {
#line 235
    tmp___3 = " MIPS16";
  } else {
#line 235
    tmp___3 = "";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 21)) {
#line 235
    tmp___4 = " ASID_6";
  } else {
#line 235
    tmp___4 = "";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 22)) {
#line 235
    tmp___5 = " ASID_8";
  } else {
#line 235
    tmp___5 = "";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 24)) {
#line 235
    tmp___6 = " DINTsup";
  } else {
#line 235
    tmp___6 = "";
  }
#line 235
  if (((bus_params_t___18 *)bus___0->params)->impcode & (unsigned int )(1 << 28)) {
#line 235
    tmp___7 = " R3k";
  } else {
#line 235
    tmp___7 = " R4k";
  }
  {
#line 235
  printf((char const   */* __restrict  */)"EJTAG Implementation flags:%s%s%s%s%s%s%s\n",
         tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
  }
#line 244
  if (((((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
    {
#line 245
    part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAGBOOT");
#line 246
    chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
    }
  }
  {
#line 249
  part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 250
  chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
#line 252
  register_fill(ejctrl->in, 0);
#line 254
  *((ejctrl->in)->data + 16) = (char)1;
#line 255
  *((ejctrl->in)->data + 20) = (char)1;
#line 256
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 258
  *((ejctrl->in)->data + 16) = (char)0;
#line 259
  *((ejctrl->in)->data + 20) = (char)0;
#line 260
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 262
  *((ejctrl->in)->data + 18) = (char)1;
#line 263
  *((ejctrl->in)->data + 15) = (char)1;
  }
#line 264
  if (((((bus_params_t___18 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
#line 265
    *((ejctrl->in)->data + 14) = (char)1;
#line 266
    *((ejctrl->in)->data + 31) = (char)1;
  }
  {
#line 268
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 270
  *((ejctrl->in)->data + 12) = (char)1;
#line 271
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 273
  *((ejctrl->in)->data + 12) = (char)0;
#line 274
  chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
  }
#line 276
  if (! *((ejctrl->out)->data + 3)) {
    {
#line 277
    tmp___8 = register_get_string((tap_register const   *)ejctrl->out);
#line 277
    tmp___9 = gettext("%s(%d) Failed to enter debug mode, ctrl=%s\n");
#line 277
    printf((char const   */* __restrict  */)tmp___9, "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c",
           278, tmp___8);
    }
#line 280
    return;
  }
#line 283
  if (*((ejctrl->out)->data + 31)) {
    {
#line 284
    *((ejctrl->in)->data + 31) = (char)0;
#line 285
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 0);
#line 286
    *((ejctrl->in)->data + 31) = (char)1;
#line 287
    chain_shift_data_registers(((bus_params_t___18 *)bus___0->params)->chain, 1);
    }
  }
  {
#line 290
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), 4U);
#line 291
  ((bus_params_t___18 *)bus___0->params)->adr_hi = (uint16_t )0;
#line 292
  ((bus_params_t___18 *)bus___0->params)->initialized = 1;
  }
#line 293
  return;
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 298
  if (((bus_params_t___18 *)bus___0->params)->initialized) {
#line 299
    return;
  }
  {
#line 301
  ejtag_bus_init(bus___0);
  }
#line 302
  return;
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static int ejtag_gen_read(uint32_t *code___0 , uint32_t adr ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 308
  p = code___0;
#line 311
  adr_lo = (uint16_t )(adr & 65535U);
#line 312
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 314
  if ((int )((bus_params_t___18 *)bus->params)->adr_hi != (int )adr_hi) {
#line 315
    ((bus_params_t___18 *)bus->params)->adr_hi = adr_hi;
#line 316
    tmp = p;
#line 316
    p ++;
#line 316
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 319
  if (adr >> 29 == 0U) {
#line 319
    goto case_0;
  }
#line 322
  if (adr >> 29 == 1U) {
#line 322
    goto case_1;
  }
#line 325
  if (adr >> 29 == 2U) {
#line 325
    goto case_2;
  }
#line 328
  goto switch_default;
  case_0: /* CIL Label */ 
#line 320
  tmp___0 = p;
#line 320
  p ++;
#line 320
  *tmp___0 = 2422341632U | (unsigned int )adr_lo;
#line 321
  goto switch_break;
  case_1: /* CIL Label */ 
#line 323
  tmp___1 = p;
#line 323
  p ++;
#line 323
  *tmp___1 = 2489450496U | (unsigned int )((int )adr_lo & -2);
#line 324
  goto switch_break;
  case_2: /* CIL Label */ 
#line 326
  tmp___2 = p;
#line 326
  p ++;
#line 326
  *tmp___2 = 2355232768U | (unsigned int )((int )adr_lo & -4);
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 329
  tmp___3 = p;
#line 329
  p ++;
#line 329
  *tmp___3 = (uint32_t )4133;
#line 330
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 332
  tmp___4 = p;
#line 332
  p ++;
#line 332
  *tmp___4 = (uint32_t )65011720;
#line 333
  return ((int )(p - code___0));
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t code___0[3] ;
  int tmp ;

  {
  {
#line 341
  tmp = ejtag_gen_read(code___0, adr);
#line 341
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )tmp);
  }
#line 343
  return;
}
}
#line 345 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  uint32_t code___0[4] ;
  uint32_t *p ;
  uint32_t *tmp ;
  int tmp___0 ;

  {
  {
#line 349
  p = code___0;
#line 351
  tmp = p;
#line 351
  p ++;
#line 351
  *tmp = 2894200832U;
#line 352
  tmp___0 = ejtag_gen_read(p, adr);
#line 352
  p += tmp___0;
#line 354
  d = ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 357
  return (d);
}
}
#line 364
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) ;
#line 364 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t const   code[2]  = {      (uint32_t const   )2894200832U,      (uint32_t const   )65011720};
#line 360 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t d ;

  {
  {
#line 369
  d = ejtag_run_pracc(bus___0, code, 2U);
  }
#line 372
  return (d);
}
}
#line 375 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static uint32_t ejtag_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 378
  ejtag_bus_read_start(bus___0, adr);
#line 379
  tmp = ejtag_bus_read_end(bus___0);
  }
#line 379
  return (tmp);
}
}
#line 382 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t code___0[5] ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;

  {
#line 386
  p = code___0;
#line 389
  adr_lo = (uint16_t )(adr & 65535U);
#line 390
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 392
  if ((int )((bus_params_t___18 *)bus___0->params)->adr_hi != (int )adr_hi) {
#line 393
    ((bus_params_t___18 *)bus___0->params)->adr_hi = adr_hi;
#line 394
    tmp = p;
#line 394
    p ++;
#line 394
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 397
  if (adr >> 29 == 0U) {
#line 397
    goto case_0;
  }
#line 401
  if (adr >> 29 == 1U) {
#line 401
    goto case_1;
  }
#line 405
  if (adr >> 29 == 2U) {
#line 405
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
#line 398
  tmp___0 = p;
#line 398
  p ++;
#line 398
  *tmp___0 = 872546304U | (data & 255U);
#line 399
  tmp___1 = p;
#line 399
  p ++;
#line 399
  *tmp___1 = 2690777088U | (unsigned int )adr_lo;
#line 400
  goto switch_break;
  case_1: /* CIL Label */ 
#line 402
  tmp___2 = p;
#line 402
  p ++;
#line 402
  *tmp___2 = 872546304U | (data & 65535U);
#line 403
  tmp___3 = p;
#line 403
  p ++;
#line 403
  *tmp___3 = 2757885952U | (unsigned int )((int )adr_lo & -2);
#line 404
  goto switch_break;
  case_2: /* CIL Label */ 
#line 406
  tmp___4 = p;
#line 406
  p ++;
#line 406
  *tmp___4 = 1006764032U | (data >> 16);
#line 407
  tmp___5 = p;
#line 407
  p ++;
#line 407
  *tmp___5 = 876740608U | (data & 65535U);
#line 408
  tmp___6 = p;
#line 408
  p ++;
#line 408
  *tmp___6 = 2892103680U | (unsigned int )((int )adr_lo & -4);
#line 409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 411
  tmp___7 = p;
#line 411
  p ++;
#line 411
  *tmp___7 = (uint32_t )65011720;
#line 413
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 416
  return;
}
}
#line 418 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 421
  if (adr < 536870912U) {
#line 422
    area->description = (char const   *)((void *)0);
#line 423
    area->start = 0U;
#line 424
    area->length = 536870912UL;
#line 425
    area->width = 8U;
  } else
#line 426
  if (adr < 1073741824U) {
#line 427
    area->description = (char const   *)((void *)0);
#line 428
    area->start = 536870912U;
#line 429
    area->length = 536870912UL;
#line 430
    area->width = 16U;
  } else
#line 431
  if (adr < 1610612736U) {
#line 432
    area->description = (char const   *)((void *)0);
#line 433
    area->start = 1073741824U;
#line 434
    area->length = 536870912UL;
#line 435
    area->width = 32U;
  } else {
#line 437
    area->description = (char const   *)((void *)0);
#line 438
    area->start = 1610612736U;
#line 439
    area->length = 2684354560UL;
#line 440
    area->width = 0U;
  }
#line 442
  return (0);
}
}
#line 445 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static void ejtag_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 448
  free(bus___0->params);
#line 449
  free((void *)bus___0);
  }
#line 450
  return;
}
}
#line 452
static bus_t *ejtag_bus_new(char **cmd_params___0 ) ;
#line 454 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
struct bus_driver  const  ejtag_bus  = 
#line 454
     {"ejtag", "EJTAG compatible bus driver via PrAcc", & ejtag_bus_new, & ejtag_bus_free,
    & ejtag_bus_printinfo, & ejtag_bus_prepare, & ejtag_bus_area, & ejtag_bus_read_start,
    & ejtag_bus_read_next, & ejtag_bus_read_end, & ejtag_bus_read, & ejtag_bus_write,
    (int (*)(bus_t *bus ))0};
#line 469 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/ejtag.c"
static bus_t *ejtag_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  void *tmp ;

  {
#line 474
  if (! chain) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if (! chain->parts) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if ((chain->parts)->len <= chain->active_part) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if (chain->active_part < 0) {
#line 475
    return ((bus_t *)((void *)0));
  }
  {
#line 477
  tmp = malloc(sizeof(bus_t ));
#line 477
  bus___0 = (bus_t *)tmp;
  }
#line 478
  if (! bus___0) {
#line 479
    return ((bus_t *)((void *)0));
  }
  {
#line 481
  bus___0->driver = & ejtag_bus;
#line 482
  bus___0->params = malloc(sizeof(bus_params_t___18 ));
  }
#line 483
  if (! bus___0->params) {
    {
#line 484
    free((void *)bus___0);
    }
#line 485
    return ((bus_t *)((void *)0));
  }
#line 488
  ((bus_params_t___18 *)bus___0->params)->chain = chain;
#line 489
  ((bus_params_t___18 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 490
  ((bus_params_t___18 *)bus___0->params)->initialized = 0;
#line 492
  return (bus___0);
}
}
#line 39 "../../include/bus.h"
buses_t buses ;
#line 40
bus_driver_t const   *bus_drivers[29] ;
#line 42
void buses_free(void) ;
#line 43
void buses_add(bus_t *abus ) ;
#line 44
void buses_delete(bus_t *abus ) ;
#line 28 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.h"
struct bus_driver  const  au1500_bus ;
#line 29
struct bus_driver  const  bcm1250_bus ;
#line 31
struct bus_driver  const  bf533_stamp_bus ;
#line 32
struct bus_driver  const  bf533_ezkit_bus ;
#line 33
struct bus_driver  const  bf537_stamp_bus ;
#line 34
struct bus_driver  const  bf537_ezkit_bus ;
#line 35
struct bus_driver  const  bf561_ezkit_bus ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
bus_driver_t const   *bus_drivers[29]  = 
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
  {      & au1500_bus,      & bcm1250_bus,      & ejtag_bus,      & bf533_stamp_bus, 
        & bf533_ezkit_bus,      & bf537_stamp_bus,      & bf537_ezkit_bus,      & bf561_ezkit_bus, 
        & ixp425_bus,      & lh7a400_bus,      & mpc824x_bus,      & mpc5200_bus, 
        & ppc440gx_ebc8_bus,      & ppc405ep_bus,      & prototype_bus,      & pxa2x0_bus, 
        & pxa27x_bus,      & s3c4510_bus,      & sa1110_bus,      & sh7727_bus, 
        & sh7750r_bus,      & sh7751r_bus,      & h7202_bus,      & slsup3_bus, 
        & tx4925_bus,      & jopcyc_bus,      & sharc_21065L_bus,      & zefant_xs3_bus, 
        (bus_driver_t const   *)((void *)0)};
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
bus_t *bus  =    (bus_t *)((void *)0);
#line 65 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
buses_t buses  =    {0, (bus_t **)((void *)0)};
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
void buses_free(void) 
{ 
  int i ;

  {
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < buses.len)) {
#line 71
      goto while_break;
    }
    {
#line 72
    (*(((*(buses.buses + i))->driver)->free_bus))(*(buses.buses + i));
#line 71
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  free((void *)buses.buses);
#line 75
  buses.len = 0;
#line 76
  buses.buses = (bus_t **)((void *)0);
#line 77
  bus = (bus_t *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
void buses_add(bus_t *abus ) 
{ 
  bus_t **b ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  if ((unsigned long )abus == (unsigned long )((void *)0)) {
#line 85
    return;
  }
  {
#line 87
  tmp = realloc((void *)buses.buses, (unsigned long )(buses.len + 1) * sizeof(bus_t *));
#line 87
  b = (bus_t **)tmp;
  }
#line 88
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 89
    tmp___0 = gettext("Out of memory\n");
#line 89
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 90
    return;
  }
#line 92
  buses.buses = b;
#line 93
  tmp___1 = buses.len;
#line 93
  (buses.len) ++;
#line 93
  *(buses.buses + tmp___1) = abus;
#line 94
  if ((unsigned long )bus == (unsigned long )((void *)0)) {
#line 95
    bus = abus;
  }
#line 96
  return;
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/buses.c"
void buses_delete(bus_t *abus ) 
{ 
  int i ;
  bus_t **b ;
  void *tmp ;

  {
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < buses.len)) {
#line 103
      goto while_break;
    }
#line 104
    if ((unsigned long )abus == (unsigned long )*(buses.buses + i)) {
#line 105
      goto while_break;
    }
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (i >= buses.len) {
#line 107
    return;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i + 1 < buses.len)) {
#line 109
      goto while_break___0;
    }
#line 110
    *(buses.buses + i) = *(buses.buses + (i + 1));
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 113
  (buses.len) --;
#line 114
  tmp = realloc((void *)buses.buses, (unsigned long )buses.len * sizeof(bus_t *));
#line 114
  b = (bus_t **)tmp;
  }
#line 115
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 116
    buses.buses = b;
  } else
#line 115
  if (buses.len == 0) {
#line 116
    buses.buses = b;
  }
#line 118
  if ((unsigned long )bus != (unsigned long )abus) {
#line 119
    return;
  }
#line 121
  if (buses.len > 0) {
#line 122
    bus = *(buses.buses + 0);
  }
#line 123
  return;
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void select_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[1], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[2], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[3], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[0], 1, 0);
#line 78
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[1], 1, 0);
#line 79
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[2], 1, 0);
#line 80
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[3], 1, 0);
#line 82
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sras, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->scas, 1, 1);
#line 84
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->swe, 1, 1);
#line 85
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[0], 1, 1);
#line 86
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[1], 1, 1);
#line 87
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[2], 1, 1);
#line 88
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[3], 1, 1);
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void unselect_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 94
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 96
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[0], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[1], 1, 1);
#line 98
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[2], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->ams[3], 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[0], 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[1], 1, 1);
#line 103
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[2], 1, 1);
#line 104
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[3], 1, 1);
#line 106
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sras, 1, 1);
#line 107
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->scas, 1, 1);
#line 108
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->swe, 1, 1);
#line 109
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[0], 1, 1);
#line 110
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[1], 1, 1);
#line 111
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[2], 1, 1);
#line 112
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->sms[3], 1, 1);
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void setup_address___18(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 24)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 2)) & 1U));
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->abe[3], 1, (int )((a >> 1) & 1U));
  }
#line 124
  return;
}
}
#line 126 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void set_data_in___18(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 130
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < 16)) {
#line 132
      goto while_break;
    }
    {
#line 133
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->data[i], 0, 0);
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void setup_data___18(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 140
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 16)) {
#line 142
      goto while_break;
    }
    {
#line 143
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 142
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < ((((bus_params_t___19 *)bus___0->params)->chain)->parts)->len)) {
#line 152
      goto while_break;
    }
#line 153
    if ((unsigned long )((bus_params_t___19 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___19 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 154
      goto while_break;
    }
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp = gettext("Blackfin BF561 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 155
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 161
  part_set_instruction(((bus_params_t___19 *)bus___0->params)->part, "EXTEST");
#line 162
  chain_shift_instructions(((bus_params_t___19 *)bus___0->params)->chain);
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 168
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 169
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 171
  select_flash___1(bus___0);
#line 172
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->aoe, 1, 0);
#line 173
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->awe, 1, 1);
#line 175
  setup_address___18(bus___0, adr);
#line 176
  set_data_in___18(bus___0);
#line 178
  chain_shift_data_registers(chain___0, 0);
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 184
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 185
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 187
  d = (uint32_t )0;
#line 189
  setup_address___18(bus___0, adr);
#line 190
  chain_shift_data_registers(chain___0, 1);
#line 192
  i = 0;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < 16)) {
#line 192
      goto while_break;
    }
    {
#line 193
    tmp = part_get_signal(p, ((bus_params_t___19 *)bus___0->params)->data[i]);
#line 193
    d |= (uint32_t )(tmp << i);
#line 192
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (d);
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 201
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 202
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 204
  d = (uint32_t )0;
#line 206
  unselect_flash___1(bus___0);
#line 207
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->aoe, 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->awe, 1, 1);
#line 210
  chain_shift_data_registers(chain___0, 1);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < 16)) {
#line 212
      goto while_break;
    }
    {
#line 213
    tmp = part_get_signal(p, ((bus_params_t___19 *)bus___0->params)->data[i]);
#line 213
    d |= (uint32_t )(tmp << i);
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (d);
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 221
  bf561_ezkit_bus_read_start(bus___0, adr);
#line 222
  tmp = bf561_ezkit_bus_read_end(bus___0);
  }
#line 222
  return (tmp);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 228
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 229
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 231
  select_flash___1(bus___0);
#line 232
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->aoe, 1, 1);
#line 234
  setup_address___18(bus___0, adr);
#line 235
  setup_data___18(bus___0, data);
#line 237
  chain_shift_data_registers(chain___0, 0);
#line 239
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->awe, 1, 0);
#line 240
  chain_shift_data_registers(chain___0, 0);
#line 241
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->awe, 1, 1);
#line 242
  unselect_flash___1(bus___0);
#line 243
  chain_shift_data_registers(chain___0, 0);
  }
#line 244
  return;
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static int bf561_ezkit_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
#line 249
  area->description = (char const   *)((void *)0);
#line 250
  area->start = 0U;
#line 251
  area->length = 4294967296UL;
#line 252
  area->width = 16U;
#line 253
  return (0);
}
}
#line 256 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 259
  free(bus___0->params);
#line 260
  free((void *)bus___0);
  }
#line 261
  return;
}
}
#line 263
static bus_t *bf561_ezkit_bus_new(char **cmd_params___0 ) ;
#line 265 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
struct bus_driver  const  bf561_ezkit_bus  = 
#line 265
     {"bf561_ezkit", "Blackfin BF561 EZ-KIT board bus driver", & bf561_ezkit_bus_new,
    & bf561_ezkit_bus_free, & bf561_ezkit_bus_printinfo, & bf561_ezkit_bus_prepare,
    & bf561_ezkit_bus_area, & bf561_ezkit_bus_read_start, & bf561_ezkit_bus_read_next,
    & bf561_ezkit_bus_read_end, & bf561_ezkit_bus_read, & bf561_ezkit_bus_write, (int (*)(bus_t *bus ))0};
#line 280 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf561_ezkit.c"
static bus_t *bf561_ezkit_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 286
  failed = 0;
#line 288
  if (! chain) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (! chain->parts) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if ((chain->parts)->len <= chain->active_part) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (chain->active_part < 0) {
#line 289
    return ((bus_t *)((void *)0));
  }
  {
#line 291
  tmp = malloc(sizeof(bus_t ));
#line 291
  bus___0 = (bus_t *)tmp;
  }
#line 292
  if (! bus___0) {
#line 293
    return ((bus_t *)((void *)0));
  }
  {
#line 295
  bus___0->driver = & bf561_ezkit_bus;
#line 296
  bus___0->params = malloc(sizeof(bus_params_t___19 ));
  }
#line 297
  if (! bus___0->params) {
    {
#line 298
    free((void *)bus___0);
    }
#line 299
    return ((bus_t *)((void *)0));
  }
#line 302
  ((bus_params_t___19 *)bus___0->params)->chain = chain;
#line 303
  ((bus_params_t___19 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 305
  i = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < 4)) {
#line 305
      goto while_break;
    }
    {
#line 306
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 307
    ((bus_params_t___19 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 308
    if (! ((bus_params_t___19 *)bus___0->params)->ams[i]) {
      {
#line 309
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 309
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 310
      failed = 1;
      }
#line 311
      goto while_break;
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! (i < 24)) {
#line 315
      goto while_break___0;
    }
    {
#line 316
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 2);
#line 317
    ((bus_params_t___19 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 318
    if (! ((bus_params_t___19 *)bus___0->params)->addr[i]) {
      {
#line 319
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 319
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 320
      failed = 1;
      }
#line 321
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 325
    if (! (i < 4)) {
#line 325
      goto while_break___1;
    }
    {
#line 326
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ABE_B%d",
            i);
#line 327
    ((bus_params_t___19 *)bus___0->params)->abe[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 328
    if (! ((bus_params_t___19 *)bus___0->params)->abe[i]) {
      {
#line 329
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 329
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 330
      failed = 1;
      }
#line 331
      goto while_break___1;
    }
#line 325
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 335
    if (! (i < 32)) {
#line 335
      goto while_break___2;
    }
    {
#line 336
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 337
    ((bus_params_t___19 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 338
    if (! ((bus_params_t___19 *)bus___0->params)->data[i]) {
      {
#line 339
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 339
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 340
      failed = 1;
      }
#line 341
      goto while_break___2;
    }
#line 335
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 345
  ((bus_params_t___19 *)bus___0->params)->awe = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 346
  if (! ((bus_params_t___19 *)bus___0->params)->awe) {
    {
#line 347
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 347
    printf((char const   */* __restrict  */)tmp___4, "AWE_B");
#line 348
    failed = 1;
    }
  }
  {
#line 351
  ((bus_params_t___19 *)bus___0->params)->aoe = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                 "AOE_B");
  }
#line 352
  if (! ((bus_params_t___19 *)bus___0->params)->aoe) {
    {
#line 353
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 353
    printf((char const   */* __restrict  */)tmp___5, "AOE_B");
#line 354
    failed = 1;
    }
  }
  {
#line 357
  ((bus_params_t___19 *)bus___0->params)->sras = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 358
  if (! ((bus_params_t___19 *)bus___0->params)->sras) {
    {
#line 359
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 359
    printf((char const   */* __restrict  */)tmp___6, "SRAS_B");
#line 360
    failed = 1;
    }
  }
  {
#line 363
  ((bus_params_t___19 *)bus___0->params)->scas = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 364
  if (! ((bus_params_t___19 *)bus___0->params)->scas) {
    {
#line 365
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 365
    printf((char const   */* __restrict  */)tmp___7, "SCAS_B");
#line 366
    failed = 1;
    }
  }
  {
#line 369
  ((bus_params_t___19 *)bus___0->params)->swe = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 370
  if (! ((bus_params_t___19 *)bus___0->params)->swe) {
    {
#line 371
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 371
    printf((char const   */* __restrict  */)tmp___8, "SWE_B");
#line 372
    failed = 1;
    }
  }
#line 375
  i = 0;
  {
#line 375
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 375
    if (! (i < 4)) {
#line 375
      goto while_break___3;
    }
    {
#line 376
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SMS_B%d",
            i);
#line 377
    ((bus_params_t___19 *)bus___0->params)->sms[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 378
    if (! ((bus_params_t___19 *)bus___0->params)->sms[i]) {
      {
#line 379
      tmp___9 = gettext("signal \'%s\' not found\n");
#line 379
      printf((char const   */* __restrict  */)tmp___9, buff);
#line 380
      failed = 1;
      }
#line 381
      goto while_break___3;
    }
#line 375
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 385
  if (failed) {
    {
#line 386
    free(bus___0->params);
#line 387
    free((void *)bus___0);
    }
#line 388
    return ((bus_t *)((void *)0));
  }
#line 391
  return (bus___0);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void select_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 65
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 67
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[0], 1, 0);
#line 68
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[1], 1, 1);
#line 69
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[2], 1, 1);
#line 70
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[3], 1, 1);
#line 71
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->dcs0, 1, 1);
#line 72
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nce, 1, 1);
  }
#line 73
  return;
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void unselect_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 78
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 80
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[0], 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[1], 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[2], 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[3], 1, 1);
#line 84
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->dcs0, 1, 1);
#line 85
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nce, 1, 1);
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void setup_address___19(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 92
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < 24)) {
#line 94
      goto while_break;
    }
    {
#line 95
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void set_data_in___19(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 102
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i < 16)) {
#line 104
      goto while_break;
    }
    {
#line 105
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i], 0, 0);
#line 104
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void setup_data___19(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 112
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 16)) {
#line 114
      goto while_break;
    }
    {
#line 115
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 114
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < ((((bus_params_t___20 *)bus___0->params)->chain)->parts)->len)) {
#line 124
      goto while_break;
    }
#line 125
    if ((unsigned long )((bus_params_t___20 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___20 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 126
      goto while_break;
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = gettext("Blackfin BF548 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 127
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 133
  part_set_instruction(((bus_params_t___20 *)bus___0->params)->part, "EXTEST");
#line 134
  chain_shift_instructions(((bus_params_t___20 *)bus___0->params)->chain);
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 140
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 141
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 143
  select_flash___2(bus___0);
#line 144
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 0);
#line 145
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->are, 1, 0);
#line 146
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 148
  setup_address___19(bus___0, adr);
#line 149
  set_data_in___19(bus___0);
#line 151
  chain_shift_data_registers(chain___0, 0);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 157
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 158
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 160
  d = (uint32_t )0;
#line 162
  setup_address___19(bus___0, adr);
#line 163
  chain_shift_data_registers(chain___0, 1);
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < 16)) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp = part_get_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i]);
#line 166
    d |= (uint32_t )(tmp << i);
#line 165
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (d);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 174
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 175
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 177
  d = (uint32_t )0;
#line 179
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->are, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 182
  unselect_flash___2(bus___0);
#line 184
  chain_shift_data_registers(chain___0, 1);
#line 186
  i = 0;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 16)) {
#line 186
      goto while_break;
    }
    {
#line 187
    tmp = part_get_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i]);
#line 187
    d |= (uint32_t )(tmp << i);
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (d);
}
}
#line 192 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 195
  bf548_ezkit_bus_read_start(bus___0, adr);
#line 196
  tmp = bf548_ezkit_bus_read_end(bus___0);
  }
#line 196
  return (tmp);
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 202
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 203
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 205
  select_flash___2(bus___0);
#line 206
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 0);
#line 207
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->are, 1, 1);
#line 209
  setup_address___19(bus___0, adr);
#line 210
  setup_data___19(bus___0, data);
#line 212
  chain_shift_data_registers(chain___0, 0);
#line 214
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 0);
#line 215
  chain_shift_data_registers(chain___0, 0);
#line 216
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 217
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 1);
#line 218
  unselect_flash___2(bus___0);
#line 219
  chain_shift_data_registers(chain___0, 0);
  }
#line 220
  return;
}
}
#line 222 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static int bf548_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 225
  area->description = (char const   *)((void *)0);
#line 226
  area->start = 0U;
#line 227
  area->length = 4294967296UL;
#line 228
  area->width = 16U;
#line 230
  return (0);
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 236
  free(bus___0->params);
#line 237
  free((void *)bus___0);
  }
#line 238
  return;
}
}
#line 240
static bus_t *bf548_ezkit_bus_new(char **cmd_params___0 ) ;
#line 242 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
struct bus_driver  const  bf548_ezkit_bus  = 
#line 242
     {"bf548_ezkit", "Blackfin BF548 EZ-KIT board bus driver", & bf548_ezkit_bus_new,
    & bf548_ezkit_bus_free, & bf548_ezkit_bus_printinfo, & bf548_ezkit_bus_prepare,
    & bf548_ezkit_bus_area, & bf548_ezkit_bus_read_start, & bf548_ezkit_bus_read_next,
    & bf548_ezkit_bus_read_end, & bf548_ezkit_bus_read, & bf548_ezkit_bus_write, (int (*)(bus_t *bus ))0};
#line 258 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf548_ezkit.c"
static bus_t *bf548_ezkit_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 264
  failed = 0;
#line 266
  if (! chain) {
#line 267
    return ((bus_t *)((void *)0));
  } else
#line 266
  if (! chain->parts) {
#line 267
    return ((bus_t *)((void *)0));
  } else
#line 266
  if ((chain->parts)->len <= chain->active_part) {
#line 267
    return ((bus_t *)((void *)0));
  } else
#line 266
  if (chain->active_part < 0) {
#line 267
    return ((bus_t *)((void *)0));
  }
  {
#line 269
  tmp = malloc(sizeof(bus_t ));
#line 269
  bus___0 = (bus_t *)tmp;
  }
#line 270
  if (! bus___0) {
#line 271
    return ((bus_t *)((void *)0));
  }
  {
#line 273
  bus___0->driver = & bf548_ezkit_bus;
#line 274
  bus___0->params = malloc(sizeof(bus_params_t___20 ));
  }
#line 275
  if (! bus___0->params) {
    {
#line 276
    free((void *)bus___0);
    }
#line 277
    return ((bus_t *)((void *)0));
  }
#line 280
  ((bus_params_t___20 *)bus___0->params)->chain = chain;
#line 281
  ((bus_params_t___20 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < 4)) {
#line 283
      goto while_break;
    }
    {
#line 284
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS%dB",
            i);
#line 285
    ((bus_params_t___20 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 286
    if (! ((bus_params_t___20 *)bus___0->params)->ams[i]) {
      {
#line 287
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 287
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 288
      failed = 1;
      }
#line 289
      goto while_break;
    }
#line 283
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (i < 3)) {
#line 293
      goto while_break___0;
    }
    {
#line 294
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 295
    ((bus_params_t___20 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 296
    if (! ((bus_params_t___20 *)bus___0->params)->addr[i]) {
      {
#line 297
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 297
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 298
      failed = 1;
      }
#line 299
      goto while_break___0;
    }
#line 293
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  i = 3;
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 303
    if (! (i < 9)) {
#line 303
      goto while_break___1;
    }
    {
#line 304
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTH_%d",
            i + 5);
#line 305
    ((bus_params_t___20 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 306
    if (! ((bus_params_t___20 *)bus___0->params)->addr[i]) {
      {
#line 307
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 307
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 308
      failed = 1;
      }
#line 309
      goto while_break___1;
    }
#line 303
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 313
  i = 9;
  {
#line 313
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 313
    if (! (i < 24)) {
#line 313
      goto while_break___2;
    }
    {
#line 314
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTI_%d",
            i - 9);
#line 315
    ((bus_params_t___20 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 316
    if (! ((bus_params_t___20 *)bus___0->params)->addr[i]) {
      {
#line 317
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 317
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 318
      failed = 1;
      }
#line 319
      goto while_break___2;
    }
#line 313
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 323
    if (! (i < 16)) {
#line 323
      goto while_break___3;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 325
    ((bus_params_t___20 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___20 *)bus___0->params)->data[i]) {
      {
#line 327
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break___3;
    }
#line 323
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 333
  ((bus_params_t___20 *)bus___0->params)->awe = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                 "AWEB");
  }
#line 334
  if (! ((bus_params_t___20 *)bus___0->params)->awe) {
    {
#line 335
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 335
    printf((char const   */* __restrict  */)tmp___5, "AWEB");
#line 336
    failed = 1;
    }
  }
  {
#line 339
  ((bus_params_t___20 *)bus___0->params)->are = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                 "AREB");
  }
#line 340
  if (! ((bus_params_t___20 *)bus___0->params)->are) {
    {
#line 341
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 341
    printf((char const   */* __restrict  */)tmp___6, "AREB");
#line 342
    failed = 1;
    }
  }
  {
#line 345
  ((bus_params_t___20 *)bus___0->params)->aoe = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                 "AOEB");
  }
#line 346
  if (! ((bus_params_t___20 *)bus___0->params)->aoe) {
    {
#line 347
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 347
    printf((char const   */* __restrict  */)tmp___7, "AOEB");
#line 348
    failed = 1;
    }
  }
  {
#line 351
  ((bus_params_t___20 *)bus___0->params)->dcs0 = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                  "CS0_B");
  }
#line 352
  if (! ((bus_params_t___20 *)bus___0->params)->dcs0) {
    {
#line 353
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 353
    printf((char const   */* __restrict  */)tmp___8, "CS0_B");
#line 354
    failed = 1;
    }
  }
  {
#line 357
  ((bus_params_t___20 *)bus___0->params)->nce = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                 "PORTJ_1");
  }
#line 358
  if (! ((bus_params_t___20 *)bus___0->params)->nce) {
    {
#line 359
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 359
    printf((char const   */* __restrict  */)tmp___9, "PORTJ_1");
#line 360
    failed = 1;
    }
  }
#line 363
  if (failed) {
    {
#line 364
    free(bus___0->params);
#line 365
    free((void *)bus___0);
    }
#line 366
    return ((bus_t *)((void *)0));
  }
#line 369
  return (bus___0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void select_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 0);
#line 78
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 0);
#line 80
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void unselect_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 89
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 91
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 1);
#line 92
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 93
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 94
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 96
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 100
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void setup_address___20(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 109
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 19)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void set_data_in___20(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void setup_data___20(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((((bus_params_t___21 *)bus___0->params)->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )((bus_params_t___21 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___21 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF537 Stamp compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < ((((bus_params_t___21 *)bus___0->params)->chain)->parts)->len)) {
#line 152
      goto while_break;
    }
#line 153
    if ((unsigned long )((bus_params_t___21 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___21 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 154
      goto while_break;
    }
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp = gettext("Blackfin BF537 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 155
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 161
  part_set_instruction(((bus_params_t___21 *)bus___0->params)->part, "EXTEST");
#line 162
  chain_shift_instructions(((bus_params_t___21 *)bus___0->params)->chain);
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 168
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 169
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 171
  select_flash___3(bus___0);
#line 172
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 0);
#line 173
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 175
  setup_address___20(bus___0, adr);
#line 176
  set_data_in___20(bus___0);
#line 178
  chain_shift_data_registers(chain___0, 0);
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 184
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 185
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 187
  d = (uint32_t )0;
#line 189
  setup_address___20(bus___0, adr);
#line 190
  chain_shift_data_registers(chain___0, 1);
#line 192
  i = 0;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < 16)) {
#line 192
      goto while_break;
    }
    {
#line 193
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 193
    d |= (uint32_t )(tmp << i);
#line 192
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (d);
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 201
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 202
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 204
  d = (uint32_t )0;
#line 206
  unselect_flash___3(bus___0);
#line 207
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 210
  chain_shift_data_registers(chain___0, 1);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < 16)) {
#line 212
      goto while_break;
    }
    {
#line 213
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 213
    d |= (uint32_t )(tmp << i);
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (d);
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 221
  bf537_stamp_bus_read_start(bus___0, adr);
#line 222
  tmp = bf537_stamp_bus_read_end(bus___0);
  }
#line 222
  return (tmp);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 228
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 229
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 233
  select_flash___3(bus___0);
#line 234
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 236
  setup_address___20(bus___0, adr);
#line 237
  setup_data___20(bus___0, data);
#line 239
  chain_shift_data_registers(chain___0, 0);
#line 241
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 0);
#line 242
  chain_shift_data_registers(chain___0, 0);
#line 243
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 244
  unselect_flash___3(bus___0);
#line 245
  chain_shift_data_registers(chain___0, 0);
  }
#line 246
  return;
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static int bf537_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 251
  area->description = (char const   *)((void *)0);
#line 252
  area->start = 0U;
#line 253
  area->length = 4294967296UL;
#line 254
  area->width = 16U;
#line 256
  return (0);
}
}
#line 259 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 262
  free(bus___0->params);
#line 263
  free((void *)bus___0);
  }
#line 264
  return;
}
}
#line 266
static bus_t *bf537_stamp_bus_new(char **cmd_params___0 ) ;
#line 268 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_stamp_bus  = 
#line 268
     {"bf537_stamp", "Blackfin BF537 Stamp board bus driver", & bf537_stamp_bus_new,
    & bf537_stamp_bus_free, & bf537_stamp_bus_printinfo, & bf537_stamp_bus_prepare,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & bf537_stamp_bus_read, & bf537_stamp_bus_write, (int (*)(bus_t *bus ))0};
#line 283 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_ezkit_bus  = 
#line 283
     {"bf537_ezkit", "Blackfin BF537 EZ-KIT board bus driver", & bf537_stamp_bus_new,
    & bf537_stamp_bus_free, & bf537_ezkit_bus_printinfo, & bf537_stamp_bus_prepare,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & bf537_stamp_bus_read, & bf537_stamp_bus_write, (int (*)(bus_t *bus ))0};
#line 299 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf537_stamp.c"
static bus_t *bf537_stamp_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 305
  failed = 0;
#line 307
  if (! chain) {
#line 308
    return ((bus_t *)((void *)0));
  } else
#line 307
  if (! chain->parts) {
#line 308
    return ((bus_t *)((void *)0));
  } else
#line 307
  if ((chain->parts)->len <= chain->active_part) {
#line 308
    return ((bus_t *)((void *)0));
  } else
#line 307
  if (chain->active_part < 0) {
#line 308
    return ((bus_t *)((void *)0));
  }
  {
#line 310
  tmp = malloc(sizeof(bus_t ));
#line 310
  bus___0 = (bus_t *)tmp;
  }
#line 311
  if (! bus___0) {
#line 312
    return ((bus_t *)((void *)0));
  }
  {
#line 314
  bus___0->driver = & bf537_stamp_bus;
#line 315
  bus___0->params = malloc(sizeof(bus_params_t___21 ));
  }
#line 316
  if (! bus___0->params) {
    {
#line 317
    free((void *)bus___0);
    }
#line 318
    return ((bus_t *)((void *)0));
  }
#line 321
  ((bus_params_t___21 *)bus___0->params)->chain = chain;
#line 322
  ((bus_params_t___21 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 324
  i = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < 4)) {
#line 324
      goto while_break;
    }
    {
#line 325
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 326
    ((bus_params_t___21 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 327
    if (! ((bus_params_t___21 *)bus___0->params)->ams[i]) {
      {
#line 328
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 328
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 329
      failed = 1;
      }
#line 330
      goto while_break;
    }
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  i = 0;
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! (i < 19)) {
#line 334
      goto while_break___0;
    }
    {
#line 335
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 336
    ((bus_params_t___21 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 337
    if (! ((bus_params_t___21 *)bus___0->params)->addr[i]) {
      {
#line 338
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 338
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 339
      failed = 1;
      }
#line 340
      goto while_break___0;
    }
#line 334
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  i = 0;
  {
#line 343
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 343
    if (! (i < 16)) {
#line 343
      goto while_break___1;
    }
    {
#line 344
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 345
    ((bus_params_t___21 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 346
    if (! ((bus_params_t___21 *)bus___0->params)->data[i]) {
      {
#line 347
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 347
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 348
      failed = 1;
      }
#line 349
      goto while_break___1;
    }
#line 343
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 353
  ((bus_params_t___21 *)bus___0->params)->awe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 354
  if (! ((bus_params_t___21 *)bus___0->params)->awe) {
    {
#line 355
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 355
    printf((char const   */* __restrict  */)tmp___3, "AWE_B");
#line 356
    failed = 1;
    }
  }
  {
#line 359
  ((bus_params_t___21 *)bus___0->params)->are = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "ARE_B");
  }
#line 360
  if (! ((bus_params_t___21 *)bus___0->params)->are) {
    {
#line 361
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 361
    printf((char const   */* __restrict  */)tmp___4, "ARE_B");
#line 362
    failed = 1;
    }
  }
  {
#line 365
  ((bus_params_t___21 *)bus___0->params)->abe[0] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                    "ABE_B0");
  }
#line 366
  if (! ((bus_params_t___21 *)bus___0->params)->abe[0]) {
    {
#line 367
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 367
    printf((char const   */* __restrict  */)tmp___5, "ABE_B0");
#line 368
    failed = 1;
    }
  }
  {
#line 371
  ((bus_params_t___21 *)bus___0->params)->abe[1] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                    "ABE_B1");
  }
#line 372
  if (! ((bus_params_t___21 *)bus___0->params)->abe[1]) {
    {
#line 373
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 373
    printf((char const   */* __restrict  */)tmp___6, "ABE_B1");
#line 374
    failed = 1;
    }
  }
  {
#line 377
  ((bus_params_t___21 *)bus___0->params)->sras = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 378
  if (! ((bus_params_t___21 *)bus___0->params)->sras) {
    {
#line 379
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 379
    printf((char const   */* __restrict  */)tmp___7, "SRAS_B");
#line 380
    failed = 1;
    }
  }
  {
#line 383
  ((bus_params_t___21 *)bus___0->params)->scas = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 384
  if (! ((bus_params_t___21 *)bus___0->params)->scas) {
    {
#line 385
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 385
    printf((char const   */* __restrict  */)tmp___8, "SCAS_B");
#line 386
    failed = 1;
    }
  }
  {
#line 389
  ((bus_params_t___21 *)bus___0->params)->swe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 390
  if (! ((bus_params_t___21 *)bus___0->params)->swe) {
    {
#line 391
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 391
    printf((char const   */* __restrict  */)tmp___9, "SWE_B");
#line 392
    failed = 1;
    }
  }
  {
#line 395
  ((bus_params_t___21 *)bus___0->params)->sms = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SMS_B");
  }
#line 396
  if (! ((bus_params_t___21 *)bus___0->params)->sms) {
    {
#line 397
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 397
    printf((char const   */* __restrict  */)tmp___10, "SMS_B");
#line 398
    failed = 1;
    }
  }
#line 401
  if (failed) {
    {
#line 402
    free(bus___0->params);
#line 403
    free((void *)bus___0);
    }
#line 404
    return ((bus_t *)((void *)0));
  }
#line 407
  return (bus___0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void select_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 0);
#line 75
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 0);
#line 76
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 80
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void unselect_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 89
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 91
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 0);
#line 92
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 0);
#line 94
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 1);
#line 95
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 96
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 100
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void setup_address___21(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 109
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 19)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void set_data_in___21(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void setup_data___21(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((((bus_params_t___21 *)bus___0->params)->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )((bus_params_t___21 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___21 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 150
  part_set_instruction(((bus_params_t___21 *)bus___0->params)->part, "EXTEST");
#line 151
  chain_shift_instructions(((bus_params_t___21 *)bus___0->params)->chain);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 157
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 158
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 160
  select_flash___4(bus___0);
#line 161
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 164
  setup_address___21(bus___0, adr);
#line 165
  set_data_in___21(bus___0);
#line 167
  chain_shift_data_registers(chain___0, 0);
  }
#line 168
  return;
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 173
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 174
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 176
  d = (uint32_t )0;
#line 178
  setup_address___21(bus___0, adr);
#line 179
  chain_shift_data_registers(chain___0, 1);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 16)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 190
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 193
  d = (uint32_t )0;
#line 195
  unselect_flash___4(bus___0);
#line 196
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 199
  chain_shift_data_registers(chain___0, 1);
#line 201
  i = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < 16)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 202
    d |= (uint32_t )(tmp << i);
#line 201
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (d);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 210
  bf533_stamp_bus_read_start(bus___0, adr);
#line 211
  tmp = bf533_stamp_bus_read_end(bus___0);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 217
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 218
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 222
  select_flash___4(bus___0);
#line 223
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 225
  setup_address___21(bus___0, adr);
#line 226
  setup_data___21(bus___0, data);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 0);
#line 231
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 233
  unselect_flash___4(bus___0);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static int bf533_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *bf533_stamp_bus_new(char **cmd_params___0 ) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
struct bus_driver  const  bf533_stamp_bus  = 
#line 257
     {"bf533_stamp", "Blackfin BF533 Stamp board bus driver", & bf533_stamp_bus_new,
    & bf533_stamp_bus_free, & bf533_stamp_bus_printinfo, & bf533_stamp_bus_prepare,
    & bf533_stamp_bus_area, & bf533_stamp_bus_read_start, & bf533_stamp_bus_read_next,
    & bf533_stamp_bus_read_end, & bf533_stamp_bus_read, & bf533_stamp_bus_write, (int (*)(bus_t *bus ))0};
#line 272 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_stamp.c"
static bus_t *bf533_stamp_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 278
  failed = 0;
#line 280
  if (! chain) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (! chain->parts) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if ((chain->parts)->len <= chain->active_part) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (chain->active_part < 0) {
#line 281
    return ((bus_t *)((void *)0));
  }
  {
#line 283
  tmp = malloc(sizeof(bus_t ));
#line 283
  bus___0 = (bus_t *)tmp;
  }
#line 284
  if (! bus___0) {
#line 285
    return ((bus_t *)((void *)0));
  }
  {
#line 287
  bus___0->driver = & bf533_stamp_bus;
#line 288
  bus___0->params = malloc(sizeof(bus_params_t___21 ));
  }
#line 289
  if (! bus___0->params) {
    {
#line 290
    free((void *)bus___0);
    }
#line 291
    return ((bus_t *)((void *)0));
  }
#line 294
  ((bus_params_t___21 *)bus___0->params)->chain = chain;
#line 295
  ((bus_params_t___21 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 297
  i = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (i < 2)) {
#line 297
      goto while_break;
    }
    {
#line 298
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PF%d",
            i);
#line 299
    ((bus_params_t___21 *)bus___0->params)->abe[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 300
    if (! ((bus_params_t___21 *)bus___0->params)->abe[i]) {
      {
#line 301
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 301
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 302
      failed = 1;
      }
#line 303
      goto while_break;
    }
#line 297
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 4)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 309
    ((bus_params_t___21 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___21 *)bus___0->params)->ams[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! (i < 19)) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 319
    ((bus_params_t___21 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 320
    if (! ((bus_params_t___21 *)bus___0->params)->addr[i]) {
      {
#line 321
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 321
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 322
      failed = 1;
      }
#line 323
      goto while_break___1;
    }
#line 317
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 326
    if (! (i < 16)) {
#line 326
      goto while_break___2;
    }
    {
#line 327
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 328
    ((bus_params_t___21 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 329
    if (! ((bus_params_t___21 *)bus___0->params)->data[i]) {
      {
#line 330
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 330
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 331
      failed = 1;
      }
#line 332
      goto while_break___2;
    }
#line 326
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 336
  ((bus_params_t___21 *)bus___0->params)->awe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 337
  if (! ((bus_params_t___21 *)bus___0->params)->awe) {
    {
#line 338
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 338
    printf((char const   */* __restrict  */)tmp___4, "AWE_B");
#line 339
    failed = 1;
    }
  }
  {
#line 342
  ((bus_params_t___21 *)bus___0->params)->are = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "AOE_B");
  }
#line 343
  if (! ((bus_params_t___21 *)bus___0->params)->are) {
    {
#line 344
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 344
    printf((char const   */* __restrict  */)tmp___5, "AOE_B");
#line 345
    failed = 1;
    }
  }
  {
#line 348
  ((bus_params_t___21 *)bus___0->params)->sras = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 349
  if (! ((bus_params_t___21 *)bus___0->params)->sras) {
    {
#line 350
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 350
    printf((char const   */* __restrict  */)tmp___6, "SRAS_B");
#line 351
    failed = 1;
    }
  }
  {
#line 354
  ((bus_params_t___21 *)bus___0->params)->scas = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 355
  if (! ((bus_params_t___21 *)bus___0->params)->scas) {
    {
#line 356
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 356
    printf((char const   */* __restrict  */)tmp___7, "SCAS_B");
#line 357
    failed = 1;
    }
  }
  {
#line 360
  ((bus_params_t___21 *)bus___0->params)->swe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 361
  if (! ((bus_params_t___21 *)bus___0->params)->swe) {
    {
#line 362
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 362
    printf((char const   */* __restrict  */)tmp___8, "SWE_B");
#line 363
    failed = 1;
    }
  }
  {
#line 366
  ((bus_params_t___21 *)bus___0->params)->sms = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SMS_B");
  }
#line 367
  if (! ((bus_params_t___21 *)bus___0->params)->sms) {
    {
#line 368
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 368
    printf((char const   */* __restrict  */)tmp___9, "SMS_B");
#line 369
    failed = 1;
    }
  }
#line 372
  if (failed) {
    {
#line 373
    free(bus___0->params);
#line 374
    free((void *)bus___0);
    }
#line 375
    return ((bus_t *)((void *)0));
  }
#line 378
  return (bus___0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void select_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 0);
#line 78
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 0);
#line 80
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void unselect_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 89
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 91
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 1);
#line 92
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 93
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 94
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 96
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[0], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->abe[1], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sras, 1, 1);
#line 100
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->scas, 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->swe, 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->sms, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void setup_address___22(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 109
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 19)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void set_data_in___22(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void setup_data___22(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((((bus_params_t___21 *)bus___0->params)->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )((bus_params_t___21 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___21 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 EZKit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 150
  part_set_instruction(((bus_params_t___21 *)bus___0->params)->part, "EXTEST");
#line 151
  chain_shift_instructions(((bus_params_t___21 *)bus___0->params)->chain);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 157
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 158
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 160
  select_flash___5(bus___0);
#line 161
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 164
  setup_address___22(bus___0, adr);
#line 165
  set_data_in___22(bus___0);
#line 167
  chain_shift_data_registers(chain___0, 0);
  }
#line 168
  return;
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 173
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 174
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 176
  d = (uint32_t )0;
#line 178
  setup_address___22(bus___0, adr);
#line 179
  chain_shift_data_registers(chain___0, 1);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 16)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 190
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 193
  d = (uint32_t )0;
#line 195
  unselect_flash___5(bus___0);
#line 196
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 199
  chain_shift_data_registers(chain___0, 1);
#line 201
  i = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < 16)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 202
    d |= (uint32_t )(tmp << i);
#line 201
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (d);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 210
  bf533_ezkit_bus_read_start(bus___0, adr);
#line 211
  tmp = bf533_ezkit_bus_read_end(bus___0);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 217
  p = ((bus_params_t___21 *)bus___0->params)->part;
#line 218
  chain___0 = ((bus_params_t___21 *)bus___0->params)->chain;
#line 222
  select_flash___5(bus___0);
#line 223
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 225
  setup_address___22(bus___0, adr);
#line 226
  setup_data___22(bus___0, data);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 0);
#line 231
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 233
  unselect_flash___5(bus___0);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static int bf533_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *bf533_ezkit_bus_new(char **cmd_params___0 ) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
struct bus_driver  const  bf533_ezkit_bus  = 
#line 257
     {"bf533_ezkit", "Blackfin BF533 EZKit board bus driver", & bf533_ezkit_bus_new,
    & bf533_ezkit_bus_free, & bf533_ezkit_bus_printinfo, & bf533_ezkit_bus_prepare,
    & bf533_ezkit_bus_area, & bf533_ezkit_bus_read_start, & bf533_ezkit_bus_read_next,
    & bf533_ezkit_bus_read_end, & bf533_ezkit_bus_read, & bf533_ezkit_bus_write, (int (*)(bus_t *bus ))0};
#line 272 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bf533_ezkit.c"
static bus_t *bf533_ezkit_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 278
  failed = 0;
#line 280
  if (! chain) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (! chain->parts) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if ((chain->parts)->len <= chain->active_part) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (chain->active_part < 0) {
#line 281
    return ((bus_t *)((void *)0));
  }
  {
#line 283
  tmp = malloc(sizeof(bus_t ));
#line 283
  bus___0 = (bus_t *)tmp;
  }
#line 284
  if (! bus___0) {
#line 285
    return ((bus_t *)((void *)0));
  }
  {
#line 287
  bus___0->driver = & bf533_ezkit_bus;
#line 288
  bus___0->params = malloc(sizeof(bus_params_t___21 ));
  }
#line 289
  if (! bus___0->params) {
    {
#line 290
    free((void *)bus___0);
    }
#line 291
    return ((bus_t *)((void *)0));
  }
#line 294
  ((bus_params_t___21 *)bus___0->params)->chain = chain;
#line 295
  ((bus_params_t___21 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 297
  i = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (i < 4)) {
#line 297
      goto while_break;
    }
    {
#line 298
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 299
    ((bus_params_t___21 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 300
    if (! ((bus_params_t___21 *)bus___0->params)->ams[i]) {
      {
#line 301
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 301
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 302
      failed = 1;
      }
#line 303
      goto while_break;
    }
#line 297
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 19)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 309
    ((bus_params_t___21 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___21 *)bus___0->params)->addr[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 316
    if (! (i < 16)) {
#line 316
      goto while_break___1;
    }
    {
#line 317
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 318
    ((bus_params_t___21 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 319
    if (! ((bus_params_t___21 *)bus___0->params)->data[i]) {
      {
#line 320
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 320
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 321
      failed = 1;
      }
#line 322
      goto while_break___1;
    }
#line 316
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 326
  ((bus_params_t___21 *)bus___0->params)->awe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 327
  if (! ((bus_params_t___21 *)bus___0->params)->awe) {
    {
#line 328
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 328
    printf((char const   */* __restrict  */)tmp___3, "AWE_B");
#line 329
    failed = 1;
    }
  }
  {
#line 332
  ((bus_params_t___21 *)bus___0->params)->are = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "AOE_B");
  }
#line 333
  if (! ((bus_params_t___21 *)bus___0->params)->are) {
    {
#line 334
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___4, "AOE_B");
#line 335
    failed = 1;
    }
  }
  {
#line 338
  ((bus_params_t___21 *)bus___0->params)->abe[0] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                    "ABE_B0");
  }
#line 339
  if (! ((bus_params_t___21 *)bus___0->params)->abe[0]) {
    {
#line 340
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 340
    printf((char const   */* __restrict  */)tmp___5, "ABE_B0");
#line 341
    failed = 1;
    }
  }
  {
#line 344
  ((bus_params_t___21 *)bus___0->params)->abe[1] = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                    "ABE_B1");
  }
#line 345
  if (! ((bus_params_t___21 *)bus___0->params)->abe[1]) {
    {
#line 346
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 346
    printf((char const   */* __restrict  */)tmp___6, "ABE_B1");
#line 347
    failed = 1;
    }
  }
  {
#line 350
  ((bus_params_t___21 *)bus___0->params)->sras = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 351
  if (! ((bus_params_t___21 *)bus___0->params)->sras) {
    {
#line 352
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 352
    printf((char const   */* __restrict  */)tmp___7, "SRAS_B");
#line 353
    failed = 1;
    }
  }
  {
#line 356
  ((bus_params_t___21 *)bus___0->params)->scas = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 357
  if (! ((bus_params_t___21 *)bus___0->params)->scas) {
    {
#line 358
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 358
    printf((char const   */* __restrict  */)tmp___8, "SCAS_B");
#line 359
    failed = 1;
    }
  }
  {
#line 362
  ((bus_params_t___21 *)bus___0->params)->swe = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 363
  if (! ((bus_params_t___21 *)bus___0->params)->swe) {
    {
#line 364
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 364
    printf((char const   */* __restrict  */)tmp___9, "SWE_B");
#line 365
    failed = 1;
    }
  }
  {
#line 368
  ((bus_params_t___21 *)bus___0->params)->sms = part_find_signal(((bus_params_t___21 *)bus___0->params)->part,
                                                                 "SMS_B");
  }
#line 369
  if (! ((bus_params_t___21 *)bus___0->params)->sms) {
    {
#line 370
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 370
    printf((char const   */* __restrict  */)tmp___10, "SMS_B");
#line 371
    failed = 1;
    }
  }
#line 374
  if (failed) {
    {
#line 375
    free(bus___0->params);
#line 376
    free((void *)bus___0);
    }
#line 377
    return ((bus_t *)((void *)0));
  }
#line 380
  return (bus___0);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void setup_address___23(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 24)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_ad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void set_data_in___23(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 8)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_ad[i + 24], 0, 0);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void setup_data___23(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 88
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < 8)) {
#line 90
      goto while_break;
    }
    {
#line 91
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_ad[i + 24], 1, (int )((d >> i) & 1U));
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void bcm1250_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < ((((bus_params_t___22 *)bus___0->params)->chain)->parts)->len)) {
#line 101
      goto while_break;
    }
#line 102
    if ((unsigned long )((bus_params_t___22 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___22 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 103
      goto while_break;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp = gettext("Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 104
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
void bcm1250_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 110
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 111
  chain___0 = ((bus_params_t___22 *)bus___0->params)->chain;
#line 113
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[0], 1, 0);
#line 114
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[1], 1, 1);
#line 115
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[2], 1, 1);
#line 116
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[3], 1, 1);
#line 117
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[4], 1, 1);
#line 118
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[5], 1, 1);
#line 119
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[6], 1, 1);
#line 120
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[7], 1, 1);
#line 121
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_rw, 1, 1);
#line 122
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_wr_l, 1, 1);
#line 123
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_oe_l, 1, 0);
#line 125
  setup_address___23(bus___0, adr);
#line 126
  set_data_in___23(bus___0);
#line 128
  chain_shift_data_registers(chain___0, 0);
  }
#line 129
  return;
}
}
#line 131 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 134
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 135
  chain___0 = ((bus_params_t___22 *)bus___0->params)->chain;
#line 137
  setup_address___23(bus___0, adr);
#line 138
  chain_shift_data_registers(chain___0, 1);
#line 142
  d = (uint32_t )0;
#line 144
  i = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < 8)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->io_ad[i + 24]);
#line 145
    d |= (uint32_t )(tmp << i);
#line 144
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (d);
}
}
#line 152 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 155
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 156
  chain___0 = ((bus_params_t___22 *)bus___0->params)->chain;
#line 158
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[0], 1, 1);
#line 159
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_oe_l, 1, 1);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 164
  d = (uint32_t )0;
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < 8)) {
#line 166
      goto while_break;
    }
    {
#line 167
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->io_ad[i + 24]);
#line 167
    d |= (uint32_t )(tmp << i);
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (d);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t i ;

  {
  {
#line 178
  bcm1250_bus_read_start(bus___0, adr);
#line 179
  i = bcm1250_bus_read_end(bus___0);
  }
#line 180
  return (i);
}
}
#line 183 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
void bcm1250_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 186
  p = ((bus_params_t___22 *)bus___0->params)->part;
#line 187
  chain___0 = ((bus_params_t___22 *)bus___0->params)->chain;
#line 189
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[0], 1, 0);
#line 190
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[3], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[4], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[5], 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[6], 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_cs_l[7], 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_rw, 1, 0);
#line 198
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_wr_l, 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_oe_l, 1, 1);
#line 201
  setup_address___23(bus___0, adr);
#line 202
  setup_data___23(bus___0, data);
#line 204
  chain_shift_data_registers(chain___0, 0);
#line 206
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_wr_l, 1, 0);
#line 207
  chain_shift_data_registers(chain___0, 0);
#line 209
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->io_wr_l, 1, 1);
#line 210
  chain_shift_data_registers(chain___0, 0);
  }
#line 211
  return;
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static int bcm1250_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
#line 249
  area->description = (char const   *)((void *)0);
#line 250
  area->start = 0U;
#line 251
  area->length = 4294967296UL;
#line 252
  area->width = 8U;
#line 254
  return (0);
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void bcm1250_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 260
  part_set_instruction(((bus_params_t___22 *)bus___0->params)->part, "EXTEST");
#line 261
  chain_shift_instructions(((bus_params_t___22 *)bus___0->params)->chain);
  }
#line 262
  return;
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static void bcm1250_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 267
  free(bus___0->params);
#line 268
  free((void *)bus___0);
  }
#line 269
  return;
}
}
#line 271
static bus_t *bcm1250_bus_new(char **cmd_params___0 ) ;
#line 273 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
struct bus_driver  const  bcm1250_bus  = 
#line 273
     {"bcm1250", "Broadcom BCM1250 compatible bus driver via BSR", & bcm1250_bus_new,
    & bcm1250_bus_free, & bcm1250_bus_printinfo, & bcm1250_bus_prepare, & bcm1250_bus_area,
    & bcm1250_bus_read_start, & bcm1250_bus_read_next, & bcm1250_bus_read_end, & bcm1250_bus_read,
    & bcm1250_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 289 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/bcm1250.c"
static bus_t *bcm1250_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 295
  failed = 0;
#line 297
  if (! chain) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if (! chain->parts) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if ((chain->parts)->len <= chain->active_part) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if (chain->active_part < 0) {
#line 298
    return ((bus_t *)((void *)0));
  }
  {
#line 300
  tmp = malloc(sizeof(bus_t ));
#line 300
  bus___0 = (bus_t *)tmp;
  }
#line 301
  if (! bus___0) {
#line 302
    return ((bus_t *)((void *)0));
  }
  {
#line 304
  bus___0->driver = & bcm1250_bus;
#line 305
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___22 ));
  }
#line 306
  if (! bus___0->params) {
    {
#line 307
    free((void *)bus___0);
    }
#line 308
    return ((bus_t *)((void *)0));
  }
#line 311
  ((bus_params_t___22 *)bus___0->params)->chain = chain;
#line 312
  ((bus_params_t___22 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < 32)) {
#line 314
      goto while_break;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_AD%d",
            i);
#line 316
    ((bus_params_t___22 *)bus___0->params)->io_ad[i] = part_find_signal(((bus_params_t___22 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___22 *)bus___0->params)->io_ad[i]) {
      {
#line 318
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 318
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 319
      failed = 1;
      }
#line 320
      goto while_break;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! (i < 8)) {
#line 323
      goto while_break___0;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_CS_L%d",
            i);
#line 325
    ((bus_params_t___22 *)bus___0->params)->io_cs_l[i] = part_find_signal(((bus_params_t___22 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___22 *)bus___0->params)->io_cs_l[i]) {
      {
#line 327
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break___0;
    }
#line 323
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 332
  ((bus_params_t___22 *)bus___0->params)->io_rw = part_find_signal(((bus_params_t___22 *)bus___0->params)->part,
                                                                   "IO_RW");
  }
#line 333
  if (! ((bus_params_t___22 *)bus___0->params)->io_rw) {
    {
#line 334
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___2, "IO_RW");
#line 335
    failed = 1;
    }
  }
  {
#line 337
  ((bus_params_t___22 *)bus___0->params)->io_wr_l = part_find_signal(((bus_params_t___22 *)bus___0->params)->part,
                                                                     "IO_WR_L");
  }
#line 338
  if (! ((bus_params_t___22 *)bus___0->params)->io_wr_l) {
    {
#line 339
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 339
    printf((char const   */* __restrict  */)tmp___3, "IO_WR_L");
#line 340
    failed = 1;
    }
  }
  {
#line 342
  ((bus_params_t___22 *)bus___0->params)->io_oe_l = part_find_signal(((bus_params_t___22 *)bus___0->params)->part,
                                                                     "IO_OE_L");
  }
#line 343
  if (! ((bus_params_t___22 *)bus___0->params)->io_oe_l) {
    {
#line 344
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 344
    printf((char const   */* __restrict  */)tmp___4, "IO_OE_L");
#line 345
    failed = 1;
    }
  }
#line 348
  if (failed) {
    {
#line 349
    free(bus___0->params);
#line 350
    free((void *)bus___0);
    }
#line 351
    return ((bus_t *)((void *)0));
  }
#line 354
  return (bus___0);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void setup_address___24(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 32)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->rad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void set_data_in___24(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 81
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned int )i < area.width)) {
#line 83
      goto while_break;
    }
    {
#line 84
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->rd[i], 0, 0);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static uint32_t get_data_out(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 92
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 94
  d = (uint32_t )0;
#line 96
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned int )i < area.width)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = part_get_signal(p, ((bus_params_t___23 *)bus___0->params)->rd[i]);
#line 99
    d |= (uint32_t )(tmp << i);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (d);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void setup_data___24(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 108
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 111
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 113
  i = 0;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned int )i < area.width)) {
#line 113
      goto while_break;
    }
    {
#line 114
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->rd[i], 1, (int )((d >> i) & 1U));
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static bus_t *au1500_bus_new(char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 122
  failed = 0;
#line 125
  if (! chain) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if (! chain->parts) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if ((chain->parts)->len <= chain->active_part) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if (chain->active_part < 0) {
#line 126
    return ((bus_t *)((void *)0));
  }
  {
#line 128
  tmp = malloc(sizeof(bus_t ));
#line 128
  bus___0 = (bus_t *)tmp;
  }
#line 129
  if (! bus___0) {
#line 130
    return ((bus_t *)((void *)0));
  }
  {
#line 132
  bus___0->driver = & au1500_bus;
#line 133
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___23 ));
  }
#line 134
  if (! bus___0->params) {
    {
#line 135
    free((void *)bus___0);
    }
#line 136
    return ((bus_t *)((void *)0));
  }
#line 139
  ((bus_params_t___23 *)bus___0->params)->chain = chain;
#line 140
  ((bus_params_t___23 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 32)) {
#line 142
      goto while_break;
    }
    {
#line 143
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RAD%d",
            i);
#line 144
    ((bus_params_t___23 *)bus___0->params)->rad[i] = part_find_signal(((bus_params_t___23 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 145
    if (! ((bus_params_t___23 *)bus___0->params)->rad[i]) {
      {
#line 146
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 146
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 147
      failed = 1;
      }
#line 148
      goto while_break;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! (i < 4)) {
#line 152
      goto while_break___0;
    }
    {
#line 153
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RCE_N%d",
            i);
#line 154
    ((bus_params_t___23 *)bus___0->params)->nrcs[i] = part_find_signal(((bus_params_t___23 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 155
    if (! ((bus_params_t___23 *)bus___0->params)->nrcs[i]) {
      {
#line 156
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 156
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 157
      failed = 1;
      }
#line 158
      goto while_break___0;
    }
#line 152
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 163
  ((bus_params_t___23 *)bus___0->params)->nrwe = part_find_signal(((bus_params_t___23 *)bus___0->params)->part,
                                                                  "RWE_N");
  }
#line 164
  if (! ((bus_params_t___23 *)bus___0->params)->nrwe) {
    {
#line 165
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 165
    printf((char const   */* __restrict  */)tmp___2, "RWE_N");
#line 166
    failed = 1;
    }
  }
  {
#line 169
  ((bus_params_t___23 *)bus___0->params)->nroe = part_find_signal(((bus_params_t___23 *)bus___0->params)->part,
                                                                  "ROE_N");
  }
#line 170
  if (! ((bus_params_t___23 *)bus___0->params)->nroe) {
    {
#line 171
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 171
    printf((char const   */* __restrict  */)tmp___3, "ROE_N");
#line 172
    failed = 1;
    }
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (i < 32)) {
#line 175
      goto while_break___1;
    }
    {
#line 176
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 177
    ((bus_params_t___23 *)bus___0->params)->rd[i] = part_find_signal(((bus_params_t___23 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 178
    if (! ((bus_params_t___23 *)bus___0->params)->rd[i]) {
      {
#line 179
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 179
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 180
      failed = 1;
      }
#line 181
      goto while_break___1;
    }
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 185
  if (failed) {
    {
#line 186
    free(bus___0->params);
#line 187
    free((void *)bus___0);
    }
#line 188
    return ((bus_t *)((void *)0));
  }
#line 191
  return (bus___0);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 198
  area->description = (char const   *)((void *)0);
#line 199
  area->start = 0U;
#line 200
  area->length = 4294967296UL;
#line 202
  tmp___1 = part_find_signal(((bus_params_t___23 *)bus___0->params)->part, "ROMSIZ");
#line 202
  tmp___2 = part_get_signal(((bus_params_t___23 *)bus___0->params)->part, tmp___1);
  }
#line 202
  if (tmp___2) {
#line 202
    area->width = 16U;
  } else {
#line 202
    area->width = 32U;
  }
#line 205
  return (0);
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void au1500_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 212
  free(bus___0->params);
#line 213
  free((void *)bus___0);
  }
#line 214
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void au1500_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 221
  i = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < ((((bus_params_t___23 *)bus___0->params)->chain)->parts)->len)) {
#line 221
      goto while_break;
    }
#line 222
    if ((unsigned long )((bus_params_t___23 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___23 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 223
      goto while_break;
    }
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  tmp = gettext("AU1500 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 224
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 225
  return;
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void au1500_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 230
  part_set_instruction(((bus_params_t___23 *)bus___0->params)->part, "EXTEST");
#line 231
  chain_shift_instructions(((bus_params_t___23 *)bus___0->params)->chain);
  }
#line 232
  return;
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void au1500_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 237
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 238
  chain___0 = ((bus_params_t___23 *)bus___0->params)->chain;
#line 240
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[0], 1, 0);
#line 241
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[1], 1, 1);
#line 242
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[2], 1, 1);
#line 243
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[3], 1, 1);
#line 244
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrwe, 1, 1);
#line 245
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nroe, 1, 0);
#line 247
  setup_address___24(bus___0, adr);
#line 248
  set_data_in___24(bus___0);
#line 250
  chain_shift_data_registers(chain___0, 0);
  }
#line 251
  return;
}
}
#line 253 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static uint32_t au1500_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;
  uint32_t tmp ;

  {
  {
#line 256
  chain___0 = ((bus_params_t___23 *)bus___0->params)->chain;
#line 258
  setup_address___24(bus___0, adr);
#line 259
  chain_shift_data_registers(chain___0, 1);
#line 261
  tmp = get_data_out(bus___0);
  }
#line 261
  return (tmp);
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static uint32_t au1500_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t tmp ;

  {
  {
#line 267
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 268
  chain___0 = ((bus_params_t___23 *)bus___0->params)->chain;
#line 270
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[0], 1, 1);
#line 271
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[1], 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[2], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[3], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrwe, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nroe, 1, 1);
#line 277
  chain_shift_data_registers(chain___0, 1);
#line 279
  tmp = get_data_out(bus___0);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static uint32_t au1500_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 285
  au1500_bus_read_start(bus___0, adr);
#line 286
  tmp = au1500_bus_read_end(bus___0);
  }
#line 286
  return (tmp);
}
}
#line 289 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
static void au1500_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 292
  p = ((bus_params_t___23 *)bus___0->params)->part;
#line 293
  chain___0 = ((bus_params_t___23 *)bus___0->params)->chain;
#line 295
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[0], 1, 0);
#line 296
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[1], 1, 1);
#line 297
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[2], 1, 1);
#line 298
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[3], 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrwe, 1, 1);
#line 300
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nroe, 1, 1);
#line 302
  setup_address___24(bus___0, adr);
#line 303
  setup_data___24(bus___0, data);
#line 305
  chain_shift_data_registers(chain___0, 0);
#line 307
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrwe, 1, 0);
#line 308
  chain_shift_data_registers(chain___0, 0);
#line 310
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrwe, 1, 1);
#line 311
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nroe, 1, 1);
#line 312
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[0], 1, 1);
#line 313
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[1], 1, 1);
#line 314
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[2], 1, 1);
#line 315
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nrcs[3], 1, 1);
#line 317
  chain_shift_data_registers(chain___0, 0);
  }
#line 318
  return;
}
}
#line 320 "/home/khheo/project/benchmark/urjtag-0.8/src/bus/au1500.c"
struct bus_driver  const  au1500_bus  = 
#line 320
     {"au1500", "AU1500 BUS Driver via BSR", & au1500_bus_new, & au1500_bus_free, & au1500_bus_printinfo,
    & au1500_bus_prepare, & au1500_bus_area, & au1500_bus_read_start, & au1500_bus_read_next,
    & au1500_bus_read_end, & au1500_bus_read, & au1500_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 49 "../../include/jtag.h"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 47 "../../include/cmd.h"
int cmd_params(char **params ) ;
#line 48
int cmd_get_number(char *s , unsigned int *i ) ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/writemem.c"
static int cmd_writemem_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 4) {
#line 40
    return (-1);
  }
#line 42
  if (! bus) {
    {
#line 43
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 43
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 47
  if (tmp___1) {
#line 48
    return (-1);
  } else {
    {
#line 47
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 47
    if (tmp___2) {
#line 48
      return (-1);
    }
  }
  {
#line 50
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"r");
  }
#line 51
  if (! f) {
    {
#line 52
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 52
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 53
    return (1);
  }
  {
#line 55
  writemem(bus, f, adr, len);
#line 56
  fclose(f);
  }
#line 58
  return (1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/writemem.c"
static void cmd_writemem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nWrite to device memory starting at ADDR the FILENAME file.\n\nADDR       start address of the written memory area\nLEN        written memory length\nFILENAME   name of the input file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\nNOTE: This is NOT useful for FLASH programming!\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "writemem");
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/writemem.c"
cmd_t cmd_writemem  =    {(char *)"writemem", (char *)"write content of file to the memory", & cmd_writemem_help,
    & cmd_writemem_run};
#line 49 "../../include/cmd.h"
int cmd_test_cable(void) ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/test.c"
static int cmd_test_run(char **params ) 
{ 
  int data ;
  unsigned int i ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 44
  tmp = cmd_params(params);
  }
#line 44
  if (tmp != 4) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 47
  if (tmp___0 != 0) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___1 = cmd_test_cable();
  }
#line 50
  if (! tmp___1) {
#line 51
    return (1);
  }
#line 53
  if (! chain->parts) {
    {
#line 54
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 55
    return (1);
  }
#line 58
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 59
    tmp___3 = gettext("%s: no active part\n");
#line 59
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 60
    return (1);
  }
  {
#line 63
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 64
  if (! s) {
    {
#line 65
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 66
    return (1);
  }
  {
#line 72
  tmp___5 = cmd_get_number(*(params + 3), & i);
  }
#line 72
  if (tmp___5) {
#line 73
    return (1);
  }
  {
#line 75
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 76
  if (data != -1) {
#line 77
    if ((unsigned int )data != i) {
      {
#line 78
      tmp___6 = gettext("<FAIL>%s = %d\n");
#line 78
      printf((char const   */* __restrict  */)tmp___6, *(params + 2), data);
      }
#line 79
      return (-99);
    }
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/test.c"
static void cmd_test_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL 0/1\nTest signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/test.c"
cmd_t cmd_test  =    {(char *)"test", (char *)"test external signal value", & cmd_test_help, & cmd_test_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/svf.c"
static int cmd_svf_run(char **params ) 
{ 
  FILE *SVF_FILE ;
  int num_params ;
  int result ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 38
  result = -1;
#line 40
  num_params = cmd_params(params);
  }
#line 41
  if (num_params == 2) {
#line 41
    goto _L;
  } else
#line 41
  if (num_params == 3) {
    _L: /* CIL Label */ 
    {
#line 42
    SVF_FILE = fopen((char const   */* __restrict  */)*(params + 1), (char const   */* __restrict  */)"r");
    }
#line 42
    if ((unsigned long )SVF_FILE != (unsigned long )((void *)0)) {
#line 44
      if (num_params == 3) {
        {
#line 45
        tmp = strcasecmp((char const   *)*(params + 2), "stop");
        }
#line 45
        if (tmp == 0) {
          {
#line 46
          svf_run(SVF_FILE, 1);
#line 47
          result = 1;
          }
        }
      } else {
        {
#line 50
        svf_run(SVF_FILE, 0);
#line 51
        result = 1;
        }
      }
      {
#line 54
      fclose(SVF_FILE);
      }
    } else {
      {
#line 56
      tmp___0 = gettext("%s: cannot open file \'%s\' for reading\n");
#line 56
      printf((char const   */* __restrict  */)tmp___0, "svf", *(params + 1));
      }
    }
  }
#line 61
  return (result);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/svf.c"
static void cmd_svf_help(void) 
{ 
  char *tmp ;

  {
  {
#line 68
  tmp = gettext("Usage: %s FILE\nUsage: %s FILE stop\nExecute svf commands from FILE.\nCommand execution stops upon TDO mismatch when \'stop\' is specified.\n\nFILE file containing SVF commans\n");
#line 68
  printf((char const   */* __restrict  */)tmp, "svf", "svf");
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/svf.c"
cmd_t cmd_svf  =    {(char *)"svf", (char *)"execute svf commands from file", & cmd_svf_help, & cmd_svf_run};
#line 49 "../../include/bssignal.h"
signal_t *signal_alloc(char const   *name ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/signal.c"
static int cmd_signal_run(char **params ) 
{ 
  part_t *part___0 ;
  signal_t *s ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 42
  i = cmd_params(params);
  }
#line 42
  if (i < 2) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable();
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "signal");
    }
#line 56
    return (1);
  }
  {
#line 59
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 60
  s = part_find_signal(part___0, (char const   *)*(params + 1));
  }
#line 60
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 61
    if (i == 3) {
      {
#line 62
      printf((char const   */* __restrict  */)"Defining pin for signal %s\n", s->name);
      }
#line 64
      if (s->pin) {
        {
#line 64
        free((void *)s->pin);
        }
      }
      {
#line 67
      tmp___2 = strlen((char const   *)*(params + 2));
#line 67
      tmp___3 = malloc(tmp___2 + 1UL);
#line 67
      s->pin = (char *)tmp___3;
#line 68
      strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
      }
#line 70
      return (1);
    } else {
      {
#line 73
      tmp___4 = gettext("Signal \'%s\' already defined\n");
#line 73
      printf((char const   */* __restrict  */)tmp___4, *(params + 1));
      }
#line 74
      return (1);
    }
  }
  {
#line 78
  s = signal_alloc((char const   *)*(params + 1));
  }
#line 80
  if (i == 3) {
    {
#line 82
    tmp___5 = strlen((char const   *)*(params + 2));
#line 82
    tmp___6 = malloc(tmp___5 + 1UL);
#line 82
    s->pin = (char *)tmp___6;
#line 83
    strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
    }
  }
#line 87
  if (! s) {
    {
#line 88
    tmp___7 = gettext("out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 89
    return (1);
  }
#line 92
  s->next = part___0->signals;
#line 93
  part___0->signals = s;
#line 95
  return (1);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/signal.c"
static void cmd_signal_help(void) 
{ 
  char *tmp ;

  {
  {
#line 101
  tmp = gettext("Usage: %s SIGNAL [PIN#]\nDefine new signal with name SIGNAL for a part.\n\nSIGNAL\t\tNew signal name\nPIN#   \tList of pin # for a signal\n");
#line 101
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/signal.c"
cmd_t cmd_signal  =    {(char *)"signal", (char *)"define new signal for a part", & cmd_signal_help, & cmd_signal_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shift.c"
static int cmd_shift_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp != 2) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable();
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tmp___1 = strcasecmp((char const   *)*(params + 1), "ir");
  }
#line 44
  if (tmp___1 == 0) {
    {
#line 45
    chain_shift_instructions(chain);
    }
#line 46
    return (1);
  }
  {
#line 48
  tmp___2 = strcasecmp((char const   *)*(params + 1), "dr");
  }
#line 48
  if (tmp___2 == 0) {
    {
#line 49
    chain_shift_data_registers(chain, 1);
    }
#line 50
    return (1);
  }
#line 53
  return (-1);
}
}
#line 56 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shift.c"
static void cmd_shift_help(void) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = gettext("Usage: %s\nUsage: %s\nShift instruction or data register through JTAG chain.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "shift ir", "shift dr");
  }
#line 64
  return;
}
}
#line 66 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shift.c"
cmd_t cmd_shift  =    {(char *)"shift", (char *)"shift data/instruction registers through JTAG chain",
    & cmd_shift_help, & cmd_shift_run};
#line 781 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shell.c"
static int cmd_shell_run(char **params ) 
{ 
  int i ;
  int len ;
  int n ;
  int tmp ;
  char *shell_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 42
  tmp = cmd_params(params);
#line 42
  n = tmp;
#line 45
  n = cmd_params(params);
  }
#line 45
  if (n == 1) {
#line 46
    return (-1);
  }
#line 57
  i = 1;
#line 57
  len = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < n)) {
#line 57
      goto while_break;
    }
    {
#line 57
    tmp___0 = strlen((char const   *)*(params + i));
#line 57
    len = (int )((size_t )len + (1UL + tmp___0));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___1 = malloc((size_t )len);
#line 59
  shell_cmd = (char *)tmp___1;
  }
#line 60
  if ((unsigned long )shell_cmd == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___2 = gettext("Out of memory\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return (-1);
  }
  {
#line 66
  strcpy((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + 1));
#line 67
  i = 2;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < n)) {
#line 67
      goto while_break___0;
    }
    {
#line 69
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)" ");
#line 70
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + i));
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  printf((char const   */* __restrict  */)"Executing \'%s\'\n", shell_cmd);
#line 74
  system((char const   *)shell_cmd);
#line 75
  free((void *)shell_cmd);
  }
#line 77
  return (1);
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shell.c"
static void cmd_shell_help(void) 
{ 
  char *tmp ;

  {
  {
#line 83
  tmp = gettext("Usage: %s cmmd\nShell out to os for a command.\n\nCMMD OS Shell Command\n");
#line 83
  printf((char const   */* __restrict  */)tmp, "shell cmmd");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/shell.c"
cmd_t cmd_shell  =    {(char *)"shell", (char *)"shell cmmd", & cmd_shell_help, & cmd_shell_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/set.c"
static int cmd_set_run(char **params ) 
{ 
  int dir ;
  unsigned int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 40
  data = 0U;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 4) {
#line 44
    return (-1);
  } else {
    {
#line 43
    tmp___0 = cmd_params(params);
    }
#line 43
    if (tmp___0 > 5) {
#line 44
      return (-1);
    }
  }
  {
#line 46
  tmp___1 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 46
  if (tmp___1 != 0) {
#line 47
    return (-1);
  }
  {
#line 49
  tmp___2 = cmd_test_cable();
  }
#line 49
  if (! tmp___2) {
#line 50
    return (1);
  }
#line 52
  if (! chain->parts) {
    {
#line 53
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 54
    return (1);
  }
#line 57
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 58
    tmp___4 = gettext("%s: no active part\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "set");
    }
#line 59
    return (1);
  }
  {
#line 63
  tmp___5 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 63
  if (tmp___5 != 0) {
    {
#line 63
    tmp___6 = strcasecmp((char const   *)*(params + 3), "out");
    }
#line 63
    if (tmp___6 != 0) {
#line 64
      return (-1);
    }
  }
  {
#line 66
  tmp___8 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 66
  if (tmp___8 == 0) {
#line 66
    dir = 0;
  } else {
#line 66
    dir = 1;
  }
#line 68
  if (dir) {
    {
#line 69
    tmp___9 = cmd_get_number(*(params + 4), & data);
    }
#line 69
    if (tmp___9) {
#line 70
      return (-1);
    }
#line 71
    if (data > 1U) {
#line 72
      return (-1);
    }
  }
  {
#line 75
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 76
  if (! s) {
    {
#line 77
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 77
    printf((char const   */* __restrict  */)tmp___10, *(params + 2));
    }
#line 78
    return (1);
  }
  {
#line 80
  part_set_signal(*((chain->parts)->parts + chain->active_part), s, dir, (int )data);
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/set.c"
static void cmd_set_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL DIR [DATA]\nSet signal state in input BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\nDIR           requested signal direction; possible values: \'in\' or \'out\'\nDATA          desired output signal value (\'0\' or \'1\'); used only if DIR\n                is \'out\'\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "set signal");
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/set.c"
cmd_t cmd_set  =    {(char *)"set", (char *)"set external signal value", & cmd_set_help, & cmd_set_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/scan.c"
static int cmd_scan_run(char **params ) 
{ 
  part_t *part___0 ;
  data_register *bsr ;
  tap_register *obsr ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  instruction *tmp___4 ;
  instruction *tmp___5 ;
  char *tmp___6 ;
  signal_t *s ;
  char const   *tmp___7 ;
  int old ;
  int new ;
  salias_t *a ;
  char *tmp___8 ;

  {
  {
#line 43
  i = cmd_params(params);
  }
#line 43
  if (i < 1) {
#line 44
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable();
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "scan");
    }
#line 56
    return (1);
  }
  {
#line 59
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 62
  bsr = part_find_data_register(part___0, "BSR");
  }
#line 63
  if (! bsr) {
    {
#line 64
    tmp___2 = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 64
    printf((char const   */* __restrict  */)tmp___2, "cmd_scan_run", "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/scan.c",
           64);
    }
#line 65
    return (1);
  }
  {
#line 68
  tmp___5 = part_find_instruction(part___0, "SAMPLE");
  }
#line 68
  if (tmp___5) {
    {
#line 70
    part_set_instruction(part___0, "SAMPLE");
    }
  } else {
    {
#line 72
    tmp___4 = part_find_instruction(part___0, "SAMPLE/PRELOAD");
    }
#line 72
    if (tmp___4) {
      {
#line 74
      part_set_instruction(part___0, "SAMPLE/PRELOAD");
      }
    } else {
      {
#line 78
      tmp___3 = gettext("%s(%s:%d) Part can\'t SAMPLE\n");
#line 78
      printf((char const   */* __restrict  */)tmp___3, "cmd_scan_run", "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/scan.c",
             78);
      }
#line 79
      return (1);
    }
  }
  {
#line 82
  chain_shift_instructions(chain);
#line 84
  obsr = register_alloc((bsr->out)->len);
  }
#line 86
  if (! obsr) {
    {
#line 88
    tmp___6 = gettext("Out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 89
    return (1);
  }
  {
#line 95
  tmp___7 = register_get_string((tap_register const   *)bsr->out);
#line 95
  register_init(obsr, tmp___7);
#line 97
  chain_shift_data_registers(chain, 1);
#line 99
  s = part___0->signals;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! s) {
#line 99
      goto while_break;
    }
#line 101
    if ((unsigned long )s->input != (unsigned long )((void *)0)) {
#line 103
      old = (int )*(obsr->data + (s->input)->bit);
#line 104
      new = (int )*((bsr->out)->data + (s->input)->bit);
#line 105
      if (old != new) {
        {
#line 108
        printf((char const   */* __restrict  */)"%s", s->name);
#line 109
        a = part___0->saliases;
        }
        {
#line 109
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 109
          if (! a) {
#line 109
            goto while_break___0;
          }
#line 111
          if ((unsigned long )a->signal == (unsigned long )s) {
            {
#line 111
            printf((char const   */* __restrict  */)",%s", a->name);
            }
          }
#line 109
          a = a->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 113
        tmp___8 = gettext(": %d > %d\n");
#line 113
        printf((char const   */* __restrict  */)tmp___8, old, new);
        }
      }
    }
#line 99
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  register_free(obsr);
  }
#line 121
  return (1);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/scan.c"
static void cmd_scan_help(void) 
{ 
  char *tmp ;

  {
  {
#line 127
  tmp = gettext("Usage: %s [SIGNAL]* \nRead BSR and show changes since last scan.\n");
#line 127
  printf((char const   */* __restrict  */)tmp, "scan");
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/scan.c"
cmd_t cmd_scan  =    {(char *)"scan", (char *)"read BSR and show changes since last scan", & cmd_scan_help,
    & cmd_scan_run};
#line 52 "../../include/bssignal.h"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/salias.c"
static int cmd_salias_run(char **params ) 
{ 
  part_t *part___0 ;
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  signal_t *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable();
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
#line 48
  if (! chain->parts) {
    {
#line 49
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 50
    return (1);
  }
#line 53
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 54
    tmp___2 = gettext("%s: no active part\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2, "signal");
    }
#line 55
    return (1);
  }
  {
#line 58
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 59
  tmp___4 = part_find_signal(part___0, (char const   *)*(params + 1));
  }
#line 59
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___3 = gettext("Signal \'%s\' already defined\n");
#line 60
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 61
    return (1);
  }
  {
#line 64
  s = part_find_signal(part___0, (char const   *)*(params + 2));
  }
#line 65
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 66
    tmp___5 = gettext("Signal \'%s\' not found\n");
#line 66
    printf((char const   */* __restrict  */)tmp___5, *(params + 2));
    }
#line 67
    return (1);
  }
  {
#line 70
  sa = salias_alloc((char const   *)*(params + 1), (signal_t const   *)s);
  }
#line 71
  if (! sa) {
    {
#line 72
    tmp___6 = gettext("out of memory\n");
#line 72
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 73
    return (1);
  }
#line 76
  sa->next = part___0->saliases;
#line 77
  part___0->saliases = sa;
#line 79
  return (1);
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/salias.c"
static void cmd_salias_help(void) 
{ 
  char *tmp ;

  {
  {
#line 85
  tmp = gettext("Usage: %s ALIAS SIGNAL\nDefine new signal ALIAS as alias for existing SIGNAL.\n\nALIAS         New signal alias name\nSIGNAL        Existing signal name\n");
#line 85
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/salias.c"
struct __anonstruct_cmd_t_148900231  const  cmd_salias  =    {(char *)"salias", (char *)"define an alias for a signal", & cmd_salias_help, & cmd_salias_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/reset.c"
void jtag_reset(chain_t *chain___0 ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/reset.c"
static int cmd_reset_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp > 1) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
  {
#line 45
  jtag_reset(chain);
  }
#line 47
  return (1);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/reset.c"
static void cmd_reset_help(void) 
{ 
  char *tmp ;

  {
  {
#line 53
  tmp = gettext("Usage: %s\nReset current JTAG chain.\n");
#line 53
  printf((char const   */* __restrict  */)tmp, "reset");
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/reset.c"
cmd_t cmd_reset  =    {(char *)"reset", (char *)"reset JTAG chain", & cmd_reset_help, & cmd_reset_run};
#line 41 "../../include/data_register.h"
data_register *data_register_alloc(char const   *name , int len ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/register.c"
static int cmd_register_run(char **params ) 
{ 
  part_t *part___0 ;
  unsigned int len ;
  data_register *dr___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  data_register *tmp___5 ;
  char *tmp___6 ;
  int i ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp___0 = cmd_test_cable();
  }
#line 46
  if (! tmp___0) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___2 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___2, "register");
    }
#line 56
    return (1);
  }
  {
#line 59
  tmp___3 = cmd_get_number(*(params + 2), & len);
  }
#line 59
  if (tmp___3) {
#line 60
    return (-1);
  }
  {
#line 62
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 64
  tmp___5 = part_find_data_register(part___0, (char const   *)*(params + 1));
  }
#line 64
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
    {
#line 65
    tmp___4 = gettext("Data register \'%s\' already defined\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 1));
    }
#line 66
    return (1);
  }
  {
#line 69
  dr___0 = data_register_alloc((char const   *)*(params + 1), (int )len);
  }
#line 70
  if (! dr___0) {
    {
#line 71
    tmp___6 = gettext("out of memory\n");
#line 71
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 72
    return (1);
  }
  {
#line 75
  dr___0->next = part___0->data_registers;
#line 76
  part___0->data_registers = dr___0;
#line 79
  tmp___9 = strcasecmp((char const   *)(dr___0->name), "BSR");
  }
#line 79
  if (tmp___9 == 0) {
    {
#line 82
    part___0->boundary_length = (int )len;
#line 83
    tmp___7 = malloc((unsigned long )part___0->boundary_length * sizeof(*(part___0->bsbits)));
#line 83
    part___0->bsbits = (bsbit_t **)tmp___7;
    }
#line 84
    if (! part___0->bsbits) {
      {
#line 85
      tmp___8 = gettext("out of memory\n");
#line 85
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 86
      return (1);
    }
#line 88
    i = 0;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (i < part___0->boundary_length)) {
#line 88
        goto while_break;
      }
#line 89
      *(part___0->bsbits + i) = (bsbit_t *)((void *)0);
#line 88
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 93
  tmp___11 = strcasecmp((char const   *)(dr___0->name), "DIR");
  }
#line 93
  if (tmp___11 == 0) {
    {
#line 94
    tmp___10 = register_get_string((tap_register const   *)part___0->id);
#line 94
    register_init(dr___0->out, tmp___10);
    }
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/register.c"
static void cmd_register_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s NAME LENGTH\nDefine new data register with specified NAME and LENGTH.\n\nNAME          Data register name\nLENGTH        Data register length\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "register");
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/register.c"
cmd_t cmd_register  =    {(char *)"register", (char *)"define new data register for a part", & cmd_register_help,
    & cmd_register_run};
#line 48 "../../include/jtag.h"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/readmem.c"
static int cmd_readmem_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp != 4) {
#line 42
    return (-1);
  }
#line 44
  if (! bus) {
    {
#line 45
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 45
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 46
    return (1);
  }
  {
#line 49
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 49
  if (tmp___1) {
#line 50
    return (-1);
  } else {
    {
#line 49
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 49
    if (tmp___2) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"w");
  }
#line 53
  if (! f) {
    {
#line 54
    tmp___3 = gettext("Unable to create file `%s\'!\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 55
    return (1);
  }
  {
#line 57
  readmem(bus, f, adr, len);
#line 58
  fclose(f);
  }
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/readmem.c"
static void cmd_readmem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nCopy device memory content starting with ADDR to FILENAME file.\n\nADDR       start address of the copied memory area\nLEN        copied memory length\nFILENAME   name of the output file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "readmem");
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/readmem.c"
cmd_t cmd_readmem  =    {(char *)"readmem", (char *)"read content of the memory and write it to file",
    & cmd_readmem_help, & cmd_readmem_run};
#line 31 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/quit.c"
static int cmd_quit_run(char **params ) 
{ 


  {
#line 34
  if (*(params + 1)) {
#line 35
    return (-1);
  }
#line 37
  return (0);
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/quit.c"
static void cmd_quit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 43
  tmp = gettext("Usage: %s\nExit from %s.\n");
#line 43
  printf((char const   */* __restrict  */)tmp, "quit", "urjtag");
  }
#line 47
  return;
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/quit.c"
cmd_t cmd_quit  =    {(char *)"quit", (char *)"exit and terminate this session", & cmd_quit_help, & cmd_quit_run};
#line 930 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcstombs)(char * __restrict  __s ,
                                                                                  wchar_t const   * __restrict  __pwcs ,
                                                                                  size_t __n ) ;
#line 524 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 222 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 590
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) swprintf)(wchar_t * __restrict  __s ,
                                                                               size_t __n ,
                                                                               wchar_t const   * __restrict  __format 
                                                                               , ...) ;
#line 66 "../../include/part.h"
void part_print(part_t *p ) ;
#line 79
void parts_print(parts_t *ps ) ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/print.c"
static int cmd_print_run(char **params ) 
{ 
  char format[128] ;
  wchar_t wformat[128] ;
  wchar_t wheader[128] ;
  char header[128] ;
  int i ;
  int noheader ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  part_t *part___0 ;
  signal_t *s ;
  salias_t *sa ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int i___0 ;
  uint64_t a ;
  bus_area_t area ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 47
  noheader = 0;
#line 49
  tmp = cmd_params(params);
  }
#line 49
  if (tmp > 2) {
#line 50
    return (-1);
  }
  {
#line 52
  tmp___0 = cmd_test_cable();
  }
#line 52
  if (! tmp___0) {
#line 53
    return (1);
  }
#line 55
  if (! chain->parts) {
    {
#line 56
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 56
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 57
    return (1);
  }
  {
#line 60
  tmp___4 = cmd_params(params);
  }
#line 60
  if (tmp___4 == 2) {
    {
#line 61
    tmp___2 = strcasecmp((char const   *)*(params + 1), "bus");
    }
#line 61
    if (tmp___2 == 0) {
#line 62
      noheader = 1;
    }
    {
#line 64
    tmp___3 = strcasecmp((char const   *)*(params + 1), "signals");
    }
#line 64
    if (tmp___3 == 0) {
      {
#line 66
      printf((char const   */* __restrict  */)"Signals:\n");
#line 69
      part___0 = *((chain->parts)->parts + chain->active_part);
#line 70
      s = part___0->signals;
      }
      {
#line 70
      while (1) {
        while_continue: /* CIL Label */ ;
#line 70
        if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 70
          goto while_break;
        }
#line 72
        if (s->pin) {
          {
#line 72
          printf((char const   */* __restrict  */)"%s %s", s->name, s->pin);
          }
        } else {
          {
#line 73
          printf((char const   */* __restrict  */)"%s", s->name);
          }
        }
#line 74
        if (s->input) {
          {
#line 74
          printf((char const   */* __restrict  */)"\tinput=%s", (s->input)->name);
          }
        }
#line 75
        if (s->output) {
          {
#line 75
          printf((char const   */* __restrict  */)"\toutput=%s", (s->output)->name);
          }
        }
#line 77
        sa = part___0->saliases;
        {
#line 77
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 77
          if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
#line 77
            goto while_break___0;
          }
#line 78
          if ((unsigned long )s == (unsigned long )sa->signal) {
            {
#line 78
            printf((char const   */* __restrict  */)"\tsalias=%s", sa->name);
            }
          }
#line 77
          sa = sa->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 80
        printf((char const   */* __restrict  */)"\n");
#line 70
        s = s->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 82
      return (1);
    }
  }
#line 86
  if (noheader == 0) {
    {
#line 87
    tmp___5 = gettext(" No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 87
    snprintf((char */* __restrict  */)(format), (size_t )128, (char const   */* __restrict  */)tmp___5,
             25, 20, 8, 20, 32);
#line 90
    tmp___7 = mbstowcs((wchar_t */* __restrict  */)(wformat), (char const   */* __restrict  */)(format),
                       (size_t )128);
    }
#line 90
    if (tmp___7 == 0xffffffffffffffffUL) {
      {
#line 91
      tmp___6 = gettext("(%d) String conversion failed!\n");
#line 91
      printf((char const   */* __restrict  */)tmp___6, 91);
      }
    }
    {
#line 92
    tmp___8 = gettext("Register");
#line 92
    tmp___9 = gettext("Instruction");
#line 92
    tmp___10 = gettext("Stepping");
#line 92
    tmp___11 = gettext("Part");
#line 92
    tmp___12 = gettext("Manufacturer");
#line 92
    swprintf((wchar_t */* __restrict  */)(wheader), (size_t )128, (wchar_t const   */* __restrict  */)(wformat),
             tmp___12, tmp___11, tmp___10, tmp___9, tmp___8);
#line 93
    tmp___14 = wcstombs((char */* __restrict  */)(header), (wchar_t const   */* __restrict  */)(wheader),
                        (size_t )128);
    }
#line 93
    if (tmp___14 == 0xffffffffffffffffUL) {
      {
#line 94
      tmp___13 = gettext("(%d) String conversion failed!\n");
#line 94
      printf((char const   */* __restrict  */)tmp___13, 94);
      }
    }
    {
#line 100
    printf((char const   */* __restrict  */)(header));
#line 102
    i = 0;
    }
    {
#line 102
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 102
      tmp___15 = wcslen((wchar_t const   *)(wheader));
      }
#line 102
      if (! ((size_t )i < tmp___15)) {
#line 102
        goto while_break___1;
      }
      {
#line 103
      putchar('-');
#line 102
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 104
    putchar('\n');
    }
  }
  {
#line 107
  tmp___24 = cmd_params(params);
  }
#line 107
  if (tmp___24 == 1) {
#line 108
    if ((chain->parts)->len > chain->active_part) {
#line 109
      if ((*((chain->parts)->parts + chain->active_part))->alias) {
        {
#line 110
        tmp___16 = gettext(" %3d %s ");
#line 110
        printf((char const   */* __restrict  */)tmp___16, chain->active_part, (*((chain->parts)->parts + chain->active_part))->alias);
        }
      } else {
        {
#line 112
        tmp___17 = gettext(" %3d ");
#line 112
        printf((char const   */* __restrict  */)tmp___17, chain->active_part);
        }
      }
      {
#line 114
      part_print(*((chain->parts)->parts + chain->active_part));
      }
    }
#line 116
    if ((unsigned long )bus != (unsigned long )((void *)0)) {
#line 121
      i___0 = 0;
      {
#line 121
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 121
        if (! (i___0 < buses.len)) {
#line 121
          goto while_break___2;
        }
#line 122
        if ((unsigned long )*(buses.buses + i___0) == (unsigned long )bus) {
#line 123
          goto while_break___2;
        }
#line 121
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 124
      tmp___18 = gettext("\nActive bus:\n*%d: ");
#line 124
      printf((char const   */* __restrict  */)tmp___18, i___0);
#line 125
      (*((bus->driver)->printinfo))(bus);
#line 127
      a = (uint64_t )0;
      }
      {
#line 127
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 127
        if (! (a < 4294967296UL)) {
#line 127
          goto while_break___3;
        }
        {
#line 128
        tmp___20 = (*((bus->driver)->area))(bus, (uint32_t )a, & area);
        }
#line 128
        if (tmp___20 != 0) {
          {
#line 129
          tmp___19 = gettext("Error in bus area discovery at 0x%08llX\n");
#line 129
          printf((char const   */* __restrict  */)tmp___19, (unsigned long long )a);
          }
#line 130
          goto while_break___3;
        }
#line 132
        if (area.width != 0U) {
#line 133
          if ((unsigned long )area.description != (unsigned long )((void *)0)) {
            {
#line 134
            tmp___21 = gettext(area.description);
#line 134
            tmp___22 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit, (%s)\n");
#line 134
            printf((char const   */* __restrict  */)tmp___22, area.start, (unsigned long long )area.length,
                   area.width, tmp___21);
            }
          } else {
            {
#line 136
            tmp___23 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit\n");
#line 136
            printf((char const   */* __restrict  */)tmp___23, area.start, (unsigned long long )area.length,
                   area.width);
            }
          }
        }
#line 127
        a = (uint64_t )area.start + area.length;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 141
    return (1);
  }
  {
#line 144
  tmp___25 = strcasecmp((char const   *)*(params + 1), "chain");
  }
#line 144
  if (tmp___25 == 0) {
    {
#line 145
    parts_print(chain->parts);
    }
#line 146
    return (1);
  }
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 149
    if (! (i < buses.len)) {
#line 149
      goto while_break___4;
    }
#line 150
    if ((unsigned long )*(buses.buses + i) == (unsigned long )bus) {
      {
#line 151
      tmp___26 = gettext("*%d: ");
#line 151
      printf((char const   */* __restrict  */)tmp___26, i);
      }
    } else {
      {
#line 153
      tmp___27 = gettext("%d: ");
#line 153
      printf((char const   */* __restrict  */)tmp___27, i);
      }
    }
    {
#line 154
    (*(((*(buses.buses + i))->driver)->printinfo))(*(buses.buses + i));
#line 149
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 157
  return (1);
}
}
#line 160 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/print.c"
static void cmd_print_help(void) 
{ 
  char *tmp ;

  {
  {
#line 163
  tmp = gettext("Usage: %s [chain|bus|signals]\nDisplay JTAG chain status.\n\nDisplay list of the parts connected to the JTAG chain including\npart number and current (active) instruction and data register.\n");
#line 163
  printf((char const   */* __restrict  */)tmp, "print");
  }
#line 170
  return;
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/print.c"
cmd_t cmd_print  =    {(char *)"print", (char *)"display JTAG chain list/status", & cmd_print_help, & cmd_print_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
static int cmd_peek_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  int pars ;
  int j ;
  bus_area_t area ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 38
  j = 1;
#line 43
  pars = cmd_params(params);
  }
#line 43
  if (pars < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp);
    }
#line 48
    return (1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___0 = cmd_get_number(*(params + j), & adr);
    }
#line 51
    if (tmp___0) {
#line 52
      return (-1);
    }
    {
#line 54
    (*((bus->driver)->prepare))(bus);
#line 55
    (*((bus->driver)->area))(bus, adr, & area);
#line 56
    val = (*((bus->driver)->read))(bus, adr);
    }
    {
#line 60
    if (area.width == 8U) {
#line 60
      goto case_8;
    }
#line 64
    if (area.width == 16U) {
#line 64
      goto case_16;
    }
#line 68
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 61
    val &= 255U;
#line 62
    tmp___1 = gettext("bus_read(0x%08x) = 0x%02X (%i)\n");
#line 62
    printf((char const   */* __restrict  */)tmp___1, adr, val, val);
    }
#line 63
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 65
    val &= 65535U;
#line 66
    tmp___2 = gettext("bus_read(0x%08x) = 0x%04X (%i)\n");
#line 66
    printf((char const   */* __restrict  */)tmp___2, adr, val, val);
    }
#line 67
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 69
    tmp___3 = gettext("bus_read(0x%08x) = 0x%08X (%i)\n");
#line 69
    printf((char const   */* __restrict  */)tmp___3, adr, val, val);
    }
    switch_break: /* CIL Label */ ;
    }
#line 50
    j ++;
#line 50
    if (! (j != pars)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (1);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
static void cmd_peek_help(void) 
{ 
  char *tmp ;

  {
  {
#line 79
  tmp = gettext("Usage: %s ADDR\nRead a single word (bus width size).\n\nADDR       address to read from\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 79
  printf((char const   */* __restrict  */)tmp, "peek");
  }
#line 88
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
cmd_t cmd_peek  =    {(char *)"peek", (char *)"read a single word", & cmd_peek_help, & cmd_peek_run};
#line 97 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
static int cmd_poke_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  bus_area_t area ;
  int k ;
  int pars ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 103
  k = 1;
#line 103
  tmp = cmd_params(params);
#line 103
  pars = tmp;
  }
#line 105
  if (pars < 3) {
#line 106
    return (-1);
  } else
#line 105
  if (! (pars & 1)) {
#line 106
    return (-1);
  }
#line 108
  if (! bus) {
    {
#line 109
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 109
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 110
    return (1);
  }
  {
#line 114
  (*((bus->driver)->prepare))(bus);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (k < pars)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___1 = cmd_get_number(*(params + k), & adr);
    }
#line 117
    if (tmp___1) {
#line 118
      return (-1);
    } else {
      {
#line 117
      tmp___2 = cmd_get_number(*(params + (k + 1)), & val);
      }
#line 117
      if (tmp___2) {
#line 118
        return (-1);
      }
    }
    {
#line 119
    (*((bus->driver)->area))(bus, adr, & area);
#line 120
    (*((bus->driver)->write))(bus, adr, val);
#line 121
    k += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (1);
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
static void cmd_poke_help(void) 
{ 
  char *tmp ;

  {
  {
#line 130
  tmp = gettext("Usage: %s ADDR VAL [ADDR VAL] ... \nWrite a single word (bus width size).\n\nADDR       address to write\nVAL        value to write\n\nADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 130
  printf((char const   */* __restrict  */)tmp, "poke");
  }
#line 140
  return;
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/peekpoke.c"
cmd_t cmd_poke  =    {(char *)"poke", (char *)"write a single word", & cmd_poke_help, & cmd_poke_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/part.c"
static int cmd_part_run(char **params ) 
{ 
  unsigned int n ;
  part_t *part___0 ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int i ;
  char *a ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 41
  tmp___2 = cmd_params(params);
  }
#line 41
  if (tmp___2 == 3) {
    {
#line 42
    tmp___1 = strcasecmp((char const   *)*(params + 1), "alias");
    }
#line 42
    if (tmp___1 == 0) {
      {
#line 44
      part___0 = *((chain->parts)->parts + chain->active_part);
#line 45
      tmp = strlen((char const   *)*(params + 2));
#line 45
      tmp___0 = malloc(tmp + 1UL);
#line 45
      part___0->alias = (char *)tmp___0;
#line 46
      strcpy((char */* __restrict  */)part___0->alias, (char const   */* __restrict  */)*(params + 2));
      }
#line 47
      return (1);
    }
  }
  {
#line 52
  tmp___3 = cmd_params(params);
  }
#line 52
  if (tmp___3 != 2) {
#line 53
    return (-1);
  }
  {
#line 55
  tmp___4 = cmd_test_cable();
  }
#line 55
  if (! tmp___4) {
#line 56
    return (1);
  }
#line 58
  if (! chain->parts) {
    {
#line 59
    tmp___5 = gettext("Run \"detect\" first.\n");
#line 59
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 60
    return (1);
  }
  {
#line 64
  tmp___7 = cmd_get_number(*(params + 1), & n);
  }
#line 64
  if (tmp___7) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < (chain->parts)->len)) {
#line 70
        goto while_break;
      }
#line 71
      a = (*((chain->parts)->parts + i))->alias;
#line 72
      if (a) {
        {
#line 72
        tmp___6 = strcasecmp((char const   *)a, (char const   *)*(params + 1));
        }
#line 72
        if (tmp___6 == 0) {
#line 72
          goto while_break;
        }
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (i < (chain->parts)->len) {
#line 74
      n = (unsigned int )i;
    } else {
#line 77
      return (-1);
    }
  }
#line 80
  if (n >= (unsigned int )(chain->parts)->len) {
    {
#line 81
    tmp___8 = gettext("%s: invalid part number\n");
#line 81
    printf((char const   */* __restrict  */)tmp___8, "part");
    }
#line 82
    return (1);
  }
#line 85
  chain->active_part = (int )n;
#line 87
  return (1);
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/part.c"
static void cmd_part_help(void) 
{ 
  char *tmp ;

  {
  {
#line 93
  tmp = gettext("Usage: %s PART\nChange active part for current JTAG chain.\n\nPART          part number | alias\n");
#line 93
  printf((char const   */* __restrict  */)tmp, "part");
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/part.c"
cmd_t cmd_part  =    {(char *)"part", (char *)"change active part for current JTAG chain", & cmd_part_help,
    & cmd_part_run};
#line 42 "../../include/instruction.h"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/instruction.c"
static int cmd_instruction_run(char **params ) 
{ 
  part_t *part___0 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned int len ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  instruction *i ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  instruction *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 40
  tmp = cmd_test_cable();
  }
#line 40
  if (! tmp) {
#line 41
    return (1);
  }
#line 43
  if (! chain->parts) {
    {
#line 44
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 44
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 45
    return (1);
  }
#line 48
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 49
    tmp___1 = gettext("%s: no active part\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1, "instruction");
    }
#line 50
    return (1);
  }
  {
#line 53
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 55
  tmp___3 = cmd_params(params);
  }
#line 55
  if (tmp___3 == 2) {
    {
#line 56
    part_set_instruction(part___0, (char const   *)*(params + 1));
    }
#line 57
    if ((unsigned long )part___0->active_instruction == (unsigned long )((void *)0)) {
      {
#line 58
      tmp___2 = gettext("%s: unknown instruction \'%s\'\n");
#line 58
      printf((char const   */* __restrict  */)tmp___2, "instruction", *(params + 1));
      }
    }
#line 59
    return (1);
  }
  {
#line 62
  tmp___7 = cmd_params(params);
  }
#line 62
  if (tmp___7 == 3) {
    {
#line 65
    tmp___4 = strcasecmp((char const   *)*(params + 1), "length");
    }
#line 65
    if (tmp___4 != 0) {
#line 66
      return (-1);
    }
#line 68
    if ((unsigned long )part___0->instructions != (unsigned long )((void *)0)) {
      {
#line 69
      tmp___5 = gettext("instruction length is already set and used\n");
#line 69
      printf((char const   */* __restrict  */)tmp___5);
      }
#line 70
      return (1);
    }
    {
#line 73
    tmp___6 = cmd_get_number(*(params + 2), & len);
    }
#line 73
    if (tmp___6) {
#line 74
      return (-1);
    }
#line 76
    part___0->instruction_length = (int )len;
#line 77
    return (1);
  }
  {
#line 80
  tmp___14 = cmd_params(params);
  }
#line 80
  if (tmp___14 == 4) {
    {
#line 83
    tmp___9 = strlen((char const   *)*(params + 2));
    }
#line 83
    if (tmp___9 != (size_t )part___0->instruction_length) {
      {
#line 84
      tmp___8 = gettext("invalid instruction length\n");
#line 84
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 85
      return (1);
    }
    {
#line 88
    tmp___11 = part_find_instruction(part___0, (char const   *)*(params + 1));
    }
#line 88
    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
      {
#line 89
      tmp___10 = gettext("Instruction \'%s\' already defined\n");
#line 89
      printf((char const   */* __restrict  */)tmp___10, *(params + 1));
      }
#line 90
      return (1);
    }
    {
#line 93
    i = instruction_alloc((char const   *)*(params + 1), part___0->instruction_length,
                          (char const   *)*(params + 2));
    }
#line 94
    if (! i) {
      {
#line 95
      tmp___12 = gettext("out of memory\n");
#line 95
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 96
      return (1);
    }
    {
#line 99
    i->next = part___0->instructions;
#line 100
    part___0->instructions = i;
#line 102
    i->data_register = part_find_data_register(part___0, (char const   *)*(params + 3));
    }
#line 103
    if ((unsigned long )i->data_register == (unsigned long )((void *)0)) {
      {
#line 104
      tmp___13 = gettext("unknown data register \'%s\'\n");
#line 104
      printf((char const   */* __restrict  */)tmp___13, *(params + 3));
      }
#line 105
      return (1);
    }
#line 108
    return (1);
  }
#line 111
  return (-1);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/instruction.c"
static void cmd_instruction_help(void) 
{ 
  char *tmp ;

  {
  {
#line 117
  tmp = gettext("Usage: %s INSTRUCTION\nUsage: %s length LENGTH\nUsage: %s INSTRUCTION CODE REGISTER\nChange active INSTRUCTION for a part or declare new instruction.\n\nINSTRUCTION   instruction name (e.g. BYPASS)\nLENGTH        common instruction length\nCODE          instruction code (e.g. 11111)\nREGISTER      default data register for instruction (e.g. BR)\n");
#line 117
  printf((char const   */* __restrict  */)tmp, "instruction", "instruction", "instruction");
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/instruction.c"
cmd_t cmd_instruction  =    {(char *)"instruction", (char *)"change active instruction for a part or declare new instruction",
    & cmd_instruction_help, & cmd_instruction_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/initbus.c"
static int cmd_initbus_run(char **params ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bus_t *bus___0 ;
  bus_t *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp < 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
#line 50
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___5 = strcasecmp((char const   *)(bus_drivers[i])->name, (char const   *)*(params + 1));
    }
#line 56
    if (tmp___5 == 0) {
      {
#line 57
      tmp___3 = (*((bus_drivers[i])->new_bus))(params);
#line 57
      bus___0 = tmp___3;
      }
#line 58
      if ((unsigned long )bus___0 == (unsigned long )((void *)0)) {
        {
#line 59
        tmp___4 = gettext("bus initialization failed!\n");
#line 59
        printf((char const   */* __restrict  */)tmp___4);
        }
#line 60
        return (1);
      }
      {
#line 62
      buses_add(bus___0);
      }
#line 63
      return (1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp___6 = gettext("Unknown bus: %s\n");
#line 67
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 69
  return (1);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/initbus.c"
static void cmd_initbus_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 77
  tmp = gettext("Usage: %s BUSNAME\nInitialize new bus driver for active part.\n\nBUSNAME       Name of the bus\n\nList of available buses:\n");
#line 77
  printf((char const   */* __restrict  */)tmp, "initbus");
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 86
      goto while_break;
    }
    {
#line 87
    tmp___0 = gettext("%-10s %s\n");
#line 87
    printf((char const   */* __restrict  */)tmp___0, (bus_drivers[i])->name, (bus_drivers[i])->description);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/initbus.c"
struct __anonstruct_cmd_t_148900231  const  cmd_initbus  =    {(char *)"initbus", (char *)"initialize bus driver for active part", & cmd_initbus_help,
    & cmd_initbus_run};
#line 42 "../../include/jtag.h"
int jtag_parse_file(char const   *filename ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static int cmd_include_or_script_run(int is_include , char **params ) 
{ 
  int go ;
  int i ;
  int j ;
  char *path ;
  int len ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 39
  go = 0;
#line 39
  j = 1;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! is_include) {
    {
#line 48
    tmp___0 = gettext("Please use the \'include\' command instead of \'script\'\n");
#line 48
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 54
  path = *(params + 1);
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((int )*path == 46)) {
#line 55
      goto while_break;
    }
#line 55
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if ((int )*path == 47) {
    {
#line 58
    path = strdup((char const   *)*(params + 1));
    }
  } else
#line 56
  if (! is_include) {
    {
#line 58
    path = strdup((char const   *)*(params + 1));
    }
  } else {
    {
#line 62
    tmp___1 = strlen("/usr/local/share/urjtag");
#line 62
    tmp___2 = strlen((char const   *)*(params + 1));
#line 62
    len = (int )((tmp___1 + tmp___2) + 2UL);
#line 62
    tmp___3 = malloc((size_t )len);
#line 62
    path = (char *)tmp___3;
    }
#line 63
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
#line 65
      snprintf((char */* __restrict  */)path, (size_t )len, (char const   */* __restrict  */)"%s/%s",
               "/usr/local/share/urjtag", *(params + 1));
      }
    }
  }
#line 68
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 69
    tmp___4 = gettext("Out of memory\n");
#line 69
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 70
    return (1);
  }
  {
#line 75
  tmp___6 = bsdl_read_file((char const   *)path, -1, (char *)((void *)0));
  }
#line 75
  if (tmp___6 >= 0) {
    {
#line 78
    go = bsdl_read_file((char const   *)path, 1, (char *)((void *)0));
#line 80
    free((void *)path);
    }
#line 81
    if (go >= 0) {
#line 81
      tmp___5 = 1;
    } else {
#line 81
      tmp___5 = 0;
    }
#line 81
    return (tmp___5);
  }
  {
#line 85
  tmp___7 = cmd_params(params);
  }
#line 85
  if (tmp___7 > 2) {
    {
#line 86
    sscanf((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"%d",
           & j);
    }
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! (i < j)) {
#line 89
      goto while_break___0;
    }
    {
#line 90
    go = jtag_parse_file((char const   *)path);
    }
#line 92
    if (go < 0) {
#line 93
      if (go != -99) {
        {
#line 94
        tmp___8 = gettext("Unable to open file `%s go=%d\'!\n");
#line 94
        printf((char const   */* __restrict  */)tmp___8, path, go);
        }
      }
#line 95
      goto while_break___0;
    }
#line 89
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 99
  free((void *)path);
  }
#line 101
  if (go) {
#line 101
    tmp___9 = 1;
  } else {
#line 101
    tmp___9 = 0;
  }
#line 101
  return (tmp___9);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static void cmd_include_or_script_help(char *cmd ) 
{ 
  char *tmp ;

  {
  {
#line 107
  tmp = gettext("Usage: %s FILENAME [n] \nRun command sequence n times from external FILENAME.\n\nFILENAME      Name of the file with commands\n");
#line 107
  printf((char const   */* __restrict  */)tmp, cmd);
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static int cmd_include_run(char **params ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = cmd_include_or_script_run(1, params);
  }
#line 118
  return (tmp);
}
}
#line 121 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static void cmd_include_help(void) 
{ 


  {
  {
#line 124
  cmd_include_or_script_help((char *)"include");
  }
#line 125
  return;
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
cmd_t cmd_include  =    {(char *)"include", (char *)"include command sequence from external repository",
    & cmd_include_help, & cmd_include_run};
#line 134 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static int cmd_script_run(char **params ) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = cmd_include_or_script_run(0, params);
  }
#line 137
  return (tmp);
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
static void cmd_script_help(void) 
{ 


  {
  {
#line 143
  cmd_include_or_script_help((char *)"script");
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/include.c"
cmd_t cmd_script  =    {(char *)"script", (char *)"run command sequence from external file", & cmd_script_help,
    & cmd_script_run};
#line 44 "../../include/cmd.h"
cmd_t const   *cmds[37] ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/help.c"
static int cmd_help_run(char **params ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 38
  if (! *(params + 1)) {
    {
#line 39
    tmp = gettext("Command list:\n\n");
#line 39
    printf((char const   */* __restrict  */)tmp);
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! cmds[i]) {
#line 40
        goto while_break;
      }
#line 41
      if ((cmds[i])->desc) {
        {
#line 41
        tmp___0 = gettext((char const   *)(cmds[i])->desc);
#line 41
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 41
        tmp___1 = gettext("(no description available)");
#line 41
        tmp___2 = tmp___1;
        }
      }
      {
#line 41
      tmp___3 = gettext("%-13s %s\n");
#line 41
      printf((char const   */* __restrict  */)tmp___3, (cmds[i])->name, tmp___2);
#line 40
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    tmp___4 = gettext("\nType \"help COMMAND\" for details about a particular command.\n");
#line 42
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 43
    return (1);
  }
#line 46
  if (*(params + 2)) {
#line 47
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! cmds[i]) {
#line 50
      goto while_break___0;
    }
    {
#line 51
    tmp___5 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 1));
    }
#line 51
    if (tmp___5 == 0) {
#line 52
      if ((cmds[i])->help) {
        {
#line 53
        (*((cmds[i])->help))();
        }
      }
#line 54
      return (1);
    }
#line 50
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  tmp___6 = gettext("%s: unknown command\n");
#line 57
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 59
  return (1);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/help.c"
static void cmd_help_help(void) 
{ 
  char *tmp ;

  {
  {
#line 65
  tmp = gettext("Usage: %s [COMMAND]\nPrint short help for COMMAND, or list of available commands.\n");
#line 65
  printf((char const   */* __restrict  */)tmp, "help");
  }
#line 69
  return;
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/help.c"
cmd_t cmd_help  =    {(char *)"help", (char *)"display this help", & cmd_help_help, & cmd_help_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/get.c"
static int cmd_get_run(char **params ) 
{ 
  int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 45
  if (tmp___0 != 0) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp___1 = cmd_test_cable();
  }
#line 48
  if (! tmp___1) {
#line 49
    return (1);
  }
#line 51
  if (! chain->parts) {
    {
#line 52
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 52
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 53
    return (1);
  }
#line 56
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 57
    tmp___3 = gettext("%s: no active part\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 58
    return (1);
  }
  {
#line 61
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 62
  if (! s) {
    {
#line 63
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 63
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 64
    return (1);
  }
  {
#line 66
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 67
  if (data != -1) {
    {
#line 68
    tmp___5 = gettext("%s = %d\n");
#line 68
    printf((char const   */* __restrict  */)tmp___5, *(params + 2), data);
    }
  }
#line 70
  return (1);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/get.c"
static void cmd_get_help(void) 
{ 
  char *tmp ;

  {
  {
#line 76
  tmp = gettext("Usage: %s SIGNAL\nGet signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 76
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 82
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/get.c"
cmd_t cmd_get  =    {(char *)"get", (char *)"get external signal value", & cmd_get_help, & cmd_get_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/frequency.c"
static int cmd_frequency_run(char **params ) 
{ 
  unsigned int freq ;
  uint32_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 39
  tmp___1 = cmd_params(params);
  }
#line 39
  if (tmp___1 == 1) {
    {
#line 40
    tmp = cable_get_frequency(chain->cable);
#line 40
    tmp___0 = gettext("Current TCK frequency is %u Hz\n");
#line 40
    printf((char const   */* __restrict  */)tmp___0, tmp);
    }
#line 41
    return (1);
  }
  {
#line 44
  tmp___2 = cmd_params(params);
  }
#line 44
  if (tmp___2 != 2) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___3 = cmd_get_number(*(params + 1), & freq);
  }
#line 47
  if (tmp___3) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___4 = gettext("Setting TCK frequency to %u Hz\n");
#line 50
  printf((char const   */* __restrict  */)tmp___4, freq);
#line 51
  cable_set_frequency(chain->cable, freq);
  }
#line 53
  return (1);
}
}
#line 56 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/frequency.c"
static void cmd_frequency_help(void) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = gettext("Usage: %s [FREQ]\nChange TCK frequency to FREQ or print current TCK frequency.\n\nFREQ is in hertz. It\'s a maximum TCK frequency for JTAG interface.\nIn some cases the TCK frequency is less than FREQ, but the frequency\nis never more than FREQ. Maximum supported frequency depends on JTAG\nadapter.\n\nFREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\nUse 0 for FREQ to disable frequency limit.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "frequency");
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/frequency.c"
cmd_t cmd_frequency  =    {(char *)"frequency", (char *)"setup JTAG frequency", & cmd_frequency_help, & cmd_frequency_run};
#line 83 "../../include/flash.h"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) ;
#line 84
void flashmsbin(bus_t *bus___0 , FILE *f ) ;
#line 88
flash_driver_t *flash_drivers[8] ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/flashmem.c"
static int cmd_flashmem_run(char **params ) 
{ 
  int msbin ;
  uint32_t adr ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 40
  adr = (uint32_t )0;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp != 3) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 48
    return (1);
  }
  {
#line 51
  tmp___1 = strcasecmp("msbin", (char const   *)*(params + 1));
#line 51
  msbin = tmp___1 == 0;
  }
#line 52
  if (! msbin) {
    {
#line 52
    tmp___2 = cmd_get_number(*(params + 1), & adr);
    }
#line 52
    if (tmp___2) {
#line 53
      return (-1);
    }
  }
  {
#line 55
  f = fopen((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"rb");
  }
#line 56
  if (! f) {
    {
#line 57
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, *(params + 2));
    }
#line 58
    return (1);
  }
#line 60
  if (msbin) {
    {
#line 61
    flashmsbin(bus, f);
    }
  } else {
    {
#line 63
    flashmem(bus, f, adr);
    }
  }
  {
#line 64
  fclose(f);
  }
#line 66
  return (1);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/flashmem.c"
static void cmd_flashmem_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 74
  tmp = gettext("Usage: %s ADDR FILENAME\nUsage: %s FILENAME\nProgram FILENAME content to flash memory.\n\nADDR       target address for raw binary image\nFILENAME   name of the input file\n%-10s FILENAME is in MS .bin format (for WinCE)\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 74
  printf((char const   */* __restrict  */)tmp, "flashmem", "flashmem msbin", "msbin");
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! flash_drivers[i]) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___0 = gettext((flash_drivers[i])->description);
#line 89
    tmp___1 = gettext((flash_drivers[i])->name);
#line 89
    tmp___2 = gettext("%s\n     %s\n");
#line 89
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/flashmem.c"
cmd_t cmd_flashmem  =    {(char *)"flashmem", (char *)"burn flash memory with data from a file", & cmd_flashmem_help,
    & cmd_flashmem_run};
#line 51 "../../include/jtag.h"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/eraseflash.c"
static int cmd_eraseflash_run(char **params ) 
{ 
  uint32_t adr ;
  unsigned int number ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 39
  adr = (uint32_t )0;
#line 40
  number = 0U;
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 44
  tmp___0 = cmd_test_cable();
  }
#line 44
  if (! tmp___0) {
#line 45
    return (1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___1 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 48
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & adr);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
  {
#line 52
  tmp___3 = cmd_get_number(*(params + 2), & number);
  }
#line 52
  if (tmp___3) {
#line 53
    return (-1);
  }
  {
#line 54
  flasherase(bus, adr, (int )number);
  }
#line 56
  return (1);
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/eraseflash.c"
static void cmd_eraseflash_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR BLOCKS\nErase flash memory from ADDR.\n\nADDR       target addres for erasing block\nBLOCKS     number of blocks to erase\n\nADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "eraseflash");
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! flash_drivers[i]) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = gettext((flash_drivers[i])->description);
#line 77
    tmp___1 = gettext((flash_drivers[i])->name);
#line 77
    tmp___2 = gettext("%s\n     %s\n");
#line 77
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/eraseflash.c"
cmd_t cmd_eraseflash  =    {(char *)"eraseflash", (char *)"erase flash memory by number of blocks", & cmd_eraseflash_help,
    & cmd_eraseflash_run};
#line 39 "../../include/jtag.h"
int big_endian ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/endian.c"
static int cmd_endian_run(char **params ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp > 2) {
#line 38
    return (-1);
  }
#line 40
  if (! *(params + 1)) {
#line 41
    if (big_endian) {
      {
#line 42
      tmp___0 = gettext("Endianess for external files: big\n");
#line 42
      printf((char const   */* __restrict  */)tmp___0);
      }
    } else {
      {
#line 44
      tmp___1 = gettext("Endianess for external files: little\n");
#line 44
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 45
    return (1);
  }
  {
#line 49
  tmp___2 = strcasecmp((char const   *)*(params + 1), "little");
  }
#line 49
  if (tmp___2 == 0) {
#line 50
    big_endian = 0;
#line 51
    return (1);
  }
  {
#line 53
  tmp___3 = strcasecmp((char const   *)*(params + 1), "big");
  }
#line 53
  if (tmp___3 == 0) {
#line 54
    big_endian = 1;
#line 55
    return (1);
  }
#line 58
  return (-1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/endian.c"
static void cmd_endian_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s\nSet or print endianess for external files.\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "endian [little|big]");
  }
#line 68
  return;
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/endian.c"
cmd_t cmd_endian  =    {(char *)"endian", (char *)"set/print endianess", & cmd_endian_help, & cmd_endian_run};
#line 276 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/dr.c"
static int cmd_dr_run(char **params ) 
{ 
  int dir ;
  tap_register *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned int bit ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 38
  dir = 1;
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp < 1) {
#line 42
    return (-1);
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    }
  }
  {
#line 44
  tmp___1 = cmd_test_cable();
  }
#line 44
  if (! tmp___1) {
#line 45
    return (1);
  }
#line 47
  if (! chain->parts) {
    {
#line 48
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 48
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 49
    return (1);
  }
#line 52
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 53
    tmp___3 = gettext("%s: no active part\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3, "dr");
    }
#line 54
    return (1);
  }
#line 57
  if ((unsigned long )(*((chain->parts)->parts + chain->active_part))->active_instruction == (unsigned long )((void *)0)) {
    {
#line 58
    tmp___4 = gettext("%s: part without active instruction\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "dr");
    }
#line 59
    return (1);
  }
#line 61
  if ((unsigned long )((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___5 = gettext("%s: part without active data register\n");
#line 62
    printf((char const   */* __restrict  */)tmp___5, "dr");
    }
#line 63
    return (1);
  }
#line 66
  if (*(params + 1)) {
    {
#line 67
    tmp___11 = strcasecmp((char const   *)*(params + 1), "in");
    }
#line 67
    if (tmp___11 == 0) {
#line 68
      dir = 0;
    } else {
      {
#line 69
      tmp___10 = strcasecmp((char const   *)*(params + 1), "out");
      }
#line 69
      if (tmp___10 == 0) {
#line 70
        dir = 1;
      } else {
        {
#line 73
        tmp___6 = strspn((char const   *)*(params + 1), "01");
#line 73
        tmp___7 = strlen((char const   *)*(params + 1));
        }
#line 73
        if (tmp___6 != tmp___7) {
#line 74
          return (-1);
        }
        {
#line 77
        r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
#line 78
        tmp___9 = strlen((char const   *)*(params + 1));
        }
#line 78
        if ((size_t )r->len != tmp___9) {
          {
#line 79
          tmp___8 = gettext("%s: register length mismatch\n");
#line 79
          printf((char const   */* __restrict  */)tmp___8, "dr");
          }
#line 80
          return (1);
        }
#line 82
        bit = 0U;
        {
#line 82
        while (1) {
          while_continue: /* CIL Label */ ;
#line 82
          if (! *(*(params + 1) + bit)) {
#line 82
            goto while_break;
          }
#line 83
          *(r->data + ((unsigned int )(r->len - 1) - bit)) = (char )((int )*(*(params + 1) + bit) == 49);
#line 82
          bit ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 86
        dir = 0;
      }
    }
  }
#line 90
  if (dir) {
#line 91
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->out;
  } else {
#line 93
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
  }
  {
#line 94
  tmp___12 = register_get_string((tap_register const   *)r);
#line 94
  tmp___13 = gettext("%s\n");
#line 94
  printf((char const   */* __restrict  */)tmp___13, tmp___12);
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/dr.c"
static void cmd_dr_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s [DIR]\nDisplay input or output data register content.\n\nDIR           requested data register; possible values: \'in\' for\n                input and \'out\' for output; default is \'out\'\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "dr");
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/dr.c"
cmd_t cmd_dr  =    {(char *)"dr", (char *)"display active data register for a part", & cmd_dr_help,
    & cmd_dr_run};
#line 46 "../../include/jtag.h"
void discovery(chain_t *chain___0 ) ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/discovery.c"
static int cmd_discovery_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = cmd_params(params);
  }
#line 36
  if (tmp != 1) {
#line 37
    return (-1);
  }
  {
#line 39
  tmp___0 = cmd_test_cable();
  }
#line 39
  if (! tmp___0) {
#line 40
    return (1);
  }
  {
#line 42
  discovery(chain);
  }
#line 44
  return (1);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/discovery.c"
static void cmd_discovery_help(void) 
{ 
  char *tmp ;

  {
  {
#line 50
  tmp = gettext("Usage: %s\nDiscovery of unknown parts in the JTAG chain.\n\n\'%s\' attempts to detect these parameters of an unknown JTAG\nchain:\n 1. IR (instruction register) length\n 2. DR (data register) length for all possible instructions\n\nWarning: This may be dangerous for some parts (especially if the\npart doesn\'t have TRST signal).\n");
#line 50
  printf((char const   */* __restrict  */)tmp, "discovery", "discovery");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/discovery.c"
cmd_t cmd_discovery  =    {(char *)"discovery", (char *)"discovery of unknown parts in the JTAG chain", & cmd_discovery_help,
    & cmd_discovery_run};
#line 76 "../../include/part.h"
void parts_free(parts_t *ps ) ;
#line 78
void parts_set_instruction(parts_t *ps , char const   *iname ) ;
#line 44 "../../include/jtag.h"
int detect_parts(chain_t *chain___0 , char *db_path ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detect.c"
static int cmd_detect_run(char **params ) 
{ 
  int i ;
  bus_t *abus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 1) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable();
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
  {
#line 48
  buses_free();
#line 49
  parts_free(chain->parts);
#line 50
  chain->parts = (parts_t *)((void *)0);
#line 51
  detect_parts(chain, (char *)"/usr/local/share/urjtag");
  }
#line 52
  if (! chain->parts) {
#line 53
    return (1);
  }
#line 54
  if (! (chain->parts)->len) {
    {
#line 55
    parts_free(chain->parts);
#line 56
    chain->parts = (parts_t *)((void *)0);
    }
#line 57
    return (1);
  }
  {
#line 59
  parts_set_instruction(chain->parts, "SAMPLE/PRELOAD");
#line 60
  chain_shift_instructions(chain);
#line 61
  chain_shift_data_registers(chain, 1);
#line 62
  parts_set_instruction(chain->parts, "BYPASS");
#line 63
  chain_shift_instructions(chain);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < buses.len)) {
#line 66
      goto while_break;
    }
#line 68
    abus = *(buses.buses + i);
#line 69
    if ((abus->driver)->init) {
      {
#line 71
      tmp___1 = (*((abus->driver)->init))(abus);
      }
#line 71
      if (! tmp___1) {
#line 72
        return (-1);
      }
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detect.c"
static void cmd_detect_help(void) 
{ 
  char *tmp ;

  {
  {
#line 82
  tmp = gettext("Usage: %s\nDetect parts on the JTAG chain.\n\nOutput from this command is a list of the detected parts.\nIf no parts are detected other commands may not work properly.\n");
#line 82
  printf((char const   */* __restrict  */)tmp, "detect");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detect.c"
cmd_t cmd_detect  =    {(char *)"detect", (char *)"detect parts on the JTAG chain", & cmd_detect_help,
    & cmd_detect_run};
#line 81 "../../include/flash.h"
void detectflash(bus_t *bus___0 , uint32_t adr ) ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detectflash.c"
static int cmd_detectflash_run(char **params ) 
{ 
  uint32_t adr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp != 2) {
#line 38
    return (-1);
  }
#line 40
  if (! bus) {
    {
#line 41
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 41
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 42
    return (1);
  }
  {
#line 45
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 45
  if (tmp___1) {
#line 46
    return (-1);
  }
  {
#line 48
  detectflash(bus, adr);
  }
#line 50
  return (1);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detectflash.c"
static void cmd_detectflash_help(void) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("Usage: %s ADDRESS\nDetect flash memory type connected to a part.\n\nADDRESS    Base address for memory region\n");
#line 56
  printf((char const   */* __restrict  */)tmp, "detectflash");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/detectflash.c"
cmd_t cmd_detectflash  =    {(char *)"detectflash", (char *)"detect parameters of flash chips attached to a part",
    & cmd_detectflash_help, & cmd_detectflash_run};
#line 40 "../../include/jtag.h"
int debug_mode ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/debug.c"
static int cmd_debug_run(char **params ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_get_number(*(params + 1), & i);
  }
#line 45
  if (tmp___0) {
#line 46
    return (1);
  }
#line 48
  debug_mode = (int )i;
#line 49
  return (1);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/debug.c"
static void cmd_debug_help(void) 
{ 
  char *tmp ;

  {
  {
#line 55
  tmp = gettext("Usage: %s  n\nEnabled debugging.\n\nn =1 fileio, 2=tap commands, 4 =?\n");
#line 55
  printf((char const   */* __restrict  */)tmp, "debug n");
  }
#line 61
  return;
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/debug.c"
cmd_t cmd_debug  =    {(char *)"debug", (char *)"debug jtag program", & cmd_debug_help, & cmd_debug_run};
#line 37 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
cmd_t cmd_cable ;
#line 44
cmd_t cmd_bit ;
#line 49
cmd_t cmd_bus ;
#line 71
cmd_t cmd_bsdl ;
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
cmd_t const   *cmds[37]  = 
#line 75
  {      (cmd_t const   *)(& cmd_quit),      (cmd_t const   *)(& cmd_help),      (cmd_t const   *)(& cmd_frequency),      (cmd_t const   *)(& cmd_cable), 
        (cmd_t const   *)(& cmd_reset),      (cmd_t const   *)(& cmd_discovery),      (cmd_t const   *)(& cmd_detect),      (cmd_t const   *)(& cmd_signal), 
        (cmd_t const   *)(& cmd_scan),      & cmd_salias,      (cmd_t const   *)(& cmd_bit),      (cmd_t const   *)(& cmd_register), 
        & cmd_initbus,      (cmd_t const   *)(& cmd_print),      (cmd_t const   *)(& cmd_part),      (cmd_t const   *)(& cmd_bus), 
        (cmd_t const   *)(& cmd_instruction),      (cmd_t const   *)(& cmd_shift),      (cmd_t const   *)(& cmd_dr),      (cmd_t const   *)(& cmd_get), 
        (cmd_t const   *)(& cmd_test),      (cmd_t const   *)(& cmd_shell),      (cmd_t const   *)(& cmd_set),      (cmd_t const   *)(& cmd_endian), 
        (cmd_t const   *)(& cmd_peek),      (cmd_t const   *)(& cmd_poke),      (cmd_t const   *)(& cmd_readmem),      (cmd_t const   *)(& cmd_writemem), 
        (cmd_t const   *)(& cmd_detectflash),      (cmd_t const   *)(& cmd_flashmem),      (cmd_t const   *)(& cmd_eraseflash),      (cmd_t const   *)(& cmd_script), 
        (cmd_t const   *)(& cmd_include),      (cmd_t const   *)(& cmd_svf),      (cmd_t const   *)(& cmd_bsdl),      (cmd_t const   *)(& cmd_debug), 
        (cmd_t const   *)((void *)0)};
#line 119 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
int cmd_test_cable(void) 
{ 
  char *tmp ;

  {
#line 122
  if (chain->cable) {
#line 123
    return (1);
  }
  {
#line 125
  tmp = gettext("Error: Cable not configured. Please use \'%s\' command first!\n");
#line 125
  printf((char const   */* __restrict  */)tmp, "cable");
  }
#line 126
  return (0);
}
}
#line 131 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
int cmd_run(char **params ) 
{ 
  int i ;
  int r ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 136
  if (! *(params + 0)) {
#line 137
    return (1);
  }
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! cmds[i]) {
#line 139
      goto while_break;
    }
    {
#line 140
    tmp___1 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0));
    }
#line 140
    if (tmp___1 == 0) {
      {
#line 141
      tmp = (*((cmds[i])->run))(params);
#line 141
      r = tmp;
      }
#line 142
      if (r < 0) {
        {
#line 143
        tmp___0 = gettext("%s: syntax error!\n");
#line 143
        printf((char const   */* __restrict  */)tmp___0, *(params + 0));
        }
      }
#line 144
      return (r);
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp___2 = gettext("%s: unknown command\n");
#line 147
  printf((char const   */* __restrict  */)tmp___2, *(params + 0));
  }
#line 148
  return (1);
}
}
#line 151 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
int cmd_params(char **params ) 
{ 
  int i ;

  {
#line 154
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! *(params + i)) {
#line 156
      goto while_break;
    }
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (i);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cmd.c"
int cmd_get_number(char *s , unsigned int *i ) 
{ 
  int n ;
  int r ;
  size_t l ;

  {
#line 169
  if (! s) {
#line 170
    return (-1);
  } else
#line 169
  if (! i) {
#line 170
    return (-1);
  }
  {
#line 172
  l = strlen((char const   *)s);
#line 174
  n = -1;
#line 175
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"0x%x%n",
             i, & n);
  }
#line 176
  if (r == 1) {
#line 176
    if ((size_t )n == l) {
#line 177
      return (0);
    }
  }
  {
#line 179
  n = -1;
#line 180
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%u%n",
             i, & n);
  }
#line 181
  if (r == 1) {
#line 181
    if ((size_t )n == l) {
#line 182
      return (0);
    }
  }
#line 184
  return (-1);
}
}
#line 47 "../../include/chain.h"
void chain_disconnect(chain_t *chain___0 ) ;
#line 50
int chain_set_trst(chain_t *chain___0 , int trst ) ;
#line 121 "../../include/cable.h"
int cable_init(cable_t *cable ) ;
#line 145
cable_driver_t *cable_drivers[15] ;
#line 60 "../../include/parport.h"
parport_driver_t *parport_drivers[4] ;
#line 31 "../../include/tap.h"
void tap_reset(chain_t *chain___0 ) ;
#line 40 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cable.c"
static int cmd_cable_run(char **params ) 
{ 
  cable_t *cable ;
  int i ;
  int paramc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmparam ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 45
  tmp = cmd_params(params);
#line 45
  paramc = tmp;
  }
#line 48
  if (paramc < 2) {
#line 48
    return (-1);
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! parport_drivers[i]) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp___0 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 52
    if (tmp___0 == 0) {
#line 53
      goto while_break;
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if ((unsigned long )parport_drivers[i] != (unsigned long )((parport_driver_t *)0)) {
    {
#line 58
    tmp___1 = gettext("Note: the \'cable\' command syntax changed, please read the help text\n");
#line 58
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 59
    if (paramc >= 4) {
#line 62
      tmparam = *(params + 3);
#line 63
      *(params + 3) = *(params + 2);
#line 64
      *(params + 2) = *(params + 1);
#line 65
      *(params + 1) = tmparam;
    } else {
#line 68
      return (-1);
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! cable_drivers[i]) {
#line 72
      goto while_break___0;
    }
    {
#line 73
    tmp___2 = strcasecmp((char const   *)*(params + 1), (cable_drivers[i])->name);
    }
#line 73
    if (tmp___2 == 0) {
#line 74
      goto while_break___0;
    }
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  if (! cable_drivers[i]) {
    {
#line 76
    tmp___3 = gettext("Unknown cable type: %s\n");
#line 76
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 77
    return (1);
  }
#line 80
  if (paramc >= 3) {
    {
#line 82
    tmp___4 = strcasecmp((char const   *)*(params + 2), "help");
    }
#line 82
    if (tmp___4 == 0) {
      {
#line 84
      (*((cable_drivers[i])->help))((cable_drivers[i])->name);
      }
#line 85
      return (1);
    }
  }
#line 89
  if (bus) {
    {
#line 90
    (*((bus->driver)->free_bus))(bus);
#line 91
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 94
  chain_disconnect(chain);
#line 96
  tmp___5 = malloc(sizeof(cable_t ));
#line 96
  cable = (cable_t *)tmp___5;
  }
#line 98
  if (! cable) {
    {
#line 99
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 99
    printf((char const   */* __restrict  */)tmp___6, "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cable.c",
           99);
    }
#line 100
    return (1);
  }
  {
#line 103
  cable->driver = cable_drivers[i];
#line 105
  params ++;
#line 105
  tmp___8 = (*((cable->driver)->connect))(params, cable);
  }
#line 105
  if (tmp___8) {
    {
#line 106
    tmp___7 = gettext("Error: Cable connection failed!\n");
#line 106
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 107
    return (1);
  }
  {
#line 110
  chain->cable = cable;
#line 112
  tmp___10 = cable_init(chain->cable);
  }
#line 112
  if (tmp___10) {
    {
#line 113
    tmp___9 = gettext("Error: Cable initialization failed!\n");
#line 113
    printf((char const   */* __restrict  */)tmp___9);
#line 114
    chain_disconnect(chain);
    }
#line 115
    return (1);
  }
  {
#line 117
  chain_set_trst(chain, 0);
#line 118
  chain_set_trst(chain, 1);
#line 119
  tap_reset(chain);
  }
#line 121
  return (1);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cable.c"
static void cmd_cable_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 129
  tmp = gettext("Usage: %s DRIVER [DRIVER_OPTS]\nSelect JTAG cable type.\n\nDRIVER      name of cable\nDRIVER_OPTS options for the selected cable\n\nType \"cable DRIVER help\" for info about options for cable DRIVER.\n\nList of supported cables:\n");
#line 129
  printf((char const   */* __restrict  */)tmp, "cable");
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! cable_drivers[i]) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp___0 = gettext((cable_drivers[i])->description);
#line 142
    tmp___1 = gettext("%-13s %s\n");
#line 142
    printf((char const   */* __restrict  */)tmp___1, (cable_drivers[i])->name, tmp___0);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/cable.c"
cmd_t cmd_cable  =    {(char *)"cable", (char *)"select JTAG cable", & cmd_cable_help, & cmd_cable_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bus.c"
static int cmd_bus_run(char **params ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & n);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
#line 53
  if (n >= (unsigned int )buses.len) {
    {
#line 54
    tmp___3 = gettext("%s: invalid bus number\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, "bus");
    }
#line 55
    return (1);
  }
#line 58
  bus = *(buses.buses + n);
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bus.c"
static void cmd_bus_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s BUS\nChange active bus.\n\nBUS           bus number\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "bus");
  }
#line 72
  return;
}
}
#line 74 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bus.c"
cmd_t cmd_bus  =    {(char *)"bus", (char *)"change active bus", & cmd_bus_help, & cmd_bus_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bsdl.c"
static int cmd_bsdl_run(char **params ) 
{ 
  int num_params ;
  int result ;
  int debug_save ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 37
  result = -1;
#line 39
  num_params = cmd_params(params);
  }
#line 40
  if (num_params >= 2) {
    {
#line 41
    tmp___1 = strcmp((char const   *)*(params + 1), "test");
    }
#line 41
    if (tmp___1 == 0) {
#line 44
      debug_save = bsdl_debug;
#line 45
      bsdl_debug = 1;
#line 46
      if (num_params == 3) {
        {
#line 47
        tmp___0 = bsdl_read_file((char const   *)*(params + 2), -1, (char *)((void *)0));
        }
#line 47
        if (tmp___0 >= 0) {
#line 47
          result = 1;
        } else {
#line 47
          result = -1;
        }
      } else
#line 48
      if (num_params == 2) {
        {
#line 49
        bsdl_scan_files((char const   *)((void *)0), -1);
#line 50
        result = 1;
        }
      }
#line 52
      bsdl_debug = debug_save;
    }
    {
#line 55
    tmp___4 = strcmp((char const   *)*(params + 1), "dump");
    }
#line 55
    if (tmp___4 == 0) {
#line 56
      if (num_params == 3) {
        {
#line 57
        tmp___3 = bsdl_read_file((char const   *)*(params + 2), 0, (char *)((void *)0));
        }
#line 57
        if (tmp___3 >= 0) {
#line 57
          result = 1;
        } else {
#line 57
          result = -1;
        }
      } else
#line 58
      if (num_params == 2) {
        {
#line 59
        bsdl_scan_files((char const   *)((void *)0), 0);
#line 60
        result = 1;
        }
      }
    }
#line 64
    if (num_params == 3) {
      {
#line 65
      tmp___5 = strcmp((char const   *)*(params + 1), "path");
      }
#line 65
      if (tmp___5 == 0) {
        {
#line 66
        bsdl_set_path((char const   *)*(params + 2));
#line 67
        result = 1;
        }
      }
      {
#line 70
      tmp___8 = strcmp((char const   *)*(params + 1), "debug");
      }
#line 70
      if (tmp___8 == 0) {
        {
#line 71
        tmp___6 = strcmp((char const   *)*(params + 2), "on");
        }
#line 71
        if (tmp___6 == 0) {
#line 72
          bsdl_debug = 1;
#line 73
          result = 1;
        }
        {
#line 75
        tmp___7 = strcmp((char const   *)*(params + 2), "off");
        }
#line 75
        if (tmp___7 == 0) {
#line 76
          bsdl_debug = 0;
#line 77
          result = 1;
        }
      }
    }
  }
#line 83
  return (result);
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bsdl.c"
static void cmd_bsdl_help(void) 
{ 
  char *tmp ;

  {
  {
#line 90
  tmp = gettext("Usage: %s path PATHLIST\nUsage: %s test [FILE]\nUsage: %s dump [FILE]\nUsage: %s debug on|off\nManage BSDL files\n\nPATHLIST semicolon separated list of directory paths to search for BSDL files\nFILE file containing part description in BSDL format\n");
#line 90
  printf((char const   */* __restrict  */)tmp, "bsdl", "bsdl", "bsdl", "bsdl");
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bsdl.c"
cmd_t cmd_bsdl  =    {(char *)"bsdl", (char *)"manage BSDL files", & cmd_bsdl_help, & cmd_bsdl_run};
#line 51 "../../include/bsbit.h"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bit.c"
static void cmd_bit_print_params(char **params , unsigned int parameters , char *command ) 
{ 
  unsigned int i ;

  {
  {
#line 39
  strcpy((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + 0));
#line 40
  i = 1U;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < parameters)) {
#line 40
      goto while_break;
    }
    {
#line 41
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)" ");
#line 42
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + i));
#line 40
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bit.c"
static int cmd_bit_run(char **params ) 
{ 
  part_t *part___0 ;
  data_register *bsr ;
  unsigned int bit ;
  int type ;
  int safe ;
  unsigned int control ;
  unsigned int parameters ;
  int tmp ;
  char command[1024] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  signal_t *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 55
  tmp = cmd_params(params);
#line 55
  parameters = (unsigned int )tmp;
#line 58
  cmd_bit_print_params(params, parameters, command);
  }
#line 60
  if (parameters != 5U) {
#line 60
    if (parameters != 8U) {
      {
#line 61
      tmp___0 = gettext("%s: invalid number of parameters (%d) for command \'%s\'\n");
#line 61
      printf((char const   */* __restrict  */)tmp___0, "bit", parameters, command);
      }
#line 62
      return (-1);
    }
  }
  {
#line 65
  tmp___2 = cmd_test_cable();
  }
#line 65
  if (! tmp___2) {
    {
#line 66
    tmp___1 = gettext("%s: cable test failed for command \'%s\'\n");
#line 66
    printf((char const   */* __restrict  */)tmp___1, "bit", command);
    }
#line 67
    return (1);
  }
#line 70
  if (! chain->parts) {
    {
#line 71
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 71
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 72
    return (1);
  }
#line 75
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 76
    tmp___4 = gettext("%s: no active part\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4, "bit");
    }
#line 77
    return (1);
  }
  {
#line 80
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 81
  bsr = part_find_data_register(part___0, "BSR");
  }
#line 82
  if ((unsigned long )bsr == (unsigned long )((void *)0)) {
    {
#line 83
    tmp___5 = gettext("%s: missing Boundary Scan Register (BSR) for command \'%s\'\n");
#line 83
    printf((char const   */* __restrict  */)tmp___5, "bit", command);
    }
#line 84
    return (1);
  }
  {
#line 88
  tmp___7 = cmd_get_number(*(params + 1), & bit);
  }
#line 88
  if (tmp___7) {
    {
#line 89
    tmp___6 = gettext("%s: unable to get boundary bit number for command \'%s\'\n");
#line 89
    printf((char const   */* __restrict  */)tmp___6, "bit", command);
    }
#line 90
    return (-1);
  }
#line 93
  if (bit >= (unsigned int )(bsr->in)->len) {
    {
#line 94
    tmp___8 = gettext("%s: invalid boundary bit number for command \'%s\'\n");
#line 94
    printf((char const   */* __restrict  */)tmp___8, "bit", command);
    }
#line 95
    return (1);
  }
#line 97
  if ((unsigned long )*(part___0->bsbits + bit) != (unsigned long )((void *)0)) {
    {
#line 98
    tmp___9 = gettext("%s: duplicate bit declaration for command \'%s\'\n");
#line 98
    printf((char const   */* __restrict  */)tmp___9, "bit", command);
    }
#line 99
    return (1);
  }
  {
#line 103
  tmp___11 = strlen((char const   *)*(params + 2));
  }
#line 103
  if (tmp___11 != 1UL) {
    {
#line 104
    tmp___10 = gettext("%s: invalid bit type length for command \'%s\'\n");
#line 104
    printf((char const   */* __restrict  */)tmp___10, "bit", command);
    }
#line 105
    return (-1);
  }
  {
#line 109
  if ((int )*(*(params + 2) + 0) == 105) {
#line 109
    goto case_105;
  }
#line 109
  if ((int )*(*(params + 2) + 0) == 73) {
#line 109
    goto case_105;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 111) {
#line 113
    goto case_111;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 79) {
#line 113
    goto case_111;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 98) {
#line 117
    goto case_98;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 66) {
#line 117
    goto case_98;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 99) {
#line 121
    goto case_99;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 67) {
#line 121
    goto case_99;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 120) {
#line 125
    goto case_120;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 88) {
#line 125
    goto case_120;
  }
#line 128
  goto switch_default;
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 110
  type = 1;
#line 111
  goto switch_break;
  case_111: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 114
  type = 2;
#line 115
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 118
  type = 5;
#line 119
  goto switch_break;
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 122
  type = 3;
#line 123
  goto switch_break;
  case_120: /* CIL Label */ 
  case_88: /* CIL Label */ 
#line 126
  type = 4;
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 129
  tmp___12 = gettext("%s: invalid bit type for command \'%s\'\n");
#line 129
  printf((char const   */* __restrict  */)tmp___12, "bit", command);
  }
#line 130
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___14 = strlen((char const   *)*(params + 3));
  }
#line 134
  if (tmp___14 != 1UL) {
    {
#line 135
    tmp___13 = gettext("%s: invalid default value length for command \'%s\'\n");
#line 135
    printf((char const   */* __restrict  */)tmp___13, "bit", command);
    }
#line 136
    return (-1);
  }
#line 139
  if ((int )*(*(params + 3) + 0) == 49) {
#line 139
    safe = 1;
  } else {
#line 139
    safe = 0;
  }
  {
#line 140
  *((bsr->in)->data + bit) = (char )safe;
#line 143
  tmp___15 = part_find_signal(part___0, (char const   *)*(params + 4));
#line 143
  *(part___0->bsbits + bit) = bsbit_alloc((int )bit, (char const   *)*(params + 4),
                                          type, tmp___15, safe);
  }
#line 144
  if ((unsigned long )*(part___0->bsbits + bit) == (unsigned long )((void *)0)) {
    {
#line 145
    tmp___16 = gettext("%s: out of memory for command \'%s\'\n");
#line 145
    printf((char const   */* __restrict  */)tmp___16, "bit", command);
    }
#line 146
    return (1);
  }
  {
#line 150
  tmp___17 = cmd_params(params);
  }
#line 150
  if (tmp___17 == 5) {
#line 151
    return (1);
  }
  {
#line 154
  tmp___19 = cmd_get_number(*(params + 5), & control);
  }
#line 154
  if (tmp___19) {
    {
#line 155
    tmp___18 = gettext("%s: unable to get control bit number for command \'%s\'\n");
#line 155
    printf((char const   */* __restrict  */)tmp___18, "bit", command);
    }
#line 156
    return (-1);
  }
#line 158
  if (control >= (unsigned int )(bsr->in)->len) {
    {
#line 159
    tmp___20 = gettext("%s: invalid control bit number for command \'%s\'\n");
#line 159
    printf((char const   */* __restrict  */)tmp___20, "bit", command);
    }
#line 160
    return (1);
  }
  {
#line 162
  (*(part___0->bsbits + bit))->control = (int )control;
#line 165
  tmp___22 = strlen((char const   *)*(params + 6));
  }
#line 165
  if (tmp___22 != 1UL) {
    {
#line 166
    tmp___21 = gettext("%s: invalid control value length for command \'%s\'\n");
#line 166
    printf((char const   */* __restrict  */)tmp___21, "bit", command);
    }
#line 167
    return (-1);
  }
#line 169
  if ((int )*(*(params + 6) + 0) == 49) {
#line 169
    (*(part___0->bsbits + bit))->control_value = 1;
  } else {
#line 169
    (*(part___0->bsbits + bit))->control_value = 0;
  }
  {
#line 172
  tmp___23 = strcasecmp((char const   *)*(params + 7), "Z");
  }
#line 172
  if (tmp___23) {
#line 173
    return (-1);
  }
#line 175
  (*(part___0->bsbits + bit))->control_state = -1;
#line 177
  return (1);
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bit.c"
static void cmd_bit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 183
  tmp = gettext("Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\nDefine new BSR (Boundary Scan Register) bit for SIGNAL, with\nDEFAULT value.\n\nNUMBER        Bit number in the BSR\nTYPE          Bit type, valid values are I, O, B, C, and X\nDEFAULT       Default (safe) bit value, valid values are 1, 0, ?\nSIGNAL        Associated signal name\nCBIT          Control bit number\nCVAL          Control value\nCSTATE        Control state, valid state is only Z\n");
#line 183
  printf((char const   */* __restrict  */)tmp, "bit");
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/cmd/bit.c"
cmd_t cmd_bit  =    {(char *)"bit", (char *)"define new BSR bit", & cmd_bit_help, & cmd_bit_run};
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/jedec.c"
static struct amd_flash_info  const  table[21]  = 
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )1, (int const   )8918, "AMD AM29F800BT", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )15}, {(u_int32_t )983040,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )1015808,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )1032192,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )4, (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384,
                                                                (u_int32_t )1}, {(u_int32_t )16384,
                                                                                 (u_int32_t )8192,
                                                                                 (u_int32_t )2},
                                                               {(u_int32_t )32768,
                                                                (u_int32_t )32768,
                                                                (u_int32_t )1}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )32, (int const   )8900, "ST M29W160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (u_int8_t const   )1,
      (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )48},
                                         {(u_int32_t )3145728, (u_int32_t )65536,
                                          (u_int32_t )15}, {(u_int32_t )4128768, (u_int32_t )8192,
                                                            (u_int32_t )8}}}, 
        {(int const   )1, (int const   )8830, "AMD AM29BDS643D", (long const   )8388608,
      (u_int8_t const   )1, (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )96}, {(u_int32_t )6291456,
                                                                                  (u_int32_t )65536,
                                                                                  (u_int32_t )31},
                                                               {(u_int32_t )8323072,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )8}}}, 
        {(int const   )31, (int const   )192, "Atmel AT49xV16x", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )8192,
                                                                (u_int32_t )8}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )8192, (u_int32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )7},
                                         {(u_int32_t )458752, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )491520, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )507904, (u_int32_t )16384, (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (u_int8_t const   )0,
      (int const   )1, (int const   )1, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )8}}}};
#line 368 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/jedec.c"
int jedec_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int manid_as[2] ;
  int devid_as[2] ;
  int manid ;
  int devid ;
  int ba ;
  int bw ;
  int i ;
  int j ;
  cfi_query_structure_t *cfi ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 374
  manid = 0;
#line 374
  devid = 0;
#line 380
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 380
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 381
  if (! *cfi_array___0) {
#line 382
    return (-2);
  }
  {
#line 384
  (*cfi_array___0)->bus = bus___0;
#line 385
  (*cfi_array___0)->address = adr;
#line 386
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 386
  if (tmp___0 != 0) {
#line 387
    return (-8);
  }
#line 388
  bw = (int )area.width;
#line 389
  if (bw != 8) {
#line 389
    if (bw != 16) {
#line 389
      if (bw != 32) {
#line 390
        return (-3);
      }
    }
  }
  {
#line 391
  ba = bw / 8;
#line 391
  (*cfi_array___0)->bus_width = ba;
#line 393
  tmp___1 = calloc((size_t )1, sizeof(cfi_chip_t *));
#line 393
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 394
  if (! (*cfi_array___0)->cfi_chips) {
#line 395
    return (-2);
  }
  {
#line 397
  tmp___2 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 397
  *((*cfi_array___0)->cfi_chips + 0) = (cfi_chip_t *)tmp___2;
  }
#line 398
  if (! *((*cfi_array___0)->cfi_chips + 0)) {
#line 399
    return (-2);
  }
  {
#line 402
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 403
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )170);
#line 404
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )85);
#line 405
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )144);
#line 407
  tmp___3 = (*((bus___0->driver)->read))(bus___0, adr);
#line 407
  manid_as[0] = (int )tmp___3;
#line 408
  tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + 2U);
#line 408
  devid_as[0] = (int )tmp___4;
#line 409
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 412
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 413
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 414
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 415
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 417
  tmp___5 = (*((bus___0->driver)->read))(bus___0, adr);
#line 417
  manid_as[1] = (int )tmp___5;
#line 418
  tmp___6 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 418
  devid_as[1] = (int )tmp___6;
#line 419
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 421
  i = 0;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! ((unsigned long )i < sizeof(table) / sizeof(struct amd_flash_info ))) {
#line 421
      goto while_break;
    }
#line 424
    manid = manid_as[table[i].as_method];
#line 425
    devid = devid_as[table[i].as_method];
#line 426
    if (manid == (int )table[i].mfr_id) {
#line 426
      if (devid == (int )table[i].dev_id) {
#line 426
        goto while_break;
      }
    }
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dev ID=%04x   man ID=%04x\n",
          devid, manid);
  }
#line 430
  if ((unsigned long )i == sizeof(table) / sizeof(struct amd_flash_info )) {
#line 431
    return (-4);
  }
#line 433
  cfi = & (*((*cfi_array___0)->cfi_chips + 0))->cfi;
#line 435
  cfi->identification_string.pri_id_code = (uint16_t )2;
#line 436
  cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 437
  cfi->identification_string.alt_id_code = (uint16_t )0;
#line 438
  cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 440
  cfi->device_geometry.device_size = (uint32_t )table[i].size;
#line 442
  cfi->device_geometry.device_interface = (uint16_t )table[i].interface_width;
  {
#line 444
  if ((int const   )table[i].interface_width == 0) {
#line 444
    goto case_0;
  }
#line 447
  if ((int const   )table[i].interface_width == 1) {
#line 447
    goto case_1;
  }
#line 450
  if ((int const   )table[i].interface_width == 2) {
#line 450
    goto case_2;
  }
#line 455
  if ((int const   )table[i].interface_width == 3) {
#line 455
    goto case_3;
  }
#line 458
  if ((int const   )table[i].interface_width == 4) {
#line 458
    goto case_4;
  }
#line 463
  goto switch_default;
  case_0: /* CIL Label */ 
#line 445
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 446
  goto switch_break;
  case_1: /* CIL Label */ 
#line 448
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 449
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 451
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X8_X16", "CFI_INTERFACE_X16");
#line 452
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 453
  cfi->device_geometry.device_interface = (uint16_t )1;
  }
#line 454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 456
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 457
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 459
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X16_X32", "CFI_INTERFACE_X32");
#line 460
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 461
  cfi->device_geometry.device_interface = (uint16_t )3;
  }
#line 462
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 465
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unsupported interface geometry %d, bailing out\n",
          (int const   )table[i].interface_width);
#line 466
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 467
  cfi->device_geometry.device_interface = (uint16_t )0;
  }
#line 468
  return (-5);
#line 469
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 472
  cfi->device_geometry.number_of_erase_regions = (uint8_t )table[i].numeraseregions;
#line 474
  tmp___7 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 474
  cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___7;
  }
#line 476
  if (! cfi->device_geometry.erase_block_regions) {
#line 477
    return (-2);
  }
#line 479
  j = 0;
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! (j < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 479
      goto while_break___0;
    }
#line 480
    (cfi->device_geometry.erase_block_regions + j)->erase_block_size = (uint32_t )table[i].regions[j].erasesize;
#line 482
    (cfi->device_geometry.erase_block_regions + j)->number_of_erase_blocks = (uint32_t )table[i].regions[j].numblocks;
#line 479
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 486
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found %s flash,  size = %li bytes.\n",
          table[i].name, table[i].size);
  }
#line 488
  return (0);
}
}
#line 48 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 56 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 61
  if (tmp != 0) {
#line 62
    return (0);
  }
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 64
    if (area.width == 32U) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return (tmp___0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_autodetect(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 74
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 74
  if (tmp != 0) {
#line 75
    return (0);
  }
#line 77
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 77
    goto _L;
  } else
#line 77
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 77
    if (area.width == 16U) {
#line 77
      tmp___0 = 1;
    } else {
#line 77
      tmp___0 = 0;
    }
  } else {
#line 77
    tmp___0 = 0;
  }
#line 77
  return (tmp___0);
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 87
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 87
  if (tmp != 0) {
#line 88
    return (0);
  }
#line 90
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 90
    goto _L;
  } else
#line 90
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 90
    if (area.width == 8U) {
#line 90
      tmp___0 = 1;
    } else {
#line 90
      tmp___0 = 0;
    }
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  return (tmp___0);
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static void _intel_flash_print_info(cfi_array_t *cfi_array___0 , int o ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 99
  bus___0 = cfi_array___0->bus;
#line 101
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 101
  mid = tmp & 255U;
  }
  {
#line 103
  if (mid == 137U) {
#line 103
    goto case_137;
  }
#line 106
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 104
  tmp___0 = gettext("Manufacturer: %s\n");
#line 104
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 105
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 107
  tmp___1 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 107
  printf((char const   */* __restrict  */)tmp___1, mid);
  }
#line 108
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 111
  tmp___2 = gettext("Chip: ");
#line 111
  printf((char const   */* __restrict  */)tmp___2);
#line 112
  tmp___3 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 112
  cid = tmp___3 & 65535U;
  }
  {
#line 114
  if (cid == 22U) {
#line 114
    goto case_22;
  }
#line 117
  if (cid == 23U) {
#line 117
    goto case_23;
  }
#line 120
  if (cid == 24U) {
#line 120
    goto case_24;
  }
#line 123
  if (cid == 29U) {
#line 123
    goto case_29;
  }
#line 126
  if (cid == 34817U) {
#line 126
    goto case_34817;
  }
#line 129
  if (cid == 34818U) {
#line 129
    goto case_34818;
  }
#line 132
  if (cid == 34819U) {
#line 132
    goto case_34819;
  }
#line 135
  if (cid == 34821U) {
#line 135
    goto case_34821;
  }
#line 138
  if (cid == 34822U) {
#line 138
    goto case_34822;
  }
#line 141
  if (cid == 34823U) {
#line 141
    goto case_34823;
  }
#line 144
  if (cid == 34827U) {
#line 144
    goto case_34827;
  }
#line 147
  if (cid == 34828U) {
#line 147
    goto case_34828;
  }
#line 150
  if (cid == 34829U) {
#line 150
    goto case_34829;
  }
#line 153
  if (cid == 34830U) {
#line 153
    goto case_34830;
  }
#line 156
  if (cid == 34831U) {
#line 156
    goto case_34831;
  }
#line 159
  if (cid == 34832U) {
#line 159
    goto case_34832;
  }
#line 162
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 115
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 116
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 118
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 119
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 121
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 122
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 125
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 127
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 128
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 130
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 131
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 134
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 137
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 140
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 143
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 146
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 149
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 152
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 155
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 158
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 161
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 163
  tmp___4 = gettext("Unknown (0x%02X)!\n");
#line 163
  printf((char const   */* __restrict  */)tmp___4, cid);
  }
#line 164
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 168
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 169
  return;
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static void intel_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 174
  o = 1;
#line 175
  bus___0 = cfi_array___0->bus;
#line 181
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 184
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 186
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 187
  return;
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static void intel_flash_print_info32(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 192
  o = 2;
#line 193
  bus___0 = cfi_array___0->bus;
#line 198
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 201
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 203
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 204
  return;
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 210
  bus___0 = cfi_array___0->bus;
#line 212
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 213
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 214
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 216
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 216
    sr = (uint16_t )(tmp & 254U);
    }
#line 216
    if ((int )sr & (1 << 7)) {
#line 216
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 219
    goto case_0;
  }
#line 221
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 221
    goto case_exp;
  }
#line 224
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 224
    goto case_exp___0;
  }
#line 227
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 227
    goto case_exp___1;
  }
#line 230
  goto switch_default;
  case_0: /* CIL Label */ 
#line 220
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 222
  tmp___0 = gettext("flash: invalid command seq\n");
#line 222
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 223
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 225
  tmp___1 = gettext("flash: low vpen\n");
#line 225
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 226
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 228
  tmp___2 = gettext("flash: block locked\n");
#line 228
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 229
  return (3);
  switch_default: /* CIL Label */ 
#line 231
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 234
  return (99);
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 241
  bus___0 = cfi_array___0->bus;
#line 243
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 244
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 245
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 247
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 247
    sr = (uint16_t )(tmp & 254U);
    }
#line 247
    if ((int )sr & (1 << 7)) {
#line 247
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if ((int )sr != 1 << 7) {
    {
#line 250
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 250
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 251
    return (99);
  } else {
#line 253
    return (0);
  }
}
}
#line 256 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 260
  bus___0 = cfi_array___0->bus;
#line 262
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 263
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 264
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 266
    sr = (uint16_t )(tmp & 254U);
    }
#line 266
    if ((int )sr & (1 << 7)) {
#line 266
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  if ((int )sr != 1 << 7) {
    {
#line 269
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 269
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 270
    return (99);
  } else {
#line 272
    return (0);
  }
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 279
  bus___0 = cfi_array___0->bus;
#line 281
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 282
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 283
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 285
    sr = tmp & 16646398U;
    }
#line 285
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 285
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 288
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 289
    return (99);
  } else {
#line 291
    return (0);
  }
}
}
#line 294 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 298
  bus___0 = cfi_array___0->bus;
#line 300
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 301
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 302
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 304
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 304
    sr = tmp & 16646398U;
    }
#line 304
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 304
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 307
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 308
    return (99);
  } else {
#line 310
    return (0);
  }
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 317
  bus___0 = cfi_array___0->bus;
#line 319
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 320
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 321
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 323
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 323
    sr = tmp & 16646398U;
    }
#line 323
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 323
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 326
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 327
    return (99);
  } else {
#line 329
    return (0);
  }
}
}
#line 332 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static void intel_flash_readarray32(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 336
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 337
  return;
}
}
#line 339 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
static void intel_flash_readarray(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 343
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 344
  return;
}
}
#line 346 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
flash_driver_t intel_32_flash_driver  = 
#line 346
     {4U, "Intel Standard Command Set", "supported: 28Fxxxx, 2 x 16 bit", & intel_flash_autodetect32,
    & intel_flash_print_info32, & intel_flash_erase_block32, & intel_flash_unlock_block32,
    & intel_flash_program32, & intel_flash_readarray32};
#line 358 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
flash_driver_t intel_16_flash_driver  = 
#line 358
     {2U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 16 bit", & intel_flash_autodetect,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 370 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/intel.c"
flash_driver_t intel_8_flash_driver  = 
#line 370
     {1U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 8 bit", & intel_flash_autodetect8,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 58 "../../include/flash.h"
void cfi_array_free(cfi_array_t *cfi_array___0 ) ;
#line 59
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/detectflash.c"
cfi_array_t *cfi_array  =    (cfi_array_t *)((void *)0);
#line 47
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/detectflash.c"
void detectflash(bus_t *bus___0 , uint32_t adr ) 
{ 
  cfi_query_structure_t *cfi ;
  char const   *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 55
  if (! bus___0) {
    {
#line 56
    tmp = gettext("Error: Missing bus driver!\n");
#line 56
    printf((char const   */* __restrict  */)tmp);
    }
#line 57
    return;
  }
  {
#line 60
  cfi_array_free(cfi_array);
#line 61
  cfi_array = (cfi_array_t *)((void *)0);
#line 63
  (*((bus___0->driver)->prepare))(bus___0);
#line 65
  tmp___2 = cfi_detect(bus___0, adr, & cfi_array);
  }
#line 65
  if (tmp___2) {
    {
#line 66
    cfi_array_free(cfi_array);
#line 67
    cfi_array = (cfi_array_t *)((void *)0);
#line 68
    tmp___1 = jedec_detect(bus___0, adr, & cfi_array);
    }
#line 68
    if (tmp___1 != 0) {
      {
#line 69
      cfi_array_free(cfi_array);
#line 70
      cfi_array = (cfi_array_t *)((void *)0);
#line 71
      tmp___0 = amd_detect(bus___0, adr, & cfi_array);
      }
#line 71
      if (tmp___0 != 0) {
        {
#line 73
        cfi_array_free(cfi_array);
#line 74
        cfi_array = (cfi_array_t *)((void *)0);
        }
      }
    }
  }
#line 85
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
    {
#line 87
    tmp___3 = gettext("Flash not found!\n");
#line 87
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 88
    return;
  }
  {
#line 91
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 96
  tmp___4 = gettext("Query identification string:\n");
#line 96
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 99
  if ((int )cfi->identification_string.pri_id_code == 0) {
#line 99
    goto case_0;
  }
#line 102
  if ((int )cfi->identification_string.pri_id_code == 1) {
#line 102
    goto case_1;
  }
#line 105
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 105
    goto case_2;
  }
#line 108
  if ((int )cfi->identification_string.pri_id_code == 3) {
#line 108
    goto case_3;
  }
#line 111
  if ((int )cfi->identification_string.pri_id_code == 4) {
#line 111
    goto case_4;
  }
#line 114
  if ((int )cfi->identification_string.pri_id_code == 256) {
#line 114
    goto case_256;
  }
#line 117
  if ((int )cfi->identification_string.pri_id_code == 257) {
#line 117
    goto case_257;
  }
#line 120
  if ((int )cfi->identification_string.pri_id_code == 258) {
#line 120
    goto case_258;
  }
#line 123
  goto switch_default;
  case_0: /* CIL Label */ 
#line 100
  s = "null";
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  s = "Intel/Sharp Extended Command Set";
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
#line 106
  s = "AMD/Fujitsu Standard Command Set";
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 109
  s = "Intel Standard Command Set";
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  s = "AMD/Fujitsu Extended Command Set";
#line 113
  goto switch_break;
  case_256: /* CIL Label */ 
#line 115
  s = "Mitsubishi Standard Command Set";
#line 116
  goto switch_break;
  case_257: /* CIL Label */ 
#line 118
  s = "Mitsubishi Extended Command Set";
#line 119
  goto switch_break;
  case_258: /* CIL Label */ 
#line 121
  s = "Page Write Command Set";
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 124
  s = "unknown!!!";
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp___5 = gettext(s);
#line 127
  tmp___6 = gettext("\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 127
  printf((char const   */* __restrict  */)tmp___6, (int )cfi->identification_string.pri_id_code,
         tmp___5);
  }
  {
#line 129
  if ((int )cfi->identification_string.alt_id_code == 0) {
#line 129
    goto case_0___0;
  }
#line 132
  if ((int )cfi->identification_string.alt_id_code == 1) {
#line 132
    goto case_1___0;
  }
#line 135
  if ((int )cfi->identification_string.alt_id_code == 2) {
#line 135
    goto case_2___0;
  }
#line 138
  if ((int )cfi->identification_string.alt_id_code == 3) {
#line 138
    goto case_3___0;
  }
#line 141
  if ((int )cfi->identification_string.alt_id_code == 4) {
#line 141
    goto case_4___0;
  }
#line 144
  if ((int )cfi->identification_string.alt_id_code == 256) {
#line 144
    goto case_256___0;
  }
#line 147
  if ((int )cfi->identification_string.alt_id_code == 257) {
#line 147
    goto case_257___0;
  }
#line 150
  if ((int )cfi->identification_string.alt_id_code == 258) {
#line 150
    goto case_258___0;
  }
#line 153
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 130
  s = "null";
#line 131
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 133
  s = "Intel/Sharp Extended Command Set";
#line 134
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 136
  s = "AMD/Fujitsu Standard Command Set";
#line 137
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 139
  s = "Intel Standard Command Set";
#line 140
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 142
  s = "AMD/Fujitsu Extended Command Set";
#line 143
  goto switch_break___0;
  case_256___0: /* CIL Label */ 
#line 145
  s = "Mitsubishi Standard Command Set";
#line 146
  goto switch_break___0;
  case_257___0: /* CIL Label */ 
#line 148
  s = "Mitsubishi Extended Command Set";
#line 149
  goto switch_break___0;
  case_258___0: /* CIL Label */ 
#line 151
  s = "Page Write Command Set";
#line 152
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 154
  s = "unknown!!!";
#line 155
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 157
  tmp___7 = gettext(s);
#line 157
  tmp___8 = gettext("\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 157
  printf((char const   */* __restrict  */)tmp___8, (int )cfi->identification_string.alt_id_code,
         tmp___7);
#line 160
  tmp___9 = gettext("Query system interface information:\n");
#line 160
  printf((char const   */* __restrict  */)tmp___9);
#line 161
  tmp___10 = gettext("\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n");
#line 161
  printf((char const   */* __restrict  */)tmp___10, (int )cfi->system_interface_info.vcc_min_wev);
#line 162
  tmp___11 = gettext("\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n");
#line 162
  printf((char const   */* __restrict  */)tmp___11, (int )cfi->system_interface_info.vcc_max_wev);
#line 163
  tmp___12 = gettext("\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n");
#line 163
  printf((char const   */* __restrict  */)tmp___12, (int )cfi->system_interface_info.vpp_min_wev);
#line 164
  tmp___13 = gettext("\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n");
#line 164
  printf((char const   */* __restrict  */)tmp___13, (int )cfi->system_interface_info.vpp_max_wev);
#line 165
  tmp___14 = gettext("\tTypical timeout per single byte/word program: %d us\n");
#line 165
  printf((char const   */* __restrict  */)tmp___14, cfi->system_interface_info.typ_single_write_timeout);
#line 166
  tmp___15 = gettext("\tTypical timeout for maximum-size multi-byte program: %d us\n");
#line 166
  printf((char const   */* __restrict  */)tmp___15, cfi->system_interface_info.typ_buffer_write_timeout);
#line 167
  tmp___16 = gettext("\tTypical timeout per individual block erase: %d ms\n");
#line 167
  printf((char const   */* __restrict  */)tmp___16, cfi->system_interface_info.typ_block_erase_timeout);
#line 168
  tmp___17 = gettext("\tTypical timeout for full chip erase: %d ms\n");
#line 168
  printf((char const   */* __restrict  */)tmp___17, cfi->system_interface_info.typ_chip_erase_timeout);
#line 169
  tmp___18 = gettext("\tMaximum timeout for byte/word program: %d us\n");
#line 169
  printf((char const   */* __restrict  */)tmp___18, cfi->system_interface_info.max_single_write_timeout);
#line 170
  tmp___19 = gettext("\tMaximum timeout for multi-byte program: %d us\n");
#line 170
  printf((char const   */* __restrict  */)tmp___19, cfi->system_interface_info.max_buffer_write_timeout);
#line 171
  tmp___20 = gettext("\tMaximum timeout per individual block erase: %d ms\n");
#line 171
  printf((char const   */* __restrict  */)tmp___20, cfi->system_interface_info.max_block_erase_timeout);
#line 172
  tmp___21 = gettext("\tMaximum timeout for chip erase: %d ms\n");
#line 172
  printf((char const   */* __restrict  */)tmp___21, cfi->system_interface_info.max_chip_erase_timeout);
#line 175
  tmp___22 = gettext("Device geometry definition:\n");
#line 175
  printf((char const   */* __restrict  */)tmp___22);
#line 176
  tmp___23 = gettext("\tDevice Size: %d B (%d KiB, %d MiB)\n");
#line 176
  printf((char const   */* __restrict  */)tmp___23, cfi->device_geometry.device_size,
         cfi->device_geometry.device_size / 1024U, cfi->device_geometry.device_size / 1048576U);
  }
  {
#line 182
  if ((int )cfi->device_geometry.device_interface == 0) {
#line 182
    goto case_0___1;
  }
#line 185
  if ((int )cfi->device_geometry.device_interface == 1) {
#line 185
    goto case_1___1;
  }
#line 188
  if ((int )cfi->device_geometry.device_interface == 2) {
#line 188
    goto case_2___1;
  }
#line 191
  if ((int )cfi->device_geometry.device_interface == 3) {
#line 191
    goto case_3___1;
  }
#line 194
  if ((int )cfi->device_geometry.device_interface == 4) {
#line 194
    goto case_4___1;
  }
#line 197
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 183
  s = "x8";
#line 184
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 186
  s = "x16";
#line 187
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 189
  s = "x8/x16";
#line 190
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 192
  s = "x32";
#line 193
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 195
  s = "x16/x32";
#line 196
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 198
  s = "unknown!!!";
#line 199
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 201
  tmp___24 = gettext(s);
#line 201
  tmp___25 = gettext("\tFlash Device Interface Code description: 0x%04X (%s)\n");
#line 201
  printf((char const   */* __restrict  */)tmp___25, (int )cfi->device_geometry.device_interface,
         tmp___24);
#line 202
  tmp___26 = gettext("\tMaximum number of bytes in multi-byte program: %d\n");
#line 202
  printf((char const   */* __restrict  */)tmp___26, cfi->device_geometry.max_bytes_write);
#line 203
  tmp___27 = gettext("\tNumber of Erase Block Regions within device: %d\n");
#line 203
  printf((char const   */* __restrict  */)tmp___27, (int )cfi->device_geometry.number_of_erase_regions);
#line 204
  tmp___28 = gettext("\tErase Block Region Information:\n");
#line 204
  printf((char const   */* __restrict  */)tmp___28);
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp___29 = gettext("\t\tRegion %d:\n");
#line 209
    printf((char const   */* __restrict  */)tmp___29, i);
#line 210
    tmp___30 = gettext("\t\t\tErase Block Size: %d B (%d KiB)\n");
#line 210
    printf((char const   */* __restrict  */)tmp___30, (cfi->device_geometry.erase_block_regions + i)->erase_block_size,
           (cfi->device_geometry.erase_block_regions + i)->erase_block_size / 1024U);
#line 213
    tmp___31 = gettext("\t\t\tNumber of Erase Blocks: %d\n");
#line 213
    printf((char const   */* __restrict  */)tmp___31, (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/cfi.c"
void cfi_array_free(cfi_array_t *cfi_array___0 ) 
{ 
  int i ;

  {
#line 43
  if (! cfi_array___0) {
#line 44
    return;
  }
#line 46
  if (cfi_array___0->cfi_chips) {
#line 49
    i = 0;
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      if (! (i < cfi_array___0->bus_width)) {
#line 49
        goto while_break;
      }
#line 50
      if (! *(cfi_array___0->cfi_chips + i)) {
#line 51
        goto __Cont;
      }
      {
#line 53
      free((void *)(*(cfi_array___0->cfi_chips + i))->cfi.device_geometry.erase_block_regions);
#line 54
      free((void *)*(cfi_array___0->cfi_chips + i));
      }
      __Cont: /* CIL Label */ 
#line 49
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 56
    free((void *)cfi_array___0->cfi_chips);
    }
  }
  {
#line 59
  free((void *)cfi_array___0);
  }
#line 60
  return;
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/cfi.c"
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  unsigned int bw ;
  unsigned int d ;
  int ba ;
  int ma ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  cfi_query_structure_t *cfi ;
  uint32_t tmp___2 ;
  int ret ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;
  uint32_t tmp___21 ;
  int tmp___22 ;
  uint32_t tmp___23 ;
  int tmp___24 ;
  uint32_t tmp___25 ;
  int tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint8_t tmp___32 ;
  uint32_t tmp___33 ;
  void *tmp___34 ;
  int a ;
  int i ;
  uint32_t y ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t z ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;

  {
#line 71
  if (! cfi_array___0) {
#line 72
    return (-1);
  } else
#line 71
  if (! bus___0) {
#line 72
    return (-1);
  }
  {
#line 74
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 74
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 75
  if (! *cfi_array___0) {
#line 76
    return (-2);
  }
  {
#line 78
  (*cfi_array___0)->bus = bus___0;
#line 79
  (*cfi_array___0)->address = adr;
#line 80
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 80
  if (tmp___0 != 0) {
#line 81
    return (-8);
  }
#line 82
  bw = area.width;
#line 83
  if (bw != 8U) {
#line 83
    if (bw != 16U) {
#line 83
      if (bw != 32U) {
#line 84
        return (-3);
      }
    }
  }
  {
#line 85
  ba = (int )(bw / 8U);
#line 85
  (*cfi_array___0)->bus_width = ba;
#line 86
  tmp___1 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 86
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 87
  if (! (*cfi_array___0)->cfi_chips) {
#line 88
    return (-2);
  }
#line 90
  d = 0U;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (d < bw)) {
#line 90
      goto while_break;
    }
#line 100
    ret = -4;
#line 103
    ma = 1;
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! (ma <= 4)) {
#line 103
        goto while_break___0;
      }
      {
#line 104
      (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )((85 * ba) * ma), (uint32_t )(152 << d));
#line 106
      tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((16 * ba) * ma));
      }
#line 106
      if (((tmp___4 >> d) & 255U) == 81U) {
        {
#line 107
        ret = -5;
#line 108
        tmp___3 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((17 * ba) * ma));
        }
#line 108
        if (((tmp___3 >> d) & 255U) == 82U) {
#line 109
          goto while_break___0;
        }
      }
      {
#line 112
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
#line 103
      ma *= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    if (ma > 4) {
#line 116
      return (ret);
    }
    {
#line 118
    tmp___5 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((18 * ba) * ma));
    }
#line 118
    if (((tmp___5 >> d) & 255U) != 89U) {
      {
#line 119
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 120
      return (-6);
    }
    {
#line 123
    tmp___6 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 123
    *((*cfi_array___0)->cfi_chips + d / 8U) = (cfi_chip_t *)tmp___6;
    }
#line 124
    if (! *((*cfi_array___0)->cfi_chips + d / 8U)) {
      {
#line 125
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 126
      return (-2);
    }
    {
#line 128
    cfi = & (*((*cfi_array___0)->cfi_chips + d / 8U))->cfi;
#line 131
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((19 * ba) * ma));
#line 131
    tmp___7 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((20 * ba) * ma));
#line 131
    tmp___8 = (*((bus___0->driver)->read_end))(bus___0);
#line 131
    cfi->identification_string.pri_id_code = (uint16_t )(((tmp___7 >> d) & 255U) | (((tmp___8 >> d) & 255U) << 8));
#line 132
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 133
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((23 * ba) * ma));
#line 133
    tmp___9 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((24 * ba) * ma));
#line 133
    tmp___10 = (*((bus___0->driver)->read_end))(bus___0);
#line 133
    cfi->identification_string.alt_id_code = (uint16_t )(((tmp___9 >> d) & 255U) | (((tmp___10 >> d) & 255U) << 8));
#line 134
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 137
    tmp___11 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((27 * ba) * ma));
#line 137
    tmp___2 = (tmp___11 >> d) & 255U;
#line 138
    cfi->system_interface_info.vcc_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 139
    tmp___12 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((28 * ba) * ma));
#line 139
    tmp___2 = (tmp___12 >> d) & 255U;
#line 140
    cfi->system_interface_info.vcc_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 141
    tmp___13 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((29 * ba) * ma));
#line 141
    tmp___2 = (tmp___13 >> d) & 255U;
#line 142
    cfi->system_interface_info.vpp_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 143
    tmp___14 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((30 * ba) * ma));
#line 143
    tmp___2 = (tmp___14 >> d) & 255U;
#line 144
    cfi->system_interface_info.vpp_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 147
    tmp___15 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((31 * ba) * ma));
#line 147
    tmp___2 = (tmp___15 >> d) & 255U;
    }
#line 148
    if (tmp___2) {
#line 148
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 148
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )0;
    }
    {
#line 150
    tmp___16 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((32 * ba) * ma));
#line 150
    tmp___2 = (tmp___16 >> d) & 255U;
    }
#line 151
    if (tmp___2) {
#line 151
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 151
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )0;
    }
    {
#line 153
    tmp___17 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((33 * ba) * ma));
#line 153
    tmp___2 = (tmp___17 >> d) & 255U;
    }
#line 154
    if (tmp___2) {
#line 154
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 154
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )0;
    }
    {
#line 156
    tmp___18 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((34 * ba) * ma));
#line 156
    tmp___2 = (tmp___18 >> d) & 255U;
    }
#line 157
    if (tmp___2) {
#line 157
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 157
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )0;
    }
    {
#line 159
    tmp___19 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((35 * ba) * ma));
#line 159
    tmp___2 = (tmp___19 >> d) & 255U;
    }
#line 160
    if (tmp___2) {
#line 160
      tmp___20 = 1 << tmp___2;
    } else {
#line 160
      tmp___20 = 0;
    }
    {
#line 160
    cfi->system_interface_info.max_single_write_timeout = (uint32_t )tmp___20 * cfi->system_interface_info.typ_single_write_timeout;
#line 163
    tmp___21 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((36 * ba) * ma));
#line 163
    tmp___2 = (tmp___21 >> d) & 255U;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___22 = 1 << tmp___2;
    } else {
#line 164
      tmp___22 = 0;
    }
    {
#line 164
    cfi->system_interface_info.max_buffer_write_timeout = (uint32_t )tmp___22 * cfi->system_interface_info.typ_buffer_write_timeout;
#line 167
    tmp___23 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((37 * ba) * ma));
#line 167
    tmp___2 = (tmp___23 >> d) & 255U;
    }
#line 168
    if (tmp___2) {
#line 168
      tmp___24 = 1 << tmp___2;
    } else {
#line 168
      tmp___24 = 0;
    }
    {
#line 168
    cfi->system_interface_info.max_block_erase_timeout = (uint32_t )tmp___24 * cfi->system_interface_info.typ_block_erase_timeout;
#line 171
    tmp___25 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((38 * ba) * ma));
#line 171
    tmp___2 = (tmp___25 >> d) & 255U;
    }
#line 172
    if (tmp___2) {
#line 172
      tmp___26 = 1 << tmp___2;
    } else {
#line 172
      tmp___26 = 0;
    }
    {
#line 172
    cfi->system_interface_info.max_chip_erase_timeout = (uint32_t )tmp___26 * cfi->system_interface_info.typ_chip_erase_timeout;
#line 177
    tmp___27 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((39 * ba) * ma));
#line 177
    cfi->device_geometry.device_size = (uint32_t )(1 << ((tmp___27 >> d) & 255U));
#line 179
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((40 * ba) * ma));
#line 179
    tmp___28 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((41 * ba) * ma));
#line 179
    tmp___29 = (*((bus___0->driver)->read_end))(bus___0);
#line 179
    cfi->device_geometry.device_interface = (uint16_t )(((tmp___28 >> d) & 255U) | (((tmp___29 >> d) & 255U) << 8));
#line 182
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((42 * ba) * ma));
#line 182
    tmp___30 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((43 * ba) * ma));
#line 182
    tmp___31 = (*((bus___0->driver)->read_end))(bus___0);
#line 182
    cfi->device_geometry.max_bytes_write = (uint32_t )(1 << (((tmp___30 >> d) & 255U) | (((tmp___31 >> d) & 255U) << 8)));
#line 184
    tmp___33 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((44 * ba) * ma));
#line 184
    tmp___32 = (uint8_t )((tmp___33 >> d) & 255U);
#line 184
    cfi->device_geometry.number_of_erase_regions = tmp___32;
#line 184
    tmp___2 = (uint32_t )tmp___32;
#line 186
    tmp___34 = malloc((unsigned long )tmp___2 * sizeof(cfi_erase_block_region_t ));
#line 186
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___34;
    }
#line 187
    if (! cfi->device_geometry.erase_block_regions) {
      {
#line 188
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 189
      return (-2);
    }
#line 196
    i = 0;
#line 196
    a = 45;
    {
#line 196
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 196
      if (! ((uint32_t )i < tmp___2)) {
#line 196
        goto while_break___1;
      }
      {
#line 197
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((a * ba) * ma));
#line 197
      tmp___35 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )(((a + 1) * ba) * ma));
#line 197
      tmp___36 = (*((bus___0->driver)->read_end))(bus___0);
#line 197
      y = ((tmp___35 >> d) & 255U) | (((tmp___36 >> d) & 255U) << 8);
#line 198
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )(((a + 2) * ba) * ma));
#line 198
      tmp___37 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((((a + 2) + 1) * ba) * ma));
#line 198
      tmp___38 = (*((bus___0->driver)->read_end))(bus___0);
#line 198
      z = (((tmp___37 >> d) & 255U) | (((tmp___38 >> d) & 255U) << 8)) << 8;
      }
#line 199
      if (z == 0U) {
#line 200
        z = (uint32_t )128;
      }
#line 201
      (cfi->device_geometry.erase_block_regions + i)->erase_block_size = z;
#line 202
      (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = y + 1U;
#line 196
      i ++;
#line 196
      a += 4;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 209
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
    }
    {
#line 219
    if ((int )cfi->device_geometry.device_interface == 0) {
#line 219
      goto case_0;
    }
#line 224
    if ((int )cfi->device_geometry.device_interface == 1) {
#line 224
      goto case_1;
    }
#line 230
    if ((int )cfi->device_geometry.device_interface == 2) {
#line 230
      goto case_2;
    }
#line 237
    if ((int )cfi->device_geometry.device_interface == 3) {
#line 237
      goto case_3;
    }
#line 243
    if ((int )cfi->device_geometry.device_interface == 4) {
#line 243
      goto case_4;
    }
#line 252
    goto switch_default;
    case_0: /* CIL Label */ 
#line 220
    if (ma != 1) {
#line 221
      return (-7);
    }
#line 222
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 1;
#line 223
    goto switch_break;
    case_1: /* CIL Label */ 
#line 225
    if (ma != 1) {
#line 226
      return (-7);
    }
#line 227
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2;
#line 228
    d += 8U;
#line 229
    goto switch_break;
    case_2: /* CIL Label */ 
#line 231
    if (ma != 1) {
#line 231
      if (ma != 2) {
#line 232
        return (-7);
      }
    }
#line 233
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2 / ma;
#line 234
    if (ma == 1) {
#line 235
      d += 8U;
    }
#line 236
    goto switch_break;
    case_3: /* CIL Label */ 
#line 238
    if (ma != 1) {
#line 239
      return (-7);
    }
#line 240
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4;
#line 241
    d += 24U;
#line 242
    goto switch_break;
    case_4: /* CIL Label */ 
#line 244
    if (ma != 1) {
#line 244
      if (ma != 2) {
#line 245
        return (-7);
      }
    }
#line 246
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4 / ma;
#line 247
    if (ma == 1) {
#line 248
      d += 24U;
    } else {
#line 250
      d += 8U;
    }
#line 251
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 253
    return (-7);
    switch_break: /* CIL Label */ ;
    }
#line 90
    d += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (0);
}
}
#line 463 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 46 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int dbg  =    0;
#line 48
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_address_shift(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 73
  if (cfi_array___0->bus_width == 4) {
#line 73
    return (2);
  }
  {
#line 80
  if ((*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_size == 1U) {
#line 80
    goto case_1;
  }
#line 80
  if ((*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_size == 2U) {
#line 80
    goto case_1;
  }
#line 84
  if ((*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_size == 3U) {
#line 84
    goto case_3;
  }
#line 84
  if ((*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_size == 4U) {
#line 84
    goto case_3;
  }
#line 87
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  return (1);
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 85
  return (2);
  switch_default: /* CIL Label */ 
#line 87
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  if (cfi_array___0->bus_width == 2) {
#line 90
    return (1);
  }
#line 92
  return (0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 99
  if (cfi_array___0->bus_width != 4) {
#line 99
    return (0);
  }
#line 100
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_autodetect16(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 106
  if (cfi_array___0->bus_width != 2) {
#line 106
    return (0);
  }
#line 107
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 113
  if (cfi_array___0->bus_width != 1) {
#line 113
    return (0);
  }
#line 114
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amdstatus(cfi_array_t *cfi_array___0 , uint32_t adr , int data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;

  {
#line 165
  bus___0 = cfi_array___0->bus;
#line 168
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 171
  timeout = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (timeout < 7000)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 172
    data1 = tmp;
#line 173
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 173
    data2 = tmp___0;
    }
#line 177
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 178
      return (1);
    }
#line 182
    if (dbg) {
      {
#line 183
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    } else {
      {
#line 185
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 186
    usleep((__useconds_t )100);
#line 171
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (0);
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static void amd_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 266
  bus___0 = cfi_array___0->bus;
#line 267
  tmp = amd_flash_address_shift(cfi_array___0);
#line 267
  o = tmp;
#line 269
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 270
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 271
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 272
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 272
  mid = (int )(tmp___0 & 65535U);
#line 273
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 273
  cid = (int )(tmp___1 & 65535U);
#line 274
  tmp___2 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 274
  prot = (int )(tmp___2 & 255U);
#line 275
  amd_flash_read_array(cfi_array___0);
#line 276
  tmp___3 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 276
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 278
  if (mid == 1) {
#line 278
    goto case_1;
  }
#line 281
  if (mid == 32) {
#line 281
    goto case_32;
  }
#line 284
  if (mid == 44) {
#line 284
    goto case_44;
  }
#line 287
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 279
  tmp___4 = gettext("AMD");
#line 279
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 280
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 282
  tmp___5 = gettext("ST/Samsung");
#line 282
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 283
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 285
  tmp___6 = gettext("Macronix");
#line 285
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 288
  tmp___7 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 288
  printf((char const   */* __restrict  */)tmp___7, mid);
  }
#line 289
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 291
  tmp___8 = gettext("\n\tChip: ");
#line 291
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 293
  if (cid == 79) {
#line 293
    goto case_79;
  }
#line 296
  if (cid == 8919) {
#line 296
    goto case_8919;
  }
#line 299
  if (cid == 8795) {
#line 299
    goto case_8795;
  }
#line 302
  if (cid == 8777) {
#line 302
    goto case_8777;
  }
#line 305
  if (cid == 73) {
#line 305
    goto case_73;
  }
#line 308
  if (cid == 147) {
#line 308
    goto case_147;
  }
#line 311
  if (cid == 202) {
#line 311
    goto case_202;
  }
#line 314
  if (cid == 203) {
#line 314
    goto case_203;
  }
#line 317
  goto switch_default___0;
  case_79: /* CIL Label */ 
  {
#line 294
  tmp___9 = gettext("Am29LV040B");
#line 294
  printf((char const   */* __restrict  */)tmp___9);
  }
#line 295
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 297
  tmp___10 = gettext("Am29LV640D/Am29LV641D/Am29LV642D");
#line 297
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 298
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 300
  tmp___11 = gettext("Am29LV800B");
#line 300
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 301
  goto switch_break___0;
  case_8777: /* CIL Label */ 
  {
#line 303
  tmp___12 = gettext("MX29LV160B");
#line 303
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 304
  goto switch_break___0;
  case_73: /* CIL Label */ 
  {
#line 306
  tmp___13 = gettext("AM29LV160DB");
#line 306
  printf((char const   */* __restrict  */)tmp___13);
  }
#line 307
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 309
  tmp___14 = gettext("Am29LV065D");
#line 309
  printf((char const   */* __restrict  */)tmp___14);
  }
#line 310
  goto switch_break___0;
  case_202: /* CIL Label */ 
  {
#line 312
  tmp___15 = gettext("M29W320DT");
#line 312
  printf((char const   */* __restrict  */)tmp___15);
  }
#line 313
  goto switch_break___0;
  case_203: /* CIL Label */ 
  {
#line 315
  tmp___16 = gettext("M29W320DB");
#line 315
  printf((char const   */* __restrict  */)tmp___16);
  }
#line 316
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 318
  tmp___17 = gettext("Unknown (ID 0x%04x)");
#line 318
  printf((char const   */* __restrict  */)tmp___17, cid);
  }
#line 319
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 321
  tmp___18 = gettext("\n\tProtected: %04x\n");
#line 321
  printf((char const   */* __restrict  */)tmp___18, prot);
#line 324
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 325
  return;
}
}
#line 327 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 330
  bus___0 = cfi_array___0->bus;
#line 331
  tmp = amd_flash_address_shift(cfi_array___0);
#line 331
  o = tmp;
#line 333
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 337
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 338
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 339
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 340
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 341
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 342
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 344
  tmp___0 = amdstatus(cfi_array___0, adr, 65535);
  }
#line 344
  if (tmp___0) {
    {
#line 345
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 346
    amd_flash_read_array(cfi_array___0);
    }
#line 347
    return (0);
  }
  {
#line 349
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 351
  amd_flash_read_array(cfi_array___0);
  }
#line 353
  return (99);
}
}
#line 356 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 359
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 360
  return (0);
}
}
#line 363 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;

  {
  {
#line 367
  bus___0 = cfi_array___0->bus;
#line 368
  tmp = amd_flash_address_shift(cfi_array___0);
#line 368
  o = tmp;
  }
#line 370
  if (dbg) {
    {
#line 371
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 373
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 374
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 375
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 377
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 378
  status = amdstatus(cfi_array___0, adr, (int )data);
  }
#line 381
  return (! status);
}
}
#line 384 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 388
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 389
  return;
}
}
#line 391 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
flash_driver_t amd_32_flash_driver  = 
#line 391
     {4U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit",
    & amd_flash_autodetect32, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 403 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
flash_driver_t amd_16_flash_driver  = 
#line 403
     {2U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV800B; 1x16 Bit", & amd_flash_autodetect16,
    & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block, & amd_flash_program,
    & amd_flash_read_array};
#line 415 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd.c"
flash_driver_t amd_8_flash_driver  = 
#line 415
     {1U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV160, AMD 29LV065D, AMD 29LV040B; 1x8 Bit",
    & amd_flash_autodetect8, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 var_forced_detection  ;
#line 77
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) ;
#line 78
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 79
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) ;
#line 80
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) ;
#line 81
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 82
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 83
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  bus_area_t area ;
  cfi_query_structure_t *cfi ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  unsigned int bw ;
  int ba ;
  int i ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 92
  if (! cfi_array___0) {
#line 93
    return (-1);
  } else
#line 92
  if (! bus___0) {
#line 93
    return (-1);
  }
  {
#line 95
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 95
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 96
  if (! *cfi_array___0) {
#line 97
    return (-2);
  }
  {
#line 99
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 100
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 101
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 102
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 103
  tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 103
  mid = (int )tmp___0;
#line 104
  tmp___1 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 104
  did = (int )tmp___1;
#line 105
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 107
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_detect", mid,
         did);
  }
#line 108
  if (mid != 1) {
#line 109
    return (-1);
  }
  {
#line 113
  if (did == 164) {
#line 113
    goto case_164;
  }
#line 116
  if (did == 79) {
#line 116
    goto case_79;
  }
#line 120
  goto switch_default;
  case_164: /* CIL Label */ 
#line 114
  var_forced_detection.flash = 1UL;
#line 115
  goto switch_break;
  case_79: /* CIL Label */ 
#line 117
  var_forced_detection.flash = 1UL;
#line 118
  var_forced_detection.algorithm = (unsigned short)1;
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 124
  (*cfi_array___0)->bus = bus___0;
#line 125
  (*cfi_array___0)->address = (uint32_t )0;
#line 126
  tmp___2 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 126
  if (tmp___2 != 0) {
#line 127
    return (-8);
  }
#line 128
  bw = area.width;
#line 130
  if (bw != 8U) {
#line 130
    if (bw != 16U) {
#line 130
      if (bw != 32U) {
#line 131
        return (-3);
      }
    }
  }
  {
#line 132
  ba = (int )(bw / 8U);
#line 132
  (*cfi_array___0)->bus_width = ba;
#line 133
  tmp___3 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 133
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___3;
  }
#line 134
  if (! (*cfi_array___0)->cfi_chips) {
#line 135
    return (-2);
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < ba)) {
#line 136
      goto while_break;
    }
    {
#line 138
    tmp___4 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 138
    *((*cfi_array___0)->cfi_chips + i) = (cfi_chip_t *)tmp___4;
    }
#line 139
    if (! *((*cfi_array___0)->cfi_chips + i)) {
#line 140
      return (-2);
    }
    {
#line 141
    (*((*cfi_array___0)->cfi_chips + i))->width = 1;
#line 142
    cfi = & (*((*cfi_array___0)->cfi_chips + i))->cfi;
#line 144
    cfi->identification_string.pri_id_code = (uint16_t )0;
#line 145
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 146
    cfi->identification_string.alt_id_code = (uint16_t )0;
#line 147
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 149
    cfi->device_geometry.device_size = (uint32_t )524288;
#line 150
    cfi->device_geometry.device_interface = (uint16_t )0;
#line 151
    cfi->device_geometry.max_bytes_write = (uint32_t )32;
#line 152
    cfi->device_geometry.number_of_erase_regions = (uint8_t )1;
#line 153
    tmp___5 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 153
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___5;
    }
#line 155
    if (! cfi->device_geometry.erase_block_regions) {
#line 156
      return (-2);
    }
#line 158
    (cfi->device_geometry.erase_block_regions + i)->erase_block_size = (uint32_t )65536;
#line 159
    (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = (uint32_t )8;
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (0);
}
}
#line 166 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 168
  return (var_forced_detection.flash == 1UL);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 177
  dq7mask = (unsigned short )(1 << 7);
#line 178
  dq5mask = (unsigned short )(1 << 5);
#line 179
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 181
  timeout = (short)0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((int )timeout < 1000)) {
#line 181
      goto while_break;
    }
    {
#line 183
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 183
    data1 = (unsigned short )(tmp & 255U);
    }
#line 184
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 185
      return (1);
    }
#line 187
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 189
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 189
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 190
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 192
        return (1);
      } else {
#line 196
        return (0);
      }
    }
    {
#line 199
    usleep((__useconds_t )50);
#line 181
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 210
  bus___0 = cfi_array___0->bus;
#line 213
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 214
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 217
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 217
  mid = (int )tmp;
#line 218
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 218
  did = (int )tmp___0;
#line 219
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 219
  prot = (int )tmp___1;
#line 220
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 222
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 227
  if (mid == 1) {
#line 227
    goto case_1;
  }
#line 230
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 228
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 228
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 229
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 231
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 231
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___4 = gettext("\n\tChip: ");
#line 234
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 236
  if (did == 164) {
#line 236
    goto case_164;
  }
#line 240
  if (did == 79) {
#line 240
    goto case_79;
  }
#line 244
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 237
  tmp___5 = gettext("Am29C040B\t-\t");
#line 237
  printf((char const   */* __restrict  */)tmp___5);
#line 238
  tmp___6 = gettext("5V Flash\n");
#line 238
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 239
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 241
  tmp___7 = gettext("Am29LV040B\t-\t");
#line 241
  printf((char const   */* __restrict  */)tmp___7);
#line 242
  tmp___8 = gettext("3V Flash\n");
#line 242
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 243
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 245
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 245
  printf((char const   */* __restrict  */)tmp___9, did);
  }
#line 246
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 248
  tmp___10 = gettext("\n\tProtected: %04x\n");
#line 248
  printf((char const   */* __restrict  */)tmp___10, prot);
  }
#line 249
  return;
}
}
#line 251 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 254
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 256
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 257
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 258
    usleep((__useconds_t )100);
#line 259
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 261
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 262
  return;
}
}
#line 266 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 268
  bus___0 = cfi_array___0->bus;
#line 270
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 274
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 276
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 277
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 278
    usleep((__useconds_t )100);
#line 279
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 282
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 283
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 289
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 292
  tmp = amd_29xx040_status(bus___0, adr, (unsigned short)255);
  }
#line 292
  if (tmp) {
    {
#line 293
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 294
    amd_29xx040_read_array(cfi_array___0);
    }
#line 295
    return (1);
  }
  {
#line 297
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 299
  amd_29xx040_read_array(cfi_array___0);
  }
#line 301
  return (-5);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 307
  bus___0 = cfi_array___0->bus;
#line 311
  if ((int )var_forced_detection.algorithm == 1) {
#line 313
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 315
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 316
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 318
      usleep((__useconds_t )1000);
#line 319
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 324
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 325
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 329
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 330
  status = amd_29xx040_status(bus___0, adr, (unsigned short )data);
  }
#line 333
  return (! status);
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 338
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 339
  return (0);
}
}
#line 343 "/home/khheo/project/benchmark/urjtag-0.8/src/flash/amd_flash.c"
flash_driver_t amd_29xx040_flash_driver  = 
#line 343
     {1U, "AMD Standard Command Set", "supported: AMD 29LV040B, 29C040B, 1x8 Bit", & amd_29xx040_autodetect,
    & amd_29xx040_print_info, & amd_29xx040_erase_block, & amd_29xx040_unlock_block,
    & amd_29xx040_program, & amd_29xx040_read_array};
#line 40 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern long __sysconf(int  ) ;
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/lib/fclock.c"
extern int ( /* missing proto */  __builtin_isnormal)() ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/lib/fclock.c"
long double frealtime(void) 
{ 
  long double result ;
  struct timespec t ;
  int tmp ;
  int tmp___3 ;

  {
  {
#line 55
  tmp = clock_gettime(0, & t);
  }
#line 55
  if (tmp == -1) {
    {
#line 56
    perror("frealtime (clock_gettime)");
#line 57
    exit(1);
    }
  }
  {
#line 59
  result = (long double )t.tv_sec + (long double )t.tv_nsec * (long double )1e-9;
#line 69
  tmp___3 = __builtin_isnormal(result);
  }
#line 69
  if (! tmp___3) {
    {
#line 69
    __assert_fail("isnormal(result)", "/home/khheo/project/benchmark/urjtag-0.8/src/lib/fclock.c",
                  69U, "frealtime");
    }
  }
#line 70
  if (! (result > (long double )0)) {
    {
#line 70
    __assert_fail("result > 0", "/home/khheo/project/benchmark/urjtag-0.8/src/lib/fclock.c",
                  70U, "frealtime");
    }
  }
#line 71
  return (result);
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/lib/fclock.c"
long double fcputime(void) 
{ 
  struct tms t ;
  clock_t c ;
  clock_t tmp ;
  long tmp___0 ;

  {
  {
#line 79
  tmp = times(& t);
#line 79
  c = tmp;
  }
#line 80
  if (c == -1L) {
    {
#line 81
    perror("fcputime (times)");
#line 82
    exit(1);
    }
  }
  {
#line 84
  tmp___0 = __sysconf(2);
  }
#line 84
  return (((long double )t.tms_utime + (long double )t.tms_stime) / (long double )tmp___0);
}
}
#line 50 "../../include/bssignal.h"
void signal_free(signal_t *s ) ;
#line 53
void salias_free(salias_t *salias ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.8/src/part/signal.c"
signal_t *signal_alloc(char const   *name ) 
{ 
  signal_t *s ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*s));
#line 33
  s = (signal_t *)tmp;
  }
#line 34
  if (! s) {
#line 35
    return ((signal_t *)((void *)0));
  }
  {
#line 37
  s->name = strdup(name);
  }
#line 38
  if (! s->name) {
    {
#line 39
    free((void *)s);
    }
#line 40
    return ((signal_t *)((void *)0));
  }
#line 42
  s->pin = (char *)((void *)0);
#line 43
  s->next = (signal_t *)((void *)0);
#line 44
  s->input = (bsbit_t *)((void *)0);
#line 45
  s->output = (bsbit_t *)((void *)0);
#line 47
  return (s);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.8/src/part/signal.c"
void signal_free(signal_t *s ) 
{ 


  {
#line 53
  if (! s) {
#line 54
    return;
  }
  {
#line 55
  free((void *)s->name);
#line 56
  free((void *)s);
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/part/signal.c"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) 
{ 
  salias_t *sa ;
  void *tmp ;

  {
  {
#line 62
  tmp = malloc(sizeof(*sa));
#line 62
  sa = (salias_t *)tmp;
  }
#line 63
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 64
    return ((salias_t *)((void *)0));
  }
  {
#line 66
  sa->name = strdup(name);
  }
#line 67
  if ((unsigned long )sa->name == (unsigned long )((void *)0)) {
    {
#line 68
    free((void *)sa);
    }
#line 69
    return ((salias_t *)((void *)0));
  }
#line 71
  sa->next = (salias_t *)((void *)0);
#line 72
  sa->signal = (signal_t *)signal;
#line 74
  return (sa);
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.8/src/part/signal.c"
void salias_free(salias_t *salias ) 
{ 


  {
#line 79
  if ((unsigned long )salias == (unsigned long )((void *)0)) {
#line 80
    return;
  }
  {
#line 81
  free((void *)salias->name);
#line 82
  free((void *)salias);
  }
#line 83
  return;
}
}
#line 52 "../../include/bsbit.h"
void bsbit_free(bsbit_t *b ) ;
#line 36 "../../include/register.h"
tap_register *register_duplicate(tap_register const   *tr ) ;
#line 42 "../../include/data_register.h"
void data_register_free(data_register *dr___0 ) ;
#line 43 "../../include/instruction.h"
void instruction_free(instruction *i ) ;
#line 57 "../../include/part.h"
part_t *part_alloc(tap_register const   *id ) ;
#line 58
void part_free(part_t *p ) ;
#line 75
parts_t *parts_alloc(void) ;
#line 77
int parts_add_part(parts_t *ps , part_t *p ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
part_t *part_alloc(tap_register const   *id ) 
{ 
  part_t *p ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc(sizeof(*p));
#line 37
  p = (part_t *)tmp;
  }
#line 38
  if (! p) {
#line 39
    return ((part_t *)((void *)0));
  }
  {
#line 40
  p->alias = (char *)((void *)0);
#line 41
  p->id = register_duplicate(id);
#line 42
  p->manufacturer[0] = (char )'\000';
#line 43
  p->part[0] = (char )'\000';
#line 44
  p->stepping[0] = (char )'\000';
#line 45
  p->signals = (signal_t *)((void *)0);
#line 46
  p->saliases = (salias_t *)((void *)0);
#line 47
  p->instruction_length = 0;
#line 48
  p->instructions = (instruction *)((void *)0);
#line 49
  p->active_instruction = (instruction *)((void *)0);
#line 50
  p->data_registers = (data_register *)((void *)0);
#line 51
  p->boundary_length = 0;
#line 52
  p->bsbits = (bsbit_t **)((void *)0);
  }
#line 54
  return (p);
}
}
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void part_free(part_t *p ) 
{ 
  int i ;
  signal_t *s ;
  salias_t *sa ;
  instruction *i___0 ;
  data_register *dr___0 ;

  {
#line 62
  if (! p) {
#line 63
    return;
  }
  {
#line 66
  free((void *)p->id);
  }
#line 68
  if (p->alias) {
    {
#line 68
    free((void *)p->alias);
    }
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! p->signals) {
#line 71
      goto while_break;
    }
    {
#line 72
    s = p->signals;
#line 73
    p->signals = s->next;
#line 74
    signal_free(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! p->saliases) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    sa = p->saliases;
#line 80
    p->saliases = sa->next;
#line 81
    salias_free(sa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! p->instructions) {
#line 85
      goto while_break___1;
    }
    {
#line 86
    i___0 = p->instructions;
#line 87
    p->instructions = i___0->next;
#line 88
    instruction_free(i___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 92
    if (! p->data_registers) {
#line 92
      goto while_break___2;
    }
    {
#line 93
    dr___0 = p->data_registers;
#line 94
    p->data_registers = dr___0->next;
#line 95
    data_register_free(dr___0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 99
    if (! (i < p->boundary_length)) {
#line 99
      goto while_break___3;
    }
    {
#line 100
    bsbit_free(*(p->bsbits + i));
#line 99
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)p->bsbits);
#line 103
  free((void *)p);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
instruction *part_find_instruction(part_t *p , char const   *iname ) 
{ 
  instruction *i ;
  int tmp ;

  {
#line 111
  if (! p) {
#line 112
    return ((instruction *)((void *)0));
  } else
#line 111
  if (! iname) {
#line 112
    return ((instruction *)((void *)0));
  }
#line 114
  i = p->instructions;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break;
    }
    {
#line 116
    tmp = strcasecmp(iname, (char const   *)(i->name));
    }
#line 116
    if (tmp == 0) {
#line 117
      goto while_break;
    }
#line 118
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (i);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
data_register *part_find_data_register(part_t *p , char const   *drname ) 
{ 
  data_register *dr___0 ;
  int tmp ;

  {
#line 129
  if (! p) {
#line 130
    return ((data_register *)((void *)0));
  } else
#line 129
  if (! drname) {
#line 130
    return ((data_register *)((void *)0));
  }
#line 132
  dr___0 = p->data_registers;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! dr___0) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp = strcasecmp(drname, (char const   *)(dr___0->name));
    }
#line 134
    if (tmp == 0) {
#line 135
      goto while_break;
    }
#line 136
    dr___0 = dr___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (dr___0);
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
signal_t *part_find_signal(part_t *p , char const   *signalname ) 
{ 
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;

  {
#line 148
  if (! p) {
#line 149
    return ((signal_t *)((void *)0));
  } else
#line 148
  if (! signalname) {
#line 149
    return ((signal_t *)((void *)0));
  }
#line 151
  s = p->signals;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! s) {
#line 152
      goto while_break;
    }
    {
#line 153
    tmp = strcasecmp(signalname, (char const   *)s->name);
    }
#line 153
    if (tmp == 0) {
#line 154
      return (s);
    }
#line 155
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  sa = p->saliases;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! sa) {
#line 159
      goto while_break___0;
    }
    {
#line 160
    tmp___0 = strcasecmp(signalname, (char const   *)sa->name);
    }
#line 160
    if (tmp___0 == 0) {
#line 161
      return (sa->signal);
    }
#line 162
    sa = sa->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return ((signal_t *)((void *)0));
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void part_set_instruction(part_t *p , char const   *iname ) 
{ 


  {
#line 171
  if (p) {
    {
#line 172
    p->active_instruction = part_find_instruction(p, iname);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) 
{ 
  data_register *bsr ;
  char *tmp ;
  int control ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 180
  if (! p) {
#line 181
    return;
  } else
#line 180
  if (! s) {
#line 181
    return;
  }
  {
#line 184
  bsr = part_find_data_register(p, "BSR");
  }
#line 185
  if (! bsr) {
    {
#line 186
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 186
    printf((char const   */* __restrict  */)tmp, "part_set_signal", "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c",
           186);
    }
#line 187
    return;
  }
#line 191
  if (out) {
#line 193
    if (! s->output) {
      {
#line 194
      tmp___0 = gettext("signal \'%s\' cannot be set as output\n");
#line 194
      printf((char const   */* __restrict  */)tmp___0, s->name);
      }
#line 195
      return;
    }
#line 197
    *((bsr->in)->data + (s->output)->bit) = (char )(val & 1);
#line 199
    control = (*(p->bsbits + (s->output)->bit))->control;
#line 200
    if (control >= 0) {
#line 201
      *((bsr->in)->data + control) = (char )((*(p->bsbits + (s->output)->bit))->control_value ^ 1);
    }
  } else {
#line 203
    if (! s->input) {
      {
#line 204
      tmp___1 = gettext("signal \'%s\' cannot be set as input\n");
#line 204
      printf((char const   */* __restrict  */)tmp___1, s->name);
      }
#line 205
      return;
    }
#line 207
    if (s->output) {
#line 208
      *((bsr->in)->data + (s->output)->control) = (char )(*(p->bsbits + (s->output)->bit))->control_value;
    }
  }
#line 210
  return;
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
int part_get_signal(part_t *p , signal_t *s ) 
{ 
  data_register *bsr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 217
  if (! p) {
#line 218
    return (-1);
  } else
#line 217
  if (! s) {
#line 218
    return (-1);
  }
  {
#line 221
  bsr = part_find_data_register(p, "BSR");
  }
#line 222
  if (! bsr) {
    {
#line 223
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 223
    printf((char const   */* __restrict  */)tmp, "part_get_signal", "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c",
           223);
    }
#line 224
    return (-1);
  }
#line 227
  if (! s->input) {
    {
#line 228
    tmp___0 = gettext("signal \'%s\' is not input signal\n");
#line 228
    printf((char const   */* __restrict  */)tmp___0, s->name);
    }
#line 229
    return (-1);
  }
#line 232
  return ((int )*((bsr->out)->data + (s->input)->bit));
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void part_print(part_t *p ) 
{ 
  char *instruction___0 ;
  char *dr___0 ;
  char format[100] ;
  char *tmp ;

  {
#line 238
  instruction___0 = (char *)((void *)0);
#line 239
  dr___0 = (char *)((void *)0);
#line 242
  if (! p) {
#line 243
    return;
  }
  {
#line 245
  tmp = gettext("%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 245
  snprintf((char */* __restrict  */)(format), (size_t )100, (char const   */* __restrict  */)tmp,
           25, 20, 8, 20, 32);
  }
#line 248
  if (p->active_instruction) {
#line 249
    instruction___0 = (p->active_instruction)->name;
#line 250
    if ((unsigned long )(p->active_instruction)->data_register != (unsigned long )((void *)0)) {
#line 251
      dr___0 = ((p->active_instruction)->data_register)->name;
    }
  }
#line 253
  if ((unsigned long )instruction___0 == (unsigned long )((void *)0)) {
    {
#line 254
    instruction___0 = gettext("(none)");
    }
  }
#line 255
  if ((unsigned long )dr___0 == (unsigned long )((void *)0)) {
    {
#line 256
    dr___0 = gettext("(none)");
    }
  }
  {
#line 257
  printf((char const   */* __restrict  */)(format), p->manufacturer, p->part, p->stepping,
         instruction___0, dr___0);
  }
#line 258
  return;
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
parts_t *parts_alloc(void) 
{ 
  parts_t *ps ;
  void *tmp ;

  {
  {
#line 265
  tmp = malloc(sizeof(*ps));
#line 265
  ps = (parts_t *)tmp;
  }
#line 266
  if (! ps) {
#line 267
    return ((parts_t *)((void *)0));
  }
#line 269
  ps->len = 0;
#line 270
  ps->parts = (part_t **)((void *)0);
#line 272
  return (ps);
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void parts_free(parts_t *ps ) 
{ 
  int i ;

  {
#line 280
  if (! ps) {
#line 281
    return;
  }
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < ps->len)) {
#line 283
      goto while_break;
    }
    {
#line 284
    part_free(*(ps->parts + i));
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  free((void *)ps->parts);
#line 287
  free((void *)ps);
  }
#line 288
  return;
}
}
#line 290 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
int parts_add_part(parts_t *ps , part_t *p ) 
{ 
  part_t **np ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = realloc((void *)ps->parts, (unsigned long )(ps->len + 1) * sizeof(*(ps->parts)));
#line 293
  np = (part_t **)tmp;
  }
#line 295
  if (! np) {
#line 296
    return (0);
  }
#line 298
  ps->parts = np;
#line 299
  tmp___0 = ps->len;
#line 299
  (ps->len) ++;
#line 299
  *(ps->parts + tmp___0) = p;
#line 301
  return (1);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void parts_set_instruction(parts_t *ps , char const   *iname ) 
{ 
  int i ;

  {
#line 309
  if (! ps) {
#line 310
    return;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < ps->len)) {
#line 312
      goto while_break;
    }
    {
#line 313
    (*(ps->parts + i))->active_instruction = part_find_instruction(*(ps->parts + i),
                                                                   iname);
#line 312
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 316 "/home/khheo/project/benchmark/urjtag-0.8/src/part/part.c"
void parts_print(parts_t *ps ) 
{ 
  int i ;
  part_t *p ;
  char *tmp ;

  {
#line 321
  if (! ps) {
#line 322
    return;
  }
#line 324
  i = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < ps->len)) {
#line 324
      goto while_break;
    }
#line 325
    p = *(ps->parts + i);
#line 327
    if (! p) {
#line 328
      goto __Cont;
    }
    {
#line 330
    tmp = gettext(" %3d ");
#line 330
    printf((char const   */* __restrict  */)tmp, i);
#line 331
    part_print(p);
    }
    __Cont: /* CIL Label */ 
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 33 "/home/khheo/project/benchmark/urjtag-0.8/src/part/instruction.c"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) 
{ 
  instruction *i ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((instruction *)((void *)0));
  } else
#line 38
  if (! val) {
#line 39
    return ((instruction *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*i));
#line 41
  i = (instruction *)tmp;
  }
#line 42
  if (! i) {
#line 43
    return ((instruction *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 20UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Instruction name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name,
          (size_t )20);
#line 48
  i->name[20] = (char )'\000';
#line 50
  i->value = register_alloc(len);
  }
#line 51
  if (! i->value) {
    {
#line 52
    free((void *)(i->name));
#line 53
    free((void *)i);
    }
#line 54
    return ((instruction *)((void *)0));
  }
  {
#line 57
  register_init(i->value, val);
#line 58
  i->data_register = (data_register *)((void *)0);
#line 59
  i->next = (instruction *)((void *)0);
  }
#line 61
  return (i);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/part/instruction.c"
void instruction_free(instruction *i ) 
{ 


  {
#line 67
  if (! i) {
#line 68
    return;
  }
  {
#line 70
  register_free(i->value);
#line 71
  free((void *)i);
  }
#line 72
  return;
}
}
#line 33 "/home/khheo/project/benchmark/urjtag-0.8/src/part/data_register.c"
data_register *data_register_alloc(char const   *name , int len ) 
{ 
  data_register *dr___0 ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((data_register *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*dr___0));
#line 41
  dr___0 = (data_register *)tmp;
  }
#line 42
  if (! dr___0) {
#line 43
    return ((data_register *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 32UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Data register name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(dr___0->name), (char const   */* __restrict  */)name,
          (size_t )32);
#line 48
  dr___0->name[32] = (char )'\000';
  }
#line 50
  if (len > 0) {
    {
#line 52
    dr___0->in = register_alloc(len);
#line 53
    dr___0->out = register_alloc(len);
    }
  } else {
    {
#line 57
    dr___0->in = register_alloc(1);
#line 58
    dr___0->out = register_alloc(1);
    }
  }
#line 60
  if (! dr___0->in) {
    {
#line 61
    free((void *)dr___0->in);
#line 62
    free((void *)dr___0->out);
#line 63
    free((void *)(dr___0->name));
#line 64
    free((void *)dr___0);
    }
#line 65
    return ((data_register *)((void *)0));
  } else
#line 60
  if (! dr___0->out) {
    {
#line 61
    free((void *)dr___0->in);
#line 62
    free((void *)dr___0->out);
#line 63
    free((void *)(dr___0->name));
#line 64
    free((void *)dr___0);
    }
#line 65
    return ((data_register *)((void *)0));
  }
#line 68
  dr___0->next = (data_register *)((void *)0);
#line 70
  return (dr___0);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/part/data_register.c"
void data_register_free(data_register *dr___0 ) 
{ 


  {
#line 76
  if (! dr___0) {
#line 77
    return;
  }
  {
#line 79
  register_free(dr___0->in);
#line 80
  register_free(dr___0->out);
#line 81
  free((void *)dr___0);
  }
#line 82
  return;
}
}
#line 30 "/home/khheo/project/benchmark/urjtag-0.8/src/part/bsbit.c"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) 
{ 
  bsbit_t *b ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*b));
#line 33
  b = (bsbit_t *)tmp;
  }
#line 34
  if (! b) {
#line 35
    return ((bsbit_t *)((void *)0));
  }
  {
#line 37
  b->name = strdup(name);
  }
#line 38
  if (! b->name) {
    {
#line 39
    free((void *)b);
    }
#line 40
    return ((bsbit_t *)((void *)0));
  }
#line 43
  b->bit = bit;
#line 44
  b->type = type;
#line 45
  b->signal = (signal_t *)((void *)0);
#line 46
  b->safe = safe;
#line 47
  b->control = -1;
#line 49
  if ((unsigned long )signal != (unsigned long )((void *)0)) {
#line 50
    b->signal = signal;
    {
#line 52
    if (type == 1) {
#line 52
      goto case_1;
    }
#line 55
    if (type == 2) {
#line 55
      goto case_2;
    }
#line 58
    if (type == 5) {
#line 58
      goto case_5;
    }
#line 51
    goto switch_break;
    case_1: /* CIL Label */ 
#line 53
    signal->input = b;
#line 54
    goto switch_break;
    case_2: /* CIL Label */ 
#line 56
    signal->output = b;
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
#line 59
    signal->input = b;
#line 60
    signal->output = b;
#line 61
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 65
  return (b);
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/part/bsbit.c"
void bsbit_free(bsbit_t *b ) 
{ 


  {
#line 71
  if (! b) {
#line 72
    return;
  }
  {
#line 74
  free((void *)b->name);
#line 75
  free((void *)b);
  }
#line 76
  return;
}
}
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 332 "/usr/include/usb.h"
extern void usb_init(void) ;
#line 334
extern int usb_find_busses(void) ;
#line 11 "../../include/xpcu.h"
int xpcu_init(void) ;
#line 12
int xpcu_close(struct usb_dev_handle *xpcu ) ;
#line 14
int xpcu_raise_ioa5(struct usb_dev_handle *xpcu ) ;
#line 15
int xpcu_write_gpio(struct usb_dev_handle *xpcu , uint8_t bits ) ;
#line 16
int xpcu_read_gpio(struct usb_dev_handle *xpcu , uint8_t *bits ) ;
#line 18
int xpcu_select_gpio(struct usb_dev_handle *xpcu , int chain___0 ) ;
#line 19
int xpcu_open(struct usb_dev_handle **xpcu ) ;
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
parport_driver_t xpcu_pp_driver ;
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static port_node_t *ports  =    (port_node_t *)((void *)0);
#line 72 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static parport_t *xpcu_pp_alloc(char const   *vidpid ) 
{ 
  xpcu_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;
  char *f ;
  char *tmp___2 ;
  char *l ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 75
  tmp = malloc(sizeof(*params));
#line 75
  params = (xpcu_params_t *)tmp;
#line 76
  tmp___0 = malloc(sizeof(*parport));
#line 76
  parport = (parport_t *)tmp___0;
#line 77
  tmp___1 = malloc(sizeof(*node));
#line 77
  node = (port_node_t *)tmp___1;
  }
#line 79
  if (! node) {
    {
#line 80
    free((void *)node);
#line 81
    free((void *)parport);
#line 82
    free((void *)params);
    }
#line 83
    return ((parport_t *)((void *)0));
  } else
#line 79
  if (! parport) {
    {
#line 80
    free((void *)node);
#line 81
    free((void *)parport);
#line 82
    free((void *)params);
    }
#line 83
    return ((parport_t *)((void *)0));
  } else
#line 79
  if (! params) {
    {
#line 80
    free((void *)node);
#line 81
    free((void *)parport);
#line 82
    free((void *)params);
    }
#line 83
    return ((parport_t *)((void *)0));
  }
  {
#line 86
  params->product_id = 0U;
#line 87
  params->vendor_id = 0U;
#line 88
  params->serial = (char *)((void *)0);
#line 89
  params->dev = (usb_dev_handle *)((void *)0);
#line 92
  tmp___2 = strchr(vidpid, ':');
#line 92
  f = tmp___2;
#line 93
  tmp___3 = strrchr(vidpid, ':');
#line 93
  l = tmp___3;
  }
#line 94
  if (f) {
    {
#line 96
    tmp___4 = strtoul((char const   */* __restrict  */)vidpid, (char **/* __restrict  */)((void *)0),
                      16);
#line 96
    params->vendor_id = (unsigned int )tmp___4;
#line 97
    tmp___5 = strtoul((char const   */* __restrict  */)(f + 1), (char **/* __restrict  */)((void *)0),
                      16);
#line 97
    params->product_id = (unsigned int )tmp___5;
    }
#line 98
    if ((unsigned long )l != (unsigned long )f) {
      {
#line 98
      params->serial = strdup((char const   *)(l + 1));
      }
    }
  }
#line 102
  parport->params = (void *)params;
#line 103
  parport->driver = & xpcu_pp_driver;
#line 104
  parport->cable = (cable_t *)((void *)0);
#line 106
  node->port = parport;
#line 107
  node->next = ports;
#line 109
  ports = node;
#line 111
  return (parport);
}
}
#line 116 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static void xpcu_pp_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 121
  prev = & ports;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! *prev) {
#line 121
      goto while_break;
    }
#line 122
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 123
      goto while_break;
    }
#line 121
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (*prev) {
    {
#line 126
    pn = *prev;
#line 127
    *prev = pn->next;
#line 128
    free((void *)pn);
    }
  }
  {
#line 131
  free((void *)((xpcu_params_t *)port->params)->serial);
#line 132
  free(port->params);
#line 133
  free((void *)port);
  }
#line 134
  return;
}
}
#line 138 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
parport_t *xpcu_pp_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 145
  if (parnum != 1) {
    {
#line 146
    tmp = gettext("Syntax error!\n");
#line 146
    printf((char const   */* __restrict  */)tmp);
    }
#line 147
    return ((parport_t *)((void *)0));
  }
#line 150
  pn = ports;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! pn) {
#line 150
      goto while_break;
    }
    {
#line 151
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 151
    if (tmp___2 == 0) {
      {
#line 152
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 152
      tmp___1 = gettext("Disconnecting %s, device %s\n");
#line 152
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 153
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 154
      goto while_break;
    }
#line 150
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  tmp___3 = gettext("Initializing device %s\n");
#line 160
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 163
  parport = xpcu_pp_alloc(*(par + 0));
  }
#line 164
  if (! parport) {
    {
#line 165
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 165
    printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c",
           165);
    }
#line 166
    return ((parport_t *)((void *)0));
  }
#line 169
  return (parport);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_open(parport_t *parport ) 
{ 
  xpcu_params_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 177
  p = (xpcu_params_t *)parport->params;
#line 179
  usb_init();
#line 181
  tmp = usb_find_busses();
  }
#line 181
  if (tmp < 0) {
    {
#line 183
    perror("usb_find_busses failed");
    }
#line 184
    return (-1);
  }
  {
#line 187
  tmp___0 = xpcu_init();
  }
#line 187
  if (tmp___0 < 0) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t initialize XPCU\n");
    }
#line 190
    return (-1);
  }
  {
#line 193
  tmp___1 = xpcu_open(& p->dev);
  }
#line 193
  if (tmp___1 < 0) {
    {
#line 195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open XPCU\n");
    }
#line 196
    return (-1);
  }
  {
#line 199
  tmp___2 = xpcu_raise_ioa5(p->dev);
  }
#line 199
  if (tmp___2 < 0) {
#line 199
    return (-1);
  }
  {
#line 202
  tmp___3 = xpcu_select_gpio(p->dev, 0);
  }
#line 202
  if (tmp___3 < 0) {
#line 202
    return (-1);
  }
#line 204
  return (0);
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_close(parport_t *parport ) 
{ 
  xpcu_params_t *p ;

  {
  {
#line 212
  p = (xpcu_params_t *)parport->params;
#line 213
  xpcu_close(p->dev);
  }
#line 214
  return (0);
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_set_data(parport_t *parport , uint8_t data ) 
{ 
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 222
  p = (xpcu_params_t *)parport->params;
#line 224
  tmp = xpcu_write_gpio(p->dev, data);
  }
#line 224
  if (tmp < 0) {
#line 224
    return (-1);
  }
#line 225
  return (0);
}
}
#line 230 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 234
  p = (xpcu_params_t *)parport->params;
#line 236
  tmp = xpcu_read_gpio(p->dev, & d);
  }
#line 236
  if (tmp < 0) {
#line 236
    return (0);
  }
#line 237
  return ((int )d);
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_get_status(parport_t *parport ) 
{ 


  {
#line 245
  return (0);
}
}
#line 250 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_set_control(parport_t *parport , uint8_t data ) 
{ 
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 253
  p = (xpcu_params_t *)parport->params;
#line 255
  tmp = xpcu_select_gpio(p->dev, (int )data);
  }
#line 255
  if (tmp < 0) {
#line 255
    return (-1);
  }
#line 256
  return (0);
}
}
#line 261 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_pp.c"
parport_driver_t xpcu_pp_driver  = 
#line 261
     {"xpcu", & xpcu_pp_connect, & xpcu_pp_free, & xpcu_pp_open, & xpcu_pp_close, & xpcu_pp_set_data,
    & xpcu_pp_get_data, & xpcu_pp_get_status, & xpcu_pp_set_control};
#line 281 "/usr/include/usb.h"
extern struct usb_bus *usb_busses ;
#line 290
extern usb_dev_handle *usb_open(struct usb_device *dev ) ;
#line 291
extern int usb_close(usb_dev_handle *dev ) ;
#line 312
extern int usb_control_msg(usb_dev_handle *dev , int requesttype , int request , int value ,
                           int index , char *bytes , int size , int timeout ) ;
#line 315
extern int usb_claim_interface(usb_dev_handle *dev , int interface ) ;
#line 316
extern int usb_release_interface(usb_dev_handle *dev , int interface ) ;
#line 320
extern int usb_reset(usb_dev_handle *dev ) ;
#line 335
extern int usb_find_devices(void) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
struct usb_device *find_xpcu(void) 
{ 
  struct usb_device *xpcu_dev ;
  struct usb_bus *bus___0 ;
  struct usb_device *dev ;
  int tmp ;

  {
  {
#line 51
  xpcu_dev = (struct usb_device *)((void *)0);
#line 53
  tmp = usb_find_devices();
  }
#line 53
  if (tmp < 0) {
    {
#line 55
    perror("find_xpcu: usb_find_devices failed");
    }
  } else {
#line 61
    bus___0 = usb_busses;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (bus___0) {
#line 61
        if (! (! xpcu_dev)) {
#line 61
          goto while_break;
        }
      } else {
#line 61
        goto while_break;
      }
#line 65
      dev = bus___0->devices;
      {
#line 65
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 65
        if (dev) {
#line 65
          if (! (! xpcu_dev)) {
#line 65
            goto while_break___0;
          }
        } else {
#line 65
          goto while_break___0;
        }
#line 67
        if ((int )dev->descriptor.idVendor == 1021) {
#line 69
          if ((int )dev->descriptor.idProduct == 8) {
#line 71
            xpcu_dev = dev;
          } else {
            {
#line 75
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found Xilinx device with unknown PID %04X. No firmware loaded?\n",
                    (int )dev->descriptor.idProduct);
            }
          }
        }
#line 65
        dev = dev->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 61
      bus___0 = bus___0->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 84
  return (xpcu_dev);
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_init(void) 
{ 
  struct usb_device *xpcu_dev ;
  struct usb_device *tmp ;
  struct usb_dev_handle *xpcu ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = find_xpcu();
#line 91
  xpcu_dev = tmp;
  }
#line 94
  if ((unsigned long )xpcu_dev == (unsigned long )((void *)0)) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xpcu_reset: no device found\n");
    }
#line 97
    return (-1);
  }
  {
#line 100
  xpcu = usb_open(xpcu_dev);
  }
#line 101
  if ((unsigned long )xpcu == (unsigned long )((void *)0)) {
    {
#line 103
    perror("xpcu_reset: usb_open() failed");
    }
#line 104
    return (-1);
  }
  {
#line 107
  tmp___0 = usb_reset(xpcu);
  }
#line 107
  if (tmp___0 < 0) {
    {
#line 109
    perror("xpcu_reset: usb_reset() failed");
    }
#line 110
    return (-1);
  }
#line 113
  return (0);
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_close(struct usb_dev_handle *xpcu ) 
{ 


  {
  {
#line 120
  usb_release_interface(xpcu, 0);
#line 121
  usb_close(xpcu);
  }
#line 123
  return (0);
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_request_28(struct usb_dev_handle *xpcu , int value ) 
{ 
  int tmp ;

  {
  {
#line 132
  tmp = usb_control_msg(xpcu, 64, 176, 40, value, (char *)((void *)0), 0, 1000);
  }
#line 132
  if (tmp < 0) {
    {
#line 134
    perror("usb_control_msg(0x28.x)");
    }
#line 135
    return (-1);
  }
#line 138
  return (0);
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_write_gpio(struct usb_dev_handle *xpcu , uint8_t bits ) 
{ 
  int tmp ;

  {
  {
#line 145
  tmp = usb_control_msg(xpcu, 64, 176, 48, (int )bits, (char *)((void *)0), 0, 1000);
  }
#line 145
  if (tmp < 0) {
    {
#line 147
    perror("usb_control_msg(0x30.0x00) (write port E)");
    }
#line 148
    return (-1);
  }
#line 151
  return (0);
}
}
#line 156 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_read_gpio(struct usb_dev_handle *xpcu , uint8_t *bits ) 
{ 
  int tmp ;

  {
  {
#line 158
  tmp = usb_control_msg(xpcu, 192, 176, 56, 0, (char *)bits, 1, 1000);
  }
#line 158
  if (tmp < 0) {
    {
#line 160
    perror("usb_control_msg(0x38.0x00) (read port E)");
    }
#line 161
    return (-1);
  }
#line 164
  return (0);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_read_firmware_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 172
  tmp = usb_control_msg(xpcu, 192, 176, 80, 0, (char *)buf, 2, 1000);
  }
#line 172
  if (tmp < 0) {
    {
#line 174
    perror("usb_control_msg(0x50.0) (read_firmware_version)");
    }
#line 175
    return (-1);
  }
#line 177
  return (0);
}
}
#line 183 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_read_cpld_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 185
  tmp = usb_control_msg(xpcu, 192, 176, 80, 1, (char *)buf, 2, 1000);
  }
#line 185
  if (tmp < 0) {
    {
#line 187
    perror("usb_control_msg(0x50.1) (read_cpld_version)");
    }
#line 188
    return (-1);
  }
#line 190
  return (0);
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_raise_ioa5(struct usb_dev_handle *xpcu ) 
{ 
  int tmp ;

  {
  {
#line 198
  tmp = usb_control_msg(xpcu, 64, 176, 24, 0, (char *)((void *)0), 0, 1000);
  }
#line 198
  if (tmp < 0) {
    {
#line 200
    perror("usb_control_msg(0x18.0x00) (raise IOA.5");
    }
#line 201
    return (-1);
  }
#line 204
  return (0);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_select_gpio(struct usb_dev_handle *xpcu , int chain___0 ) 
{ 
  int tmp ;

  {
  {
#line 212
  tmp = usb_control_msg(xpcu, 64, 176, 82, chain___0, (char *)((void *)0), 0, 1000);
  }
#line 212
  if (tmp < 0) {
    {
#line 214
    perror("usb_control_msg(0x52.x) (select gpio)");
    }
#line 215
    return (-1);
  }
#line 218
  return (0);
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/xpcu_common.c"
int xpcu_open(struct usb_dev_handle **xpcu ) 
{ 
  uint16_t buf ;
  struct usb_device *xpcu_dev ;
  struct usb_device *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 226
  tmp = find_xpcu();
#line 226
  xpcu_dev = tmp;
  }
#line 228
  if ((unsigned long )xpcu_dev == (unsigned long )((void *)0)) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xpcu_open: no device found\n");
    }
#line 231
    return (-1);
  }
  {
#line 234
  *xpcu = usb_open(xpcu_dev);
  }
#line 235
  if ((unsigned long )*xpcu == (unsigned long )((void *)0)) {
    {
#line 237
    perror("xpcu_open: usb_open() failed");
    }
#line 238
    return (-1);
  }
  {
#line 241
  tmp___0 = usb_claim_interface(*xpcu, 0);
  }
#line 241
  if (tmp___0 != 0) {
    {
#line 243
    perror("xpcu_open: usb_claim_interface failed");
#line 244
    usb_close(*xpcu);
    }
#line 245
    return (-1);
  }
  {
#line 249
  tmp___1 = xpcu_request_28(*xpcu, 17);
  }
#line 249
  if (tmp___1 < 0) {
    {
#line 251
    usb_close(*xpcu);
    }
#line 252
    return (-1);
  }
  {
#line 255
  tmp___2 = xpcu_write_gpio(*xpcu, (uint8_t )8);
  }
#line 255
  if (tmp___2 < 0) {
    {
#line 257
    usb_close(*xpcu);
    }
#line 258
    return (-1);
  }
  {
#line 263
  tmp___3 = xpcu_read_firmware_version(*xpcu, & buf);
  }
#line 263
  if (tmp___3 < 0) {
    {
#line 265
    usb_close(*xpcu);
    }
#line 266
    return (-1);
  } else {
    {
#line 270
    printf((char const   */* __restrict  */)"firmware version = 0x%04X (%u)\n", (int )buf,
           (int )buf);
    }
  }
  {
#line 275
  tmp___4 = xpcu_read_cpld_version(*xpcu, & buf);
  }
#line 275
  if (tmp___4 < 0) {
    {
#line 277
    usb_close(*xpcu);
    }
#line 278
    return (-1);
  } else {
    {
#line 282
    printf((char const   */* __restrict  */)"cable CPLD version = 0x%04X (%u)\n",
           (int )buf, (int )buf);
    }
#line 283
    if ((int )buf == 0) {
      {
#line 285
      printf((char const   */* __restrict  */)"Warning: version \'0\' can\'t be correct. Please try resetting the cable\n");
      }
    }
  }
#line 289
  return (0);
}
}
#line 53 "../../include/parport.h"
int parport_open(parport_t *port ) ;
#line 55
int parport_set_data(parport_t *port , uint8_t data ) ;
#line 56
int parport_get_data(parport_t *port ) ;
#line 58
int parport_set_control(parport_t *port , uint8_t data ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.h"
int generic_connect(char **params , cable_t *cable ) ;
#line 40
void generic_disconnect(cable_t *cable ) ;
#line 41
void generic_cable_free(cable_t *cable ) ;
#line 42
void generic_done(cable_t *cable ) ;
#line 44
int generic_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 45
int generic_get_trst(cable_t *cable ) ;
#line 47
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 38 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
static int xpc_int_init(cable_t *cable ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 41
  tmp = parport_open(cable->port);
  }
#line 41
  if (tmp) {
#line 41
    return (-1);
  }
  {
#line 42
  tmp___0 = parport_set_control(cable->port, (uint8_t )1);
  }
#line 42
  if (tmp___0 < 0) {
#line 42
    return (-1);
  }
#line 44
  ((generic_params_t *)cable->params)->trst = 1;
#line 46
  return (0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
static int xpc_ext_init(cable_t *cable ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 52
  tmp = parport_open(cable->port);
  }
#line 52
  if (tmp) {
#line 52
    return (-1);
  }
  {
#line 53
  tmp___0 = parport_set_control(cable->port, (uint8_t )0);
  }
#line 53
  if (tmp___0 < 0) {
#line 53
    return (-1);
  }
#line 55
  ((generic_params_t *)cable->params)->trst = 1;
#line 57
  return (0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
static void xpc_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 72
  if (tms) {
#line 72
    tms = 1;
  } else {
#line 72
    tms = 0;
  }
#line 73
  if (tdi) {
#line 73
    tdi = 1;
  } else {
#line 73
    tdi = 0;
  }
  {
#line 75
  parport_set_data(cable->port, (uint8_t )(((1 << 3) | (tms << 1)) | tdi));
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < n)) {
#line 76
      goto while_break;
    }
    {
#line 77
    parport_set_data(cable->port, (uint8_t )((((1 << 3) | (1 << 2)) | (tms << 1)) | tdi));
#line 78
    parport_set_data(cable->port, (uint8_t )(((1 << 3) | (tms << 1)) | tdi));
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
static int xpc_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 85
  tmp = parport_get_data(cable->port);
  }
#line 85
  return (tmp & 1);
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
static int xpc_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 91
  return (1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
void xpc_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 


  {
#line 97
  cable->frequency = new_frequency;
#line 98
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
void xpcu_usbcable_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 104
  tmp = gettext("Usage: cable %s xpcu VID:PID\n\nVID        vendor ID (hex, e.g. 9FB, or empty)\nPID        product ID (hex, e.g. 6001, or empty)\n\n");
#line 104
  printf((char const   */* __restrict  */)tmp, cablename);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
cable_driver_t xpc_int_cable_driver  = 
#line 113
     {"xpc_int", "Xilinx Platform Cable USB internal chain", & generic_connect, & generic_disconnect,
    & generic_cable_free, & xpc_int_init, & generic_done, & xpc_set_frequency, & xpc_clock,
    & xpc_get_tdo, & generic_transfer, & xpc_set_trst, & generic_get_trst, & generic_flush_using_transfer,
    & xpcu_usbcable_help};
#line 131 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/xpc.c"
cable_driver_t xpc_ext_cable_driver  = 
#line 131
     {"xpc_ext", "Xilinx Platform Cable USB external chain", & generic_connect, & generic_disconnect,
    & generic_cable_free, & xpc_ext_init, & generic_done, & xpc_set_frequency, & xpc_clock,
    & xpc_get_tdo, & generic_transfer, & xpc_set_trst, & generic_get_trst, & generic_flush_using_transfer,
    & xpcu_usbcable_help};
#line 57 "../../include/parport.h"
int parport_get_status(parport_t *port ) ;
#line 140 "../../include/cable.h"
void cable_wait(cable_t *cable ) ;
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.h"
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 46
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static char const   *std_wgl_map  =    "7,4,3,2,1,#0";
#line 109 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int map_pin(char *pin , int *act , int *inact ) 
{ 
  int bitnum ;
  int inverted ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 113
  inverted = 0;
#line 115
  if ((int )*pin == 35) {
#line 116
    inverted = 1;
#line 117
    pin ++;
  }
  {
#line 120
  tmp = __ctype_b_loc();
  }
#line 120
  if (! ((int const   )*(*tmp + (int )*pin) & 2048)) {
#line 121
    return (-1);
  }
  {
#line 123
  tmp___0 = atoi((char const   *)pin);
#line 123
  bitnum = tmp___0 % 8;
#line 125
  bitnum = 1 << bitnum;
  }
#line 127
  if (inverted) {
#line 127
    *act = 0;
  } else {
#line 127
    *act = bitnum;
  }
#line 128
  if (inverted) {
#line 128
    *inact = bitnum;
  } else {
#line 128
    *inact = 0;
  }
#line 130
  return (0);
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int set_mapping(char *bitmap , cable_t *cable ) 
{ 
  char delim ;
  int syntax ;
  char *tdo ;
  char *trst ;
  char *tdi ;
  char *tck ;
  char *tms ;
  char *srst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 137
  delim = (char )',';
#line 138
  syntax = 0;
#line 142
  tdo = bitmap;
#line 142
  if (tdo) {
    {
#line 143
    trst = strchr((char const   *)tdo, (int )delim);
    }
#line 143
    if (trst) {
      {
#line 144
      trst ++;
#line 145
      tdi = strchr((char const   *)trst, (int )delim);
      }
#line 145
      if (tdi) {
        {
#line 146
        tdi ++;
#line 147
        tck = strchr((char const   *)tdi, (int )delim);
        }
#line 147
        if (tck) {
          {
#line 148
          tck ++;
#line 149
          tms = strchr((char const   *)tck, (int )delim);
          }
#line 149
          if (tms) {
            {
#line 150
            tms ++;
#line 151
            srst = strchr((char const   *)tms, (int )delim);
            }
#line 151
            if (srst) {
#line 152
              srst ++;
#line 153
              syntax = 1;
            }
          }
        }
      }
    }
  }
#line 156
  if (! syntax) {
#line 157
    return (-1);
  }
  {
#line 159
  tmp = map_pin(tdo, & ((wiggler_params_t *)cable->params)->tdo_act, & ((wiggler_params_t *)cable->params)->tdo_inact);
  }
#line 159
  if (tmp != 0) {
#line 159
    return (-1);
  }
  {
#line 160
  tmp___0 = map_pin(trst, & ((wiggler_params_t *)cable->params)->trst_act, & ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 160
  if (tmp___0 != 0) {
#line 160
    return (-1);
  }
  {
#line 161
  tmp___1 = map_pin(tdi, & ((wiggler_params_t *)cable->params)->tdi_act, & ((wiggler_params_t *)cable->params)->tdi_inact);
  }
#line 161
  if (tmp___1 != 0) {
#line 161
    return (-1);
  }
  {
#line 162
  tmp___2 = map_pin(tck, & ((wiggler_params_t *)cable->params)->tck_act, & ((wiggler_params_t *)cable->params)->tck_inact);
  }
#line 162
  if (tmp___2 != 0) {
#line 162
    return (-1);
  }
  {
#line 163
  tmp___3 = map_pin(tms, & ((wiggler_params_t *)cable->params)->tms_act, & ((wiggler_params_t *)cable->params)->tms_inact);
  }
#line 163
  if (tmp___3 != 0) {
#line 163
    return (-1);
  }
  {
#line 164
  tmp___4 = map_pin(srst, & ((wiggler_params_t *)cable->params)->srst_act, & ((wiggler_params_t *)cable->params)->srst_inact);
  }
#line 164
  if (tmp___4 != 0) {
#line 164
    return (-1);
  }
#line 166
  return (0);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int wiggler_connect(char **params , cable_t *cable ) 
{ 
  int result ;
  char *param_bitmap ;
  wiggler_params_t *wiggler_params ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 174
  param_bitmap = (char *)((void *)0);
#line 177
  tmp = cmd_params(params);
  }
#line 177
  if (tmp == 4) {
#line 179
    param_bitmap = *(params + 3);
#line 181
    *(params + 3) = (char *)((void *)0);
  }
  {
#line 184
  result = generic_connect(params, cable);
  }
#line 184
  if (result != 0) {
#line 185
    return (result);
  }
#line 187
  if (param_bitmap) {
#line 188
    *(params + 3) = param_bitmap;
  }
  {
#line 190
  tmp___0 = malloc(sizeof(*wiggler_params));
#line 190
  wiggler_params = (wiggler_params_t *)tmp___0;
  }
#line 190
  if ((unsigned long )wiggler_params == (unsigned long )((void *)0)) {
#line 191
    return (4);
  }
  {
#line 194
  free(cable->params);
#line 195
  cable->params = (void *)wiggler_params;
  }
#line 198
  if (! param_bitmap) {
#line 199
    param_bitmap = (char *)std_wgl_map;
  }
  {
#line 201
  result = set_mapping(param_bitmap, cable);
  }
#line 201
  if (result != 0) {
#line 202
    return (result);
  }
#line 207
  ((wiggler_params_t *)cable->params)->unused_bits = ~ (((((((((((wiggler_params_t *)cable->params)->srst_act | ((wiggler_params_t *)cable->params)->srst_inact) | ((wiggler_params_t *)cable->params)->tms_act) | ((wiggler_params_t *)cable->params)->tms_inact) | ((wiggler_params_t *)cable->params)->tck_act) | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->tdi_act) | ((wiggler_params_t *)cable->params)->tdi_inact) | ((wiggler_params_t *)cable->params)->trst_act) | ((wiggler_params_t *)cable->params)->trst_inact) & 255;
#line 213
  return (0);
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int wiggler_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = parport_open(cable->port);
  }
#line 221
  if (tmp) {
#line 222
    return (-1);
  }
  {
#line 224
  data = parport_get_data(cable->port);
  }
#line 224
  if (data < 0) {
    {
#line 225
    tmp___0 = parport_set_data(cable->port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
    }
#line 225
    if (tmp___0) {
#line 226
      return (-1);
    }
#line 227
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact;
  } else {
#line 229
    ((wiggler_params_t *)cable->params)->trst_lvl = data & (((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 231
  return (0);
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static void wiggler_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 239
  if (tms) {
#line 239
    tms = 1;
  } else {
#line 239
    tms = 0;
  }
#line 240
  if (tdi) {
#line 240
    tdi = 1;
  } else {
#line 240
    tdi = 0;
  }
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < n)) {
#line 242
      goto while_break;
    }
#line 243
    if (tms) {
#line 243
      tmp = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 243
      tmp = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 243
    if (tdi) {
#line 243
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 243
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 243
    parport_set_data(cable->port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | tmp) | tmp___0) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 248
    cable_wait(cable);
    }
#line 249
    if (tms) {
#line 249
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 249
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 249
    if (tdi) {
#line 249
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 249
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 249
    parport_set_data(cable->port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_act) | tmp___1) | tmp___2) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 254
    cable_wait(cable);
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 258 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int wiggler_get_tdo(cable_t *cable ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 261
  parport_set_data(cable->port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 264
  cable_wait(cable);
#line 265
  tmp___1 = parport_get_status(cable->port);
  }
#line 265
  if ((tmp___1 & (((wiggler_params_t *)cable->params)->tdo_act | ((wiggler_params_t *)cable->params)->tdo_inact)) ^ ((wiggler_params_t *)cable->params)->tdo_act) {
#line 265
    tmp___0 = 0;
  } else {
#line 265
    tmp___0 = 1;
  }
#line 265
  return (tmp___0);
}
}
#line 269 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int wiggler_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
#line 272
  if (trst) {
#line 272
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act;
  } else {
#line 272
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_inact;
  }
  {
#line 274
  parport_set_data(cable->port, (uint8_t )(((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->unused_bits));
  }
#line 276
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 276
    tmp = 0;
  } else {
#line 276
    tmp = 1;
  }
#line 276
  return (tmp);
}
}
#line 279 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static int wiggler_get_trst(cable_t *cable ) 
{ 
  int tmp ;

  {
#line 282
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 282
    tmp = 0;
  } else {
#line 282
    tmp = 1;
  }
#line 282
  return (tmp);
}
}
#line 285 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
static void wiggler_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 288
  tmp = gettext("Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEF      ppdev device (e.g. /dev/parport0)\nTDO, ...   parallel port bit number, prepend \'#\' for inversion\n           default is \'%s\'\n\n");
#line 288
  printf((char const   */* __restrict  */)tmp, cablename, cablename, std_wgl_map);
  }
#line 317
  return;
}
}
#line 319 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
cable_driver_t wiggler_cable_driver  = 
#line 319
     {"WIGGLER", "Macraigor Wiggler JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_cable_free, & wiggler_init, & generic_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_trst, & wiggler_get_trst,
    & generic_flush_one_by_one, & wiggler_help};
#line 337 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler.c"
cable_driver_t igloo_cable_driver  = 
#line 337
     {"IGLOO", "Excelpoint IGLOO JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_cable_free, & wiggler_init, & generic_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_trst, & wiggler_get_trst,
    & generic_flush_one_by_one, & wiggler_help};
#line 48 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.h"
void generic_lptcable_help(char const   *cablename ) ;
#line 67 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler2.c"
static int wiggler2_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 72
  tmp = parport_open(cable->port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
  {
#line 75
  data = parport_get_data(cable->port);
  }
#line 75
  if (data < 0) {
    {
#line 76
    tmp___0 = parport_set_data(cable->port, (uint8_t )(~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255));
    }
#line 76
    if (tmp___0) {
#line 77
      return (-1);
    }
#line 78
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 80
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 82
  return (0);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler2.c"
static void wiggler2_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 90
  if (tms) {
#line 90
    tms = 1;
  } else {
#line 90
    tms = 0;
  }
#line 91
  if (tdi) {
#line 91
    tdi = 1;
  } else {
#line 91
    tdi = 0;
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < n)) {
#line 93
      goto while_break;
    }
    {
#line 94
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 95
    cable_wait(cable);
#line 96
    parport_set_data(cable->port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 97
    cable_wait(cable);
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 104
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 105
  cable_wait(cable);
#line 106
  tmp = parport_get_status(cable->port);
  }
#line 106
  return ((tmp >> 7) & 1);
}
}
#line 109 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler2.c"
static int wiggler2_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 112
  if (trst) {
#line 112
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 112
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 114
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
  }
#line 115
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/wiggler2.c"
cable_driver_t wiggler2_cable_driver  = 
#line 118
     {"WIGGLER2", "Modified (with CPU Reset) WIGGLER JTAG Cable", & generic_connect,
    & generic_disconnect, & generic_cable_free, & wiggler2_init, & generic_done, & generic_set_frequency,
    & wiggler2_clock, & wiggler2_get_tdo, & generic_transfer, & wiggler2_set_trst,
    & generic_get_trst, & generic_flush_one_by_one, & generic_lptcable_help};
#line 68 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/triton.c"
static int triton_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 71
  tmp = parport_open(cable->port);
  }
#line 71
  if (tmp) {
#line 72
    return (-1);
  }
#line 74
  ((generic_params_t *)cable->params)->trst = 1;
#line 75
  ((generic_params_t *)cable->params)->sreset = 1;
#line 77
  return (0);
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/triton.c"
static void triton_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 85
  if (tms) {
#line 85
    tms = 1;
  } else {
#line 85
    tms = 0;
  }
#line 86
  if (tdi) {
#line 86
    tdi = 1;
  } else {
#line 86
    tdi = 0;
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < n)) {
#line 88
      goto while_break;
    }
    {
#line 89
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 90
    cable_wait(cable);
#line 91
    parport_set_data(cable->port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 92
    cable_wait(cable);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/triton.c"
static int triton_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 99
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
#line 100
  cable_wait(cable);
#line 101
  tmp = parport_get_status(cable->port);
  }
#line 101
  return ((tmp >> 7) & 1);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/triton.c"
static int triton_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 107
  if (trst) {
#line 107
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 107
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 109
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
  }
#line 110
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/triton.c"
cable_driver_t triton_cable_driver  = 
#line 113
     {"TRITON", "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable", & generic_connect,
    & generic_disconnect, & generic_cable_free, & triton_init, & generic_done, & generic_set_frequency,
    & triton_clock, & triton_get_tdo, & generic_transfer, & triton_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_lptcable_help};
#line 127 "../../include/cable.h"
int cable_get_tdo_late(cable_t *cable ) ;
#line 128
int cable_defer_get_tdo(cable_t *cable ) ;
#line 135
int cable_transfer_late(cable_t *cable , char *out ) ;
#line 136
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 49 "../../include/chain.h"
void chain_defer_clock(chain_t *chain___0 , int tms , int tdi , int n ) ;
#line 32 "../../include/tap.h"
void tap_capture_dr(chain_t *chain___0 ) ;
#line 33
void tap_capture_ir(chain_t *chain___0 ) ;
#line 34
void tap_defer_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                              int exit___0 ) ;
#line 35
void tap_shift_register_output(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                               int exit___0 ) ;
#line 36
void tap_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                        int exit___0 ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_reset(chain_t *chain___0 ) 
{ 


  {
  {
#line 37
  tap_state_reset(chain___0);
#line 39
  chain_defer_clock(chain___0, 1, 0, 5);
#line 40
  chain_defer_clock(chain___0, 0, 0, 1);
#line 42
  parts_set_instruction(chain___0->parts, "BYPASS");
  }
#line 43
  return;
}
}
#line 45 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_defer_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                              int exit___0 ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 50
  tmp___1 = tap_state(chain___0);
  }
#line 50
  if (! (tmp___1 & (1 << 2))) {
    {
#line 51
    tmp = tap_state(chain___0);
#line 51
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 51
    printf((char const   */* __restrict  */)tmp___0, "tap_shift_register", tmp);
    }
  }
  {
#line 54
  tmp___2 = tap_state(chain___0);
  }
#line 54
  if (tmp___2 & (1 << 4)) {
    {
#line 55
    chain_defer_clock(chain___0, 0, 0, 1);
    }
  }
#line 57
  i = (int )in->len;
#line 58
  if (exit___0) {
#line 58
    i --;
  }
#line 59
  if (out) {
#line 59
    if (out->len < i) {
#line 59
      i = out->len;
    }
  }
#line 61
  if (out) {
    {
#line 62
    cable_defer_transfer(chain___0->cable, i, (char *)in->data, out->data);
    }
  } else {
    {
#line 64
    cable_defer_transfer(chain___0->cable, i, (char *)in->data, (char *)((void *)0));
    }
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < (int )in->len)) {
#line 66
      goto while_break;
    }
#line 67
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 67
      if (i < out->len) {
        {
#line 68
        tmp___3 = cable_defer_get_tdo(chain___0->cable);
#line 68
        *(out->data + i) = (char )tmp___3;
        }
      }
    }
#line 69
    if (exit___0 != 0) {
#line 69
      if (i + 1 == (int )in->len) {
#line 69
        tmp___4 = 1;
      } else {
#line 69
        tmp___4 = 0;
      }
    } else {
#line 69
      tmp___4 = 0;
    }
    {
#line 69
    chain_defer_clock(chain___0, tmp___4, (int )*(in->data + i), 1);
#line 66
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (exit___0 == 1) {
    {
#line 74
    chain_defer_clock(chain___0, 1, 0, 1);
#line 75
    chain_defer_clock(chain___0, 0, 0, 1);
    }
  }
#line 77
  return;
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_shift_register_output(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                               int exit___0 ) 
{ 
  int j ;
  int tmp ;

  {
#line 82
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 86
    j = (int )in->len;
#line 87
    if (exit___0) {
#line 87
      j --;
    }
#line 88
    if (out) {
#line 88
      if (out->len < j) {
#line 88
        j = out->len;
      }
    }
    {
#line 93
    cable_transfer_late(chain___0->cable, out->data);
    }
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      if (j < (int )in->len) {
#line 94
        if (! (j < out->len)) {
#line 94
          goto while_break;
        }
      } else {
#line 94
        goto while_break;
      }
      {
#line 95
      tmp = cable_get_tdo_late(chain___0->cable);
#line 95
      *(out->data + j) = (char )tmp;
#line 94
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                        int exit___0 ) 
{ 


  {
  {
#line 102
  tap_defer_shift_register(chain___0, in, out, exit___0);
#line 103
  tap_shift_register_output(chain___0, in, out, exit___0);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_capture_dr(chain_t *chain___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 109
  tmp___1 = tap_state(chain___0);
  }
#line 109
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 110
    tmp = tap_state(chain___0);
#line 110
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 110
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_dr", tmp);
    }
  }
  {
#line 113
  chain_defer_clock(chain___0, 1, 0, 1);
#line 114
  chain_defer_clock(chain___0, 0, 0, 1);
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/tap.c"
void tap_capture_ir(chain_t *chain___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 120
  tmp___1 = tap_state(chain___0);
  }
#line 120
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 121
    tmp = tap_state(chain___0);
#line 121
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 121
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_ir", tmp);
    }
  }
  {
#line 124
  chain_defer_clock(chain___0, 1, 0, 2);
#line 125
  chain_defer_clock(chain___0, 0, 0, 1);
  }
#line 126
  return;
}
}
#line 60 "../../include/state.h"
int tap_state_init(chain_t *chain___0 ) ;
#line 61
int tap_state_done(chain_t *chain___0 ) ;
#line 63
int tap_state_set_trst(chain_t *chain___0 , int old_trst , int new_trst ) ;
#line 64
int tap_state_clock(chain_t *chain___0 , int tms ) ;
#line 29 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state(chain_t *chain___0 ) 
{ 


  {
#line 32
  return (chain___0->state);
}
}
#line 35 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state_init(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 38
  tmp = 1 << 7;
#line 38
  chain___0->state = tmp;
#line 38
  return (tmp);
}
}
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state_done(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 44
  tmp = 1 << 7;
#line 44
  chain___0->state = tmp;
#line 44
  return (tmp);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state_reset(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 50
  tmp = (1 << 7) | (1 << 3);
#line 50
  chain___0->state = tmp;
#line 50
  return (tmp);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state_set_trst(chain_t *chain___0 , int old_trst , int new_trst ) 
{ 


  {
#line 56
  if (old_trst) {
#line 56
    old_trst = 1;
  } else {
#line 56
    old_trst = 0;
  }
#line 57
  if (new_trst) {
#line 57
    new_trst = 1;
  } else {
#line 57
    new_trst = 0;
  }
#line 59
  if (old_trst != new_trst) {
#line 60
    if (new_trst) {
#line 61
      chain___0->state = (1 << 7) | (1 << 3);
    } else {
#line 63
      chain___0->state = 1 << 7;
    }
  }
#line 66
  return (chain___0->state);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/state.c"
int tap_state_clock(chain_t *chain___0 , int tms ) 
{ 


  {
#line 72
  if (tms) {
    {
#line 74
    if (chain___0->state == ((1 << 7) | (1 << 3))) {
#line 74
      goto case_exp;
    }
#line 78
    if (chain___0->state == ((1 << 1) | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain___0->state == (1 | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain___0->state == 1 << 3) {
#line 78
      goto case_exp___0;
    }
#line 81
    if (chain___0->state == 1) {
#line 81
      goto case_1;
    }
#line 85
    if (chain___0->state == (1 | (1 << 2))) {
#line 85
      goto case_exp___3;
    }
#line 85
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 85
      goto case_exp___3;
    }
#line 89
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 89
      goto case_exp___5;
    }
#line 89
    if (chain___0->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 89
      goto case_exp___5;
    }
#line 92
    if (chain___0->state == (1 | (1 << 6))) {
#line 92
      goto case_exp___7;
    }
#line 95
    if (chain___0->state == 1 << 1) {
#line 95
      goto case_exp___8;
    }
#line 99
    if (chain___0->state == ((1 << 1) | (1 << 2))) {
#line 99
      goto case_exp___9;
    }
#line 99
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 99
      goto case_exp___9;
    }
#line 103
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 103
      goto case_exp___11;
    }
#line 103
    if (chain___0->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 103
      goto case_exp___11;
    }
#line 106
    if (chain___0->state == ((1 << 1) | (1 << 6))) {
#line 106
      goto case_exp___13;
    }
#line 109
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 75
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
#line 79
    chain___0->state = 1;
#line 80
    goto switch_break;
    case_1: /* CIL Label */ 
#line 82
    chain___0->state = 1 << 1;
#line 83
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
#line 86
    chain___0->state = (1 | (1 << 5)) | (1 << 6);
#line 87
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
#line 90
    chain___0->state = 1 | (1 << 3);
#line 91
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 93
    chain___0->state = (1 | (1 << 2)) | (1 << 5);
#line 94
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 96
    chain___0->state = (1 << 7) | (1 << 3);
#line 97
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
#line 100
    chain___0->state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 101
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    case_exp___12: /* CIL Label */ 
#line 104
    chain___0->state = (1 << 1) | (1 << 3);
#line 105
    goto switch_break;
    case_exp___13: /* CIL Label */ 
#line 107
    chain___0->state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 110
    chain___0->state = 1 << 7;
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 118
    if (chain___0->state == ((1 << 1) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == (1 | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == 1 << 3) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == ((1 << 7) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 121
    if (chain___0->state == 1) {
#line 121
      goto case_1___0;
    }
#line 126
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain___0->state == (1 | (1 << 2))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 126
      goto case_exp___18;
    }
#line 130
    if (chain___0->state == (1 | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 130
    if (chain___0->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 133
    if (chain___0->state == 1 << 1) {
#line 133
      goto case_exp___23;
    }
#line 138
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain___0->state == ((1 << 1) | (1 << 2))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 138
      goto case_exp___24;
    }
#line 142
    if (chain___0->state == ((1 << 1) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 142
    if (chain___0->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 145
    goto switch_default___0;
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
#line 119
    chain___0->state = 1 << 3;
#line 120
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 122
    chain___0->state = (1 | (1 << 2)) | (1 << 4);
#line 123
    goto switch_break___0;
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    case_exp___20: /* CIL Label */ 
#line 127
    chain___0->state = 1 | (1 << 2);
#line 128
    goto switch_break___0;
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
#line 131
    chain___0->state = 1 | (1 << 6);
#line 132
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
#line 134
    chain___0->state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 135
    goto switch_break___0;
    case_exp___24: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
#line 139
    chain___0->state = (1 << 1) | (1 << 2);
#line 140
    goto switch_break___0;
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
#line 143
    chain___0->state = (1 << 1) | (1 << 6);
#line 144
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 146
    chain___0->state = 1 << 7;
#line 147
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 151
  return (chain___0->state);
}
}
#line 40 "../../include/register.h"
int register_all_bits_same_value(tap_register const   *tr ) ;
#line 42
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) ;
#line 43
int register_match(tap_register const   *tr , char const   *expr ) ;
#line 44
tap_register *register_inc(tap_register *tr ) ;
#line 45
tap_register *register_dec(tap_register *tr ) ;
#line 46
tap_register *register_shift_right(tap_register *tr , int shift ) ;
#line 47
tap_register *register_shift_left(tap_register *tr , int shift ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_alloc(int len ) 
{ 
  tap_register *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 35
  if (len < 1) {
#line 36
    return ((tap_register *)((void *)0));
  }
  {
#line 38
  tmp = malloc(sizeof(tap_register ));
#line 38
  tr = (tap_register *)tmp;
  }
#line 39
  if (! tr) {
#line 40
    return ((tap_register *)((void *)0));
  }
  {
#line 42
  tmp___0 = malloc((size_t )len);
#line 42
  tr->data = (char *)tmp___0;
  }
#line 43
  if (! tr->data) {
    {
#line 44
    free((void *)tr);
    }
#line 45
    return ((tap_register *)((void *)0));
  }
  {
#line 48
  memset((void *)tr->data, 0, (size_t )len);
#line 50
  tmp___1 = malloc((size_t )(len + 1));
#line 50
  tr->string = (char *)tmp___1;
  }
#line 51
  if (! tr->string) {
    {
#line 52
    free((void *)tr->data);
#line 53
    free((void *)tr);
    }
#line 54
    return ((tap_register *)((void *)0));
  }
#line 57
  tr->len = len;
#line 58
  *(tr->string + len) = (char )'\000';
#line 60
  return (tr);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_duplicate(tap_register const   *tr ) 
{ 
  char const   *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;

  {
#line 66
  if (! tr) {
#line 67
    return ((tap_register *)((void *)0));
  }
  {
#line 69
  tmp = register_get_string(tr);
#line 69
  tmp___0 = register_alloc((int )tr->len);
#line 69
  tmp___1 = register_init(tmp___0, tmp);
  }
#line 69
  return (tmp___1);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
void register_free(tap_register *tr ) 
{ 


  {
#line 75
  if (tr) {
    {
#line 76
    free((void *)tr->data);
#line 77
    free((void *)tr->string);
    }
  }
  {
#line 79
  free((void *)tr);
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_fill(tap_register *tr , int val ) 
{ 


  {
#line 85
  if (tr) {
    {
#line 86
    memset((void *)tr->data, val & 1, (size_t )tr->len);
    }
  }
#line 88
  return (tr);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
char const   *register_get_string(tap_register const   *tr ) 
{ 
  int i ;

  {
#line 96
  if (! tr) {
#line 97
    return ((char const   *)((void *)0));
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < (int )tr->len)) {
#line 99
      goto while_break;
    }
#line 100
    if ((int )*(tr->data + i) & 1) {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'1';
    } else {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'0';
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((char const   *)tr->string);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
int register_all_bits_same_value(tap_register const   *tr ) 
{ 
  int i ;
  int value ;

  {
#line 109
  if (! tr) {
#line 109
    return (-1);
  }
#line 110
  if (tr->len < 0) {
#line 110
    return (-1);
  }
#line 115
  value = (int )*(tr->data + 0) & 1;
#line 117
  i = 1;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < (int )tr->len)) {
#line 117
      goto while_break;
    }
#line 119
    if (((int )*(tr->data + i) & 1) != value) {
#line 119
      return (-1);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (value);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_init(tap_register *tr , char const   *value ) 
{ 
  int i ;
  char const   *p ;
  char *tmp ;

  {
#line 131
  if (! value) {
#line 132
    return (tr);
  } else
#line 131
  if (! tr) {
#line 132
    return (tr);
  }
  {
#line 134
  tmp = strchr(value, '\000');
#line 134
  p = (char const   *)tmp;
#line 136
  i = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < tr->len)) {
#line 136
      goto while_break;
    }
#line 137
    if ((unsigned long )p == (unsigned long )value) {
#line 138
      *(tr->data + i) = (char)0;
    } else {
#line 140
      p --;
#line 141
      if ((int const   )*p == 48) {
#line 141
        *(tr->data + i) = (char)0;
      } else {
#line 141
        *(tr->data + i) = (char)1;
      }
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (tr);
}
}
#line 148 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) 
{ 
  int i ;

  {
#line 153
  if (! tr) {
#line 153
    if (! tr2) {
#line 154
      return (0);
    }
  }
#line 156
  if (! tr) {
#line 157
    return (1);
  } else
#line 156
  if (! tr2) {
#line 157
    return (1);
  }
#line 159
  if (tr->len != tr2->len) {
#line 160
    return (1);
  }
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < (int )tr->len)) {
#line 162
      goto while_break;
    }
#line 163
    if ((int )*(tr->data + i) != (int )*(tr2->data + i)) {
#line 164
      return (1);
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (0);
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
int register_match(tap_register const   *tr , char const   *expr ) 
{ 
  int i ;
  char const   *s ;
  size_t tmp ;

  {
#line 175
  if (! tr) {
#line 176
    return (0);
  } else
#line 175
  if (! expr) {
#line 176
    return (0);
  } else {
    {
#line 175
    tmp = strlen(expr);
    }
#line 175
    if ((size_t )tr->len != tmp) {
#line 176
      return (0);
    }
  }
  {
#line 178
  s = register_get_string(tr);
#line 180
  i = 0;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < (int )tr->len)) {
#line 180
      goto while_break;
    }
#line 181
    if ((int const   )*(expr + i) != 63) {
#line 181
      if ((int const   )*(expr + i) != (int const   )*(s + i)) {
#line 182
        return (0);
      }
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (1);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_inc(tap_register *tr ) 
{ 
  int i ;

  {
#line 192
  if (! tr) {
#line 193
    return ((tap_register *)((void *)0));
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < tr->len)) {
#line 195
      goto while_break;
    }
#line 196
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 198
    if ((int )*(tr->data + i) == 1) {
#line 199
      goto while_break;
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (tr);
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_dec(tap_register *tr ) 
{ 
  int i ;

  {
#line 210
  if (! tr) {
#line 211
    return ((tap_register *)((void *)0));
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < tr->len)) {
#line 213
      goto while_break;
    }
#line 214
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 216
    if ((int )*(tr->data + i) == 0) {
#line 217
      goto while_break;
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (tr);
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_shift_right(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 228
  if (! tr) {
#line 229
    return ((tap_register *)((void *)0));
  }
#line 231
  if (shift < 1) {
#line 232
    return (tr);
  }
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < tr->len)) {
#line 234
      goto while_break;
    }
#line 235
    if (i + shift < tr->len) {
#line 236
      *(tr->data + i) = *(tr->data + (i + shift));
    } else {
#line 238
      *(tr->data + i) = (char)0;
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return (tr);
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/register.c"
tap_register *register_shift_left(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 249
  if (! tr) {
#line 250
    return ((tap_register *)((void *)0));
  }
#line 252
  if (shift < 1) {
#line 253
    return (tr);
  }
#line 255
  i = tr->len - 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i >= 0)) {
#line 255
      goto while_break;
    }
#line 256
    if (i - shift >= 0) {
#line 257
      *(tr->data + i) = *(tr->data + (i - shift));
    } else {
#line 259
      *(tr->data + i) = (char)0;
    }
#line 255
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (tr);
}
}
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 67 "/usr/include/stropts.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 45 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static port_node_t *ports___0  =    (port_node_t *)((void *)0);
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc(sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc(sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc(sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports___0;
#line 87
  ports___0 = node;
#line 89
  return (parport);
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static void ppdev_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports___0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
parport_t *ppdev_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 118
  if (parnum != 1) {
    {
#line 119
    tmp = gettext("Syntax error!\n");
#line 119
    printf((char const   */* __restrict  */)tmp);
    }
#line 120
    return ((parport_t *)((void *)0));
  }
#line 123
  pn = ports___0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! pn) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 124
    if (tmp___2 == 0) {
      {
#line 125
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 125
      tmp___1 = gettext("Disconnecting %s from ppdev port %s\n");
#line 125
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 126
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 127
      goto while_break;
    }
#line 123
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp___3 = gettext("Initializing ppdev port %s\n");
#line 130
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 132
  parport = ppdev_parport_alloc(*(par + 0));
  }
#line 133
  if (! parport) {
    {
#line 134
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c",
           134);
    }
#line 135
    return ((parport_t *)((void *)0));
  }
#line 138
  return (parport);
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_open(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_close(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_set_data(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_get_status(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
static int ppdev_set_control(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver  = 
#line 226
     {"ppdev", & ppdev_connect, & ppdev_parport_free, & ppdev_open, & ppdev_close, & ppdev_set_data,
    & ppdev_get_data, & ppdev_get_status, & ppdev_set_control};
#line 54 "../../include/parport.h"
int parport_close(parport_t *port ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
parport_driver_t direct_parport_driver ;
#line 50 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
parport_driver_t *parport_drivers[4]  = {      & direct_parport_driver,      & ppdev_parport_driver,      & xpcu_pp_driver,      (parport_driver_t *)((void *)0)};
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_open(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 78
  tmp = (*((port->driver)->open))(port);
  }
#line 78
  return (tmp);
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_close(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = (*((port->driver)->close))(port);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_set_data(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = (*((port->driver)->set_data))(port, data);
  }
#line 90
  return (tmp);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_get_data(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 96
  tmp = (*((port->driver)->get_data))(port);
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_get_status(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = (*((port->driver)->get_status))(port);
  }
#line 102
  return (tmp);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport.c"
int parport_set_control(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 108
  tmp = (*((port->driver)->set_control))(port, data);
  }
#line 108
  return (tmp);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/mpcbdm.c"
static int mpcbdm_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = parport_open(cable->port);
  }
#line 66
  if (tmp) {
#line 67
    return (-1);
  }
  {
#line 69
  parport_set_control(cable->port, (uint8_t )0);
#line 70
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 72
  return (0);
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 80
  if (tms) {
#line 80
    tms = 1;
  } else {
#line 80
    tms = 0;
  }
#line 81
  if (tdi) {
#line 81
    tdi = 1;
  } else {
#line 81
    tdi = 0;
  }
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < n)) {
#line 83
      goto while_break;
    }
    {
#line 84
    parport_set_data(cable->port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 85
    cable_wait(cable);
#line 86
    parport_set_data(cable->port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 87
    cable_wait(cable);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 94
  parport_set_data(cable->port, (uint8_t )0);
#line 95
  cable_wait(cable);
#line 96
  tmp = parport_get_status(cable->port);
  }
#line 96
  return ((tmp >> 5) & 1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 102
  if (trst) {
#line 102
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 102
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 104
  parport_set_control(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst ^ 1));
  }
#line 105
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/mpcbdm.c"
cable_driver_t mpcbdm_cable_driver  = 
#line 108
     {"MPCBDM", "Mpcbdm JTAG cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & mpcbdm_init, & generic_done, & generic_set_frequency, & mpcbdm_clock, & mpcbdm_get_tdo,
    & generic_transfer, & mpcbdm_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/lattice.c"
static int lattice_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
#line 59
  ((generic_params_t *)cable->params)->trst = 1;
#line 61
  return (0);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/lattice.c"
static void lattice_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 69
  if (tms) {
#line 69
    tms = 1;
  } else {
#line 69
    tms = 0;
  }
#line 70
  if (tdi) {
#line 70
    tdi = 1;
  } else {
#line 70
    tdi = 0;
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < n)) {
#line 72
      goto while_break;
    }
    {
#line 73
    parport_set_data(cable->port, (uint8_t )(((tms << 2) | tdi) | (1 << 4)));
#line 74
    cable_wait(cable);
#line 75
    parport_set_data(cable->port, (uint8_t )((((1 << 1) | (tms << 2)) | tdi) | (1 << 4)));
#line 76
    cable_wait(cable);
#line 72
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/lattice.c"
static int lattice_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 83
  parport_set_data(cable->port, (uint8_t )(1 << 4));
#line 84
  cable_wait(cable);
#line 85
  tmp = parport_get_status(cable->port);
  }
#line 85
  return ((tmp >> 6) & 1);
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/lattice.c"
static int lattice_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 91
  tmp = parport_set_data(cable->port, (uint8_t )(trst << 4));
  }
#line 91
  return (tmp);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/lattice.c"
cable_driver_t lattice_cable_driver  = 
#line 94
     {"Lattice", "Lattice Parallel Port JTAG Cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & lattice_init, & generic_done, & generic_set_frequency,
    & lattice_clock, & lattice_get_tdo, & generic_transfer, & lattice_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_lptcable_help};
#line 66 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/keithkoep.c"
static int keithkoep_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 75
  return (0);
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/keithkoep.c"
static void keithkoep_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait(cable);
#line 89
    parport_set_data(cable->port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait(cable);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 97
  parport_set_data(cable->port, (uint8_t )0);
#line 98
  cable_wait(cable);
#line 99
  tmp = parport_get_status(cable->port);
  }
#line 99
  return ((tmp >> 5) & 1);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/keithkoep.c"
static int keithkoep_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 105
  if (trst) {
#line 105
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 105
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 107
  parport_set_control(cable->port, (uint8_t )((generic_params_t *)cable->params)->trst);
  }
#line 108
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/keithkoep.c"
cable_driver_t keithkoep_cable_driver  = 
#line 111
     {"KeithKoep", "Keith & Koep JTAG cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & keithkoep_init, & generic_done, & generic_set_frequency,
    & keithkoep_clock, & keithkoep_get_tdo, & generic_transfer, & keithkoep_set_trst,
    & generic_get_trst, & generic_flush_one_by_one, & generic_lptcable_help};
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 329 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fmax)(double __x ,
                                                                              double __y )  __attribute__((__const__)) ;
#line 122 "../../include/cable.h"
void cable_done(cable_t *cable ) ;
#line 141
void cable_purge_queue(cable_queue_info_t *q , int io ) ;
#line 142
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 143
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
int generic_connect(char **params , cable_t *cable ) 
{ 
  generic_params_t *cable_params ;
  void *tmp ;
  parport_t *port ;
  int i ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 56
  tmp = malloc(sizeof(*cable_params));
#line 56
  cable_params = (generic_params_t *)tmp;
#line 60
  tmp___1 = cmd_params(params);
  }
#line 60
  if (tmp___1 < 3) {
    {
#line 61
    tmp___0 = gettext("not enough arguments!\n");
#line 61
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 62
    return (1);
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! parport_drivers[i]) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp___2 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 67
    if (tmp___2 == 0) {
#line 68
      goto while_break;
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (! parport_drivers[i]) {
    {
#line 70
    tmp___3 = gettext("Unknown port driver: %s\n");
#line 70
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 71
    return (2);
  }
  {
#line 75
  tmp___4 = cmd_params(params);
#line 75
  port = (*((parport_drivers[i])->connect))((char const   **)(params + 2), tmp___4 - 2);
  }
#line 78
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 79
    tmp___5 = gettext("Error: Cable connection failed!\n");
#line 79
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 80
    return (3);
  }
#line 83
  if (! cable_params) {
    {
#line 84
    free((void *)cable_params);
#line 85
    free((void *)cable);
    }
#line 86
    return (4);
  }
#line 89
  cable->port = port;
#line 90
  cable->params = (void *)cable_params;
#line 91
  cable->chain = (chain_t *)((void *)0);
#line 93
  return (0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_disconnect(cable_t *cable ) 
{ 


  {
  {
#line 99
  cable_done(cable);
#line 100
  chain_disconnect(cable->chain);
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_cable_free(cable_t *cable ) 
{ 


  {
  {
#line 106
  (*(((cable->port)->driver)->parport_free))(cable->port);
#line 107
  free(cable->params);
#line 108
  free((void *)cable);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_done(cable_t *cable ) 
{ 


  {
  {
#line 114
  parport_close(cable->port);
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
int generic_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int tmp ;

  {
#line 122
  if (out) {
#line 123
    i = 0;
    {
#line 123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 123
      if (! (i < len)) {
#line 123
        goto while_break;
      }
      {
#line 124
      tmp = (*((cable->driver)->get_tdo))(cable);
#line 124
      *(out + i) = (char )tmp;
#line 125
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 123
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 128
    i = 0;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! (i < len)) {
#line 128
        goto while_break___0;
      }
      {
#line 129
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 128
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 132
  return (i);
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
int generic_get_trst(cable_t *cable ) 
{ 


  {
#line 138
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
int do_one_queued_action(cable_t *cable ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  int r ;
  int tmp___0 ;

  {
  {
#line 150
  i = cable_get_queue_item(cable, & cable->todo);
  }
#line 150
  if (i >= 0) {
#line 154
    if (cable->done.num_items >= cable->done.max_items) {
#line 156
      if ((unsigned int )(cable->todo.data + i)->action == 1U) {
        {
#line 160
        tmp = gettext("No space in cable activity results queue.\n");
#line 160
        printf((char const   */* __restrict  */)tmp);
#line 161
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 156
      if ((unsigned int )(cable->todo.data + i)->action == 4U) {
        {
#line 160
        tmp = gettext("No space in cable activity results queue.\n");
#line 160
        printf((char const   */* __restrict  */)tmp);
#line 161
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 156
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
        {
#line 160
        tmp = gettext("No space in cable activity results queue.\n");
#line 160
        printf((char const   */* __restrict  */)tmp);
#line 161
        cable_purge_queue(& cable->done, 1);
        }
      }
    }
    {
#line 167
    if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 167
      goto case_0;
    }
#line 173
    if ((unsigned int )(cable->todo.data + i)->action == 3U) {
#line 173
      goto case_3;
    }
#line 177
    if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 177
      goto case_2;
    }
#line 198
    if ((unsigned int )(cable->todo.data + i)->action == 1U) {
#line 198
      goto case_1;
    }
#line 207
    if ((unsigned int )(cable->todo.data + i)->action == 4U) {
#line 207
      goto case_4;
    }
#line 165
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 168
    (*((cable->driver)->clock))(cable, (cable->todo.data + i)->arg.clock.tms, (cable->todo.data + i)->arg.clock.tdi,
                                (cable->todo.data + i)->arg.clock.n);
    }
#line 172
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 174
    cable_set_trst(cable, (cable->todo.data + i)->arg.value.trst);
    }
#line 176
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 179
    tmp___0 = (*((cable->driver)->transfer))(cable, (cable->todo.data + i)->arg.transfer.len,
                                             (cable->todo.data + i)->arg.transfer.in,
                                             (cable->todo.data + i)->arg.transfer.out);
#line 179
    r = tmp___0;
#line 184
    free((void *)(cable->todo.data + i)->arg.transfer.in);
    }
#line 185
    if ((unsigned long )(cable->todo.data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
      {
#line 187
      j = cable_add_queue_item(cable, & cable->done);
#line 191
      (cable->done.data + j)->action = (enum __anonenum_action_990402164 )2;
#line 192
      (cable->done.data + j)->arg.xferred.len = (cable->todo.data + i)->arg.transfer.len;
#line 193
      (cable->done.data + j)->arg.xferred.res = r;
#line 194
      (cable->done.data + j)->arg.xferred.out = (cable->todo.data + i)->arg.transfer.out;
      }
    }
#line 196
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 199
    j = cable_add_queue_item(cable, & cable->done);
#line 203
    (cable->done.data + j)->action = (enum __anonenum_action_990402164 )1;
#line 204
    (cable->done.data + j)->arg.value.tdo = (*((cable->driver)->get_tdo))(cable);
    }
#line 206
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 208
    j = cable_add_queue_item(cable, & cable->done);
#line 212
    (cable->done.data + j)->action = (enum __anonenum_action_990402164 )4;
#line 213
    (cable->done.data + j)->arg.value.trst = (*((cable->driver)->get_trst))(cable);
    }
#line 215
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 221
    return (1);
  }
#line 227
  return (0);
}
}
#line 230 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int tmp ;

  {
#line 233
  if ((unsigned int )how_much == 0U) {
#line 233
    return;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 235
    tmp = do_one_queued_action(cable);
    }
#line 235
    if (! tmp) {
#line 235
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int i ;
  int j ;
  int n ;
  char *in ;
  char *out ;
  int r ;
  int bits ;
  int tdo ;
  int k ;
  int k___0 ;
  void *tmp ;
  void *tmp___0 ;
  int k___1 ;
  int tmp___1 ;
  int len ;
  int k___2 ;
  int tmp___2 ;
  int c ;
  int tmp___3 ;
  char *p ;
  int len___0 ;
  int c___0 ;
  int tmp___4 ;

  {
#line 244
  if ((unsigned int )how_much == 0U) {
#line 244
    return;
  }
#line 246
  if (cable->todo.num_items == 0) {
#line 246
    return;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    bits = 0;
#line 250
    tdo = 0;
#line 260
    i = cable->todo.next_item;
#line 260
    n = 0;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! (n < cable->todo.num_items)) {
#line 260
        goto while_break___0;
      }
#line 262
      if ((unsigned int )(cable->todo.data + i)->action != 0U) {
#line 262
        if ((unsigned int )(cable->todo.data + i)->action != 2U) {
#line 262
          if ((unsigned int )(cable->todo.data + i)->action != 1U) {
#line 269
            goto while_break___0;
          }
        }
      }
#line 271
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 271
        if ((cable->todo.data + i)->arg.clock.tms != 0) {
#line 277
          goto while_break___0;
        }
      }
#line 279
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 281
        k = (cable->todo.data + i)->arg.clock.n;
#line 285
        bits += k;
      } else
#line 287
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 289
        k___0 = (cable->todo.data + i)->arg.transfer.len;
#line 293
        bits += k___0;
      }
#line 295
      i ++;
#line 296
      if (i >= cable->todo.max_items) {
#line 296
        i = 0;
      }
#line 260
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    if (bits == 0) {
      {
#line 305
      do_one_queued_action(cable);
      }
    } else
#line 303
    if (n <= 1) {
      {
#line 305
      do_one_queued_action(cable);
      }
    } else {
      {
#line 311
      tmp = malloc((size_t )bits);
#line 311
      in = (char *)tmp;
#line 312
      tmp___0 = malloc((size_t )bits);
#line 312
      out = (char *)tmp___0;
      }
#line 314
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 314
        goto _L;
      } else
#line 314
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 316
        if ((unsigned long )in != (unsigned long )((void *)0)) {
          {
#line 316
          free((void *)in);
          }
        }
#line 317
        if ((unsigned long )out != (unsigned long )((void *)0)) {
          {
#line 317
          free((void *)out);
          }
        }
        {
#line 318
        generic_flush_one_by_one(cable, how_much);
        }
#line 319
        goto while_break;
      }
#line 322
      j = 0;
#line 322
      bits = 0;
#line 322
      i = cable->todo.next_item;
      {
#line 322
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 322
        if (! (j < n)) {
#line 322
          goto while_break___1;
        }
#line 324
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 327
          k___1 = 0;
          {
#line 327
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 327
            if (! (k___1 < (cable->todo.data + i)->arg.clock.n)) {
#line 327
              goto while_break___2;
            }
#line 328
            tmp___1 = bits;
#line 328
            bits ++;
#line 328
            *(in + tmp___1) = (char )(cable->todo.data + i)->arg.clock.tdi;
#line 327
            k___1 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else
#line 330
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 332
          len = (cable->todo.data + i)->arg.transfer.len;
#line 333
          if (len > 0) {
            {
#line 335
            memcpy((void */* __restrict  */)(in + bits), (void const   */* __restrict  */)(cable->todo.data + i)->arg.transfer.in,
                   (size_t )len);
#line 336
            bits += len;
            }
          }
        }
#line 339
        i ++;
#line 340
        if (i >= cable->todo.max_items) {
#line 340
          i = 0;
        }
#line 322
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 345
      r = (*((cable->driver)->transfer))(cable, bits, in, out);
#line 353
      j = 0;
#line 353
      bits = 0;
#line 353
      i = cable->todo.next_item;
      }
      {
#line 353
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 353
        if (! (j < n)) {
#line 353
          goto while_break___3;
        }
#line 355
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 358
          k___2 = 0;
          {
#line 358
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 358
            if (! (k___2 < (cable->todo.data + i)->arg.clock.n)) {
#line 358
              goto while_break___4;
            }
#line 359
            tmp___2 = bits;
#line 359
            bits ++;
#line 359
            tdo = (int )*(out + tmp___2);
#line 358
            k___2 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else
#line 361
        if ((unsigned int )(cable->todo.data + i)->action == 1U) {
          {
#line 363
          tmp___3 = cable_add_queue_item(cable, & cable->done);
#line 363
          c = tmp___3;
#line 367
          (cable->done.data + c)->action = (enum __anonenum_action_990402164 )1;
#line 368
          (cable->done.data + c)->arg.value.tdo = tdo;
          }
        } else
#line 370
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
          {
#line 372
          p = (cable->todo.data + i)->arg.transfer.out;
#line 373
          len___0 = (cable->todo.data + i)->arg.transfer.len;
#line 374
          free((void *)(cable->todo.data + i)->arg.transfer.in);
          }
#line 375
          if ((unsigned long )p != (unsigned long )((void *)0)) {
            {
#line 377
            tmp___4 = cable_add_queue_item(cable, & cable->done);
#line 377
            c___0 = tmp___4;
#line 381
            (cable->done.data + c___0)->action = (enum __anonenum_action_990402164 )2;
#line 382
            (cable->done.data + c___0)->arg.xferred.len = len___0;
#line 383
            (cable->done.data + c___0)->arg.xferred.res = r;
#line 384
            (cable->done.data + c___0)->arg.xferred.out = p;
            }
#line 385
            if (len___0 > 0) {
              {
#line 385
              memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(out + bits),
                     (size_t )len___0);
              }
            }
          }
#line 387
          if (len___0 > 0) {
#line 387
            bits += len___0;
          }
#line 388
          if (bits > 0) {
#line 388
            tdo = (int )*(out + (bits - 1));
          }
        }
#line 390
        i ++;
#line 391
        if (i >= cable->todo.max_items) {
#line 391
          i = 0;
        }
#line 353
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 394
      cable->todo.next_item = i;
#line 395
      cable->todo.num_items -= n;
#line 397
      free((void *)in);
#line 398
      free((void *)out);
      }
    }
#line 248
    if (! (cable->todo.num_items > 0)) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return;
}
}
#line 404 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 
  double tolerance ;
  uint32_t loops ;
  uint32_t delay ;
  uint32_t frequency ;
  uint32_t i ;
  uint32_t new_delay ;
  long double start ;
  long double end ;
  long double real_frequency ;
  double tmp___0 ;

  {
#line 407
  if (new_frequency == 0U) {
#line 408
    cable->delay = (uint32_t )0;
#line 409
    cable->frequency = (uint32_t )0;
  } else {
    {
#line 411
    tolerance = 0.1;
#line 413
    delay = cable->delay;
#line 414
    frequency = cable->frequency;
#line 416
    printf((char const   */* __restrict  */)"requested frequency %u, now calibrating delay loop\n",
           new_frequency);
    }
#line 418
    if (delay == 0U) {
#line 419
      delay = (uint32_t )1000;
#line 420
      loops = (uint32_t )10000;
    } else {
#line 422
      loops = 3U * frequency;
    }
    {
#line 425
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 429
      start = frealtime();
#line 430
      i = (uint32_t )0;
      }
      {
#line 430
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 430
        if (! (i < loops)) {
#line 430
          goto while_break___0;
        }
        {
#line 431
        (*((cable->driver)->clock))(cable, 0, 0, 1);
#line 430
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 433
      end = frealtime();
      }
#line 435
      if (! (end > start)) {
        {
#line 435
        __assert_fail("end > start", "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c",
                      435U, "generic_set_frequency");
        }
      }
      {
#line 436
      real_frequency = (long double )loops / (end - start);
#line 437
      printf((char const   */* __restrict  */)"new real frequency %Lg, delay %u\n",
             real_frequency, delay);
#line 440
      tmp___0 = fmax((double )real_frequency, (double )new_frequency);
#line 440
      loops = (uint32_t )((double )3 * tmp___0);
#line 441
      new_delay = (uint32_t )(((long double )delay * real_frequency) / (long double )new_frequency);
      }
#line 443
      if (real_frequency >= (long double )((1.0 - tolerance) * (double )new_frequency)) {
#line 444
        if (real_frequency <= (long double )((1.0 + tolerance) * (double )new_frequency)) {
#line 445
          goto while_break;
        }
#line 447
        if (new_delay > delay) {
#line 448
          delay = new_delay;
        } else {
#line 450
          delay ++;
        }
      } else {
#line 453
        if (new_delay < delay) {
#line 454
          delay = new_delay;
        } else {
#line 456
          delay --;
        }
#line 458
        if (delay == 0U) {
          {
#line 459
          printf((char const   */* __restrict  */)"operating without delay\n");
          }
#line 460
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 465
    printf((char const   */* __restrict  */)"done\n");
#line 467
    cable->delay = delay;
#line 468
    cable->frequency = frequency;
    }
  }
#line 470
  return;
}
}
#line 472 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/generic.c"
void generic_lptcable_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 475
  tmp = gettext("Usage: cable %s parallel PORTADDR\n   or: cable %s ppdev PPDEV\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEF      ppdev device (e.g. /dev/parport0)\n\n");
#line 475
  printf((char const   */* __restrict  */)tmp, cablename, cablename);
  }
#line 501
  return;
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ei012.c"
static int ei012_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 58
  tmp = parport_open(cable->port);
  }
#line 58
  if (tmp) {
#line 59
    return (-1);
  }
  {
#line 61
  data = parport_get_data(cable->port);
  }
#line 61
  if (data < 0) {
    {
#line 62
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 4));
    }
#line 62
    if (tmp___0) {
#line 63
      return (-1);
    }
#line 64
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 66
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 68
  return (0);
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ei012.c"
static void ei012_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait(cable);
#line 82
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait(cable);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ei012.c"
static int ei012_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 90
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 91
  cable_wait(cable);
#line 92
  tmp = parport_get_status(cable->port);
  }
#line 92
  return ((tmp >> 7) & 1);
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ei012.c"
static int ei012_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 98
  if (trst) {
#line 98
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 98
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 100
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 101
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ei012.c"
cable_driver_t ei012_cable_driver  = 
#line 104
     {"EI012", "ETC EI012 JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & ei012_init, & generic_done, & generic_set_frequency, & ei012_clock, & ei012_get_tdo,
    & generic_transfer, & ei012_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 51 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ea253.c"
static int ea253_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
  {
#line 59
  data = parport_get_data(cable->port);
  }
#line 59
  if (data < 0) {
    {
#line 60
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 4));
    }
#line 60
    if (tmp___0) {
#line 61
      return (-1);
    }
#line 62
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 64
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ea253.c"
static void ea253_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | tdi));
#line 79
    cable_wait(cable);
#line 80
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 81
    cable_wait(cable);
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ea253.c"
static int ea253_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 89
  cable_wait(cable);
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 4) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ea253.c"
static int ea253_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  if (trst) {
#line 96
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 96
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 98
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 99
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/ea253.c"
cable_driver_t ea253_cable_driver  = 
#line 102
     {"EA253", "ETC EA253 JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & ea253_init, & generic_done, & generic_set_frequency, & ea253_clock, & ea253_get_tdo,
    & generic_transfer, & ea253_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 58 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/dlc5.c"
static int dlc5_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = parport_open(cable->port);
  }
#line 61
  if (tmp) {
#line 62
    return (-1);
  }
#line 64
  ((generic_params_t *)cable->params)->trst = 1;
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/dlc5.c"
static void dlc5_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 79
    cable_wait(cable);
#line 80
    parport_set_data(cable->port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 81
    cable_wait(cable);
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/dlc5.c"
static int dlc5_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(1 << 4));
#line 89
  cable_wait(cable);
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 4) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/dlc5.c"
static int dlc5_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/dlc5.c"
cable_driver_t dlc5_cable_driver  = 
#line 99
     {"DLC5", "Xilinx DLC5 JTAG Parallel Cable III", & generic_connect, & generic_disconnect,
    & generic_cable_free, & dlc5_init, & generic_done, & generic_set_frequency, & dlc5_clock,
    & dlc5_get_tdo, & generic_transfer, & dlc5_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 837
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioperm)(unsigned long __from ,
                                                                             unsigned long __num ,
                                                                             int __turn_on ) ;
#line 38
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static port_node_t *ports___1  =    (port_node_t *)((void *)0);
#line 111 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 114
  tmp = malloc(sizeof(*params));
#line 114
  params = (direct_params_t *)tmp;
#line 115
  tmp___0 = malloc(sizeof(*parport));
#line 115
  parport = (parport_t *)tmp___0;
#line 116
  tmp___1 = malloc(sizeof(*node));
#line 116
  node = (port_node_t *)tmp___1;
  }
#line 118
  if (! node) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! parport) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! params) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  }
#line 125
  params->port = port;
#line 127
  parport->params = (void *)params;
#line 128
  parport->driver = & direct_parport_driver;
#line 129
  parport->cable = (cable_t *)((void *)0);
#line 131
  node->port = parport;
#line 132
  node->next = ports___1;
#line 134
  ports___1 = node;
#line 136
  return (parport);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static void direct_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 144
  prev = & ports___1;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! *prev) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 146
      goto while_break;
    }
#line 144
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (*prev) {
    {
#line 149
    pn = *prev;
#line 150
    *prev = pn->next;
#line 151
    free((void *)pn);
    }
  }
  {
#line 154
  free(port->params);
#line 155
  free((void *)port);
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
parport_t *direct_connect(char const   **par , int parnum ) 
{ 
  long port_scan_val ;
  unsigned int port ;
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int aport ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 163
  pn = ports___1;
#line 166
  if (parnum != 1) {
    {
#line 167
    tmp = gettext("Syntax error!\n");
#line 167
    printf((char const   */* __restrict  */)tmp);
    }
#line 168
    return ((parport_t *)((void *)0));
  }
  {
#line 171
  port_scan_val = strtol((char const   */* __restrict  */)*(par + 0), (char **/* __restrict  */)((void *)0),
                         0);
  }
#line 173
  if (port_scan_val < 0L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  } else
#line 173
  if (port_scan_val + 3L > 65535L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  }
#line 178
  port = (unsigned int )port_scan_val;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! pn) {
#line 180
      goto while_break;
    }
#line 181
    pn = ports___1;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! pn) {
#line 181
        goto while_break___0;
      }
      {
#line 184
      aport = ((direct_params_t *)(pn->port)->params)->port;
#line 185
      tmp___3 = abs((int )(aport - port));
      }
#line 185
      if (tmp___3 < 3) {
        {
#line 186
        tmp___1 = gettext((((pn->port)->cable)->driver)->description);
#line 186
        tmp___2 = gettext("Disconnecting %s from parallel port at 0x%x\n");
#line 186
        printf((char const   */* __restrict  */)tmp___2, tmp___1, aport);
#line 187
        (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
        }
#line 188
        goto while_break___0;
      }
#line 181
      pn = pn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___4 = gettext("Initializing parallel port at 0x%x\n");
#line 192
  printf((char const   */* __restrict  */)tmp___4, port);
#line 194
  parport = direct_parport_alloc(port);
  }
#line 195
  if (! parport) {
    {
#line 196
    tmp___5 = gettext("%s(%d) Out of memory.\n");
#line 196
    printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c",
           196);
    }
#line 197
    return ((parport_t *)((void *)0));
  }
#line 200
  return (parport);
}
}
#line 203 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_open(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  port = ((direct_params_t *)parport->params)->port;
#line 207
  if (port + 3U <= 1024U) {
    {
#line 207
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 207
    if (tmp) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 207
  if (port + 3U > 1024U) {
    {
#line 207
    tmp___0 = iopl(3);
    }
#line 207
    if (tmp___0) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      tmp___1 = 0;
    }
  } else {
#line 207
    tmp___1 = 0;
  }
#line 207
  return (tmp___1);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_close(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 213
  port = ((direct_params_t *)parport->params)->port;
#line 214
  if (port + 3U <= 1024U) {
    {
#line 214
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 214
    tmp___1 = tmp;
    }
  } else {
    {
#line 214
    tmp___0 = iopl(0);
#line 214
    tmp___1 = tmp___0;
    }
  }
#line 214
  return (tmp___1);
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_set_data(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 220
  port = ((direct_params_t *)parport->params)->port;
#line 221
  outb(data, (unsigned short )port);
  }
#line 222
  return (0);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_get_data(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 228
  port = ((direct_params_t *)parport->params)->port;
#line 229
  tmp = inb((unsigned short )port);
  }
#line 229
  return ((int )tmp);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_get_status(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 235
  port = ((direct_params_t *)parport->params)->port;
#line 236
  tmp = inb((unsigned short )(port + 1U));
  }
#line 236
  return ((int )tmp ^ 128);
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
static int direct_set_control(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 242
  port = ((direct_params_t *)parport->params)->port;
#line 243
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 244
  return (0);
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/parport/direct.c"
parport_driver_t direct_parport_driver  = 
#line 247
     {"parallel", & direct_connect, & direct_parport_free, & direct_open, & direct_close,
    & direct_set_data, & direct_get_data, & direct_get_status, & direct_set_control};
#line 120 "../../include/cable.h"
void cable_free(cable_t *cable ) ;
#line 123
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 124
void cable_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 125
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 131
int cable_get_trst(cable_t *cable ) ;
#line 45 "../../include/chain.h"
chain_t *chain_alloc(void) ;
#line 46
void chain_free(chain_t *chain___0 ) ;
#line 51
int chain_get_trst(chain_t *chain___0 ) ;
#line 56
void chain_flush(chain_t *chain___0 ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
chain_t *chain_alloc(void) 
{ 
  chain_t *chain___0 ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc(sizeof(chain_t ));
#line 37
  chain___0 = (chain_t *)tmp;
  }
#line 38
  if (! chain___0) {
#line 39
    return ((chain_t *)((void *)0));
  }
  {
#line 41
  chain___0->cable = (cable_t *)((void *)0);
#line 42
  chain___0->parts = (parts_t *)((void *)0);
#line 43
  chain___0->active_part = 0;
#line 44
  tap_state_init(chain___0);
  }
#line 46
  return (chain___0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_free(chain_t *chain___0 ) 
{ 


  {
#line 52
  if (! chain___0) {
#line 53
    return;
  }
  {
#line 55
  chain_disconnect(chain___0);
#line 57
  parts_free(chain___0->parts);
#line 58
  free((void *)chain___0);
  }
#line 59
  return;
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_disconnect(chain_t *chain___0 ) 
{ 


  {
#line 64
  if (! chain___0->cable) {
#line 65
    return;
  }
  {
#line 67
  tap_state_done(chain___0);
#line 68
  cable_done(chain___0->cable);
#line 69
  cable_free(chain___0->cable);
#line 70
  chain___0->cable = (cable_t *)((void *)0);
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_clock(chain_t *chain___0 , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 78
  if (! chain___0) {
#line 79
    return;
  } else
#line 78
  if (! chain___0->cable) {
#line 79
    return;
  }
  {
#line 81
  cable_clock(chain___0->cable, tms, tdi, n);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < n)) {
#line 83
      goto while_break;
    }
    {
#line 84
    tap_state_clock(chain___0, tms);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_defer_clock(chain_t *chain___0 , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 92
  if (! chain___0) {
#line 93
    return;
  } else
#line 92
  if (! chain___0->cable) {
#line 93
    return;
  }
  {
#line 95
  cable_defer_clock(chain___0->cable, tms, tdi, n);
#line 97
  i = 0;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < n)) {
#line 97
      goto while_break;
    }
    {
#line 98
    tap_state_clock(chain___0, tms);
#line 97
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
int chain_set_trst(chain_t *chain___0 , int trst ) 
{ 
  int old_trst ;
  int tmp ;

  {
  {
#line 104
  tmp = cable_get_trst(chain___0->cable);
#line 104
  old_trst = tmp;
#line 105
  trst = cable_set_trst(chain___0->cable, trst);
#line 106
  tap_state_set_trst(chain___0, old_trst, trst);
  }
#line 107
  return (trst);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
int chain_get_trst(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
  {
#line 113
  tmp = cable_get_trst(chain___0->cable);
  }
#line 113
  return (tmp);
}
}
#line 116 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_shift_instructions_mode(chain_t *chain___0 , int capture , int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  int tmp___0 ;

  {
#line 122
  if (! chain___0) {
#line 123
    return;
  } else
#line 122
  if (! chain___0->parts) {
#line 123
    return;
  }
#line 125
  ps = chain___0->parts;
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < ps->len)) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 129
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 129
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c",
             129, i);
      }
#line 130
      return;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  if (capture) {
    {
#line 135
    tap_capture_ir(chain___0);
    }
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < ps->len)) {
#line 136
      goto while_break___0;
    }
#line 137
    if (i + 1 == ps->len) {
#line 137
      tmp___0 = exit___0;
    } else {
#line 137
      tmp___0 = 0;
    }
    {
#line 137
    tap_shift_register(chain___0, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                       (tap_register *)((void *)0), tmp___0);
#line 136
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_shift_instructions(chain_t *chain___0 ) 
{ 


  {
  {
#line 144
  chain_shift_instructions_mode(chain___0, 1, 1);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_shift_data_registers_mode(chain_t *chain___0 , int capture_output , int capture ,
                                     int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  tap_register *tmp___2 ;
  int tmp___3 ;

  {
#line 153
  if (! chain___0) {
#line 154
    return;
  } else
#line 153
  if (! chain___0->parts) {
#line 154
    return;
  }
#line 156
  ps = chain___0->parts;
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < ps->len)) {
#line 158
      goto while_break;
    }
#line 159
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 160
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 160
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c",
             160, i);
      }
#line 161
      return;
    }
#line 163
    if ((unsigned long )((*(ps->parts + i))->active_instruction)->data_register == (unsigned long )((void *)0)) {
      {
#line 164
      tmp___0 = gettext("%s(%d) Part %d without data register\n");
#line 164
      printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c",
             164, i);
      }
#line 165
      return;
    }
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (capture) {
    {
#line 170
    tap_capture_dr(chain___0);
    }
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (i < ps->len)) {
#line 175
      goto while_break___0;
    }
#line 176
    if (i + 1 == ps->len) {
#line 176
      tmp___1 = exit___0;
    } else {
#line 176
      tmp___1 = 0;
    }
#line 176
    if (capture_output) {
#line 176
      tmp___2 = (((*(ps->parts + i))->active_instruction)->data_register)->out;
    } else {
#line 176
      tmp___2 = (tap_register *)((void *)0);
    }
    {
#line 176
    tap_defer_shift_register(chain___0, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                             tmp___2, tmp___1);
#line 175
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  if (capture_output) {
#line 183
    i = 0;
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 183
      if (! (i < ps->len)) {
#line 183
        goto while_break___1;
      }
#line 184
      if (i + 1 == ps->len) {
#line 184
        tmp___3 = exit___0;
      } else {
#line 184
        tmp___3 = 0;
      }
      {
#line 184
      tap_shift_register_output(chain___0, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                                (((*(ps->parts + i))->active_instruction)->data_register)->out,
                                tmp___3);
#line 183
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 194
    cable_flush(chain___0->cable, (cable_flush_amount_t )1);
    }
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_shift_data_registers(chain_t *chain___0 , int capture_output ) 
{ 


  {
  {
#line 201
  chain_shift_data_registers_mode(chain___0, capture_output, 1, 1);
  }
#line 202
  return;
}
}
#line 204 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/chain.c"
void chain_flush(chain_t *chain___0 ) 
{ 


  {
#line 207
  if ((unsigned long )chain___0->cable != (unsigned long )((void *)0)) {
    {
#line 208
    cable_flush(chain___0->cable, (cable_flush_amount_t )3);
    }
  }
#line 209
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 126 "../../include/cable.h"
int cable_get_tdo(cable_t *cable ) ;
#line 130
int cable_defer_set_trst(cable_t *cable , int trst ) ;
#line 132
int cable_get_trst_late(cable_t *cable ) ;
#line 133
int cable_defer_get_trst(cable_t *cable ) ;
#line 134
int cable_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
cable_driver_t arcom_cable_driver ;
#line 43
cable_driver_t byteblaster_cable_driver ;
#line 76 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
cable_driver_t *cable_drivers[15]  = 
#line 76
  {      & arcom_cable_driver,      & byteblaster_cable_driver,      & dlc5_cable_driver,      & ea253_cable_driver, 
        & ei012_cable_driver,      & igloo_cable_driver,      & keithkoep_cable_driver,      & lattice_cable_driver, 
        & mpcbdm_cable_driver,      & triton_cable_driver,      & wiggler_cable_driver,      & wiggler2_cable_driver, 
        & xpc_int_cable_driver,      & xpc_ext_cable_driver,      (cable_driver_t *)((void *)0)};
#line 112 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_free(cable_t *cable ) 
{ 


  {
  {
#line 115
  (*((cable->driver)->cable_free))(cable);
  }
#line 116
  return;
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_init(cable_t *cable ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 121
  cable->delay = (uint32_t )0;
#line 122
  cable->frequency = (uint32_t )0;
#line 124
  cable->todo.max_items = 128;
#line 125
  cable->todo.num_items = 0;
#line 126
  cable->todo.next_item = 0;
#line 127
  cable->todo.next_free = 0;
#line 128
  tmp = malloc((unsigned long )cable->todo.max_items * sizeof(cable_queue_t ));
#line 128
  cable->todo.data = (cable_queue_t *)tmp;
#line 130
  cable->done.max_items = 128;
#line 131
  cable->done.num_items = 0;
#line 132
  cable->done.next_item = 0;
#line 133
  cable->done.next_free = 0;
#line 134
  tmp___0 = malloc((unsigned long )cable->done.max_items * sizeof(cable_queue_t ));
#line 134
  cable->done.data = (cable_queue_t *)tmp___0;
  }
#line 136
  if ((unsigned long )cable->todo.data == (unsigned long )((void *)0)) {
#line 136
    goto _L;
  } else
#line 136
  if ((unsigned long )cable->done.data == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 138
    tmp___1 = gettext("Failed to allocate memory for cable activity queue.\n");
#line 138
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 139
    if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
      {
#line 139
      free((void *)cable->todo.data);
      }
    }
#line 140
    if ((unsigned long )cable->done.data != (unsigned long )((void *)0)) {
      {
#line 140
      free((void *)cable->done.data);
      }
    }
#line 141
    return (1);
  }
  {
#line 144
  tmp___2 = (*((cable->driver)->init))(cable);
  }
#line 144
  return (tmp___2);
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) 
{ 


  {
#line 150
  if ((unsigned int )how_much == 1U) {
#line 153
    how_much = (cable_flush_amount_t )3;
  }
  {
#line 159
  (*((cable->driver)->flush))(cable, how_much);
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_done(cable_t *cable ) 
{ 


  {
  {
#line 165
  cable_flush(cable, (cable_flush_amount_t )3);
  }
#line 166
  if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
    {
#line 168
    free((void *)cable->todo.data);
#line 169
    free((void *)cable->done.data);
    }
  }
  {
#line 171
  (*((cable->driver)->done))(cable);
  }
#line 171
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;
  int new_max_items ;
  cable_queue_t *resized ;
  void *tmp ;
  char *tmp___0 ;
  int added_space ;
  int num_to_move ;
  int dest ;

  {
#line 178
  if (q->num_items >= q->max_items) {
    {
#line 188
    new_max_items = q->max_items + 128;
#line 189
    tmp = realloc((void *)q->data, (unsigned long )new_max_items * sizeof(cable_queue_t ));
#line 189
    resized = (cable_queue_t *)tmp;
    }
#line 190
    if ((unsigned long )resized == (unsigned long )((void *)0)) {
      {
#line 192
      tmp___0 = gettext("Out of memory: couldn\'t resize activity queue to %d\n");
#line 192
      printf((char const   */* __restrict  */)tmp___0, new_max_items);
      }
#line 194
      return (-1);
    }
#line 200
    q->data = resized;
#line 209
    if (q->next_item != 0) {
#line 211
      added_space = new_max_items - q->max_items;
#line 212
      num_to_move = q->max_items - q->next_item;
#line 215
      if (num_to_move <= q->next_free) {
        {
#line 221
        dest = new_max_items - num_to_move;
#line 226
        memmove((void *)(q->data + dest), (void const   *)(q->data + q->next_item),
                (unsigned long )num_to_move * sizeof(cable_queue_t ));
#line 229
        q->next_item = dest;
        }
      } else
#line 234
      if (q->next_free <= added_space) {
        {
#line 242
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (unsigned long )q->next_free * sizeof(cable_queue_t ));
        }
      } else {
        {
#line 257
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (unsigned long )added_space * sizeof(cable_queue_t ));
#line 267
        memmove((void *)(q->data + 0), (void const   *)(q->data + added_space), (unsigned long )(q->next_free - added_space) * sizeof(cable_queue_t ));
        }
      }
    }
#line 273
    q->max_items = new_max_items;
#line 274
    q->next_free = q->next_item + q->num_items;
#line 275
    if (q->next_free >= new_max_items) {
#line 275
      q->next_free -= new_max_items;
    }
  }
#line 283
  i = q->next_free;
#line 284
  j = i + 1;
#line 285
  if (j >= q->max_items) {
#line 285
    j = 0;
  }
#line 286
  q->next_free = j;
#line 287
  (q->num_items) ++;
#line 290
  return (i);
}
}
#line 293 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;

  {
#line 296
  if (q->num_items > 0) {
#line 298
    i = q->next_item;
#line 299
    j = i + 1;
#line 300
    if (j >= q->max_items) {
#line 300
      j = 0;
    }
#line 301
    q->next_item = j;
#line 302
    (q->num_items) --;
#line 304
    return (i);
  }
#line 308
  return (-1);
}
}
#line 311 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_purge_queue(cable_queue_info_t *q , int io ) 
{ 
  int i ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (q->num_items > 0)) {
#line 314
      goto while_break;
    }
#line 316
    i = q->next_item;
#line 317
    if ((unsigned int )(q->data + i)->action == 2U) {
#line 319
      if (io == 0) {
#line 321
        if ((unsigned long )(q->data + i)->arg.transfer.in != (unsigned long )((void *)0)) {
          {
#line 321
          free((void *)(q->data + i)->arg.transfer.in);
          }
        }
#line 322
        if ((unsigned long )(q->data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
          {
#line 322
          free((void *)(q->data + i)->arg.transfer.out);
          }
        }
      } else
#line 326
      if ((unsigned long )(q->data + i)->arg.xferred.out != (unsigned long )((void *)0)) {
        {
#line 326
        free((void *)(q->data + i)->arg.xferred.out);
        }
      }
    }
#line 330
    i ++;
#line 331
    if (i >= q->max_items) {
#line 331
      i = 0;
    }
#line 332
    (q->num_items) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  q->num_items = 0;
#line 336
  q->next_item = 0;
#line 337
  q->next_free = 0;
#line 338
  return;
}
}
#line 340 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 


  {
  {
#line 343
  cable_flush(cable, (cable_flush_amount_t )3);
#line 344
  (*((cable->driver)->clock))(cable, tms, tdi, n);
  }
#line 345
  return;
}
}
#line 347 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 350
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 350
  i = tmp;
  }
#line 351
  if (i < 0) {
#line 351
    return (1);
  }
  {
#line 352
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )0;
#line 353
  (cable->todo.data + i)->arg.clock.tms = tms;
#line 354
  (cable->todo.data + i)->arg.clock.tdi = tdi;
#line 355
  (cable->todo.data + i)->arg.clock.n = n;
#line 356
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 357
  return (0);
}
}
#line 360 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 363
  cable_flush(cable, (cable_flush_amount_t )3);
#line 364
  tmp = (*((cable->driver)->get_tdo))(cable);
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_get_tdo_late(cable_t *cable ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 371
  cable_flush(cable, (cable_flush_amount_t )2);
#line 372
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 373
  if (i >= 0) {
#line 375
    if ((unsigned int )(cable->done.data + i)->action != 1U) {
      {
#line 377
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 377
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 379
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 383
      return ((cable->done.data + i)->arg.value.tdo);
    }
  }
  {
#line 386
  tmp___0 = (*((cable->driver)->get_tdo))(cable);
  }
#line 386
  return (tmp___0);
}
}
#line 389 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_defer_get_tdo(cable_t *cable ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 392
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 392
  i = tmp;
  }
#line 393
  if (i < 0) {
#line 393
    return (1);
  }
  {
#line 394
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )1;
#line 395
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 396
  return (0);
}
}
#line 399 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 402
  cable_flush(cable, (cable_flush_amount_t )3);
#line 403
  tmp = (*((cable->driver)->set_trst))(cable, trst);
  }
#line 403
  return (tmp);
}
}
#line 406 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_defer_set_trst(cable_t *cable , int trst ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 409
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 409
  i = tmp;
  }
#line 410
  if (i < 0) {
#line 410
    return (1);
  }
  {
#line 411
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )3;
#line 412
  (cable->todo.data + i)->arg.value.trst = trst;
#line 413
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 414
  return (0);
}
}
#line 417 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_get_trst(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 420
  cable_flush(cable, (cable_flush_amount_t )3);
#line 421
  tmp = (*((cable->driver)->get_trst))(cable);
  }
#line 421
  return (tmp);
}
}
#line 424 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_get_trst_late(cable_t *cable ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 428
  cable_flush(cable, (cable_flush_amount_t )2);
#line 429
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 430
  if (i >= 0) {
#line 432
    if ((unsigned int )(cable->done.data + i)->action != 4U) {
      {
#line 434
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 434
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 436
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 440
      return ((cable->done.data + i)->arg.value.trst);
    }
  }
  {
#line 443
  tmp___0 = (*((cable->driver)->get_trst))(cable);
  }
#line 443
  return (tmp___0);
}
}
#line 446 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_defer_get_trst(cable_t *cable ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 449
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 449
  i = tmp;
  }
#line 450
  if (i < 0) {
#line 450
    return (1);
  }
  {
#line 451
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )4;
#line 452
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 453
  return (0);
}
}
#line 456 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int tmp ;

  {
  {
#line 459
  cable_flush(cable, (cable_flush_amount_t )3);
#line 460
  tmp = (*((cable->driver)->transfer))(cable, len, in, out);
  }
#line 460
  return (tmp);
}
}
#line 463 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_transfer_late(cable_t *cable , char *out ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 467
  cable_flush(cable, (cable_flush_amount_t )2);
#line 468
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 470
  if (i >= 0) {
#line 470
    if ((unsigned int )(cable->done.data + i)->action == 2U) {
#line 478
      if (out) {
        {
#line 478
        memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)(cable->done.data + i)->arg.xferred.out,
               (size_t )(cable->done.data + i)->arg.xferred.len);
        }
      }
      {
#line 481
      free((void *)(cable->done.data + i)->arg.xferred.out);
      }
#line 482
      return ((cable->done.data + i)->arg.xferred.res);
    }
  }
#line 485
  if ((unsigned int )(cable->done.data + i)->action != 2U) {
    {
#line 487
    tmp = gettext("Internal error: Got wrong type of result from queue (#%d %p.%d)\n");
#line 487
    printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
           & cable->done, i);
#line 489
    cable_purge_queue(& cable->done, 1);
    }
  } else {
    {
#line 493
    tmp___0 = gettext("Internal error: Wanted transfer result but none was queued\n");
#line 493
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 495
  return (0);
}
}
#line 498 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  char *ibuf ;
  char *obuf ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 501
  obuf = (char *)((void *)0);
#line 504
  tmp = malloc((size_t )len);
#line 504
  ibuf = (char *)tmp;
  }
#line 505
  if ((unsigned long )ibuf == (unsigned long )((void *)0)) {
#line 505
    return (1);
  }
#line 507
  if (out) {
    {
#line 509
    tmp___0 = malloc((size_t )len);
#line 509
    obuf = (char *)tmp___0;
    }
#line 510
    if ((unsigned long )obuf == (unsigned long )((void *)0)) {
      {
#line 512
      free((void *)ibuf);
      }
#line 513
      return (1);
    }
  }
  {
#line 517
  i = cable_add_queue_item(cable, & cable->todo);
  }
#line 518
  if (i < 0) {
    {
#line 520
    free((void *)ibuf);
    }
#line 521
    if (obuf) {
      {
#line 521
      free((void *)obuf);
      }
    }
#line 522
    return (1);
  }
#line 525
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )2;
#line 526
  (cable->todo.data + i)->arg.transfer.len = len;
#line 527
  if (in) {
    {
#line 527
    memcpy((void */* __restrict  */)ibuf, (void const   */* __restrict  */)in, (size_t )len);
    }
  }
  {
#line 528
  (cable->todo.data + i)->arg.transfer.in = ibuf;
#line 529
  (cable->todo.data + i)->arg.transfer.out = obuf;
#line 530
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 531
  return (0);
}
}
#line 534 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 


  {
  {
#line 537
  cable_flush(cable, (cable_flush_amount_t )3);
#line 538
  (*((cable->driver)->set_frequency))(cable, new_frequency);
  }
#line 539
  return;
}
}
#line 541 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
uint32_t cable_get_frequency(cable_t *cable ) 
{ 


  {
#line 544
  return (cable->frequency);
}
}
#line 547 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable.c"
void cable_wait(cable_t *cable ) 
{ 
  int i ;
  int volatile   j ;
  uint32_t delay ;

  {
#line 552
  delay = cable->delay;
#line 554
  if (delay == 0U) {
#line 555
    return;
  }
#line 557
  i = 0;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! ((uint32_t )i < delay)) {
#line 557
      goto while_break;
    }
#line 558
    j = (int volatile   )i;
#line 557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/byteblaster.c"
static int byteblaster_init(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 72
  BB_II = 0;
#line 74
  tmp = parport_open(cable->port);
  }
#line 74
  if (tmp) {
#line 75
    return (-1);
  }
  {
#line 77
  ((generic_params_t *)cable->params)->trst = 1;
#line 80
  parport_set_data(cable->port, (uint8_t )(1 << 5));
#line 81
  tmp___0 = parport_get_status(cable->port);
  }
#line 81
  if (! ((tmp___0 >> 6) & 1)) {
#line 82
    BB_II = 1;
  }
  {
#line 83
  parport_set_data(cable->port, (uint8_t )0);
#line 84
  tmp___1 = parport_get_status(cable->port);
  }
#line 84
  if ((tmp___1 >> 6) & 1) {
#line 85
    BB_II = 1;
  }
#line 89
  if (BB_II) {
    {
#line 89
    tmp___2 = parport_get_status(cable->port);
    }
#line 89
    if ((tmp___2 >> 3) & 1) {
#line 90
      return (-1);
    }
  }
  {
#line 93
  parport_set_control(cable->port, (uint8_t )12);
  }
#line 95
  return (0);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/byteblaster.c"
static void byteblaster_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 103
  if (tms) {
#line 103
    tms = 1;
  } else {
#line 103
    tms = 0;
  }
#line 104
  if (tdi) {
#line 104
    tdi = 1;
  } else {
#line 104
    tdi = 0;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < n)) {
#line 106
      goto while_break;
    }
    {
#line 107
    parport_set_data(cable->port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 108
    cable_wait(cable);
#line 109
    parport_set_data(cable->port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 110
    cable_wait(cable);
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 117
  parport_set_data(cable->port, (uint8_t )0);
#line 118
  cable_wait(cable);
#line 119
  tmp = parport_get_status(cable->port);
  }
#line 119
  return ((tmp >> 7) & 1);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/byteblaster.c"
static int byteblaster_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 125
  return (1);
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/byteblaster.c"
cable_driver_t byteblaster_cable_driver  = 
#line 128
     {"ByteBlaster", "Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable",
    & generic_connect, & generic_disconnect, & generic_cable_free, & byteblaster_init,
    & generic_done, & generic_set_frequency, & byteblaster_clock, & byteblaster_get_tdo,
    & generic_transfer, & byteblaster_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 51 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/arcom.c"
static int arcom_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
  {
#line 59
  data = parport_get_data(cable->port);
  }
#line 59
  if (data < 0) {
    {
#line 60
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 3));
    }
#line 60
    if (tmp___0) {
#line 61
      return (-1);
    }
#line 62
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 64
    ((generic_params_t *)cable->params)->trst = (data >> 3) & 1;
  }
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/arcom.c"
static void arcom_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 3) | (tms << 2)) | (tdi << 1)));
#line 79
    cable_wait(cable);
#line 80
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait(cable);
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/arcom.c"
static int arcom_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
#line 89
  cable_wait(cable);
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 7) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/arcom.c"
static int arcom_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  if (trst) {
#line 96
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 96
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 98
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
  }
#line 99
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.8/src/tap/cable/arcom.c"
cable_driver_t arcom_cable_driver  = 
#line 102
     {"ARCOM", "Arcom JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & arcom_init, & generic_done, & generic_set_frequency, & arcom_clock, & arcom_get_tdo,
    & generic_transfer, & arcom_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_lptcable_help};
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
flash_driver_t *flash_drivers[8]  = 
#line 57 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
  {      & amd_32_flash_driver,      & amd_16_flash_driver,      & amd_8_flash_driver,      & intel_32_flash_driver, 
        & intel_16_flash_driver,      & intel_8_flash_driver,      & amd_29xx040_flash_driver,      (flash_driver_t *)((void *)0)};
#line 69 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
static flash_driver_t *flash_driver  =    (flash_driver_t *)((void *)0);
#line 71 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
static void set_flash_driver(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  flash_driver = (flash_driver_t *)((void *)0);
#line 78
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 79
    return;
  }
#line 80
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 83
    if (tmp) {
      {
#line 84
      flash_driver = flash_drivers[i];
#line 85
      (*(flash_driver->print_info))(cfi_array);
      }
#line 86
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 89
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 93
  tmp___1 = gettext("Flash not supported!\n");
#line 93
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
void flashmsbin(bus_t *bus___0 , FILE *f ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  char *tmp ;
  char sync[8] ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t start ;
  uint32_t len ;
  int first ;
  int last ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  uint32_t a ;
  uint32_t l ;
  uint32_t c ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint32_t data ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  uint32_t a___0 ;
  uint32_t l___0 ;
  uint32_t c___0 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  uint32_t data___0 ;
  uint32_t readed ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 102
  set_flash_driver();
  }
#line 103
  if (! cfi_array) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  } else
#line 103
  if (! flash_driver) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  }
  {
#line 107
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 112
  fread((void */* __restrict  */)(& sync), sizeof(char ), (size_t )7, (FILE */* __restrict  */)f);
#line 113
  sync[7] = (char )'\000';
#line 114
  tmp___1 = strcmp("B000FF\n", (char const   *)(sync));
  }
#line 114
  if (tmp___1 != 0) {
    {
#line 115
    tmp___0 = gettext("Invalid sync sequence!\n");
#line 115
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 116
    return;
  }
  {
#line 126
  fread((void */* __restrict  */)(& start), sizeof(start), (size_t )1, (FILE */* __restrict  */)f);
#line 127
  fread((void */* __restrict  */)(& len), sizeof(len), (size_t )1, (FILE */* __restrict  */)f);
#line 128
  first = (int )(start / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
#line 129
  last = (int )(((start + len) - 1U) / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (first <= last)) {
#line 130
      goto while_break;
    }
    {
#line 131
    adr = ((uint32_t )first * (cfi->device_geometry.erase_block_regions + 0)->erase_block_size) * 2U;
#line 132
    (*(flash_driver->unlock_block))(cfi_array, adr);
#line 133
    tmp___2 = gettext("block %d unlocked\n");
#line 133
    printf((char const   */* __restrict  */)tmp___2, first);
#line 134
    tmp___3 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 134
    tmp___4 = gettext("erasing block %d: %d\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, first, tmp___3);
#line 130
    first ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp___5 = gettext("program:\n");
#line 138
  printf((char const   */* __restrict  */)tmp___5);
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 142
    fread((void */* __restrict  */)(& a), sizeof(a), (size_t )1, (FILE */* __restrict  */)f);
#line 143
    fread((void */* __restrict  */)(& l), sizeof(l), (size_t )1, (FILE */* __restrict  */)f);
#line 144
    fread((void */* __restrict  */)(& c), sizeof(c), (size_t )1, (FILE */* __restrict  */)f);
#line 145
    tmp___7 = feof(f);
    }
#line 145
    if (tmp___7) {
      {
#line 146
      tmp___6 = gettext("Error: premature end of file\n");
#line 146
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 147
      return;
    }
    {
#line 149
    tmp___8 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 149
    printf((char const   */* __restrict  */)tmp___8, a, l, c);
    }
#line 150
    if (a == 0U) {
#line 150
      if (c == 0U) {
#line 151
        goto while_break___0;
      }
    }
#line 152
    if (l & 3U) {
      {
#line 153
      tmp___9 = gettext("Error: Invalid record length!\n");
#line 153
      printf((char const   */* __restrict  */)tmp___9);
      }
#line 154
      return;
    }
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      if (! l) {
#line 157
        goto while_break___1;
      }
      {
#line 160
      tmp___10 = gettext("addr: 0x%08X");
#line 160
      printf((char const   */* __restrict  */)tmp___10, a);
#line 161
      printf((char const   */* __restrict  */)"\r");
#line 162
      fflush(stdout);
#line 163
      fread((void */* __restrict  */)(& data), sizeof(data), (size_t )1, (FILE */* __restrict  */)f);
#line 164
      tmp___12 = (*(flash_driver->program))(cfi_array, a, data);
      }
#line 164
      if (tmp___12) {
        {
#line 165
        tmp___11 = gettext("\nflash error\n");
#line 165
        printf((char const   */* __restrict  */)tmp___11);
        }
#line 166
        return;
      }
#line 168
      a += 4U;
#line 169
      l -= 4U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  printf((char const   */* __restrict  */)"\n");
#line 174
  (*(flash_driver->readarray))(cfi_array);
#line 176
  fseek(f, 15L, 0);
#line 177
  tmp___13 = gettext("verify:\n");
#line 177
  printf((char const   */* __restrict  */)tmp___13);
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 182
    fread((void */* __restrict  */)(& a___0), sizeof(a___0), (size_t )1, (FILE */* __restrict  */)f);
#line 183
    fread((void */* __restrict  */)(& l___0), sizeof(l___0), (size_t )1, (FILE */* __restrict  */)f);
#line 184
    fread((void */* __restrict  */)(& c___0), sizeof(c___0), (size_t )1, (FILE */* __restrict  */)f);
#line 185
    tmp___15 = feof(f);
    }
#line 185
    if (tmp___15) {
      {
#line 186
      tmp___14 = gettext("Error: premature end of file\n");
#line 186
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 187
      return;
    }
    {
#line 189
    tmp___16 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 189
    printf((char const   */* __restrict  */)tmp___16, a___0, l___0, c___0);
    }
#line 190
    if (a___0 == 0U) {
#line 190
      if (c___0 == 0U) {
#line 191
        goto while_break___2;
      }
    }
#line 192
    if (l___0 & 3U) {
      {
#line 193
      tmp___17 = gettext("Error: Invalid record length!\n");
#line 193
      printf((char const   */* __restrict  */)tmp___17);
      }
#line 194
      return;
    }
    {
#line 197
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 197
      if (! l___0) {
#line 197
        goto while_break___3;
      }
      {
#line 200
      tmp___18 = gettext("addr: 0x%08X");
#line 200
      printf((char const   */* __restrict  */)tmp___18, a___0);
#line 201
      printf((char const   */* __restrict  */)"\r");
#line 202
      fflush(stdout);
#line 203
      fread((void */* __restrict  */)(& data___0), sizeof(data___0), (size_t )1, (FILE */* __restrict  */)f);
#line 204
      readed = (*((bus___0->driver)->read))(bus___0, a___0);
      }
#line 205
      if (data___0 != readed) {
        {
#line 206
        tmp___19 = gettext("\nverify error: 0x%08X vs. 0x%08X at addr %08X\n");
#line 206
        printf((char const   */* __restrict  */)tmp___19, readed, data___0, a___0);
        }
#line 208
        return;
      }
#line 210
      a___0 += 4U;
#line 211
      l___0 -= 4U;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 215
  tmp___20 = gettext("\nDone.\n");
#line 215
  printf((char const   */* __restrict  */)tmp___20);
  }
#line 216
  return;
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
static int find_block(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ,
                      int *bytes_until_next_block ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;
  int bir ;

  {
#line 222
  b = 0;
#line 223
  bb = 0;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 225
      goto while_break;
    }
#line 226
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 227
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 228
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 229
    region_size = region_blocks * region_block_size;
#line 231
    if (adr < bb + region_size) {
#line 233
      bir = (adr - bb) / region_block_size;
#line 234
      *bytes_until_next_block = (bb + (bir + 1) * region_block_size) - adr;
#line 235
      return (b + bir);
    }
#line 237
    b += region_blocks;
#line 238
    bb += region_size;
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (-1);
}
}
#line 243 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  int *erased ;
  int i ;
  int neb ;
  int bus_width ;
  int chip_width ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t data ;
  uint8_t b[4096] ;
  int bc ;
  int bn ;
  int btr ;
  int block_no ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int j ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  uint8_t buf[16] ;
  uint32_t data___0 ;
  uint32_t readed ;
  int j___0 ;
  int tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 254
  set_flash_driver();
  }
#line 255
  if (! cfi_array) {
    {
#line 256
    tmp = gettext("no flash driver found\n");
#line 256
    printf((char const   */* __restrict  */)tmp);
    }
#line 257
    return;
  } else
#line 255
  if (! flash_driver) {
    {
#line 256
    tmp = gettext("no flash driver found\n");
#line 256
    printf((char const   */* __restrict  */)tmp);
    }
#line 257
    return;
  }
#line 259
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 261
  bus_width = cfi_array->bus_width;
#line 262
  chip_width = (*(cfi_array->cfi_chips + 0))->width;
#line 264
  i = 0;
#line 264
  neb = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 264
      goto while_break;
    }
#line 265
    neb = (int )((uint32_t )neb + (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 264
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  tmp___0 = malloc((unsigned long )neb * sizeof(*erased));
#line 267
  erased = (int *)tmp___0;
  }
#line 268
  if (! erased) {
    {
#line 269
    tmp___1 = gettext("Out of memory!\n");
#line 269
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 270
    return;
  }
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! (i < neb)) {
#line 272
      goto while_break___0;
    }
#line 273
    *(erased + i) = 0;
#line 272
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 275
  tmp___2 = gettext("program:\n");
#line 275
  printf((char const   */* __restrict  */)tmp___2);
#line 276
  adr = addr;
  }
  {
#line 277
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 277
    tmp___11 = feof(f);
    }
#line 277
    if (tmp___11) {
#line 277
      goto while_break___1;
    }
    {
#line 281
    bc = 0;
#line 281
    bn = 0;
#line 281
    btr = 4096;
#line 282
    tmp___3 = find_block(cfi, (int )(adr - cfi_array->address), bus_width, chip_width,
                         & btr);
#line 282
    block_no = tmp___3;
    }
#line 284
    if (btr > 4096) {
#line 284
      btr = 4096;
    }
    {
#line 285
    tmp___4 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )btr, (FILE */* __restrict  */)f);
#line 285
    bn = (int )tmp___4;
    }
#line 287
    if (bn > 0) {
#line 287
      if (! *(erased + block_no)) {
        {
#line 288
        (*(flash_driver->unlock_block))(cfi_array, adr);
#line 289
        tmp___5 = gettext("\nblock %d unlocked\n");
#line 289
        printf((char const   */* __restrict  */)tmp___5, block_no);
#line 290
        tmp___6 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 290
        tmp___7 = gettext("erasing block %d: %d\n");
#line 290
        printf((char const   */* __restrict  */)tmp___7, block_no, tmp___6);
#line 291
        *(erased + block_no) = 1;
        }
      }
    }
#line 294
    bc = 0;
    {
#line 294
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 294
      if (! (bc < bn)) {
#line 294
        goto while_break___2;
      }
#line 296
      if ((adr & 255U) == 0U) {
        {
#line 297
        tmp___8 = gettext("addr: 0x%08X\r");
#line 297
        printf((char const   */* __restrict  */)tmp___8, adr);
#line 298
        fflush(stdout);
        }
      }
#line 301
      data = (uint32_t )0;
#line 302
      j = 0;
      {
#line 302
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 302
        if (! ((unsigned int )j < flash_driver->bus_width)) {
#line 302
          goto while_break___3;
        }
#line 303
        if (big_endian) {
#line 304
          data = (data << 8) | (unsigned int )b[bc + j];
        } else {
#line 306
          data |= (unsigned int )((int )b[bc + j] << j * 8);
        }
#line 302
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 308
      tmp___10 = (*(flash_driver->program))(cfi_array, adr, data);
      }
#line 308
      if (tmp___10) {
        {
#line 309
        tmp___9 = gettext("\nflash error\n");
#line 309
        printf((char const   */* __restrict  */)tmp___9);
        }
#line 310
        return;
      }
#line 312
      adr += flash_driver->bus_width;
#line 294
      bc = (int )((unsigned int )bc + flash_driver->bus_width);
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 315
  printf((char const   */* __restrict  */)"\n");
#line 317
  (*(flash_driver->readarray))(cfi_array);
#line 319
  fseek(f, 0L, 0);
#line 320
  tmp___12 = gettext("verify:\n");
#line 320
  printf((char const   */* __restrict  */)tmp___12);
#line 321
  fflush(stdout);
#line 322
  adr = addr;
  }
  {
#line 323
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 323
    tmp___19 = feof(f);
    }
#line 323
    if (tmp___19) {
#line 323
      goto while_break___4;
    }
    {
#line 329
    tmp___15 = fread((void */* __restrict  */)(buf), (size_t )flash_driver->bus_width,
                     (size_t )1, (FILE */* __restrict  */)f);
    }
#line 329
    if (tmp___15 != 1UL) {
      {
#line 330
      tmp___13 = feof(f);
      }
#line 330
      if (tmp___13) {
#line 331
        goto while_break___4;
      }
      {
#line 332
      tmp___14 = gettext("Error during file read.\n");
#line 332
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 333
      return;
    }
#line 336
    data___0 = (uint32_t )0;
#line 337
    j___0 = 0;
    {
#line 337
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 337
      if (! ((unsigned int )j___0 < flash_driver->bus_width)) {
#line 337
        goto while_break___5;
      }
#line 338
      if (big_endian) {
#line 339
        data___0 = (data___0 << 8) | (unsigned int )buf[j___0];
      } else {
#line 341
        data___0 |= (unsigned int )((int )buf[j___0] << j___0 * 8);
      }
#line 337
      j___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 343
    if (addr) {
#line 343
      tmp___17 = 1;
    } else {
#line 343
      tmp___17 = 0;
    }
#line 343
    if (tmp___17 == 0) {
      {
#line 344
      tmp___16 = gettext("addr: 0x%08X\r");
#line 344
      printf((char const   */* __restrict  */)tmp___16, adr);
#line 345
      fflush(stdout);
      }
    }
    {
#line 347
    readed = (*((bus___0->driver)->read))(bus___0, adr);
    }
#line 348
    if (data___0 != readed) {
      {
#line 349
      tmp___18 = gettext("\nverify error:\nread: 0x%08X\nexpected: 0x%08X\n");
#line 349
      printf((char const   */* __restrict  */)tmp___18, readed, data___0);
      }
#line 350
      return;
    }
#line 352
    adr += flash_driver->bus_width;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 354
  tmp___20 = gettext("\nDone.\n");
#line 354
  printf((char const   */* __restrict  */)tmp___20);
#line 356
  free((void *)erased);
  }
#line 357
  return;
}
}
#line 359 "/home/khheo/project/benchmark/urjtag-0.8/src/flash.c"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) 
{ 
  cfi_query_structure_t *cfi ;
  int i ;
  int status ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int addr_block ;
  int block_no ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 364
  status = 0;
#line 366
  set_flash_driver();
  }
#line 367
  if (! cfi_array) {
    {
#line 368
    tmp = gettext("no flash driver found\n");
#line 368
    printf((char const   */* __restrict  */)tmp);
    }
#line 369
    return;
  } else
#line 367
  if (! flash_driver) {
    {
#line 368
    tmp = gettext("no flash driver found\n");
#line 368
    printf((char const   */* __restrict  */)tmp);
    }
#line 369
    return;
  }
#line 371
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 373
  if (number > 1) {
#line 373
    tmp___0 = "s";
  } else {
#line 373
    tmp___0 = "";
  }
  {
#line 373
  tmp___1 = gettext("\nErasing %d Flash block%s from address 0x%x\n");
#line 373
  printf((char const   */* __restrict  */)tmp___1, number, tmp___0, addr);
#line 375
  i = 1;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i <= number)) {
#line 375
      goto while_break;
    }
    {
#line 376
    addr_block = (int )(((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * flash_driver->bus_width) / 2U);
#line 377
    block_no = (int )(addr / (uint32_t )addr_block);
#line 378
    tmp___2 = gettext("(%d%% Completed) FLASH Block %d : Unlocking ... ");
#line 378
    printf((char const   */* __restrict  */)tmp___2, (i * 100) / number, block_no);
#line 379
    fflush(stdout);
#line 380
    (*(flash_driver->unlock_block))(cfi_array, addr);
#line 381
    tmp___3 = gettext("Erasing ... ");
#line 381
    printf((char const   */* __restrict  */)tmp___3);
#line 382
    fflush(stdout);
#line 383
    status = (*(flash_driver->erase_block))(cfi_array, addr);
    }
#line 384
    if (status == 0) {
#line 385
      if (i == number) {
        {
#line 386
        tmp___4 = gettext("\r(100%% Completed) FLASH Block %d : Unlocking ... Erasing ... Ok.\n");
#line 386
        printf((char const   */* __restrict  */)tmp___4, block_no);
        }
      } else {
        {
#line 388
        tmp___5 = gettext("Ok.\r%78s\r");
#line 388
        printf((char const   */* __restrict  */)tmp___5, "");
        }
      }
    } else {
      {
#line 391
      tmp___6 = gettext("ERROR.\n");
#line 391
      printf((char const   */* __restrict  */)tmp___6);
      }
    }
#line 392
    addr |= (unsigned int )(addr_block - 1);
#line 393
    addr ++;
#line 375
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if (status == 0) {
    {
#line 397
    tmp___7 = gettext("\nErasing Completed.\n");
#line 397
    printf((char const   */* __restrict  */)tmp___7);
    }
  } else {
    {
#line 399
    tmp___8 = gettext("\nErasing Failed.\n");
#line 399
    printf((char const   */* __restrict  */)tmp___8);
    }
  }
#line 404
  return;
}
}
#line 36 "/home/khheo/project/benchmark/urjtag-0.8/src/writemem.c"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  int bidx ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 41
  bc = 0;
#line 42
  bidx = 0;
#line 48
  if (! bus___0) {
    {
#line 49
    tmp = gettext("Error: Missing bus driver!\n");
#line 49
    printf((char const   */* __restrict  */)tmp);
    }
#line 50
    return;
  }
  {
#line 53
  (*((bus___0->driver)->prepare))(bus___0);
#line 55
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 55
  if (tmp___1 != 0) {
    {
#line 56
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 56
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 57
    return;
  }
#line 59
  step = area.width / 8U;
#line 61
  if (step == 0U) {
    {
#line 62
    tmp___2 = gettext("Unknown bus width!\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return;
  }
  {
#line 66
  addr &= ~ (step - 1U);
#line 67
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 69
  tmp___3 = gettext("address: 0x%08X\n");
#line 69
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 70
  tmp___4 = gettext("length:  0x%08X\n");
#line 70
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 72
  if (len == 0U) {
    {
#line 73
    tmp___5 = gettext("length is 0.\n");
#line 73
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 74
    return;
  }
  {
#line 77
  a = addr;
#line 78
  end = (uint64_t )(a + len);
#line 79
  tmp___6 = gettext("writing:\n");
#line 79
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((uint64_t )a < end)) {
#line 81
      goto while_break;
    }
#line 86
    if ((uint32_t )bc < step) {
      {
#line 87
      tmp___7 = gettext("addr: 0x%08X");
#line 87
      printf((char const   */* __restrict  */)tmp___7, a);
#line 88
      printf((char const   */* __restrict  */)"\r");
#line 89
      fflush(stdout);
      }
#line 90
      if (bc != 0) {
        {
#line 91
        tmp___8 = gettext("Data not on word boundary, NOT SUPPORTED!");
#line 91
        printf((char const   */* __restrict  */)tmp___8);
        }
      }
      {
#line 92
      tmp___11 = feof(f);
      }
#line 92
      if (tmp___11) {
        {
#line 93
        tmp___9 = gettext("Unexpected end of file!\n");
#line 93
        printf((char const   */* __restrict  */)tmp___9);
#line 94
        tmp___10 = gettext("Addr: 0x%08X\n");
#line 94
        printf((char const   */* __restrict  */)tmp___10, a);
        }
#line 95
        goto while_break;
      }
      {
#line 97
      tmp___12 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )4096, (FILE */* __restrict  */)f);
#line 97
      bc = (int )tmp___12;
      }
#line 98
      if (! bc) {
        {
#line 99
        tmp___13 = gettext("Short read: bc=0x%X\n");
#line 99
        printf((char const   */* __restrict  */)tmp___13, bc);
        }
      }
#line 101
      bidx = 0;
    }
#line 106
    data = (uint32_t )0;
#line 107
    j = (int )step;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (j > 0)) {
#line 107
        goto while_break___0;
      }
#line 108
      if (big_endian) {
#line 109
        tmp___14 = bidx;
#line 109
        bidx ++;
#line 109
        data |= (unsigned int )b[tmp___14];
#line 110
        data <<= 8;
#line 111
        bc --;
      } else {
#line 113
        tmp___15 = bidx;
#line 113
        bidx ++;
#line 113
        data |= (unsigned int )((int )b[tmp___15] << (step - (uint32_t )j) * 8U);
#line 114
        bc --;
      }
#line 107
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 118
    (*((bus___0->driver)->write))(bus___0, a, data);
#line 81
    a += step;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp___16 = gettext("\nDone.\n");
#line 122
  printf((char const   */* __restrict  */)tmp___16);
  }
#line 123
  return;
}
}
#line 43 "/home/khheo/project/benchmark/urjtag-0.8/src/readmem.c"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 48
  bc = 0;
#line 54
  if (! bus___0) {
    {
#line 55
    tmp = gettext("Error: Missing bus driver!\n");
#line 55
    printf((char const   */* __restrict  */)tmp);
    }
#line 56
    return;
  }
  {
#line 59
  (*((bus___0->driver)->prepare))(bus___0);
#line 61
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 61
  if (tmp___1 != 0) {
    {
#line 62
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 62
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 63
    return;
  }
#line 65
  step = area.width / 8U;
#line 67
  if (step == 0U) {
    {
#line 68
    tmp___2 = gettext("Unknown bus width!\n");
#line 68
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 69
    return;
  }
  {
#line 72
  addr &= ~ (step - 1U);
#line 73
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 75
  tmp___3 = gettext("address: 0x%08X\n");
#line 75
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 76
  tmp___4 = gettext("length:  0x%08X\n");
#line 76
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 78
  if (len == 0U) {
    {
#line 79
    tmp___5 = gettext("length is 0.\n");
#line 79
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 80
    return;
  }
  {
#line 83
  a = addr;
#line 84
  end = (uint64_t )(a + len);
#line 85
  tmp___6 = gettext("reading:\n");
#line 85
  printf((char const   */* __restrict  */)tmp___6);
#line 86
  (*((bus___0->driver)->read_start))(bus___0, addr);
#line 87
  a += step;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((uint64_t )a <= end)) {
#line 87
      goto while_break;
    }
#line 91
    if (a < addr + len) {
      {
#line 92
      data = (*((bus___0->driver)->read_next))(bus___0, a);
      }
    } else {
      {
#line 94
      data = (*((bus___0->driver)->read_end))(bus___0);
      }
    }
#line 96
    j = (int )step;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (j > 0)) {
#line 96
        goto while_break___0;
      }
#line 97
      if (big_endian) {
#line 98
        tmp___7 = bc;
#line 98
        bc ++;
#line 98
        b[tmp___7] = (uint8_t )((data >> (j - 1) * 8) & 255U);
      } else {
#line 100
        tmp___8 = bc;
#line 100
        bc ++;
#line 100
        b[tmp___8] = (uint8_t )(data & 255U);
#line 101
        data >>= 8;
      }
#line 96
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    if (bc >= 4096) {
#line 104
      goto _L;
    } else
#line 104
    if ((uint64_t )a >= end) {
      _L: /* CIL Label */ 
      {
#line 105
      tmp___9 = gettext("addr: 0x%08X");
#line 105
      printf((char const   */* __restrict  */)tmp___9, a);
#line 106
      printf((char const   */* __restrict  */)"\r");
#line 107
      fflush(stdout);
#line 108
      fwrite((void const   */* __restrict  */)(b), (size_t )bc, (size_t )1, (FILE */* __restrict  */)f);
#line 109
      bc = 0;
      }
    }
#line 87
    a += step;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp___10 = gettext("\nDone.\n");
#line 113
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 114
  return;
}
}
#line 45 "../include/jtag.h"
int detect_register_size(chain_t *chain___0 ) ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.8/src/discovery.c"
int detect_register_size(chain_t *chain___0 ) 
{ 
  int len ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rpat ;
  int tdo ;
  int tdo_stuck ;
  int p ;
  int ok ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;
  int i ;
  char const   *s ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 50
  tdo_stuck = -2;
#line 52
  len = 1;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (len <= 1024)) {
#line 52
      goto while_break;
    }
    {
#line 54
    ok = 0;
#line 56
    tmp = register_alloc(len);
#line 56
    rz = register_fill(tmp, 0);
#line 57
    rout = register_alloc(8 + len);
#line 58
    tmp___0 = register_alloc(8 + len);
#line 58
    tmp___1 = register_fill(tmp___0, 0);
#line 58
    rpat = register_inc(tmp___1);
#line 60
    p = 1;
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (p < 1 << 8)) {
#line 60
        goto while_break___0;
      }
      {
#line 63
      ok = 0;
#line 65
      s = register_get_string((tap_register const   *)rpat);
      }
      {
#line 66
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 66
        if (! *s) {
#line 66
          goto while_break___1;
        }
#line 67
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 69
      i = 0;
      {
#line 69
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 69
        if (! (i < 1)) {
#line 69
          goto while_break___2;
        }
        {
#line 70
        tap_shift_register(chain___0, (tap_register const   *)rz, (tap_register *)((void *)0),
                           0);
#line 71
        tap_shift_register(chain___0, (tap_register const   *)rpat, rout, 0);
#line 73
        tdo = register_all_bits_same_value((tap_register const   *)rout);
        }
#line 74
        if (tdo_stuck == -2) {
#line 74
          tdo_stuck = tdo;
        }
#line 75
        if (tdo_stuck != tdo) {
#line 75
          tdo_stuck = -1;
        }
        {
#line 77
        register_shift_right(rout, len);
#line 79
        tmp___2 = register_compare((tap_register const   *)rpat, (tap_register const   *)rout);
        }
#line 79
        if (tmp___2 == 0) {
#line 80
          ok ++;
        }
#line 69
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 82
      if (100 * ok < 100) {
#line 83
        ok = 0;
#line 84
        goto while_break___0;
      }
      {
#line 87
      register_inc(rpat);
#line 60
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    register_free(rz);
#line 91
    register_free(rout);
#line 92
    register_free(rpat);
    }
#line 94
    if (ok) {
#line 95
      return (len);
    }
#line 52
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (tdo_stuck >= 0) {
    {
#line 100
    tmp___3 = gettext("Warning: TDO seems to be stuck at %d\n");
#line 100
    printf((char const   */* __restrict  */)tmp___3, tdo_stuck);
    }
  }
#line 103
  return (-1);
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.8/src/discovery.c"
void jtag_reset(chain_t *chain___0 ) 
{ 


  {
  {
#line 109
  chain_set_trst(chain___0, 0);
#line 110
  chain_set_trst(chain___0, 1);
#line 112
  tap_reset(chain___0);
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.8/src/discovery.c"
void discovery(chain_t *chain___0 ) 
{ 
  int irlen ;
  tap_register *ir___0 ;
  tap_register *irz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;
  char *tmp___3 ;
  int rs ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 123
  jtag_reset(chain___0);
#line 125
  tmp = gettext("Detecting IR length ... ");
#line 125
  printf((char const   */* __restrict  */)tmp);
#line 126
  fflush(stdout);
#line 128
  tap_capture_ir(chain___0);
#line 129
  irlen = detect_register_size(chain___0);
#line 131
  tmp___0 = gettext("%d\n");
#line 131
  printf((char const   */* __restrict  */)tmp___0, irlen);
  }
#line 133
  if (irlen < 1) {
    {
#line 134
    tmp___1 = gettext("Error: Invalid IR length!\n");
#line 134
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 135
    return;
  }
  {
#line 139
  tmp___2 = register_alloc(irlen);
#line 139
  ir___0 = register_fill(tmp___2, 1);
#line 140
  irz = register_duplicate((tap_register const   *)ir___0);
  }
#line 142
  if (! ir___0) {
    {
#line 143
    register_free(ir___0);
#line 144
    register_free(irz);
#line 145
    tmp___3 = gettext("Error: Out of memory!\n");
#line 145
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 146
    return;
  } else
#line 142
  if (! irz) {
    {
#line 143
    register_free(ir___0);
#line 144
    register_free(irz);
#line 145
    tmp___3 = gettext("Error: Out of memory!\n");
#line 145
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 146
    return;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    jtag_reset(chain___0);
#line 154
    tap_capture_ir(chain___0);
#line 155
    tap_shift_register(chain___0, (tap_register const   *)ir___0, (tap_register *)((void *)0),
                       1);
#line 157
    tmp___4 = register_get_string((tap_register const   *)ir___0);
#line 157
    tmp___5 = gettext("Detecting DR length for IR %s ... ");
#line 157
    printf((char const   */* __restrict  */)tmp___5, tmp___4);
#line 158
    fflush(stdout);
#line 160
    tap_capture_dr(chain___0);
#line 161
    rs = detect_register_size(chain___0);
#line 163
    tmp___6 = gettext("%d\n");
#line 163
    printf((char const   */* __restrict  */)tmp___6, rs);
#line 165
    register_inc(ir___0);
#line 166
    tmp___7 = register_compare((tap_register const   *)ir___0, (tap_register const   *)irz);
    }
#line 166
    if (tmp___7 == 0) {
#line 167
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  register_free(ir___0);
#line 170
  register_free(irz);
  }
#line 171
  return;
}
}
#line 564 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 302 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.8/src/detect.c"
static int find_record(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 54
  r = 0;
#line 56
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 57
  if (! file) {
    {
#line 58
    tmp = gettext("Cannot open %s\n");
#line 58
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 59
    return (0);
  }
  {
#line 62
  tr = register_alloc(key->len);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 69
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 70
      goto while_break;
    }
    {
#line 73
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 74
    if (p) {
#line 75
      *p = (char )'\000';
    }
#line 77
    p = line;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (*p) {
        {
#line 80
        tmp___1 = __ctype_b_loc();
        }
#line 80
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 80
          goto while_break___0;
        }
      } else {
#line 80
        goto while_break___0;
      }
#line 81
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 84
    s = strchr((char const   *)p, '\000');
    }
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 85
        goto while_break___1;
      }
      {
#line 86
      tmp___2 = __ctype_b_loc();
#line 86
      s --;
      }
#line 86
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 87
        goto while_break___1;
      }
#line 88
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 92
    if (! *p) {
#line 93
      goto __Cont;
    }
#line 96
    s = p;
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 97
      if (*s) {
        {
#line 97
        tmp___3 = __ctype_b_loc();
        }
#line 97
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 97
          goto while_break___2;
        }
      } else {
#line 97
        goto while_break___2;
      }
#line 98
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 99
    if (*s) {
#line 100
      tmp___4 = s;
#line 100
      s ++;
#line 100
      *tmp___4 = (char )'\000';
    }
    {
#line 103
    tmp___5 = strlen((char const   *)p);
    }
#line 103
    if (tmp___5 != (size_t )key->len) {
#line 104
      goto __Cont;
    }
    {
#line 107
    register_init(tr, (char const   *)p);
#line 108
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 108
    if (tmp___6) {
#line 109
      goto __Cont;
    }
#line 112
    p = s;
    {
#line 115
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 115
      if (*p) {
        {
#line 115
        tmp___7 = __ctype_b_loc();
        }
#line 115
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 115
          goto while_break___3;
        }
      } else {
#line 115
        goto while_break___3;
      }
#line 116
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 119
    if (! *p) {
#line 120
      goto __Cont;
    }
#line 123
    s = p;
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (*s) {
        {
#line 124
        tmp___8 = __ctype_b_loc();
        }
#line 124
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 124
          goto while_break___4;
        }
      } else {
#line 124
        goto while_break___4;
      }
#line 125
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 126
    if (*s) {
#line 127
      tmp___9 = s;
#line 127
      s ++;
#line 127
      *tmp___9 = (char )'\000';
    }
    {
#line 130
    tmp___10 = strlen((char const   *)p);
    }
#line 130
    if (tmp___10 >= sizeof(idr->name)) {
#line 131
      goto __Cont;
    }
    {
#line 134
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 137
    p = s;
    }
    {
#line 140
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 140
      if (*p) {
        {
#line 140
        tmp___11 = __ctype_b_loc();
        }
#line 140
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 140
          goto while_break___5;
        }
      } else {
#line 140
        goto while_break___5;
      }
#line 141
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 144
    if (! *p) {
#line 145
      goto __Cont;
    }
    {
#line 148
    tmp___12 = strlen((char const   *)p);
    }
#line 148
    if (tmp___12 >= sizeof(idr->fullname)) {
#line 149
      goto __Cont;
    }
    {
#line 152
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 154
    r = 1;
    }
#line 155
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  fclose(file);
#line 160
  register_free(tr);
  }
#line 162
  return (r);
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.8/src/detect.c"
uint64_t bits_to_uint64(tap_register *t ) 
{ 
  int i ;
  uint64_t l ;
  uint64_t b ;

  {
#line 170
  l = (uint64_t )0;
#line 170
  b = (uint64_t )1;
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < t->len)) {
#line 171
      goto while_break;
    }
#line 172
    if ((int )*(t->data + i) & 1) {
#line 172
      l |= b;
    }
#line 173
    b <<= 1;
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (l);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.8/src/detect.c"
int detect_parts(chain_t *chain___0 , char *db_path ) 
{ 
  int irlen ;
  tap_register *ir___0 ;
  int chlen ;
  tap_register *one ;
  tap_register *ones ;
  tap_register *br ;
  tap_register *id ;
  parts_t *ps ;
  int i ;
  char data_path[1024] ;
  char *cmd[3] ;
  char manufacturer[26] ;
  char partname[21] ;
  char stepping[9] ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  tap_register *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  part_t *part___0 ;
  tap_register *did ;
  tap_register *key ;
  struct id_record idr ;
  char *p ;
  int tmp___7 ;
  uint64_t tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
  {
#line 193
  cmd[0] = (char *)"script";
#line 193
  cmd[1] = data_path;
#line 193
  cmd[2] = (char *)((void *)0);
#line 199
  tap_reset(chain___0);
#line 200
  tap_capture_ir(chain___0);
#line 201
  irlen = detect_register_size(chain___0);
  }
#line 202
  if (irlen < 1) {
#line 203
    return (0);
  }
  {
#line 205
  tmp = gettext("IR length: %d\n");
#line 205
  printf((char const   */* __restrict  */)tmp, irlen);
#line 208
  tmp___0 = register_alloc(irlen);
#line 208
  ir___0 = register_fill(tmp___0, 1);
  }
#line 209
  if ((unsigned long )ir___0 == (unsigned long )((void *)0)) {
    {
#line 210
    tmp___1 = gettext("out of memory\n");
#line 210
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 211
    return (0);
  }
  {
#line 214
  tap_shift_register(chain___0, (tap_register const   *)ir___0, (tap_register *)((void *)0),
                     1);
#line 215
  register_free(ir___0);
#line 218
  tap_capture_dr(chain___0);
#line 219
  chlen = detect_register_size(chain___0);
  }
#line 220
  if (chlen < 1) {
    {
#line 221
    tmp___2 = gettext("Unable to detect JTAG chain length\n");
#line 221
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 222
    return (0);
  }
  {
#line 224
  tmp___3 = gettext("Chain length: %d\n");
#line 224
  printf((char const   */* __restrict  */)tmp___3, chlen);
#line 227
  tmp___4 = register_alloc(1);
#line 227
  one = register_fill(tmp___4, 1);
#line 228
  tmp___5 = register_alloc(31);
#line 228
  ones = register_fill(tmp___5, 1);
#line 229
  br = register_alloc(1);
#line 230
  id = register_alloc(32);
#line 231
  ps = parts_alloc();
  }
#line 232
  if (! one) {
#line 232
    goto _L;
  } else
#line 232
  if (! ones) {
#line 232
    goto _L;
  } else
#line 232
  if (! br) {
#line 232
    goto _L;
  } else
#line 232
  if (! id) {
#line 232
    goto _L;
  } else
#line 232
  if (! ps) {
    _L: /* CIL Label */ 
    {
#line 233
    tmp___6 = gettext("out of memory\n");
#line 233
    printf((char const   */* __restrict  */)tmp___6);
#line 235
    register_free(one);
#line 236
    register_free(ones);
#line 237
    register_free(br);
#line 238
    register_free(id);
#line 239
    parts_free(ps);
    }
#line 240
    return (0);
  }
  {
#line 242
  chain___0->parts = ps;
#line 243
  chain___0->active_part = 0;
#line 246
  tap_reset(chain___0);
#line 247
  tap_capture_dr(chain___0);
#line 249
  i = 0;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i < chlen)) {
#line 249
      goto while_break;
    }
    {
#line 251
    did = br;
#line 256
    tap_shift_register(chain___0, (tap_register const   *)one, br, 0);
#line 257
    tmp___7 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 257
    if (tmp___7 == 0) {
      {
#line 259
      tap_shift_register(chain___0, (tap_register const   *)ones, id, 0);
#line 260
      register_shift_left(id, 1);
#line 261
      *(id->data + 0) = (char)1;
#line 262
      did = id;
      }
    }
    {
#line 265
    tmp___8 = bits_to_uint64(did);
#line 265
    tmp___9 = register_get_string((tap_register const   *)did);
#line 265
    tmp___10 = gettext("Device Id: %s (0x%016lX)\n");
#line 265
    printf((char const   */* __restrict  */)tmp___10, tmp___9, tmp___8);
#line 267
    part___0 = part_alloc((tap_register const   *)did);
    }
#line 268
    if ((unsigned long )part___0 == (unsigned long )((void *)0)) {
      {
#line 269
      tmp___11 = gettext("Out of memory\n");
#line 269
      printf((char const   */* __restrict  */)tmp___11);
      }
#line 270
      goto while_break;
    }
    {
#line 272
    parts_add_part(ps, part___0);
    }
#line 274
    if ((unsigned long )did == (unsigned long )br) {
#line 275
      goto __Cont;
    }
    {
#line 277
    chain___0->active_part = ps->len - 1;
#line 280
    tmp___28 = register_get_string((tap_register const   *)did);
#line 280
    tmp___29 = bsdl_scan_files(tmp___28, 1);
    }
#line 280
    if (tmp___29 <= 0) {
      {
#line 285
      strcpy((char */* __restrict  */)(data_path), (char const   */* __restrict  */)db_path);
#line 288
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/MANUFACTURERS");
#line 290
      key = register_alloc(11);
#line 291
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 1),
             (size_t )key->len);
#line 292
      tmp___13 = find_record(data_path, key, & idr);
      }
#line 292
      if (! tmp___13) {
        {
#line 293
        tmp___12 = gettext("  Unknown manufacturer!\n");
#line 293
        printf((char const   */* __restrict  */)tmp___12);
#line 294
        register_free(key);
        }
#line 295
        goto __Cont;
      }
      {
#line 297
      register_free(key);
#line 299
      tmp___14 = gettext("  Manufacturer: %s\n");
#line 299
      printf((char const   */* __restrict  */)tmp___14, idr.fullname);
#line 300
      tmp___16 = strlen((char const   *)(idr.fullname));
      }
#line 300
      if (tmp___16 > 25UL) {
        {
#line 301
        tmp___15 = gettext("Warning: Manufacturer too long\n");
#line 301
        printf((char const   */* __restrict  */)tmp___15);
        }
      }
      {
#line 302
      strncpy((char */* __restrict  */)(manufacturer), (char const   */* __restrict  */)(idr.fullname),
              (size_t )25);
#line 303
      manufacturer[25] = (char )'\000';
#line 306
      p = strrchr((char const   *)(data_path), '/');
      }
#line 307
      if (p) {
#line 308
        *(p + 1) = (char )'\000';
      } else {
#line 310
        data_path[0] = (char )'\000';
      }
      {
#line 311
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 312
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/PARTS");
#line 314
      key = register_alloc(16);
#line 315
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 12),
             (size_t )key->len);
#line 316
      tmp___18 = find_record(data_path, key, & idr);
      }
#line 316
      if (! tmp___18) {
        {
#line 317
        tmp___17 = gettext("  Unknown part!\n");
#line 317
        printf((char const   */* __restrict  */)tmp___17);
#line 318
        register_free(key);
        }
#line 319
        goto __Cont;
      }
      {
#line 321
      register_free(key);
#line 323
      tmp___19 = gettext("  Part(%d):         %s\n");
#line 323
      printf((char const   */* __restrict  */)tmp___19, chain___0->active_part, idr.fullname);
#line 324
      tmp___21 = strlen((char const   *)(idr.fullname));
      }
#line 324
      if (tmp___21 > 20UL) {
        {
#line 325
        tmp___20 = gettext("Warning: Part too long\n");
#line 325
        printf((char const   */* __restrict  */)tmp___20);
        }
      }
      {
#line 326
      strncpy((char */* __restrict  */)(partname), (char const   */* __restrict  */)(idr.fullname),
              (size_t )20);
#line 327
      partname[20] = (char )'\000';
#line 330
      p = strrchr((char const   *)(data_path), '/');
      }
#line 331
      if (p) {
#line 332
        *(p + 1) = (char )'\000';
      } else {
#line 334
        data_path[0] = (char )'\000';
      }
      {
#line 335
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 336
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/STEPPINGS");
#line 338
      key = register_alloc(4);
#line 339
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 28),
             (size_t )key->len);
#line 340
      tmp___23 = find_record(data_path, key, & idr);
      }
#line 340
      if (! tmp___23) {
        {
#line 341
        tmp___22 = gettext("  Unknown stepping!\n");
#line 341
        printf((char const   */* __restrict  */)tmp___22);
#line 342
        register_free(key);
        }
#line 343
        goto __Cont;
      }
      {
#line 345
      register_free(key);
#line 347
      tmp___24 = gettext("  Stepping:     %s\n");
#line 347
      printf((char const   */* __restrict  */)tmp___24, idr.fullname);
#line 348
      tmp___26 = strlen((char const   *)(idr.fullname));
      }
#line 348
      if (tmp___26 > 8UL) {
        {
#line 349
        tmp___25 = gettext("Warning: Stepping too long\n");
#line 349
        printf((char const   */* __restrict  */)tmp___25);
        }
      }
      {
#line 350
      strncpy((char */* __restrict  */)(stepping), (char const   */* __restrict  */)(idr.fullname),
              (size_t )8);
#line 351
      stepping[8] = (char )'\000';
#line 354
      p = strrchr((char const   *)(data_path), '/');
      }
#line 355
      if (p) {
#line 356
        *(p + 1) = (char )'\000';
      } else {
#line 358
        data_path[0] = (char )'\000';
      }
      {
#line 359
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 361
      tmp___27 = gettext("  Filename:     %s\n");
#line 361
      printf((char const   */* __restrict  */)tmp___27, data_path);
#line 364
      strcpy((char */* __restrict  */)(part___0->manufacturer), (char const   */* __restrict  */)(manufacturer));
#line 365
      strcpy((char */* __restrict  */)(part___0->part), (char const   */* __restrict  */)(partname));
#line 366
      strcpy((char */* __restrict  */)(part___0->stepping), (char const   */* __restrict  */)(stepping));
#line 367
      cmd_run(cmd);
      }
    }
#line 372
    if ((unsigned long )part___0->active_instruction == (unsigned long )((void *)0)) {
      {
#line 373
      part___0->active_instruction = part_find_instruction(part___0, "IDCODE");
      }
    }
    __Cont: /* CIL Label */ 
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! (i < 32)) {
#line 376
      goto while_break___0;
    }
    {
#line 377
    tap_shift_register(chain___0, (tap_register const   *)one, br, 0);
#line 378
    tmp___31 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 378
    if (tmp___31 != 0) {
      {
#line 379
      tmp___30 = gettext("Error: Unable to detect JTAG chain end!\n");
#line 379
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 380
      goto while_break___0;
    }
#line 376
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 383
  tap_shift_register(chain___0, (tap_register const   *)one, (tap_register *)((void *)0),
                     1);
#line 385
  register_free(one);
#line 386
  register_free(ones);
#line 387
  register_free(br);
#line 388
  register_free(id);
  }
#line 390
  return (ps->len);
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 616 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
chain_t *chain  =    (chain_t *)((void *)0);
#line 59 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
int debug_mode  =    0;
#line 60 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
int big_endian  =    0;
#line 61 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
int interactive  =    0;
#line 64 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static char *get_token(char *buf ) 
{ 
  char *t ;
  char *tmp ;

  {
  {
#line 67
  tmp = strtok((char */* __restrict  */)buf, (char const   */* __restrict  */)" \f\n\r\t\v");
#line 67
  t = tmp;
  }
#line 68
  if (t) {
#line 68
    if ((int )*t == 35) {
#line 69
      return ((char *)((void *)0));
    }
  }
#line 70
  return (t);
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static void jtag_create_jtagdir(void) 
{ 
  char *home ;
  char *tmp ;
  char *jdir ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 80
  tmp = getenv("HOME");
#line 80
  home = tmp;
  }
#line 83
  if (! home) {
#line 84
    return;
  }
  {
#line 86
  tmp___0 = strlen((char const   *)home);
#line 86
  tmp___1 = strlen(".jtag");
#line 86
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 86
  jdir = (char *)tmp___2;
  }
#line 87
  if (! jdir) {
#line 88
    return;
  }
  {
#line 90
  strcpy((char */* __restrict  */)jdir, (char const   */* __restrict  */)home);
#line 91
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)"/");
#line 92
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)".jtag");
#line 95
  mkdir((char const   *)jdir, (__mode_t )((((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 97
  free((void *)jdir);
  }
#line 98
  return;
}
}
#line 156 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static int jtag_parse_line(char *line ) 
{ 
  char *t ;
  int l ;
  int n ;
  char **a ;
  int r ;
  size_t tmp ;
  char **newa ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 165
  if (! line) {
#line 166
    return (1);
  } else {
    {
#line 165
    tmp = strlen((char const   *)line);
    }
#line 165
    if (! (tmp > 0UL)) {
#line 166
      return (1);
    }
  }
  {
#line 168
  t = get_token(line);
  }
#line 169
  if (! t) {
#line 170
    return (1);
  }
#line 172
  n = 0;
#line 173
  l = 0;
#line 174
  a = (char **)((void *)0);
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! t) {
#line 175
      goto while_break;
    }
#line 176
    if (n + 2 > l) {
#line 178
      if (l < 16) {
#line 178
        l = 16;
      } else {
#line 178
        l *= 2;
      }
      {
#line 179
      tmp___0 = realloc((void *)a, (unsigned long )l * sizeof(char *));
#line 179
      newa = (char **)tmp___0;
      }
#line 180
      if (! newa) {
        {
#line 181
        free((void *)a);
#line 182
        tmp___1 = gettext("Out of memory\n");
#line 182
        printf((char const   */* __restrict  */)tmp___1);
        }
#line 183
        return (1);
      }
#line 185
      a = newa;
    }
    {
#line 187
    tmp___2 = n;
#line 187
    n ++;
#line 187
    *(a + tmp___2) = t;
#line 188
    *(a + n) = (char *)((void *)0);
#line 190
    t = get_token((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  r = cmd_run(a);
  }
#line 194
  if (debug_mode & 1) {
    {
#line 194
    printf((char const   */* __restrict  */)"Return in jtag_parse_line r=%d\n", r);
    }
  }
  {
#line 195
  free((void *)a);
  }
#line 196
  return (r);
}
}
#line 200 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static int jtag_readline_multiple_commands_support(char *line ) 
{ 
  int r ;
  char *nextcmd ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 203
  nextcmd = line;
#line 205
  if (! line) {
#line 206
    return (1);
  } else {
    {
#line 205
    tmp = strlen((char const   *)line);
    }
#line 205
    if (! (tmp > 0UL)) {
#line 206
      return (1);
    }
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    line = nextcmd;
#line 211
    nextcmd = strstr((char const   *)nextcmd, "::");
    }
#line 213
    if (nextcmd) {
#line 214
      tmp___0 = nextcmd;
#line 214
      nextcmd ++;
#line 214
      *tmp___0 = (char)0;
#line 215
      nextcmd ++;
      {
#line 216
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 216
        if (! ((int )*line == 58)) {
#line 216
          goto while_break___0;
        }
#line 216
        line ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 219
    r = jtag_parse_line(line);
#line 221
    chain_flush(chain);
    }
#line 208
    if (nextcmd) {
#line 208
      if (! r) {
#line 208
        goto while_break;
      }
    } else {
#line 208
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (r);
}
}
#line 228 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static void jtag_readline_loop(char const   *prompt ) 
{ 
  char line[1024] ;
  char *tmp ;

  {
#line 250
  line[0] = (char)0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    jtag_readline_multiple_commands_support(line);
#line 254
    printf((char const   */* __restrict  */)"%s", prompt);
#line 255
    fflush(stdout);
#line 251
    tmp = fgets((char */* __restrict  */)(line), 1023, (FILE */* __restrict  */)stdin);
    }
#line 251
    if (! tmp) {
#line 251
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 261 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static int jtag_parse_stream(FILE *f ) 
{ 
  int go ;
  char *line ;
  size_t n ;
  size_t tmp ;
  __ssize_t tmp___0 ;

  {
#line 264
  go = 1;
#line 265
  line = (char *)((void *)0);
#line 266
  n = (size_t )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (go) {
      {
#line 268
      tmp___0 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& n),
                        (FILE */* __restrict  */)f);
      }
#line 268
      if (! (tmp___0 != -1L)) {
#line 268
        goto while_break;
      }
    } else {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp = strlen((char const   *)line);
    }
#line 269
    if (tmp > 0UL) {
#line 269
      if ((int )*(line + 0) != 35) {
        {
#line 270
        go = jtag_parse_line(line);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  free((void *)line);
  }
#line 274
  return (go);
}
}
#line 277 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
int jtag_parse_file(char const   *filename ) 
{ 
  FILE *f ;
  int go ;

  {
  {
#line 283
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 284
  if (! f) {
#line 285
    return (-1);
  }
  {
#line 287
  go = jtag_parse_stream(f);
#line 289
  fclose(f);
  }
#line 290
  if (debug_mode & 1) {
    {
#line 290
    printf((char const   */* __restrict  */)"File Closed gp=%d\n", go);
    }
  }
#line 291
  return (go);
}
}
#line 294 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static int jtag_parse_rc(void) 
{ 
  char *home ;
  char *tmp ;
  char *file ;
  int go ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 297
  tmp = getenv("HOME");
#line 297
  home = tmp;
  }
#line 301
  if (! home) {
#line 302
    return (1);
  }
  {
#line 304
  tmp___0 = strlen((char const   *)home);
#line 304
  tmp___1 = strlen(".jtag");
#line 304
  tmp___2 = strlen("rc");
#line 304
  tmp___3 = malloc(((tmp___0 + tmp___1) + tmp___2) + 3UL);
#line 304
  file = (char *)tmp___3;
  }
#line 305
  if (! file) {
#line 306
    return (1);
  }
  {
#line 308
  strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)home);
#line 309
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 310
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)".jtag");
#line 311
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 312
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"rc");
#line 314
  go = jtag_parse_file((char const   *)file);
#line 316
  free((void *)file);
  }
#line 318
  return (go);
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static void cleanup(void) 
{ 


  {
  {
#line 324
  cfi_array_free(cfi_array);
#line 325
  cfi_array = (cfi_array_t *)((void *)0);
  }
#line 327
  if (bus) {
    {
#line 328
    (*((bus->driver)->free_bus))(bus);
#line 329
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 331
  chain_free(chain);
#line 332
  chain = (chain_t *)((void *)0);
  }
#line 333
  return;
}
}
#line 360
int main(int argc , char * const  *argv ) ;
#line 360 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
static struct option long_options[5]  = {      {"version", 0, (int *)0, 'v'}, 
        {"norc", 0, (int *)0, 'n'}, 
        {"interactive", 0, (int *)0, 'i'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 335 "/home/khheo/project/benchmark/urjtag-0.8/src/jtag.c"
int main(int argc , char * const  *argv ) 
{ 
  int go ;
  int i ;
  int c ;
  int norc ;
  int help ;
  int version ;
  char *tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int option_index ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 338
  go = 0;
#line 341
  norc = 0;
#line 342
  help = 0;
#line 343
  version = 0;
#line 345
  tmp___0 = geteuid();
  }
#line 345
  if (tmp___0 == 0U) {
    {
#line 345
    tmp___1 = getuid();
    }
#line 345
    if (tmp___1 != 0U) {
      {
#line 347
      tmp = gettext("\'%s\' must not be run suid root!\n");
#line 347
      printf((char const   */* __restrict  */)tmp, "jtag");
      }
#line 348
      return (-1);
    }
  }
  {
#line 353
  setlocale(6, "");
#line 354
  bindtextdomain("urjtag", "/usr/local/share/locale");
#line 355
  textdomain("urjtag");
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 370
    option_index = 0;
#line 372
    c = getopt_long(argc, argv, "vnhi", (struct option  const  *)(long_options), & option_index);
    }
#line 376
    if (c == -1) {
#line 377
      goto while_break;
    }
    {
#line 381
    if (c == 118) {
#line 381
      goto case_118;
    }
#line 385
    if (c == 110) {
#line 385
      goto case_110;
    }
#line 389
    if (c == 105) {
#line 389
      goto case_105;
    }
#line 394
    goto switch_default;
    case_118: /* CIL Label */ 
#line 382
    version = 1;
#line 383
    goto switch_break;
    case_110: /* CIL Label */ 
#line 386
    norc = 1;
#line 387
    goto switch_break;
    case_105: /* CIL Label */ 
#line 390
    interactive = 1;
#line 391
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 395
    help = 1;
#line 396
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if (help) {
    {
#line 403
    tmp___2 = gettext("%s #%s\n");
#line 403
    printf((char const   */* __restrict  */)tmp___2, "UrJTAG 0.8", "1067");
#line 404
    printf((char const   */* __restrict  */)"\n");
#line 406
    tmp___3 = gettext("Usage: %s [OPTION] [FILE]\n");
#line 406
    printf((char const   */* __restrict  */)tmp___3, "jtag");
#line 407
    printf((char const   */* __restrict  */)"\n");
#line 409
    tmp___4 = gettext("  -h, --help          display this help and exit\n");
#line 409
    printf((char const   */* __restrict  */)tmp___4);
#line 410
    tmp___5 = gettext("  -v, --version       display version information and exit\n");
#line 410
    printf((char const   */* __restrict  */)tmp___5);
#line 411
    printf((char const   */* __restrict  */)"\n");
#line 412
    tmp___6 = gettext("  -n, --norc          disable reading ~/.jtag/rc on startup\n");
#line 412
    printf((char const   */* __restrict  */)tmp___6);
#line 413
    tmp___7 = gettext("  -i, --interactive   enter interactive mode after reading files\n");
#line 413
    printf((char const   */* __restrict  */)tmp___7);
#line 414
    printf((char const   */* __restrict  */)"\n");
#line 415
    tmp___8 = gettext("  [FILE]              file containing commands to execute\n");
#line 415
    printf((char const   */* __restrict  */)tmp___8);
#line 416
    printf((char const   */* __restrict  */)"\n");
#line 418
    tmp___9 = gettext("  Please report bugs at http://www.urjtag.org\n");
#line 418
    printf((char const   */* __restrict  */)tmp___9);
#line 420
    exit(0);
    }
  }
#line 423
  if (version) {
    {
#line 425
    tmp___10 = gettext("\n%s #%s\n\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n");
#line 425
    printf((char const   */* __restrict  */)tmp___10, "UrJTAG 0.8", "1067");
#line 430
    tmp___11 = gettext("\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n");
#line 430
    printf((char const   */* __restrict  */)tmp___11);
#line 445
    exit(0);
    }
  }
#line 450
  if (argc > optind) {
#line 451
    i = optind;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (i < argc)) {
#line 451
        goto while_break___0;
      }
      {
#line 452
      chain = chain_alloc();
      }
#line 453
      if (! chain) {
        {
#line 454
        tmp___12 = gettext("Out of memory\n");
#line 454
        printf((char const   */* __restrict  */)tmp___12);
        }
#line 455
        return (-1);
      }
      {
#line 458
      go = jtag_parse_file((char const   *)*(argv + i));
#line 459
      cleanup();
      }
#line 460
      if (go < 0) {
        {
#line 461
        tmp___13 = gettext("Unable to open file `%s\'!\n");
#line 461
        printf((char const   */* __restrict  */)tmp___13, *(argv + i));
        }
#line 462
        goto while_break___0;
      }
#line 451
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 466
    if (! interactive) {
#line 466
      return (0);
    }
  }
  {
#line 470
  tmp___15 = isatty(0);
  }
#line 470
  if (! tmp___15) {
    {
#line 471
    chain = chain_alloc();
    }
#line 472
    if (! chain) {
      {
#line 473
      tmp___14 = gettext("Out of memory\n");
#line 473
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 474
      return (-1);
    }
    {
#line 477
    jtag_parse_stream(stdin);
#line 479
    cleanup();
    }
#line 481
    return (0);
  }
  {
#line 485
  tmp___16 = gettext("\n%s #%s\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n\n%s is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nThere is absolutely no warranty for %s.\n\n");
#line 485
  printf((char const   */* __restrict  */)tmp___16, "UrJTAG 0.8", "1067", "UrJTAG",
         "UrJTAG");
#line 495
  chain = chain_alloc();
  }
#line 496
  if (! chain) {
    {
#line 497
    tmp___17 = gettext("Out of memory\n");
#line 497
    printf((char const   */* __restrict  */)tmp___17);
    }
#line 498
    return (-1);
  }
  {
#line 501
  tmp___18 = gettext("WARNING: %s may damage your hardware!\n");
#line 501
  printf((char const   */* __restrict  */)tmp___18, "UrJTAG");
#line 502
  tmp___19 = gettext("Type \"quit\" to exit, \"help\" for help.\n\n");
#line 502
  printf((char const   */* __restrict  */)tmp___19);
#line 505
  jtag_create_jtagdir();
  }
#line 508
  if (norc) {
#line 508
    go = 1;
  } else {
    {
#line 508
    tmp___20 = jtag_parse_rc();
#line 508
    go = tmp___20;
    }
  }
#line 510
  if (go) {
    {
#line 518
    jtag_readline_loop("jtag> ");
    }
  }
  {
#line 526
  cleanup();
  }
#line 528
  return (0);
}
}
