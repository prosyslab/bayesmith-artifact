/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 263 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef unsigned int uInt;
#line 264 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef unsigned long uLong;
#line 279 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef void *voidpf;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 261 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef unsigned char Byte;
#line 270 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef Byte Bytef;
#line 275 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef uLong uLongf;
#line 89 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
struct internal_state ;
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef struct z_stream_s z_stream;
#line 112 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef z_stream *z_streamp;
#line 1355 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
struct internal_state {
   int dummy ;
};
#line 272 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef char charf;
#line 273 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef int intf;
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
struct z_stream_s___0 {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state___0 *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef struct z_stream_s___0 z_stream___0;
#line 112 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef z_stream___0 *z_streamp___0;
#line 118 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 118 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef struct gz_header_s gz_header;
#line 135 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef gz_header *gz_headerp;
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
typedef unsigned char uch;
#line 48 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
typedef uch uchf;
#line 49 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
typedef unsigned short ush;
#line 50 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
typedef ush ushf;
#line 51 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
typedef unsigned long ulg;
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
union __anonunion_fc_152553610 {
   ush freq ;
   ush code ;
};
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
union __anonunion_dl_152553611 {
   ush dad ;
   ush len ;
};
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
struct ct_data_s {
   union __anonunion_fc_152553610 fc ;
   union __anonunion_dl_152553611 dl ;
};
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct ct_data_s ct_data;
#line 78
struct static_tree_desc_s ;
#line 78 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct static_tree_desc_s static_tree_desc;
#line 80 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
struct tree_desc_s {
   ct_data *dyn_tree ;
   int max_code ;
   static_tree_desc *stat_desc ;
};
#line 80 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct tree_desc_s tree_desc;
#line 86 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef ush Pos;
#line 87 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef Pos Posf;
#line 88 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef unsigned int IPos;
#line 94 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
struct internal_state___0 {
   z_streamp___0 strm ;
   int status ;
   Bytef *pending_buf ;
   ulg pending_buf_size ;
   Bytef *pending_out ;
   uInt pending ;
   int wrap ;
   gz_headerp gzhead ;
   uInt gzindex ;
   Byte method ;
   int last_flush ;
   uInt w_size ;
   uInt w_bits ;
   uInt w_mask ;
   Bytef *window ;
   ulg window_size ;
   Posf *prev ;
   Posf *head ;
   uInt ins_h ;
   uInt hash_size ;
   uInt hash_bits ;
   uInt hash_mask ;
   uInt hash_shift ;
   long block_start ;
   uInt match_length ;
   IPos prev_match ;
   int match_available ;
   uInt strstart ;
   uInt match_start ;
   uInt lookahead ;
   uInt prev_length ;
   uInt max_chain_length ;
   uInt max_lazy_match ;
   int level ;
   int strategy ;
   uInt good_match ;
   int nice_match ;
   struct ct_data_s dyn_ltree[573] ;
   struct ct_data_s dyn_dtree[61] ;
   struct ct_data_s bl_tree[39] ;
   struct tree_desc_s l_desc ;
   struct tree_desc_s d_desc ;
   struct tree_desc_s bl_desc ;
   ush bl_count[16] ;
   int heap[573] ;
   int heap_len ;
   int heap_max ;
   uch depth[573] ;
   uchf *l_buf ;
   uInt lit_bufsize ;
   uInt last_lit ;
   ushf *d_buf ;
   ulg opt_len ;
   ulg static_len ;
   uInt matches ;
   int last_eob_len ;
   ush bi_buf ;
   int bi_valid ;
};
#line 94 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct internal_state___0 deflate_state;
#line 121 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
struct static_tree_desc_s {
   ct_data const   *static_tree ;
   intf const   *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
};
#line 24 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.h"
struct __anonstruct_code_1002866527 {
   unsigned char op ;
   unsigned char bits ;
   unsigned short val ;
};
#line 24 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.h"
typedef struct __anonstruct_code_1002866527 code;
#line 47
enum __anonenum_codetype_576538390 {
    CODES = 0,
    LENS = 1,
    DISTS = 2
} ;
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.h"
typedef enum __anonenum_codetype_576538390 codetype;
#line 20 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.h"
enum __anonenum_inflate_mode_317123664 {
    HEAD = 0,
    FLAGS = 1,
    TIME = 2,
    OS = 3,
    EXLEN = 4,
    EXTRA = 5,
    NAME = 6,
    COMMENT = 7,
    HCRC = 8,
    DICTID = 9,
    DICT = 10,
    TYPE = 11,
    TYPEDO = 12,
    STORED = 13,
    COPY = 14,
    TABLE = 15,
    LENLENS = 16,
    CODELENS = 17,
    LEN = 18,
    LENEXT = 19,
    DIST = 20,
    DISTEXT = 21,
    MATCH = 22,
    LIT = 23,
    CHECK = 24,
    LENGTH = 25,
    DONE = 26,
    BAD = 27,
    MEM = 28,
    SYNC = 29
} ;
#line 20 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.h"
typedef enum __anonenum_inflate_mode_317123664 inflate_mode;
#line 77 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.h"
struct inflate_state {
   inflate_mode mode ;
   int last ;
   int wrap ;
   int havedict ;
   int flags ;
   unsigned int dmax ;
   unsigned long check ;
   unsigned long total ;
   gz_headerp head ;
   unsigned int wbits ;
   unsigned int wsize ;
   unsigned int whave ;
   unsigned int write ;
   unsigned char *window ;
   unsigned long hold ;
   unsigned int bits ;
   unsigned int length ;
   unsigned int offset ;
   unsigned int extra ;
   code const   *lencode ;
   code const   *distcode ;
   unsigned int lenbits ;
   unsigned int distbits ;
   unsigned int ncode ;
   unsigned int nlen ;
   unsigned int ndist ;
   unsigned int have ;
   code *next ;
   unsigned short lens[320] ;
   unsigned short work[288] ;
   code codes[2048] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 280 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zconf.h"
typedef void *voidp;
#line 1075 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
typedef voidp gzFile;
#line 56 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
struct gz_stream {
   z_stream stream ;
   int z_err ;
   int z_eof ;
   FILE *file ;
   Byte *inbuf ;
   Byte *outbuf ;
   uLong crc ;
   char *msg ;
   char *path ;
   int transparent ;
   char mode ;
   off_t start ;
   off_t in ;
   off_t out ;
   int back ;
   int last ;
};
#line 56 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
typedef struct gz_stream gz_stream;
#line 78 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct static_tree_desc_s___0 static_tree_desc___0;
#line 80 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
struct tree_desc_s___0 {
   ct_data *dyn_tree ;
   int max_code ;
   static_tree_desc___0 *stat_desc ;
};
#line 94 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
struct internal_state___1 {
   z_streamp___0 strm ;
   int status ;
   Bytef *pending_buf ;
   ulg pending_buf_size ;
   Bytef *pending_out ;
   uInt pending ;
   int wrap ;
   gz_headerp gzhead ;
   uInt gzindex ;
   Byte method ;
   int last_flush ;
   uInt w_size ;
   uInt w_bits ;
   uInt w_mask ;
   Bytef *window ;
   ulg window_size ;
   Posf *prev ;
   Posf *head ;
   uInt ins_h ;
   uInt hash_size ;
   uInt hash_bits ;
   uInt hash_mask ;
   uInt hash_shift ;
   long block_start ;
   uInt match_length ;
   IPos prev_match ;
   int match_available ;
   uInt strstart ;
   uInt match_start ;
   uInt lookahead ;
   uInt prev_length ;
   uInt max_chain_length ;
   uInt max_lazy_match ;
   int level ;
   int strategy ;
   uInt good_match ;
   int nice_match ;
   struct ct_data_s dyn_ltree[573] ;
   struct ct_data_s dyn_dtree[61] ;
   struct ct_data_s bl_tree[39] ;
   struct tree_desc_s___0 l_desc ;
   struct tree_desc_s___0 d_desc ;
   struct tree_desc_s___0 bl_desc ;
   ush bl_count[16] ;
   int heap[573] ;
   int heap_len ;
   int heap_max ;
   uch depth[573] ;
   uchf *l_buf ;
   uInt lit_bufsize ;
   uInt last_lit ;
   ushf *d_buf ;
   ulg opt_len ;
   ulg static_len ;
   uInt matches ;
   int last_eob_len ;
   ush bi_buf ;
   int bi_valid ;
};
#line 94 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
typedef struct internal_state___1 deflate_state___0;
#line 66 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
enum __anonenum_block_state_307922230 {
    need_more = 0,
    block_done = 1,
    finish_started = 2,
    finish_done = 3
} ;
#line 66 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
typedef enum __anonenum_block_state_307922230 block_state;
#line 123 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
struct config_s {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
   block_state (*func)(deflate_state___0 *s , int flush ) ;
};
#line 123 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
typedef struct config_s config;
#line 161 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
struct static_tree_desc_s___0 {
   int dummy ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 39 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
typedef unsigned int u4;
#line 1085 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef unsigned long png_uint_32;
#line 1086 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef long png_int_32;
#line 1087 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef unsigned short png_uint_16;
#line 1089 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef unsigned char png_byte;
#line 1097 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef size_t png_size_t;
#line 1162 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 1165 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef void *png_voidp;
#line 1166 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef png_byte *png_bytep;
#line 1167 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 1169 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 1171 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef char const   *png_const_charp;
#line 1172 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef char *png_charp;
#line 1194 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef char **png_charpp;
#line 489 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 489 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_color_struct png_color;
#line 495 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_color *png_colorp;
#line 498 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 498 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_color_16_struct png_color_16;
#line 506 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_color_16 *png_color_16p;
#line 509 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 509 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_color_8_struct png_color_8;
#line 517 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_color_8 *png_color_8p;
#line 524 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 524 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 532 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 540 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 540 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 547 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 598 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 598 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_time_struct png_time;
#line 607 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_time *png_timep;
#line 616 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   png_size_t size ;
   png_byte location ;
};
#line 616 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 626 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 1011 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   png_uint_32 rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 1011 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_row_info_struct png_row_info;
#line 1021 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_row_info *png_row_infop;
#line 1030
struct png_struct_def ;
#line 1030 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_struct_def png_struct;
#line 1031 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_struct *png_structp;
#line 1092 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_struct_def {
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   png_voidp io_ptr ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   z_stream zstream ;
   png_bytep zbuf ;
   png_size_t zbuf_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   png_uint_32 rowbytes ;
   png_uint_32 irowbytes ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep sub_row ;
   png_bytep up_row ;
   png_bytep avg_row ;
   png_bytep paeth_row ;
   png_row_info row_info ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte chunk_name[5] ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_byte background_gamma_type ;
   png_color_16 background ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   png_color_8 sig_bit ;
   png_bytep trans ;
   png_color_16 trans_values ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   png_uint_16p hist ;
   png_charp time_buffer ;
   png_uint_32 free_me ;
   png_voidp user_chunk_ptr ;
   int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) ;
   int num_chunk_list ;
   png_bytep chunk_list ;
   png_uint_32 mng_features_permitted ;
   png_bytep big_row_buf ;
   png_byte compression_type ;
};
#line 145 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
struct __anonstruct_compression_state_568980115 {
   char *input ;
   int input_len ;
   int num_output_ptr ;
   int max_output_ptr ;
   png_charpp output_ptr ;
};
#line 145 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
typedef struct __anonstruct_compression_state_568980115 compression_state;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 1188 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef png_byte **png_bytepp;
#line 559 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   png_size_t text_length ;
};
#line 559 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_text_struct png_text;
#line 578 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_text *png_textp;
#line 669 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
struct png_info_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   png_uint_32 rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   png_byte srgb_intent ;
   int num_text ;
   int max_text ;
   png_textp text ;
   png_time mod_time ;
   png_color_8 sig_bit ;
   png_bytep trans ;
   png_color_16 trans_values ;
   png_color_16 background ;
   png_int_32 x_offset ;
   png_int_32 y_offset ;
   png_byte offset_unit_type ;
   png_uint_32 x_pixels_per_unit ;
   png_uint_32 y_pixels_per_unit ;
   png_byte phys_unit_type ;
   png_uint_16p hist ;
   png_charp pcal_purpose ;
   png_int_32 pcal_X0 ;
   png_int_32 pcal_X1 ;
   png_charp pcal_units ;
   png_charpp pcal_params ;
   png_byte pcal_type ;
   png_byte pcal_nparams ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   png_size_t unknown_chunks_num ;
   png_charp iccp_name ;
   png_charp iccp_profile ;
   png_uint_32 iccp_proflen ;
   png_byte iccp_compression ;
   png_sPLT_tp splt_palettes ;
   png_uint_32 splt_palettes_num ;
   png_byte scal_unit ;
   png_charp scal_s_width ;
   png_charp scal_s_height ;
   png_bytepp row_pointers ;
   png_fixed_point int_gamma ;
   png_fixed_point int_x_white ;
   png_fixed_point int_y_white ;
   png_fixed_point int_x_red ;
   png_fixed_point int_y_red ;
   png_fixed_point int_x_green ;
   png_fixed_point int_y_green ;
   png_fixed_point int_x_blue ;
   png_fixed_point int_y_blue ;
};
#line 669 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef struct png_info_struct png_info;
#line 907 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_info *png_infop;
#line 908 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_info **png_infopp;
#line 1380 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_struct **png_structpp;
#line 1179 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngconf.h"
typedef FILE *png_FILE_p;
#line 548 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_sPLT_t **png_sPLT_tpp;
#line 627 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 42 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.h"
struct minitiff_info {
   void (*error_handler)(char const   *msg ) ;
   void (*warning_handler)(char const   *msg ) ;
   int byte_order ;
   size_t width ;
   size_t height ;
   unsigned int bits_per_sample ;
   unsigned int compression ;
   unsigned int photometric ;
   size_t strip_offsets_count ;
   long *strip_offsets ;
   unsigned int samples_per_pixel ;
   unsigned int rows_per_strip ;
};
#line 54 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
struct minitiff_get_struct {
   unsigned int (*get_ushort)(unsigned char const   *buf_ptr ) ;
   unsigned long (*get_ulong)(unsigned char const   *buf_ptr ) ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 50 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmio.h"
struct pnm_struct {
   unsigned int type_code ;
   unsigned int width ;
   unsigned int height ;
   unsigned int maxval ;
};
#line 50 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmio.h"
typedef struct pnm_struct pnm_struct;
#line 43 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.h"
struct GIFScreen {
   unsigned int Width ;
   unsigned int Height ;
   unsigned int GlobalColorFlag ;
   unsigned int ColorResolution ;
   unsigned int SortFlag ;
   unsigned int GlobalNumColors ;
   unsigned int Background ;
   unsigned int PixelAspectRatio ;
   unsigned char GlobalColorTable[768] ;
};
#line 60 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.h"
struct GIFImage {
   struct GIFScreen *Screen ;
   unsigned int LeftPos ;
   unsigned int TopPos ;
   unsigned int Width ;
   unsigned int Height ;
   unsigned int LocalColorFlag ;
   unsigned int InterlaceFlag ;
   unsigned int SortFlag ;
   unsigned int LocalNumColors ;
   unsigned char LocalColorTable[768] ;
   unsigned char **Rows ;
};
#line 79 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.h"
struct GIFExtension {
   struct GIFScreen *Screen ;
   unsigned char Label ;
   unsigned int BufferSize ;
   unsigned char *Buffer ;
};
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.h"
struct GIFGraphicCtlExt {
   unsigned int DisposalMethod ;
   unsigned int InputFlag ;
   unsigned int TransparentFlag ;
   unsigned int DelayTime ;
   unsigned int Transparent ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_725419627 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_725419627 __mbstate_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
struct __anonstruct__G_fpos_t_800156284 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
typedef struct __anonstruct__G_fpos_t_800156284 _G_fpos_t;
#line 78 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 36 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 22 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.h"
typedef int bitset_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 189 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct __anonstruct_v_1022237947 {
   char const   *etmp ;
};
#line 189 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct exception_context {
   jmp_buf *penv ;
   int caught ;
   struct __anonstruct_v_1022237947  volatile  v ;
};
#line 194 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct opng_image_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   int bit_depth ;
   int color_type ;
   int compression_type ;
   int filter_type ;
   int interlace_type ;
   png_bytepp row_pointers ;
   png_colorp palette ;
   int num_palette ;
   png_color_16p background_ptr ;
   png_color_16 background ;
   png_uint_16p hist ;
   png_color_8p sig_bit_ptr ;
   png_color_8 sig_bit ;
   png_bytep trans ;
   int num_trans ;
   png_color_16p trans_values_ptr ;
   png_color_16 trans_values ;
   png_unknown_chunkp unknowns ;
   int num_unknowns ;
};
#line 214 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct opng_info_struct {
   int input_is_png ;
   int valid ;
   png_uint_32 file_size ;
   png_uint_32 idat_size ;
   png_uint_32 best_file_size ;
   png_uint_32 best_idat_size ;
   png_uint_32 total_idat_size ;
   unsigned int num_idat_chunks ;
   png_uint_32 crt_row ;
   png_uint_32 last_row ;
   int crt_ipass ;
   int last_ipass ;
   png_uint_32 reductions ;
   bitset_t compr_level_set ;
   bitset_t mem_level_set ;
   bitset_t strategy_set ;
   bitset_t filter_set ;
   int best_compr_level ;
   int best_mem_level ;
   int best_strategy ;
   int best_filter ;
   int num_iterations ;
};
#line 229 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct cmdline_struct {
   int has_files ;
   int help ;
   int ver ;
   int optim_level ;
   int interlace ;
   int keep ;
   int quiet ;
   int nb ;
   int nc ;
   int np ;
   int nz ;
   int fix ;
   int force ;
   int full ;
   int log ;
   int preserve ;
   int simulate ;
   bitset_t compr_level_set ;
   bitset_t mem_level_set ;
   bitset_t strategy_set ;
   bitset_t filter_set ;
   int window_bits ;
};
#line 242 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct global_struct {
   FILE *logfile ;
   unsigned int err_count ;
   unsigned int fix_count ;
};
#line 1298
enum __anonenum_action_828115248 {
    none = 0,
    join = 1,
    recompress = 2,
    create = 3
} ;
#line 221 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
char const   *zlibVersion(void) ;
#line 966
uLong zlibCompileFlags(void) ;
#line 1358
char const   *zError(int err ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.h"
char const   * const  z_errmsg[10] ;
#line 261
voidpf zcalloc(voidpf opaque , unsigned int items , unsigned int size ) ;
#line 262
void zcfree(voidpf opaque , voidpf ptr ) ;
#line 14 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
char const   * const  z_errmsg[10]  = 
#line 14 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
  {      (char const   */* const  */)"need dictionary",      (char const   */* const  */)"stream end",      (char const   */* const  */)"",      (char const   */* const  */)"file error", 
        (char const   */* const  */)"stream error",      (char const   */* const  */)"data error",      (char const   */* const  */)"insufficient memory",      (char const   */* const  */)"buffer error", 
        (char const   */* const  */)"incompatible version",      (char const   */* const  */)""};
#line 27 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
char const   *zlibVersion(void) 
{ 


  {
#line 29
  return ("1.2.3-optipng");
}
}
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
uLong zlibCompileFlags(void) 
{ 
  uLong flags ;

  {
#line 36
  flags = (uLong )0;
  {
#line 38
  if (sizeof(uInt ) == 2UL) {
#line 38
    goto case_2;
  }
#line 39
  if (sizeof(uInt ) == 4UL) {
#line 39
    goto case_4;
  }
#line 40
  if (sizeof(uInt ) == 8UL) {
#line 40
    goto case_8;
  }
#line 41
  goto switch_default;
  case_2: /* CIL Label */ 
#line 38
  goto switch_break;
  case_4: /* CIL Label */ 
#line 39
  flags ++;
#line 39
  goto switch_break;
  case_8: /* CIL Label */ 
#line 40
  flags += 2UL;
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 41
  flags += 3UL;
  switch_break: /* CIL Label */ ;
  }
  {
#line 44
  if (sizeof(uLong ) == 2UL) {
#line 44
    goto case_2___0;
  }
#line 45
  if (sizeof(uLong ) == 4UL) {
#line 45
    goto case_4___0;
  }
#line 46
  if (sizeof(uLong ) == 8UL) {
#line 46
    goto case_8___0;
  }
#line 47
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 44
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 45
  flags += (uLong )(1 << 2);
#line 45
  goto switch_break___0;
  case_8___0: /* CIL Label */ 
#line 46
  flags += (uLong )(2 << 2);
#line 46
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 47
  flags += (uLong )(3 << 2);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 50
  if (sizeof(voidpf ) == 2UL) {
#line 50
    goto case_2___1;
  }
#line 51
  if (sizeof(voidpf ) == 4UL) {
#line 51
    goto case_4___1;
  }
#line 52
  if (sizeof(voidpf ) == 8UL) {
#line 52
    goto case_8___1;
  }
#line 53
  goto switch_default___1;
  case_2___1: /* CIL Label */ 
#line 50
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 51
  flags += (uLong )(1 << 4);
#line 51
  goto switch_break___1;
  case_8___1: /* CIL Label */ 
#line 52
  flags += (uLong )(2 << 4);
#line 52
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 53
  flags += (uLong )(3 << 4);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 56
  if (sizeof(off_t ) == 2UL) {
#line 56
    goto case_2___2;
  }
#line 57
  if (sizeof(off_t ) == 4UL) {
#line 57
    goto case_4___2;
  }
#line 58
  if (sizeof(off_t ) == 8UL) {
#line 58
    goto case_8___2;
  }
#line 59
  goto switch_default___2;
  case_2___2: /* CIL Label */ 
#line 56
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
#line 57
  flags += (uLong )(1 << 6);
#line 57
  goto switch_break___2;
  case_8___2: /* CIL Label */ 
#line 58
  flags += (uLong )(2 << 6);
#line 58
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 59
  flags += (uLong )(3 << 6);
  switch_break___2: /* CIL Label */ ;
  }
#line 77
  flags += (uLong )(1L << 16);
#line 80
  flags += (uLong )(1L << 17);
#line 112
  return (flags);
}
}
#line 133 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
char const   *zError(int err ) 
{ 


  {
#line 136
  return ((char const   *)z_errmsg[2 - err]);
}
}
#line 300 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
voidpf zcalloc(voidpf opaque , unsigned int items , unsigned int size ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  voidpf tmp___1 ;

  {
#line 305
  if (opaque) {
#line 305
    items += size - size;
  }
#line 306
  if (sizeof(uInt ) > 2UL) {
    {
#line 306
    tmp = malloc((size_t )(items * size));
#line 306
    tmp___1 = tmp;
    }
  } else {
    {
#line 306
    tmp___0 = calloc((size_t )items, (size_t )size);
#line 306
    tmp___1 = tmp___0;
    }
  }
#line 306
  return (tmp___1);
}
}
#line 310 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zutil.c"
void zcfree(voidpf opaque , voidpf ptr ) 
{ 


  {
  {
#line 314
  free(ptr);
  }
#line 315
  if (opaque) {
#line 315
    return;
  }
#line 316
  return;
}
}
#line 372 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
int inflate(z_streamp strm , int flush ) ;
#line 471
int inflateEnd(z_streamp strm ) ;
#line 1056
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1328
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 26 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/uncompr.c"
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  z_stream stream ;
  int err ;

  {
#line 35
  stream.next_in = (Bytef *)source;
#line 36
  stream.avail_in = (uInt )sourceLen;
#line 38
  if ((uLong )stream.avail_in != sourceLen) {
#line 38
    return (-5);
  }
#line 40
  stream.next_out = dest;
#line 41
  stream.avail_out = (uInt )*destLen;
#line 42
  if ((uLong )stream.avail_out != *destLen) {
#line 42
    return (-5);
  }
  {
#line 44
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 45
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 47
  err = inflateInit_(& stream, "1.2.3-optipng", (int )sizeof(z_stream ));
  }
#line 48
  if (err != 0) {
#line 48
    return (err);
  }
  {
#line 50
  err = inflate(& stream, 4);
  }
#line 51
  if (err != 1) {
    {
#line 52
    inflateEnd(& stream);
    }
#line 53
    if (err == 2) {
#line 54
      return (-3);
    } else
#line 53
    if (err == -5) {
#line 53
      if (stream.avail_in == 0U) {
#line 54
        return (-3);
      }
    }
#line 55
    return (err);
  }
  {
#line 57
  *destLen = stream.total_out;
#line 59
  err = inflateEnd(& stream);
  }
#line 60
  return (err);
}
}
#line 282 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.h"
void _tr_init(deflate_state *s ) ;
#line 283
int _tr_tally(deflate_state *s , unsigned int dist , unsigned int lc ) ;
#line 284
void _tr_flush_block(deflate_state *s , charf *buf___1 , ulg stored_len , int eof ) ;
#line 286
void _tr_align(deflate_state *s ) ;
#line 287
void _tr_stored_block(deflate_state *s , charf *buf___1 , ulg stored_len , int eof ) ;
#line 304
uch const   _length_code[256] ;
#line 305
uch const   _dist_code[512] ;
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static int const   extra_lbits[29]  = 
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )0};
#line 64 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static int const   extra_dbits[30]  = 
#line 64
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )6,      (int const   )6, 
        (int const   )7,      (int const   )7,      (int const   )8,      (int const   )8, 
        (int const   )9,      (int const   )9,      (int const   )10,      (int const   )10, 
        (int const   )11,      (int const   )11,      (int const   )12,      (int const   )12, 
        (int const   )13,      (int const   )13};
#line 67 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static int const   extra_blbits[19]  = 
#line 67
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )3,      (int const   )7};
#line 70 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static uch const   bl_order[19]  = 
#line 70
  {      (uch const   )16,      (uch const   )17,      (uch const   )18,      (uch const   )0, 
        (uch const   )8,      (uch const   )7,      (uch const   )9,      (uch const   )6, 
        (uch const   )10,      (uch const   )5,      (uch const   )11,      (uch const   )4, 
        (uch const   )12,      (uch const   )3,      (uch const   )13,      (uch const   )2, 
        (uch const   )14,      (uch const   )1,      (uch const   )15};
#line 3 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
static ct_data const   static_ltree[288]  = 
#line 3 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
  {      {{(ush )12}, {(ush )8}}, 
        {{(ush )140}, {(ush )8}}, 
        {{(ush )76}, {(ush )8}}, 
        {{(ush )204}, {(ush )8}}, 
        {{(ush )44}, {(ush )8}}, 
        {{(ush )172}, {(ush )8}}, 
        {{(ush )108}, {(ush )8}}, 
        {{(ush )236}, {(ush )8}}, 
        {{(ush )28}, {(ush )8}}, 
        {{(ush )156}, {(ush )8}}, 
        {{(ush )92}, {(ush )8}}, 
        {{(ush )220}, {(ush )8}}, 
        {{(ush )60}, {(ush )8}}, 
        {{(ush )188}, {(ush )8}}, 
        {{(ush )124}, {(ush )8}}, 
        {{(ush )252}, {(ush )8}}, 
        {{(ush )2}, {(ush )8}}, 
        {{(ush )130}, {(ush )8}}, 
        {{(ush )66}, {(ush )8}}, 
        {{(ush )194}, {(ush )8}}, 
        {{(ush )34}, {(ush )8}}, 
        {{(ush )162}, {(ush )8}}, 
        {{(ush )98}, {(ush )8}}, 
        {{(ush )226}, {(ush )8}}, 
        {{(ush )18}, {(ush )8}}, 
        {{(ush )146}, {(ush )8}}, 
        {{(ush )82}, {(ush )8}}, 
        {{(ush )210}, {(ush )8}}, 
        {{(ush )50}, {(ush )8}}, 
        {{(ush )178}, {(ush )8}}, 
        {{(ush )114}, {(ush )8}}, 
        {{(ush )242}, {(ush )8}}, 
        {{(ush )10}, {(ush )8}}, 
        {{(ush )138}, {(ush )8}}, 
        {{(ush )74}, {(ush )8}}, 
        {{(ush )202}, {(ush )8}}, 
        {{(ush )42}, {(ush )8}}, 
        {{(ush )170}, {(ush )8}}, 
        {{(ush )106}, {(ush )8}}, 
        {{(ush )234}, {(ush )8}}, 
        {{(ush )26}, {(ush )8}}, 
        {{(ush )154}, {(ush )8}}, 
        {{(ush )90}, {(ush )8}}, 
        {{(ush )218}, {(ush )8}}, 
        {{(ush )58}, {(ush )8}}, 
        {{(ush )186}, {(ush )8}}, 
        {{(ush )122}, {(ush )8}}, 
        {{(ush )250}, {(ush )8}}, 
        {{(ush )6}, {(ush )8}}, 
        {{(ush )134}, {(ush )8}}, 
        {{(ush )70}, {(ush )8}}, 
        {{(ush )198}, {(ush )8}}, 
        {{(ush )38}, {(ush )8}}, 
        {{(ush )166}, {(ush )8}}, 
        {{(ush )102}, {(ush )8}}, 
        {{(ush )230}, {(ush )8}}, 
        {{(ush )22}, {(ush )8}}, 
        {{(ush )150}, {(ush )8}}, 
        {{(ush )86}, {(ush )8}}, 
        {{(ush )214}, {(ush )8}}, 
        {{(ush )54}, {(ush )8}}, 
        {{(ush )182}, {(ush )8}}, 
        {{(ush )118}, {(ush )8}}, 
        {{(ush )246}, {(ush )8}}, 
        {{(ush )14}, {(ush )8}}, 
        {{(ush )142}, {(ush )8}}, 
        {{(ush )78}, {(ush )8}}, 
        {{(ush )206}, {(ush )8}}, 
        {{(ush )46}, {(ush )8}}, 
        {{(ush )174}, {(ush )8}}, 
        {{(ush )110}, {(ush )8}}, 
        {{(ush )238}, {(ush )8}}, 
        {{(ush )30}, {(ush )8}}, 
        {{(ush )158}, {(ush )8}}, 
        {{(ush )94}, {(ush )8}}, 
        {{(ush )222}, {(ush )8}}, 
        {{(ush )62}, {(ush )8}}, 
        {{(ush )190}, {(ush )8}}, 
        {{(ush )126}, {(ush )8}}, 
        {{(ush )254}, {(ush )8}}, 
        {{(ush )1}, {(ush )8}}, 
        {{(ush )129}, {(ush )8}}, 
        {{(ush )65}, {(ush )8}}, 
        {{(ush )193}, {(ush )8}}, 
        {{(ush )33}, {(ush )8}}, 
        {{(ush )161}, {(ush )8}}, 
        {{(ush )97}, {(ush )8}}, 
        {{(ush )225}, {(ush )8}}, 
        {{(ush )17}, {(ush )8}}, 
        {{(ush )145}, {(ush )8}}, 
        {{(ush )81}, {(ush )8}}, 
        {{(ush )209}, {(ush )8}}, 
        {{(ush )49}, {(ush )8}}, 
        {{(ush )177}, {(ush )8}}, 
        {{(ush )113}, {(ush )8}}, 
        {{(ush )241}, {(ush )8}}, 
        {{(ush )9}, {(ush )8}}, 
        {{(ush )137}, {(ush )8}}, 
        {{(ush )73}, {(ush )8}}, 
        {{(ush )201}, {(ush )8}}, 
        {{(ush )41}, {(ush )8}}, 
        {{(ush )169}, {(ush )8}}, 
        {{(ush )105}, {(ush )8}}, 
        {{(ush )233}, {(ush )8}}, 
        {{(ush )25}, {(ush )8}}, 
        {{(ush )153}, {(ush )8}}, 
        {{(ush )89}, {(ush )8}}, 
        {{(ush )217}, {(ush )8}}, 
        {{(ush )57}, {(ush )8}}, 
        {{(ush )185}, {(ush )8}}, 
        {{(ush )121}, {(ush )8}}, 
        {{(ush )249}, {(ush )8}}, 
        {{(ush )5}, {(ush )8}}, 
        {{(ush )133}, {(ush )8}}, 
        {{(ush )69}, {(ush )8}}, 
        {{(ush )197}, {(ush )8}}, 
        {{(ush )37}, {(ush )8}}, 
        {{(ush )165}, {(ush )8}}, 
        {{(ush )101}, {(ush )8}}, 
        {{(ush )229}, {(ush )8}}, 
        {{(ush )21}, {(ush )8}}, 
        {{(ush )149}, {(ush )8}}, 
        {{(ush )85}, {(ush )8}}, 
        {{(ush )213}, {(ush )8}}, 
        {{(ush )53}, {(ush )8}}, 
        {{(ush )181}, {(ush )8}}, 
        {{(ush )117}, {(ush )8}}, 
        {{(ush )245}, {(ush )8}}, 
        {{(ush )13}, {(ush )8}}, 
        {{(ush )141}, {(ush )8}}, 
        {{(ush )77}, {(ush )8}}, 
        {{(ush )205}, {(ush )8}}, 
        {{(ush )45}, {(ush )8}}, 
        {{(ush )173}, {(ush )8}}, 
        {{(ush )109}, {(ush )8}}, 
        {{(ush )237}, {(ush )8}}, 
        {{(ush )29}, {(ush )8}}, 
        {{(ush )157}, {(ush )8}}, 
        {{(ush )93}, {(ush )8}}, 
        {{(ush )221}, {(ush )8}}, 
        {{(ush )61}, {(ush )8}}, 
        {{(ush )189}, {(ush )8}}, 
        {{(ush )125}, {(ush )8}}, 
        {{(ush )253}, {(ush )8}}, 
        {{(ush )19}, {(ush )9}}, 
        {{(ush )275}, {(ush )9}}, 
        {{(ush )147}, {(ush )9}}, 
        {{(ush )403}, {(ush )9}}, 
        {{(ush )83}, {(ush )9}}, 
        {{(ush )339}, {(ush )9}}, 
        {{(ush )211}, {(ush )9}}, 
        {{(ush )467}, {(ush )9}}, 
        {{(ush )51}, {(ush )9}}, 
        {{(ush )307}, {(ush )9}}, 
        {{(ush )179}, {(ush )9}}, 
        {{(ush )435}, {(ush )9}}, 
        {{(ush )115}, {(ush )9}}, 
        {{(ush )371}, {(ush )9}}, 
        {{(ush )243}, {(ush )9}}, 
        {{(ush )499}, {(ush )9}}, 
        {{(ush )11}, {(ush )9}}, 
        {{(ush )267}, {(ush )9}}, 
        {{(ush )139}, {(ush )9}}, 
        {{(ush )395}, {(ush )9}}, 
        {{(ush )75}, {(ush )9}}, 
        {{(ush )331}, {(ush )9}}, 
        {{(ush )203}, {(ush )9}}, 
        {{(ush )459}, {(ush )9}}, 
        {{(ush )43}, {(ush )9}}, 
        {{(ush )299}, {(ush )9}}, 
        {{(ush )171}, {(ush )9}}, 
        {{(ush )427}, {(ush )9}}, 
        {{(ush )107}, {(ush )9}}, 
        {{(ush )363}, {(ush )9}}, 
        {{(ush )235}, {(ush )9}}, 
        {{(ush )491}, {(ush )9}}, 
        {{(ush )27}, {(ush )9}}, 
        {{(ush )283}, {(ush )9}}, 
        {{(ush )155}, {(ush )9}}, 
        {{(ush )411}, {(ush )9}}, 
        {{(ush )91}, {(ush )9}}, 
        {{(ush )347}, {(ush )9}}, 
        {{(ush )219}, {(ush )9}}, 
        {{(ush )475}, {(ush )9}}, 
        {{(ush )59}, {(ush )9}}, 
        {{(ush )315}, {(ush )9}}, 
        {{(ush )187}, {(ush )9}}, 
        {{(ush )443}, {(ush )9}}, 
        {{(ush )123}, {(ush )9}}, 
        {{(ush )379}, {(ush )9}}, 
        {{(ush )251}, {(ush )9}}, 
        {{(ush )507}, {(ush )9}}, 
        {{(ush )7}, {(ush )9}}, 
        {{(ush )263}, {(ush )9}}, 
        {{(ush )135}, {(ush )9}}, 
        {{(ush )391}, {(ush )9}}, 
        {{(ush )71}, {(ush )9}}, 
        {{(ush )327}, {(ush )9}}, 
        {{(ush )199}, {(ush )9}}, 
        {{(ush )455}, {(ush )9}}, 
        {{(ush )39}, {(ush )9}}, 
        {{(ush )295}, {(ush )9}}, 
        {{(ush )167}, {(ush )9}}, 
        {{(ush )423}, {(ush )9}}, 
        {{(ush )103}, {(ush )9}}, 
        {{(ush )359}, {(ush )9}}, 
        {{(ush )231}, {(ush )9}}, 
        {{(ush )487}, {(ush )9}}, 
        {{(ush )23}, {(ush )9}}, 
        {{(ush )279}, {(ush )9}}, 
        {{(ush )151}, {(ush )9}}, 
        {{(ush )407}, {(ush )9}}, 
        {{(ush )87}, {(ush )9}}, 
        {{(ush )343}, {(ush )9}}, 
        {{(ush )215}, {(ush )9}}, 
        {{(ush )471}, {(ush )9}}, 
        {{(ush )55}, {(ush )9}}, 
        {{(ush )311}, {(ush )9}}, 
        {{(ush )183}, {(ush )9}}, 
        {{(ush )439}, {(ush )9}}, 
        {{(ush )119}, {(ush )9}}, 
        {{(ush )375}, {(ush )9}}, 
        {{(ush )247}, {(ush )9}}, 
        {{(ush )503}, {(ush )9}}, 
        {{(ush )15}, {(ush )9}}, 
        {{(ush )271}, {(ush )9}}, 
        {{(ush )143}, {(ush )9}}, 
        {{(ush )399}, {(ush )9}}, 
        {{(ush )79}, {(ush )9}}, 
        {{(ush )335}, {(ush )9}}, 
        {{(ush )207}, {(ush )9}}, 
        {{(ush )463}, {(ush )9}}, 
        {{(ush )47}, {(ush )9}}, 
        {{(ush )303}, {(ush )9}}, 
        {{(ush )175}, {(ush )9}}, 
        {{(ush )431}, {(ush )9}}, 
        {{(ush )111}, {(ush )9}}, 
        {{(ush )367}, {(ush )9}}, 
        {{(ush )239}, {(ush )9}}, 
        {{(ush )495}, {(ush )9}}, 
        {{(ush )31}, {(ush )9}}, 
        {{(ush )287}, {(ush )9}}, 
        {{(ush )159}, {(ush )9}}, 
        {{(ush )415}, {(ush )9}}, 
        {{(ush )95}, {(ush )9}}, 
        {{(ush )351}, {(ush )9}}, 
        {{(ush )223}, {(ush )9}}, 
        {{(ush )479}, {(ush )9}}, 
        {{(ush )63}, {(ush )9}}, 
        {{(ush )319}, {(ush )9}}, 
        {{(ush )191}, {(ush )9}}, 
        {{(ush )447}, {(ush )9}}, 
        {{(ush )127}, {(ush )9}}, 
        {{(ush )383}, {(ush )9}}, 
        {{(ush )255}, {(ush )9}}, 
        {{(ush )511}, {(ush )9}}, 
        {{(ush )0}, {(ush )7}}, 
        {{(ush )64}, {(ush )7}}, 
        {{(ush )32}, {(ush )7}}, 
        {{(ush )96}, {(ush )7}}, 
        {{(ush )16}, {(ush )7}}, 
        {{(ush )80}, {(ush )7}}, 
        {{(ush )48}, {(ush )7}}, 
        {{(ush )112}, {(ush )7}}, 
        {{(ush )8}, {(ush )7}}, 
        {{(ush )72}, {(ush )7}}, 
        {{(ush )40}, {(ush )7}}, 
        {{(ush )104}, {(ush )7}}, 
        {{(ush )24}, {(ush )7}}, 
        {{(ush )88}, {(ush )7}}, 
        {{(ush )56}, {(ush )7}}, 
        {{(ush )120}, {(ush )7}}, 
        {{(ush )4}, {(ush )7}}, 
        {{(ush )68}, {(ush )7}}, 
        {{(ush )36}, {(ush )7}}, 
        {{(ush )100}, {(ush )7}}, 
        {{(ush )20}, {(ush )7}}, 
        {{(ush )84}, {(ush )7}}, 
        {{(ush )52}, {(ush )7}}, 
        {{(ush )116}, {(ush )7}}, 
        {{(ush )3}, {(ush )8}}, 
        {{(ush )131}, {(ush )8}}, 
        {{(ush )67}, {(ush )8}}, 
        {{(ush )195}, {(ush )8}}, 
        {{(ush )35}, {(ush )8}}, 
        {{(ush )163}, {(ush )8}}, 
        {{(ush )99}, {(ush )8}}, 
        {{(ush )227}, {(ush )8}}};
#line 64 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
static ct_data const   static_dtree[30]  = 
#line 64
  {      {{(ush )0}, {(ush )5}}, 
        {{(ush )16}, {(ush )5}}, 
        {{(ush )8}, {(ush )5}}, 
        {{(ush )24}, {(ush )5}}, 
        {{(ush )4}, {(ush )5}}, 
        {{(ush )20}, {(ush )5}}, 
        {{(ush )12}, {(ush )5}}, 
        {{(ush )28}, {(ush )5}}, 
        {{(ush )2}, {(ush )5}}, 
        {{(ush )18}, {(ush )5}}, 
        {{(ush )10}, {(ush )5}}, 
        {{(ush )26}, {(ush )5}}, 
        {{(ush )6}, {(ush )5}}, 
        {{(ush )22}, {(ush )5}}, 
        {{(ush )14}, {(ush )5}}, 
        {{(ush )30}, {(ush )5}}, 
        {{(ush )1}, {(ush )5}}, 
        {{(ush )17}, {(ush )5}}, 
        {{(ush )9}, {(ush )5}}, 
        {{(ush )25}, {(ush )5}}, 
        {{(ush )5}, {(ush )5}}, 
        {{(ush )21}, {(ush )5}}, 
        {{(ush )13}, {(ush )5}}, 
        {{(ush )29}, {(ush )5}}, 
        {{(ush )3}, {(ush )5}}, 
        {{(ush )19}, {(ush )5}}, 
        {{(ush )11}, {(ush )5}}, 
        {{(ush )27}, {(ush )5}}, 
        {{(ush )7}, {(ush )5}}, 
        {{(ush )23}, {(ush )5}}};
#line 73 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
uch const   _dist_code[512]  = 
#line 73
  {      (uch const   )0,      (uch const   )1,      (uch const   )2,      (uch const   )3, 
        (uch const   )4,      (uch const   )4,      (uch const   )5,      (uch const   )5, 
        (uch const   )6,      (uch const   )6,      (uch const   )6,      (uch const   )6, 
        (uch const   )7,      (uch const   )7,      (uch const   )7,      (uch const   )7, 
        (uch const   )8,      (uch const   )8,      (uch const   )8,      (uch const   )8, 
        (uch const   )8,      (uch const   )8,      (uch const   )8,      (uch const   )8, 
        (uch const   )9,      (uch const   )9,      (uch const   )9,      (uch const   )9, 
        (uch const   )9,      (uch const   )9,      (uch const   )9,      (uch const   )9, 
        (uch const   )10,      (uch const   )10,      (uch const   )10,      (uch const   )10, 
        (uch const   )10,      (uch const   )10,      (uch const   )10,      (uch const   )10, 
        (uch const   )10,      (uch const   )10,      (uch const   )10,      (uch const   )10, 
        (uch const   )10,      (uch const   )10,      (uch const   )10,      (uch const   )10, 
        (uch const   )11,      (uch const   )11,      (uch const   )11,      (uch const   )11, 
        (uch const   )11,      (uch const   )11,      (uch const   )11,      (uch const   )11, 
        (uch const   )11,      (uch const   )11,      (uch const   )11,      (uch const   )11, 
        (uch const   )11,      (uch const   )11,      (uch const   )11,      (uch const   )11, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )0,      (uch const   )0,      (uch const   )16,      (uch const   )17, 
        (uch const   )18,      (uch const   )18,      (uch const   )19,      (uch const   )19, 
        (uch const   )20,      (uch const   )20,      (uch const   )20,      (uch const   )20, 
        (uch const   )21,      (uch const   )21,      (uch const   )21,      (uch const   )21, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )28,      (uch const   )28,      (uch const   )28,      (uch const   )28, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29, 
        (uch const   )29,      (uch const   )29,      (uch const   )29,      (uch const   )29};
#line 102 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
uch const   _length_code[256]  = 
#line 102
  {      (uch const   )0,      (uch const   )1,      (uch const   )2,      (uch const   )3, 
        (uch const   )4,      (uch const   )5,      (uch const   )6,      (uch const   )7, 
        (uch const   )8,      (uch const   )8,      (uch const   )9,      (uch const   )9, 
        (uch const   )10,      (uch const   )10,      (uch const   )11,      (uch const   )11, 
        (uch const   )12,      (uch const   )12,      (uch const   )12,      (uch const   )12, 
        (uch const   )13,      (uch const   )13,      (uch const   )13,      (uch const   )13, 
        (uch const   )14,      (uch const   )14,      (uch const   )14,      (uch const   )14, 
        (uch const   )15,      (uch const   )15,      (uch const   )15,      (uch const   )15, 
        (uch const   )16,      (uch const   )16,      (uch const   )16,      (uch const   )16, 
        (uch const   )16,      (uch const   )16,      (uch const   )16,      (uch const   )16, 
        (uch const   )17,      (uch const   )17,      (uch const   )17,      (uch const   )17, 
        (uch const   )17,      (uch const   )17,      (uch const   )17,      (uch const   )17, 
        (uch const   )18,      (uch const   )18,      (uch const   )18,      (uch const   )18, 
        (uch const   )18,      (uch const   )18,      (uch const   )18,      (uch const   )18, 
        (uch const   )19,      (uch const   )19,      (uch const   )19,      (uch const   )19, 
        (uch const   )19,      (uch const   )19,      (uch const   )19,      (uch const   )19, 
        (uch const   )20,      (uch const   )20,      (uch const   )20,      (uch const   )20, 
        (uch const   )20,      (uch const   )20,      (uch const   )20,      (uch const   )20, 
        (uch const   )20,      (uch const   )20,      (uch const   )20,      (uch const   )20, 
        (uch const   )20,      (uch const   )20,      (uch const   )20,      (uch const   )20, 
        (uch const   )21,      (uch const   )21,      (uch const   )21,      (uch const   )21, 
        (uch const   )21,      (uch const   )21,      (uch const   )21,      (uch const   )21, 
        (uch const   )21,      (uch const   )21,      (uch const   )21,      (uch const   )21, 
        (uch const   )21,      (uch const   )21,      (uch const   )21,      (uch const   )21, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )22,      (uch const   )22,      (uch const   )22,      (uch const   )22, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )23,      (uch const   )23,      (uch const   )23,      (uch const   )23, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )24,      (uch const   )24,      (uch const   )24,      (uch const   )24, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )25,      (uch const   )25,      (uch const   )25,      (uch const   )25, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )26,      (uch const   )26,      (uch const   )26,      (uch const   )26, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )27, 
        (uch const   )27,      (uch const   )27,      (uch const   )27,      (uch const   )28};
#line 118 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
static int const   base_length[29]  = 
#line 118
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )6,      (int const   )7, 
        (int const   )8,      (int const   )10,      (int const   )12,      (int const   )14, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )28, 
        (int const   )32,      (int const   )40,      (int const   )48,      (int const   )56, 
        (int const   )64,      (int const   )80,      (int const   )96,      (int const   )112, 
        (int const   )128,      (int const   )160,      (int const   )192,      (int const   )224, 
        (int const   )0};
#line 123 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.h"
static int const   base_dist[30]  = 
#line 123
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )6,      (int const   )8,      (int const   )12, 
        (int const   )16,      (int const   )24,      (int const   )32,      (int const   )48, 
        (int const   )64,      (int const   )96,      (int const   )128,      (int const   )192, 
        (int const   )256,      (int const   )384,      (int const   )512,      (int const   )768, 
        (int const   )1024,      (int const   )1536,      (int const   )2048,      (int const   )3072, 
        (int const   )4096,      (int const   )6144,      (int const   )8192,      (int const   )12288, 
        (int const   )16384,      (int const   )24576};
#line 129 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static static_tree_desc static_l_desc  =    {static_ltree, extra_lbits, 257, 286, 15};
#line 132 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static static_tree_desc static_d_desc  =    {static_dtree, extra_dbits, 0, 30, 15};
#line 135 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static static_tree_desc static_bl_desc  =    {(ct_data const   *)0, extra_blbits, 0, 19, 7};
#line 142
static void tr_static_init(void) ;
#line 143
static void init_block(deflate_state *s ) ;
#line 144
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) ;
#line 145
static void gen_bitlen(deflate_state *s , tree_desc *desc ) ;
#line 146
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) ;
#line 147
static void build_tree(deflate_state *s , tree_desc *desc ) ;
#line 148
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 149
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 150
static int build_bl_tree(deflate_state *s ) ;
#line 151
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) ;
#line 153
static void compress_block(deflate_state *s , ct_data *ltree , ct_data *dtree ) ;
#line 155
static void set_data_type(deflate_state *s ) ;
#line 156
static unsigned int bi_reverse(unsigned int code , int len ) ;
#line 157
static void bi_windup(deflate_state *s ) ;
#line 158
static void bi_flush(deflate_state *s ) ;
#line 159
static void copy_block(deflate_state *s , charf *buf___1 , unsigned int len , int header ) ;
#line 238 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void tr_static_init(void) 
{ 


  {
#line 316
  return;
}
}
#line 382 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
void _tr_init(deflate_state *s ) 
{ 


  {
  {
#line 385
  tr_static_init();
#line 387
  s->l_desc.dyn_tree = s->dyn_ltree;
#line 388
  s->l_desc.stat_desc = & static_l_desc;
#line 390
  s->d_desc.dyn_tree = s->dyn_dtree;
#line 391
  s->d_desc.stat_desc = & static_d_desc;
#line 393
  s->bl_desc.dyn_tree = s->bl_tree;
#line 394
  s->bl_desc.stat_desc = & static_bl_desc;
#line 396
  s->bi_buf = (ush )0;
#line 397
  s->bi_valid = 0;
#line 398
  s->last_eob_len = 8;
#line 405
  init_block(s);
  }
#line 406
  return;
}
}
#line 411 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void init_block(deflate_state *s ) 
{ 
  int n ;
  ulg tmp ;
  uInt tmp___0 ;

  {
#line 417
  n = 0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (n < 286)) {
#line 417
      goto while_break;
    }
#line 417
    s->dyn_ltree[n].fc.freq = (ush )0;
#line 417
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  n = 0;
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 418
    if (! (n < 30)) {
#line 418
      goto while_break___0;
    }
#line 418
    s->dyn_dtree[n].fc.freq = (ush )0;
#line 418
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 419
  n = 0;
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 419
    if (! (n < 19)) {
#line 419
      goto while_break___1;
    }
#line 419
    s->bl_tree[n].fc.freq = (ush )0;
#line 419
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 421
  s->dyn_ltree[256].fc.freq = (ush )1;
#line 422
  tmp = (ulg )0L;
#line 422
  s->static_len = tmp;
#line 422
  s->opt_len = tmp;
#line 423
  tmp___0 = (uInt )0;
#line 423
  s->matches = tmp___0;
#line 423
  s->last_lit = tmp___0;
#line 424
  return;
}
}
#line 455 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) 
{ 
  int v ;
  int j ;

  {
#line 460
  v = s->heap[k];
#line 461
  j = k << 1;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (j <= s->heap_len)) {
#line 462
      goto while_break;
    }
#line 464
    if (j < s->heap_len) {
#line 464
      if ((int )(tree + s->heap[j + 1])->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 466
        j ++;
      } else
#line 464
      if ((int )(tree + s->heap[j + 1])->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 464
        if ((int )s->depth[s->heap[j + 1]] <= (int )s->depth[s->heap[j]]) {
#line 466
          j ++;
        }
      }
    }
#line 469
    if ((int )(tree + v)->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 469
      goto while_break;
    } else
#line 469
    if ((int )(tree + v)->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 469
      if ((int )s->depth[v] <= (int )s->depth[s->heap[j]]) {
#line 469
        goto while_break;
      }
    }
#line 472
    s->heap[k] = s->heap[j];
#line 472
    k = j;
#line 475
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  s->heap[k] = v;
#line 478
  return;
}
}
#line 490 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void gen_bitlen(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  int max_code___0 ;
  ct_data const   *stree ;
  intf const   *extra ;
  int base ;
  int max_length ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 494
  tree = desc->dyn_tree;
#line 495
  max_code___0 = desc->max_code;
#line 496
  stree = (desc->stat_desc)->static_tree;
#line 497
  extra = (desc->stat_desc)->extra_bits;
#line 498
  base = (desc->stat_desc)->extra_base;
#line 499
  max_length = (desc->stat_desc)->max_length;
#line 505
  overflow = 0;
#line 507
  bits = 0;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (bits <= 15)) {
#line 507
      goto while_break;
    }
#line 507
    s->bl_count[bits] = (ush )0;
#line 507
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  (tree + s->heap[s->heap_max])->dl.len = (ush )0;
#line 514
  h = s->heap_max + 1;
  {
#line 514
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 514
    if (! (h < 573)) {
#line 514
      goto while_break___0;
    }
#line 515
    n = s->heap[h];
#line 516
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 517
    if (bits > max_length) {
#line 517
      bits = max_length;
#line 517
      overflow ++;
    }
#line 518
    (tree + n)->dl.len = (ush )bits;
#line 521
    if (n > max_code___0) {
#line 521
      goto __Cont;
    }
#line 523
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] + 1);
#line 524
    xbits = 0;
#line 525
    if (n >= base) {
#line 525
      xbits = (int )*(extra + (n - base));
    }
#line 526
    f = (tree + n)->fc.freq;
#line 527
    s->opt_len += (ulg )f * (ulg )(bits + xbits);
#line 528
    if (stree) {
#line 528
      s->static_len += (ulg )f * (ulg )((int const   )(stree + n)->dl.len + (int const   )xbits);
    }
    __Cont: /* CIL Label */ 
#line 514
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 530
  if (overflow == 0) {
#line 530
    return;
  }
  {
#line 536
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 537
    bits = max_length - 1;
    {
#line 538
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 538
      if (! ((int )s->bl_count[bits] == 0)) {
#line 538
        goto while_break___2;
      }
#line 538
      bits --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 539
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] - 1);
#line 540
    s->bl_count[bits + 1] = (ush )((int )s->bl_count[bits + 1] + 2);
#line 541
    s->bl_count[max_length] = (ush )((int )s->bl_count[max_length] - 1);
#line 545
    overflow -= 2;
#line 536
    if (! (overflow > 0)) {
#line 536
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 553
  bits = max_length;
  {
#line 553
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 553
    if (! (bits != 0)) {
#line 553
      goto while_break___3;
    }
#line 554
    n = (int )s->bl_count[bits];
    {
#line 555
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 555
      if (! (n != 0)) {
#line 555
        goto while_break___4;
      }
#line 556
      h --;
#line 556
      m = s->heap[h];
#line 557
      if (m > max_code___0) {
#line 557
        goto while_continue___4;
      }
#line 558
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 560
        s->opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
#line 562
        (tree + m)->dl.len = (ush )bits;
      }
#line 564
      n --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 553
    bits --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 567
  return;
}
}
#line 577 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) 
{ 
  ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;

  {
#line 583
  code = (ush )0;
#line 590
  bits = 1;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! (bits <= 15)) {
#line 590
      goto while_break;
    }
#line 591
    code = (ush )(((int )code + (int )*(bl_count + (bits - 1))) << 1);
#line 591
    next_code[bits] = code;
#line 590
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  n = 0;
  {
#line 600
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 600
    if (! (n <= max_code___0)) {
#line 600
      goto while_break___0;
    }
#line 601
    len = (int )(tree + n)->dl.len;
#line 602
    if (len == 0) {
#line 602
      goto __Cont;
    }
    {
#line 604
    tmp = next_code[len];
#line 604
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 604
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 604
    (tree + n)->fc.code = (ush )tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 600
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  return;
}
}
#line 619 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void build_tree(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data const   *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code___0 ;
  int node ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 623
  tree = desc->dyn_tree;
#line 624
  stree = (desc->stat_desc)->static_tree;
#line 625
  elems = (desc->stat_desc)->elems;
#line 627
  max_code___0 = -1;
#line 634
  s->heap_len = 0;
#line 634
  s->heap_max = 573;
#line 636
  n = 0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (n < elems)) {
#line 636
      goto while_break;
    }
#line 637
    if ((int )(tree + n)->fc.freq != 0) {
#line 638
      (s->heap_len) ++;
#line 638
      max_code___0 = n;
#line 638
      s->heap[s->heap_len] = max_code___0;
#line 639
      s->depth[n] = (uch )0;
    } else {
#line 641
      (tree + n)->dl.len = (ush )0;
    }
#line 636
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 650
    if (! (s->heap_len < 2)) {
#line 650
      goto while_break___0;
    }
#line 651
    (s->heap_len) ++;
#line 651
    if (max_code___0 < 2) {
#line 651
      max_code___0 ++;
#line 651
      tmp = max_code___0;
    } else {
#line 651
      tmp = 0;
    }
#line 651
    s->heap[s->heap_len] = tmp;
#line 651
    node = tmp;
#line 652
    (tree + node)->fc.freq = (ush )1;
#line 653
    s->depth[node] = (uch )0;
#line 654
    (s->opt_len) --;
#line 654
    if (stree) {
#line 654
      s->static_len -= (ulg )(stree + node)->dl.len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 657
  desc->max_code = max_code___0;
#line 662
  n = s->heap_len / 2;
  {
#line 662
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 662
    if (! (n >= 1)) {
#line 662
      goto while_break___1;
    }
    {
#line 662
    pqdownheap(s, tree, n);
#line 662
    n --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 667
  node = elems;
  {
#line 668
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 669
    n = s->heap[1];
#line 669
    tmp___0 = s->heap_len;
#line 669
    (s->heap_len) --;
#line 669
    s->heap[1] = s->heap[tmp___0];
#line 669
    pqdownheap(s, tree, 1);
#line 670
    m = s->heap[1];
#line 672
    (s->heap_max) --;
#line 672
    s->heap[s->heap_max] = n;
#line 673
    (s->heap_max) --;
#line 673
    s->heap[s->heap_max] = m;
#line 676
    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
    }
#line 677
    if ((int )s->depth[n] >= (int )s->depth[m]) {
#line 677
      tmp___1 = (int )s->depth[n];
    } else {
#line 677
      tmp___1 = (int )s->depth[m];
    }
    {
#line 677
    s->depth[node] = (uch )(tmp___1 + 1);
#line 679
    tmp___2 = (ush )node;
#line 679
    (tree + m)->dl.dad = tmp___2;
#line 679
    (tree + n)->dl.dad = tmp___2;
#line 687
    tmp___3 = node;
#line 687
    node ++;
#line 687
    s->heap[1] = tmp___3;
#line 688
    pqdownheap(s, tree, 1);
    }
#line 668
    if (! (s->heap_len >= 2)) {
#line 668
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 692
  (s->heap_max) --;
#line 692
  s->heap[s->heap_max] = s->heap[1];
#line 697
  gen_bitlen(s, desc);
#line 700
  gen_codes(tree, max_code___0, s->bl_count);
  }
#line 701
  return;
}
}
#line 707 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 713
  prevlen = -1;
#line 715
  nextlen = (int )(tree + 0)->dl.len;
#line 716
  count = 0;
#line 717
  max_count = 7;
#line 718
  min_count = 4;
#line 720
  if (nextlen == 0) {
#line 720
    max_count = 138;
#line 720
    min_count = 3;
  }
#line 721
  (tree + (max_code___0 + 1))->dl.len = (ush )65535;
#line 723
  n = 0;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (n <= max_code___0)) {
#line 723
      goto while_break;
    }
#line 724
    curlen = nextlen;
#line 724
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 725
    count ++;
#line 725
    if (count < max_count) {
#line 725
      if (curlen == nextlen) {
#line 726
        goto __Cont;
      } else {
#line 725
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 727
    if (count < min_count) {
#line 728
      s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + count);
    } else
#line 729
    if (curlen != 0) {
#line 730
      if (curlen != prevlen) {
#line 730
        s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + 1);
      }
#line 731
      s->bl_tree[16].fc.freq = (ush )((int )s->bl_tree[16].fc.freq + 1);
    } else
#line 732
    if (count <= 10) {
#line 733
      s->bl_tree[17].fc.freq = (ush )((int )s->bl_tree[17].fc.freq + 1);
    } else {
#line 735
      s->bl_tree[18].fc.freq = (ush )((int )s->bl_tree[18].fc.freq + 1);
    }
#line 737
    count = 0;
#line 737
    prevlen = curlen;
#line 738
    if (nextlen == 0) {
#line 739
      max_count = 138;
#line 739
      min_count = 3;
    } else
#line 740
    if (curlen == nextlen) {
#line 741
      max_count = 6;
#line 741
      min_count = 3;
    } else {
#line 743
      max_count = 7;
#line 743
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 723
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return;
}
}
#line 752 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___3 ;
  uInt tmp___4 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___5 ;
  uInt tmp___6 ;
  int len___3 ;
  int val___3 ;
  uInt tmp___7 ;
  uInt tmp___8 ;
  int len___4 ;
  int val___4 ;
  uInt tmp___9 ;
  uInt tmp___10 ;
  int len___5 ;
  int val___5 ;
  uInt tmp___11 ;
  uInt tmp___12 ;
  int len___6 ;
  int val___6 ;
  uInt tmp___13 ;
  uInt tmp___14 ;

  {
#line 758
  prevlen = -1;
#line 760
  nextlen = (int )(tree + 0)->dl.len;
#line 761
  count = 0;
#line 762
  max_count = 7;
#line 763
  min_count = 4;
#line 766
  if (nextlen == 0) {
#line 766
    max_count = 138;
#line 766
    min_count = 3;
  }
#line 768
  n = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (n <= max_code___0)) {
#line 768
      goto while_break;
    }
#line 769
    curlen = nextlen;
#line 769
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 770
    count ++;
#line 770
    if (count < max_count) {
#line 770
      if (curlen == nextlen) {
#line 771
        goto __Cont;
      } else {
#line 770
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 772
    if (count < min_count) {
      {
#line 773
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 773
        len = (int )s->bl_tree[curlen].dl.len;
#line 773
        if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 773
          val = (int )s->bl_tree[curlen].fc.code;
#line 773
          s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 773
          tmp = s->pending;
#line 773
          (s->pending) ++;
#line 773
          *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 773
          tmp___0 = s->pending;
#line 773
          (s->pending) ++;
#line 773
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 773
          s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 773
          s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
        } else {
#line 773
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 773
          s->bi_valid += len;
        }
#line 773
        count --;
#line 773
        if (! (count != 0)) {
#line 773
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 775
    if (curlen != 0) {
#line 776
      if (curlen != prevlen) {
#line 777
        len___0 = (int )s->bl_tree[curlen].dl.len;
#line 777
        if (s->bi_valid > (int )(16UL * sizeof(char )) - len___0) {
#line 777
          val___0 = (int )s->bl_tree[curlen].fc.code;
#line 777
          s->bi_buf = (ush )((int )s->bi_buf | (val___0 << s->bi_valid));
#line 777
          tmp___1 = s->pending;
#line 777
          (s->pending) ++;
#line 777
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 777
          tmp___2 = s->pending;
#line 777
          (s->pending) ++;
#line 777
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 777
          s->bi_buf = (ush )((int )((ush )val___0) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 777
          s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___0 - 16UL * sizeof(char )));
        } else {
#line 777
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 777
          s->bi_valid += len___0;
        }
#line 777
        count --;
      }
#line 780
      len___1 = (int )s->bl_tree[16].dl.len;
#line 780
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___1) {
#line 780
        val___1 = (int )s->bl_tree[16].fc.code;
#line 780
        s->bi_buf = (ush )((int )s->bi_buf | (val___1 << s->bi_valid));
#line 780
        tmp___3 = s->pending;
#line 780
        (s->pending) ++;
#line 780
        *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 780
        tmp___4 = s->pending;
#line 780
        (s->pending) ++;
#line 780
        *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 780
        s->bi_buf = (ush )((int )((ush )val___1) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 780
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___1 - 16UL * sizeof(char )));
      } else {
#line 780
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[16].fc.code << s->bi_valid));
#line 780
        s->bi_valid += len___1;
      }
#line 780
      len___2 = 2;
#line 780
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___2) {
#line 780
        val___2 = count - 3;
#line 780
        s->bi_buf = (ush )((int )s->bi_buf | (val___2 << s->bi_valid));
#line 780
        tmp___5 = s->pending;
#line 780
        (s->pending) ++;
#line 780
        *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 780
        tmp___6 = s->pending;
#line 780
        (s->pending) ++;
#line 780
        *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 780
        s->bi_buf = (ush )((int )((ush )val___2) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 780
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___2 - 16UL * sizeof(char )));
      } else {
#line 780
        s->bi_buf = (ush )((int )s->bi_buf | ((count - 3) << s->bi_valid));
#line 780
        s->bi_valid += len___2;
      }
    } else
#line 782
    if (count <= 10) {
#line 783
      len___3 = (int )s->bl_tree[17].dl.len;
#line 783
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___3) {
#line 783
        val___3 = (int )s->bl_tree[17].fc.code;
#line 783
        s->bi_buf = (ush )((int )s->bi_buf | (val___3 << s->bi_valid));
#line 783
        tmp___7 = s->pending;
#line 783
        (s->pending) ++;
#line 783
        *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf & 255);
#line 783
        tmp___8 = s->pending;
#line 783
        (s->pending) ++;
#line 783
        *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf >> 8);
#line 783
        s->bi_buf = (ush )((int )((ush )val___3) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 783
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___3 - 16UL * sizeof(char )));
      } else {
#line 783
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[17].fc.code << s->bi_valid));
#line 783
        s->bi_valid += len___3;
      }
#line 783
      len___4 = 3;
#line 783
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___4) {
#line 783
        val___4 = count - 3;
#line 783
        s->bi_buf = (ush )((int )s->bi_buf | (val___4 << s->bi_valid));
#line 783
        tmp___9 = s->pending;
#line 783
        (s->pending) ++;
#line 783
        *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf & 255);
#line 783
        tmp___10 = s->pending;
#line 783
        (s->pending) ++;
#line 783
        *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf >> 8);
#line 783
        s->bi_buf = (ush )((int )((ush )val___4) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 783
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___4 - 16UL * sizeof(char )));
      } else {
#line 783
        s->bi_buf = (ush )((int )s->bi_buf | ((count - 3) << s->bi_valid));
#line 783
        s->bi_valid += len___4;
      }
    } else {
#line 786
      len___5 = (int )s->bl_tree[18].dl.len;
#line 786
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___5) {
#line 786
        val___5 = (int )s->bl_tree[18].fc.code;
#line 786
        s->bi_buf = (ush )((int )s->bi_buf | (val___5 << s->bi_valid));
#line 786
        tmp___11 = s->pending;
#line 786
        (s->pending) ++;
#line 786
        *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf & 255);
#line 786
        tmp___12 = s->pending;
#line 786
        (s->pending) ++;
#line 786
        *(s->pending_buf + tmp___12) = (uch )((int )s->bi_buf >> 8);
#line 786
        s->bi_buf = (ush )((int )((ush )val___5) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 786
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___5 - 16UL * sizeof(char )));
      } else {
#line 786
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[18].fc.code << s->bi_valid));
#line 786
        s->bi_valid += len___5;
      }
#line 786
      len___6 = 7;
#line 786
      if (s->bi_valid > (int )(16UL * sizeof(char )) - len___6) {
#line 786
        val___6 = count - 11;
#line 786
        s->bi_buf = (ush )((int )s->bi_buf | (val___6 << s->bi_valid));
#line 786
        tmp___13 = s->pending;
#line 786
        (s->pending) ++;
#line 786
        *(s->pending_buf + tmp___13) = (uch )((int )s->bi_buf & 255);
#line 786
        tmp___14 = s->pending;
#line 786
        (s->pending) ++;
#line 786
        *(s->pending_buf + tmp___14) = (uch )((int )s->bi_buf >> 8);
#line 786
        s->bi_buf = (ush )((int )((ush )val___6) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 786
        s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___6 - 16UL * sizeof(char )));
      } else {
#line 786
        s->bi_buf = (ush )((int )s->bi_buf | ((count - 11) << s->bi_valid));
#line 786
        s->bi_valid += len___6;
      }
    }
#line 788
    count = 0;
#line 788
    prevlen = curlen;
#line 789
    if (nextlen == 0) {
#line 790
      max_count = 138;
#line 790
      min_count = 3;
    } else
#line 791
    if (curlen == nextlen) {
#line 792
      max_count = 6;
#line 792
      min_count = 3;
    } else {
#line 794
      max_count = 7;
#line 794
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 768
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 797
  return;
}
}
#line 803 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static int build_bl_tree(deflate_state *s ) 
{ 
  int max_blindex ;

  {
  {
#line 809
  scan_tree(s, s->dyn_ltree, s->l_desc.max_code);
#line 810
  scan_tree(s, s->dyn_dtree, s->d_desc.max_code);
#line 813
  build_tree(s, & s->bl_desc);
#line 822
  max_blindex = 18;
  }
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 822
    if (! (max_blindex >= 3)) {
#line 822
      goto while_break;
    }
#line 823
    if ((int )s->bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 823
      goto while_break;
    }
#line 822
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 826
  s->opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 830
  return (max_blindex);
}
}
#line 838 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___3 ;
  uInt tmp___4 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___5 ;
  uInt tmp___6 ;

  {
#line 848
  len = 5;
#line 848
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 848
    val = lcodes - 257;
#line 848
    s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 848
    tmp = s->pending;
#line 848
    (s->pending) ++;
#line 848
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 848
    tmp___0 = s->pending;
#line 848
    (s->pending) ++;
#line 848
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 848
    s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 848
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
  } else {
#line 848
    s->bi_buf = (ush )((int )s->bi_buf | ((lcodes - 257) << s->bi_valid));
#line 848
    s->bi_valid += len;
  }
#line 849
  len___0 = 5;
#line 849
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len___0) {
#line 849
    val___0 = dcodes - 1;
#line 849
    s->bi_buf = (ush )((int )s->bi_buf | (val___0 << s->bi_valid));
#line 849
    tmp___1 = s->pending;
#line 849
    (s->pending) ++;
#line 849
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 849
    tmp___2 = s->pending;
#line 849
    (s->pending) ++;
#line 849
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 849
    s->bi_buf = (ush )((int )((ush )val___0) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 849
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___0 - 16UL * sizeof(char )));
  } else {
#line 849
    s->bi_buf = (ush )((int )s->bi_buf | ((dcodes - 1) << s->bi_valid));
#line 849
    s->bi_valid += len___0;
  }
#line 850
  len___1 = 4;
#line 850
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len___1) {
#line 850
    val___1 = blcodes - 4;
#line 850
    s->bi_buf = (ush )((int )s->bi_buf | (val___1 << s->bi_valid));
#line 850
    tmp___3 = s->pending;
#line 850
    (s->pending) ++;
#line 850
    *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 850
    tmp___4 = s->pending;
#line 850
    (s->pending) ++;
#line 850
    *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 850
    s->bi_buf = (ush )((int )((ush )val___1) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 850
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___1 - 16UL * sizeof(char )));
  } else {
#line 850
    s->bi_buf = (ush )((int )s->bi_buf | ((blcodes - 4) << s->bi_valid));
#line 850
    s->bi_valid += len___1;
  }
#line 851
  rank = 0;
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (rank < blcodes)) {
#line 851
      goto while_break;
    }
#line 853
    len___2 = 3;
#line 853
    if (s->bi_valid > (int )(16UL * sizeof(char )) - len___2) {
#line 853
      val___2 = (int )s->bl_tree[bl_order[rank]].dl.len;
#line 853
      s->bi_buf = (ush )((int )s->bi_buf | (val___2 << s->bi_valid));
#line 853
      tmp___5 = s->pending;
#line 853
      (s->pending) ++;
#line 853
      *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 853
      tmp___6 = s->pending;
#line 853
      (s->pending) ++;
#line 853
      *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 853
      s->bi_buf = (ush )((int )((ush )val___2) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 853
      s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___2 - 16UL * sizeof(char )));
    } else {
#line 853
      s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[bl_order[rank]].dl.len << s->bi_valid));
#line 853
      s->bi_valid += len___2;
    }
#line 851
    rank ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 857
  send_tree(s, s->dyn_ltree, lcodes - 1);
#line 860
  send_tree(s, s->dyn_dtree, dcodes - 1);
  }
#line 862
  return;
}
}
#line 867 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
void _tr_stored_block(deflate_state *s , charf *buf___1 , ulg stored_len , int eof ) 
{ 
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;

  {
#line 873
  len = 3;
#line 873
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 873
    val = eof;
#line 873
    s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 873
    tmp = s->pending;
#line 873
    (s->pending) ++;
#line 873
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 873
    tmp___0 = s->pending;
#line 873
    (s->pending) ++;
#line 873
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 873
    s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 873
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
  } else {
#line 873
    s->bi_buf = (ush )((int )s->bi_buf | (eof << s->bi_valid));
#line 873
    s->bi_valid += len;
  }
  {
#line 878
  copy_block(s, buf___1, (unsigned int )stored_len, 1);
  }
#line 879
  return;
}
}
#line 892 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
void _tr_align(deflate_state *s ) 
{ 
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___3 ;
  uInt tmp___4 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___5 ;
  uInt tmp___6 ;

  {
#line 895
  len = 3;
#line 895
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 895
    val = 1 << 1;
#line 895
    s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 895
    tmp = s->pending;
#line 895
    (s->pending) ++;
#line 895
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 895
    tmp___0 = s->pending;
#line 895
    (s->pending) ++;
#line 895
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 895
    s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 895
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
  } else {
#line 895
    s->bi_buf = (ush )((int )s->bi_buf | ((1 << 1) << s->bi_valid));
#line 895
    s->bi_valid += len;
  }
#line 896
  len___0 = (int )static_ltree[256].dl.len;
#line 896
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len___0) {
#line 896
    val___0 = (int )static_ltree[256].fc.code;
#line 896
    s->bi_buf = (ush )((int )s->bi_buf | (val___0 << s->bi_valid));
#line 896
    tmp___1 = s->pending;
#line 896
    (s->pending) ++;
#line 896
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 896
    tmp___2 = s->pending;
#line 896
    (s->pending) ++;
#line 896
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 896
    s->bi_buf = (ush )((int )((ush )val___0) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 896
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___0 - 16UL * sizeof(char )));
  } else {
#line 896
    s->bi_buf = (ush )((int )s->bi_buf | (int )((int const   )static_ltree[256].fc.code << s->bi_valid));
#line 896
    s->bi_valid += len___0;
  }
  {
#line 900
  bi_flush(s);
  }
#line 906
  if (((1 + s->last_eob_len) + 10) - s->bi_valid < 9) {
#line 907
    len___1 = 3;
#line 907
    if (s->bi_valid > (int )(16UL * sizeof(char )) - len___1) {
#line 907
      val___1 = 1 << 1;
#line 907
      s->bi_buf = (ush )((int )s->bi_buf | (val___1 << s->bi_valid));
#line 907
      tmp___3 = s->pending;
#line 907
      (s->pending) ++;
#line 907
      *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 907
      tmp___4 = s->pending;
#line 907
      (s->pending) ++;
#line 907
      *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 907
      s->bi_buf = (ush )((int )((ush )val___1) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 907
      s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___1 - 16UL * sizeof(char )));
    } else {
#line 907
      s->bi_buf = (ush )((int )s->bi_buf | ((1 << 1) << s->bi_valid));
#line 907
      s->bi_valid += len___1;
    }
#line 908
    len___2 = (int )static_ltree[256].dl.len;
#line 908
    if (s->bi_valid > (int )(16UL * sizeof(char )) - len___2) {
#line 908
      val___2 = (int )static_ltree[256].fc.code;
#line 908
      s->bi_buf = (ush )((int )s->bi_buf | (val___2 << s->bi_valid));
#line 908
      tmp___5 = s->pending;
#line 908
      (s->pending) ++;
#line 908
      *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 908
      tmp___6 = s->pending;
#line 908
      (s->pending) ++;
#line 908
      *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 908
      s->bi_buf = (ush )((int )((ush )val___2) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 908
      s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___2 - 16UL * sizeof(char )));
    } else {
#line 908
      s->bi_buf = (ush )((int )s->bi_buf | (int )((int const   )static_ltree[256].fc.code << s->bi_valid));
#line 908
      s->bi_valid += len___2;
    }
    {
#line 912
    bi_flush(s);
    }
  }
#line 914
  s->last_eob_len = 7;
#line 915
  return;
}
}
#line 921 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
void _tr_flush_block(deflate_state *s , charf *buf___1 , ulg stored_len , int eof ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;

  {
#line 928
  max_blindex = 0;
#line 931
  if (s->level > 0) {
#line 934
    if (stored_len > 0UL) {
#line 934
      if ((s->strm)->data_type == 2) {
        {
#line 935
        set_data_type(s);
        }
      }
    }
    {
#line 938
    build_tree(s, & s->l_desc);
#line 942
    build_tree(s, & s->d_desc);
#line 952
    max_blindex = build_bl_tree(s);
#line 955
    opt_lenb = ((s->opt_len + 3UL) + 7UL) >> 3;
#line 956
    static_lenb = ((s->static_len + 3UL) + 7UL) >> 3;
    }
#line 962
    if (static_lenb <= opt_lenb) {
#line 962
      opt_lenb = static_lenb;
    }
  } else {
#line 966
    static_lenb = stored_len + 5UL;
#line 966
    opt_lenb = static_lenb;
  }
#line 972
  if (stored_len + 4UL <= opt_lenb) {
#line 972
    if ((unsigned long )buf___1 != (unsigned long )((char *)0)) {
      {
#line 981
      _tr_stored_block(s, buf___1, stored_len, eof);
      }
    } else {
#line 972
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 986
  if (s->strategy == 4) {
#line 986
    goto _L;
  } else
#line 986
  if (static_lenb == opt_lenb) {
    _L: /* CIL Label */ 
#line 988
    len = 3;
#line 988
    if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 988
      val = (1 << 1) + eof;
#line 988
      s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 988
      tmp = s->pending;
#line 988
      (s->pending) ++;
#line 988
      *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 988
      tmp___0 = s->pending;
#line 988
      (s->pending) ++;
#line 988
      *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 988
      s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 988
      s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
    } else {
#line 988
      s->bi_buf = (ush )((int )s->bi_buf | (((1 << 1) + eof) << s->bi_valid));
#line 988
      s->bi_valid += len;
    }
    {
#line 989
    compress_block(s, (ct_data *)(static_ltree), (ct_data *)(static_dtree));
    }
  } else {
#line 994
    len___0 = 3;
#line 994
    if (s->bi_valid > (int )(16UL * sizeof(char )) - len___0) {
#line 994
      val___0 = (2 << 1) + eof;
#line 994
      s->bi_buf = (ush )((int )s->bi_buf | (val___0 << s->bi_valid));
#line 994
      tmp___1 = s->pending;
#line 994
      (s->pending) ++;
#line 994
      *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 994
      tmp___2 = s->pending;
#line 994
      (s->pending) ++;
#line 994
      *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 994
      s->bi_buf = (ush )((int )((ush )val___0) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 994
      s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___0 - 16UL * sizeof(char )));
    } else {
#line 994
      s->bi_buf = (ush )((int )s->bi_buf | (((2 << 1) + eof) << s->bi_valid));
#line 994
      s->bi_valid += len___0;
    }
    {
#line 995
    send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1, max_blindex + 1);
#line 997
    compress_block(s, s->dyn_ltree, s->dyn_dtree);
    }
  }
  {
#line 1006
  init_block(s);
  }
#line 1008
  if (eof) {
    {
#line 1009
    bi_windup(s);
    }
  }
#line 1016
  return;
}
}
#line 1022 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
int _tr_tally(deflate_state *s , unsigned int dist , unsigned int lc ) 
{ 
  uInt tmp ;
  int tmp___0 ;

  {
#line 1027
  *(s->d_buf + s->last_lit) = (ush )dist;
#line 1028
  tmp = s->last_lit;
#line 1028
  (s->last_lit) ++;
#line 1028
  *(s->l_buf + tmp) = (uch )lc;
#line 1029
  if (dist == 0U) {
#line 1031
    s->dyn_ltree[lc].fc.freq = (ush )((int )s->dyn_ltree[lc].fc.freq + 1);
  } else {
#line 1033
    (s->matches) ++;
#line 1035
    dist --;
#line 1040
    s->dyn_ltree[((int const   )_length_code[lc] + 256) + 1].fc.freq = (ush )((int )s->dyn_ltree[((int const   )_length_code[lc] + 256) + 1].fc.freq + 1);
#line 1041
    if (dist < 256U) {
#line 1041
      tmp___0 = (int const   )_dist_code[dist];
    } else {
#line 1041
      tmp___0 = (int const   )_dist_code[256U + (dist >> 7)];
    }
#line 1041
    s->dyn_dtree[tmp___0].fc.freq = (ush )((int )s->dyn_dtree[tmp___0].fc.freq + 1);
  }
#line 1062
  return (s->last_lit == s->lit_bufsize - 1U);
}
}
#line 1072 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void compress_block(deflate_state *s , ct_data *ltree , ct_data *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  int len ;
  int val ;
  uInt tmp___0 ;
  uInt tmp___1 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___2 ;
  uInt tmp___3 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___4 ;
  uInt tmp___5 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___6 ;
  uInt tmp___7 ;
  int len___3 ;
  int val___3 ;
  uInt tmp___8 ;
  uInt tmp___9 ;
  int len___4 ;
  int val___4 ;
  uInt tmp___10 ;
  uInt tmp___11 ;

  {
#line 1079
  lx = 0U;
#line 1083
  if (s->last_lit != 0U) {
    {
#line 1083
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1084
      dist = (unsigned int )*(s->d_buf + lx);
#line 1085
      tmp = lx;
#line 1085
      lx ++;
#line 1085
      lc = (int )*(s->l_buf + tmp);
#line 1086
      if (dist == 0U) {
#line 1087
        len = (int )(ltree + lc)->dl.len;
#line 1087
        if (s->bi_valid > (int )(16UL * sizeof(char )) - len) {
#line 1087
          val = (int )(ltree + lc)->fc.code;
#line 1087
          s->bi_buf = (ush )((int )s->bi_buf | (val << s->bi_valid));
#line 1087
          tmp___0 = s->pending;
#line 1087
          (s->pending) ++;
#line 1087
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf & 255);
#line 1087
          tmp___1 = s->pending;
#line 1087
          (s->pending) ++;
#line 1087
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf >> 8);
#line 1087
          s->bi_buf = (ush )((int )((ush )val) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1087
          s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len - 16UL * sizeof(char )));
        } else {
#line 1087
          s->bi_buf = (ush )((int )s->bi_buf | ((int )(ltree + lc)->fc.code << s->bi_valid));
#line 1087
          s->bi_valid += len;
        }
      } else {
#line 1091
        code = (unsigned int )_length_code[lc];
#line 1092
        len___0 = (int )(ltree + ((code + 256U) + 1U))->dl.len;
#line 1092
        if (s->bi_valid > (int )(16UL * sizeof(char )) - len___0) {
#line 1092
          val___0 = (int )(ltree + ((code + 256U) + 1U))->fc.code;
#line 1092
          s->bi_buf = (ush )((int )s->bi_buf | (val___0 << s->bi_valid));
#line 1092
          tmp___2 = s->pending;
#line 1092
          (s->pending) ++;
#line 1092
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf & 255);
#line 1092
          tmp___3 = s->pending;
#line 1092
          (s->pending) ++;
#line 1092
          *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf >> 8);
#line 1092
          s->bi_buf = (ush )((int )((ush )val___0) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1092
          s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___0 - 16UL * sizeof(char )));
        } else {
#line 1092
          s->bi_buf = (ush )((int )s->bi_buf | ((int )(ltree + ((code + 256U) + 1U))->fc.code << s->bi_valid));
#line 1092
          s->bi_valid += len___0;
        }
#line 1093
        extra = (int )extra_lbits[code];
#line 1094
        if (extra != 0) {
#line 1095
          lc -= (int )base_length[code];
#line 1096
          len___1 = extra;
#line 1096
          if (s->bi_valid > (int )(16UL * sizeof(char )) - len___1) {
#line 1096
            val___1 = lc;
#line 1096
            s->bi_buf = (ush )((int )s->bi_buf | (val___1 << s->bi_valid));
#line 1096
            tmp___4 = s->pending;
#line 1096
            (s->pending) ++;
#line 1096
            *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf & 255);
#line 1096
            tmp___5 = s->pending;
#line 1096
            (s->pending) ++;
#line 1096
            *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf >> 8);
#line 1096
            s->bi_buf = (ush )((int )((ush )val___1) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1096
            s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___1 - 16UL * sizeof(char )));
          } else {
#line 1096
            s->bi_buf = (ush )((int )s->bi_buf | (lc << s->bi_valid));
#line 1096
            s->bi_valid += len___1;
          }
        }
#line 1098
        dist --;
#line 1099
        if (dist < 256U) {
#line 1099
          code = (unsigned int )_dist_code[dist];
        } else {
#line 1099
          code = (unsigned int )_dist_code[256U + (dist >> 7)];
        }
#line 1102
        len___2 = (int )(dtree + code)->dl.len;
#line 1102
        if (s->bi_valid > (int )(16UL * sizeof(char )) - len___2) {
#line 1102
          val___2 = (int )(dtree + code)->fc.code;
#line 1102
          s->bi_buf = (ush )((int )s->bi_buf | (val___2 << s->bi_valid));
#line 1102
          tmp___6 = s->pending;
#line 1102
          (s->pending) ++;
#line 1102
          *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf & 255);
#line 1102
          tmp___7 = s->pending;
#line 1102
          (s->pending) ++;
#line 1102
          *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf >> 8);
#line 1102
          s->bi_buf = (ush )((int )((ush )val___2) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1102
          s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___2 - 16UL * sizeof(char )));
        } else {
#line 1102
          s->bi_buf = (ush )((int )s->bi_buf | ((int )(dtree + code)->fc.code << s->bi_valid));
#line 1102
          s->bi_valid += len___2;
        }
#line 1103
        extra = (int )extra_dbits[code];
#line 1104
        if (extra != 0) {
#line 1105
          dist -= (unsigned int )base_dist[code];
#line 1106
          len___3 = extra;
#line 1106
          if (s->bi_valid > (int )(16UL * sizeof(char )) - len___3) {
#line 1106
            val___3 = (int )dist;
#line 1106
            s->bi_buf = (ush )((int )s->bi_buf | (val___3 << s->bi_valid));
#line 1106
            tmp___8 = s->pending;
#line 1106
            (s->pending) ++;
#line 1106
            *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf & 255);
#line 1106
            tmp___9 = s->pending;
#line 1106
            (s->pending) ++;
#line 1106
            *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf >> 8);
#line 1106
            s->bi_buf = (ush )((int )((ush )val___3) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1106
            s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___3 - 16UL * sizeof(char )));
          } else {
#line 1106
            s->bi_buf = (ush )((unsigned int )s->bi_buf | (dist << s->bi_valid));
#line 1106
            s->bi_valid += len___3;
          }
        }
      }
#line 1083
      if (! (lx < s->last_lit)) {
#line 1083
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1116
  len___4 = (int )(ltree + 256)->dl.len;
#line 1116
  if (s->bi_valid > (int )(16UL * sizeof(char )) - len___4) {
#line 1116
    val___4 = (int )(ltree + 256)->fc.code;
#line 1116
    s->bi_buf = (ush )((int )s->bi_buf | (val___4 << s->bi_valid));
#line 1116
    tmp___10 = s->pending;
#line 1116
    (s->pending) ++;
#line 1116
    *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf & 255);
#line 1116
    tmp___11 = s->pending;
#line 1116
    (s->pending) ++;
#line 1116
    *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf >> 8);
#line 1116
    s->bi_buf = (ush )((int )((ush )val___4) >> (16UL * sizeof(char ) - (unsigned long )s->bi_valid));
#line 1116
    s->bi_valid = (int )((unsigned long )s->bi_valid + ((unsigned long )len___4 - 16UL * sizeof(char )));
  } else {
#line 1116
    s->bi_buf = (ush )((int )s->bi_buf | ((int )(ltree + 256)->fc.code << s->bi_valid));
#line 1116
    s->bi_valid += len___4;
  }
#line 1117
  s->last_eob_len = (int )(ltree + 256)->dl.len;
#line 1118
  return;
}
}
#line 1126 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void set_data_type(deflate_state *s ) 
{ 
  int n ;

  {
#line 1131
  n = 0;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! (n < 9)) {
#line 1131
      goto while_break;
    }
#line 1132
    if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1133
      goto while_break;
    }
#line 1131
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  if (n == 9) {
#line 1135
    n = 14;
    {
#line 1135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1135
      if (! (n < 32)) {
#line 1135
        goto while_break___0;
      }
#line 1136
      if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1137
        goto while_break___0;
      }
#line 1135
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1138
  if (n == 32) {
#line 1138
    (s->strm)->data_type = 1;
  } else {
#line 1138
    (s->strm)->data_type = 0;
  }
#line 1139
  return;
}
}
#line 1146 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 1150
  res = 0U;
  {
#line 1151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    res |= code & 1U;
#line 1153
    code >>= 1;
#line 1153
    res <<= 1;
#line 1151
    len --;
#line 1151
    if (! (len > 0)) {
#line 1151
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1155
  return (res >> 1);
}
}
#line 1161 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void bi_flush(deflate_state *s ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;

  {
#line 1164
  if (s->bi_valid == 16) {
#line 1165
    tmp = s->pending;
#line 1165
    (s->pending) ++;
#line 1165
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1165
    tmp___0 = s->pending;
#line 1165
    (s->pending) ++;
#line 1165
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 1166
    s->bi_buf = (ush )0;
#line 1167
    s->bi_valid = 0;
  } else
#line 1168
  if (s->bi_valid >= 8) {
#line 1169
    tmp___1 = s->pending;
#line 1169
    (s->pending) ++;
#line 1169
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
#line 1170
    s->bi_buf = (ush )((int )s->bi_buf >> 8);
#line 1171
    s->bi_valid -= 8;
  }
#line 1173
  return;
}
}
#line 1178 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void bi_windup(deflate_state *s ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;

  {
#line 1181
  if (s->bi_valid > 8) {
#line 1182
    tmp = s->pending;
#line 1182
    (s->pending) ++;
#line 1182
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1182
    tmp___0 = s->pending;
#line 1182
    (s->pending) ++;
#line 1182
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
  } else
#line 1183
  if (s->bi_valid > 0) {
#line 1184
    tmp___1 = s->pending;
#line 1184
    (s->pending) ++;
#line 1184
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
  }
#line 1186
  s->bi_buf = (ush )0;
#line 1187
  s->bi_valid = 0;
#line 1191
  return;
}
}
#line 1197 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/trees.c"
static void copy_block(deflate_state *s , charf *buf___1 , unsigned int len , int header ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  uInt tmp___3 ;
  charf *tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 1203
  bi_windup(s);
#line 1204
  s->last_eob_len = 8;
  }
#line 1206
  if (header) {
#line 1207
    tmp = s->pending;
#line 1207
    (s->pending) ++;
#line 1207
    *(s->pending_buf + tmp) = (uch )((int )((ush )len) & 255);
#line 1207
    tmp___0 = s->pending;
#line 1207
    (s->pending) ++;
#line 1207
    *(s->pending_buf + tmp___0) = (uch )((int )((ush )len) >> 8);
#line 1208
    tmp___1 = s->pending;
#line 1208
    (s->pending) ++;
#line 1208
    *(s->pending_buf + tmp___1) = (uch )((int )((ush )(~ len)) & 255);
#line 1208
    tmp___2 = s->pending;
#line 1208
    (s->pending) ++;
#line 1208
    *(s->pending_buf + tmp___2) = (uch )((int )((ush )(~ len)) >> 8);
  }
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    tmp___5 = len;
#line 1216
    len --;
#line 1216
    if (! tmp___5) {
#line 1216
      goto while_break;
    }
#line 1217
    tmp___3 = s->pending;
#line 1217
    (s->pending) ++;
#line 1217
    tmp___4 = buf___1;
#line 1217
    buf___1 ++;
#line 1217
    *(s->pending_buf + tmp___3) = (Bytef )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1219
  return;
}
}
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.h"
int inflate_table(codetype type , unsigned short *lens , unsigned int codes , code **table___0 ,
                  unsigned int *bits , unsigned short *work ) ;
#line 11 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
char const   inflate_copyright[47]  = 
#line 11 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
  {      (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'3',      (char const   )' ',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'5',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'M', 
        (char const   )'a',      (char const   )'r',      (char const   )'k',      (char const   )' ', 
        (char const   )'A',      (char const   )'d',      (char const   )'l',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'\000'};
#line 60 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
static unsigned short const   lbase[31]  = 
#line 60
  {      (unsigned short const   )3,      (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )7,      (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )13,      (unsigned short const   )15,      (unsigned short const   )17, 
        (unsigned short const   )19,      (unsigned short const   )23,      (unsigned short const   )27,      (unsigned short const   )31, 
        (unsigned short const   )35,      (unsigned short const   )43,      (unsigned short const   )51,      (unsigned short const   )59, 
        (unsigned short const   )67,      (unsigned short const   )83,      (unsigned short const   )99,      (unsigned short const   )115, 
        (unsigned short const   )131,      (unsigned short const   )163,      (unsigned short const   )195,      (unsigned short const   )227, 
        (unsigned short const   )258,      (unsigned short const   )0,      (unsigned short const   )0};
#line 63 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
static unsigned short const   lext[31]  = 
#line 63
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17, 
        (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21, 
        (unsigned short const   )16,      (unsigned short const   )201,      (unsigned short const   )196};
#line 66 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
static unsigned short const   dbase[32]  = 
#line 66
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )13, 
        (unsigned short const   )17,      (unsigned short const   )25,      (unsigned short const   )33,      (unsigned short const   )49, 
        (unsigned short const   )65,      (unsigned short const   )97,      (unsigned short const   )129,      (unsigned short const   )193, 
        (unsigned short const   )257,      (unsigned short const   )385,      (unsigned short const   )513,      (unsigned short const   )769, 
        (unsigned short const   )1025,      (unsigned short const   )1537,      (unsigned short const   )2049,      (unsigned short const   )3073, 
        (unsigned short const   )4097,      (unsigned short const   )6145,      (unsigned short const   )8193,      (unsigned short const   )12289, 
        (unsigned short const   )16385,      (unsigned short const   )24577,      (unsigned short const   )0,      (unsigned short const   )0};
#line 70 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
static unsigned short const   dext[32]  = 
#line 70
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )22, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )24,      (unsigned short const   )24, 
        (unsigned short const   )25,      (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )26, 
        (unsigned short const   )27,      (unsigned short const   )27,      (unsigned short const   )28,      (unsigned short const   )28, 
        (unsigned short const   )29,      (unsigned short const   )29,      (unsigned short const   )64,      (unsigned short const   )64};
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inftrees.c"
int inflate_table(codetype type , unsigned short *lens , unsigned int codes , code **table___0 ,
                  unsigned int *bits , unsigned short *work ) 
{ 
  unsigned int len ;
  unsigned int sym ;
  unsigned int min ;
  unsigned int max ;
  unsigned int root ;
  unsigned int curr ;
  unsigned int drop ;
  int left ;
  unsigned int used ;
  unsigned int huff ;
  unsigned int incr ;
  unsigned int fill ;
  unsigned int low ;
  unsigned int mask ;
  code this ;
  code *next ;
  unsigned short const   *base ;
  unsigned short const   *extra ;
  int end ;
  unsigned short count[16] ;
  unsigned short offs[16] ;
  code *tmp ;
  code *tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 107
  len = 0U;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (len <= 15U)) {
#line 107
      goto while_break;
    }
#line 108
    count[len] = (unsigned short)0;
#line 107
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  sym = 0U;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (sym < codes)) {
#line 109
      goto while_break___0;
    }
#line 110
    count[*(lens + sym)] = (unsigned short )((int )count[*(lens + sym)] + 1);
#line 109
    sym ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  root = *bits;
#line 114
  max = 15U;
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 114
    if (! (max >= 1U)) {
#line 114
      goto while_break___1;
    }
#line 115
    if ((int )count[max] != 0) {
#line 115
      goto while_break___1;
    }
#line 114
    max --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 116
  if (root > max) {
#line 116
    root = max;
  }
#line 117
  if (max == 0U) {
#line 118
    this.op = (unsigned char)64;
#line 119
    this.bits = (unsigned char)1;
#line 120
    this.val = (unsigned short)0;
#line 121
    tmp = *table___0;
#line 121
    (*table___0) ++;
#line 121
    *tmp = this;
#line 122
    tmp___0 = *table___0;
#line 122
    (*table___0) ++;
#line 122
    *tmp___0 = this;
#line 123
    *bits = 1U;
#line 124
    return (0);
  }
#line 126
  min = 1U;
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 126
    if (! (min <= 15U)) {
#line 126
      goto while_break___2;
    }
#line 127
    if ((int )count[min] != 0) {
#line 127
      goto while_break___2;
    }
#line 126
    min ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 128
  if (root < min) {
#line 128
    root = min;
  }
#line 131
  left = 1;
#line 132
  len = 1U;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (len <= 15U)) {
#line 132
      goto while_break___3;
    }
#line 133
    left <<= 1;
#line 134
    left -= (int )count[len];
#line 135
    if (left < 0) {
#line 135
      return (-1);
    }
#line 132
    len ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 137
  if (left > 0) {
#line 137
    if ((unsigned int )type == 0U) {
#line 138
      return (-1);
    } else
#line 137
    if (max != 1U) {
#line 138
      return (-1);
    }
  }
#line 141
  offs[1] = (unsigned short)0;
#line 142
  len = 1U;
  {
#line 142
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 142
    if (! (len < 15U)) {
#line 142
      goto while_break___4;
    }
#line 143
    offs[len + 1U] = (unsigned short )((int )offs[len] + (int )count[len]);
#line 142
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 146
  sym = 0U;
  {
#line 146
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 146
    if (! (sym < codes)) {
#line 146
      goto while_break___5;
    }
#line 147
    if ((int )*(lens + sym) != 0) {
#line 147
      tmp___1 = offs[*(lens + sym)];
#line 147
      offs[*(lens + sym)] = (unsigned short )((int )offs[*(lens + sym)] + 1);
#line 147
      *(work + tmp___1) = (unsigned short )sym;
    }
#line 146
    sym ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 183
  if ((unsigned int )type == 0U) {
#line 183
    goto case_0;
  }
#line 187
  if ((unsigned int )type == 1U) {
#line 187
    goto case_1;
  }
#line 194
  goto switch_default;
  case_0: /* CIL Label */ 
#line 184
  extra = (unsigned short const   *)work;
#line 184
  base = extra;
#line 185
  end = 19;
#line 186
  goto switch_break;
  case_1: /* CIL Label */ 
#line 188
  base = lbase;
#line 189
  base -= 257;
#line 190
  extra = lext;
#line 191
  extra -= 257;
#line 192
  end = 256;
#line 193
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 195
  base = dbase;
#line 196
  extra = dext;
#line 197
  end = -1;
  switch_break: /* CIL Label */ ;
  }
#line 201
  huff = 0U;
#line 202
  sym = 0U;
#line 203
  len = min;
#line 204
  next = *table___0;
#line 205
  curr = root;
#line 206
  drop = 0U;
#line 207
  low = 4294967295U;
#line 208
  used = 1U << root;
#line 209
  mask = used - 1U;
#line 212
  if ((unsigned int )type == 1U) {
#line 212
    if (used >= 1456U) {
#line 213
      return (1);
    }
  }
  {
#line 216
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 218
    this.bits = (unsigned char )(len - drop);
#line 219
    if ((int )*(work + sym) < end) {
#line 220
      this.op = (unsigned char)0;
#line 221
      this.val = *(work + sym);
    } else
#line 223
    if ((int )*(work + sym) > end) {
#line 224
      this.op = (unsigned char )*(extra + *(work + sym));
#line 225
      this.val = (unsigned short )*(base + *(work + sym));
    } else {
#line 228
      this.op = (unsigned char)96;
#line 229
      this.val = (unsigned short)0;
    }
#line 233
    incr = 1U << (len - drop);
#line 234
    fill = 1U << curr;
#line 235
    min = fill;
    {
#line 236
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 237
      fill -= incr;
#line 238
      *(next + ((huff >> drop) + fill)) = this;
#line 236
      if (! (fill != 0U)) {
#line 236
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 242
    incr = 1U << (len - 1U);
    {
#line 243
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 243
      if (! (huff & incr)) {
#line 243
        goto while_break___8;
      }
#line 244
      incr >>= 1;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 245
    if (incr != 0U) {
#line 246
      huff &= incr - 1U;
#line 247
      huff += incr;
    } else {
#line 250
      huff = 0U;
    }
#line 253
    sym ++;
#line 254
    count[len] = (unsigned short )((int )count[len] - 1);
#line 254
    if ((int )count[len] == 0) {
#line 255
      if (len == max) {
#line 255
        goto while_break___6;
      }
#line 256
      len = (unsigned int )*(lens + *(work + sym));
    }
#line 260
    if (len > root) {
#line 260
      if ((huff & mask) != low) {
#line 262
        if (drop == 0U) {
#line 263
          drop = root;
        }
#line 266
        next += min;
#line 269
        curr = len - drop;
#line 270
        left = 1 << curr;
        {
#line 271
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 271
          if (! (curr + drop < max)) {
#line 271
            goto while_break___9;
          }
#line 272
          left -= (int )count[curr + drop];
#line 273
          if (left <= 0) {
#line 273
            goto while_break___9;
          }
#line 274
          curr ++;
#line 275
          left <<= 1;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 279
        used += 1U << curr;
#line 280
        if ((unsigned int )type == 1U) {
#line 280
          if (used >= 1456U) {
#line 281
            return (1);
          }
        }
#line 284
        low = huff & mask;
#line 285
        (*table___0 + low)->op = (unsigned char )curr;
#line 286
        (*table___0 + low)->bits = (unsigned char )root;
#line 287
        (*table___0 + low)->val = (unsigned short )(next - *table___0);
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 298
  this.op = (unsigned char)64;
#line 299
  this.bits = (unsigned char )(len - drop);
#line 300
  this.val = (unsigned short)0;
  {
#line 301
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 301
    if (! (huff != 0U)) {
#line 301
      goto while_break___10;
    }
#line 303
    if (drop != 0U) {
#line 303
      if ((huff & mask) != low) {
#line 304
        drop = 0U;
#line 305
        len = root;
#line 306
        next = *table___0;
#line 307
        this.bits = (unsigned char )len;
      }
    }
#line 311
    *(next + (huff >> drop)) = this;
#line 314
    incr = 1U << (len - 1U);
    {
#line 315
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 315
      if (! (huff & incr)) {
#line 315
        goto while_break___11;
      }
#line 316
      incr >>= 1;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 317
    if (incr != 0U) {
#line 318
      huff &= incr - 1U;
#line 319
      huff += incr;
    } else {
#line 322
      huff = 0U;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 326
  *table___0 += used;
#line 327
  *bits = root;
#line 328
  return (0);
}
}
#line 745 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 767
int inflateSync(z_streamp strm ) ;
#line 782
int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 798
int inflateReset(z_streamp strm ) ;
#line 808
int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 824
int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1269
uLong adler32(uLong adler , Bytef const   *buf___1 , uInt len ) ;
#line 1334
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) ;
#line 1359
int inflateSyncPoint(z_streamp strm ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 11 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffast.h"
void inflate_fast(z_streamp strm , unsigned int start ) ;
#line 95 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
static void fixedtables(struct inflate_state *state ) ;
#line 96
static int updatewindow(z_streamp strm , unsigned int out ) ;
#line 100
static unsigned int syncsearch(unsigned int *have , unsigned char *buf___1 , unsigned int len ) ;
#line 103 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateReset(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  uLong tmp ;
  unsigned long tmp___0 ;
  code const   *tmp___1 ;
  code *tmp___2 ;

  {
#line 108
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 108
    return (-2);
  } else
#line 108
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 108
    return (-2);
  }
#line 109
  state = (struct inflate_state *)strm->state;
#line 110
  tmp___0 = 0UL;
#line 110
  state->total = tmp___0;
#line 110
  tmp = tmp___0;
#line 110
  strm->total_out = tmp;
#line 110
  strm->total_in = tmp;
#line 111
  strm->msg = (char *)0;
#line 112
  strm->adler = (uLong )1;
#line 113
  state->mode = (inflate_mode )0;
#line 114
  state->last = 0;
#line 115
  state->havedict = 0;
#line 116
  state->dmax = 32768U;
#line 117
  state->head = (gz_headerp )0;
#line 118
  state->wsize = 0U;
#line 119
  state->whave = 0U;
#line 120
  state->write = 0U;
#line 121
  state->hold = 0UL;
#line 122
  state->bits = 0U;
#line 123
  tmp___2 = state->codes;
#line 123
  state->next = tmp___2;
#line 123
  tmp___1 = (code const   *)tmp___2;
#line 123
  state->distcode = tmp___1;
#line 123
  state->lencode = tmp___1;
#line 125
  return (0);
}
}
#line 128 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflatePrime(z_streamp strm , int bits , int value ) 
{ 
  struct inflate_state *state ;

  {
#line 135
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 135
    return (-2);
  } else
#line 135
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 135
    return (-2);
  }
#line 136
  state = (struct inflate_state *)strm->state;
#line 137
  if (bits > 16) {
#line 137
    return (-2);
  } else
#line 137
  if (state->bits + (unsigned int )bits > 32U) {
#line 137
    return (-2);
  }
#line 138
  value = (int )((long )value & ((1L << bits) - 1L));
#line 139
  state->hold += (unsigned long )(value << state->bits);
#line 140
  state->bits += (unsigned int )bits;
#line 141
  return (0);
}
}
#line 144 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) 
{ 
  struct inflate_state *state ;
  voidpf tmp ;
  int tmp___0 ;

  {
#line 152
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 154
    return (-6);
  } else
#line 152
  if ((int const   )*(version + 0) != (int const   )*("1.2.3-optipng" + 0)) {
#line 154
    return (-6);
  } else
#line 152
  if (stream_size != (int )sizeof(z_stream )) {
#line 154
    return (-6);
  }
#line 155
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 155
    return (-2);
  }
#line 156
  strm->msg = (char *)0;
#line 157
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 158
    strm->zalloc = & zcalloc;
#line 159
    strm->opaque = (voidpf )0;
  }
#line 161
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 161
    strm->zfree = & zcfree;
  }
  {
#line 162
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 162
  state = (struct inflate_state *)tmp;
  }
#line 164
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 164
    return (-4);
  }
#line 166
  strm->state = (struct internal_state *)state;
#line 167
  if (windowBits < 0) {
#line 168
    state->wrap = 0;
#line 169
    windowBits = - windowBits;
  } else {
#line 172
    state->wrap = (windowBits >> 4) + 1;
  }
#line 177
  if (windowBits < 8) {
    {
#line 178
    (*(strm->zfree))(strm->opaque, (voidpf )state);
#line 179
    strm->state = (struct internal_state *)0;
    }
#line 180
    return (-2);
  } else
#line 177
  if (windowBits > 15) {
    {
#line 178
    (*(strm->zfree))(strm->opaque, (voidpf )state);
#line 179
    strm->state = (struct internal_state *)0;
    }
#line 180
    return (-2);
  }
  {
#line 182
  state->wbits = (unsigned int )windowBits;
#line 183
  state->window = (unsigned char *)0;
#line 184
  tmp___0 = inflateReset(strm);
  }
#line 184
  return (tmp___0);
}
}
#line 187 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 192
  tmp = inflateInit2_(strm, 15, version, stream_size);
  }
#line 192
  return (tmp);
}
}
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
static code const   lenfix[512]  = 
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
static code const   distfix[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 205 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
static void fixedtables(struct inflate_state *state ) 
{ 


  {
#line 242
  state->lencode = lenfix;
#line 243
  state->lenbits = 9U;
#line 244
  state->distcode = distfix;
#line 245
  state->distbits = 5U;
#line 246
  return;
}
}
#line 323 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
static int updatewindow(z_streamp strm , unsigned int out ) 
{ 
  struct inflate_state *state ;
  unsigned int copy ;
  unsigned int dist ;
  voidpf tmp ;

  {
#line 330
  state = (struct inflate_state *)strm->state;
#line 333
  if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
    {
#line 334
    tmp = (*(strm->zalloc))(strm->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 334
    state->window = (unsigned char *)tmp;
    }
#line 337
    if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
#line 337
      return (1);
    }
  }
#line 341
  if (state->wsize == 0U) {
#line 342
    state->wsize = 1U << state->wbits;
#line 343
    state->write = 0U;
#line 344
    state->whave = 0U;
  }
#line 348
  copy = out - strm->avail_out;
#line 349
  if (copy >= state->wsize) {
    {
#line 350
    memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(strm->next_out - state->wsize),
           (size_t )state->wsize);
#line 351
    state->write = 0U;
#line 352
    state->whave = state->wsize;
    }
  } else {
#line 355
    dist = state->wsize - state->write;
#line 356
    if (dist > copy) {
#line 356
      dist = copy;
    }
    {
#line 357
    memcpy((void */* __restrict  */)(state->window + state->write), (void const   */* __restrict  */)(strm->next_out - copy),
           (size_t )dist);
#line 358
    copy -= dist;
    }
#line 359
    if (copy) {
      {
#line 360
      memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(strm->next_out - copy),
             (size_t )copy);
#line 361
      state->write = copy;
#line 362
      state->whave = state->wsize;
      }
    } else {
#line 365
      state->write += dist;
#line 366
      if (state->write == state->wsize) {
#line 366
        state->write = 0U;
      }
#line 367
      if (state->whave < state->wsize) {
#line 367
        state->whave += dist;
      }
    }
  }
#line 370
  return (0);
}
}
#line 574 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
static unsigned short const   order[19]  = 
#line 574
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 554 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflate(z_streamp strm , int flush ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int in ;
  unsigned int out ;
  unsigned int copy ;
  unsigned char *from ;
  code this ;
  code last ;
  unsigned int len ;
  int ret ;
  unsigned char *tmp ;
  unsigned long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned long tmp___28 ;
  int tmp___29 ;
  unsigned long tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 577
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 579
    return (-2);
  } else
#line 577
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 579
    return (-2);
  } else
#line 577
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 579
    return (-2);
  } else
#line 577
  if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 577
    if (strm->avail_in != 0U) {
#line 579
      return (-2);
    }
  }
#line 581
  state = (struct inflate_state *)strm->state;
#line 582
  if ((unsigned int )state->mode == 11U) {
#line 582
    state->mode = (inflate_mode )12;
  }
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    put = strm->next_out;
#line 583
    left = strm->avail_out;
#line 583
    next = strm->next_in;
#line 583
    have = strm->avail_in;
#line 583
    hold = state->hold;
#line 583
    bits = state->bits;
#line 583
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  in = have;
#line 585
  out = left;
#line 586
  ret = 0;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 589
    if ((unsigned int )state->mode == 0U) {
#line 589
      goto case_0;
    }
#line 761
    if ((unsigned int )state->mode == 9U) {
#line 761
      goto case_9;
    }
#line 766
    if ((unsigned int )state->mode == 10U) {
#line 766
      goto case_10;
    }
#line 773
    if ((unsigned int )state->mode == 11U) {
#line 773
      goto case_11;
    }
#line 775
    if ((unsigned int )state->mode == 12U) {
#line 775
      goto case_12;
    }
#line 807
    if ((unsigned int )state->mode == 13U) {
#line 807
      goto case_13;
    }
#line 820
    if ((unsigned int )state->mode == 14U) {
#line 820
      goto case_14;
    }
#line 837
    if ((unsigned int )state->mode == 15U) {
#line 837
      goto case_15;
    }
#line 855
    if ((unsigned int )state->mode == 16U) {
#line 855
      goto case_16;
    }
#line 876
    if ((unsigned int )state->mode == 17U) {
#line 876
      goto case_17;
    }
#line 950
    if ((unsigned int )state->mode == 18U) {
#line 950
      goto case_18;
    }
#line 993
    if ((unsigned int )state->mode == 19U) {
#line 993
      goto case_19;
    }
#line 1001
    if ((unsigned int )state->mode == 20U) {
#line 1001
      goto case_20;
    }
#line 1026
    if ((unsigned int )state->mode == 21U) {
#line 1026
      goto case_21;
    }
#line 1046
    if ((unsigned int )state->mode == 22U) {
#line 1046
      goto case_22;
    }
#line 1071
    if ((unsigned int )state->mode == 23U) {
#line 1071
      goto case_23;
    }
#line 1077
    if ((unsigned int )state->mode == 24U) {
#line 1077
      goto case_24;
    }
#line 1114
    if ((unsigned int )state->mode == 26U) {
#line 1114
      goto case_26;
    }
#line 1117
    if ((unsigned int )state->mode == 27U) {
#line 1117
      goto case_27;
    }
#line 1120
    if ((unsigned int )state->mode == 28U) {
#line 1120
      goto case_28;
    }
#line 1123
    goto switch_default;
    case_0: /* CIL Label */ 
#line 590
    if (state->wrap == 0) {
#line 591
      state->mode = (inflate_mode )12;
#line 592
      goto switch_break;
    }
    {
#line 594
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 594
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 594
        if (! (bits < 16U)) {
#line 594
          goto while_break___2;
        }
        {
#line 594
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 594
          if (have == 0U) {
#line 594
            goto inf_leave;
          }
#line 594
          have --;
#line 594
          tmp = next;
#line 594
          next ++;
#line 594
          hold += (unsigned long )*tmp << bits;
#line 594
          bits += 8U;
#line 594
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 594
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 608
    if (((unsigned long )(((unsigned int )hold & ((1U << 8) - 1U)) << 8) + (hold >> 8)) % 31UL) {
#line 611
      strm->msg = (char *)"incorrect header check";
#line 612
      state->mode = (inflate_mode )27;
#line 613
      goto switch_break;
    }
#line 615
    if (((unsigned int )hold & ((1U << 4) - 1U)) != 8U) {
#line 616
      strm->msg = (char *)"unknown compression method";
#line 617
      state->mode = (inflate_mode )27;
#line 618
      goto switch_break;
    }
    {
#line 620
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 620
      hold >>= 4;
#line 620
      bits -= 4U;
#line 620
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 621
    len = ((unsigned int )hold & ((1U << 4) - 1U)) + 8U;
#line 622
    if (len > state->wbits) {
#line 623
      strm->msg = (char *)"invalid window size";
#line 624
      state->mode = (inflate_mode )27;
#line 625
      goto switch_break;
    }
    {
#line 627
    state->dmax = 1U << len;
#line 629
    tmp___0 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 629
    state->check = tmp___0;
#line 629
    strm->adler = tmp___0;
    }
#line 630
    if (hold & 512UL) {
#line 630
      state->mode = (inflate_mode )9;
    } else {
#line 630
      state->mode = (inflate_mode )11;
    }
    {
#line 631
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 631
      hold = 0UL;
#line 631
      bits = 0U;
#line 631
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 632
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 762
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 762
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 762
        if (! (bits < 32U)) {
#line 762
          goto while_break___7;
        }
        {
#line 762
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 762
          if (have == 0U) {
#line 762
            goto inf_leave;
          }
#line 762
          have --;
#line 762
          tmp___1 = next;
#line 762
          next ++;
#line 762
          hold += (unsigned long )*tmp___1 << bits;
#line 762
          bits += 8U;
#line 762
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 762
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 763
    tmp___2 = ((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24);
#line 763
    state->check = tmp___2;
#line 763
    strm->adler = tmp___2;
    {
#line 764
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 764
      hold = 0UL;
#line 764
      bits = 0U;
#line 764
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 765
    state->mode = (inflate_mode )10;
    case_10: /* CIL Label */ 
#line 767
    if (state->havedict == 0) {
      {
#line 768
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 768
        strm->next_out = put;
#line 768
        strm->avail_out = left;
#line 768
        strm->next_in = next;
#line 768
        strm->avail_in = have;
#line 768
        state->hold = hold;
#line 768
        state->bits = bits;
#line 768
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 769
      return (2);
    }
    {
#line 771
    tmp___3 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 771
    state->check = tmp___3;
#line 771
    strm->adler = tmp___3;
#line 772
    state->mode = (inflate_mode )11;
    }
    case_11: /* CIL Label */ 
#line 774
    if (flush == 5) {
#line 774
      goto inf_leave;
    }
    case_12: /* CIL Label */ 
#line 776
    if (state->last) {
      {
#line 777
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 777
        hold >>= bits & 7U;
#line 777
        bits -= bits & 7U;
#line 777
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 778
      state->mode = (inflate_mode )24;
#line 779
      goto switch_break;
    }
    {
#line 781
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 781
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 781
        if (! (bits < 3U)) {
#line 781
          goto while_break___13;
        }
        {
#line 781
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 781
          if (have == 0U) {
#line 781
            goto inf_leave;
          }
#line 781
          have --;
#line 781
          tmp___4 = next;
#line 781
          next ++;
#line 781
          hold += (unsigned long )*tmp___4 << bits;
#line 781
          bits += 8U;
#line 781
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 781
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 782
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 783
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 783
      hold >>= 1;
#line 783
      bits --;
#line 783
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 785
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 785
      goto case_0___0;
    }
#line 790
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 790
      goto case_1;
    }
#line 796
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 796
      goto case_2;
    }
#line 801
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 801
      goto case_3;
    }
#line 784
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 788
    state->mode = (inflate_mode )13;
#line 789
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 791
    fixedtables(state);
#line 794
    state->mode = (inflate_mode )18;
    }
#line 795
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 799
    state->mode = (inflate_mode )15;
#line 800
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 802
    strm->msg = (char *)"invalid block type";
#line 803
    state->mode = (inflate_mode )27;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 805
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 805
      hold >>= 2;
#line 805
      bits -= 2U;
#line 805
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 806
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 808
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 808
      hold >>= bits & 7U;
#line 808
      bits -= bits & 7U;
#line 808
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 809
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 809
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 809
        if (! (bits < 32U)) {
#line 809
          goto while_break___19;
        }
        {
#line 809
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 809
          if (have == 0U) {
#line 809
            goto inf_leave;
          }
#line 809
          have --;
#line 809
          tmp___5 = next;
#line 809
          next ++;
#line 809
          hold += (unsigned long )*tmp___5 << bits;
#line 809
          bits += 8U;
#line 809
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
#line 809
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 810
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 811
      strm->msg = (char *)"invalid stored block lengths";
#line 812
      state->mode = (inflate_mode )27;
#line 813
      goto switch_break;
    }
#line 815
    state->length = (unsigned int )hold & 65535U;
    {
#line 818
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 818
      hold = 0UL;
#line 818
      bits = 0U;
#line 818
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 819
    state->mode = (inflate_mode )14;
    case_14: /* CIL Label */ 
#line 821
    copy = state->length;
#line 822
    if (copy) {
#line 823
      if (copy > have) {
#line 823
        copy = have;
      }
#line 824
      if (copy > left) {
#line 824
        copy = left;
      }
#line 825
      if (copy == 0U) {
#line 825
        goto inf_leave;
      }
      {
#line 826
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 827
      have -= copy;
#line 828
      next += copy;
#line 829
      left -= copy;
#line 830
      put += copy;
#line 831
      state->length -= copy;
      }
#line 832
      goto switch_break;
    }
#line 835
    state->mode = (inflate_mode )11;
#line 836
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 838
    while (1) {
      while_continue___22: /* CIL Label */ ;
      {
#line 838
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 838
        if (! (bits < 14U)) {
#line 838
          goto while_break___23;
        }
        {
#line 838
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 838
          if (have == 0U) {
#line 838
            goto inf_leave;
          }
#line 838
          have --;
#line 838
          tmp___6 = next;
#line 838
          next ++;
#line 838
          hold += (unsigned long )*tmp___6 << bits;
#line 838
          bits += 8U;
#line 838
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
#line 838
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 839
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 840
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 840
      hold >>= 5;
#line 840
      bits -= 5U;
#line 840
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 841
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 842
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 842
      hold >>= 5;
#line 842
      bits -= 5U;
#line 842
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 843
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 844
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 844
      hold >>= 4;
#line 844
      bits -= 4U;
#line 844
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 846
    if (state->nlen > 286U) {
#line 847
      strm->msg = (char *)"too many length or distance symbols";
#line 848
      state->mode = (inflate_mode )27;
#line 849
      goto switch_break;
    } else
#line 846
    if (state->ndist > 30U) {
#line 847
      strm->msg = (char *)"too many length or distance symbols";
#line 848
      state->mode = (inflate_mode )27;
#line 849
      goto switch_break;
    }
#line 853
    state->have = 0U;
#line 854
    state->mode = (inflate_mode )16;
    case_16: /* CIL Label */ 
    {
#line 856
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 856
      if (! (state->have < state->ncode)) {
#line 856
        goto while_break___28;
      }
      {
#line 857
      while (1) {
        while_continue___29: /* CIL Label */ ;
        {
#line 857
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 857
          if (! (bits < 3U)) {
#line 857
            goto while_break___30;
          }
          {
#line 857
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 857
            if (have == 0U) {
#line 857
              goto inf_leave;
            }
#line 857
            have --;
#line 857
            tmp___7 = next;
#line 857
            next ++;
#line 857
            hold += (unsigned long )*tmp___7 << bits;
#line 857
            bits += 8U;
#line 857
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
        }
        while_break___30: /* CIL Label */ ;
        }
#line 857
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 858
      tmp___8 = state->have;
#line 858
      (state->have) ++;
#line 858
      state->lens[order[tmp___8]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 859
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 859
        hold >>= 3;
#line 859
        bits -= 3U;
#line 859
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 861
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 861
      if (! (state->have < 19U)) {
#line 861
        goto while_break___33;
      }
#line 862
      tmp___9 = state->have;
#line 862
      (state->have) ++;
#line 862
      state->lens[order[tmp___9]] = (unsigned short)0;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 863
    state->next = state->codes;
#line 864
    state->lencode = (code const   *)state->next;
#line 865
    state->lenbits = 7U;
#line 866
    ret = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                        state->work);
    }
#line 868
    if (ret) {
#line 869
      strm->msg = (char *)"invalid code lengths set";
#line 870
      state->mode = (inflate_mode )27;
#line 871
      goto switch_break;
    }
#line 874
    state->have = 0U;
#line 875
    state->mode = (inflate_mode )17;
    case_17: /* CIL Label */ 
    {
#line 877
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 877
      if (! (state->have < state->nlen + state->ndist)) {
#line 877
        goto while_break___34;
      }
      {
#line 878
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 879
        this = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 880
        if ((unsigned int )this.bits <= bits) {
#line 880
          goto while_break___35;
        }
        {
#line 881
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 881
          if (have == 0U) {
#line 881
            goto inf_leave;
          }
#line 881
          have --;
#line 881
          tmp___10 = next;
#line 881
          next ++;
#line 881
          hold += (unsigned long )*tmp___10 << bits;
#line 881
          bits += 8U;
#line 881
          goto while_break___36;
        }
        while_break___36: /* CIL Label */ ;
        }
      }
      while_break___35: /* CIL Label */ ;
      }
#line 883
      if ((int )this.val < 16) {
        {
#line 884
        while (1) {
          while_continue___37: /* CIL Label */ ;
          {
#line 884
          while (1) {
            while_continue___38: /* CIL Label */ ;
#line 884
            if (! (bits < (unsigned int )this.bits)) {
#line 884
              goto while_break___38;
            }
            {
#line 884
            while (1) {
              while_continue___39: /* CIL Label */ ;
#line 884
              if (have == 0U) {
#line 884
                goto inf_leave;
              }
#line 884
              have --;
#line 884
              tmp___11 = next;
#line 884
              next ++;
#line 884
              hold += (unsigned long )*tmp___11 << bits;
#line 884
              bits += 8U;
#line 884
              goto while_break___39;
            }
            while_break___39: /* CIL Label */ ;
            }
          }
          while_break___38: /* CIL Label */ ;
          }
#line 884
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
        {
#line 885
        while (1) {
          while_continue___40: /* CIL Label */ ;
#line 885
          hold >>= (int )this.bits;
#line 885
          bits -= (unsigned int )this.bits;
#line 885
          goto while_break___40;
        }
        while_break___40: /* CIL Label */ ;
        }
#line 886
        tmp___12 = state->have;
#line 886
        (state->have) ++;
#line 886
        state->lens[tmp___12] = this.val;
      } else {
#line 889
        if ((int )this.val == 16) {
          {
#line 890
          while (1) {
            while_continue___41: /* CIL Label */ ;
            {
#line 890
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 890
              if (! (bits < (unsigned int )((int )this.bits + 2))) {
#line 890
                goto while_break___42;
              }
              {
#line 890
              while (1) {
                while_continue___43: /* CIL Label */ ;
#line 890
                if (have == 0U) {
#line 890
                  goto inf_leave;
                }
#line 890
                have --;
#line 890
                tmp___13 = next;
#line 890
                next ++;
#line 890
                hold += (unsigned long )*tmp___13 << bits;
#line 890
                bits += 8U;
#line 890
                goto while_break___43;
              }
              while_break___43: /* CIL Label */ ;
              }
            }
            while_break___42: /* CIL Label */ ;
            }
#line 890
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
          {
#line 891
          while (1) {
            while_continue___44: /* CIL Label */ ;
#line 891
            hold >>= (int )this.bits;
#line 891
            bits -= (unsigned int )this.bits;
#line 891
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
#line 892
          if (state->have == 0U) {
#line 893
            strm->msg = (char *)"invalid bit length repeat";
#line 894
            state->mode = (inflate_mode )27;
#line 895
            goto while_break___34;
          }
#line 897
          len = (unsigned int )state->lens[state->have - 1U];
#line 898
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 899
          while (1) {
            while_continue___45: /* CIL Label */ ;
#line 899
            hold >>= 2;
#line 899
            bits -= 2U;
#line 899
            goto while_break___45;
          }
          while_break___45: /* CIL Label */ ;
          }
        } else
#line 901
        if ((int )this.val == 17) {
          {
#line 902
          while (1) {
            while_continue___46: /* CIL Label */ ;
            {
#line 902
            while (1) {
              while_continue___47: /* CIL Label */ ;
#line 902
              if (! (bits < (unsigned int )((int )this.bits + 3))) {
#line 902
                goto while_break___47;
              }
              {
#line 902
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 902
                if (have == 0U) {
#line 902
                  goto inf_leave;
                }
#line 902
                have --;
#line 902
                tmp___14 = next;
#line 902
                next ++;
#line 902
                hold += (unsigned long )*tmp___14 << bits;
#line 902
                bits += 8U;
#line 902
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
            }
            while_break___47: /* CIL Label */ ;
            }
#line 902
            goto while_break___46;
          }
          while_break___46: /* CIL Label */ ;
          }
          {
#line 903
          while (1) {
            while_continue___49: /* CIL Label */ ;
#line 903
            hold >>= (int )this.bits;
#line 903
            bits -= (unsigned int )this.bits;
#line 903
            goto while_break___49;
          }
          while_break___49: /* CIL Label */ ;
          }
#line 904
          len = 0U;
#line 905
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 906
          while (1) {
            while_continue___50: /* CIL Label */ ;
#line 906
            hold >>= 3;
#line 906
            bits -= 3U;
#line 906
            goto while_break___50;
          }
          while_break___50: /* CIL Label */ ;
          }
        } else {
          {
#line 909
          while (1) {
            while_continue___51: /* CIL Label */ ;
            {
#line 909
            while (1) {
              while_continue___52: /* CIL Label */ ;
#line 909
              if (! (bits < (unsigned int )((int )this.bits + 7))) {
#line 909
                goto while_break___52;
              }
              {
#line 909
              while (1) {
                while_continue___53: /* CIL Label */ ;
#line 909
                if (have == 0U) {
#line 909
                  goto inf_leave;
                }
#line 909
                have --;
#line 909
                tmp___15 = next;
#line 909
                next ++;
#line 909
                hold += (unsigned long )*tmp___15 << bits;
#line 909
                bits += 8U;
#line 909
                goto while_break___53;
              }
              while_break___53: /* CIL Label */ ;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
#line 909
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
          {
#line 910
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 910
            hold >>= (int )this.bits;
#line 910
            bits -= (unsigned int )this.bits;
#line 910
            goto while_break___54;
          }
          while_break___54: /* CIL Label */ ;
          }
#line 911
          len = 0U;
#line 912
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 913
          while (1) {
            while_continue___55: /* CIL Label */ ;
#line 913
            hold >>= 7;
#line 913
            bits -= 7U;
#line 913
            goto while_break___55;
          }
          while_break___55: /* CIL Label */ ;
          }
        }
#line 915
        if (state->have + copy > state->nlen + state->ndist) {
#line 916
          strm->msg = (char *)"invalid bit length repeat";
#line 917
          state->mode = (inflate_mode )27;
#line 918
          goto while_break___34;
        }
        {
#line 920
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 920
          tmp___17 = copy;
#line 920
          copy --;
#line 920
          if (! tmp___17) {
#line 920
            goto while_break___56;
          }
#line 921
          tmp___16 = state->have;
#line 921
          (state->have) ++;
#line 921
          state->lens[tmp___16] = (unsigned short )len;
        }
        while_break___56: /* CIL Label */ ;
        }
      }
    }
    while_break___34: /* CIL Label */ ;
    }
#line 926
    if ((unsigned int )state->mode == 27U) {
#line 926
      goto switch_break;
    }
    {
#line 929
    state->next = state->codes;
#line 930
    state->lencode = (code const   *)state->next;
#line 931
    state->lenbits = 9U;
#line 932
    ret = inflate_table((codetype )1, state->lens, state->nlen, & state->next, & state->lenbits,
                        state->work);
    }
#line 934
    if (ret) {
#line 935
      strm->msg = (char *)"invalid literal/lengths set";
#line 936
      state->mode = (inflate_mode )27;
#line 937
      goto switch_break;
    }
    {
#line 939
    state->distcode = (code const   *)state->next;
#line 940
    state->distbits = 6U;
#line 941
    ret = inflate_table((codetype )2, state->lens + state->nlen, state->ndist, & state->next,
                        & state->distbits, state->work);
    }
#line 943
    if (ret) {
#line 944
      strm->msg = (char *)"invalid distances set";
#line 945
      state->mode = (inflate_mode )27;
#line 946
      goto switch_break;
    }
#line 949
    state->mode = (inflate_mode )18;
    case_18: /* CIL Label */ 
#line 951
    if (have >= 6U) {
#line 951
      if (left >= 258U) {
        {
#line 952
        while (1) {
          while_continue___57: /* CIL Label */ ;
#line 952
          strm->next_out = put;
#line 952
          strm->avail_out = left;
#line 952
          strm->next_in = next;
#line 952
          strm->avail_in = have;
#line 952
          state->hold = hold;
#line 952
          state->bits = bits;
#line 952
          goto while_break___57;
        }
        while_break___57: /* CIL Label */ ;
        }
        {
#line 953
        inflate_fast(strm, out);
        }
        {
#line 954
        while (1) {
          while_continue___58: /* CIL Label */ ;
#line 954
          put = strm->next_out;
#line 954
          left = strm->avail_out;
#line 954
          next = strm->next_in;
#line 954
          have = strm->avail_in;
#line 954
          hold = state->hold;
#line 954
          bits = state->bits;
#line 954
          goto while_break___58;
        }
        while_break___58: /* CIL Label */ ;
        }
#line 955
        goto switch_break;
      }
    }
    {
#line 957
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 958
      this = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 959
      if ((unsigned int )this.bits <= bits) {
#line 959
        goto while_break___59;
      }
      {
#line 960
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 960
        if (have == 0U) {
#line 960
          goto inf_leave;
        }
#line 960
        have --;
#line 960
        tmp___18 = next;
#line 960
        next ++;
#line 960
        hold += (unsigned long )*tmp___18 << bits;
#line 960
        bits += 8U;
#line 960
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
    }
    while_break___59: /* CIL Label */ ;
    }
#line 962
    if (this.op) {
#line 962
      if (((int )this.op & 240) == 0) {
#line 963
        last = this;
        {
#line 964
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 965
          this = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 967
          if ((unsigned int )((int )last.bits + (int )this.bits) <= bits) {
#line 967
            goto while_break___61;
          }
          {
#line 968
          while (1) {
            while_continue___62: /* CIL Label */ ;
#line 968
            if (have == 0U) {
#line 968
              goto inf_leave;
            }
#line 968
            have --;
#line 968
            tmp___19 = next;
#line 968
            next ++;
#line 968
            hold += (unsigned long )*tmp___19 << bits;
#line 968
            bits += 8U;
#line 968
            goto while_break___62;
          }
          while_break___62: /* CIL Label */ ;
          }
        }
        while_break___61: /* CIL Label */ ;
        }
        {
#line 970
        while (1) {
          while_continue___63: /* CIL Label */ ;
#line 970
          hold >>= (int )last.bits;
#line 970
          bits -= (unsigned int )last.bits;
#line 970
          goto while_break___63;
        }
        while_break___63: /* CIL Label */ ;
        }
      }
    }
    {
#line 972
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 972
      hold >>= (int )this.bits;
#line 972
      bits -= (unsigned int )this.bits;
#line 972
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 973
    state->length = (unsigned int )this.val;
#line 974
    if ((int )this.op == 0) {
#line 978
      state->mode = (inflate_mode )23;
#line 979
      goto switch_break;
    }
#line 981
    if ((int )this.op & 32) {
#line 983
      state->mode = (inflate_mode )11;
#line 984
      goto switch_break;
    }
#line 986
    if ((int )this.op & 64) {
#line 987
      strm->msg = (char *)"invalid literal/length code";
#line 988
      state->mode = (inflate_mode )27;
#line 989
      goto switch_break;
    }
#line 991
    state->extra = (unsigned int )this.op & 15U;
#line 992
    state->mode = (inflate_mode )19;
    case_19: /* CIL Label */ 
#line 994
    if (state->extra) {
      {
#line 995
      while (1) {
        while_continue___65: /* CIL Label */ ;
        {
#line 995
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 995
          if (! (bits < state->extra)) {
#line 995
            goto while_break___66;
          }
          {
#line 995
          while (1) {
            while_continue___67: /* CIL Label */ ;
#line 995
            if (have == 0U) {
#line 995
              goto inf_leave;
            }
#line 995
            have --;
#line 995
            tmp___20 = next;
#line 995
            next ++;
#line 995
            hold += (unsigned long )*tmp___20 << bits;
#line 995
            bits += 8U;
#line 995
            goto while_break___67;
          }
          while_break___67: /* CIL Label */ ;
          }
        }
        while_break___66: /* CIL Label */ ;
        }
#line 995
        goto while_break___65;
      }
      while_break___65: /* CIL Label */ ;
      }
#line 996
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 997
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 997
        hold >>= state->extra;
#line 997
        bits -= state->extra;
#line 997
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
    }
#line 1000
    state->mode = (inflate_mode )20;
    case_20: /* CIL Label */ 
    {
#line 1002
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1003
      this = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 1004
      if ((unsigned int )this.bits <= bits) {
#line 1004
        goto while_break___69;
      }
      {
#line 1005
      while (1) {
        while_continue___70: /* CIL Label */ ;
#line 1005
        if (have == 0U) {
#line 1005
          goto inf_leave;
        }
#line 1005
        have --;
#line 1005
        tmp___21 = next;
#line 1005
        next ++;
#line 1005
        hold += (unsigned long )*tmp___21 << bits;
#line 1005
        bits += 8U;
#line 1005
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
    }
    while_break___69: /* CIL Label */ ;
    }
#line 1007
    if (((int )this.op & 240) == 0) {
#line 1008
      last = this;
      {
#line 1009
      while (1) {
        while_continue___71: /* CIL Label */ ;
#line 1010
        this = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 1012
        if ((unsigned int )((int )last.bits + (int )this.bits) <= bits) {
#line 1012
          goto while_break___71;
        }
        {
#line 1013
        while (1) {
          while_continue___72: /* CIL Label */ ;
#line 1013
          if (have == 0U) {
#line 1013
            goto inf_leave;
          }
#line 1013
          have --;
#line 1013
          tmp___22 = next;
#line 1013
          next ++;
#line 1013
          hold += (unsigned long )*tmp___22 << bits;
#line 1013
          bits += 8U;
#line 1013
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
      }
      while_break___71: /* CIL Label */ ;
      }
      {
#line 1015
      while (1) {
        while_continue___73: /* CIL Label */ ;
#line 1015
        hold >>= (int )last.bits;
#line 1015
        bits -= (unsigned int )last.bits;
#line 1015
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
    }
    {
#line 1017
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 1017
      hold >>= (int )this.bits;
#line 1017
      bits -= (unsigned int )this.bits;
#line 1017
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
#line 1018
    if ((int )this.op & 64) {
#line 1019
      strm->msg = (char *)"invalid distance code";
#line 1020
      state->mode = (inflate_mode )27;
#line 1021
      goto switch_break;
    }
#line 1023
    state->offset = (unsigned int )this.val;
#line 1024
    state->extra = (unsigned int )this.op & 15U;
#line 1025
    state->mode = (inflate_mode )21;
    case_21: /* CIL Label */ 
#line 1027
    if (state->extra) {
      {
#line 1028
      while (1) {
        while_continue___75: /* CIL Label */ ;
        {
#line 1028
        while (1) {
          while_continue___76: /* CIL Label */ ;
#line 1028
          if (! (bits < state->extra)) {
#line 1028
            goto while_break___76;
          }
          {
#line 1028
          while (1) {
            while_continue___77: /* CIL Label */ ;
#line 1028
            if (have == 0U) {
#line 1028
              goto inf_leave;
            }
#line 1028
            have --;
#line 1028
            tmp___23 = next;
#line 1028
            next ++;
#line 1028
            hold += (unsigned long )*tmp___23 << bits;
#line 1028
            bits += 8U;
#line 1028
            goto while_break___77;
          }
          while_break___77: /* CIL Label */ ;
          }
        }
        while_break___76: /* CIL Label */ ;
        }
#line 1028
        goto while_break___75;
      }
      while_break___75: /* CIL Label */ ;
      }
#line 1029
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 1030
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 1030
        hold >>= state->extra;
#line 1030
        bits -= state->extra;
#line 1030
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
    }
#line 1039
    if (state->offset > (state->whave + out) - left) {
#line 1040
      strm->msg = (char *)"invalid distance too far back";
#line 1041
      state->mode = (inflate_mode )27;
#line 1042
      goto switch_break;
    }
#line 1045
    state->mode = (inflate_mode )22;
    case_22: /* CIL Label */ 
#line 1047
    if (left == 0U) {
#line 1047
      goto inf_leave;
    }
#line 1048
    copy = out - left;
#line 1049
    if (state->offset > copy) {
#line 1050
      copy = state->offset - copy;
#line 1051
      if (copy > state->write) {
#line 1052
        copy -= state->write;
#line 1053
        from = state->window + (state->wsize - copy);
      } else {
#line 1056
        from = state->window + (state->write - copy);
      }
#line 1057
      if (copy > state->length) {
#line 1057
        copy = state->length;
      }
    } else {
#line 1060
      from = put - state->offset;
#line 1061
      copy = state->length;
    }
#line 1063
    if (copy > left) {
#line 1063
      copy = left;
    }
#line 1064
    left -= copy;
#line 1065
    state->length -= copy;
    {
#line 1066
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 1067
      tmp___24 = put;
#line 1067
      put ++;
#line 1067
      tmp___25 = from;
#line 1067
      from ++;
#line 1067
      *tmp___24 = *tmp___25;
#line 1066
      copy --;
#line 1066
      if (! copy) {
#line 1066
        goto while_break___79;
      }
    }
    while_break___79: /* CIL Label */ ;
    }
#line 1069
    if (state->length == 0U) {
#line 1069
      state->mode = (inflate_mode )18;
    }
#line 1070
    goto switch_break;
    case_23: /* CIL Label */ 
#line 1072
    if (left == 0U) {
#line 1072
      goto inf_leave;
    }
#line 1073
    tmp___26 = put;
#line 1073
    put ++;
#line 1073
    *tmp___26 = (unsigned char )state->length;
#line 1074
    left --;
#line 1075
    state->mode = (inflate_mode )18;
#line 1076
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1078
    if (state->wrap) {
      {
#line 1079
      while (1) {
        while_continue___80: /* CIL Label */ ;
        {
#line 1079
        while (1) {
          while_continue___81: /* CIL Label */ ;
#line 1079
          if (! (bits < 32U)) {
#line 1079
            goto while_break___81;
          }
          {
#line 1079
          while (1) {
            while_continue___82: /* CIL Label */ ;
#line 1079
            if (have == 0U) {
#line 1079
              goto inf_leave;
            }
#line 1079
            have --;
#line 1079
            tmp___27 = next;
#line 1079
            next ++;
#line 1079
            hold += (unsigned long )*tmp___27 << bits;
#line 1079
            bits += 8U;
#line 1079
            goto while_break___82;
          }
          while_break___82: /* CIL Label */ ;
          }
        }
        while_break___81: /* CIL Label */ ;
        }
#line 1079
        goto while_break___80;
      }
      while_break___80: /* CIL Label */ ;
      }
#line 1080
      out -= left;
#line 1081
      strm->total_out += (uLong )out;
#line 1082
      state->total += (unsigned long )out;
#line 1083
      if (out) {
        {
#line 1084
        tmp___28 = adler32(state->check, (Bytef const   *)(put - out), out);
#line 1084
        state->check = tmp___28;
#line 1084
        strm->adler = tmp___28;
        }
      }
#line 1086
      out = left;
#line 1087
      if (((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24) != state->check) {
#line 1092
        strm->msg = (char *)"incorrect data check";
#line 1093
        state->mode = (inflate_mode )27;
#line 1094
        goto switch_break;
      }
      {
#line 1096
      while (1) {
        while_continue___83: /* CIL Label */ ;
#line 1096
        hold = 0UL;
#line 1096
        bits = 0U;
#line 1096
        goto while_break___83;
      }
      while_break___83: /* CIL Label */ ;
      }
    }
#line 1113
    state->mode = (inflate_mode )26;
    case_26: /* CIL Label */ 
#line 1115
    ret = 1;
#line 1116
    goto inf_leave;
    case_27: /* CIL Label */ 
#line 1118
    ret = -3;
#line 1119
    goto inf_leave;
    case_28: /* CIL Label */ 
#line 1121
    return (-4);
    switch_default: /* CIL Label */ 
#line 1124
    return (-2);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  inf_leave: 
  {
#line 1134
  while (1) {
    while_continue___84: /* CIL Label */ ;
#line 1134
    strm->next_out = put;
#line 1134
    strm->avail_out = left;
#line 1134
    strm->next_in = next;
#line 1134
    strm->avail_in = have;
#line 1134
    state->hold = hold;
#line 1134
    state->bits = bits;
#line 1134
    goto while_break___84;
  }
  while_break___84: /* CIL Label */ ;
  }
#line 1135
  if (state->wsize) {
#line 1135
    goto _L;
  } else
#line 1135
  if ((unsigned int )state->mode < 24U) {
#line 1135
    if (out != strm->avail_out) {
      _L: /* CIL Label */ 
      {
#line 1136
      tmp___29 = updatewindow(strm, out);
      }
#line 1136
      if (tmp___29) {
#line 1137
        state->mode = (inflate_mode )28;
#line 1138
        return (-4);
      }
    }
  }
#line 1140
  in -= strm->avail_in;
#line 1141
  out -= strm->avail_out;
#line 1142
  strm->total_in += (uLong )in;
#line 1143
  strm->total_out += (uLong )out;
#line 1144
  state->total += (unsigned long )out;
#line 1145
  if (state->wrap) {
#line 1145
    if (out) {
      {
#line 1146
      tmp___30 = adler32(state->check, (Bytef const   *)(strm->next_out - out), out);
#line 1146
      state->check = tmp___30;
#line 1146
      strm->adler = tmp___30;
      }
    }
  }
#line 1148
  if (state->last) {
#line 1148
    tmp___31 = 64;
  } else {
#line 1148
    tmp___31 = 0;
  }
#line 1148
  if ((unsigned int )state->mode == 11U) {
#line 1148
    tmp___32 = 128;
  } else {
#line 1148
    tmp___32 = 0;
  }
#line 1148
  strm->data_type = (int )((state->bits + (unsigned int )tmp___31) + (unsigned int )tmp___32);
#line 1150
  if (in == 0U) {
#line 1150
    if (out == 0U) {
#line 1150
      goto _L___0;
    } else {
#line 1150
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1150
  if (flush == 4) {
    _L___0: /* CIL Label */ 
#line 1150
    if (ret == 0) {
#line 1151
      ret = -5;
    }
  }
#line 1152
  return (ret);
}
}
#line 1155 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateEnd(z_streamp strm ) 
{ 
  struct inflate_state *state ;

  {
#line 1159
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1160
    return (-2);
  } else
#line 1159
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1160
    return (-2);
  } else
#line 1159
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 1160
    return (-2);
  }
#line 1161
  state = (struct inflate_state *)strm->state;
#line 1162
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1162
    (*(strm->zfree))(strm->opaque, (voidpf )state->window);
    }
  }
  {
#line 1163
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 1164
  strm->state = (struct internal_state *)0;
  }
#line 1166
  return (0);
}
}
#line 1169 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  struct inflate_state *state ;
  unsigned long id ;
  int tmp ;

  {
#line 1178
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1178
    return (-2);
  } else
#line 1178
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1178
    return (-2);
  }
#line 1179
  state = (struct inflate_state *)strm->state;
#line 1180
  if (state->wrap != 0) {
#line 1180
    if ((unsigned int )state->mode != 10U) {
#line 1181
      return (-2);
    }
  }
#line 1184
  if ((unsigned int )state->mode == 10U) {
    {
#line 1185
    id = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 1186
    id = adler32(id, dictionary, dictLength);
    }
#line 1187
    if (id != state->check) {
#line 1188
      return (-3);
    }
  }
  {
#line 1192
  tmp = updatewindow(strm, strm->avail_out);
  }
#line 1192
  if (tmp) {
#line 1193
    state->mode = (inflate_mode )28;
#line 1194
    return (-4);
  }
#line 1196
  if (dictLength > state->wsize) {
    {
#line 1197
    memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)((dictionary + dictLength) - state->wsize),
           (size_t )state->wsize);
#line 1199
    state->whave = state->wsize;
    }
  } else {
    {
#line 1202
    memcpy((void */* __restrict  */)((state->window + state->wsize) - dictLength),
           (void const   */* __restrict  */)dictionary, (size_t )dictLength);
#line 1204
    state->whave = dictLength;
    }
  }
#line 1206
  state->havedict = 1;
#line 1208
  return (0);
}
}
#line 1211 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateGetHeader(z_streamp strm , gz_headerp head ) 
{ 
  struct inflate_state *state ;

  {
#line 1218
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1218
    return (-2);
  } else
#line 1218
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1218
    return (-2);
  }
#line 1219
  state = (struct inflate_state *)strm->state;
#line 1220
  if ((state->wrap & 2) == 0) {
#line 1220
    return (-2);
  }
#line 1223
  state->head = head;
#line 1224
  head->done = 0;
#line 1225
  return (0);
}
}
#line 1239 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
static unsigned int syncsearch(unsigned int *have , unsigned char *buf___1 , unsigned int len ) 
{ 
  unsigned int got ;
  unsigned int next ;
  int tmp ;

  {
#line 1247
  got = *have;
#line 1248
  next = 0U;
  {
#line 1249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1249
    if (next < len) {
#line 1249
      if (! (got < 4U)) {
#line 1249
        goto while_break;
      }
    } else {
#line 1249
      goto while_break;
    }
#line 1250
    if (got < 2U) {
#line 1250
      tmp = 0;
    } else {
#line 1250
      tmp = 255;
    }
#line 1250
    if ((int )*(buf___1 + next) == tmp) {
#line 1251
      got ++;
    } else
#line 1252
    if (*(buf___1 + next)) {
#line 1253
      got = 0U;
    } else {
#line 1255
      got = 4U - got;
    }
#line 1256
    next ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  *have = got;
#line 1259
  return (next);
}
}
#line 1262 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateSync(z_streamp strm ) 
{ 
  unsigned int len ;
  unsigned long in ;
  unsigned long out ;
  unsigned char buf___1[4] ;
  struct inflate_state *state ;
  unsigned int tmp ;

  {
#line 1271
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1271
    return (-2);
  } else
#line 1271
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1271
    return (-2);
  }
#line 1272
  state = (struct inflate_state *)strm->state;
#line 1273
  if (strm->avail_in == 0U) {
#line 1273
    if (state->bits < 8U) {
#line 1273
      return (-5);
    }
  }
#line 1276
  if ((unsigned int )state->mode != 29U) {
#line 1277
    state->mode = (inflate_mode )29;
#line 1278
    state->hold <<= state->bits & 7U;
#line 1279
    state->bits -= state->bits & 7U;
#line 1280
    len = 0U;
    {
#line 1281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1281
      if (! (state->bits >= 8U)) {
#line 1281
        goto while_break;
      }
#line 1282
      tmp = len;
#line 1282
      len ++;
#line 1282
      buf___1[tmp] = (unsigned char )state->hold;
#line 1283
      state->hold >>= 8;
#line 1284
      state->bits -= 8U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1286
    state->have = 0U;
#line 1287
    syncsearch(& state->have, buf___1, len);
    }
  }
  {
#line 1291
  len = syncsearch(& state->have, strm->next_in, strm->avail_in);
#line 1292
  strm->avail_in -= len;
#line 1293
  strm->next_in += len;
#line 1294
  strm->total_in += (uLong )len;
  }
#line 1297
  if (state->have != 4U) {
#line 1297
    return (-3);
  }
  {
#line 1298
  in = strm->total_in;
#line 1298
  out = strm->total_out;
#line 1299
  inflateReset(strm);
#line 1300
  strm->total_in = in;
#line 1300
  strm->total_out = out;
#line 1301
  state->mode = (inflate_mode )11;
  }
#line 1302
  return (0);
}
}
#line 1313 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateSyncPoint(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
#line 1318
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1318
    return (-2);
  } else
#line 1318
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1318
    return (-2);
  }
#line 1319
  state = (struct inflate_state *)strm->state;
#line 1320
  if ((unsigned int )state->mode == 13U) {
#line 1320
    if (state->bits == 0U) {
#line 1320
      tmp = 1;
    } else {
#line 1320
      tmp = 0;
    }
  } else {
#line 1320
    tmp = 0;
  }
#line 1320
  return (tmp);
}
}
#line 1323 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inflate.c"
int inflateCopy(z_streamp dest , z_streamp source ) 
{ 
  struct inflate_state *state ;
  struct inflate_state *copy ;
  unsigned char *window ;
  unsigned int wsize ;
  voidpf tmp ;
  voidpf tmp___0 ;

  {
#line 1333
  if ((unsigned long )dest == (unsigned long )((z_streamp )0)) {
#line 1335
    return (-2);
  } else
#line 1333
  if ((unsigned long )source == (unsigned long )((z_streamp )0)) {
#line 1335
    return (-2);
  } else
#line 1333
  if ((unsigned long )source->state == (unsigned long )((struct internal_state *)0)) {
#line 1335
    return (-2);
  } else
#line 1333
  if ((unsigned long )source->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                     uInt items ,
                                                                     uInt size ))0)) {
#line 1335
    return (-2);
  } else
#line 1333
  if ((unsigned long )source->zfree == (unsigned long )((void (*)(voidpf opaque ,
                                                                  voidpf address ))0)) {
#line 1335
    return (-2);
  }
  {
#line 1336
  state = (struct inflate_state *)source->state;
#line 1339
  tmp = (*(source->zalloc))(source->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 1339
  copy = (struct inflate_state *)tmp;
  }
#line 1341
  if ((unsigned long )copy == (unsigned long )((struct inflate_state *)0)) {
#line 1341
    return (-4);
  }
#line 1342
  window = (unsigned char *)0;
#line 1343
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1344
    tmp___0 = (*(source->zalloc))(source->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 1344
    window = (unsigned char *)tmp___0;
    }
#line 1346
    if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
      {
#line 1347
      (*(source->zfree))(source->opaque, (voidpf )copy);
      }
#line 1348
      return (-4);
    }
  }
  {
#line 1353
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)source, sizeof(z_stream ));
#line 1354
  memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)state, sizeof(struct inflate_state ));
  }
#line 1355
  if ((unsigned long )state->lencode >= (unsigned long )(state->codes)) {
#line 1355
    if ((unsigned long )state->lencode <= (unsigned long )((state->codes + 2048) - 1)) {
#line 1357
      copy->lencode = (code const   *)(copy->codes + (state->lencode - (code const   *)(state->codes)));
#line 1358
      copy->distcode = (code const   *)(copy->codes + (state->distcode - (code const   *)(state->codes)));
    }
  }
#line 1360
  copy->next = copy->codes + (state->next - state->codes);
#line 1361
  if ((unsigned long )window != (unsigned long )((unsigned char *)0)) {
    {
#line 1362
    wsize = 1U << state->wbits;
#line 1363
    memcpy((void */* __restrict  */)window, (void const   */* __restrict  */)state->window,
           (size_t )wsize);
    }
  }
#line 1365
  copy->window = window;
#line 1366
  dest->state = (struct internal_state *)copy;
#line 1367
  return (0);
}
}
#line 67 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffast.c"
void inflate_fast(z_streamp strm , unsigned int start ) 
{ 
  struct inflate_state *state ;
  unsigned char *in ;
  unsigned char *last ;
  unsigned char *out ;
  unsigned char *beg ;
  unsigned char *end ;
  unsigned int wsize ;
  unsigned int whave ;
  unsigned int write___0 ;
  unsigned char *window ;
  unsigned long hold ;
  unsigned int bits ;
  code const   *lcode ;
  code const   *dcode ;
  unsigned int lmask ;
  unsigned int dmask ;
  code this ;
  unsigned int op ;
  unsigned int len ;
  unsigned int dist ;
  unsigned char *from ;
  long tmp ;
  long tmp___0 ;

  {
#line 98
  state = (struct inflate_state *)strm->state;
#line 99
  in = strm->next_in - 1;
#line 100
  last = in + (strm->avail_in - 5U);
#line 101
  out = strm->next_out - 1;
#line 102
  beg = out - (start - strm->avail_out);
#line 103
  end = out + (strm->avail_out - 257U);
#line 107
  wsize = state->wsize;
#line 108
  whave = state->whave;
#line 109
  write___0 = state->write;
#line 110
  window = state->window;
#line 111
  hold = state->hold;
#line 112
  bits = state->bits;
#line 113
  lcode = state->lencode;
#line 114
  dcode = state->distcode;
#line 115
  lmask = (1U << state->lenbits) - 1U;
#line 116
  dmask = (1U << state->distbits) - 1U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (bits < 15U) {
#line 122
      in ++;
#line 122
      hold += (unsigned long )*in << bits;
#line 123
      bits += 8U;
#line 124
      in ++;
#line 124
      hold += (unsigned long )*in << bits;
#line 125
      bits += 8U;
    }
#line 127
    this = (code )*(lcode + (hold & (unsigned long )lmask));
    dolen: 
#line 129
    op = (unsigned int )this.bits;
#line 130
    hold >>= op;
#line 131
    bits -= op;
#line 132
    op = (unsigned int )this.op;
#line 133
    if (op == 0U) {
#line 137
      out ++;
#line 137
      *out = (unsigned char )this.val;
    } else
#line 139
    if (op & 16U) {
#line 140
      len = (unsigned int )this.val;
#line 141
      op &= 15U;
#line 142
      if (op) {
#line 143
        if (bits < op) {
#line 144
          in ++;
#line 144
          hold += (unsigned long )*in << bits;
#line 145
          bits += 8U;
        }
#line 147
        len += (unsigned int )hold & ((1U << op) - 1U);
#line 148
        hold >>= op;
#line 149
        bits -= op;
      }
#line 152
      if (bits < 15U) {
#line 153
        in ++;
#line 153
        hold += (unsigned long )*in << bits;
#line 154
        bits += 8U;
#line 155
        in ++;
#line 155
        hold += (unsigned long )*in << bits;
#line 156
        bits += 8U;
      }
#line 158
      this = (code )*(dcode + (hold & (unsigned long )dmask));
      dodist: 
#line 160
      op = (unsigned int )this.bits;
#line 161
      hold >>= op;
#line 162
      bits -= op;
#line 163
      op = (unsigned int )this.op;
#line 164
      if (op & 16U) {
#line 165
        dist = (unsigned int )this.val;
#line 166
        op &= 15U;
#line 167
        if (bits < op) {
#line 168
          in ++;
#line 168
          hold += (unsigned long )*in << bits;
#line 169
          bits += 8U;
#line 170
          if (bits < op) {
#line 171
            in ++;
#line 171
            hold += (unsigned long )*in << bits;
#line 172
            bits += 8U;
          }
        }
#line 175
        dist += (unsigned int )hold & ((1U << op) - 1U);
#line 183
        hold >>= op;
#line 184
        bits -= op;
#line 186
        op = (unsigned int )(out - beg);
#line 187
        if (dist > op) {
#line 188
          op = dist - op;
#line 189
          if (op > whave) {
#line 190
            strm->msg = (char *)"invalid distance too far back";
#line 191
            state->mode = (inflate_mode )27;
#line 192
            goto while_break;
          }
#line 194
          from = window - 1;
#line 195
          if (write___0 == 0U) {
#line 196
            from += wsize - op;
#line 197
            if (op < len) {
#line 198
              len -= op;
              {
#line 199
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 200
                out ++;
#line 200
                from ++;
#line 200
                *out = *from;
#line 199
                op --;
#line 199
                if (! op) {
#line 199
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 202
              from = out - dist;
            }
          } else
#line 205
          if (write___0 < op) {
#line 206
            from += (wsize + write___0) - op;
#line 207
            op -= write___0;
#line 208
            if (op < len) {
#line 209
              len -= op;
              {
#line 210
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 211
                out ++;
#line 211
                from ++;
#line 211
                *out = *from;
#line 210
                op --;
#line 210
                if (! op) {
#line 210
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 213
              from = window - 1;
#line 214
              if (write___0 < len) {
#line 215
                op = write___0;
#line 216
                len -= op;
                {
#line 217
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 218
                  out ++;
#line 218
                  from ++;
#line 218
                  *out = *from;
#line 217
                  op --;
#line 217
                  if (! op) {
#line 217
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 220
                from = out - dist;
              }
            }
          } else {
#line 225
            from += write___0 - op;
#line 226
            if (op < len) {
#line 227
              len -= op;
              {
#line 228
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 229
                out ++;
#line 229
                from ++;
#line 229
                *out = *from;
#line 228
                op --;
#line 228
                if (! op) {
#line 228
                  goto while_break___3;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 231
              from = out - dist;
            }
          }
          {
#line 234
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 234
            if (! (len > 2U)) {
#line 234
              goto while_break___4;
            }
#line 235
            out ++;
#line 235
            from ++;
#line 235
            *out = *from;
#line 236
            out ++;
#line 236
            from ++;
#line 236
            *out = *from;
#line 237
            out ++;
#line 237
            from ++;
#line 237
            *out = *from;
#line 238
            len -= 3U;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 240
          if (len) {
#line 241
            out ++;
#line 241
            from ++;
#line 241
            *out = *from;
#line 242
            if (len > 1U) {
#line 243
              out ++;
#line 243
              from ++;
#line 243
              *out = *from;
            }
          }
        } else {
#line 247
          from = out - dist;
          {
#line 248
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 249
            out ++;
#line 249
            from ++;
#line 249
            *out = *from;
#line 250
            out ++;
#line 250
            from ++;
#line 250
            *out = *from;
#line 251
            out ++;
#line 251
            from ++;
#line 251
            *out = *from;
#line 252
            len -= 3U;
#line 248
            if (! (len > 2U)) {
#line 248
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 254
          if (len) {
#line 255
            out ++;
#line 255
            from ++;
#line 255
            *out = *from;
#line 256
            if (len > 1U) {
#line 257
              out ++;
#line 257
              from ++;
#line 257
              *out = *from;
            }
          }
        }
      } else
#line 261
      if ((op & 64U) == 0U) {
#line 262
        this = (code )*(dcode + ((unsigned long )this.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 263
        goto dodist;
      } else {
#line 266
        strm->msg = (char *)"invalid distance code";
#line 267
        state->mode = (inflate_mode )27;
#line 268
        goto while_break;
      }
    } else
#line 271
    if ((op & 64U) == 0U) {
#line 272
      this = (code )*(lcode + ((unsigned long )this.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 273
      goto dolen;
    } else
#line 275
    if (op & 32U) {
#line 277
      state->mode = (inflate_mode )11;
#line 278
      goto while_break;
    } else {
#line 281
      strm->msg = (char *)"invalid literal/length code";
#line 282
      state->mode = (inflate_mode )27;
#line 283
      goto while_break;
    }
#line 120
    if ((unsigned long )in < (unsigned long )last) {
#line 120
      if (! ((unsigned long )out < (unsigned long )end)) {
#line 120
        goto while_break;
      }
    } else {
#line 120
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  len = bits >> 3;
#line 289
  in -= len;
#line 290
  bits -= len << 3;
#line 291
  hold &= (unsigned long )((1U << bits) - 1U);
#line 294
  strm->next_in = in + 1;
#line 295
  strm->next_out = out + 1;
#line 296
  if ((unsigned long )in < (unsigned long )last) {
#line 296
    tmp = 5L + (last - in);
  } else {
#line 296
    tmp = 5L - (in - last);
  }
#line 296
  strm->avail_in = (unsigned int )tmp;
#line 297
  if ((unsigned long )out < (unsigned long )end) {
#line 297
    tmp___0 = 257L + (end - out);
  } else {
#line 297
    tmp___0 = 257L - (out - end);
  }
#line 297
  strm->avail_out = (unsigned int )tmp___0;
#line 299
  state->hold = hold;
#line 300
  state->bits = bits;
#line 301
  return;
}
}
#line 889 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) ;
#line 958
int inflateBackEnd(z_streamp strm ) ;
#line 1336
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) ;
#line 19 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) ;
#line 28 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) 
{ 
  struct inflate_state *state ;
  voidpf tmp ;

  {
#line 37
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 39
    return (-6);
  } else
#line 37
  if ((int const   )*(version + 0) != (int const   )*("1.2.3-optipng" + 0)) {
#line 39
    return (-6);
  } else
#line 37
  if (stream_size != (int )sizeof(z_stream )) {
#line 39
    return (-6);
  }
#line 40
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 42
    return (-2);
  } else
#line 40
  if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits < 8) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits > 15) {
#line 42
    return (-2);
  }
#line 43
  strm->msg = (char *)0;
#line 44
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 45
    strm->zalloc = & zcalloc;
#line 46
    strm->opaque = (voidpf )0;
  }
#line 48
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 48
    strm->zfree = & zcfree;
  }
  {
#line 49
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 49
  state = (struct inflate_state *)tmp;
  }
#line 51
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 51
    return (-4);
  }
#line 53
  strm->state = (struct internal_state *)state;
#line 54
  state->dmax = 32768U;
#line 55
  state->wbits = (unsigned int )windowBits;
#line 56
  state->wsize = 1U << windowBits;
#line 57
  state->window = window;
#line 58
  state->write = 0U;
#line 59
  state->whave = 0U;
#line 60
  return (0);
}
}
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
static code const   lenfix___0[512]  = 
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/inffixed.h"
static code const   distfix___0[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 73 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) 
{ 


  {
#line 110
  state->lencode = lenfix___0;
#line 111
  state->lenbits = 9U;
#line 112
  state->distcode = distfix___0;
#line 113
  state->distbits = 5U;
#line 114
  return;
}
}
#line 260 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
static unsigned short const   order___0[19]  = 
#line 260
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 241 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int copy ;
  unsigned char *from ;
  code this ;
  code last ;
  unsigned int len ;
  int ret ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;

  {
#line 264
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 265
    return (-2);
  } else
#line 264
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 265
    return (-2);
  }
#line 266
  state = (struct inflate_state *)strm->state;
#line 269
  strm->msg = (char *)0;
#line 270
  state->mode = (inflate_mode )11;
#line 271
  state->last = 0;
#line 272
  state->whave = 0U;
#line 273
  next = strm->next_in;
#line 274
  if ((unsigned long )next != (unsigned long )((unsigned char *)0)) {
#line 274
    have = strm->avail_in;
  } else {
#line 274
    have = 0U;
  }
#line 275
  hold = 0UL;
#line 276
  bits = 0U;
#line 277
  put = state->window;
#line 278
  left = state->wsize;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    if ((unsigned int )state->mode == 11U) {
#line 283
      goto case_11;
    }
#line 317
    if ((unsigned int )state->mode == 13U) {
#line 317
      goto case_13;
    }
#line 349
    if ((unsigned int )state->mode == 15U) {
#line 349
      goto case_15;
    }
#line 464
    if ((unsigned int )state->mode == 18U) {
#line 464
      goto case_18;
    }
#line 589
    if ((unsigned int )state->mode == 26U) {
#line 589
      goto case_26;
    }
#line 598
    if ((unsigned int )state->mode == 27U) {
#line 598
      goto case_27;
    }
#line 602
    goto switch_default;
    case_11: /* CIL Label */ 
#line 285
    if (state->last) {
      {
#line 286
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 286
        hold >>= bits & 7U;
#line 286
        bits -= bits & 7U;
#line 286
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 287
      state->mode = (inflate_mode )26;
#line 288
      goto switch_break;
    }
    {
#line 290
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 290
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 290
        if (! (bits < 3U)) {
#line 290
          goto while_break___2;
        }
        {
#line 290
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 290
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 290
            if (have == 0U) {
              {
#line 290
              have = (*in)(in_desc, & next);
              }
#line 290
              if (have == 0U) {
#line 290
                next = (unsigned char *)0;
#line 290
                ret = -5;
#line 290
                goto inf_leave;
              }
            }
#line 290
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 290
          have --;
#line 290
          tmp = next;
#line 290
          next ++;
#line 290
          hold += (unsigned long )*tmp << bits;
#line 290
          bits += 8U;
#line 290
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 290
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 291
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 292
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 292
      hold >>= 1;
#line 292
      bits --;
#line 292
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 294
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 294
      goto case_0;
    }
#line 299
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 299
      goto case_1;
    }
#line 305
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 305
      goto case_2;
    }
#line 310
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 310
      goto case_3;
    }
#line 293
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 297
    state->mode = (inflate_mode )13;
#line 298
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 300
    fixedtables___0(state);
#line 303
    state->mode = (inflate_mode )18;
    }
#line 304
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 308
    state->mode = (inflate_mode )15;
#line 309
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 311
    strm->msg = (char *)"invalid block type";
#line 312
    state->mode = (inflate_mode )27;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 314
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 314
      hold >>= 2;
#line 314
      bits -= 2U;
#line 314
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 315
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 319
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 319
      hold >>= bits & 7U;
#line 319
      bits -= bits & 7U;
#line 319
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 320
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 320
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 320
        if (! (bits < 32U)) {
#line 320
          goto while_break___9;
        }
        {
#line 320
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 320
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 320
            if (have == 0U) {
              {
#line 320
              have = (*in)(in_desc, & next);
              }
#line 320
              if (have == 0U) {
#line 320
                next = (unsigned char *)0;
#line 320
                ret = -5;
#line 320
                goto inf_leave;
              }
            }
#line 320
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 320
          have --;
#line 320
          tmp___0 = next;
#line 320
          next ++;
#line 320
          hold += (unsigned long )*tmp___0 << bits;
#line 320
          bits += 8U;
#line 320
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 320
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 321
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 322
      strm->msg = (char *)"invalid stored block lengths";
#line 323
      state->mode = (inflate_mode )27;
#line 324
      goto switch_break;
    }
#line 326
    state->length = (unsigned int )hold & 65535U;
    {
#line 329
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 329
      hold = 0UL;
#line 329
      bits = 0U;
#line 329
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 332
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 332
      if (! (state->length != 0U)) {
#line 332
        goto while_break___13;
      }
#line 333
      copy = state->length;
      {
#line 334
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 334
        if (have == 0U) {
          {
#line 334
          have = (*in)(in_desc, & next);
          }
#line 334
          if (have == 0U) {
#line 334
            next = (unsigned char *)0;
#line 334
            ret = -5;
#line 334
            goto inf_leave;
          }
        }
#line 334
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 335
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 335
        if (left == 0U) {
          {
#line 335
          put = state->window;
#line 335
          left = state->wsize;
#line 335
          state->whave = left;
#line 335
          tmp___1 = (*out)(out_desc, put, left);
          }
#line 335
          if (tmp___1) {
#line 335
            ret = -5;
#line 335
            goto inf_leave;
          }
        }
#line 335
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 336
      if (copy > have) {
#line 336
        copy = have;
      }
#line 337
      if (copy > left) {
#line 337
        copy = left;
      }
      {
#line 338
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 339
      have -= copy;
#line 340
      next += copy;
#line 341
      left -= copy;
#line 342
      put += copy;
#line 343
      state->length -= copy;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 346
    state->mode = (inflate_mode )11;
#line 347
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 351
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 351
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 351
        if (! (bits < 14U)) {
#line 351
          goto while_break___17;
        }
        {
#line 351
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 351
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 351
            if (have == 0U) {
              {
#line 351
              have = (*in)(in_desc, & next);
              }
#line 351
              if (have == 0U) {
#line 351
                next = (unsigned char *)0;
#line 351
                ret = -5;
#line 351
                goto inf_leave;
              }
            }
#line 351
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 351
          have --;
#line 351
          tmp___2 = next;
#line 351
          next ++;
#line 351
          hold += (unsigned long )*tmp___2 << bits;
#line 351
          bits += 8U;
#line 351
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 351
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 352
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 353
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 353
      hold >>= 5;
#line 353
      bits -= 5U;
#line 353
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 354
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 355
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 355
      hold >>= 5;
#line 355
      bits -= 5U;
#line 355
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 356
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 357
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 357
      hold >>= 4;
#line 357
      bits -= 4U;
#line 357
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 359
    if (state->nlen > 286U) {
#line 360
      strm->msg = (char *)"too many length or distance symbols";
#line 361
      state->mode = (inflate_mode )27;
#line 362
      goto switch_break;
    } else
#line 359
    if (state->ndist > 30U) {
#line 360
      strm->msg = (char *)"too many length or distance symbols";
#line 361
      state->mode = (inflate_mode )27;
#line 362
      goto switch_break;
    }
#line 368
    state->have = 0U;
    {
#line 369
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 369
      if (! (state->have < state->ncode)) {
#line 369
        goto while_break___23;
      }
      {
#line 370
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 370
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 370
          if (! (bits < 3U)) {
#line 370
            goto while_break___25;
          }
          {
#line 370
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 370
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 370
              if (have == 0U) {
                {
#line 370
                have = (*in)(in_desc, & next);
                }
#line 370
                if (have == 0U) {
#line 370
                  next = (unsigned char *)0;
#line 370
                  ret = -5;
#line 370
                  goto inf_leave;
                }
              }
#line 370
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 370
            have --;
#line 370
            tmp___3 = next;
#line 370
            next ++;
#line 370
            hold += (unsigned long )*tmp___3 << bits;
#line 370
            bits += 8U;
#line 370
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 370
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 371
      tmp___4 = state->have;
#line 371
      (state->have) ++;
#line 371
      state->lens[order___0[tmp___4]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 372
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 372
        hold >>= 3;
#line 372
        bits -= 3U;
#line 372
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 374
      if (! (state->have < 19U)) {
#line 374
        goto while_break___29;
      }
#line 375
      tmp___5 = state->have;
#line 375
      (state->have) ++;
#line 375
      state->lens[order___0[tmp___5]] = (unsigned short)0;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 376
    state->next = state->codes;
#line 377
    state->lencode = (code const   *)state->next;
#line 378
    state->lenbits = 7U;
#line 379
    ret = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                        state->work);
    }
#line 381
    if (ret) {
#line 382
      strm->msg = (char *)"invalid code lengths set";
#line 383
      state->mode = (inflate_mode )27;
#line 384
      goto switch_break;
    }
#line 389
    state->have = 0U;
    {
#line 390
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 390
      if (! (state->have < state->nlen + state->ndist)) {
#line 390
        goto while_break___30;
      }
      {
#line 391
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 392
        this = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 393
        if ((unsigned int )this.bits <= bits) {
#line 393
          goto while_break___31;
        }
        {
#line 394
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 394
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 394
            if (have == 0U) {
              {
#line 394
              have = (*in)(in_desc, & next);
              }
#line 394
              if (have == 0U) {
#line 394
                next = (unsigned char *)0;
#line 394
                ret = -5;
#line 394
                goto inf_leave;
              }
            }
#line 394
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 394
          have --;
#line 394
          tmp___6 = next;
#line 394
          next ++;
#line 394
          hold += (unsigned long )*tmp___6 << bits;
#line 394
          bits += 8U;
#line 394
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
#line 396
      if ((int )this.val < 16) {
        {
#line 397
        while (1) {
          while_continue___34: /* CIL Label */ ;
          {
#line 397
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 397
            if (! (bits < (unsigned int )this.bits)) {
#line 397
              goto while_break___35;
            }
            {
#line 397
            while (1) {
              while_continue___36: /* CIL Label */ ;
              {
#line 397
              while (1) {
                while_continue___37: /* CIL Label */ ;
#line 397
                if (have == 0U) {
                  {
#line 397
                  have = (*in)(in_desc, & next);
                  }
#line 397
                  if (have == 0U) {
#line 397
                    next = (unsigned char *)0;
#line 397
                    ret = -5;
#line 397
                    goto inf_leave;
                  }
                }
#line 397
                goto while_break___37;
              }
              while_break___37: /* CIL Label */ ;
              }
#line 397
              have --;
#line 397
              tmp___7 = next;
#line 397
              next ++;
#line 397
              hold += (unsigned long )*tmp___7 << bits;
#line 397
              bits += 8U;
#line 397
              goto while_break___36;
            }
            while_break___36: /* CIL Label */ ;
            }
          }
          while_break___35: /* CIL Label */ ;
          }
#line 397
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
        {
#line 398
        while (1) {
          while_continue___38: /* CIL Label */ ;
#line 398
          hold >>= (int )this.bits;
#line 398
          bits -= (unsigned int )this.bits;
#line 398
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
#line 399
        tmp___8 = state->have;
#line 399
        (state->have) ++;
#line 399
        state->lens[tmp___8] = this.val;
      } else {
#line 402
        if ((int )this.val == 16) {
          {
#line 403
          while (1) {
            while_continue___39: /* CIL Label */ ;
            {
#line 403
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 403
              if (! (bits < (unsigned int )((int )this.bits + 2))) {
#line 403
                goto while_break___40;
              }
              {
#line 403
              while (1) {
                while_continue___41: /* CIL Label */ ;
                {
#line 403
                while (1) {
                  while_continue___42: /* CIL Label */ ;
#line 403
                  if (have == 0U) {
                    {
#line 403
                    have = (*in)(in_desc, & next);
                    }
#line 403
                    if (have == 0U) {
#line 403
                      next = (unsigned char *)0;
#line 403
                      ret = -5;
#line 403
                      goto inf_leave;
                    }
                  }
#line 403
                  goto while_break___42;
                }
                while_break___42: /* CIL Label */ ;
                }
#line 403
                have --;
#line 403
                tmp___9 = next;
#line 403
                next ++;
#line 403
                hold += (unsigned long )*tmp___9 << bits;
#line 403
                bits += 8U;
#line 403
                goto while_break___41;
              }
              while_break___41: /* CIL Label */ ;
              }
            }
            while_break___40: /* CIL Label */ ;
            }
#line 403
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
          {
#line 404
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 404
            hold >>= (int )this.bits;
#line 404
            bits -= (unsigned int )this.bits;
#line 404
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
#line 405
          if (state->have == 0U) {
#line 406
            strm->msg = (char *)"invalid bit length repeat";
#line 407
            state->mode = (inflate_mode )27;
#line 408
            goto while_break___30;
          }
#line 410
          len = (unsigned int )state->lens[state->have - 1U];
#line 411
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 412
          while (1) {
            while_continue___44: /* CIL Label */ ;
#line 412
            hold >>= 2;
#line 412
            bits -= 2U;
#line 412
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
        } else
#line 414
        if ((int )this.val == 17) {
          {
#line 415
          while (1) {
            while_continue___45: /* CIL Label */ ;
            {
#line 415
            while (1) {
              while_continue___46: /* CIL Label */ ;
#line 415
              if (! (bits < (unsigned int )((int )this.bits + 3))) {
#line 415
                goto while_break___46;
              }
              {
#line 415
              while (1) {
                while_continue___47: /* CIL Label */ ;
                {
#line 415
                while (1) {
                  while_continue___48: /* CIL Label */ ;
#line 415
                  if (have == 0U) {
                    {
#line 415
                    have = (*in)(in_desc, & next);
                    }
#line 415
                    if (have == 0U) {
#line 415
                      next = (unsigned char *)0;
#line 415
                      ret = -5;
#line 415
                      goto inf_leave;
                    }
                  }
#line 415
                  goto while_break___48;
                }
                while_break___48: /* CIL Label */ ;
                }
#line 415
                have --;
#line 415
                tmp___10 = next;
#line 415
                next ++;
#line 415
                hold += (unsigned long )*tmp___10 << bits;
#line 415
                bits += 8U;
#line 415
                goto while_break___47;
              }
              while_break___47: /* CIL Label */ ;
              }
            }
            while_break___46: /* CIL Label */ ;
            }
#line 415
            goto while_break___45;
          }
          while_break___45: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___49: /* CIL Label */ ;
#line 416
            hold >>= (int )this.bits;
#line 416
            bits -= (unsigned int )this.bits;
#line 416
            goto while_break___49;
          }
          while_break___49: /* CIL Label */ ;
          }
#line 417
          len = 0U;
#line 418
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 419
          while (1) {
            while_continue___50: /* CIL Label */ ;
#line 419
            hold >>= 3;
#line 419
            bits -= 3U;
#line 419
            goto while_break___50;
          }
          while_break___50: /* CIL Label */ ;
          }
        } else {
          {
#line 422
          while (1) {
            while_continue___51: /* CIL Label */ ;
            {
#line 422
            while (1) {
              while_continue___52: /* CIL Label */ ;
#line 422
              if (! (bits < (unsigned int )((int )this.bits + 7))) {
#line 422
                goto while_break___52;
              }
              {
#line 422
              while (1) {
                while_continue___53: /* CIL Label */ ;
                {
#line 422
                while (1) {
                  while_continue___54: /* CIL Label */ ;
#line 422
                  if (have == 0U) {
                    {
#line 422
                    have = (*in)(in_desc, & next);
                    }
#line 422
                    if (have == 0U) {
#line 422
                      next = (unsigned char *)0;
#line 422
                      ret = -5;
#line 422
                      goto inf_leave;
                    }
                  }
#line 422
                  goto while_break___54;
                }
                while_break___54: /* CIL Label */ ;
                }
#line 422
                have --;
#line 422
                tmp___11 = next;
#line 422
                next ++;
#line 422
                hold += (unsigned long )*tmp___11 << bits;
#line 422
                bits += 8U;
#line 422
                goto while_break___53;
              }
              while_break___53: /* CIL Label */ ;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
#line 422
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
          {
#line 423
          while (1) {
            while_continue___55: /* CIL Label */ ;
#line 423
            hold >>= (int )this.bits;
#line 423
            bits -= (unsigned int )this.bits;
#line 423
            goto while_break___55;
          }
          while_break___55: /* CIL Label */ ;
          }
#line 424
          len = 0U;
#line 425
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 426
          while (1) {
            while_continue___56: /* CIL Label */ ;
#line 426
            hold >>= 7;
#line 426
            bits -= 7U;
#line 426
            goto while_break___56;
          }
          while_break___56: /* CIL Label */ ;
          }
        }
#line 428
        if (state->have + copy > state->nlen + state->ndist) {
#line 429
          strm->msg = (char *)"invalid bit length repeat";
#line 430
          state->mode = (inflate_mode )27;
#line 431
          goto while_break___30;
        }
        {
#line 433
        while (1) {
          while_continue___57: /* CIL Label */ ;
#line 433
          tmp___13 = copy;
#line 433
          copy --;
#line 433
          if (! tmp___13) {
#line 433
            goto while_break___57;
          }
#line 434
          tmp___12 = state->have;
#line 434
          (state->have) ++;
#line 434
          state->lens[tmp___12] = (unsigned short )len;
        }
        while_break___57: /* CIL Label */ ;
        }
      }
    }
    while_break___30: /* CIL Label */ ;
    }
#line 439
    if ((unsigned int )state->mode == 27U) {
#line 439
      goto switch_break;
    }
    {
#line 442
    state->next = state->codes;
#line 443
    state->lencode = (code const   *)state->next;
#line 444
    state->lenbits = 9U;
#line 445
    ret = inflate_table((codetype )1, state->lens, state->nlen, & state->next, & state->lenbits,
                        state->work);
    }
#line 447
    if (ret) {
#line 448
      strm->msg = (char *)"invalid literal/lengths set";
#line 449
      state->mode = (inflate_mode )27;
#line 450
      goto switch_break;
    }
    {
#line 452
    state->distcode = (code const   *)state->next;
#line 453
    state->distbits = 6U;
#line 454
    ret = inflate_table((codetype )2, state->lens + state->nlen, state->ndist, & state->next,
                        & state->distbits, state->work);
    }
#line 456
    if (ret) {
#line 457
      strm->msg = (char *)"invalid distances set";
#line 458
      state->mode = (inflate_mode )27;
#line 459
      goto switch_break;
    }
#line 462
    state->mode = (inflate_mode )18;
    case_18: /* CIL Label */ 
#line 466
    if (have >= 6U) {
#line 466
      if (left >= 258U) {
        {
#line 467
        while (1) {
          while_continue___58: /* CIL Label */ ;
#line 467
          strm->next_out = put;
#line 467
          strm->avail_out = left;
#line 467
          strm->next_in = next;
#line 467
          strm->avail_in = have;
#line 467
          state->hold = hold;
#line 467
          state->bits = bits;
#line 467
          goto while_break___58;
        }
        while_break___58: /* CIL Label */ ;
        }
#line 468
        if (state->whave < state->wsize) {
#line 469
          state->whave = state->wsize - left;
        }
        {
#line 470
        inflate_fast(strm, state->wsize);
        }
        {
#line 471
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 471
          put = strm->next_out;
#line 471
          left = strm->avail_out;
#line 471
          next = strm->next_in;
#line 471
          have = strm->avail_in;
#line 471
          hold = state->hold;
#line 471
          bits = state->bits;
#line 471
          goto while_break___59;
        }
        while_break___59: /* CIL Label */ ;
        }
#line 472
        goto switch_break;
      }
    }
    {
#line 476
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 477
      this = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 478
      if ((unsigned int )this.bits <= bits) {
#line 478
        goto while_break___60;
      }
      {
#line 479
      while (1) {
        while_continue___61: /* CIL Label */ ;
        {
#line 479
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 479
          if (have == 0U) {
            {
#line 479
            have = (*in)(in_desc, & next);
            }
#line 479
            if (have == 0U) {
#line 479
              next = (unsigned char *)0;
#line 479
              ret = -5;
#line 479
              goto inf_leave;
            }
          }
#line 479
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
#line 479
        have --;
#line 479
        tmp___14 = next;
#line 479
        next ++;
#line 479
        hold += (unsigned long )*tmp___14 << bits;
#line 479
        bits += 8U;
#line 479
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
    }
    while_break___60: /* CIL Label */ ;
    }
#line 481
    if (this.op) {
#line 481
      if (((int )this.op & 240) == 0) {
#line 482
        last = this;
        {
#line 483
        while (1) {
          while_continue___63: /* CIL Label */ ;
#line 484
          this = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 486
          if ((unsigned int )((int )last.bits + (int )this.bits) <= bits) {
#line 486
            goto while_break___63;
          }
          {
#line 487
          while (1) {
            while_continue___64: /* CIL Label */ ;
            {
#line 487
            while (1) {
              while_continue___65: /* CIL Label */ ;
#line 487
              if (have == 0U) {
                {
#line 487
                have = (*in)(in_desc, & next);
                }
#line 487
                if (have == 0U) {
#line 487
                  next = (unsigned char *)0;
#line 487
                  ret = -5;
#line 487
                  goto inf_leave;
                }
              }
#line 487
              goto while_break___65;
            }
            while_break___65: /* CIL Label */ ;
            }
#line 487
            have --;
#line 487
            tmp___15 = next;
#line 487
            next ++;
#line 487
            hold += (unsigned long )*tmp___15 << bits;
#line 487
            bits += 8U;
#line 487
            goto while_break___64;
          }
          while_break___64: /* CIL Label */ ;
          }
        }
        while_break___63: /* CIL Label */ ;
        }
        {
#line 489
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 489
          hold >>= (int )last.bits;
#line 489
          bits -= (unsigned int )last.bits;
#line 489
          goto while_break___66;
        }
        while_break___66: /* CIL Label */ ;
        }
      }
    }
    {
#line 491
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 491
      hold >>= (int )this.bits;
#line 491
      bits -= (unsigned int )this.bits;
#line 491
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 492
    state->length = (unsigned int )this.val;
#line 495
    if ((int )this.op == 0) {
      {
#line 499
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 499
        if (left == 0U) {
          {
#line 499
          put = state->window;
#line 499
          left = state->wsize;
#line 499
          state->whave = left;
#line 499
          tmp___16 = (*out)(out_desc, put, left);
          }
#line 499
          if (tmp___16) {
#line 499
            ret = -5;
#line 499
            goto inf_leave;
          }
        }
#line 499
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
#line 500
      tmp___17 = put;
#line 500
      put ++;
#line 500
      *tmp___17 = (unsigned char )state->length;
#line 501
      left --;
#line 502
      state->mode = (inflate_mode )18;
#line 503
      goto switch_break;
    }
#line 507
    if ((int )this.op & 32) {
#line 509
      state->mode = (inflate_mode )11;
#line 510
      goto switch_break;
    }
#line 514
    if ((int )this.op & 64) {
#line 515
      strm->msg = (char *)"invalid literal/length code";
#line 516
      state->mode = (inflate_mode )27;
#line 517
      goto switch_break;
    }
#line 521
    state->extra = (unsigned int )this.op & 15U;
#line 522
    if (state->extra != 0U) {
      {
#line 523
      while (1) {
        while_continue___69: /* CIL Label */ ;
        {
#line 523
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 523
          if (! (bits < state->extra)) {
#line 523
            goto while_break___70;
          }
          {
#line 523
          while (1) {
            while_continue___71: /* CIL Label */ ;
            {
#line 523
            while (1) {
              while_continue___72: /* CIL Label */ ;
#line 523
              if (have == 0U) {
                {
#line 523
                have = (*in)(in_desc, & next);
                }
#line 523
                if (have == 0U) {
#line 523
                  next = (unsigned char *)0;
#line 523
                  ret = -5;
#line 523
                  goto inf_leave;
                }
              }
#line 523
              goto while_break___72;
            }
            while_break___72: /* CIL Label */ ;
            }
#line 523
            have --;
#line 523
            tmp___18 = next;
#line 523
            next ++;
#line 523
            hold += (unsigned long )*tmp___18 << bits;
#line 523
            bits += 8U;
#line 523
            goto while_break___71;
          }
          while_break___71: /* CIL Label */ ;
          }
        }
        while_break___70: /* CIL Label */ ;
        }
#line 523
        goto while_break___69;
      }
      while_break___69: /* CIL Label */ ;
      }
#line 524
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 525
      while (1) {
        while_continue___73: /* CIL Label */ ;
#line 525
        hold >>= state->extra;
#line 525
        bits -= state->extra;
#line 525
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
    }
    {
#line 530
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 531
      this = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 532
      if ((unsigned int )this.bits <= bits) {
#line 532
        goto while_break___74;
      }
      {
#line 533
      while (1) {
        while_continue___75: /* CIL Label */ ;
        {
#line 533
        while (1) {
          while_continue___76: /* CIL Label */ ;
#line 533
          if (have == 0U) {
            {
#line 533
            have = (*in)(in_desc, & next);
            }
#line 533
            if (have == 0U) {
#line 533
              next = (unsigned char *)0;
#line 533
              ret = -5;
#line 533
              goto inf_leave;
            }
          }
#line 533
          goto while_break___76;
        }
        while_break___76: /* CIL Label */ ;
        }
#line 533
        have --;
#line 533
        tmp___19 = next;
#line 533
        next ++;
#line 533
        hold += (unsigned long )*tmp___19 << bits;
#line 533
        bits += 8U;
#line 533
        goto while_break___75;
      }
      while_break___75: /* CIL Label */ ;
      }
    }
    while_break___74: /* CIL Label */ ;
    }
#line 535
    if (((int )this.op & 240) == 0) {
#line 536
      last = this;
      {
#line 537
      while (1) {
        while_continue___77: /* CIL Label */ ;
#line 538
        this = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 540
        if ((unsigned int )((int )last.bits + (int )this.bits) <= bits) {
#line 540
          goto while_break___77;
        }
        {
#line 541
        while (1) {
          while_continue___78: /* CIL Label */ ;
          {
#line 541
          while (1) {
            while_continue___79: /* CIL Label */ ;
#line 541
            if (have == 0U) {
              {
#line 541
              have = (*in)(in_desc, & next);
              }
#line 541
              if (have == 0U) {
#line 541
                next = (unsigned char *)0;
#line 541
                ret = -5;
#line 541
                goto inf_leave;
              }
            }
#line 541
            goto while_break___79;
          }
          while_break___79: /* CIL Label */ ;
          }
#line 541
          have --;
#line 541
          tmp___20 = next;
#line 541
          next ++;
#line 541
          hold += (unsigned long )*tmp___20 << bits;
#line 541
          bits += 8U;
#line 541
          goto while_break___78;
        }
        while_break___78: /* CIL Label */ ;
        }
      }
      while_break___77: /* CIL Label */ ;
      }
      {
#line 543
      while (1) {
        while_continue___80: /* CIL Label */ ;
#line 543
        hold >>= (int )last.bits;
#line 543
        bits -= (unsigned int )last.bits;
#line 543
        goto while_break___80;
      }
      while_break___80: /* CIL Label */ ;
      }
    }
    {
#line 545
    while (1) {
      while_continue___81: /* CIL Label */ ;
#line 545
      hold >>= (int )this.bits;
#line 545
      bits -= (unsigned int )this.bits;
#line 545
      goto while_break___81;
    }
    while_break___81: /* CIL Label */ ;
    }
#line 546
    if ((int )this.op & 64) {
#line 547
      strm->msg = (char *)"invalid distance code";
#line 548
      state->mode = (inflate_mode )27;
#line 549
      goto switch_break;
    }
#line 551
    state->offset = (unsigned int )this.val;
#line 554
    state->extra = (unsigned int )this.op & 15U;
#line 555
    if (state->extra != 0U) {
      {
#line 556
      while (1) {
        while_continue___82: /* CIL Label */ ;
        {
#line 556
        while (1) {
          while_continue___83: /* CIL Label */ ;
#line 556
          if (! (bits < state->extra)) {
#line 556
            goto while_break___83;
          }
          {
#line 556
          while (1) {
            while_continue___84: /* CIL Label */ ;
            {
#line 556
            while (1) {
              while_continue___85: /* CIL Label */ ;
#line 556
              if (have == 0U) {
                {
#line 556
                have = (*in)(in_desc, & next);
                }
#line 556
                if (have == 0U) {
#line 556
                  next = (unsigned char *)0;
#line 556
                  ret = -5;
#line 556
                  goto inf_leave;
                }
              }
#line 556
              goto while_break___85;
            }
            while_break___85: /* CIL Label */ ;
            }
#line 556
            have --;
#line 556
            tmp___21 = next;
#line 556
            next ++;
#line 556
            hold += (unsigned long )*tmp___21 << bits;
#line 556
            bits += 8U;
#line 556
            goto while_break___84;
          }
          while_break___84: /* CIL Label */ ;
          }
        }
        while_break___83: /* CIL Label */ ;
        }
#line 556
        goto while_break___82;
      }
      while_break___82: /* CIL Label */ ;
      }
#line 557
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 558
      while (1) {
        while_continue___86: /* CIL Label */ ;
#line 558
        hold >>= state->extra;
#line 558
        bits -= state->extra;
#line 558
        goto while_break___86;
      }
      while_break___86: /* CIL Label */ ;
      }
    }
#line 560
    if (state->whave < state->wsize) {
#line 560
      tmp___22 = left;
    } else {
#line 560
      tmp___22 = 0U;
    }
#line 560
    if (state->offset > state->wsize - tmp___22) {
#line 562
      strm->msg = (char *)"invalid distance too far back";
#line 563
      state->mode = (inflate_mode )27;
#line 564
      goto switch_break;
    }
    {
#line 569
    while (1) {
      while_continue___87: /* CIL Label */ ;
      {
#line 570
      while (1) {
        while_continue___88: /* CIL Label */ ;
#line 570
        if (left == 0U) {
          {
#line 570
          put = state->window;
#line 570
          left = state->wsize;
#line 570
          state->whave = left;
#line 570
          tmp___23 = (*out)(out_desc, put, left);
          }
#line 570
          if (tmp___23) {
#line 570
            ret = -5;
#line 570
            goto inf_leave;
          }
        }
#line 570
        goto while_break___88;
      }
      while_break___88: /* CIL Label */ ;
      }
#line 571
      copy = state->wsize - state->offset;
#line 572
      if (copy < left) {
#line 573
        from = put + copy;
#line 574
        copy = left - copy;
      } else {
#line 577
        from = put - state->offset;
#line 578
        copy = left;
      }
#line 580
      if (copy > state->length) {
#line 580
        copy = state->length;
      }
#line 581
      state->length -= copy;
#line 582
      left -= copy;
      {
#line 583
      while (1) {
        while_continue___89: /* CIL Label */ ;
#line 584
        tmp___24 = put;
#line 584
        put ++;
#line 584
        tmp___25 = from;
#line 584
        from ++;
#line 584
        *tmp___24 = *tmp___25;
#line 583
        copy --;
#line 583
        if (! copy) {
#line 583
          goto while_break___89;
        }
      }
      while_break___89: /* CIL Label */ ;
      }
#line 569
      if (! (state->length != 0U)) {
#line 569
        goto while_break___87;
      }
    }
    while_break___87: /* CIL Label */ ;
    }
#line 587
    goto switch_break;
    case_26: /* CIL Label */ 
#line 591
    ret = 1;
#line 592
    if (left < state->wsize) {
      {
#line 593
      tmp___26 = (*out)(out_desc, state->window, state->wsize - left);
      }
#line 593
      if (tmp___26) {
#line 594
        ret = -5;
      }
    }
#line 596
    goto inf_leave;
    case_27: /* CIL Label */ 
#line 599
    ret = -3;
#line 600
    goto inf_leave;
    switch_default: /* CIL Label */ 
#line 603
    ret = -2;
#line 604
    goto inf_leave;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  inf_leave: 
#line 609
  strm->next_in = next;
#line 610
  strm->avail_in = have;
#line 611
  return (ret);
}
}
#line 614 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/infback.c"
int inflateBackEnd(z_streamp strm ) 
{ 


  {
#line 617
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 618
    return (-2);
  } else
#line 617
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 618
    return (-2);
  } else
#line 617
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 618
    return (-2);
  }
  {
#line 619
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 620
  strm->state = (struct internal_state *)0;
  }
#line 622
  return (0);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 757
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 615 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 1077
gzFile gzopen(char const   *path , char const   *mode ) ;
#line 1094
gzFile gzdopen(int fd , char const   *mode ) ;
#line 1107
int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1115
int gzread(gzFile file , voidp buf___1 , unsigned int len ) ;
#line 1151
char *gzgets(gzFile file , char *buf___1 , int len ) ;
#line 1166
int gzgetc(gzFile file ) ;
#line 1172
int gzungetc(int c , gzFile file ) ;
#line 1192
off_t gzseek(gzFile file , off_t offset , int whence ) ;
#line 1210
int gzrewind(gzFile file ) ;
#line 1217
off_t gztell(gzFile file ) ;
#line 1226
int gzeof(gzFile file ) ;
#line 1232
int gzdirect(gzFile file ) ;
#line 1238
int gzclose(gzFile file ) ;
#line 1245
char const   *gzerror(gzFile file , int *errnum ) ;
#line 1254
void gzclearerr(gzFile file ) ;
#line 1294
unsigned long crc32(unsigned long crc , unsigned char const   *buf___1 , unsigned int len ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static int const   gz_magic[2]  = {      (int const   )31,      (int const   )139};
#line 76
static gzFile gz_open(char const   *path , char const   *mode , int fd ) ;
#line 78
static int get_byte(gz_stream *s ) ;
#line 79
static void check_header(gz_stream *s ) ;
#line 80
static int destroy(gz_stream *s ) ;
#line 82
static uLong getLong(gz_stream *s ) ;
#line 93 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static gzFile gz_open(char const   *path , char const   *mode , int fd ) 
{ 
  int err ;
  int level ;
  int strategy ;
  char *p ;
  gz_stream *s ;
  char fmode[80] ;
  char *m ;
  void *tmp ;
  Byte *tmp___0 ;
  Byte *tmp___1 ;
  uInt tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Byte *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  FILE *tmp___10 ;
  FILE *tmp___11 ;
  long tmp___12 ;

  {
#line 99
  level = -1;
#line 100
  strategy = 0;
#line 101
  p = (char *)mode;
#line 104
  m = fmode;
#line 106
  if (! path) {
#line 106
    return ((gzFile )0);
  } else
#line 106
  if (! mode) {
#line 106
    return ((gzFile )0);
  }
  {
#line 108
  tmp = malloc(sizeof(gz_stream ));
#line 108
  s = (gz_stream *)tmp;
  }
#line 109
  if (! s) {
#line 109
    return ((gzFile )0);
  }
  {
#line 111
  s->stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 112
  s->stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 113
  s->stream.opaque = (voidpf )0;
#line 114
  tmp___0 = (Byte *)0;
#line 114
  s->inbuf = tmp___0;
#line 114
  s->stream.next_in = tmp___0;
#line 115
  tmp___1 = (Byte *)0;
#line 115
  s->outbuf = tmp___1;
#line 115
  s->stream.next_out = tmp___1;
#line 116
  tmp___2 = (uInt )0;
#line 116
  s->stream.avail_out = tmp___2;
#line 116
  s->stream.avail_in = tmp___2;
#line 117
  s->file = (FILE *)((void *)0);
#line 118
  s->z_err = 0;
#line 119
  s->z_eof = 0;
#line 120
  s->in = (off_t )0;
#line 121
  s->out = (off_t )0;
#line 122
  s->back = -1;
#line 123
  s->crc = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 124
  s->msg = (char *)((void *)0);
#line 125
  s->transparent = 0;
#line 127
  tmp___3 = strlen(path);
#line 127
  tmp___4 = malloc(tmp___3 + 1UL);
#line 127
  s->path = (char *)tmp___4;
  }
#line 128
  if ((unsigned long )s->path == (unsigned long )((void *)0)) {
    {
#line 129
    destroy(s);
    }
#line 129
    return ((gzFile )0);
  }
  {
#line 131
  strcpy((char */* __restrict  */)s->path, (char const   */* __restrict  */)path);
#line 133
  s->mode = (char )'\000';
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if ((int )*p == 114) {
#line 135
      s->mode = (char )'r';
    }
#line 136
    if ((int )*p == 119) {
#line 136
      s->mode = (char )'w';
    } else
#line 136
    if ((int )*p == 97) {
#line 136
      s->mode = (char )'w';
    }
#line 137
    if ((int )*p >= 48) {
#line 137
      if ((int )*p <= 57) {
#line 138
        level = (int )*p - 48;
      } else {
#line 137
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 139
    if ((int )*p == 102) {
#line 140
      strategy = 1;
    } else
#line 141
    if ((int )*p == 104) {
#line 142
      strategy = 2;
    } else
#line 143
    if ((int )*p == 82) {
#line 144
      strategy = 3;
    } else {
#line 146
      tmp___5 = m;
#line 146
      m ++;
#line 146
      *tmp___5 = *p;
    }
#line 134
    tmp___6 = p;
#line 134
    p ++;
#line 134
    if (*tmp___6) {
#line 134
      if (! ((unsigned long )m != (unsigned long )(fmode + sizeof(fmode)))) {
#line 134
        goto while_break;
      }
    } else {
#line 134
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if ((int )s->mode == 0) {
    {
#line 149
    destroy(s);
    }
#line 149
    return ((gzFile )0);
  }
#line 151
  if ((int )s->mode == 119) {
#line 153
    err = -2;
#line 161
    if (err != 0) {
      {
#line 162
      destroy(s);
      }
#line 162
      return ((gzFile )0);
    } else
#line 161
    if ((unsigned long )s->outbuf == (unsigned long )((Byte *)0)) {
      {
#line 162
      destroy(s);
      }
#line 162
      return ((gzFile )0);
    }
  } else {
    {
#line 165
    tmp___8 = malloc((size_t )16384);
#line 165
    tmp___7 = (Byte *)tmp___8;
#line 165
    s->inbuf = tmp___7;
#line 165
    s->stream.next_in = tmp___7;
#line 167
    err = inflateInit2_(& s->stream, -15, "1.2.3-optipng", (int )sizeof(z_stream ));
    }
#line 174
    if (err != 0) {
      {
#line 175
      destroy(s);
      }
#line 175
      return ((gzFile )0);
    } else
#line 174
    if ((unsigned long )s->inbuf == (unsigned long )((Byte *)0)) {
      {
#line 175
      destroy(s);
      }
#line 175
      return ((gzFile )0);
    }
  }
  {
#line 178
  s->stream.avail_out = (uInt )16384;
#line 180
  tmp___9 = __errno_location();
#line 180
  *tmp___9 = 0;
  }
#line 181
  if (fd < 0) {
    {
#line 181
    tmp___10 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)(fmode));
#line 181
    s->file = tmp___10;
    }
  } else {
    {
#line 181
    tmp___11 = fdopen(fd, (char const   *)(fmode));
#line 181
    s->file = tmp___11;
    }
  }
#line 183
  if ((unsigned long )s->file == (unsigned long )((void *)0)) {
    {
#line 184
    destroy(s);
    }
#line 184
    return ((gzFile )0);
  }
#line 186
  if ((int )s->mode == 119) {
    {
#line 189
    fprintf((FILE */* __restrict  */)s->file, (char const   */* __restrict  */)"%c%c%c%c%c%c%c%c%c%c",
            gz_magic[0], gz_magic[1], 8, 0, 0, 0, 0, 0, 0, 3);
#line 191
    s->start = 10L;
    }
  } else {
    {
#line 198
    check_header(s);
#line 199
    tmp___12 = ftell(s->file);
#line 199
    s->start = tmp___12 - (long )s->stream.avail_in;
    }
  }
#line 202
  return ((gzFile )s);
}
}
#line 208 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
gzFile gzopen(char const   *path , char const   *mode ) 
{ 
  gzFile tmp ;

  {
  {
#line 212
  tmp = gz_open(path, mode, -1);
  }
#line 212
  return (tmp);
}
}
#line 219 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
gzFile gzdopen(int fd , char const   *mode ) 
{ 
  char name[46] ;
  gzFile tmp ;

  {
#line 225
  if (fd < 0) {
#line 225
    return ((gzFile )0);
  }
  {
#line 226
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"<fd:%d>",
          fd);
#line 228
  tmp = gz_open((char const   *)(name), mode, fd);
  }
#line 228
  return (tmp);
}
}
#line 234 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzsetparams(gzFile file , int level , int strategy ) 
{ 
  gz_stream *s ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 239
  s = (gz_stream *)file;
#line 241
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 241
    return (-2);
  } else
#line 241
  if ((int )s->mode != 119) {
#line 241
    return (-2);
  }
#line 244
  if (s->stream.avail_out == 0U) {
    {
#line 246
    s->stream.next_out = s->outbuf;
#line 247
    tmp = fwrite((void const   */* __restrict  */)s->outbuf, (size_t )1, (size_t )16384,
                 (FILE */* __restrict  */)s->file);
    }
#line 247
    if (tmp != 16384UL) {
#line 248
      s->z_err = -1;
    }
#line 250
    s->stream.avail_out = (uInt )16384;
  }
  {
#line 253
  tmp___0 = deflateParams(& s->stream, level, strategy);
  }
#line 253
  return (tmp___0);
}
}
#line 261 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static int get_byte(gz_stream *s ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  Bytef *tmp___2 ;

  {
#line 264
  if (s->z_eof) {
#line 264
    return (-1);
  }
#line 265
  if (s->stream.avail_in == 0U) {
    {
#line 266
    tmp = __errno_location();
#line 266
    *tmp = 0;
#line 267
    tmp___0 = fread((void */* __restrict  */)s->inbuf, (size_t )1, (size_t )16384,
                    (FILE */* __restrict  */)s->file);
#line 267
    s->stream.avail_in = (uInt )tmp___0;
    }
#line 268
    if (s->stream.avail_in == 0U) {
      {
#line 269
      s->z_eof = 1;
#line 270
      tmp___1 = ferror(s->file);
      }
#line 270
      if (tmp___1) {
#line 270
        s->z_err = -1;
      }
#line 271
      return (-1);
    }
#line 273
    s->stream.next_in = s->inbuf;
  }
#line 275
  (s->stream.avail_in) --;
#line 276
  tmp___2 = s->stream.next_in;
#line 276
  (s->stream.next_in) ++;
#line 276
  return ((int )*tmp___2);
}
}
#line 288 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static void check_header(gz_stream *s ) 
{ 
  int method ;
  int flags ;
  uInt len ;
  int c ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uInt tmp___4 ;
  int tmp___5 ;

  {
#line 299
  len = s->stream.avail_in;
#line 300
  if (len < 2U) {
#line 301
    if (len) {
#line 301
      *(s->inbuf + 0) = *(s->stream.next_in + 0);
    }
    {
#line 302
    tmp = __errno_location();
#line 302
    *tmp = 0;
#line 303
    tmp___0 = fread((void */* __restrict  */)(s->inbuf + len), (size_t )1, (size_t )(16384 >> len),
                    (FILE */* __restrict  */)s->file);
#line 303
    len = (uInt )tmp___0;
    }
#line 304
    if (len == 0U) {
      {
#line 304
      tmp___1 = ferror(s->file);
      }
#line 304
      if (tmp___1) {
#line 304
        s->z_err = -1;
      }
    }
#line 305
    s->stream.avail_in += len;
#line 306
    s->stream.next_in = s->inbuf;
#line 307
    if (s->stream.avail_in < 2U) {
#line 308
      s->transparent = (int )s->stream.avail_in;
#line 309
      return;
    }
  }
#line 314
  if ((int )*(s->stream.next_in + 0) != (int )gz_magic[0]) {
#line 316
    s->transparent = 1;
#line 317
    return;
  } else
#line 314
  if ((int )*(s->stream.next_in + 1) != (int )gz_magic[1]) {
#line 316
    s->transparent = 1;
#line 317
    return;
  }
  {
#line 319
  s->stream.avail_in -= 2U;
#line 320
  s->stream.next_in += 2;
#line 323
  method = get_byte(s);
#line 324
  flags = get_byte(s);
  }
#line 325
  if (method != 8) {
#line 326
    s->z_err = -3;
#line 327
    return;
  } else
#line 325
  if ((flags & 224) != 0) {
#line 326
    s->z_err = -3;
#line 327
    return;
  }
#line 331
  len = (uInt )0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (len < 6U)) {
#line 331
      goto while_break;
    }
    {
#line 331
    get_byte(s);
#line 331
    len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if ((flags & 4) != 0) {
    {
#line 334
    tmp___2 = get_byte(s);
#line 334
    len = (uInt )tmp___2;
#line 335
    tmp___3 = get_byte(s);
#line 335
    len += (uInt )tmp___3 << 8;
    }
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      tmp___4 = len;
#line 337
      len --;
#line 337
      if (tmp___4 != 0U) {
        {
#line 337
        tmp___5 = get_byte(s);
        }
#line 337
        if (! (tmp___5 != -1)) {
#line 337
          goto while_break___0;
        }
      } else {
#line 337
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 339
  if ((flags & 8) != 0) {
    {
#line 340
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 340
      c = get_byte(s);
      }
#line 340
      if (c != 0) {
#line 340
        if (! (c != -1)) {
#line 340
          goto while_break___1;
        }
      } else {
#line 340
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 342
  if ((flags & 16) != 0) {
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 343
      c = get_byte(s);
      }
#line 343
      if (c != 0) {
#line 343
        if (! (c != -1)) {
#line 343
          goto while_break___2;
        }
      } else {
#line 343
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 345
  if ((flags & 2) != 0) {
#line 346
    len = (uInt )0;
    {
#line 346
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 346
      if (! (len < 2U)) {
#line 346
        goto while_break___3;
      }
      {
#line 346
      get_byte(s);
#line 346
      len ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 348
  if (s->z_eof) {
#line 348
    s->z_err = -3;
  } else {
#line 348
    s->z_err = 0;
  }
#line 349
  return;
}
}
#line 355 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static int destroy(gz_stream *s ) 
{ 
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
#line 358
  err = 0;
#line 360
  if (! s) {
#line 360
    return (-2);
  }
#line 362
  if (s->msg) {
    {
#line 362
    free((void *)s->msg);
    }
  }
#line 364
  if ((unsigned long )s->stream.state != (unsigned long )((void *)0)) {
#line 365
    if ((int )s->mode == 119) {
#line 367
      err = -2;
    } else
#line 371
    if ((int )s->mode == 114) {
      {
#line 372
      err = inflateEnd(& s->stream);
      }
    }
  }
#line 375
  if ((unsigned long )s->file != (unsigned long )((void *)0)) {
    {
#line 375
    tmp___0 = fclose(s->file);
    }
#line 375
    if (tmp___0) {
      {
#line 377
      tmp = __errno_location();
      }
#line 377
      if (*tmp != 29) {
#line 379
        err = -1;
      }
    }
  }
#line 381
  if (s->z_err < 0) {
#line 381
    err = s->z_err;
  }
#line 383
  if (s->inbuf) {
    {
#line 383
    free((void *)s->inbuf);
    }
  }
#line 384
  if (s->outbuf) {
    {
#line 384
    free((void *)s->outbuf);
    }
  }
#line 385
  if (s->path) {
    {
#line 385
    free((void *)s->path);
    }
  }
#line 386
  if (s) {
    {
#line 386
    free((void *)s);
    }
  }
#line 387
  return (err);
}
}
#line 394 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzread(gzFile file , voidp buf___1 , unsigned int len ) 
{ 
  gz_stream *s ;
  Bytef *start ;
  Byte *next_out ;
  Byte *tmp ;
  uInt n ;
  size_t tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  uLong tmp___4 ;

  {
#line 399
  s = (gz_stream *)file;
#line 400
  start = (Bytef *)buf___1;
#line 403
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 403
    return (-2);
  } else
#line 403
  if ((int )s->mode != 114) {
#line 403
    return (-2);
  }
#line 405
  if (s->z_err == -3) {
#line 405
    return (-1);
  } else
#line 405
  if (s->z_err == -1) {
#line 405
    return (-1);
  }
#line 406
  if (s->z_err == 1) {
#line 406
    return (0);
  }
#line 408
  next_out = (Byte *)buf___1;
#line 409
  s->stream.next_out = (Bytef *)buf___1;
#line 410
  s->stream.avail_out = len;
#line 412
  if (s->stream.avail_out) {
#line 412
    if (s->back != -1) {
#line 413
      tmp = next_out;
#line 413
      next_out ++;
#line 413
      *tmp = (Byte )s->back;
#line 414
      (s->stream.next_out) ++;
#line 415
      (s->stream.avail_out) --;
#line 416
      s->back = -1;
#line 417
      (s->out) ++;
#line 418
      start ++;
#line 419
      if (s->last) {
#line 420
        s->z_err = 1;
#line 421
        return (1);
      }
    }
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (s->stream.avail_out != 0U)) {
#line 425
      goto while_break;
    }
#line 427
    if (s->transparent) {
#line 429
      n = s->stream.avail_in;
#line 430
      if (n > s->stream.avail_out) {
#line 430
        n = s->stream.avail_out;
      }
#line 431
      if (n > 0U) {
        {
#line 432
        memcpy((void */* __restrict  */)s->stream.next_out, (void const   */* __restrict  */)s->stream.next_in,
               (size_t )n);
#line 433
        next_out += n;
#line 434
        s->stream.next_out = next_out;
#line 435
        s->stream.next_in += n;
#line 436
        s->stream.avail_out -= n;
#line 437
        s->stream.avail_in -= n;
        }
      }
#line 439
      if (s->stream.avail_out > 0U) {
        {
#line 440
        tmp___0 = fread((void */* __restrict  */)next_out, (size_t )1, (size_t )s->stream.avail_out,
                        (FILE */* __restrict  */)s->file);
#line 440
        s->stream.avail_out -= (uInt )tmp___0;
        }
      }
#line 443
      len -= s->stream.avail_out;
#line 444
      s->in += (off_t )len;
#line 445
      s->out += (off_t )len;
#line 446
      if (len == 0U) {
#line 446
        s->z_eof = 1;
      }
#line 447
      return ((int )len);
    }
#line 449
    if (s->stream.avail_in == 0U) {
#line 449
      if (! s->z_eof) {
        {
#line 451
        tmp___1 = __errno_location();
#line 451
        *tmp___1 = 0;
#line 452
        tmp___2 = fread((void */* __restrict  */)s->inbuf, (size_t )1, (size_t )16384,
                        (FILE */* __restrict  */)s->file);
#line 452
        s->stream.avail_in = (uInt )tmp___2;
        }
#line 453
        if (s->stream.avail_in == 0U) {
          {
#line 454
          s->z_eof = 1;
#line 455
          tmp___3 = ferror(s->file);
          }
#line 455
          if (tmp___3) {
#line 456
            s->z_err = -1;
#line 457
            goto while_break;
          }
        }
#line 460
        s->stream.next_in = s->inbuf;
      }
    }
    {
#line 462
    s->in += (off_t )s->stream.avail_in;
#line 463
    s->out += (off_t )s->stream.avail_out;
#line 464
    s->z_err = inflate(& s->stream, 0);
#line 465
    s->in -= (off_t )s->stream.avail_in;
#line 466
    s->out -= (off_t )s->stream.avail_out;
    }
#line 468
    if (s->z_err == 1) {
      {
#line 470
      s->crc = crc32(s->crc, (Bytef const   *)start, (uInt )(s->stream.next_out - start));
#line 471
      start = s->stream.next_out;
#line 473
      tmp___4 = getLong(s);
      }
#line 473
      if (tmp___4 != s->crc) {
#line 474
        s->z_err = -3;
      } else {
        {
#line 476
        getLong(s);
#line 481
        check_header(s);
        }
#line 482
        if (s->z_err == 0) {
          {
#line 483
          inflateReset(& s->stream);
#line 484
          s->crc = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
          }
        }
      }
    }
#line 488
    if (s->z_err != 0) {
#line 488
      goto while_break;
    } else
#line 488
    if (s->z_eof) {
#line 488
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 490
  s->crc = crc32(s->crc, (Bytef const   *)start, (uInt )(s->stream.next_out - start));
  }
#line 492
  if (len == s->stream.avail_out) {
#line 492
    if (s->z_err == -3) {
#line 494
      return (-1);
    } else
#line 492
    if (s->z_err == -1) {
#line 494
      return (-1);
    }
  }
#line 495
  return ((int )(len - s->stream.avail_out));
}
}
#line 503 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzgetc(gzFile file ) 
{ 
  unsigned char c ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 508
  tmp___1 = gzread(file, (voidp )(& c), 1U);
  }
#line 508
  if (tmp___1 == 1) {
#line 508
    tmp___0 = (int )c;
  } else {
#line 508
    tmp___0 = -1;
  }
#line 508
  return (tmp___0);
}
}
#line 515 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzungetc(int c , gzFile file ) 
{ 
  gz_stream *s ;

  {
#line 519
  s = (gz_stream *)file;
#line 521
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 521
    return (-1);
  } else
#line 521
  if ((int )s->mode != 114) {
#line 521
    return (-1);
  } else
#line 521
  if (c == -1) {
#line 521
    return (-1);
  } else
#line 521
  if (s->back != -1) {
#line 521
    return (-1);
  }
#line 522
  s->back = c;
#line 523
  (s->out) --;
#line 524
  s->last = s->z_err == 1;
#line 525
  if (s->last) {
#line 525
    s->z_err = 0;
  }
#line 526
  s->z_eof = 0;
#line 527
  return (c);
}
}
#line 540 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
char *gzgets(gzFile file , char *buf___1 , int len ) 
{ 
  char *b ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 545
  b = buf___1;
#line 546
  if ((unsigned long )buf___1 == (unsigned long )((char *)0)) {
#line 546
    return ((char *)0);
  } else
#line 546
  if (len <= 0) {
#line 546
    return ((char *)0);
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    len --;
#line 548
    if (len > 0) {
      {
#line 548
      tmp = gzread(file, (voidp )buf___1, 1U);
      }
#line 548
      if (tmp == 1) {
#line 548
        tmp___0 = buf___1;
#line 548
        buf___1 ++;
#line 548
        if (! ((int )*tmp___0 != 10)) {
#line 548
          goto while_break;
        }
      } else {
#line 548
        goto while_break;
      }
    } else {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  *buf___1 = (char )'\000';
#line 550
  if ((unsigned long )b == (unsigned long )buf___1) {
#line 550
    if (len > 0) {
#line 550
      tmp___1 = (char *)0;
    } else {
#line 550
      tmp___1 = b;
    }
  } else {
#line 550
    tmp___1 = b;
  }
#line 550
  return (tmp___1);
}
}
#line 767 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
off_t gzseek(gzFile file , off_t offset , int whence ) 
{ 
  gz_stream *s ;
  int tmp ;
  off_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int size ;

  {
#line 772
  s = (gz_stream *)file;
#line 774
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 776
    return (-1L);
  } else
#line 774
  if (whence == 2) {
#line 776
    return (-1L);
  } else
#line 774
  if (s->z_err == -1) {
#line 776
    return (-1L);
  } else
#line 774
  if (s->z_err == -3) {
#line 776
    return (-1L);
  }
#line 779
  if ((int )s->mode == 119) {
#line 781
    return (-1L);
  }
#line 809
  if (whence == 1) {
#line 810
    offset += s->out;
  }
#line 812
  if (offset < 0L) {
#line 812
    return (-1L);
  }
#line 814
  if (s->transparent) {
    {
#line 816
    s->back = -1;
#line 817
    s->stream.avail_in = (uInt )0;
#line 818
    s->stream.next_in = s->inbuf;
#line 819
    tmp = fseek(s->file, offset, 0);
    }
#line 819
    if (tmp < 0) {
#line 819
      return (-1L);
    }
#line 821
    tmp___0 = offset;
#line 821
    s->out = tmp___0;
#line 821
    s->in = tmp___0;
#line 822
    return (offset);
  }
#line 826
  if (offset >= s->out) {
#line 827
    offset -= s->out;
  } else {
    {
#line 828
    tmp___1 = gzrewind(file);
    }
#line 828
    if (tmp___1 < 0) {
#line 829
      return (-1L);
    }
  }
#line 833
  if (offset != 0L) {
#line 833
    if ((unsigned long )s->outbuf == (unsigned long )((Byte *)0)) {
      {
#line 834
      tmp___2 = malloc((size_t )16384);
#line 834
      s->outbuf = (Byte *)tmp___2;
      }
#line 835
      if ((unsigned long )s->outbuf == (unsigned long )((Byte *)0)) {
#line 835
        return (-1L);
      }
    }
  }
#line 837
  if (offset) {
#line 837
    if (s->back != -1) {
#line 838
      s->back = -1;
#line 839
      (s->out) ++;
#line 840
      offset --;
#line 841
      if (s->last) {
#line 841
        s->z_err = 1;
      }
    }
  }
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 843
    if (! (offset > 0L)) {
#line 843
      goto while_break;
    }
#line 844
    size = 16384;
#line 845
    if (offset < 16384L) {
#line 845
      size = (int )offset;
    }
    {
#line 847
    size = gzread(file, (voidp )s->outbuf, (uInt )size);
    }
#line 848
    if (size <= 0) {
#line 848
      return (-1L);
    }
#line 849
    offset -= (off_t )size;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  return (s->out);
}
}
#line 857 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzrewind(gzFile file ) 
{ 
  gz_stream *s ;
  int tmp ;

  {
#line 860
  s = (gz_stream *)file;
#line 862
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 862
    return (-1);
  } else
#line 862
  if ((int )s->mode != 114) {
#line 862
    return (-1);
  }
  {
#line 864
  s->z_err = 0;
#line 865
  s->z_eof = 0;
#line 866
  s->back = -1;
#line 867
  s->stream.avail_in = (uInt )0;
#line 868
  s->stream.next_in = s->inbuf;
#line 869
  s->crc = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
  }
#line 870
  if (! s->transparent) {
    {
#line 870
    inflateReset(& s->stream);
    }
  }
  {
#line 871
  s->in = (off_t )0;
#line 872
  s->out = (off_t )0;
#line 873
  tmp = fseek(s->file, s->start, 0);
  }
#line 873
  return (tmp);
}
}
#line 881 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
off_t gztell(gzFile file ) 
{ 
  off_t tmp ;

  {
  {
#line 884
  tmp = gzseek(file, 0L, 1);
  }
#line 884
  return (tmp);
}
}
#line 891 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzeof(gzFile file ) 
{ 
  gz_stream *s ;

  {
#line 894
  s = (gz_stream *)file;
#line 900
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 900
    return (0);
  } else
#line 900
  if ((int )s->mode != 114) {
#line 900
    return (0);
  }
#line 901
  if (s->z_eof) {
#line 901
    return (1);
  }
#line 902
  return (s->z_err == 1);
}
}
#line 908 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzdirect(gzFile file ) 
{ 
  gz_stream *s ;

  {
#line 911
  s = (gz_stream *)file;
#line 913
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 913
    return (0);
  } else
#line 913
  if ((int )s->mode != 114) {
#line 913
    return (0);
  }
#line 914
  return (s->transparent);
}
}
#line 935 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
static uLong getLong(gz_stream *s ) 
{ 
  uLong x ;
  int tmp ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 938
  tmp = get_byte(s);
#line 938
  x = (uLong )tmp;
#line 941
  tmp___0 = get_byte(s);
#line 941
  x += (uLong )tmp___0 << 8;
#line 942
  tmp___1 = get_byte(s);
#line 942
  x += (uLong )tmp___1 << 16;
#line 943
  c = get_byte(s);
  }
#line 944
  if (c == -1) {
#line 944
    s->z_err = -3;
  }
#line 945
  x += (uLong )c << 24;
#line 946
  return (x);
}
}
#line 953 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
int gzclose(gzFile file ) 
{ 
  gz_stream *s ;
  int tmp ;

  {
#line 956
  s = (gz_stream *)file;
#line 958
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 958
    return (-2);
  }
#line 960
  if ((int )s->mode == 119) {
#line 962
    return (-2);
  }
  {
#line 971
  tmp = destroy((gz_stream *)file);
  }
#line 971
  return (tmp);
}
}
#line 987 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
char const   *gzerror(gzFile file , int *errnum ) 
{ 
  char *m ;
  gz_stream *s ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 992
  s = (gz_stream *)file;
#line 994
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 995
    *errnum = -2;
#line 996
    return ((char const   *)z_errmsg[4]);
  }
#line 998
  *errnum = s->z_err;
#line 999
  if (*errnum == 0) {
#line 999
    return ("");
  }
#line 1001
  if (*errnum == -1) {
    {
#line 1001
    tmp = __errno_location();
#line 1001
    tmp___0 = strerror(*tmp);
#line 1001
    tmp___1 = tmp___0;
    }
  } else {
#line 1001
    tmp___1 = s->stream.msg;
  }
#line 1001
  m = tmp___1;
#line 1003
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 1003
    m = (char *)z_errmsg[2 - s->z_err];
  } else
#line 1003
  if ((int )*m == 0) {
#line 1003
    m = (char *)z_errmsg[2 - s->z_err];
  }
#line 1005
  if (s->msg) {
    {
#line 1005
    free((void *)s->msg);
    }
  }
  {
#line 1006
  tmp___2 = strlen((char const   *)s->path);
#line 1006
  tmp___3 = strlen((char const   *)m);
#line 1006
  tmp___4 = malloc((tmp___2 + tmp___3) + 3UL);
#line 1006
  s->msg = (char *)tmp___4;
  }
#line 1007
  if ((unsigned long )s->msg == (unsigned long )((char *)0)) {
#line 1007
    return ((char const   *)z_errmsg[6]);
  }
  {
#line 1008
  strcpy((char */* __restrict  */)s->msg, (char const   */* __restrict  */)s->path);
#line 1009
  strcat((char */* __restrict  */)s->msg, (char const   */* __restrict  */)": ");
#line 1010
  strcat((char */* __restrict  */)s->msg, (char const   */* __restrict  */)m);
  }
#line 1011
  return ((char const   *)s->msg);
}
}
#line 1017 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/gzio.c"
void gzclearerr(gzFile file ) 
{ 
  gz_stream *s ;

  {
#line 1020
  s = (gz_stream *)file;
#line 1022
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1022
    return;
  }
#line 1023
  if (s->z_err != 1) {
#line 1023
    s->z_err = 0;
  }
  {
#line 1024
  s->z_eof = 0;
#line 1025
  clearerr(s->file);
  }
#line 1026
  return;
}
}
#line 251 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
int deflate(z_streamp___0 strm , int flush ) ;
#line 337
int deflateEnd(z_streamp___0 strm ) ;
#line 547
int deflateSetDictionary(z_streamp___0 strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 586
int deflateCopy(z_streamp___0 dest , z_streamp___0 source ) ;
#line 604
int deflateReset(z_streamp___0 strm ) ;
#line 636
int deflateTune(z_streamp___0 strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) ;
#line 653
uLong deflateBound(z_streamp___0 strm , uLong sourceLen ) ;
#line 662
int deflatePrime(z_streamp___0 strm , int bits , int value ) ;
#line 678
int deflateSetHeader(z_streamp___0 strm , gz_headerp head ) ;
#line 1049
uLong compressBound(uLong sourceLen ) ;
#line 1326
int deflateInit_(z_streamp___0 strm , int level , char const   *version , int stream_size ) ;
#line 1330
int deflateInit2_(z_streamp___0 strm , int level , int method , int windowBits , int memLevel ,
                  int strategy , char const   *version , int stream_size ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 54 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
char const   deflate_copyright[53]  = 
#line 54 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
  {      (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'3',      (char const   )' ',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'5',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'J', 
        (char const   )'e',      (char const   )'a',      (char const   )'n',      (char const   )'-', 
        (char const   )'l',      (char const   )'o',      (char const   )'u',      (char const   )'p', 
        (char const   )' ',      (char const   )'G',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'l',      (char const   )'y',      (char const   )' ', 
        (char const   )'\000'};
#line 76
static void fill_window(deflate_state___0 *s ) ;
#line 77
static block_state deflate_stored(deflate_state___0 *s , int flush ) ;
#line 78
static block_state deflate_fast(deflate_state___0 *s , int flush ) ;
#line 80
static block_state deflate_slow(deflate_state___0 *s , int flush ) ;
#line 82
static void lm_init(deflate_state___0 *s ) ;
#line 83
static void putShortMSB(deflate_state___0 *s , uInt b ) ;
#line 84
static void flush_pending(z_streamp___0 strm ) ;
#line 85
static int read_buf(z_streamp___0 strm , Bytef *buf___1 , unsigned int size ) ;
#line 91
static uInt longest_match(deflate_state___0 *s , IPos cur_match ) ;
#line 94
static uInt longest_match_fast(deflate_state___0 *s , IPos cur_match ) ;
#line 137 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static config const   configuration_table[10]  = 
#line 137
  {      {(ush )0, (ush )0, (ush )0, (ush )0, & deflate_stored}, 
        {(ush )4, (ush )4, (ush )8, (ush )4, & deflate_fast}, 
        {(ush )4, (ush )5, (ush )16, (ush )8, & deflate_fast}, 
        {(ush )4, (ush )6, (ush )32, (ush )32, & deflate_fast}, 
        {(ush )4, (ush )4, (ush )16, (ush )16, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )32, (ush )32, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )128, (ush )128, & deflate_slow}, 
        {(ush )8, (ush )32, (ush )128, (ush )256, & deflate_slow}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024, & deflate_slow}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096, & deflate_slow}};
#line 204 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateInit_(z_streamp___0 strm , int level , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 210
  tmp = deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size);
  }
#line 210
  return (tmp);
}
}
#line 229 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static char const   my_version[14]  = 
#line 229
  {      (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'.', 
        (char const   )'3',      (char const   )'-',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'p',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
#line 216 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateInit2_(z_streamp___0 strm , int level , int method , int windowBits , int memLevel ,
                  int strategy , char const   *version , int stream_size ) 
{ 
  deflate_state___0 *s ;
  int wrap ;
  ushf *overlay ;
  voidpf tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;
  int tmp___4 ;

  {
#line 228
  wrap = 1;
#line 236
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 238
    return (-6);
  } else
#line 236
  if ((int const   )*(version + 0) != (int const   )my_version[0]) {
#line 238
    return (-6);
  } else
#line 236
  if ((unsigned long )stream_size != sizeof(z_stream___0 )) {
#line 238
    return (-6);
  }
#line 240
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 240
    return (-2);
  }
#line 242
  strm->msg = (char *)0;
#line 243
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 244
    strm->zalloc = & zcalloc;
#line 245
    strm->opaque = (voidpf )0;
  }
#line 247
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 247
    strm->zfree = & zcfree;
  }
#line 252
  if (level == -1) {
#line 252
    level = 6;
  }
#line 255
  if (windowBits < 0) {
#line 256
    wrap = 0;
#line 257
    windowBits = - windowBits;
  }
#line 265
  if (memLevel < 1) {
#line 268
    return (-2);
  } else
#line 265
  if (memLevel > 9) {
#line 268
    return (-2);
  } else
#line 265
  if (method != 8) {
#line 268
    return (-2);
  } else
#line 265
  if (windowBits < 8) {
#line 268
    return (-2);
  } else
#line 265
  if (windowBits > 15) {
#line 268
    return (-2);
  } else
#line 265
  if (level < 0) {
#line 268
    return (-2);
  } else
#line 265
  if (level > 9) {
#line 268
    return (-2);
  } else
#line 265
  if (strategy < 0) {
#line 268
    return (-2);
  } else
#line 265
  if (strategy > 4) {
#line 268
    return (-2);
  }
#line 270
  if (windowBits == 8) {
#line 270
    windowBits = 9;
  }
  {
#line 271
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(deflate_state___0 ));
#line 271
  s = (deflate_state___0 *)tmp;
  }
#line 272
  if ((unsigned long )s == (unsigned long )((deflate_state___0 *)0)) {
#line 272
    return (-4);
  }
  {
#line 273
  strm->state = s;
#line 274
  s->strm = strm;
#line 276
  s->wrap = wrap;
#line 277
  s->gzhead = (gz_headerp )0;
#line 278
  s->w_bits = (uInt )windowBits;
#line 279
  s->w_size = (uInt )(1 << s->w_bits);
#line 280
  s->w_mask = s->w_size - 1U;
#line 282
  s->hash_bits = (uInt )(memLevel + 7);
#line 283
  s->hash_size = (uInt )(1 << s->hash_bits);
#line 284
  s->hash_mask = s->hash_size - 1U;
#line 285
  s->hash_shift = ((s->hash_bits + 3U) - 1U) / 3U;
#line 287
  tmp___0 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )(2UL * sizeof(Byte )));
#line 287
  s->window = (Bytef *)tmp___0;
#line 288
  tmp___1 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )sizeof(Pos ));
#line 288
  s->prev = (Posf *)tmp___1;
#line 289
  tmp___2 = (*(strm->zalloc))(strm->opaque, s->hash_size, (uInt )sizeof(Pos ));
#line 289
  s->head = (Posf *)tmp___2;
#line 291
  s->lit_bufsize = (uInt )(1 << (memLevel + 6));
#line 293
  tmp___3 = (*(strm->zalloc))(strm->opaque, s->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 293
  overlay = (ushf *)tmp___3;
#line 294
  s->pending_buf = (uchf *)overlay;
#line 295
  s->pending_buf_size = (ulg )s->lit_bufsize * (sizeof(ush ) + 2UL);
  }
#line 297
  if ((unsigned long )s->window == (unsigned long )((Bytef *)0)) {
    {
#line 299
    s->status = 666;
#line 300
    strm->msg = (char *)z_errmsg[6];
#line 301
    deflateEnd(strm);
    }
#line 302
    return (-4);
  } else
#line 297
  if ((unsigned long )s->prev == (unsigned long )((Posf *)0)) {
    {
#line 299
    s->status = 666;
#line 300
    strm->msg = (char *)z_errmsg[6];
#line 301
    deflateEnd(strm);
    }
#line 302
    return (-4);
  } else
#line 297
  if ((unsigned long )s->head == (unsigned long )((Posf *)0)) {
    {
#line 299
    s->status = 666;
#line 300
    strm->msg = (char *)z_errmsg[6];
#line 301
    deflateEnd(strm);
    }
#line 302
    return (-4);
  } else
#line 297
  if ((unsigned long )s->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 299
    s->status = 666;
#line 300
    strm->msg = (char *)z_errmsg[6];
#line 301
    deflateEnd(strm);
    }
#line 302
    return (-4);
  }
  {
#line 304
  s->d_buf = overlay + (unsigned long )s->lit_bufsize / sizeof(ush );
#line 305
  s->l_buf = s->pending_buf + (1UL + sizeof(ush )) * (unsigned long )s->lit_bufsize;
#line 307
  s->level = level;
#line 308
  s->strategy = strategy;
#line 309
  s->method = (Byte )method;
#line 311
  tmp___4 = deflateReset(strm);
  }
#line 311
  return (tmp___4);
}
}
#line 315 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateSetDictionary(z_streamp___0 strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  deflate_state___0 *s ;
  uInt length ;
  uInt n ;
  IPos hash_head ;
  Posf tmp ;

  {
#line 321
  length = dictLength;
#line 323
  hash_head = (IPos )0;
#line 325
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 328
    return (-2);
  } else
#line 325
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 328
    return (-2);
  } else
#line 325
  if ((unsigned long )dictionary == (unsigned long )((Bytef const   *)0)) {
#line 328
    return (-2);
  } else
#line 325
  if ((strm->state)->wrap == 2) {
#line 328
    return (-2);
  } else
#line 325
  if ((strm->state)->wrap == 1) {
#line 325
    if ((strm->state)->status != 42) {
#line 328
      return (-2);
    }
  }
#line 330
  s = strm->state;
#line 331
  if (s->wrap) {
    {
#line 332
    strm->adler = adler32(strm->adler, dictionary, dictLength);
    }
  }
#line 334
  if (length < 3U) {
#line 334
    return (0);
  }
#line 335
  if (length > s->w_size - 262U) {
#line 336
    length = s->w_size - 262U;
#line 337
    dictionary += dictLength - length;
  }
  {
#line 339
  memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)dictionary,
         (size_t )length);
#line 340
  s->strstart = length;
#line 341
  s->block_start = (long )length;
#line 347
  s->ins_h = (uInt )*(s->window + 0);
#line 348
  s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + 1)) & s->hash_mask;
#line 349
  n = (uInt )0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! (n <= length - 3U)) {
#line 349
      goto while_break;
    }
#line 350
    s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (n + 2U))) & s->hash_mask;
#line 350
    tmp = *(s->head + s->ins_h);
#line 350
    *(s->prev + (n & s->w_mask)) = tmp;
#line 350
    hash_head = (IPos )tmp;
#line 350
    *(s->head + s->ins_h) = (Pos )n;
#line 349
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  if (hash_head) {
#line 352
    hash_head = (IPos )0;
  }
#line 353
  return (0);
}
}
#line 357 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateReset(z_streamp___0 strm ) 
{ 
  deflate_state___0 *s ;
  uLong tmp ;

  {
#line 362
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 364
    return (-2);
  } else
#line 362
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 364
    return (-2);
  } else
#line 362
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 364
    return (-2);
  } else
#line 362
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 364
    return (-2);
  }
#line 367
  tmp = (uLong )0;
#line 367
  strm->total_out = tmp;
#line 367
  strm->total_in = tmp;
#line 368
  strm->msg = (char *)0;
#line 369
  strm->data_type = 2;
#line 371
  s = strm->state;
#line 372
  s->pending = (uInt )0;
#line 373
  s->pending_out = s->pending_buf;
#line 375
  if (s->wrap < 0) {
#line 376
    s->wrap = - s->wrap;
  }
#line 378
  if (s->wrap) {
#line 378
    s->status = 42;
  } else {
#line 378
    s->status = 113;
  }
  {
#line 379
  strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 384
  s->last_flush = 0;
#line 386
  _tr_init(s);
#line 387
  lm_init(s);
  }
#line 389
  return (0);
}
}
#line 393 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateSetHeader(z_streamp___0 strm , gz_headerp head ) 
{ 


  {
#line 397
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 397
    return (-2);
  } else
#line 397
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 397
    return (-2);
  }
#line 398
  if ((strm->state)->wrap != 2) {
#line 398
    return (-2);
  }
#line 399
  (strm->state)->gzhead = head;
#line 400
  return (0);
}
}
#line 404 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflatePrime(z_streamp___0 strm , int bits , int value ) 
{ 


  {
#line 409
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 409
    return (-2);
  } else
#line 409
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 409
    return (-2);
  }
#line 410
  (strm->state)->bi_valid = bits;
#line 411
  (strm->state)->bi_buf = (ush )(value & ((1 << bits) - 1));
#line 412
  return (0);
}
}
#line 416 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateParams(z_streamp___0 strm , int level , int strategy ) 
{ 
  deflate_state___0 *s ;
  block_state (*func)(deflate_state___0 *s , int flush ) ;
  int err ;

  {
#line 423
  err = 0;
#line 425
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 425
    return (-2);
  } else
#line 425
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 425
    return (-2);
  }
#line 426
  s = strm->state;
#line 431
  if (level == -1) {
#line 431
    level = 6;
  }
#line 433
  if (level < 0) {
#line 434
    return (-2);
  } else
#line 433
  if (level > 9) {
#line 434
    return (-2);
  } else
#line 433
  if (strategy < 0) {
#line 434
    return (-2);
  } else
#line 433
  if (strategy > 4) {
#line 434
    return (-2);
  }
#line 436
  func = (block_state (*)(deflate_state___0 *s , int flush ))configuration_table[s->level].func;
#line 438
  if ((unsigned long )func != (unsigned long )configuration_table[level].func) {
#line 438
    if (strm->total_in != 0UL) {
      {
#line 440
      err = deflate(strm, 1);
      }
    }
  }
#line 442
  if (s->level != level) {
#line 443
    s->level = level;
#line 444
    s->max_lazy_match = (uInt )configuration_table[level].max_lazy;
#line 445
    s->good_match = (uInt )configuration_table[level].good_length;
#line 446
    s->nice_match = (int )configuration_table[level].nice_length;
#line 447
    s->max_chain_length = (uInt )configuration_table[level].max_chain;
  }
#line 449
  s->strategy = strategy;
#line 450
  return (err);
}
}
#line 454 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateTune(z_streamp___0 strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) 
{ 
  deflate_state___0 *s ;

  {
#line 463
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 463
    return (-2);
  } else
#line 463
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 463
    return (-2);
  }
#line 464
  s = strm->state;
#line 465
  s->good_match = (uInt )good_length;
#line 466
  s->max_lazy_match = (uInt )max_lazy;
#line 467
  s->nice_match = nice_length;
#line 468
  s->max_chain_length = (uInt )max_chain;
#line 469
  return (0);
}
}
#line 489 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
uLong deflateBound(z_streamp___0 strm , uLong sourceLen ) 
{ 
  deflate_state___0 *s ;
  uLong destLen ;
  uLong tmp ;

  {
#line 497
  destLen = ((sourceLen + ((sourceLen + 7UL) >> 3)) + ((sourceLen + 63UL) >> 6)) + 11UL;
#line 501
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 502
    return (destLen);
  } else
#line 501
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 502
    return (destLen);
  }
#line 505
  s = strm->state;
#line 506
  if (s->w_bits != 15U) {
#line 507
    return (destLen);
  } else
#line 506
  if (s->hash_bits != 15U) {
#line 507
    return (destLen);
  }
  {
#line 510
  tmp = compressBound(sourceLen);
  }
#line 510
  return (tmp);
}
}
#line 518 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static void putShortMSB(deflate_state___0 *s , uInt b ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;

  {
#line 522
  tmp = s->pending;
#line 522
  (s->pending) ++;
#line 522
  *(s->pending_buf + tmp) = (Byte )(b >> 8);
#line 523
  tmp___0 = s->pending;
#line 523
  (s->pending) ++;
#line 523
  *(s->pending_buf + tmp___0) = (Byte )(b & 255U);
#line 524
  return;
}
}
#line 532 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static void flush_pending(z_streamp___0 strm ) 
{ 
  unsigned int len ;

  {
#line 535
  len = (strm->state)->pending;
#line 537
  if (len > strm->avail_out) {
#line 537
    len = strm->avail_out;
  }
#line 538
  if (len == 0U) {
#line 538
    return;
  }
  {
#line 540
  memcpy((void */* __restrict  */)strm->next_out, (void const   */* __restrict  */)(strm->state)->pending_out,
         (size_t )len);
#line 541
  strm->next_out += len;
#line 542
  (strm->state)->pending_out += len;
#line 543
  strm->total_out += (uLong )len;
#line 544
  strm->avail_out -= len;
#line 545
  (strm->state)->pending -= len;
  }
#line 546
  if ((strm->state)->pending == 0U) {
#line 547
    (strm->state)->pending_out = (strm->state)->pending_buf;
  }
#line 549
  return;
}
}
#line 552 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflate(z_streamp___0 strm , int flush ) 
{ 
  int old_flush ;
  deflate_state___0 *s ;
  uInt header ;
  uInt level_flags ;
  block_state bstate ;
  int tmp ;

  {
#line 559
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 561
    return (-2);
  } else
#line 559
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 561
    return (-2);
  } else
#line 559
  if (flush > 4) {
#line 561
    return (-2);
  } else
#line 559
  if (flush < 0) {
#line 561
    return (-2);
  }
#line 563
  s = strm->state;
#line 565
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 568
    strm->msg = (char *)z_errmsg[4];
#line 568
    return (-2);
  } else
#line 565
  if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 565
    if (strm->avail_in != 0U) {
#line 568
      strm->msg = (char *)z_errmsg[4];
#line 568
      return (-2);
    } else {
#line 565
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 565
  if (s->status == 666) {
#line 565
    if (flush != 4) {
#line 568
      strm->msg = (char *)z_errmsg[4];
#line 568
      return (-2);
    }
  }
#line 570
  if (strm->avail_out == 0U) {
#line 570
    strm->msg = (char *)z_errmsg[7];
#line 570
    return (-5);
  }
#line 572
  s->strm = strm;
#line 573
  old_flush = s->last_flush;
#line 574
  s->last_flush = flush;
#line 577
  if (s->status == 42) {
#line 625
    header = (8U + ((s->w_bits - 8U) << 4)) << 8;
#line 628
    if (s->strategy >= 2) {
#line 629
      level_flags = (uInt )0;
    } else
#line 628
    if (s->level < 2) {
#line 629
      level_flags = (uInt )0;
    } else
#line 630
    if (s->level < 6) {
#line 631
      level_flags = (uInt )1;
    } else
#line 632
    if (s->level == 6) {
#line 633
      level_flags = (uInt )2;
    } else {
#line 635
      level_flags = (uInt )3;
    }
#line 636
    header |= level_flags << 6;
#line 637
    if (s->strstart != 0U) {
#line 637
      header |= 32U;
    }
    {
#line 638
    header += 31U - header % 31U;
#line 640
    s->status = 113;
#line 641
    putShortMSB(s, header);
    }
#line 644
    if (s->strstart != 0U) {
      {
#line 645
      putShortMSB(s, (uInt )(strm->adler >> 16));
#line 646
      putShortMSB(s, (uInt )(strm->adler & 65535UL));
      }
    }
    {
#line 648
    strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
    }
  }
#line 757
  if (s->pending != 0U) {
    {
#line 758
    flush_pending(strm);
    }
#line 759
    if (strm->avail_out == 0U) {
#line 766
      s->last_flush = -1;
#line 767
      return (0);
    }
  } else
#line 774
  if (strm->avail_in == 0U) {
#line 774
    if (flush <= old_flush) {
#line 774
      if (flush != 4) {
#line 776
        strm->msg = (char *)z_errmsg[7];
#line 776
        return (-5);
      }
    }
  }
#line 780
  if (s->status == 666) {
#line 780
    if (strm->avail_in != 0U) {
#line 781
      strm->msg = (char *)z_errmsg[7];
#line 781
      return (-5);
    }
  }
#line 786
  if (strm->avail_in != 0U) {
#line 786
    goto _L___1;
  } else
#line 786
  if (s->lookahead != 0U) {
#line 786
    goto _L___1;
  } else
#line 786
  if (flush != 0) {
#line 786
    if (s->status != 666) {
      _L___1: /* CIL Label */ 
      {
#line 790
      bstate = (*(configuration_table[s->level].func))(s, flush);
      }
#line 792
      if ((unsigned int )bstate == 2U) {
#line 793
        s->status = 666;
      } else
#line 792
      if ((unsigned int )bstate == 3U) {
#line 793
        s->status = 666;
      }
#line 795
      if ((unsigned int )bstate == 0U) {
#line 795
        goto _L___0;
      } else
#line 795
      if ((unsigned int )bstate == 2U) {
        _L___0: /* CIL Label */ 
#line 796
        if (strm->avail_out == 0U) {
#line 797
          s->last_flush = -1;
        }
#line 799
        return (0);
      }
#line 808
      if ((unsigned int )bstate == 1U) {
#line 809
        if (flush == 1) {
          {
#line 810
          _tr_align(s);
          }
        } else {
          {
#line 812
          _tr_stored_block(s, (char *)0, (ulg )0L, 0);
          }
#line 816
          if (flush == 3) {
            {
#line 817
            *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 817
            memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
            }
          }
        }
        {
#line 820
        flush_pending(strm);
        }
#line 821
        if (strm->avail_out == 0U) {
#line 822
          s->last_flush = -1;
#line 823
          return (0);
        }
      }
    }
  }
#line 829
  if (flush != 4) {
#line 829
    return (0);
  }
#line 830
  if (s->wrap <= 0) {
#line 830
    return (1);
  }
  {
#line 847
  putShortMSB(s, (uInt )(strm->adler >> 16));
#line 848
  putShortMSB(s, (uInt )(strm->adler & 65535UL));
#line 850
  flush_pending(strm);
  }
#line 854
  if (s->wrap > 0) {
#line 854
    s->wrap = - s->wrap;
  }
#line 855
  if (s->pending != 0U) {
#line 855
    tmp = 0;
  } else {
#line 855
    tmp = 1;
  }
#line 855
  return (tmp);
}
}
#line 859 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateEnd(z_streamp___0 strm ) 
{ 
  int status ;
  int tmp ;

  {
#line 864
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 864
    return (-2);
  } else
#line 864
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 864
    return (-2);
  }
#line 866
  status = (strm->state)->status;
#line 867
  if (status != 42) {
#line 867
    if (status != 69) {
#line 867
      if (status != 73) {
#line 867
        if (status != 91) {
#line 867
          if (status != 103) {
#line 867
            if (status != 113) {
#line 867
              if (status != 666) {
#line 874
                return (-2);
              }
            }
          }
        }
      }
    }
  }
#line 878
  if ((strm->state)->pending_buf) {
    {
#line 878
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->pending_buf);
    }
  }
#line 879
  if ((strm->state)->head) {
    {
#line 879
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->head);
    }
  }
#line 880
  if ((strm->state)->prev) {
    {
#line 880
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->prev);
    }
  }
#line 881
  if ((strm->state)->window) {
    {
#line 881
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->window);
    }
  }
  {
#line 883
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 884
  strm->state = (struct internal_state___1 *)0;
  }
#line 886
  if (status == 113) {
#line 886
    tmp = -3;
  } else {
#line 886
    tmp = 0;
  }
#line 886
  return (tmp);
}
}
#line 894 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
int deflateCopy(z_streamp___0 dest , z_streamp___0 source ) 
{ 
  deflate_state___0 *ds ;
  deflate_state___0 *ss ;
  ushf *overlay ;
  voidpf tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;

  {
#line 906
  if ((unsigned long )source == (unsigned long )((z_streamp___0 )0)) {
#line 907
    return (-2);
  } else
#line 906
  if ((unsigned long )dest == (unsigned long )((z_streamp___0 )0)) {
#line 907
    return (-2);
  } else
#line 906
  if ((unsigned long )source->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 907
    return (-2);
  }
  {
#line 910
  ss = source->state;
#line 912
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)source, sizeof(z_stream___0 ));
#line 914
  tmp = (*(dest->zalloc))(dest->opaque, (uInt )1, (uInt )sizeof(deflate_state___0 ));
#line 914
  ds = (deflate_state___0 *)tmp;
  }
#line 915
  if ((unsigned long )ds == (unsigned long )((deflate_state___0 *)0)) {
#line 915
    return (-4);
  }
  {
#line 916
  dest->state = ds;
#line 917
  memcpy((void */* __restrict  */)ds, (void const   */* __restrict  */)ss, sizeof(deflate_state___0 ));
#line 918
  ds->strm = dest;
#line 920
  tmp___0 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )(2UL * sizeof(Byte )));
#line 920
  ds->window = (Bytef *)tmp___0;
#line 921
  tmp___1 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )sizeof(Pos ));
#line 921
  ds->prev = (Posf *)tmp___1;
#line 922
  tmp___2 = (*(dest->zalloc))(dest->opaque, ds->hash_size, (uInt )sizeof(Pos ));
#line 922
  ds->head = (Posf *)tmp___2;
#line 923
  tmp___3 = (*(dest->zalloc))(dest->opaque, ds->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 923
  overlay = (ushf *)tmp___3;
#line 924
  ds->pending_buf = (uchf *)overlay;
  }
#line 926
  if ((unsigned long )ds->window == (unsigned long )((Bytef *)0)) {
    {
#line 928
    deflateEnd(dest);
    }
#line 929
    return (-4);
  } else
#line 926
  if ((unsigned long )ds->prev == (unsigned long )((Posf *)0)) {
    {
#line 928
    deflateEnd(dest);
    }
#line 929
    return (-4);
  } else
#line 926
  if ((unsigned long )ds->head == (unsigned long )((Posf *)0)) {
    {
#line 928
    deflateEnd(dest);
    }
#line 929
    return (-4);
  } else
#line 926
  if ((unsigned long )ds->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 928
    deflateEnd(dest);
    }
#line 929
    return (-4);
  }
  {
#line 932
  memcpy((void */* __restrict  */)ds->window, (void const   */* __restrict  */)ss->window,
         (unsigned long )(ds->w_size * 2U) * sizeof(Byte ));
#line 933
  memcpy((void */* __restrict  */)ds->prev, (void const   */* __restrict  */)ss->prev,
         (unsigned long )ds->w_size * sizeof(Pos ));
#line 934
  memcpy((void */* __restrict  */)ds->head, (void const   */* __restrict  */)ss->head,
         (unsigned long )ds->hash_size * sizeof(Pos ));
#line 935
  memcpy((void */* __restrict  */)ds->pending_buf, (void const   */* __restrict  */)ss->pending_buf,
         (size_t )((uInt )ds->pending_buf_size));
#line 937
  ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
#line 938
  ds->d_buf = overlay + (unsigned long )ds->lit_bufsize / sizeof(ush );
#line 939
  ds->l_buf = ds->pending_buf + (1UL + sizeof(ush )) * (unsigned long )ds->lit_bufsize;
#line 941
  ds->l_desc.dyn_tree = ds->dyn_ltree;
#line 942
  ds->d_desc.dyn_tree = ds->dyn_dtree;
#line 943
  ds->bl_desc.dyn_tree = ds->bl_tree;
  }
#line 945
  return (0);
}
}
#line 956 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static int read_buf(z_streamp___0 strm , Bytef *buf___1 , unsigned int size ) 
{ 
  unsigned int len ;

  {
#line 961
  len = strm->avail_in;
#line 963
  if (len > size) {
#line 963
    len = size;
  }
#line 964
  if (len == 0U) {
#line 964
    return (0);
  }
#line 966
  strm->avail_in -= len;
#line 968
  if ((strm->state)->wrap == 1) {
    {
#line 969
    strm->adler = adler32(strm->adler, (Bytef const   *)strm->next_in, len);
    }
  }
  {
#line 976
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)strm->next_in,
         (size_t )len);
#line 977
  strm->next_in += len;
#line 978
  strm->total_in += (uLong )len;
  }
#line 980
  return ((int )len);
}
}
#line 986 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static void lm_init(deflate_state___0 *s ) 
{ 
  uInt tmp ;

  {
  {
#line 989
  s->window_size = 2UL * (ulg )s->w_size;
#line 991
  *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 991
  memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 995
  s->max_lazy_match = (uInt )configuration_table[s->level].max_lazy;
#line 996
  s->good_match = (uInt )configuration_table[s->level].good_length;
#line 997
  s->nice_match = (int )configuration_table[s->level].nice_length;
#line 998
  s->max_chain_length = (uInt )configuration_table[s->level].max_chain;
#line 1000
  s->strstart = (uInt )0;
#line 1001
  s->block_start = 0L;
#line 1002
  s->lookahead = (uInt )0;
#line 1003
  tmp = (uInt )2;
#line 1003
  s->prev_length = tmp;
#line 1003
  s->match_length = tmp;
#line 1004
  s->match_available = 0;
#line 1005
  s->ins_h = (uInt )0;
  }
#line 1011
  return;
}
}
#line 1027 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static uInt longest_match(deflate_state___0 *s , IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register Bytef *scan ;
  register Bytef *match ;
  register int len ;
  int best_len ;
  int nice_match ;
  IPos limit ;
  uInt tmp ;
  Posf *prev ;
  uInt wmask ;
  register Bytef *strend ;
  register Byte scan_end1 ;
  register Byte scan_end ;

  {
#line 1031
  chain_length = s->max_chain_length;
#line 1032
  scan = s->window + s->strstart;
#line 1035
  best_len = (int )s->prev_length;
#line 1036
  nice_match = s->nice_match;
#line 1037
  if (s->strstart > s->w_size - 262U) {
#line 1037
    tmp = s->strstart - (s->w_size - 262U);
  } else {
#line 1037
    tmp = (uInt )0;
  }
#line 1037
  limit = tmp;
#line 1042
  prev = s->prev;
#line 1043
  wmask = s->w_mask;
#line 1053
  strend = (s->window + s->strstart) + 258;
#line 1054
  scan_end1 = *(scan + (best_len - 1));
#line 1055
  scan_end = *(scan + best_len);
#line 1064
  if (s->prev_length >= s->good_match) {
#line 1065
    chain_length >>= 2;
  }
#line 1070
  if ((uInt )nice_match > s->lookahead) {
#line 1070
    nice_match = (int )s->lookahead;
  }
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    match = s->window + cur_match;
#line 1121
    if ((int )*(match + best_len) != (int )scan_end) {
#line 1124
      goto __Cont;
    } else
#line 1121
    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
#line 1124
      goto __Cont;
    } else
#line 1121
    if ((int )*match != (int )*scan) {
#line 1124
      goto __Cont;
    } else {
#line 1121
      match ++;
#line 1121
      if ((int )*match != (int )*(scan + 1)) {
#line 1124
        goto __Cont;
      }
    }
#line 1132
    scan += 2;
#line 1132
    match ++;
    {
#line 1138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1138
      scan ++;
#line 1138
      match ++;
#line 1138
      if ((int )*scan == (int )*match) {
#line 1138
        scan ++;
#line 1138
        match ++;
#line 1138
        if ((int )*scan == (int )*match) {
#line 1138
          scan ++;
#line 1138
          match ++;
#line 1138
          if ((int )*scan == (int )*match) {
#line 1138
            scan ++;
#line 1138
            match ++;
#line 1138
            if ((int )*scan == (int )*match) {
#line 1138
              scan ++;
#line 1138
              match ++;
#line 1138
              if ((int )*scan == (int )*match) {
#line 1138
                scan ++;
#line 1138
                match ++;
#line 1138
                if ((int )*scan == (int )*match) {
#line 1138
                  scan ++;
#line 1138
                  match ++;
#line 1138
                  if ((int )*scan == (int )*match) {
#line 1138
                    scan ++;
#line 1138
                    match ++;
#line 1138
                    if ((int )*scan == (int )*match) {
#line 1138
                      if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 1138
                        goto while_break___0;
                      }
                    } else {
#line 1138
                      goto while_break___0;
                    }
                  } else {
#line 1138
                    goto while_break___0;
                  }
                } else {
#line 1138
                  goto while_break___0;
                }
              } else {
#line 1138
                goto while_break___0;
              }
            } else {
#line 1138
              goto while_break___0;
            }
          } else {
#line 1138
            goto while_break___0;
          }
        } else {
#line 1138
          goto while_break___0;
        }
      } else {
#line 1138
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1147
    len = 258 - (int )(strend - scan);
#line 1148
    scan = strend - 258;
#line 1152
    if (len > best_len) {
#line 1153
      s->match_start = cur_match;
#line 1154
      best_len = len;
#line 1155
      if (len >= nice_match) {
#line 1155
        goto while_break;
      }
#line 1159
      scan_end1 = *(scan + (best_len - 1));
#line 1160
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 1074
    cur_match = (IPos )*(prev + (cur_match & wmask));
#line 1074
    if (cur_match > limit) {
#line 1074
      chain_length --;
#line 1074
      if (! (chain_length != 0U)) {
#line 1074
        goto while_break;
      }
    } else {
#line 1074
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  if ((uInt )best_len <= s->lookahead) {
#line 1166
    return ((uInt )best_len);
  }
#line 1167
  return (s->lookahead);
}
}
#line 1175 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static uInt longest_match_fast(deflate_state___0 *s , IPos cur_match ) 
{ 
  register Bytef *scan ;
  register Bytef *match ;
  register int len ;
  register Bytef *strend ;
  uInt tmp ;

  {
#line 1179
  scan = s->window + s->strstart;
#line 1182
  strend = (s->window + s->strstart) + 258;
#line 1193
  match = s->window + cur_match;
#line 1197
  if ((int )*(match + 0) != (int )*(scan + 0)) {
#line 1197
    return ((uInt )2);
  } else
#line 1197
  if ((int )*(match + 1) != (int )*(scan + 1)) {
#line 1197
    return ((uInt )2);
  }
#line 1205
  scan += 2;
#line 1205
  match += 2;
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1211
    scan ++;
#line 1211
    match ++;
#line 1211
    if ((int )*scan == (int )*match) {
#line 1211
      scan ++;
#line 1211
      match ++;
#line 1211
      if ((int )*scan == (int )*match) {
#line 1211
        scan ++;
#line 1211
        match ++;
#line 1211
        if ((int )*scan == (int )*match) {
#line 1211
          scan ++;
#line 1211
          match ++;
#line 1211
          if ((int )*scan == (int )*match) {
#line 1211
            scan ++;
#line 1211
            match ++;
#line 1211
            if ((int )*scan == (int )*match) {
#line 1211
              scan ++;
#line 1211
              match ++;
#line 1211
              if ((int )*scan == (int )*match) {
#line 1211
                scan ++;
#line 1211
                match ++;
#line 1211
                if ((int )*scan == (int )*match) {
#line 1211
                  scan ++;
#line 1211
                  match ++;
#line 1211
                  if ((int )*scan == (int )*match) {
#line 1211
                    if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 1211
                      goto while_break;
                    }
                  } else {
#line 1211
                    goto while_break;
                  }
                } else {
#line 1211
                  goto while_break;
                }
              } else {
#line 1211
                goto while_break;
              }
            } else {
#line 1211
              goto while_break;
            }
          } else {
#line 1211
            goto while_break;
          }
        } else {
#line 1211
          goto while_break;
        }
      } else {
#line 1211
        goto while_break;
      }
    } else {
#line 1211
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1220
  len = 258 - (int )(strend - scan);
#line 1222
  if (len < 3) {
#line 1222
    return ((uInt )2);
  }
#line 1224
  s->match_start = cur_match;
#line 1225
  if ((uInt )len <= s->lookahead) {
#line 1225
    tmp = (uInt )len;
  } else {
#line 1225
    tmp = s->lookahead;
  }
#line 1225
  return (tmp);
}
}
#line 1266 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static void fill_window(deflate_state___0 *s ) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  register Posf *p ;
  unsigned int more ;
  uInt wsize ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 1272
  wsize = s->w_size;
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    more = (unsigned int )((s->window_size - (ulg )s->lookahead) - (ulg )s->strstart);
#line 1278
    if (sizeof(int ) <= 2UL) {
#line 1279
      if (more == 0U) {
#line 1279
        if (s->strstart == 0U) {
#line 1279
          if (s->lookahead == 0U) {
#line 1280
            more = wsize;
          } else {
#line 1279
            goto _L___0;
          }
        } else {
#line 1279
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1282
      if (more == 4294967295U) {
#line 1286
        more --;
      }
    }
#line 1293
    if (s->strstart >= wsize + (s->w_size - 262U)) {
      {
#line 1295
      memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)(s->window + wsize),
             (size_t )wsize);
#line 1296
      s->match_start -= wsize;
#line 1297
      s->strstart -= wsize;
#line 1298
      s->block_start -= (long )wsize;
#line 1307
      n = s->hash_size;
#line 1308
      p = s->head + n;
      }
      {
#line 1309
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1310
        p --;
#line 1310
        m = (unsigned int )*p;
#line 1311
        if (m >= wsize) {
#line 1311
          tmp = m - wsize;
        } else {
#line 1311
          tmp = 0U;
        }
#line 1311
        *p = (Pos )tmp;
#line 1309
        n --;
#line 1309
        if (! n) {
#line 1309
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1314
      n = wsize;
#line 1316
      p = s->prev + n;
      {
#line 1317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1318
        p --;
#line 1318
        m = (unsigned int )*p;
#line 1319
        if (m >= wsize) {
#line 1319
          tmp___0 = m - wsize;
        } else {
#line 1319
          tmp___0 = 0U;
        }
#line 1319
        *p = (Pos )tmp___0;
#line 1317
        n --;
#line 1317
        if (! n) {
#line 1317
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1325
      more += wsize;
    }
#line 1327
    if ((s->strm)->avail_in == 0U) {
#line 1327
      return;
    }
    {
#line 1342
    tmp___1 = read_buf(s->strm, (s->window + s->strstart) + s->lookahead, more);
#line 1342
    n = (unsigned int )tmp___1;
#line 1343
    s->lookahead += n;
    }
#line 1346
    if (s->lookahead >= 3U) {
#line 1347
      s->ins_h = (uInt )*(s->window + s->strstart);
#line 1348
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
    }
#line 1274
    if (s->lookahead < 262U) {
#line 1274
      if (! ((s->strm)->avail_in != 0U)) {
#line 1274
        goto while_break;
      }
    } else {
#line 1274
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1358
  return;
}
}
#line 1390 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static block_state deflate_stored(deflate_state___0 *s , int flush ) 
{ 
  ulg max_block_size ;
  ulg max_start ;
  charf *tmp ;
  charf *tmp___0 ;
  charf *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1397
  max_block_size = (ulg )65535;
#line 1400
  if (max_block_size > s->pending_buf_size - 5UL) {
#line 1401
    max_block_size = s->pending_buf_size - 5UL;
  }
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1407
    if (s->lookahead <= 1U) {
      {
#line 1412
      fill_window(s);
      }
#line 1413
      if (s->lookahead == 0U) {
#line 1413
        if (flush == 0) {
#line 1413
          return ((block_state )0);
        }
      }
#line 1415
      if (s->lookahead == 0U) {
#line 1415
        goto while_break;
      }
    }
#line 1419
    s->strstart += s->lookahead;
#line 1420
    s->lookahead = (uInt )0;
#line 1423
    max_start = (ulg )s->block_start + max_block_size;
#line 1424
    if (s->strstart == 0U) {
#line 1424
      goto _L;
    } else
#line 1424
    if ((ulg )s->strstart >= max_start) {
      _L: /* CIL Label */ 
#line 1426
      s->lookahead = (uInt )((ulg )s->strstart - max_start);
#line 1427
      s->strstart = (uInt )max_start;
#line 1428
      if (s->block_start >= 0L) {
#line 1428
        tmp = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1428
        tmp = (charf *)0;
      }
      {
#line 1428
      _tr_flush_block(s, tmp, (ulg )((long )s->strstart - s->block_start), 0);
#line 1428
      s->block_start = (long )s->strstart;
#line 1428
      flush_pending(s->strm);
      }
#line 1428
      if ((s->strm)->avail_out == 0U) {
#line 1428
        return ((block_state )0);
      }
    }
#line 1433
    if (s->strstart - (uInt )s->block_start >= s->w_size - 262U) {
#line 1434
      if (s->block_start >= 0L) {
#line 1434
        tmp___0 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1434
        tmp___0 = (charf *)0;
      }
      {
#line 1434
      _tr_flush_block(s, tmp___0, (ulg )((long )s->strstart - s->block_start), 0);
#line 1434
      s->block_start = (long )s->strstart;
#line 1434
      flush_pending(s->strm);
      }
#line 1434
      if ((s->strm)->avail_out == 0U) {
#line 1434
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1437
  if (s->block_start >= 0L) {
#line 1437
    tmp___1 = (charf *)(s->window + (unsigned int )s->block_start);
  } else {
#line 1437
    tmp___1 = (charf *)0;
  }
  {
#line 1437
  _tr_flush_block(s, tmp___1, (ulg )((long )s->strstart - s->block_start), flush == 4);
#line 1437
  s->block_start = (long )s->strstart;
#line 1437
  flush_pending(s->strm);
  }
#line 1437
  if ((s->strm)->avail_out == 0U) {
#line 1437
    if (flush == 4) {
#line 1437
      tmp___2 = 2;
    } else {
#line 1437
      tmp___2 = 0;
    }
#line 1437
    return ((block_state )tmp___2);
  }
#line 1438
  if (flush == 4) {
#line 1438
    tmp___3 = 3;
  } else {
#line 1438
    tmp___3 = 1;
  }
#line 1438
  return ((block_state )tmp___3);
}
}
#line 1448 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static block_state deflate_fast(deflate_state___0 *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int tmp___1 ;
  Posf tmp___2 ;
  uch cc ;
  uInt tmp___3 ;
  charf *tmp___4 ;
  charf *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1452
  hash_head = (IPos )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (s->lookahead < 262U) {
      {
#line 1462
      fill_window(s);
      }
#line 1463
      if (s->lookahead < 262U) {
#line 1463
        if (flush == 0) {
#line 1464
          return ((block_state )0);
        }
      }
#line 1466
      if (s->lookahead == 0U) {
#line 1466
        goto while_break;
      }
    }
#line 1472
    if (s->lookahead >= 3U) {
#line 1473
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1473
      tmp = *(s->head + s->ins_h);
#line 1473
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1473
      hash_head = (IPos )tmp;
#line 1473
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1479
    if (hash_head != 0U) {
#line 1479
      if (s->strstart - hash_head <= s->w_size - 262U) {
#line 1490
        if (s->strategy != 2) {
#line 1490
          if (s->strategy != 3) {
            {
#line 1491
            s->match_length = longest_match(s, hash_head);
            }
          } else {
#line 1490
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1492
        if (s->strategy == 3) {
#line 1492
          if (s->strstart - hash_head == 1U) {
            {
#line 1493
            s->match_length = longest_match_fast(s, hash_head);
            }
          }
        }
      }
    }
#line 1498
    if (s->match_length >= 3U) {
#line 1501
      len = (uch )(s->match_length - 3U);
#line 1501
      dist = (ush )(s->strstart - s->match_start);
#line 1501
      *(s->d_buf + s->last_lit) = dist;
#line 1501
      tmp___0 = s->last_lit;
#line 1501
      (s->last_lit) ++;
#line 1501
      *(s->l_buf + tmp___0) = len;
#line 1501
      dist = (ush )((int )dist - 1);
#line 1501
      s->dyn_ltree[((int const   )_length_code[len] + 256) + 1].fc.freq = (ush )((int )s->dyn_ltree[((int const   )_length_code[len] + 256) + 1].fc.freq + 1);
#line 1501
      if ((int )dist < 256) {
#line 1501
        tmp___1 = (int const   )_dist_code[dist];
      } else {
#line 1501
        tmp___1 = (int const   )_dist_code[256 + ((int )dist >> 7)];
      }
#line 1501
      s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1501
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1504
      s->lookahead -= s->match_length;
#line 1510
      if (s->match_length <= s->max_lazy_match) {
#line 1510
        if (s->lookahead >= 3U) {
#line 1512
          (s->match_length) --;
          {
#line 1513
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1514
            (s->strstart) ++;
#line 1515
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1515
            tmp___2 = *(s->head + s->ins_h);
#line 1515
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 1515
            hash_head = (IPos )tmp___2;
#line 1515
            *(s->head + s->ins_h) = (Pos )s->strstart;
#line 1513
            (s->match_length) --;
#line 1513
            if (! (s->match_length != 0U)) {
#line 1513
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1520
          (s->strstart) ++;
        } else {
#line 1524
          s->strstart += s->match_length;
#line 1525
          s->match_length = (uInt )0;
#line 1526
          s->ins_h = (uInt )*(s->window + s->strstart);
#line 1527
          s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
        }
      } else {
#line 1524
        s->strstart += s->match_length;
#line 1525
        s->match_length = (uInt )0;
#line 1526
        s->ins_h = (uInt )*(s->window + s->strstart);
#line 1527
        s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
      }
    } else {
#line 1538
      cc = *(s->window + s->strstart);
#line 1538
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1538
      tmp___3 = s->last_lit;
#line 1538
      (s->last_lit) ++;
#line 1538
      *(s->l_buf + tmp___3) = cc;
#line 1538
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1538
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1539
      (s->lookahead) --;
#line 1540
      (s->strstart) ++;
    }
#line 1542
    if (bflush) {
#line 1542
      if (s->block_start >= 0L) {
#line 1542
        tmp___4 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1542
        tmp___4 = (charf *)0;
      }
      {
#line 1542
      _tr_flush_block(s, tmp___4, (ulg )((long )s->strstart - s->block_start), 0);
#line 1542
      s->block_start = (long )s->strstart;
#line 1542
      flush_pending(s->strm);
      }
#line 1542
      if ((s->strm)->avail_out == 0U) {
#line 1542
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1544
  if (s->block_start >= 0L) {
#line 1544
    tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
  } else {
#line 1544
    tmp___5 = (charf *)0;
  }
  {
#line 1544
  _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), flush == 4);
#line 1544
  s->block_start = (long )s->strstart;
#line 1544
  flush_pending(s->strm);
  }
#line 1544
  if ((s->strm)->avail_out == 0U) {
#line 1544
    if (flush == 4) {
#line 1544
      tmp___6 = 2;
    } else {
#line 1544
      tmp___6 = 0;
    }
#line 1544
    return ((block_state )tmp___6);
  }
#line 1545
  if (flush == 4) {
#line 1545
    tmp___7 = 3;
  } else {
#line 1545
    tmp___7 = 1;
  }
#line 1545
  return ((block_state )tmp___7);
}
}
#line 1554 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/deflate.c"
static block_state deflate_slow(deflate_state___0 *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uInt max_insert ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int tmp___1 ;
  Posf tmp___2 ;
  charf *tmp___3 ;
  uch cc ;
  uInt tmp___4 ;
  charf *tmp___5 ;
  uch cc___0 ;
  uInt tmp___6 ;
  charf *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1558
  hash_head = (IPos )0;
  {
#line 1562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1568
    if (s->lookahead < 262U) {
      {
#line 1569
      fill_window(s);
      }
#line 1570
      if (s->lookahead < 262U) {
#line 1570
        if (flush == 0) {
#line 1571
          return ((block_state )0);
        }
      }
#line 1573
      if (s->lookahead == 0U) {
#line 1573
        goto while_break;
      }
    }
#line 1579
    if (s->lookahead >= 3U) {
#line 1580
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1580
      tmp = *(s->head + s->ins_h);
#line 1580
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1580
      hash_head = (IPos )tmp;
#line 1580
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1585
    s->prev_length = s->match_length;
#line 1585
    s->prev_match = s->match_start;
#line 1586
    s->match_length = (uInt )2;
#line 1588
    if (hash_head != 0U) {
#line 1588
      if (s->prev_length < s->max_lazy_match) {
#line 1588
        if (s->strstart - hash_head <= s->w_size - 262U) {
#line 1594
          if (s->strategy != 2) {
#line 1594
            if (s->strategy != 3) {
              {
#line 1595
              s->match_length = longest_match(s, hash_head);
              }
            } else {
#line 1594
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1596
          if (s->strategy == 3) {
#line 1596
            if (s->strstart - hash_head == 1U) {
              {
#line 1597
              s->match_length = longest_match_fast(s, hash_head);
              }
            }
          }
#line 1601
          if (s->match_length <= 5U) {
#line 1601
            if (s->strategy == 1) {
#line 1611
              s->match_length = (uInt )2;
            }
          }
        }
      }
    }
#line 1617
    if (s->prev_length >= 3U) {
#line 1617
      if (s->match_length <= s->prev_length) {
#line 1618
        max_insert = (s->strstart + s->lookahead) - 3U;
#line 1623
        len = (uch )(s->prev_length - 3U);
#line 1623
        dist = (ush )((s->strstart - 1U) - s->prev_match);
#line 1623
        *(s->d_buf + s->last_lit) = dist;
#line 1623
        tmp___0 = s->last_lit;
#line 1623
        (s->last_lit) ++;
#line 1623
        *(s->l_buf + tmp___0) = len;
#line 1623
        dist = (ush )((int )dist - 1);
#line 1623
        s->dyn_ltree[((int const   )_length_code[len] + 256) + 1].fc.freq = (ush )((int )s->dyn_ltree[((int const   )_length_code[len] + 256) + 1].fc.freq + 1);
#line 1623
        if ((int )dist < 256) {
#line 1623
          tmp___1 = (int const   )_dist_code[dist];
        } else {
#line 1623
          tmp___1 = (int const   )_dist_code[256 + ((int )dist >> 7)];
        }
#line 1623
        s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1623
        bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1631
        s->lookahead -= s->prev_length - 1U;
#line 1632
        s->prev_length -= 2U;
        {
#line 1633
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1634
          (s->strstart) ++;
#line 1634
          if (s->strstart <= max_insert) {
#line 1635
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1635
            tmp___2 = *(s->head + s->ins_h);
#line 1635
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 1635
            hash_head = (IPos )tmp___2;
#line 1635
            *(s->head + s->ins_h) = (Pos )s->strstart;
          }
#line 1633
          (s->prev_length) --;
#line 1633
          if (! (s->prev_length != 0U)) {
#line 1633
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1638
        s->match_available = 0;
#line 1639
        s->match_length = (uInt )2;
#line 1640
        (s->strstart) ++;
#line 1642
        if (bflush) {
#line 1642
          if (s->block_start >= 0L) {
#line 1642
            tmp___3 = (charf *)(s->window + (unsigned int )s->block_start);
          } else {
#line 1642
            tmp___3 = (charf *)0;
          }
          {
#line 1642
          _tr_flush_block(s, tmp___3, (ulg )((long )s->strstart - s->block_start),
                          0);
#line 1642
          s->block_start = (long )s->strstart;
#line 1642
          flush_pending(s->strm);
          }
#line 1642
          if ((s->strm)->avail_out == 0U) {
#line 1642
            return ((block_state )0);
          }
        }
      } else {
#line 1617
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1644
    if (s->match_available) {
#line 1650
      cc = *(s->window + (s->strstart - 1U));
#line 1650
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1650
      tmp___4 = s->last_lit;
#line 1650
      (s->last_lit) ++;
#line 1650
      *(s->l_buf + tmp___4) = cc;
#line 1650
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1650
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1651
      if (bflush) {
#line 1652
        if (s->block_start >= 0L) {
#line 1652
          tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
        } else {
#line 1652
          tmp___5 = (charf *)0;
        }
        {
#line 1652
        _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), 0);
#line 1652
        s->block_start = (long )s->strstart;
#line 1652
        flush_pending(s->strm);
        }
      }
#line 1654
      (s->strstart) ++;
#line 1655
      (s->lookahead) --;
#line 1656
      if ((s->strm)->avail_out == 0U) {
#line 1656
        return ((block_state )0);
      }
    } else {
#line 1661
      s->match_available = 1;
#line 1662
      (s->strstart) ++;
#line 1663
      (s->lookahead) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1667
  if (s->match_available) {
#line 1669
    cc___0 = *(s->window + (s->strstart - 1U));
#line 1669
    *(s->d_buf + s->last_lit) = (ushf )0;
#line 1669
    tmp___6 = s->last_lit;
#line 1669
    (s->last_lit) ++;
#line 1669
    *(s->l_buf + tmp___6) = cc___0;
#line 1669
    s->dyn_ltree[cc___0].fc.freq = (ush )((int )s->dyn_ltree[cc___0].fc.freq + 1);
#line 1669
    bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1670
    s->match_available = 0;
  }
#line 1672
  if (s->block_start >= 0L) {
#line 1672
    tmp___7 = (charf *)(s->window + (unsigned int )s->block_start);
  } else {
#line 1672
    tmp___7 = (charf *)0;
  }
  {
#line 1672
  _tr_flush_block(s, tmp___7, (ulg )((long )s->strstart - s->block_start), flush == 4);
#line 1672
  s->block_start = (long )s->strstart;
#line 1672
  flush_pending(s->strm);
  }
#line 1672
  if ((s->strm)->avail_out == 0U) {
#line 1672
    if (flush == 4) {
#line 1672
      tmp___8 = 2;
    } else {
#line 1672
      tmp___8 = 0;
    }
#line 1672
    return ((block_state )tmp___8);
  }
#line 1673
  if (flush == 4) {
#line 1673
    tmp___9 = 3;
  } else {
#line 1673
    tmp___9 = 1;
  }
#line 1673
  return ((block_state )tmp___9);
}
}
#line 1310 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) ;
#line 1360
unsigned long const   *get_crc_table(void) ;
#line 58 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf___1 ,
                                  unsigned int len ) ;
#line 60
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf___1 ,
                               unsigned int len ) ;
#line 68
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) ;
#line 70
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) ;
#line 5 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.h"
static unsigned long const   crc_table[8][256]  = 
#line 5 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.h"
  { {        (unsigned long const   )0UL,        (unsigned long const   )1996959894UL,        (unsigned long const   )3993919788UL,        (unsigned long const   )2567524794UL, 
            (unsigned long const   )124634137UL,        (unsigned long const   )1886057615UL,        (unsigned long const   )3915621685UL,        (unsigned long const   )2657392035UL, 
            (unsigned long const   )249268274UL,        (unsigned long const   )2044508324UL,        (unsigned long const   )3772115230UL,        (unsigned long const   )2547177864UL, 
            (unsigned long const   )162941995UL,        (unsigned long const   )2125561021UL,        (unsigned long const   )3887607047UL,        (unsigned long const   )2428444049UL, 
            (unsigned long const   )498536548UL,        (unsigned long const   )1789927666UL,        (unsigned long const   )4089016648UL,        (unsigned long const   )2227061214UL, 
            (unsigned long const   )450548861UL,        (unsigned long const   )1843258603UL,        (unsigned long const   )4107580753UL,        (unsigned long const   )2211677639UL, 
            (unsigned long const   )325883990UL,        (unsigned long const   )1684777152UL,        (unsigned long const   )4251122042UL,        (unsigned long const   )2321926636UL, 
            (unsigned long const   )335633487UL,        (unsigned long const   )1661365465UL,        (unsigned long const   )4195302755UL,        (unsigned long const   )2366115317UL, 
            (unsigned long const   )997073096UL,        (unsigned long const   )1281953886UL,        (unsigned long const   )3579855332UL,        (unsigned long const   )2724688242UL, 
            (unsigned long const   )1006888145UL,        (unsigned long const   )1258607687UL,        (unsigned long const   )3524101629UL,        (unsigned long const   )2768942443UL, 
            (unsigned long const   )901097722UL,        (unsigned long const   )1119000684UL,        (unsigned long const   )3686517206UL,        (unsigned long const   )2898065728UL, 
            (unsigned long const   )853044451UL,        (unsigned long const   )1172266101UL,        (unsigned long const   )3705015759UL,        (unsigned long const   )2882616665UL, 
            (unsigned long const   )651767980UL,        (unsigned long const   )1373503546UL,        (unsigned long const   )3369554304UL,        (unsigned long const   )3218104598UL, 
            (unsigned long const   )565507253UL,        (unsigned long const   )1454621731UL,        (unsigned long const   )3485111705UL,        (unsigned long const   )3099436303UL, 
            (unsigned long const   )671266974UL,        (unsigned long const   )1594198024UL,        (unsigned long const   )3322730930UL,        (unsigned long const   )2970347812UL, 
            (unsigned long const   )795835527UL,        (unsigned long const   )1483230225UL,        (unsigned long const   )3244367275UL,        (unsigned long const   )3060149565UL, 
            (unsigned long const   )1994146192UL,        (unsigned long const   )31158534UL,        (unsigned long const   )2563907772UL,        (unsigned long const   )4023717930UL, 
            (unsigned long const   )1907459465UL,        (unsigned long const   )112637215UL,        (unsigned long const   )2680153253UL,        (unsigned long const   )3904427059UL, 
            (unsigned long const   )2013776290UL,        (unsigned long const   )251722036UL,        (unsigned long const   )2517215374UL,        (unsigned long const   )3775830040UL, 
            (unsigned long const   )2137656763UL,        (unsigned long const   )141376813UL,        (unsigned long const   )2439277719UL,        (unsigned long const   )3865271297UL, 
            (unsigned long const   )1802195444UL,        (unsigned long const   )476864866UL,        (unsigned long const   )2238001368UL,        (unsigned long const   )4066508878UL, 
            (unsigned long const   )1812370925UL,        (unsigned long const   )453092731UL,        (unsigned long const   )2181625025UL,        (unsigned long const   )4111451223UL, 
            (unsigned long const   )1706088902UL,        (unsigned long const   )314042704UL,        (unsigned long const   )2344532202UL,        (unsigned long const   )4240017532UL, 
            (unsigned long const   )1658658271UL,        (unsigned long const   )366619977UL,        (unsigned long const   )2362670323UL,        (unsigned long const   )4224994405UL, 
            (unsigned long const   )1303535960UL,        (unsigned long const   )984961486UL,        (unsigned long const   )2747007092UL,        (unsigned long const   )3569037538UL, 
            (unsigned long const   )1256170817UL,        (unsigned long const   )1037604311UL,        (unsigned long const   )2765210733UL,        (unsigned long const   )3554079995UL, 
            (unsigned long const   )1131014506UL,        (unsigned long const   )879679996UL,        (unsigned long const   )2909243462UL,        (unsigned long const   )3663771856UL, 
            (unsigned long const   )1141124467UL,        (unsigned long const   )855842277UL,        (unsigned long const   )2852801631UL,        (unsigned long const   )3708648649UL, 
            (unsigned long const   )1342533948UL,        (unsigned long const   )654459306UL,        (unsigned long const   )3188396048UL,        (unsigned long const   )3373015174UL, 
            (unsigned long const   )1466479909UL,        (unsigned long const   )544179635UL,        (unsigned long const   )3110523913UL,        (unsigned long const   )3462522015UL, 
            (unsigned long const   )1591671054UL,        (unsigned long const   )702138776UL,        (unsigned long const   )2966460450UL,        (unsigned long const   )3352799412UL, 
            (unsigned long const   )1504918807UL,        (unsigned long const   )783551873UL,        (unsigned long const   )3082640443UL,        (unsigned long const   )3233442989UL, 
            (unsigned long const   )3988292384UL,        (unsigned long const   )2596254646UL,        (unsigned long const   )62317068UL,        (unsigned long const   )1957810842UL, 
            (unsigned long const   )3939845945UL,        (unsigned long const   )2647816111UL,        (unsigned long const   )81470997UL,        (unsigned long const   )1943803523UL, 
            (unsigned long const   )3814918930UL,        (unsigned long const   )2489596804UL,        (unsigned long const   )225274430UL,        (unsigned long const   )2053790376UL, 
            (unsigned long const   )3826175755UL,        (unsigned long const   )2466906013UL,        (unsigned long const   )167816743UL,        (unsigned long const   )2097651377UL, 
            (unsigned long const   )4027552580UL,        (unsigned long const   )2265490386UL,        (unsigned long const   )503444072UL,        (unsigned long const   )1762050814UL, 
            (unsigned long const   )4150417245UL,        (unsigned long const   )2154129355UL,        (unsigned long const   )426522225UL,        (unsigned long const   )1852507879UL, 
            (unsigned long const   )4275313526UL,        (unsigned long const   )2312317920UL,        (unsigned long const   )282753626UL,        (unsigned long const   )1742555852UL, 
            (unsigned long const   )4189708143UL,        (unsigned long const   )2394877945UL,        (unsigned long const   )397917763UL,        (unsigned long const   )1622183637UL, 
            (unsigned long const   )3604390888UL,        (unsigned long const   )2714866558UL,        (unsigned long const   )953729732UL,        (unsigned long const   )1340076626UL, 
            (unsigned long const   )3518719985UL,        (unsigned long const   )2797360999UL,        (unsigned long const   )1068828381UL,        (unsigned long const   )1219638859UL, 
            (unsigned long const   )3624741850UL,        (unsigned long const   )2936675148UL,        (unsigned long const   )906185462UL,        (unsigned long const   )1090812512UL, 
            (unsigned long const   )3747672003UL,        (unsigned long const   )2825379669UL,        (unsigned long const   )829329135UL,        (unsigned long const   )1181335161UL, 
            (unsigned long const   )3412177804UL,        (unsigned long const   )3160834842UL,        (unsigned long const   )628085408UL,        (unsigned long const   )1382605366UL, 
            (unsigned long const   )3423369109UL,        (unsigned long const   )3138078467UL,        (unsigned long const   )570562233UL,        (unsigned long const   )1426400815UL, 
            (unsigned long const   )3317316542UL,        (unsigned long const   )2998733608UL,        (unsigned long const   )733239954UL,        (unsigned long const   )1555261956UL, 
            (unsigned long const   )3268935591UL,        (unsigned long const   )3050360625UL,        (unsigned long const   )752459403UL,        (unsigned long const   )1541320221UL, 
            (unsigned long const   )2607071920UL,        (unsigned long const   )3965973030UL,        (unsigned long const   )1969922972UL,        (unsigned long const   )40735498UL, 
            (unsigned long const   )2617837225UL,        (unsigned long const   )3943577151UL,        (unsigned long const   )1913087877UL,        (unsigned long const   )83908371UL, 
            (unsigned long const   )2512341634UL,        (unsigned long const   )3803740692UL,        (unsigned long const   )2075208622UL,        (unsigned long const   )213261112UL, 
            (unsigned long const   )2463272603UL,        (unsigned long const   )3855990285UL,        (unsigned long const   )2094854071UL,        (unsigned long const   )198958881UL, 
            (unsigned long const   )2262029012UL,        (unsigned long const   )4057260610UL,        (unsigned long const   )1759359992UL,        (unsigned long const   )534414190UL, 
            (unsigned long const   )2176718541UL,        (unsigned long const   )4139329115UL,        (unsigned long const   )1873836001UL,        (unsigned long const   )414664567UL, 
            (unsigned long const   )2282248934UL,        (unsigned long const   )4279200368UL,        (unsigned long const   )1711684554UL,        (unsigned long const   )285281116UL, 
            (unsigned long const   )2405801727UL,        (unsigned long const   )4167216745UL,        (unsigned long const   )1634467795UL,        (unsigned long const   )376229701UL, 
            (unsigned long const   )2685067896UL,        (unsigned long const   )3608007406UL,        (unsigned long const   )1308918612UL,        (unsigned long const   )956543938UL, 
            (unsigned long const   )2808555105UL,        (unsigned long const   )3495958263UL,        (unsigned long const   )1231636301UL,        (unsigned long const   )1047427035UL, 
            (unsigned long const   )2932959818UL,        (unsigned long const   )3654703836UL,        (unsigned long const   )1088359270UL,        (unsigned long const   )936918000UL, 
            (unsigned long const   )2847714899UL,        (unsigned long const   )3736837829UL,        (unsigned long const   )1202900863UL,        (unsigned long const   )817233897UL, 
            (unsigned long const   )3183342108UL,        (unsigned long const   )3401237130UL,        (unsigned long const   )1404277552UL,        (unsigned long const   )615818150UL, 
            (unsigned long const   )3134207493UL,        (unsigned long const   )3453421203UL,        (unsigned long const   )1423857449UL,        (unsigned long const   )601450431UL, 
            (unsigned long const   )3009837614UL,        (unsigned long const   )3294710456UL,        (unsigned long const   )1567103746UL,        (unsigned long const   )711928724UL, 
            (unsigned long const   )3020668471UL,        (unsigned long const   )3272380065UL,        (unsigned long const   )1510334235UL,        (unsigned long const   )755167117UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )421212481UL,        (unsigned long const   )842424962UL,        (unsigned long const   )724390851UL, 
            (unsigned long const   )1684849924UL,        (unsigned long const   )2105013317UL,        (unsigned long const   )1448781702UL,        (unsigned long const   )1329698503UL, 
            (unsigned long const   )3369699848UL,        (unsigned long const   )3519200073UL,        (unsigned long const   )4210026634UL,        (unsigned long const   )3824474571UL, 
            (unsigned long const   )2897563404UL,        (unsigned long const   )3048111693UL,        (unsigned long const   )2659397006UL,        (unsigned long const   )2274893007UL, 
            (unsigned long const   )1254232657UL,        (unsigned long const   )1406739216UL,        (unsigned long const   )2029285587UL,        (unsigned long const   )1643069842UL, 
            (unsigned long const   )783210325UL,        (unsigned long const   )934667796UL,        (unsigned long const   )479770071UL,        (unsigned long const   )92505238UL, 
            (unsigned long const   )2182846553UL,        (unsigned long const   )2600511768UL,        (unsigned long const   )2955803355UL,        (unsigned long const   )2838940570UL, 
            (unsigned long const   )3866582365UL,        (unsigned long const   )4285295644UL,        (unsigned long const   )3561045983UL,        (unsigned long const   )3445231262UL, 
            (unsigned long const   )2508465314UL,        (unsigned long const   )2359236067UL,        (unsigned long const   )2813478432UL,        (unsigned long const   )3198777185UL, 
            (unsigned long const   )4058571174UL,        (unsigned long const   )3908292839UL,        (unsigned long const   )3286139684UL,        (unsigned long const   )3670389349UL, 
            (unsigned long const   )1566420650UL,        (unsigned long const   )1145479147UL,        (unsigned long const   )1869335592UL,        (unsigned long const   )1987116393UL, 
            (unsigned long const   )959540142UL,        (unsigned long const   )539646703UL,        (unsigned long const   )185010476UL,        (unsigned long const   )303839341UL, 
            (unsigned long const   )3745920755UL,        (unsigned long const   )3327985586UL,        (unsigned long const   )3983561841UL,        (unsigned long const   )4100678960UL, 
            (unsigned long const   )3140154359UL,        (unsigned long const   )2721170102UL,        (unsigned long const   )2300350837UL,        (unsigned long const   )2416418868UL, 
            (unsigned long const   )396344571UL,        (unsigned long const   )243568058UL,        (unsigned long const   )631889529UL,        (unsigned long const   )1018359608UL, 
            (unsigned long const   )1945336319UL,        (unsigned long const   )1793607870UL,        (unsigned long const   )1103436669UL,        (unsigned long const   )1490954812UL, 
            (unsigned long const   )4034481925UL,        (unsigned long const   )3915546180UL,        (unsigned long const   )3259968903UL,        (unsigned long const   )3679722694UL, 
            (unsigned long const   )2484439553UL,        (unsigned long const   )2366552896UL,        (unsigned long const   )2787371139UL,        (unsigned long const   )3208174018UL, 
            (unsigned long const   )950060301UL,        (unsigned long const   )565965900UL,        (unsigned long const   )177645455UL,        (unsigned long const   )328046286UL, 
            (unsigned long const   )1556873225UL,        (unsigned long const   )1171730760UL,        (unsigned long const   )1861902987UL,        (unsigned long const   )2011255754UL, 
            (unsigned long const   )3132841300UL,        (unsigned long const   )2745199637UL,        (unsigned long const   )2290958294UL,        (unsigned long const   )2442530455UL, 
            (unsigned long const   )3738671184UL,        (unsigned long const   )3352078609UL,        (unsigned long const   )3974232786UL,        (unsigned long const   )4126854035UL, 
            (unsigned long const   )1919080284UL,        (unsigned long const   )1803150877UL,        (unsigned long const   )1079293406UL,        (unsigned long const   )1498383519UL, 
            (unsigned long const   )370020952UL,        (unsigned long const   )253043481UL,        (unsigned long const   )607678682UL,        (unsigned long const   )1025720731UL, 
            (unsigned long const   )1711106983UL,        (unsigned long const   )2095471334UL,        (unsigned long const   )1472923941UL,        (unsigned long const   )1322268772UL, 
            (unsigned long const   )26324643UL,        (unsigned long const   )411738082UL,        (unsigned long const   )866634785UL,        (unsigned long const   )717028704UL, 
            (unsigned long const   )2904875439UL,        (unsigned long const   )3024081134UL,        (unsigned long const   )2668790573UL,        (unsigned long const   )2248782444UL, 
            (unsigned long const   )3376948395UL,        (unsigned long const   )3495106026UL,        (unsigned long const   )4219356713UL,        (unsigned long const   )3798300520UL, 
            (unsigned long const   )792689142UL,        (unsigned long const   )908347575UL,        (unsigned long const   )487136116UL,        (unsigned long const   )68299317UL, 
            (unsigned long const   )1263779058UL,        (unsigned long const   )1380486579UL,        (unsigned long const   )2036719216UL,        (unsigned long const   )1618931505UL, 
            (unsigned long const   )3890672638UL,        (unsigned long const   )4278043327UL,        (unsigned long const   )3587215740UL,        (unsigned long const   )3435896893UL, 
            (unsigned long const   )2206873338UL,        (unsigned long const   )2593195963UL,        (unsigned long const   )2981909624UL,        (unsigned long const   )2829542713UL, 
            (unsigned long const   )998479947UL,        (unsigned long const   )580430090UL,        (unsigned long const   )162921161UL,        (unsigned long const   )279890824UL, 
            (unsigned long const   )1609522511UL,        (unsigned long const   )1190423566UL,        (unsigned long const   )1842954189UL,        (unsigned long const   )1958874764UL, 
            (unsigned long const   )4082766403UL,        (unsigned long const   )3930137346UL,        (unsigned long const   )3245109441UL,        (unsigned long const   )3631694208UL, 
            (unsigned long const   )2536953671UL,        (unsigned long const   )2385372678UL,        (unsigned long const   )2768287173UL,        (unsigned long const   )3155920004UL, 
            (unsigned long const   )1900120602UL,        (unsigned long const   )1750776667UL,        (unsigned long const   )1131931800UL,        (unsigned long const   )1517083097UL, 
            (unsigned long const   )355290910UL,        (unsigned long const   )204897887UL,        (unsigned long const   )656092572UL,        (unsigned long const   )1040194781UL, 
            (unsigned long const   )3113746450UL,        (unsigned long const   )2692952403UL,        (unsigned long const   )2343461520UL,        (unsigned long const   )2461357009UL, 
            (unsigned long const   )3723805974UL,        (unsigned long const   )3304059991UL,        (unsigned long const   )4022511508UL,        (unsigned long const   )4141455061UL, 
            (unsigned long const   )2919742697UL,        (unsigned long const   )3072101800UL,        (unsigned long const   )2620513899UL,        (unsigned long const   )2234183466UL, 
            (unsigned long const   )3396041197UL,        (unsigned long const   )3547351212UL,        (unsigned long const   )4166851439UL,        (unsigned long const   )3779471918UL, 
            (unsigned long const   )1725839073UL,        (unsigned long const   )2143618976UL,        (unsigned long const   )1424512099UL,        (unsigned long const   )1307796770UL, 
            (unsigned long const   )45282277UL,        (unsigned long const   )464110244UL,        (unsigned long const   )813994343UL,        (unsigned long const   )698327078UL, 
            (unsigned long const   )3838160568UL,        (unsigned long const   )4259225593UL,        (unsigned long const   )3606301754UL,        (unsigned long const   )3488152955UL, 
            (unsigned long const   )2158586812UL,        (unsigned long const   )2578602749UL,        (unsigned long const   )2996767038UL,        (unsigned long const   )2877569151UL, 
            (unsigned long const   )740041904UL,        (unsigned long const   )889656817UL,        (unsigned long const   )506086962UL,        (unsigned long const   )120682355UL, 
            (unsigned long const   )1215357364UL,        (unsigned long const   )1366020341UL,        (unsigned long const   )2051441462UL,        (unsigned long const   )1667084919UL, 
            (unsigned long const   )3422213966UL,        (unsigned long const   )3538019855UL,        (unsigned long const   )4190942668UL,        (unsigned long const   )3772220557UL, 
            (unsigned long const   )2945847882UL,        (unsigned long const   )3062702859UL,        (unsigned long const   )2644537544UL,        (unsigned long const   )2226864521UL, 
            (unsigned long const   )52649286UL,        (unsigned long const   )439905287UL,        (unsigned long const   )823476164UL,        (unsigned long const   )672009861UL, 
            (unsigned long const   )1733269570UL,        (unsigned long const   )2119477507UL,        (unsigned long const   )1434057408UL,        (unsigned long const   )1281543041UL, 
            (unsigned long const   )2167981343UL,        (unsigned long const   )2552493150UL,        (unsigned long const   )3004082077UL,        (unsigned long const   )2853541596UL, 
            (unsigned long const   )3847487515UL,        (unsigned long const   )4233048410UL,        (unsigned long const   )3613549209UL,        (unsigned long const   )3464057816UL, 
            (unsigned long const   )1239502615UL,        (unsigned long const   )1358593622UL,        (unsigned long const   )2077699477UL,        (unsigned long const   )1657543892UL, 
            (unsigned long const   )764250643UL,        (unsigned long const   )882293586UL,        (unsigned long const   )532408465UL,        (unsigned long const   )111204816UL, 
            (unsigned long const   )1585378284UL,        (unsigned long const   )1197851309UL,        (unsigned long const   )1816695150UL,        (unsigned long const   )1968414767UL, 
            (unsigned long const   )974272232UL,        (unsigned long const   )587794345UL,        (unsigned long const   )136598634UL,        (unsigned long const   )289367339UL, 
            (unsigned long const   )2527558116UL,        (unsigned long const   )2411481253UL,        (unsigned long const   )2760973158UL,        (unsigned long const   )3179948583UL, 
            (unsigned long const   )4073438432UL,        (unsigned long const   )3956313505UL,        (unsigned long const   )3237863010UL,        (unsigned long const   )3655790371UL, 
            (unsigned long const   )347922877UL,        (unsigned long const   )229101820UL,        (unsigned long const   )646611775UL,        (unsigned long const   )1066513022UL, 
            (unsigned long const   )1892689081UL,        (unsigned long const   )1774917112UL,        (unsigned long const   )1122387515UL,        (unsigned long const   )1543337850UL, 
            (unsigned long const   )3697634229UL,        (unsigned long const   )3313392372UL,        (unsigned long const   )3998419255UL,        (unsigned long const   )4148705398UL, 
            (unsigned long const   )3087642289UL,        (unsigned long const   )2702352368UL,        (unsigned long const   )2319436851UL,        (unsigned long const   )2468674930UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )29518391UL,        (unsigned long const   )59036782UL,        (unsigned long const   )38190681UL, 
            (unsigned long const   )118073564UL,        (unsigned long const   )114017003UL,        (unsigned long const   )76381362UL,        (unsigned long const   )89069189UL, 
            (unsigned long const   )236147128UL,        (unsigned long const   )265370511UL,        (unsigned long const   )228034006UL,        (unsigned long const   )206958561UL, 
            (unsigned long const   )152762724UL,        (unsigned long const   )148411219UL,        (unsigned long const   )178138378UL,        (unsigned long const   )190596925UL, 
            (unsigned long const   )472294256UL,        (unsigned long const   )501532999UL,        (unsigned long const   )530741022UL,        (unsigned long const   )509615401UL, 
            (unsigned long const   )456068012UL,        (unsigned long const   )451764635UL,        (unsigned long const   )413917122UL,        (unsigned long const   )426358261UL, 
            (unsigned long const   )305525448UL,        (unsigned long const   )334993663UL,        (unsigned long const   )296822438UL,        (unsigned long const   )275991697UL, 
            (unsigned long const   )356276756UL,        (unsigned long const   )352202787UL,        (unsigned long const   )381193850UL,        (unsigned long const   )393929805UL, 
            (unsigned long const   )944588512UL,        (unsigned long const   )965684439UL,        (unsigned long const   )1003065998UL,        (unsigned long const   )973863097UL, 
            (unsigned long const   )1061482044UL,        (unsigned long const   )1049003019UL,        (unsigned long const   )1019230802UL,        (unsigned long const   )1023561829UL, 
            (unsigned long const   )912136024UL,        (unsigned long const   )933002607UL,        (unsigned long const   )903529270UL,        (unsigned long const   )874031361UL, 
            (unsigned long const   )827834244UL,        (unsigned long const   )815125939UL,        (unsigned long const   )852716522UL,        (unsigned long const   )856752605UL, 
            (unsigned long const   )611050896UL,        (unsigned long const   )631869351UL,        (unsigned long const   )669987326UL,        (unsigned long const   )640506825UL, 
            (unsigned long const   )593644876UL,        (unsigned long const   )580921211UL,        (unsigned long const   )551983394UL,        (unsigned long const   )556069653UL, 
            (unsigned long const   )712553512UL,        (unsigned long const   )733666847UL,        (unsigned long const   )704405574UL,        (unsigned long const   )675154545UL, 
            (unsigned long const   )762387700UL,        (unsigned long const   )749958851UL,        (unsigned long const   )787859610UL,        (unsigned long const   )792175277UL, 
            (unsigned long const   )1889177024UL,        (unsigned long const   )1901651959UL,        (unsigned long const   )1931368878UL,        (unsigned long const   )1927033753UL, 
            (unsigned long const   )2006131996UL,        (unsigned long const   )1985040171UL,        (unsigned long const   )1947726194UL,        (unsigned long const   )1976933189UL, 
            (unsigned long const   )2122964088UL,        (unsigned long const   )2135668303UL,        (unsigned long const   )2098006038UL,        (unsigned long const   )2093965857UL, 
            (unsigned long const   )2038461604UL,        (unsigned long const   )2017599123UL,        (unsigned long const   )2047123658UL,        (unsigned long const   )2076625661UL, 
            (unsigned long const   )1824272048UL,        (unsigned long const   )1836991623UL,        (unsigned long const   )1866005214UL,        (unsigned long const   )1861914857UL, 
            (unsigned long const   )1807058540UL,        (unsigned long const   )1786244187UL,        (unsigned long const   )1748062722UL,        (unsigned long const   )1777547317UL, 
            (unsigned long const   )1655668488UL,        (unsigned long const   )1668093247UL,        (unsigned long const   )1630251878UL,        (unsigned long const   )1625932113UL, 
            (unsigned long const   )1705433044UL,        (unsigned long const   )1684323811UL,        (unsigned long const   )1713505210UL,        (unsigned long const   )1742760333UL, 
            (unsigned long const   )1222101792UL,        (unsigned long const   )1226154263UL,        (unsigned long const   )1263738702UL,        (unsigned long const   )1251046777UL, 
            (unsigned long const   )1339974652UL,        (unsigned long const   )1310460363UL,        (unsigned long const   )1281013650UL,        (unsigned long const   )1301863845UL, 
            (unsigned long const   )1187289752UL,        (unsigned long const   )1191637167UL,        (unsigned long const   )1161842422UL,        (unsigned long const   )1149379777UL, 
            (unsigned long const   )1103966788UL,        (unsigned long const   )1074747507UL,        (unsigned long const   )1112139306UL,        (unsigned long const   )1133218845UL, 
            (unsigned long const   )1425107024UL,        (unsigned long const   )1429406311UL,        (unsigned long const   )1467333694UL,        (unsigned long const   )1454888457UL, 
            (unsigned long const   )1408811148UL,        (unsigned long const   )1379576507UL,        (unsigned long const   )1350309090UL,        (unsigned long const   )1371438805UL, 
            (unsigned long const   )1524775400UL,        (unsigned long const   )1528845279UL,        (unsigned long const   )1499917702UL,        (unsigned long const   )1487177649UL, 
            (unsigned long const   )1575719220UL,        (unsigned long const   )1546255107UL,        (unsigned long const   )1584350554UL,        (unsigned long const   )1605185389UL, 
            (unsigned long const   )3778354048UL,        (unsigned long const   )3774312887UL,        (unsigned long const   )3803303918UL,        (unsigned long const   )3816007129UL, 
            (unsigned long const   )3862737756UL,        (unsigned long const   )3892238699UL,        (unsigned long const   )3854067506UL,        (unsigned long const   )3833203973UL, 
            (unsigned long const   )4012263992UL,        (unsigned long const   )4007927823UL,        (unsigned long const   )3970080342UL,        (unsigned long const   )3982554209UL, 
            (unsigned long const   )3895452388UL,        (unsigned long const   )3924658387UL,        (unsigned long const   )3953866378UL,        (unsigned long const   )3932773565UL, 
            (unsigned long const   )4245928176UL,        (unsigned long const   )4241609415UL,        (unsigned long const   )4271336606UL,        (unsigned long const   )4283762345UL, 
            (unsigned long const   )4196012076UL,        (unsigned long const   )4225268251UL,        (unsigned long const   )4187931714UL,        (unsigned long const   )4166823541UL, 
            (unsigned long const   )4076923208UL,        (unsigned long const   )4072833919UL,        (unsigned long const   )4035198246UL,        (unsigned long const   )4047918865UL, 
            (unsigned long const   )4094247316UL,        (unsigned long const   )4123732899UL,        (unsigned long const   )4153251322UL,        (unsigned long const   )4132437965UL, 
            (unsigned long const   )3648544096UL,        (unsigned long const   )3636082519UL,        (unsigned long const   )3673983246UL,        (unsigned long const   )3678331705UL, 
            (unsigned long const   )3732010428UL,        (unsigned long const   )3753090955UL,        (unsigned long const   )3723829714UL,        (unsigned long const   )3694611429UL, 
            (unsigned long const   )3614117080UL,        (unsigned long const   )3601426159UL,        (unsigned long const   )3572488374UL,        (unsigned long const   )3576541825UL, 
            (unsigned long const   )3496125444UL,        (unsigned long const   )3516976691UL,        (unsigned long const   )3555094634UL,        (unsigned long const   )3525581405UL, 
            (unsigned long const   )3311336976UL,        (unsigned long const   )3298595879UL,        (unsigned long const   )3336186494UL,        (unsigned long const   )3340255305UL, 
            (unsigned long const   )3260503756UL,        (unsigned long const   )3281337595UL,        (unsigned long const   )3251864226UL,        (unsigned long const   )3222399125UL, 
            (unsigned long const   )3410866088UL,        (unsigned long const   )3398419871UL,        (unsigned long const   )3368647622UL,        (unsigned long const   )3372945905UL, 
            (unsigned long const   )3427010420UL,        (unsigned long const   )3448139075UL,        (unsigned long const   )3485520666UL,        (unsigned long const   )3456284973UL, 
            (unsigned long const   )2444203584UL,        (unsigned long const   )2423127159UL,        (unsigned long const   )2452308526UL,        (unsigned long const   )2481530905UL, 
            (unsigned long const   )2527477404UL,        (unsigned long const   )2539934891UL,        (unsigned long const   )2502093554UL,        (unsigned long const   )2497740997UL, 
            (unsigned long const   )2679949304UL,        (unsigned long const   )2659102159UL,        (unsigned long const   )2620920726UL,        (unsigned long const   )2650438049UL, 
            (unsigned long const   )2562027300UL,        (unsigned long const   )2574714131UL,        (unsigned long const   )2603727690UL,        (unsigned long const   )2599670141UL, 
            (unsigned long const   )2374579504UL,        (unsigned long const   )2353749767UL,        (unsigned long const   )2383274334UL,        (unsigned long const   )2412743529UL, 
            (unsigned long const   )2323684844UL,        (unsigned long const   )2336421851UL,        (unsigned long const   )2298759554UL,        (unsigned long const   )2294686645UL, 
            (unsigned long const   )2207933576UL,        (unsigned long const   )2186809023UL,        (unsigned long const   )2149495014UL,        (unsigned long const   )2178734801UL, 
            (unsigned long const   )2224278612UL,        (unsigned long const   )2236720739UL,        (unsigned long const   )2266437690UL,        (unsigned long const   )2262135309UL, 
            (unsigned long const   )2850214048UL,        (unsigned long const   )2820717207UL,        (unsigned long const   )2858812622UL,        (unsigned long const   )2879680249UL, 
            (unsigned long const   )2934667388UL,        (unsigned long const   )2938704459UL,        (unsigned long const   )2909776914UL,        (unsigned long const   )2897069605UL, 
            (unsigned long const   )2817622296UL,        (unsigned long const   )2788420399UL,        (unsigned long const   )2759153014UL,        (unsigned long const   )2780249921UL, 
            (unsigned long const   )2700618180UL,        (unsigned long const   )2704950259UL,        (unsigned long const   )2742877610UL,        (unsigned long const   )2730399645UL, 
            (unsigned long const   )3049550800UL,        (unsigned long const   )3020298727UL,        (unsigned long const   )3057690558UL,        (unsigned long const   )3078802825UL, 
            (unsigned long const   )2999835404UL,        (unsigned long const   )3004150075UL,        (unsigned long const   )2974355298UL,        (unsigned long const   )2961925461UL, 
            (unsigned long const   )3151438440UL,        (unsigned long const   )3121956959UL,        (unsigned long const   )3092510214UL,        (unsigned long const   )3113327665UL, 
            (unsigned long const   )3168701108UL,        (unsigned long const   )3172786307UL,        (unsigned long const   )3210370778UL,        (unsigned long const   )3197646061UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )3099354981UL,        (unsigned long const   )2852767883UL,        (unsigned long const   )313896942UL, 
            (unsigned long const   )2405603159UL,        (unsigned long const   )937357362UL,        (unsigned long const   )627793884UL,        (unsigned long const   )2648127673UL, 
            (unsigned long const   )3316918511UL,        (unsigned long const   )2097696650UL,        (unsigned long const   )1874714724UL,        (unsigned long const   )3607201537UL, 
            (unsigned long const   )1255587768UL,        (unsigned long const   )4067088605UL,        (unsigned long const   )3772741427UL,        (unsigned long const   )1482887254UL, 
            (unsigned long const   )1343838111UL,        (unsigned long const   )3903140090UL,        (unsigned long const   )4195393300UL,        (unsigned long const   )1118632049UL, 
            (unsigned long const   )3749429448UL,        (unsigned long const   )1741137837UL,        (unsigned long const   )1970407491UL,        (unsigned long const   )3452858150UL, 
            (unsigned long const   )2511175536UL,        (unsigned long const   )756094997UL,        (unsigned long const   )1067759611UL,        (unsigned long const   )2266550430UL, 
            (unsigned long const   )449832999UL,        (unsigned long const   )2725482306UL,        (unsigned long const   )2965774508UL,        (unsigned long const   )142231497UL, 
            (unsigned long const   )2687676222UL,        (unsigned long const   )412010587UL,        (unsigned long const   )171665333UL,        (unsigned long const   )2995192016UL, 
            (unsigned long const   )793786473UL,        (unsigned long const   )2548850444UL,        (unsigned long const   )2237264098UL,        (unsigned long const   )1038456711UL, 
            (unsigned long const   )1703315409UL,        (unsigned long const   )3711623348UL,        (unsigned long const   )3482275674UL,        (unsigned long const   )1999841343UL, 
            (unsigned long const   )3940814982UL,        (unsigned long const   )1381529571UL,        (unsigned long const   )1089329165UL,        (unsigned long const   )4166106984UL, 
            (unsigned long const   )4029413537UL,        (unsigned long const   )1217896388UL,        (unsigned long const   )1512189994UL,        (unsigned long const   )3802027855UL, 
            (unsigned long const   )2135519222UL,        (unsigned long const   )3354724499UL,        (unsigned long const   )3577784189UL,        (unsigned long const   )1845280792UL, 
            (unsigned long const   )899665998UL,        (unsigned long const   )2367928107UL,        (unsigned long const   )2677414085UL,        (unsigned long const   )657096608UL, 
            (unsigned long const   )3137160985UL,        (unsigned long const   )37822588UL,        (unsigned long const   )284462994UL,        (unsigned long const   )2823350519UL, 
            (unsigned long const   )2601801789UL,        (unsigned long const   )598228824UL,        (unsigned long const   )824021174UL,        (unsigned long const   )2309093331UL, 
            (unsigned long const   )343330666UL,        (unsigned long const   )2898962447UL,        (unsigned long const   )3195996129UL,        (unsigned long const   )113467524UL, 
            (unsigned long const   )1587572946UL,        (unsigned long const   )3860600759UL,        (unsigned long const   )4104763481UL,        (unsigned long const   )1276501820UL, 
            (unsigned long const   )3519211397UL,        (unsigned long const   )1769898208UL,        (unsigned long const   )2076913422UL,        (unsigned long const   )3279374443UL, 
            (unsigned long const   )3406630818UL,        (unsigned long const   )1941006535UL,        (unsigned long const   )1627703081UL,        (unsigned long const   )3652755532UL, 
            (unsigned long const   )1148164341UL,        (unsigned long const   )4241751952UL,        (unsigned long const   )3999682686UL,        (unsigned long const   )1457141531UL, 
            (unsigned long const   )247015245UL,        (unsigned long const   )3053797416UL,        (unsigned long const   )2763059142UL,        (unsigned long const   )470583459UL, 
            (unsigned long const   )2178658330UL,        (unsigned long const   )963106687UL,        (unsigned long const   )735213713UL,        (unsigned long const   )2473467892UL, 
            (unsigned long const   )992409347UL,        (unsigned long const   )2207944806UL,        (unsigned long const   )2435792776UL,        (unsigned long const   )697522413UL, 
            (unsigned long const   )3024379988UL,        (unsigned long const   )217581361UL,        (unsigned long const   )508405983UL,        (unsigned long const   )2800865210UL, 
            (unsigned long const   )4271038444UL,        (unsigned long const   )1177467017UL,        (unsigned long const   )1419450215UL,        (unsigned long const   )3962007554UL, 
            (unsigned long const   )1911572667UL,        (unsigned long const   )3377213406UL,        (unsigned long const   )3690561584UL,        (unsigned long const   )1665525589UL, 
            (unsigned long const   )1799331996UL,        (unsigned long const   )3548628985UL,        (unsigned long const   )3241568279UL,        (unsigned long const   )2039091058UL, 
            (unsigned long const   )3831314379UL,        (unsigned long const   )1558270126UL,        (unsigned long const   )1314193216UL,        (unsigned long const   )4142438437UL, 
            (unsigned long const   )2928380019UL,        (unsigned long const   )372764438UL,        (unsigned long const   )75645176UL,        (unsigned long const   )3158189981UL, 
            (unsigned long const   )568925988UL,        (unsigned long const   )2572515393UL,        (unsigned long const   )2346768303UL,        (unsigned long const   )861712586UL, 
            (unsigned long const   )3982079547UL,        (unsigned long const   )1441124702UL,        (unsigned long const   )1196457648UL,        (unsigned long const   )4293663189UL, 
            (unsigned long const   )1648042348UL,        (unsigned long const   )3666298377UL,        (unsigned long const   )3358779879UL,        (unsigned long const   )1888390786UL, 
            (unsigned long const   )686661332UL,        (unsigned long const   )2421291441UL,        (unsigned long const   )2196002399UL,        (unsigned long const   )978858298UL, 
            (unsigned long const   )2811169155UL,        (unsigned long const   )523464422UL,        (unsigned long const   )226935048UL,        (unsigned long const   )3040519789UL, 
            (unsigned long const   )3175145892UL,        (unsigned long const   )100435649UL,        (unsigned long const   )390670639UL,        (unsigned long const   )2952089162UL, 
            (unsigned long const   )841119475UL,        (unsigned long const   )2325614998UL,        (unsigned long const   )2553003640UL,        (unsigned long const   )546822429UL, 
            (unsigned long const   )2029308235UL,        (unsigned long const   )3225988654UL,        (unsigned long const   )3539796416UL,        (unsigned long const   )1782671013UL, 
            (unsigned long const   )4153826844UL,        (unsigned long const   )1328167289UL,        (unsigned long const   )1570739863UL,        (unsigned long const   )3844338162UL, 
            (unsigned long const   )1298864389UL,        (unsigned long const   )4124540512UL,        (unsigned long const   )3882013070UL,        (unsigned long const   )1608431339UL, 
            (unsigned long const   )3255406162UL,        (unsigned long const   )2058742071UL,        (unsigned long const   )1744848601UL,        (unsigned long const   )3501990332UL, 
            (unsigned long const   )2296328682UL,        (unsigned long const   )811816591UL,        (unsigned long const   )584513889UL,        (unsigned long const   )2590678532UL, 
            (unsigned long const   )129869501UL,        (unsigned long const   )3204563416UL,        (unsigned long const   )2914283062UL,        (unsigned long const   )352848211UL, 
            (unsigned long const   )494030490UL,        (unsigned long const   )2781751807UL,        (unsigned long const   )3078325777UL,        (unsigned long const   )264757620UL, 
            (unsigned long const   )2450577869UL,        (unsigned long const   )715964072UL,        (unsigned long const   )941166918UL,        (unsigned long const   )2158327331UL, 
            (unsigned long const   )3636881013UL,        (unsigned long const   )1618608400UL,        (unsigned long const   )1926213374UL,        (unsigned long const   )3396585883UL, 
            (unsigned long const   )1470427426UL,        (unsigned long const   )4011365959UL,        (unsigned long const   )4255988137UL,        (unsigned long const   )1158766284UL, 
            (unsigned long const   )1984818694UL,        (unsigned long const   )3471935843UL,        (unsigned long const   )3695453837UL,        (unsigned long const   )1693991400UL, 
            (unsigned long const   )4180638033UL,        (unsigned long const   )1100160564UL,        (unsigned long const   )1395044826UL,        (unsigned long const   )3952793279UL, 
            (unsigned long const   )3019491049UL,        (unsigned long const   )189112716UL,        (unsigned long const   )435162722UL,        (unsigned long const   )2706139399UL, 
            (unsigned long const   )1016811966UL,        (unsigned long const   )2217162459UL,        (unsigned long const   )2526189877UL,        (unsigned long const   )774831696UL, 
            (unsigned long const   )643086745UL,        (unsigned long const   )2666061564UL,        (unsigned long const   )2354934034UL,        (unsigned long const   )887166583UL, 
            (unsigned long const   )2838900430UL,        (unsigned long const   )294275499UL,        (unsigned long const   )54519365UL,        (unsigned long const   )3145957664UL, 
            (unsigned long const   )3823145334UL,        (unsigned long const   )1532818963UL,        (unsigned long const   )1240029693UL,        (unsigned long const   )4048895640UL, 
            (unsigned long const   )1820460577UL,        (unsigned long const   )3560857924UL,        (unsigned long const   )3331051178UL,        (unsigned long const   )2117577167UL, 
            (unsigned long const   )3598663992UL,        (unsigned long const   )1858283101UL,        (unsigned long const   )2088143283UL,        (unsigned long const   )3301633750UL, 
            (unsigned long const   )1495127663UL,        (unsigned long const   )3785470218UL,        (unsigned long const   )4078182116UL,        (unsigned long const   )1269332353UL, 
            (unsigned long const   )332098007UL,        (unsigned long const   )2876706482UL,        (unsigned long const   )3116540252UL,        (unsigned long const   )25085497UL, 
            (unsigned long const   )2628386432UL,        (unsigned long const   )605395429UL,        (unsigned long const   )916469259UL,        (unsigned long const   )2384220526UL, 
            (unsigned long const   )2254837415UL,        (unsigned long const   )1054503362UL,        (unsigned long const   )745528876UL,        (unsigned long const   )2496903497UL, 
            (unsigned long const   )151290352UL,        (unsigned long const   )2981684885UL,        (unsigned long const   )2735556987UL,        (unsigned long const   )464596510UL, 
            (unsigned long const   )1137851976UL,        (unsigned long const   )4218313005UL,        (unsigned long const   )3923506883UL,        (unsigned long const   )1365741990UL, 
            (unsigned long const   )3434129695UL,        (unsigned long const   )1946996346UL,        (unsigned long const   )1723425172UL,        (unsigned long const   )3724871409UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )2519730039UL,        (unsigned long const   )744558318UL,        (unsigned long const   )3125873049UL, 
            (unsigned long const   )432303367UL,        (unsigned long const   )2415159920UL,        (unsigned long const   )900031465UL,        (unsigned long const   )2744476830UL, 
            (unsigned long const   )847829774UL,        (unsigned long const   )2763578489UL,        (unsigned long const   )518641120UL,        (unsigned long const   )2295976599UL, 
            (unsigned long const   )726447625UL,        (unsigned long const   )3179065726UL,        (unsigned long const   )120436967UL,        (unsigned long const   )2434645904UL, 
            (unsigned long const   )1678817053UL,        (unsigned long const   )4062228586UL,        (unsigned long const   )1215412723UL,        (unsigned long const   )3728850564UL, 
            (unsigned long const   )2111101466UL,        (unsigned long const   )3957644653UL,        (unsigned long const   )1370871028UL,        (unsigned long const   )3347436419UL, 
            (unsigned long const   )1452829715UL,        (unsigned long const   )3232263012UL,        (unsigned long const   )2063164157UL,        (unsigned long const   )3972621706UL, 
            (unsigned long const   )1331429652UL,        (unsigned long const   )3647735395UL,        (unsigned long const   )1664946170UL,        (unsigned long const   )4111272077UL, 
            (unsigned long const   )3357568571UL,        (unsigned long const   )1578133836UL,        (unsigned long const   )3829489877UL,        (unsigned long const   )1920034722UL, 
            (unsigned long const   )3521381180UL,        (unsigned long const   )1205077067UL,        (unsigned long const   )4253355474UL,        (unsigned long const   )1807026853UL, 
            (unsigned long const   )4205360437UL,        (unsigned long const   )1821946434UL,        (unsigned long const   )3603545051UL,        (unsigned long const   )1090108588UL, 
            (unsigned long const   )3815561266UL,        (unsigned long const   )1969020741UL,        (unsigned long const   )3473790684UL,        (unsigned long const   )1497223595UL, 
            (unsigned long const   )2888882470UL,        (unsigned long const   )973135441UL,        (unsigned long const   )2152847304UL,        (unsigned long const   )375509183UL, 
            (unsigned long const   )3052712993UL,        (unsigned long const   )600093526UL,        (unsigned long const   )2576726735UL,        (unsigned long const   )262520248UL, 
            (unsigned long const   )2662859304UL,        (unsigned long const   )143131999UL,        (unsigned long const   )3000569030UL,        (unsigned long const   )619252657UL, 
            (unsigned long const   )2273079087UL,        (unsigned long const   )290220120UL,        (unsigned long const   )2870829505UL,        (unsigned long const   )1026385590UL, 
            (unsigned long const   )2420235382UL,        (unsigned long const   )108124929UL,        (unsigned long const   )3156267672UL,        (unsigned long const   )705746415UL, 
            (unsigned long const   )2307240305UL,        (unsigned long const   )532002310UL,        (unsigned long const   )2783231903UL,        (unsigned long const   )869578984UL, 
            (unsigned long const   )2731083640UL,        (unsigned long const   )888733711UL,        (unsigned long const   )2393377174UL,        (unsigned long const   )412618465UL, 
            (unsigned long const   )3138218623UL,        (unsigned long const   )759000328UL,        (unsigned long const   )2540463249UL,        (unsigned long const   )22832102UL, 
            (unsigned long const   )4098976619UL,        (unsigned long const   )1650551836UL,        (unsigned long const   )3627050373UL,        (unsigned long const   )1308648178UL, 
            (unsigned long const   )3985966700UL,        (unsigned long const   )2074411291UL,        (unsigned long const   )3253995650UL,        (unsigned long const   )1472466933UL, 
            (unsigned long const   )3336155237UL,        (unsigned long const   )1357494034UL,        (unsigned long const   )3937975947UL,        (unsigned long const   )2089335292UL, 
            (unsigned long const   )3743276386UL,        (unsigned long const   )1227741717UL,        (unsigned long const   )4085044108UL,        (unsigned long const   )1699534075UL, 
            (unsigned long const   )1482797645UL,        (unsigned long const   )3461461306UL,        (unsigned long const   )1946205347UL,        (unsigned long const   )3794844628UL, 
            (unsigned long const   )1101389642UL,        (unsigned long const   )3616921661UL,        (unsigned long const   )1841615268UL,        (unsigned long const   )4227126995UL, 
            (unsigned long const   )1793681731UL,        (unsigned long const   )4242107956UL,        (unsigned long const   )1183344557UL,        (unsigned long const   )3501744346UL, 
            (unsigned long const   )1932330052UL,        (unsigned long const   )3843883827UL,        (unsigned long const   )1598818986UL,        (unsigned long const   )3380350429UL, 
            (unsigned long const   )1014039888UL,        (unsigned long const   )2856387111UL,        (unsigned long const   )269487038UL,        (unsigned long const   )2250247369UL, 
            (unsigned long const   )632645719UL,        (unsigned long const   )3011866400UL,        (unsigned long const   )164914873UL,        (unsigned long const   )2682544590UL, 
            (unsigned long const   )251256414UL,        (unsigned long const   )2563365161UL,        (unsigned long const   )580440240UL,        (unsigned long const   )3030964167UL, 
            (unsigned long const   )389919577UL,        (unsigned long const   )2165158958UL,        (unsigned long const   )995933623UL,        (unsigned long const   )2909584064UL, 
            (unsigned long const   )545503469UL,        (unsigned long const   )3065233306UL,        (unsigned long const   )216184323UL,        (unsigned long const   )2597499252UL, 
            (unsigned long const   )961009130UL,        (unsigned long const   )2943865501UL,        (unsigned long const   )354867972UL,        (unsigned long const   )2199313523UL, 
            (unsigned long const   )302736355UL,        (unsigned long const   )2218484884UL,        (unsigned long const   )1047162125UL,        (unsigned long const   )2824497786UL, 
            (unsigned long const   )198119140UL,        (unsigned long const   )2650737043UL,        (unsigned long const   )665714698UL,        (unsigned long const   )2979923837UL, 
            (unsigned long const   )1150488560UL,        (unsigned long const   )3533899911UL,        (unsigned long const   )1760690462UL,        (unsigned long const   )4274128489UL, 
            (unsigned long const   )1566008055UL,        (unsigned long const   )3412551040UL,        (unsigned long const   )1899392025UL,        (unsigned long const   )3875957614UL, 
            (unsigned long const   )1981535486UL,        (unsigned long const   )3760968585UL,        (unsigned long const   )1518000656UL,        (unsigned long const   )3427458407UL, 
            (unsigned long const   )1876933113UL,        (unsigned long const   )4193238670UL,        (unsigned long const   )1136572183UL,        (unsigned long const   )3582898272UL, 
            (unsigned long const   )3903051478UL,        (unsigned long const   )2123616673UL,        (unsigned long const   )3301103672UL,        (unsigned long const   )1391648591UL, 
            (unsigned long const   )4050107345UL,        (unsigned long const   )1733803174UL,        (unsigned long const   )3708204351UL,        (unsigned long const   )1261875784UL, 
            (unsigned long const   )3660254680UL,        (unsigned long const   )1276840623UL,        (unsigned long const   )4132045622UL,        (unsigned long const   )1618609217UL, 
            (unsigned long const   )3287245023UL,        (unsigned long const   )1440704424UL,        (unsigned long const   )4019088945UL,        (unsigned long const   )2042521926UL, 
            (unsigned long const   )2360566219UL,        (unsigned long const   )444819132UL,        (unsigned long const   )2698145573UL,        (unsigned long const   )920807506UL, 
            (unsigned long const   )2507607244UL,        (unsigned long const   )54987707UL,        (unsigned long const   )3105227298UL,        (unsigned long const   )791020885UL, 
            (unsigned long const   )3191585477UL,        (unsigned long const   )671858098UL,        (unsigned long const   )2455417899UL,        (unsigned long const   )74101596UL, 
            (unsigned long const   )2818561986UL,        (unsigned long const   )835702965UL,        (unsigned long const   )2342443308UL,        (unsigned long const   )497999451UL, 
            (unsigned long const   )2965529755UL,        (unsigned long const   )653419500UL,        (unsigned long const   )2627955317UL,        (unsigned long const   )177433858UL, 
            (unsigned long const   )2835745180UL,        (unsigned long const   )1060507371UL,        (unsigned long const   )2238121842UL,        (unsigned long const   )324468741UL, 
            (unsigned long const   )2185936789UL,        (unsigned long const   )343587042UL,        (unsigned long const   )2922099067UL,        (unsigned long const   )941340172UL, 
            (unsigned long const   )2609828498UL,        (unsigned long const   )230610405UL,        (unsigned long const   )3085950076UL,        (unsigned long const   )568318731UL, 
            (unsigned long const   )3570586502UL,        (unsigned long const   )1122161905UL,        (unsigned long const   )4172537192UL,        (unsigned long const   )1854134815UL, 
            (unsigned long const   )3440819841UL,        (unsigned long const   )1529264630UL,        (unsigned long const   )3782717551UL,        (unsigned long const   )2001188632UL, 
            (unsigned long const   )3864660104UL,        (unsigned long const   )1885999103UL,        (unsigned long const   )3392865894UL,        (unsigned long const   )1544225041UL, 
            (unsigned long const   )4288570767UL,        (unsigned long const   )1773036280UL,        (unsigned long const   )3556731745UL,        (unsigned long const   )1171221526UL, 
            (unsigned long const   )2028079776UL,        (unsigned long const   )4006743511UL,        (unsigned long const   )1417872462UL,        (unsigned long const   )3266511673UL, 
            (unsigned long const   )1629906855UL,        (unsigned long const   )4145438928UL,        (unsigned long const   )1296525641UL,        (unsigned long const   )3682037310UL, 
            (unsigned long const   )1248514478UL,        (unsigned long const   )3696940761UL,        (unsigned long const   )1712054080UL,        (unsigned long const   )4030453815UL, 
            (unsigned long const   )1403960489UL,        (unsigned long const   )3315514334UL,        (unsigned long const   )2144318023UL,        (unsigned long const   )3925849392UL, 
            (unsigned long const   )485670333UL,        (unsigned long const   )2328017610UL,        (unsigned long const   )814986067UL,        (unsigned long const   )2795746340UL, 
            (unsigned long const   )87478458UL,        (unsigned long const   )2466699213UL,        (unsigned long const   )693624404UL,        (unsigned long const   )3211254051UL, 
            (unsigned long const   )779773619UL,        (unsigned long const   )3091882436UL,        (unsigned long const   )35350621UL,        (unsigned long const   )2485874474UL, 
            (unsigned long const   )935201716UL,        (unsigned long const   )2710441155UL,        (unsigned long const   )467600730UL,        (unsigned long const   )2381251117UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )1093737241UL,        (unsigned long const   )2187474482UL,        (unsigned long const   )3277008171UL, 
            (unsigned long const   )80047204UL,        (unsigned long const   )1173649277UL,        (unsigned long const   )2259114582UL,        (unsigned long const   )3348513103UL, 
            (unsigned long const   )143317448UL,        (unsigned long const   )1237041873UL,        (unsigned long const   )2330521594UL,        (unsigned long const   )3420058851UL, 
            (unsigned long const   )206550444UL,        (unsigned long const   )1300147893UL,        (unsigned long const   )2385347486UL,        (unsigned long const   )3474757767UL, 
            (unsigned long const   )1360183882UL,        (unsigned long const   )270784851UL,        (unsigned long const   )3547395192UL,        (unsigned long const   )2453794657UL, 
            (unsigned long const   )1440198190UL,        (unsigned long const   )350663991UL,        (unsigned long const   )3619002396UL,        (unsigned long const   )2525266693UL, 
            (unsigned long const   )1503140738UL,        (unsigned long const   )413728923UL,        (unsigned long const   )3690606000UL,        (unsigned long const   )2597009065UL, 
            (unsigned long const   )1566406630UL,        (unsigned long const   )476867839UL,        (unsigned long const   )3745464788UL,        (unsigned long const   )2651740877UL, 
            (unsigned long const   )2720302229UL,        (unsigned long const   )3809845132UL,        (unsigned long const   )541504167UL,        (unsigned long const   )1635232190UL, 
            (unsigned long const   )2799823089UL,        (unsigned long const   )3889230824UL,        (unsigned long const   )612622019UL,        (unsigned long const   )1706214874UL, 
            (unsigned long const   )2863553885UL,        (unsigned long const   )3953083972UL,        (unsigned long const   )684485487UL,        (unsigned long const   )1778217078UL, 
            (unsigned long const   )2926260537UL,        (unsigned long const   )4015663648UL,        (unsigned long const   )738789131UL,        (unsigned long const   )1832393746UL, 
            (unsigned long const   )4080420575UL,        (unsigned long const   )2986827206UL,        (unsigned long const   )1901359341UL,        (unsigned long const   )811953140UL, 
            (unsigned long const   )4159908539UL,        (unsigned long const   )3066180002UL,        (unsigned long const   )1972444297UL,        (unsigned long const   )882902928UL, 
            (unsigned long const   )4223442711UL,        (unsigned long const   )3129836558UL,        (unsigned long const   )2044635429UL,        (unsigned long const   )955232828UL, 
            (unsigned long const   )4286182259UL,        (unsigned long const   )3192449130UL,        (unsigned long const   )2098971969UL,        (unsigned long const   )1009442392UL, 
            (unsigned long const   )89094640UL,        (unsigned long const   )1149133545UL,        (unsigned long const   )2267893698UL,        (unsigned long const   )3323745499UL, 
            (unsigned long const   )25826708UL,        (unsigned long const   )1086000781UL,        (unsigned long const   )2213028774UL,        (unsigned long const   )3269015743UL, 
            (unsigned long const   )231055416UL,        (unsigned long const   )1291107105UL,        (unsigned long const   )2410124810UL,        (unsigned long const   )3465973011UL, 
            (unsigned long const   )151047260UL,        (unsigned long const   )1211225925UL,        (unsigned long const   )2338519662UL,        (unsigned long const   )3394494839UL, 
            (unsigned long const   )1415429050UL,        (unsigned long const   )359440547UL,        (unsigned long const   )3594489224UL,        (unsigned long const   )2534315665UL, 
            (unsigned long const   )1352194014UL,        (unsigned long const   )296340679UL,        (unsigned long const   )3539657196UL,        (unsigned long const   )2479618805UL, 
            (unsigned long const   )1557619314UL,        (unsigned long const   )501643627UL,        (unsigned long const   )3736425536UL,        (unsigned long const   )2676248409UL, 
            (unsigned long const   )1477578262UL,        (unsigned long const   )421729551UL,        (unsigned long const   )3664787492UL,        (unsigned long const   )2604737341UL, 
            (unsigned long const   )2808872293UL,        (unsigned long const   )3864716924UL,        (unsigned long const   )621398871UL,        (unsigned long const   )1681444942UL, 
            (unsigned long const   )2746126593UL,        (unsigned long const   )3802106392UL,        (unsigned long const   )567060275UL,        (unsigned long const   )1627241514UL, 
            (unsigned long const   )2950767789UL,        (unsigned long const   )4006625204UL,        (unsigned long const   )763564703UL,        (unsigned long const   )1823607174UL, 
            (unsigned long const   )2871281865UL,        (unsigned long const   )3927266256UL,        (unsigned long const   )692485883UL,        (unsigned long const   )1752655330UL, 
            (unsigned long const   )4135141167UL,        (unsigned long const   )3074958390UL,        (unsigned long const   )1947928861UL,        (unsigned long const   )891949572UL, 
            (unsigned long const   )4072428363UL,        (unsigned long const   )3012380754UL,        (unsigned long const   )1893623161UL,        (unsigned long const   )837779040UL, 
            (unsigned long const   )4277397223UL,        (unsigned long const   )3217227262UL,        (unsigned long const   )2089930965UL,        (unsigned long const   )1033948108UL, 
            (unsigned long const   )4197878403UL,        (unsigned long const   )3137835418UL,        (unsigned long const   )2018819249UL,        (unsigned long const   )962963368UL, 
            (unsigned long const   )1268286267UL,        (unsigned long const   )178886690UL,        (unsigned long const   )3388650761UL,        (unsigned long const   )2295049744UL, 
            (unsigned long const   )1331556191UL,        (unsigned long const   )242021446UL,        (unsigned long const   )3443513709UL,        (unsigned long const   )2349777524UL, 
            (unsigned long const   )1125276403UL,        (unsigned long const   )35865066UL,        (unsigned long const   )3245370561UL,        (unsigned long const   )2151774168UL, 
            (unsigned long const   )1205286551UL,        (unsigned long const   )115748238UL,        (unsigned long const   )3316973733UL,        (unsigned long const   )2223250364UL, 
            (unsigned long const   )445268337UL,        (unsigned long const   )1539005032UL,        (unsigned long const   )2565371715UL,        (unsigned long const   )3654904922UL, 
            (unsigned long const   )508505365UL,        (unsigned long const   )1602106892UL,        (unsigned long const   )2620201767UL,        (unsigned long const   )3709599806UL, 
            (unsigned long const   )302028985UL,        (unsigned long const   )1395753888UL,        (unsigned long const   )2422386315UL,        (unsigned long const   )3511924114UL, 
            (unsigned long const   )382072029UL,        (unsigned long const   )1475669956UL,        (unsigned long const   )2494022383UL,        (unsigned long const   )3583433206UL, 
            (unsigned long const   )3921414062UL,        (unsigned long const   )2827820215UL,        (unsigned long const   )1809723804UL,        (unsigned long const   )720317061UL, 
            (unsigned long const   )3984157642UL,        (unsigned long const   )2890428627UL,        (unsigned long const   )1864064504UL,        (unsigned long const   )774522593UL, 
            (unsigned long const   )3778469478UL,        (unsigned long const   )2684863871UL,        (unsigned long const   )1666508884UL,        (unsigned long const   )577106765UL, 
            (unsigned long const   )3857953282UL,        (unsigned long const   )2764220699UL,        (unsigned long const   )1737589808UL,        (unsigned long const   )648060713UL, 
            (unsigned long const   )3098461668UL,        (unsigned long const   )4188004093UL,        (unsigned long const   )986510294UL,        (unsigned long const   )2080237775UL, 
            (unsigned long const   )3161172352UL,        (unsigned long const   )4250579609UL,        (unsigned long const   )1040818098UL,        (unsigned long const   )2134410411UL, 
            (unsigned long const   )2955156524UL,        (unsigned long const   )4044687157UL,        (unsigned long const   )843459102UL,        (unsigned long const   )1937191175UL, 
            (unsigned long const   )3034673224UL,        (unsigned long const   )4124076881UL,        (unsigned long const   )914572922UL,        (unsigned long const   )2008178019UL, 
            (unsigned long const   )1322777291UL,        (unsigned long const   )266789330UL,        (unsigned long const   )3434466553UL,        (unsigned long const   )2374293472UL, 
            (unsigned long const   )1242732207UL,        (unsigned long const   )186879414UL,        (unsigned long const   )3362824349UL,        (unsigned long const   )2302786436UL, 
            (unsigned long const   )1180508931UL,        (unsigned long const   )124532762UL,        (unsigned long const   )3292468529UL,        (unsigned long const   )2232290856UL, 
            (unsigned long const   )1117278055UL,        (unsigned long const   )61428862UL,        (unsigned long const   )3237640533UL,        (unsigned long const   )2177589836UL, 
            (unsigned long const   )533018753UL,        (unsigned long const   )1593058200UL,        (unsigned long const   )2644971187UL,        (unsigned long const   )3700823466UL, 
            (unsigned long const   )453006565UL,        (unsigned long const   )1513181180UL,        (unsigned long const   )2573361879UL,        (unsigned long const   )3629349326UL, 
            (unsigned long const   )391110985UL,        (unsigned long const   )1451162192UL,        (unsigned long const   )2502809467UL,        (unsigned long const   )3558657122UL, 
            (unsigned long const   )327847213UL,        (unsigned long const   )1388025396UL,        (unsigned long const   )2447948575UL,        (unsigned long const   )3503923206UL, 
            (unsigned long const   )3975380574UL,        (unsigned long const   )2915198279UL,        (unsigned long const   )1855015020UL,        (unsigned long const   )799036277UL, 
            (unsigned long const   )3895857722UL,        (unsigned long const   )2835810595UL,        (unsigned long const   )1783899144UL,        (unsigned long const   )728055569UL, 
            (unsigned long const   )3833178006UL,        (unsigned long const   )2773007503UL,        (unsigned long const   )1713082788UL,        (unsigned long const   )657099453UL, 
            (unsigned long const   )3770469362UL,        (unsigned long const   )2710425835UL,        (unsigned long const   )1658781120UL,        (unsigned long const   )602924761UL, 
            (unsigned long const   )3185687572UL,        (unsigned long const   )4241532685UL,        (unsigned long const   )1065585190UL,        (unsigned long const   )2125631807UL, 
            (unsigned long const   )3106197616UL,        (unsigned long const   )4162177897UL,        (unsigned long const   )994502210UL,        (unsigned long const   )2054683995UL, 
            (unsigned long const   )3043714524UL,        (unsigned long const   )4099571397UL,        (unsigned long const   )923358190UL,        (unsigned long const   )1983400183UL, 
            (unsigned long const   )2980972984UL,        (unsigned long const   )4036956833UL,        (unsigned long const   )869023626UL,        (unsigned long const   )1929192595UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )929743361UL,        (unsigned long const   )1859421187UL,        (unsigned long const   )1505641986UL, 
            (unsigned long const   )3701999879UL,        (unsigned long const   )3955411718UL,        (unsigned long const   )2994507012UL,        (unsigned long const   )2232831749UL, 
            (unsigned long const   )3092321038UL,        (unsigned long const   )2403062031UL,        (unsigned long const   )3599079181UL,        (unsigned long const   )3790558476UL, 
            (unsigned long const   )1694046729UL,        (unsigned long const   )1402198024UL,        (unsigned long const   )170761738UL,        (unsigned long const   )1028086795UL, 
            (unsigned long const   )1889740316UL,        (unsigned long const   )1204413469UL,        (unsigned long const   )511156767UL,        (unsigned long const   )689791006UL, 
            (unsigned long const   )2886414107UL,        (unsigned long const   )2606886170UL,        (unsigned long const   )3269438232UL,        (unsigned long const   )4122306841UL, 
            (unsigned long const   )3371316498UL,        (unsigned long const   )4288214803UL,        (unsigned long const   )2787553553UL,        (unsigned long const   )2437706512UL, 
            (unsigned long const   )341457941UL,        (unsigned long const   )590413332UL,        (unsigned long const   )2056173590UL,        (unsigned long const   )1306819095UL, 
            (unsigned long const   )3762703672UL,        (unsigned long const   )3610021689UL,        (unsigned long const   )2391984443UL,        (unsigned long const   )3120040762UL, 
            (unsigned long const   )1022247999UL,        (unsigned long const   )193234494UL,        (unsigned long const   )1379582012UL,        (unsigned long const   )1699742269UL, 
            (unsigned long const   )1477926454UL,        (unsigned long const   )1870502967UL,        (unsigned long const   )918805045UL,        (unsigned long const   )27858996UL, 
            (unsigned long const   )2227132209UL,        (unsigned long const   )3017119024UL,        (unsigned long const   )3932934962UL,        (unsigned long const   )3707834675UL, 
            (unsigned long const   )2430954276UL,        (unsigned long const   )2811210021UL,        (unsigned long const   )4264685351UL,        (unsigned long const   )3378195750UL, 
            (unsigned long const   )1280139811UL,        (unsigned long const   )2066194466UL,        (unsigned long const   )580511264UL,        (unsigned long const   )368256033UL, 
            (unsigned long const   )682915882UL,        (unsigned long const   )534690347UL,        (unsigned long const   )1180761129UL,        (unsigned long const   )1896496680UL, 
            (unsigned long const   )4095504685UL,        (unsigned long const   )3279336236UL,        (unsigned long const   )2596861230UL,        (unsigned long const   )2913089327UL, 
            (unsigned long const   )3230505584UL,        (unsigned long const   )4159133809UL,        (unsigned long const   )2925076083UL,        (unsigned long const   )2570312818UL, 
            (unsigned long const   )472224631UL,        (unsigned long const   )726618486UL,        (unsigned long const   )1928402804UL,        (unsigned long const   )1167840629UL, 
            (unsigned long const   )2027719038UL,        (unsigned long const   )1337346943UL,        (unsigned long const   )369626493UL,        (unsigned long const   )560123772UL, 
            (unsigned long const   )2759098489UL,        (unsigned long const   )2468233848UL,        (unsigned long const   )3399484538UL,        (unsigned long const   )4257924731UL, 
            (unsigned long const   )2955852908UL,        (unsigned long const   )2269412973UL,        (unsigned long const   )3740940399UL,        (unsigned long const   )3918592622UL, 
            (unsigned long const   )1820767595UL,        (unsigned long const   )1542223722UL,        (unsigned long const   )38941032UL,        (unsigned long const   )892924777UL, 
            (unsigned long const   )142585698UL,        (unsigned long const   )1058368867UL,        (unsigned long const   )1722493793UL,        (unsigned long const   )1371662688UL, 
            (unsigned long const   )3570902629UL,        (unsigned long const   )3820840036UL,        (unsigned long const   )3120767590UL,        (unsigned long const   )2372526183UL, 
            (unsigned long const   )550229832UL,        (unsigned long const   )396432713UL,        (unsigned long const   )1310675787UL,        (unsigned long const   )2037748042UL, 
            (unsigned long const   )4234403407UL,        (unsigned long const   )3406371918UL,        (unsigned long const   )2461489740UL,        (unsigned long const   )2782763085UL, 
            (unsigned long const   )2560279622UL,        (unsigned long const   )2951743047UL,        (unsigned long const   )4132323397UL,        (unsigned long const   )3240395332UL, 
            (unsigned long const   )1144180033UL,        (unsigned long const   )1935150912UL,        (unsigned long const   )719735106UL,        (unsigned long const   )495749955UL, 
            (unsigned long const   )1349054804UL,        (unsigned long const   )1728197461UL,        (unsigned long const   )1052538199UL,        (unsigned long const   )165066582UL, 
            (unsigned long const   )2361456723UL,        (unsigned long const   )3148495442UL,        (unsigned long const   )3792993360UL,        (unsigned long const   )3581853265UL, 
            (unsigned long const   )3896107610UL,        (unsigned long const   )3746766939UL,        (unsigned long const   )2263705177UL,        (unsigned long const   )2978456664UL, 
            (unsigned long const   )881978205UL,        (unsigned long const   )66791772UL,        (unsigned long const   )1514499934UL,        (unsigned long const   )1831841119UL, 
            (unsigned long const   )2149266913UL,        (unsigned long const   )3077699552UL,        (unsigned long const   )4006588898UL,        (unsigned long const   )3651498979UL, 
            (unsigned long const   )1555250406UL,        (unsigned long const   )1809448679UL,        (unsigned long const   )845658341UL,        (unsigned long const   )84769508UL, 
            (unsigned long const   )944383727UL,        (unsigned long const   )253813998UL,        (unsigned long const   )1453236972UL,        (unsigned long const   )1643405549UL, 
            (unsigned long const   )3840028648UL,        (unsigned long const   )3548966377UL,        (unsigned long const   )2318838763UL,        (unsigned long const   )3176950250UL, 
            (unsigned long const   )4038595581UL,        (unsigned long const   )3352482300UL,        (unsigned long const   )2657916926UL,        (unsigned long const   )2835764735UL, 
            (unsigned long const   )739252986UL,        (unsigned long const   )461035771UL,        (unsigned long const   )1120182009UL,        (unsigned long const   )1974361336UL, 
            (unsigned long const   )1223229683UL,        (unsigned long const   )2139341554UL,        (unsigned long const   )641565936UL,        (unsigned long const   )290932465UL, 
            (unsigned long const   )2487290356UL,        (unsigned long const   )2737556469UL,        (unsigned long const   )4204105207UL,        (unsigned long const   )3456061430UL, 
            (unsigned long const   )1616738521UL,        (unsigned long const   )1463270104UL,        (unsigned long const   )243924186UL,        (unsigned long const   )971194075UL, 
            (unsigned long const   )3170202078UL,        (unsigned long const   )2342499295UL,        (unsigned long const   )3525440989UL,        (unsigned long const   )3846911964UL, 
            (unsigned long const   )3624692695UL,        (unsigned long const   )4016482774UL,        (unsigned long const   )3067670484UL,        (unsigned long const   )2175938005UL, 
            (unsigned long const   )77882064UL,        (unsigned long const   )869179601UL,        (unsigned long const   )1785784019UL,        (unsigned long const   )1561994450UL, 
            (unsigned long const   )285105861UL,        (unsigned long const   )664050884UL,        (unsigned long const   )2116737734UL,        (unsigned long const   )1228937415UL, 
            (unsigned long const   )3428210626UL,        (unsigned long const   )4215051715UL,        (unsigned long const   )2726482881UL,        (unsigned long const   )2515014080UL, 
            (unsigned long const   )2830061003UL,        (unsigned long const   )2680524746UL,        (unsigned long const   )3330001352UL,        (unsigned long const   )4044426185UL, 
            (unsigned long const   )1946633420UL,        (unsigned long const   )1131251405UL,        (unsigned long const   )450085071UL,        (unsigned long const   )767099598UL, 
            (unsigned long const   )1083617169UL,        (unsigned long const   )2013031824UL,        (unsigned long const   )776088466UL,        (unsigned long const   )422111635UL, 
            (unsigned long const   )2621351574UL,        (unsigned long const   )2874434711UL,        (unsigned long const   )4075430549UL,        (unsigned long const   )3313557652UL, 
            (unsigned long const   )4173839519UL,        (unsigned long const   )3484253854UL,        (unsigned long const   )2517842076UL,        (unsigned long const   )2709125789UL, 
            (unsigned long const   )611300760UL,        (unsigned long const   )319125401UL,        (unsigned long const   )1253781915UL,        (unsigned long const   )2110911386UL, 
            (unsigned long const   )808814989UL,        (unsigned long const   )123685772UL,        (unsigned long const   )1591807374UL,        (unsigned long const   )1770770319UL, 
            (unsigned long const   )3969745034UL,        (unsigned long const   )3690414731UL,        (unsigned long const   )2185823369UL,        (unsigned long const   )3039020680UL, 
            (unsigned long const   )2288294531UL,        (unsigned long const   )3205388418UL,        (unsigned long const   )3870301824UL,        (unsigned long const   )3520781441UL, 
            (unsigned long const   )1422693252UL,        (unsigned long const   )1671844229UL,        (unsigned long const   )974657415UL,        (unsigned long const   )225629574UL, 
            (unsigned long const   )2698044073UL,        (unsigned long const   )2545557672UL,        (unsigned long const   )3456394922UL,        (unsigned long const   )4184777899UL, 
            (unsigned long const   )2088299438UL,        (unsigned long const   )1259481519UL,        (unsigned long const   )313290669UL,        (unsigned long const   )633777580UL, 
            (unsigned long const   )411169191UL,        (unsigned long const   )803943334UL,        (unsigned long const   )1985312164UL,        (unsigned long const   )1094694821UL, 
            (unsigned long const   )3291084960UL,        (unsigned long const   )4081269409UL,        (unsigned long const   )2868739235UL,        (unsigned long const   )2643967650UL, 
            (unsigned long const   )3497247925UL,        (unsigned long const   )3877177012UL,        (unsigned long const   )3198632118UL,        (unsigned long const   )2311946935UL, 
            (unsigned long const   )215731634UL,        (unsigned long const   )1001459635UL,        (unsigned long const   )1645169073UL,        (unsigned long const   )1432718256UL, 
            (unsigned long const   )1747113915UL,        (unsigned long const   )1598559674UL,        (unsigned long const   )116806584UL,        (unsigned long const   )832344505UL, 
            (unsigned long const   )3028999868UL,        (unsigned long const   )2212502717UL,        (unsigned long const   )3663616703UL,        (unsigned long const   )3979647166UL}, 
   {        (unsigned long const   )0UL,        (unsigned long const   )1701297336UL,        (unsigned long const   )2345142698UL,        (unsigned long const   )4004492562UL, 
            (unsigned long const   )1469538959UL,        (unsigned long const   )854646327UL,        (unsigned long const   )3697240869UL,        (unsigned long const   )3107510173UL, 
            (unsigned long const   )4012422341UL,        (unsigned long const   )2320435325UL,        (unsigned long const   )1692450159UL,        (unsigned long const   )25625047UL, 
            (unsigned long const   )3099579978UL,        (unsigned long const   )3721947890UL,        (unsigned long const   )863494112UL,        (unsigned long const   )1443914584UL, 
            (unsigned long const   )2673285456UL,        (unsigned long const   )4197492200UL,        (unsigned long const   )345968890UL,        (unsigned long const   )1912122434UL, 
            (unsigned long const   )3368057823UL,        (unsigned long const   )2913453927UL,        (unsigned long const   )1124627061UL,        (unsigned long const   )644861645UL, 
            (unsigned long const   )1887415701UL,        (unsigned long const   )353898797UL,        (unsigned long const   )4223116351UL,        (unsigned long const   )2664437895UL, 
            (unsigned long const   )669568794UL,        (unsigned long const   )1116697506UL,        (unsigned long const   )2887829168UL,        (unsigned long const   )3376904712UL, 
            (unsigned long const   )1051669152UL,        (unsigned long const   )1539870232UL,        (unsigned long const   )3043441418UL,        (unsigned long const   )3489695666UL, 
            (unsigned long const   )1765298223UL,        (unsigned long const   )207613079UL,        (unsigned long const   )3807402373UL,        (unsigned long const   )2274878781UL, 
            (unsigned long const   )3515319909UL,        (unsigned long const   )3034594013UL,        (unsigned long const   )1515163599UL,        (unsigned long const   )1059599223UL, 
            (unsigned long const   )2249254122UL,        (unsigned long const   )3816249426UL,        (unsigned long const   )232320320UL,        (unsigned long const   )1757368824UL, 
            (unsigned long const   )2717395952UL,        (unsigned long const   )3298793288UL,        (unsigned long const   )707797594UL,        (unsigned long const   )1331142370UL, 
            (unsigned long const   )4134488447UL,        (unsigned long const   )2466837959UL,        (unsigned long const   )2108113109UL,        (unsigned long const   )415300717UL, 
            (unsigned long const   )1322295093UL,        (unsigned long const   )733422477UL,        (unsigned long const   )3306722975UL,        (unsigned long const   )2692688423UL, 
            (unsigned long const   )424148410UL,        (unsigned long const   )2082488578UL,        (unsigned long const   )2458907664UL,        (unsigned long const   )4159195304UL, 
            (unsigned long const   )1029182619UL,        (unsigned long const   )1480566819UL,        (unsigned long const   )3062897969UL,        (unsigned long const   )3556221321UL, 
            (unsigned long const   )1791981076UL,        (unsigned long const   )262720172UL,        (unsigned long const   )3775365054UL,        (unsigned long const   )2220933894UL, 
            (unsigned long const   )3530596446UL,        (unsigned long const   )3071745254UL,        (unsigned long const   )1505274356UL,        (unsigned long const   )1021252940UL, 
            (unsigned long const   )2246558417UL,        (unsigned long const   )3766517353UL,        (unsigned long const   )238013307UL,        (unsigned long const   )1799911363UL, 
            (unsigned long const   )2718895563UL,        (unsigned long const   )3345527155UL,        (unsigned long const   )700908641UL,        (unsigned long const   )1285601497UL, 
            (unsigned long const   )4120407876UL,        (unsigned long const   )2432685052UL,        (unsigned long const   )2119198446UL,        (unsigned long const   )456645206UL, 
            (unsigned long const   )1294448910UL,        (unsigned long const   )675284406UL,        (unsigned long const   )3337597092UL,        (unsigned long const   )2743602204UL, 
            (unsigned long const   )447798145UL,        (unsigned long const   )2144823097UL,        (unsigned long const   )2440614443UL,        (unsigned long const   )4095700627UL, 
            (unsigned long const   )66528827UL,        (unsigned long const   )1720752771UL,        (unsigned long const   )2285842321UL,        (unsigned long const   )3982005033UL, 
            (unsigned long const   )1415595188UL,        (unsigned long const   )822605836UL,        (unsigned long const   )3752348958UL,        (unsigned long const   )3134189990UL, 
            (unsigned long const   )3974075134UL,        (unsigned long const   )2310549062UL,        (unsigned long const   )1729600340UL,        (unsigned long const   )40904684UL, 
            (unsigned long const   )3142119537UL,        (unsigned long const   )3727641801UL,        (unsigned long const   )813758939UL,        (unsigned long const   )1441219939UL, 
            (unsigned long const   )2627747691UL,        (unsigned long const   )4190602195UL,        (unsigned long const   )392705729UL,        (unsigned long const   )1913621113UL, 
            (unsigned long const   )3409403364UL,        (unsigned long const   )2924536156UL,        (unsigned long const   )1090475086UL,        (unsigned long const   )630778102UL, 
            (unsigned long const   )1938328494UL,        (unsigned long const   )384775958UL,        (unsigned long const   )4164977156UL,        (unsigned long const   )2636594876UL, 
            (unsigned long const   )606071073UL,        (unsigned long const   )1098405273UL,        (unsigned long const   )2950160523UL,        (unsigned long const   )3400555571UL, 
            (unsigned long const   )1001806317UL,        (unsigned long const   )1590814037UL,        (unsigned long const   )2961068103UL,        (unsigned long const   )3575246079UL, 
            (unsigned long const   )1814117218UL,        (unsigned long const   )155617242UL,        (unsigned long const   )3890819784UL,        (unsigned long const   )2190380656UL, 
            (unsigned long const   )3567185192UL,        (unsigned long const   )2985906576UL,        (unsigned long const   )1599530114UL,        (unsigned long const   )976312378UL, 
            (unsigned long const   )2198441895UL,        (unsigned long const   )3865981727UL,        (unsigned long const   )146900493UL,        (unsigned long const   )1839610549UL, 
            (unsigned long const   )2766225597UL,        (unsigned long const   )3246849029UL,        (unsigned long const   )791234839UL,        (unsigned long const   )1246688687UL, 
            (unsigned long const   )4084605490UL,        (unsigned long const   )2517737098UL,        (unsigned long const   )2025728920UL,        (unsigned long const   )500799264UL, 
            (unsigned long const   )1271526520UL,        (unsigned long const   )783173824UL,        (unsigned long const   )3221355986UL,        (unsigned long const   )2774942058UL, 
            (unsigned long const   )475961079UL,        (unsigned long const   )2033789519UL,        (unsigned long const   )2543230813UL,        (unsigned long const   )4075889637UL, 
            (unsigned long const   )85551949UL,        (unsigned long const   )1618925557UL,        (unsigned long const   )2396087015UL,        (unsigned long const   )3954630239UL, 
            (unsigned long const   )1385040322UL,        (unsigned long const   )938063226UL,        (unsigned long const   )3645243496UL,        (unsigned long const   )3156327632UL, 
            (unsigned long const   )3929137032UL,        (unsigned long const   )2404803376UL,        (unsigned long const   )1643763234UL,        (unsigned long const   )77490842UL, 
            (unsigned long const   )3181821191UL,        (unsigned long const   )3636527551UL,        (unsigned long const   )913224877UL,        (unsigned long const   )1393100821UL, 
            (unsigned long const   )2588832285UL,        (unsigned long const   )4280929957UL,        (unsigned long const   )294026167UL,        (unsigned long const   )1960953615UL, 
            (unsigned long const   )3453554834UL,        (unsigned long const   )2831068202UL,        (unsigned long const   )1175525688UL,        (unsigned long const   )594978176UL, 
            (unsigned long const   )1969669848UL,        (unsigned long const   )268532320UL,        (unsigned long const   )4272869234UL,        (unsigned long const   )2613670858UL, 
            (unsigned long const   )586261591UL,        (unsigned long const   )1201019119UL,        (unsigned long const   )2839129597UL,        (unsigned long const   )3428716869UL, 
            (unsigned long const   )116280694UL,        (unsigned long const   )1669984718UL,        (unsigned long const   )2368095452UL,        (unsigned long const   )3896637540UL, 
            (unsigned long const   )1366896633UL,        (unsigned long const   )874419009UL,        (unsigned long const   )3669042771UL,        (unsigned long const   )3218512619UL, 
            (unsigned long const   )3922131379UL,        (unsigned long const   )2359379211UL,        (unsigned long const   )1645146137UL,        (unsigned long const   )124341409UL, 
            (unsigned long const   )3193019196UL,        (unsigned long const   )3677759364UL,        (unsigned long const   )899256982UL,        (unsigned long const   )1358835246UL, 
            (unsigned long const   )2579059750UL,        (unsigned long const   )4242466974UL,        (unsigned long const   )309419404UL,        (unsigned long const   )1997988148UL, 
            (unsigned long const   )3459135145UL,        (unsigned long const   )2873723409UL,        (unsigned long const   )1172717315UL,        (unsigned long const   )545358779UL, 
            (unsigned long const   )1989271779UL,        (unsigned long const   )334912603UL,        (unsigned long const   )4250528073UL,        (unsigned long const   )2554222065UL, 
            (unsigned long const   )554074732UL,        (unsigned long const   )1147223764UL,        (unsigned long const   )2865662918UL,        (unsigned long const   )3483973502UL, 
            (unsigned long const   )943816662UL,        (unsigned long const   )1562821486UL,        (unsigned long const   )3012130428UL,        (unsigned long const   )3605973700UL, 
            (unsigned long const   )1876303193UL,        (unsigned long const   )179413473UL,        (unsigned long const   )3827176691UL,        (unsigned long const   )2172233803UL, 
            (unsigned long const   )3614034707UL,        (unsigned long const   )2987292587UL,        (unsigned long const   )1554105017UL,        (unsigned long const   )969309697UL, 
            (unsigned long const   )2164173212UL,        (unsigned long const   )3852014884UL,        (unsigned long const   )188129334UL,        (unsigned long const   )1850809486UL, 
            (unsigned long const   )2803263110UL,        (unsigned long const   )3262241342UL,        (unsigned long const   )752774956UL,        (unsigned long const   )1236915092UL, 
            (unsigned long const   )4034987017UL,        (unsigned long const   )2514925745UL,        (unsigned long const   )2068385187UL,        (unsigned long const   )506376475UL, 
            (unsigned long const   )1212076611UL,        (unsigned long const   )760835835UL,        (unsigned long const   )3287735273UL,        (unsigned long const   )2794547025UL, 
            (unsigned long const   )531214540UL,        (unsigned long const   )2060323956UL,        (unsigned long const   )2489432422UL,        (unsigned long const   )4043703774UL}};
#line 205 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
unsigned long const   *get_crc_table(void) 
{ 


  {
#line 211
  return ((unsigned long const   *)(crc_table));
}
}
#line 219 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
unsigned long crc32(unsigned long crc , unsigned char const   *buf___1 , unsigned int len ) 
{ 
  u4 endian ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 224
  if ((unsigned long )buf___1 == (unsigned long )((unsigned char const   *)0)) {
#line 224
    return (0UL);
  }
#line 232
  if (sizeof(void *) == sizeof(ptrdiff_t )) {
#line 235
    endian = (u4 )1;
#line 236
    if (*((unsigned char *)(& endian))) {
      {
#line 237
      tmp = crc32_little(crc, buf___1, len);
      }
#line 237
      return (tmp);
    } else {
      {
#line 239
      tmp___0 = crc32_big(crc, buf___1, len);
      }
#line 239
      return (tmp___0);
    }
  }
#line 242
  crc ^= 4294967295UL;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (len >= 8U)) {
#line 243
      goto while_break;
    }
#line 244
    tmp___1 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___1) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___2 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___2) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___3 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___3) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___4 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___4) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___5 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___5) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___6 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___6) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___7 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___7) & 255] ^ (unsigned long const   )(crc >> 8));
#line 244
    tmp___8 = buf___1;
#line 244
    buf___1 ++;
#line 244
    crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___8) & 255] ^ (unsigned long const   )(crc >> 8));
#line 245
    len -= 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  if (len) {
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      tmp___9 = buf___1;
#line 248
      buf___1 ++;
#line 248
      crc = (unsigned long )(crc_table[0][((int )crc ^ (int )*tmp___9) & 255] ^ (unsigned long const   )(crc >> 8));
#line 247
      len --;
#line 247
      if (! len) {
#line 247
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 250
  return (crc ^ 4294967295UL);
}
}
#line 262 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf___1 ,
                                  unsigned int len ) 
{ 
  register u4 c ;
  register u4 const   *buf4 ;
  unsigned char const   *tmp ;
  u4 const   *tmp___0 ;
  u4 const   *tmp___1 ;
  u4 const   *tmp___2 ;
  u4 const   *tmp___3 ;
  u4 const   *tmp___4 ;
  u4 const   *tmp___5 ;
  u4 const   *tmp___6 ;
  u4 const   *tmp___7 ;
  u4 const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 270
  c = (u4 )crc;
#line 271
  c = ~ c;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (len) {
#line 272
      if (! ((ptrdiff_t )buf___1 & 3L)) {
#line 272
        goto while_break;
      }
    } else {
#line 272
      goto while_break;
    }
#line 273
    tmp = buf___1;
#line 273
    buf___1 ++;
#line 273
    c = (u4 )(crc_table[0][(c ^ (unsigned int )*tmp) & 255U] ^ (unsigned long const   )(c >> 8));
#line 274
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  buf4 = (u4 const   *)((void const   *)buf___1);
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 278
    if (! (len >= 32U)) {
#line 278
      goto while_break___0;
    }
#line 279
    tmp___0 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___0;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___1 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___1;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___2 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___2;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___3 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___3;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___4 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___4;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___5 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___5;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___6 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___6;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 279
    tmp___7 = buf4;
#line 279
    buf4 ++;
#line 279
    c ^= (unsigned int )*tmp___7;
#line 279
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 280
    len -= 32U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 282
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 282
    if (! (len >= 4U)) {
#line 282
      goto while_break___1;
    }
#line 283
    tmp___8 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___8;
#line 283
    c = (u4 )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 284
    len -= 4U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 286
  buf___1 = (unsigned char const   *)buf4;
#line 288
  if (len) {
    {
#line 288
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 289
      tmp___9 = buf___1;
#line 289
      buf___1 ++;
#line 289
      c = (u4 )(crc_table[0][(c ^ (unsigned int )*tmp___9) & 255U] ^ (unsigned long const   )(c >> 8));
#line 288
      len --;
#line 288
      if (! len) {
#line 288
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 291
  c = ~ c;
#line 292
  return ((unsigned long )c);
}
}
#line 302 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf___1 ,
                               unsigned int len ) 
{ 
  register u4 c ;
  register u4 const   *buf4 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 310
  c = ((((u4 )crc >> 24) + (((u4 )crc >> 8) & 65280U)) + (((u4 )crc & 65280U) << 8)) + (((u4 )crc & 255U) << 24);
#line 311
  c = ~ c;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (len) {
#line 312
      if (! ((ptrdiff_t )buf___1 & 3L)) {
#line 312
        goto while_break;
      }
    } else {
#line 312
      goto while_break;
    }
#line 313
    tmp = buf___1;
#line 313
    buf___1 ++;
#line 313
    c = (u4 )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp] ^ (unsigned long const   )(c << 8));
#line 314
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  buf4 = (u4 const   *)((void const   *)buf___1);
#line 318
  buf4 --;
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 319
    if (! (len >= 32U)) {
#line 319
      goto while_break___0;
    }
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 320
    buf4 ++;
#line 320
    c ^= (unsigned int )*buf4;
#line 320
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 321
    len -= 32U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (len >= 4U)) {
#line 323
      goto while_break___1;
    }
#line 324
    buf4 ++;
#line 324
    c ^= (unsigned int )*buf4;
#line 324
    c = (u4 )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 325
    len -= 4U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 327
  buf4 ++;
#line 328
  buf___1 = (unsigned char const   *)buf4;
#line 330
  if (len) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 331
      tmp___0 = buf___1;
#line 331
      buf___1 ++;
#line 331
      c = (u4 )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp___0] ^ (unsigned long const   )(c << 8));
#line 330
      len --;
#line 330
      if (! len) {
#line 330
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 333
  c = ~ c;
#line 334
  return ((unsigned long )((((c >> 24) + ((c >> 8) & 65280U)) + ((c & 65280U) << 8)) + ((c & 255U) << 24)));
}
}
#line 342 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) 
{ 
  unsigned long sum ;

  {
#line 348
  sum = 0UL;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! vec) {
#line 349
      goto while_break;
    }
#line 350
    if (vec & 1UL) {
#line 351
      sum ^= *mat;
    }
#line 352
    vec >>= 1;
#line 353
    mat ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (sum);
}
}
#line 359 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) 
{ 
  int n ;

  {
#line 365
  n = 0;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (n < 32)) {
#line 365
      goto while_break;
    }
    {
#line 366
    *(square + n) = gf2_matrix_times(mat, *(mat + n));
#line 365
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 370 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/crc32.c"
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) 
{ 
  int n ;
  unsigned long row ;
  unsigned long even[32] ;
  unsigned long odd[32] ;

  {
#line 381
  if (len2 == 0L) {
#line 382
    return (crc1);
  }
#line 385
  odd[0] = 3988292384UL;
#line 386
  row = 1UL;
#line 387
  n = 1;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (n < 32)) {
#line 387
      goto while_break;
    }
#line 388
    odd[n] = row;
#line 389
    row <<= 1;
#line 387
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  gf2_matrix_square(even, odd);
#line 396
  gf2_matrix_square(odd, even);
  }
  {
#line 400
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 402
    gf2_matrix_square(even, odd);
    }
#line 403
    if (len2 & 1L) {
      {
#line 404
      crc1 = gf2_matrix_times(even, crc1);
      }
    }
#line 405
    len2 >>= 1;
#line 408
    if (len2 == 0L) {
#line 409
      goto while_break___0;
    }
    {
#line 412
    gf2_matrix_square(odd, even);
    }
#line 413
    if (len2 & 1L) {
      {
#line 414
      crc1 = gf2_matrix_times(odd, crc1);
      }
    }
#line 415
    len2 >>= 1;
#line 400
    if (! (len2 != 0L)) {
#line 400
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 421
  crc1 ^= crc2;
#line 422
  return (crc1);
}
}
#line 1018 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1033
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) ;
#line 22 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/compress.c"
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) 
{ 
  z_stream stream ;
  int err ;
  int tmp ;

  {
#line 32
  stream.next_in = (Bytef *)source;
#line 33
  stream.avail_in = (uInt )sourceLen;
#line 38
  stream.next_out = dest;
#line 39
  stream.avail_out = (uInt )*destLen;
#line 40
  if ((uLong )stream.avail_out != *destLen) {
#line 40
    return (-5);
  }
  {
#line 42
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 43
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 44
  stream.opaque = (voidpf )0;
#line 46
  err = deflateInit_(& stream, level, "1.2.3-optipng", (int )sizeof(z_stream ));
  }
#line 47
  if (err != 0) {
#line 47
    return (err);
  }
  {
#line 49
  err = deflate(& stream, 4);
  }
#line 50
  if (err != 1) {
    {
#line 51
    deflateEnd(& stream);
    }
#line 52
    if (err == 0) {
#line 52
      tmp = -5;
    } else {
#line 52
      tmp = err;
    }
#line 52
    return (tmp);
  }
  {
#line 54
  *destLen = stream.total_out;
#line 56
  err = deflateEnd(& stream);
  }
#line 57
  return (err);
}
}
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/compress.c"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = compress2(dest, destLen, source, sourceLen, -1);
  }
#line 68
  return (tmp);
}
}
#line 75 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/compress.c"
uLong compressBound(uLong sourceLen ) 
{ 


  {
#line 78
  return (((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + 11UL);
}
}
#line 1285 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/zlib.h"
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) ;
#line 57 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/adler32.c"
uLong adler32(uLong adler , Bytef const   *buf___1 , uInt len ) 
{ 
  unsigned long sum2 ;
  unsigned int n ;
  Bytef const   *tmp ;
  uInt tmp___0 ;
  Bytef const   *tmp___1 ;
  uInt tmp___2 ;

  {
#line 66
  sum2 = (adler >> 16) & 65535UL;
#line 67
  adler &= 65535UL;
#line 70
  if (len == 1U) {
#line 71
    adler += (uLong )*(buf___1 + 0);
#line 72
    if (adler >= 65521UL) {
#line 73
      adler -= 65521UL;
    }
#line 74
    sum2 += adler;
#line 75
    if (sum2 >= 65521UL) {
#line 76
      sum2 -= 65521UL;
    }
#line 77
    return (adler | (sum2 << 16));
  }
#line 81
  if ((unsigned long )buf___1 == (unsigned long )((Bytef const   *)0)) {
#line 82
    return ((uLong )1L);
  }
#line 85
  if (len < 16U) {
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      tmp___0 = len;
#line 86
      len --;
#line 86
      if (! tmp___0) {
#line 86
        goto while_break;
      }
#line 87
      tmp = buf___1;
#line 87
      buf___1 ++;
#line 87
      adler += (uLong )*tmp;
#line 88
      sum2 += adler;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    if (adler >= 65521UL) {
#line 91
      adler -= 65521UL;
    }
#line 92
    sum2 %= 65521UL;
#line 93
    return (adler | (sum2 << 16));
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! (len >= 5552U)) {
#line 97
      goto while_break___0;
    }
#line 98
    len -= 5552U;
#line 99
    n = 347U;
    {
#line 100
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      adler += (uLong )*(buf___1 + 0);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 1);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 2);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 3);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 4);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 5);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 6);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 7);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 8);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 9);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 10);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 11);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 12);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 13);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 14);
#line 101
      sum2 += adler;
#line 101
      adler += (uLong )*(buf___1 + 15);
#line 101
      sum2 += adler;
#line 102
      buf___1 += 16;
#line 100
      n --;
#line 100
      if (! n) {
#line 100
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 104
    adler %= 65521UL;
#line 105
    sum2 %= 65521UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (len) {
    {
#line 110
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 110
      if (! (len >= 16U)) {
#line 110
        goto while_break___2;
      }
#line 111
      len -= 16U;
#line 112
      adler += (uLong )*(buf___1 + 0);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 1);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 2);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 3);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 4);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 5);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 6);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 7);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 8);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 9);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 10);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 11);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 12);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 13);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 14);
#line 112
      sum2 += adler;
#line 112
      adler += (uLong )*(buf___1 + 15);
#line 112
      sum2 += adler;
#line 113
      buf___1 += 16;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 115
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 115
      tmp___2 = len;
#line 115
      len --;
#line 115
      if (! tmp___2) {
#line 115
        goto while_break___3;
      }
#line 116
      tmp___1 = buf___1;
#line 116
      buf___1 ++;
#line 116
      adler += (uLong )*tmp___1;
#line 117
      sum2 += adler;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 119
    adler %= 65521UL;
#line 120
    sum2 %= 65521UL;
  }
#line 124
  return (adler | (sum2 << 16));
}
}
#line 128 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/zlib/adler32.c"
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) 
{ 
  unsigned long sum1 ;
  unsigned long sum2 ;
  unsigned int rem ;

  {
#line 138
  rem = (unsigned int )((unsigned long )len2 % 65521UL);
#line 139
  sum1 = adler1 & 65535UL;
#line 140
  sum2 = (unsigned long )rem * sum1;
#line 141
  sum2 %= 65521UL;
#line 142
  sum1 += ((adler2 & 65535UL) + 65521UL) - 1UL;
#line 143
  sum2 += ((((adler1 >> 16) & 65535UL) + ((adler2 >> 16) & 65535UL)) + 65521UL) - (unsigned long )rem;
#line 144
  if (sum1 > 65521UL) {
#line 144
    sum1 -= 65521UL;
  }
#line 145
  if (sum1 > 65521UL) {
#line 145
    sum1 -= 65521UL;
  }
#line 146
  if (sum2 > 65521UL << 1) {
#line 146
    sum2 -= 65521UL << 1;
  }
#line 147
  if (sum2 > 65521UL) {
#line 147
    sum2 -= 65521UL;
  }
#line 148
  return (sum1 | (sum2 << 16));
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 469 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
int const   png_pass_start[7] ;
#line 470
int const   png_pass_inc[7] ;
#line 471
int const   png_pass_ystart[7] ;
#line 472
int const   png_pass_yinc[7] ;
#line 1446
void png_write_chunk(png_structp png_ptr , png_bytep chunk_name , png_bytep data ,
                     png_size_t length ) ;
#line 1450
void png_write_chunk_start(png_structp png_ptr , png_bytep chunk_name , png_uint_32 length ) ;
#line 1454
void png_write_chunk_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 1458
void png_write_chunk_end(png_structp png_ptr ) ;
#line 1652
void png_write_flush(png_structp png_ptr ) ;
#line 1957
png_voidp png_malloc(png_structp png_ptr , png_uint_32 size ) ;
#line 1964
png_voidp png_malloc_warn(png_structp png_ptr , png_uint_32 size ) ;
#line 1969
void png_free(png_structp png_ptr , png_voidp ptr ) ;
#line 2027
void png_error(png_structp png_ptr , png_const_charp error_message ) ;
#line 2035
void png_warning(png_structp png_ptr , png_const_charp warning_message ) ;
#line 2632
void png_save_uint_32(png_bytep buf___1 , png_uint_32 i ) ;
#line 2634
void png_save_int_32(png_bytep buf___1 , png_int_32 i ) ;
#line 2641
void png_save_uint_16(png_bytep buf___1 , unsigned int i ) ;
#line 2817
png_byte const   png_IHDR[5] ;
#line 2818
png_byte const   png_IDAT[5] ;
#line 2819
png_byte const   png_IEND[5] ;
#line 2820
png_byte const   png_PLTE[5] ;
#line 2821
png_byte const   png_bKGD[5] ;
#line 2822
png_byte const   png_cHRM[5] ;
#line 2823
png_byte const   png_gAMA[5] ;
#line 2824
png_byte const   png_hIST[5] ;
#line 2825
png_byte const   png_iCCP[5] ;
#line 2827
png_byte const   png_oFFs[5] ;
#line 2828
png_byte const   png_pCAL[5] ;
#line 2829
png_byte const   png_sCAL[5] ;
#line 2830
png_byte const   png_pHYs[5] ;
#line 2831
png_byte const   png_sBIT[5] ;
#line 2832
png_byte const   png_sPLT[5] ;
#line 2833
png_byte const   png_sRGB[5] ;
#line 2834
png_byte const   png_tEXt[5] ;
#line 2835
png_byte const   png_tIME[5] ;
#line 2836
png_byte const   png_tRNS[5] ;
#line 2837
png_byte const   png_zTXt[5] ;
#line 2891
voidpf png_zalloc(voidpf png_ptr , uInt items , uInt size ) ;
#line 2894
void png_zfree(voidpf png_ptr , voidpf ptr ) ;
#line 2928
void png_reset_crc(png_structp png_ptr ) ;
#line 2931
void png_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 2960
void png_calculate_crc(png_structp png_ptr , png_bytep ptr , png_size_t length ) ;
#line 2968
void png_write_sig(png_structp png_ptr ) ;
#line 2975
void png_write_IHDR(png_structp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) ;
#line 2980
void png_write_PLTE(png_structp png_ptr , png_colorp palette , png_uint_32 num_pal ) ;
#line 2983
void png_write_IDAT(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 2986
void png_write_IEND(png_structp png_ptr ) ;
#line 2993
void png_write_gAMA_fixed(png_structp png_ptr , png_fixed_point file_gamma ) ;
#line 2999
void png_write_sBIT(png_structp png_ptr , png_color_8p sbit , int color_type ) ;
#line 3011
void png_write_cHRM_fixed(png_structp png_ptr , png_fixed_point white_x , png_fixed_point white_y ,
                          png_fixed_point red_x , png_fixed_point red_y , png_fixed_point green_x ,
                          png_fixed_point green_y , png_fixed_point blue_x , png_fixed_point blue_y ) ;
#line 3020
void png_write_sRGB(png_structp png_ptr , int srgb_intent ) ;
#line 3025
void png_write_iCCP(png_structp png_ptr , png_charp name , int compression_type ,
                    png_charp profile , int profile_len ) ;
#line 3032
void png_write_sPLT(png_structp png_ptr , png_sPLT_tp spalette ) ;
#line 3037
void png_write_tRNS(png_structp png_ptr , png_bytep trans , png_color_16p tran , int num_trans ,
                    int color_type ) ;
#line 3042
void png_write_bKGD(png_structp png_ptr , png_color_16p back , int color_type ) ;
#line 3047
void png_write_hIST(png_structp png_ptr , png_uint_16p hist , int num_hist ) ;
#line 3053
png_size_t png_check_keyword(png_structp png_ptr , png_charp key , png_charpp new_key ) ;
#line 3058
void png_write_tEXt(png_structp png_ptr , png_charp key , png_charp text , png_size_t text_len ) ;
#line 3063
void png_write_zTXt(png_structp png_ptr , png_charp key , png_charp text , png_size_t text_len ,
                    int compression ) ;
#line 3079
void png_write_oFFs(png_structp png_ptr , png_int_32 x_offset , png_int_32 y_offset ,
                    int unit_type ) ;
#line 3084
void png_write_pCAL(png_structp png_ptr , png_charp purpose , png_int_32 X0 , png_int_32 X1 ,
                    int type , int nparams , png_charp units , png_charpp params ) ;
#line 3090
void png_write_pHYs(png_structp png_ptr , png_uint_32 x_pixels_per_unit , png_uint_32 y_pixels_per_unit ,
                    int unit_type ) ;
#line 3096
void png_write_tIME(png_structp png_ptr , png_timep mod_time ) ;
#line 3106
void png_write_sCAL_s(png_structp png_ptr , int unit , png_charp width , png_charp height ) ;
#line 3113
void png_write_finish_row(png_structp png_ptr ) ;
#line 3116
void png_write_start_row(png_structp png_ptr ) ;
#line 3139
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) ;
#line 3148
void png_write_find_filter(png_structp png_ptr , png_row_infop row_info ) ;
#line 3152
void png_write_filtered_row(png_structp png_ptr , png_bytep filtered_row ) ;
#line 19 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_save_uint_32(png_bytep buf___1 , png_uint_32 i ) 
{ 


  {
#line 22
  *(buf___1 + 0) = (png_byte )((i >> 24) & 255UL);
#line 23
  *(buf___1 + 1) = (png_byte )((i >> 16) & 255UL);
#line 24
  *(buf___1 + 2) = (png_byte )((i >> 8) & 255UL);
#line 25
  *(buf___1 + 3) = (png_byte )(i & 255UL);
#line 26
  return;
}
}
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_save_int_32(png_bytep buf___1 , png_int_32 i ) 
{ 


  {
#line 35
  *(buf___1 + 0) = (png_byte )((i >> 24) & 255L);
#line 36
  *(buf___1 + 1) = (png_byte )((i >> 16) & 255L);
#line 37
  *(buf___1 + 2) = (png_byte )((i >> 8) & 255L);
#line 38
  *(buf___1 + 3) = (png_byte )(i & 255L);
#line 39
  return;
}
}
#line 45 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_save_uint_16(png_bytep buf___1 , unsigned int i ) 
{ 


  {
#line 48
  *(buf___1 + 0) = (png_byte )((i >> 8) & 255U);
#line 49
  *(buf___1 + 1) = (png_byte )(i & 255U);
#line 50
  return;
}
}
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_chunk(png_structp png_ptr , png_bytep chunk_name , png_bytep data ,
                     png_size_t length ) 
{ 


  {
  {
#line 65
  png_write_chunk_start(png_ptr, chunk_name, length);
#line 66
  png_write_chunk_data(png_ptr, data, length);
#line 67
  png_write_chunk_end(png_ptr);
  }
#line 68
  return;
}
}
#line 74 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_chunk_start(png_structp png_ptr , png_bytep chunk_name , png_uint_32 length ) 
{ 
  png_byte buf___1[4] ;

  {
  {
#line 82
  png_save_uint_32(buf___1, length);
#line 83
  png_write_data(png_ptr, buf___1, (png_size_t )4);
#line 86
  png_write_data(png_ptr, chunk_name, (png_size_t )4);
#line 88
  png_reset_crc(png_ptr);
#line 89
  png_calculate_crc(png_ptr, chunk_name, (png_size_t )4);
  }
#line 90
  return;
}
}
#line 97 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_chunk_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 


  {
#line 101
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 101
    if (length > 0UL) {
      {
#line 103
      png_calculate_crc(png_ptr, data, length);
#line 104
      png_write_data(png_ptr, data, length);
      }
    }
  }
#line 106
  return;
}
}
#line 109 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_chunk_end(png_structp png_ptr ) 
{ 
  png_byte buf___1[4] ;

  {
  {
#line 115
  png_save_uint_32(buf___1, png_ptr->crc);
#line 117
  png_write_data(png_ptr, buf___1, (png_size_t )4);
  }
#line 118
  return;
}
}
#line 126 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_sig(png_structp png_ptr ) 
{ 
  png_byte png_signature[8] ;

  {
  {
#line 129
  png_signature[0] = (png_byte )137;
#line 129
  png_signature[1] = (png_byte )80;
#line 129
  png_signature[2] = (png_byte )78;
#line 129
  png_signature[3] = (png_byte )71;
#line 129
  png_signature[4] = (png_byte )13;
#line 129
  png_signature[5] = (png_byte )10;
#line 129
  png_signature[6] = (png_byte )26;
#line 129
  png_signature[7] = (png_byte )10;
#line 131
  png_write_data(png_ptr, & png_signature[png_ptr->sig_bytes], 8UL - (png_size_t )png_ptr->sig_bytes);
  }
#line 133
  if ((int )png_ptr->sig_bytes < 3) {
#line 134
    png_ptr->mode |= 4096UL;
  }
#line 135
  return;
}
}
#line 155 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
static int png_text_compress(png_structp png_ptr , png_charp text , png_size_t text_len ,
                             int compression , compression_state *comp ) 
{ 
  int ret ;
  char msg___0[50] ;
  int old_max ;
  png_charpp old_ptr ;
  png_voidp tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;
  int old_max___0 ;
  png_charpp old_ptr___0 ;
  png_voidp tmp___2 ;
  png_voidp tmp___3 ;
  png_voidp tmp___4 ;

  {
#line 162
  comp->num_output_ptr = 0;
#line 163
  comp->max_output_ptr = 0;
#line 164
  comp->output_ptr = (png_charpp )((void *)0);
#line 165
  comp->input = (char *)((void *)0);
#line 166
  comp->input_len = 0;
#line 169
  if (compression == -1) {
#line 171
    comp->input = text;
#line 172
    comp->input_len = (int )text_len;
#line 173
    return ((int )text_len);
  }
#line 176
  if (compression >= 3) {
    {
#line 180
    sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Unknown compression type %d",
            compression);
#line 181
    png_warning(png_ptr, (png_const_charp )(msg___0));
    }
  }
#line 203
  png_ptr->zstream.avail_in = (uInt )text_len;
#line 204
  png_ptr->zstream.next_in = (Bytef *)text;
#line 205
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 206
  png_ptr->zstream.next_out = png_ptr->zbuf;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    ret = deflate(& png_ptr->zstream, 0);
    }
#line 213
    if (ret != 0) {
#line 216
      if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
        {
#line 217
        png_error(png_ptr, (png_const_charp )png_ptr->zstream.msg);
        }
      } else {
        {
#line 219
        png_error(png_ptr, "zlib error");
        }
      }
    }
#line 222
    if (! png_ptr->zstream.avail_out) {
#line 225
      if (comp->num_output_ptr >= comp->max_output_ptr) {
#line 229
        old_max = comp->max_output_ptr;
#line 230
        comp->max_output_ptr = comp->num_output_ptr + 4;
#line 231
        if ((unsigned long )comp->output_ptr != (unsigned long )((void *)0)) {
          {
#line 235
          old_ptr = comp->output_ptr;
#line 236
          tmp = png_malloc(png_ptr, (unsigned long )comp->max_output_ptr * sizeof(png_charpp ));
#line 236
          comp->output_ptr = (png_charpp )tmp;
#line 239
          memcpy((void */* __restrict  */)comp->output_ptr, (void const   */* __restrict  */)old_ptr,
                 (unsigned long )old_max * sizeof(png_charp ));
#line 241
          png_free(png_ptr, (png_voidp )old_ptr);
          }
        } else {
          {
#line 244
          tmp___0 = png_malloc(png_ptr, (unsigned long )comp->max_output_ptr * sizeof(png_charp ));
#line 244
          comp->output_ptr = (png_charpp )tmp___0;
          }
        }
      }
      {
#line 250
      tmp___1 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 250
      *(comp->output_ptr + comp->num_output_ptr) = (png_charp )tmp___1;
#line 252
      memcpy((void */* __restrict  */)*(comp->output_ptr + comp->num_output_ptr),
             (void const   */* __restrict  */)png_ptr->zbuf, png_ptr->zbuf_size);
#line 254
      (comp->num_output_ptr) ++;
#line 257
      png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 258
      png_ptr->zstream.next_out = png_ptr->zbuf;
      }
    }
#line 209
    if (! png_ptr->zstream.avail_in) {
#line 209
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 267
    ret = deflate(& png_ptr->zstream, 4);
    }
#line 269
    if (ret == 0) {
#line 272
      if (! png_ptr->zstream.avail_out) {
#line 275
        if (comp->num_output_ptr >= comp->max_output_ptr) {
#line 279
          old_max___0 = comp->max_output_ptr;
#line 280
          comp->max_output_ptr = comp->num_output_ptr + 4;
#line 281
          if ((unsigned long )comp->output_ptr != (unsigned long )((void *)0)) {
            {
#line 285
            old_ptr___0 = comp->output_ptr;
#line 287
            tmp___2 = png_malloc(png_ptr, (unsigned long )comp->max_output_ptr * sizeof(png_charpp ));
#line 287
            comp->output_ptr = (png_charpp )tmp___2;
#line 290
            memcpy((void */* __restrict  */)comp->output_ptr, (void const   */* __restrict  */)old_ptr___0,
                   (unsigned long )old_max___0 * sizeof(png_charp ));
#line 292
            png_free(png_ptr, (png_voidp )old_ptr___0);
            }
          } else {
            {
#line 295
            tmp___3 = png_malloc(png_ptr, (unsigned long )comp->max_output_ptr * sizeof(png_charp ));
#line 295
            comp->output_ptr = (png_charpp )tmp___3;
            }
          }
        }
        {
#line 301
        tmp___4 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 301
        *(comp->output_ptr + comp->num_output_ptr) = (png_charp )tmp___4;
#line 303
        memcpy((void */* __restrict  */)*(comp->output_ptr + comp->num_output_ptr),
               (void const   */* __restrict  */)png_ptr->zbuf, png_ptr->zbuf_size);
#line 305
        (comp->num_output_ptr) ++;
#line 308
        png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 309
        png_ptr->zstream.next_out = png_ptr->zbuf;
        }
      }
    } else
#line 312
    if (ret != 1) {
#line 315
      if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
        {
#line 316
        png_error(png_ptr, (png_const_charp )png_ptr->zstream.msg);
        }
      } else {
        {
#line 318
        png_error(png_ptr, "zlib error");
        }
      }
    }
#line 264
    if (! (ret != 1)) {
#line 264
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  text_len = png_ptr->zbuf_size * (png_size_t )comp->num_output_ptr;
#line 324
  if ((png_size_t )png_ptr->zstream.avail_out < png_ptr->zbuf_size) {
#line 325
    text_len += png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out;
  }
#line 327
  return ((int )text_len);
}
}
#line 331 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
static void png_write_compressed_data_out(png_structp png_ptr , compression_state *comp ) 
{ 
  int i ;

  {
#line 337
  if (comp->input) {
    {
#line 339
    png_write_chunk_data(png_ptr, (png_bytep )comp->input, (png_size_t )comp->input_len);
    }
#line 341
    return;
  }
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < comp->num_output_ptr)) {
#line 345
      goto while_break;
    }
    {
#line 347
    png_write_chunk_data(png_ptr, (png_bytep )*(comp->output_ptr + i), png_ptr->zbuf_size);
#line 349
    png_free(png_ptr, (png_voidp )*(comp->output_ptr + i));
#line 350
    *(comp->output_ptr + i) = (char *)((void *)0);
#line 345
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  if (comp->max_output_ptr != 0) {
    {
#line 353
    png_free(png_ptr, (png_voidp )comp->output_ptr);
    }
  }
#line 354
  comp->output_ptr = (png_charpp )((void *)0);
#line 356
  if ((png_uint_32 )png_ptr->zstream.avail_out < png_ptr->zbuf_size) {
    {
#line 357
    png_write_chunk_data(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out);
    }
  }
  {
#line 361
  deflateReset(& png_ptr->zstream);
#line 362
  png_ptr->zstream.data_type = 0;
  }
#line 363
  return;
}
}
#line 370 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_IHDR(png_structp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) 
{ 
  png_byte buf___1[13] ;

  {
  {
#line 384
  if (color_type == 0) {
#line 384
    goto case_0;
  }
#line 395
  if (color_type == 2) {
#line 395
    goto case_2___0;
  }
#line 400
  if (color_type == 3) {
#line 400
    goto case_3;
  }
#line 410
  if (color_type == 4) {
#line 410
    goto case_4___1;
  }
#line 415
  if (color_type == 6) {
#line 415
    goto case_6;
  }
#line 420
  goto switch_default___1;
  case_0: /* CIL Label */ 
  {
#line 391
  if (bit_depth == 16) {
#line 391
    goto case_16;
  }
#line 391
  if (bit_depth == 8) {
#line 391
    goto case_16;
  }
#line 391
  if (bit_depth == 4) {
#line 391
    goto case_16;
  }
#line 391
  if (bit_depth == 2) {
#line 391
    goto case_16;
  }
#line 391
  if (bit_depth == 1) {
#line 391
    goto case_16;
  }
#line 392
  goto switch_default;
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 391
  png_ptr->channels = (png_byte )1;
#line 391
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 392
  png_error(png_ptr, "Invalid bit depth for grayscale image");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 394
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 396
  if (bit_depth != 8) {
#line 396
    if (bit_depth != 16) {
      {
#line 397
      png_error(png_ptr, "Invalid bit depth for RGB image");
      }
    }
  }
#line 398
  png_ptr->channels = (png_byte )3;
#line 399
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 406
  if (bit_depth == 8) {
#line 406
    goto case_8___0;
  }
#line 406
  if (bit_depth == 4) {
#line 406
    goto case_8___0;
  }
#line 406
  if (bit_depth == 2) {
#line 406
    goto case_8___0;
  }
#line 406
  if (bit_depth == 1) {
#line 406
    goto case_8___0;
  }
#line 407
  goto switch_default___0;
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 406
  png_ptr->channels = (png_byte )1;
#line 406
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 407
  png_error(png_ptr, "Invalid bit depth for paletted image");
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 409
  goto switch_break;
  case_4___1: /* CIL Label */ 
#line 411
  if (bit_depth != 8) {
#line 411
    if (bit_depth != 16) {
      {
#line 412
      png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
      }
    }
  }
#line 413
  png_ptr->channels = (png_byte )2;
#line 414
  goto switch_break;
  case_6: /* CIL Label */ 
#line 416
  if (bit_depth != 8) {
#line 416
    if (bit_depth != 16) {
      {
#line 417
      png_error(png_ptr, "Invalid bit depth for RGBA image");
      }
    }
  }
#line 418
  png_ptr->channels = (png_byte )4;
#line 419
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 421
  png_error(png_ptr, "Invalid image color type specified");
  }
  switch_break: /* CIL Label */ ;
  }
#line 424
  if (compression_type != 0) {
    {
#line 426
    png_warning(png_ptr, "Invalid compression type specified");
#line 427
    compression_type = 0;
    }
  }
#line 439
  if (filter_type != 0) {
    {
#line 449
    png_warning(png_ptr, "Invalid filter type specified");
#line 450
    filter_type = 0;
    }
  }
#line 454
  if (interlace_type != 0) {
#line 454
    if (interlace_type != 1) {
      {
#line 457
      png_warning(png_ptr, "Invalid interlace type specified");
#line 458
      interlace_type = 1;
      }
    }
  }
#line 465
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 466
  png_ptr->color_type = (png_byte )color_type;
#line 467
  png_ptr->interlaced = (png_byte )interlace_type;
#line 471
  png_ptr->compression_type = (png_byte )compression_type;
#line 472
  png_ptr->width = width;
#line 473
  png_ptr->height = height;
#line 475
  png_ptr->pixel_depth = (png_byte )(bit_depth * (int )png_ptr->channels);
#line 476
  if ((int )png_ptr->pixel_depth >= 8) {
#line 476
    png_ptr->rowbytes = width * ((png_uint_32 )png_ptr->pixel_depth >> 3);
  } else {
#line 476
    png_ptr->rowbytes = (width * (png_uint_32 )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 478
  png_ptr->usr_width = png_ptr->width;
#line 479
  png_ptr->usr_bit_depth = png_ptr->bit_depth;
#line 480
  png_ptr->usr_channels = png_ptr->channels;
#line 483
  png_save_uint_32(buf___1, width);
#line 484
  png_save_uint_32(buf___1 + 4, height);
#line 485
  buf___1[8] = (png_byte )bit_depth;
#line 486
  buf___1[9] = (png_byte )color_type;
#line 487
  buf___1[10] = (png_byte )compression_type;
#line 488
  buf___1[11] = (png_byte )filter_type;
#line 489
  buf___1[12] = (png_byte )interlace_type;
#line 492
  png_write_chunk(png_ptr, (png_bytep )(png_IHDR), buf___1, (png_size_t )13);
#line 495
  png_ptr->zstream.zalloc = & png_zalloc;
#line 496
  png_ptr->zstream.zfree = & png_zfree;
#line 497
  png_ptr->zstream.opaque = (voidpf )png_ptr;
  }
#line 498
  if (! png_ptr->do_filter) {
#line 500
    if ((int )png_ptr->color_type == 3) {
#line 502
      png_ptr->do_filter = (png_byte )8;
    } else
#line 500
    if ((int )png_ptr->bit_depth < 8) {
#line 502
      png_ptr->do_filter = (png_byte )8;
    } else {
#line 504
      png_ptr->do_filter = (png_byte )248;
    }
  }
#line 506
  if (! (png_ptr->flags & 1UL)) {
#line 508
    if ((int )png_ptr->do_filter != 8) {
#line 509
      png_ptr->zlib_strategy = 1;
    } else {
#line 511
      png_ptr->zlib_strategy = 0;
    }
  }
#line 513
  if (! (png_ptr->flags & 2UL)) {
#line 514
    png_ptr->zlib_level = -1;
  }
#line 515
  if (! (png_ptr->flags & 4UL)) {
#line 516
    png_ptr->zlib_mem_level = 8;
  }
#line 517
  if (! (png_ptr->flags & 8UL)) {
#line 518
    png_ptr->zlib_window_bits = 15;
  }
#line 519
  if (! (png_ptr->flags & 16UL)) {
#line 520
    png_ptr->zlib_method = 8;
  }
  {
#line 521
  deflateInit2_(& png_ptr->zstream, png_ptr->zlib_level, png_ptr->zlib_method, png_ptr->zlib_window_bits,
                png_ptr->zlib_mem_level, png_ptr->zlib_strategy, "1.2.3-optipng",
                (int )sizeof(z_stream ));
#line 524
  png_ptr->zstream.next_out = png_ptr->zbuf;
#line 525
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 528
  png_ptr->zstream.data_type = 0;
#line 530
  png_ptr->mode = (png_uint_32 )1;
  }
#line 531
  return;
}
}
#line 537 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_PLTE(png_structp png_ptr , png_colorp palette , png_uint_32 num_pal ) 
{ 
  png_uint_32 i ;
  png_colorp pal_ptr ;
  png_byte buf___1[3] ;

  {
#line 548
  if (num_pal == 0UL) {
#line 548
    goto _L;
  } else
#line 548
  if (num_pal > 256UL) {
    _L: /* CIL Label */ 
#line 554
    if ((int )png_ptr->color_type == 3) {
      {
#line 556
      png_error(png_ptr, "Invalid number of colors in palette");
      }
    } else {
      {
#line 560
      png_warning(png_ptr, "Invalid number of colors in palette");
      }
#line 561
      return;
    }
  }
#line 565
  if (! ((int )png_ptr->color_type & 2)) {
    {
#line 567
    png_warning(png_ptr, "Ignoring request to write a PLTE chunk in grayscale PNG");
    }
#line 569
    return;
  }
  {
#line 572
  png_ptr->num_palette = (png_uint_16 )num_pal;
#line 575
  png_write_chunk_start(png_ptr, (png_bytep )(png_PLTE), num_pal * 3UL);
#line 577
  i = (png_uint_32 )0;
#line 577
  pal_ptr = palette;
  }
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! (i < num_pal)) {
#line 577
      goto while_break;
    }
    {
#line 579
    buf___1[0] = pal_ptr->red;
#line 580
    buf___1[1] = pal_ptr->green;
#line 581
    buf___1[2] = pal_ptr->blue;
#line 582
    png_write_chunk_data(png_ptr, buf___1, (png_size_t )3);
#line 577
    i ++;
#line 577
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  png_write_chunk_end(png_ptr);
#line 596
  png_ptr->mode |= 2UL;
  }
#line 597
  return;
}
}
#line 600 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_IDAT(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  unsigned int z_cmf ;
  png_uint_32 uncompressed_idat_size ;
  unsigned int z_cinfo ;
  unsigned int half_z_window_size ;

  {
#line 610
  if (! (png_ptr->mode & 4UL)) {
#line 610
    if ((int )png_ptr->compression_type == 0) {
#line 613
      z_cmf = (unsigned int )*(data + 0);
#line 614
      if ((z_cmf & 15U) == 8U) {
#line 614
        if ((z_cmf & 240U) <= 112U) {
#line 619
          if (length >= 2UL) {
#line 619
            if (png_ptr->height < 16384UL) {
#line 619
              if (png_ptr->width < 16384UL) {
#line 622
                uncompressed_idat_size = png_ptr->height * (((png_ptr->width * (png_uint_32 )png_ptr->channels) * (png_uint_32 )png_ptr->bit_depth + 15UL) >> 3);
#line 625
                z_cinfo = z_cmf >> 4;
#line 626
                half_z_window_size = (unsigned int )(1 << (z_cinfo + 7U));
                {
#line 627
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 627
                  if (uncompressed_idat_size <= (png_uint_32 )half_z_window_size) {
#line 627
                    if (! (half_z_window_size >= 256U)) {
#line 627
                      goto while_break;
                    }
                  } else {
#line 627
                    goto while_break;
                  }
#line 630
                  z_cinfo --;
#line 631
                  half_z_window_size >>= 1;
                }
                while_break: /* CIL Label */ ;
                }
#line 633
                z_cmf = (z_cmf & 15U) | (z_cinfo << 4);
#line 634
                if ((int )*(data + 0) != (int )((png_byte )z_cmf)) {
#line 636
                  *(data + 0) = (png_byte )z_cmf;
#line 637
                  *(data + 1) = (png_byte )((int )*(data + 1) & 224);
#line 638
                  *(data + 1) = (png_byte )((int )*(data + 1) + (int )((png_byte )(31U - ((z_cmf << 8) + (unsigned int )*(data + 1)) % 31U)));
                }
              }
            }
          }
        } else {
          {
#line 643
          png_error(png_ptr, "Invalid zlib compression method or flags in IDAT");
          }
        }
      } else {
        {
#line 643
        png_error(png_ptr, "Invalid zlib compression method or flags in IDAT");
        }
      }
    }
  }
  {
#line 647
  png_write_chunk(png_ptr, (png_bytep )(png_IDAT), data, length);
#line 648
  png_ptr->mode |= 4UL;
  }
#line 649
  return;
}
}
#line 652 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_IEND(png_structp png_ptr ) 
{ 


  {
  {
#line 659
  png_write_chunk(png_ptr, (png_bytep )(png_IEND), (png_bytep )((void *)0), (png_size_t )0);
#line 661
  png_ptr->mode |= 16UL;
  }
#line 662
  return;
}
}
#line 684 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_gAMA_fixed(png_structp png_ptr , png_fixed_point file_gamma ) 
{ 
  png_byte buf___1[4] ;

  {
  {
#line 694
  png_save_uint_32(buf___1, (png_uint_32 )file_gamma);
#line 695
  png_write_chunk(png_ptr, (png_bytep )(png_gAMA), buf___1, (png_size_t )4);
  }
#line 696
  return;
}
}
#line 702 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_sRGB(png_structp png_ptr , int srgb_intent ) 
{ 
  png_byte buf___1[1] ;

  {
#line 711
  if (srgb_intent >= 4) {
    {
#line 712
    png_warning(png_ptr, "Invalid sRGB rendering intent specified");
    }
  }
  {
#line 714
  buf___1[0] = (png_byte )srgb_intent;
#line 715
  png_write_chunk(png_ptr, (png_bytep )(png_sRGB), buf___1, (png_size_t )1);
  }
#line 716
  return;
}
}
#line 721 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_iCCP(png_structp png_ptr , png_charp name , int compression_type ,
                    png_charp profile , int profile_len ) 
{ 
  png_size_t name_len ;
  png_charp new_name ;
  compression_state comp ;

  {
#line 734
  comp.num_output_ptr = 0;
#line 735
  comp.max_output_ptr = 0;
#line 736
  comp.output_ptr = (png_charpp )((void *)0);
#line 737
  comp.input = (char *)((void *)0);
#line 738
  comp.input_len = 0;
#line 740
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 743
    png_warning(png_ptr, "Empty keyword in iCCP chunk");
    }
#line 744
    return;
  } else {
    {
#line 740
    name_len = png_check_keyword(png_ptr, name, & new_name);
    }
#line 740
    if (name_len == 0UL) {
      {
#line 743
      png_warning(png_ptr, "Empty keyword in iCCP chunk");
      }
#line 744
      return;
    }
  }
#line 747
  if (compression_type != 0) {
    {
#line 748
    png_warning(png_ptr, "Unknown compression type in iCCP chunk");
    }
  }
#line 750
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 751
    profile_len = 0;
  }
#line 753
  if (profile_len) {
    {
#line 754
    profile_len = png_text_compress(png_ptr, profile, (png_size_t )profile_len, 0,
                                    & comp);
    }
  }
  {
#line 758
  png_write_chunk_start(png_ptr, (png_bytep )(png_iCCP), (name_len + (png_uint_32 )profile_len) + 2UL);
#line 760
  *(new_name + (name_len + 1UL)) = (char)0;
#line 761
  png_write_chunk_data(png_ptr, (png_bytep )new_name, name_len + 2UL);
  }
#line 763
  if (profile_len) {
    {
#line 764
    png_write_compressed_data_out(png_ptr, & comp);
    }
  }
  {
#line 766
  png_write_chunk_end(png_ptr);
#line 767
  png_free(png_ptr, (png_voidp )new_name);
  }
#line 768
  return;
}
}
#line 773 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_sPLT(png_structp png_ptr , png_sPLT_tp spalette ) 
{ 
  png_size_t name_len ;
  png_charp new_name ;
  png_byte entrybuf[10] ;
  int entry_size ;
  int tmp ;
  int palette_size ;
  png_sPLT_entryp ep ;

  {
#line 782
  if ((int )spalette->depth == 8) {
#line 782
    tmp = 6;
  } else {
#line 782
    tmp = 10;
  }
#line 782
  entry_size = tmp;
#line 783
  palette_size = (int )((png_int_32 )entry_size * spalette->nentries);
#line 790
  if ((unsigned long )spalette->name == (unsigned long )((void *)0)) {
    {
#line 793
    png_warning(png_ptr, "Empty keyword in sPLT chunk");
    }
#line 794
    return;
  } else {
    {
#line 790
    name_len = png_check_keyword(png_ptr, spalette->name, & new_name);
    }
#line 790
    if (name_len == 0UL) {
      {
#line 793
      png_warning(png_ptr, "Empty keyword in sPLT chunk");
      }
#line 794
      return;
    }
  }
  {
#line 798
  png_write_chunk_start(png_ptr, (png_bytep )(png_sPLT), (name_len + 2UL) + (png_size_t )palette_size);
#line 800
  png_write_chunk_data(png_ptr, (png_bytep )new_name, name_len + 1UL);
#line 801
  png_write_chunk_data(png_ptr, & spalette->depth, (png_size_t )1);
#line 805
  ep = spalette->entries;
  }
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if (! ((unsigned long )ep < (unsigned long )(spalette->entries + spalette->nentries))) {
#line 805
      goto while_break;
    }
#line 807
    if ((int )spalette->depth == 8) {
      {
#line 809
      entrybuf[0] = (png_byte )ep->red;
#line 810
      entrybuf[1] = (png_byte )ep->green;
#line 811
      entrybuf[2] = (png_byte )ep->blue;
#line 812
      entrybuf[3] = (png_byte )ep->alpha;
#line 813
      png_save_uint_16(entrybuf + 4, (unsigned int )ep->frequency);
      }
    } else {
      {
#line 817
      png_save_uint_16(entrybuf + 0, (unsigned int )ep->red);
#line 818
      png_save_uint_16(entrybuf + 2, (unsigned int )ep->green);
#line 819
      png_save_uint_16(entrybuf + 4, (unsigned int )ep->blue);
#line 820
      png_save_uint_16(entrybuf + 6, (unsigned int )ep->alpha);
#line 821
      png_save_uint_16(entrybuf + 8, (unsigned int )ep->frequency);
      }
    }
    {
#line 823
    png_write_chunk_data(png_ptr, entrybuf, (png_size_t )entry_size);
#line 805
    ep ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  png_write_chunk_end(png_ptr);
#line 850
  png_free(png_ptr, (png_voidp )new_name);
  }
#line 851
  return;
}
}
#line 856 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_sBIT(png_structp png_ptr , png_color_8p sbit , int color_type ) 
{ 
  png_byte buf___1[4] ;
  png_size_t size ;
  png_byte maxbits ;
  int tmp ;
  png_size_t tmp___0 ;

  {
#line 867
  if (color_type & 2) {
#line 871
    if (color_type == 3) {
#line 871
      tmp = 8;
    } else {
#line 871
      tmp = (int )png_ptr->usr_bit_depth;
    }
#line 871
    maxbits = (png_byte )tmp;
#line 873
    if ((int )sbit->red == 0) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    } else
#line 873
    if ((int )sbit->red > (int )maxbits) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    } else
#line 873
    if ((int )sbit->green == 0) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    } else
#line 873
    if ((int )sbit->green > (int )maxbits) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    } else
#line 873
    if ((int )sbit->blue == 0) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    } else
#line 873
    if ((int )sbit->blue > (int )maxbits) {
      {
#line 877
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 878
      return;
    }
#line 880
    buf___1[0] = sbit->red;
#line 881
    buf___1[1] = sbit->green;
#line 882
    buf___1[2] = sbit->blue;
#line 883
    size = (png_size_t )3;
  } else {
#line 887
    if ((int )sbit->gray == 0) {
      {
#line 889
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 890
      return;
    } else
#line 887
    if ((int )sbit->gray > (int )png_ptr->usr_bit_depth) {
      {
#line 889
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 890
      return;
    }
#line 892
    buf___1[0] = sbit->gray;
#line 893
    size = (png_size_t )1;
  }
#line 896
  if (color_type & 4) {
#line 898
    if ((int )sbit->alpha == 0) {
      {
#line 900
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 901
      return;
    } else
#line 898
    if ((int )sbit->alpha > (int )png_ptr->usr_bit_depth) {
      {
#line 900
      png_warning(png_ptr, "Invalid sBIT depth specified");
      }
#line 901
      return;
    }
#line 903
    tmp___0 = size;
#line 903
    size ++;
#line 903
    buf___1[tmp___0] = sbit->alpha;
  }
  {
#line 906
  png_write_chunk(png_ptr, (png_bytep )(png_sBIT), buf___1, size);
  }
#line 907
  return;
}
}
#line 974 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_cHRM_fixed(png_structp png_ptr , png_fixed_point white_x , png_fixed_point white_y ,
                          png_fixed_point red_x , png_fixed_point red_y , png_fixed_point green_x ,
                          png_fixed_point green_y , png_fixed_point blue_x , png_fixed_point blue_y ) 
{ 
  png_byte buf___1[32] ;

  {
#line 987
  if (white_x > 80000L) {
    {
#line 989
    png_warning(png_ptr, "Invalid fixed cHRM white point specified");
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"white_x=%ld, white_y=%ld\n",
            white_x, white_y);
    }
#line 993
    return;
  } else
#line 987
  if (white_y > 80000L) {
    {
#line 989
    png_warning(png_ptr, "Invalid fixed cHRM white point specified");
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"white_x=%ld, white_y=%ld\n",
            white_x, white_y);
    }
#line 993
    return;
  } else
#line 987
  if (white_x + white_y > 100000L) {
    {
#line 989
    png_warning(png_ptr, "Invalid fixed cHRM white point specified");
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"white_x=%ld, white_y=%ld\n",
            white_x, white_y);
    }
#line 993
    return;
  }
  {
#line 995
  png_save_uint_32(buf___1, (png_uint_32 )white_x);
#line 996
  png_save_uint_32(buf___1 + 4, (png_uint_32 )white_y);
  }
#line 998
  if (red_x + red_y > 100000L) {
    {
#line 1000
    png_warning(png_ptr, "Invalid cHRM fixed red point specified");
    }
#line 1001
    return;
  }
  {
#line 1003
  png_save_uint_32(buf___1 + 8, (png_uint_32 )red_x);
#line 1004
  png_save_uint_32(buf___1 + 12, (png_uint_32 )red_y);
  }
#line 1006
  if (green_x + green_y > 100000L) {
    {
#line 1008
    png_warning(png_ptr, "Invalid fixed cHRM green point specified");
    }
#line 1009
    return;
  }
  {
#line 1011
  png_save_uint_32(buf___1 + 16, (png_uint_32 )green_x);
#line 1012
  png_save_uint_32(buf___1 + 20, (png_uint_32 )green_y);
  }
#line 1014
  if (blue_x + blue_y > 100000L) {
    {
#line 1016
    png_warning(png_ptr, "Invalid fixed cHRM blue point specified");
    }
#line 1017
    return;
  }
  {
#line 1019
  png_save_uint_32(buf___1 + 24, (png_uint_32 )blue_x);
#line 1020
  png_save_uint_32(buf___1 + 28, (png_uint_32 )blue_y);
#line 1022
  png_write_chunk(png_ptr, (png_bytep )(png_cHRM), buf___1, (png_size_t )32);
  }
#line 1023
  return;
}
}
#line 1029 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_tRNS(png_structp png_ptr , png_bytep trans , png_color_16p tran , int num_trans ,
                    int color_type ) 
{ 
  png_byte buf___1[6] ;

  {
#line 1039
  if (color_type == 3) {
#line 1041
    if (num_trans <= 0) {
      {
#line 1043
      png_warning(png_ptr, "Invalid number of transparent colors specified");
      }
#line 1044
      return;
    } else
#line 1041
    if (num_trans > (int )png_ptr->num_palette) {
      {
#line 1043
      png_warning(png_ptr, "Invalid number of transparent colors specified");
      }
#line 1044
      return;
    }
    {
#line 1047
    png_write_chunk(png_ptr, (png_bytep )(png_tRNS), trans, (png_size_t )num_trans);
    }
  } else
#line 1049
  if (color_type == 0) {
#line 1052
    if ((int )tran->gray >= 1 << (int )png_ptr->bit_depth) {
      {
#line 1054
      png_warning(png_ptr, "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
      }
#line 1056
      return;
    }
    {
#line 1058
    png_save_uint_16(buf___1, (unsigned int )tran->gray);
#line 1059
    png_write_chunk(png_ptr, (png_bytep )(png_tRNS), buf___1, (png_size_t )2);
    }
  } else
#line 1061
  if (color_type == 2) {
    {
#line 1064
    png_save_uint_16(buf___1, (unsigned int )tran->red);
#line 1065
    png_save_uint_16(buf___1 + 2, (unsigned int )tran->green);
#line 1066
    png_save_uint_16(buf___1 + 4, (unsigned int )tran->blue);
    }
#line 1067
    if ((int )png_ptr->bit_depth == 8) {
#line 1067
      if (((int )buf___1[0] | (int )buf___1[2]) | (int )buf___1[4]) {
        {
#line 1069
        png_warning(png_ptr, "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
        }
#line 1071
        return;
      }
    }
    {
#line 1073
    png_write_chunk(png_ptr, (png_bytep )(png_tRNS), buf___1, (png_size_t )6);
    }
  } else {
    {
#line 1077
    png_warning(png_ptr, "Can\'t write tRNS with an alpha channel");
    }
  }
#line 1079
  return;
}
}
#line 1084 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_bKGD(png_structp png_ptr , png_color_16p back , int color_type ) 
{ 
  png_byte buf___1[6] ;

  {
#line 1093
  if (color_type == 3) {
#line 1095
    if ((int )back->index > (int )png_ptr->num_palette) {
      {
#line 1102
      png_warning(png_ptr, "Invalid background palette index");
      }
#line 1103
      return;
    }
    {
#line 1105
    buf___1[0] = back->index;
#line 1106
    png_write_chunk(png_ptr, (png_bytep )(png_bKGD), buf___1, (png_size_t )1);
    }
  } else
#line 1108
  if (color_type & 2) {
    {
#line 1110
    png_save_uint_16(buf___1, (unsigned int )back->red);
#line 1111
    png_save_uint_16(buf___1 + 2, (unsigned int )back->green);
#line 1112
    png_save_uint_16(buf___1 + 4, (unsigned int )back->blue);
    }
#line 1113
    if ((int )png_ptr->bit_depth == 8) {
#line 1113
      if (((int )buf___1[0] | (int )buf___1[2]) | (int )buf___1[4]) {
        {
#line 1115
        png_warning(png_ptr, "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
        }
#line 1117
        return;
      }
    }
    {
#line 1119
    png_write_chunk(png_ptr, (png_bytep )(png_bKGD), buf___1, (png_size_t )6);
    }
  } else {
#line 1123
    if ((int )back->gray >= 1 << (int )png_ptr->bit_depth) {
      {
#line 1125
      png_warning(png_ptr, "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
      }
#line 1127
      return;
    }
    {
#line 1129
    png_save_uint_16(buf___1, (unsigned int )back->gray);
#line 1130
    png_write_chunk(png_ptr, (png_bytep )(png_bKGD), buf___1, (png_size_t )2);
    }
  }
#line 1132
  return;
}
}
#line 1137 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_hIST(png_structp png_ptr , png_uint_16p hist , int num_hist ) 
{ 
  int i ;
  png_byte buf___1[3] ;

  {
#line 1147
  if (num_hist > (int )png_ptr->num_palette) {
    {
#line 1151
    png_warning(png_ptr, "Invalid number of histogram entries specified");
    }
#line 1152
    return;
  }
  {
#line 1155
  png_write_chunk_start(png_ptr, (png_bytep )(png_hIST), (png_uint_32 )(num_hist * 2));
#line 1156
  i = 0;
  }
  {
#line 1156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1156
    if (! (i < num_hist)) {
#line 1156
      goto while_break;
    }
    {
#line 1158
    png_save_uint_16(buf___1, (unsigned int )*(hist + i));
#line 1159
    png_write_chunk_data(png_ptr, buf___1, (png_size_t )2);
#line 1156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1161
  png_write_chunk_end(png_ptr);
  }
#line 1162
  return;
}
}
#line 1177 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
png_size_t png_check_keyword(png_structp png_ptr , png_charp key , png_charpp new_key ) 
{ 
  png_size_t key_len ;
  png_charp kp ;
  png_charp dp ;
  int kflag ;
  int kwarn ;
  png_voidp tmp ;
  char msg___0[40] ;
  png_charp tmp___0 ;
  png_charp tmp___1 ;
  png_charp tmp___2 ;

  {
#line 1183
  kwarn = 0;
#line 1186
  *new_key = (char *)((void *)0);
#line 1188
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 1190
    png_warning(png_ptr, "zero length keyword");
    }
#line 1191
    return ((png_size_t )0);
  } else {
    {
#line 1188
    key_len = strlen((char const   *)key);
    }
#line 1188
    if (key_len == 0UL) {
      {
#line 1190
      png_warning(png_ptr, "zero length keyword");
      }
#line 1191
      return ((png_size_t )0);
    }
  }
  {
#line 1196
  tmp = png_malloc_warn(png_ptr, key_len + 2UL);
#line 1196
  *new_key = (png_charp )tmp;
  }
#line 1197
  if ((unsigned long )*new_key == (unsigned long )((void *)0)) {
    {
#line 1199
    png_warning(png_ptr, "Out of memory while procesing keyword");
    }
#line 1200
    return ((png_size_t )0);
  }
#line 1204
  kp = key;
#line 1204
  dp = *new_key;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if (! ((int )*kp != 0)) {
#line 1204
      goto while_break;
    }
#line 1206
    if ((int )*kp < 32) {
      {
#line 1211
      sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"invalid keyword character 0x%02X",
              (int )*kp);
#line 1212
      png_warning(png_ptr, (png_const_charp )(msg___0));
#line 1216
      *dp = (char )' ';
      }
    } else
#line 1206
    if ((int )*kp > 126) {
#line 1206
      if ((int )((png_byte )*kp) < 161) {
        {
#line 1211
        sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"invalid keyword character 0x%02X",
                (int )*kp);
#line 1212
        png_warning(png_ptr, (png_const_charp )(msg___0));
#line 1216
        *dp = (char )' ';
        }
      } else {
#line 1220
        *dp = *kp;
      }
    } else {
#line 1220
      *dp = *kp;
    }
#line 1204
    kp ++;
#line 1204
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1223
  *dp = (char )'\000';
#line 1226
  kp = (*new_key + key_len) - 1;
#line 1227
  if ((int )*kp == 32) {
    {
#line 1229
    png_warning(png_ptr, "trailing spaces removed from keyword");
    }
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1231
      if (! ((int )*kp == 32)) {
#line 1231
        goto while_break___0;
      }
#line 1233
      tmp___0 = kp;
#line 1233
      kp --;
#line 1233
      *tmp___0 = (char )'\000';
#line 1234
      key_len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1239
  kp = *new_key;
#line 1240
  if ((int )*kp == 32) {
    {
#line 1242
    png_warning(png_ptr, "leading spaces removed from keyword");
    }
    {
#line 1244
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1244
      if (! ((int )*kp == 32)) {
#line 1244
        goto while_break___1;
      }
#line 1246
      kp ++;
#line 1247
      key_len --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1254
  kflag = 0;
#line 1254
  dp = *new_key;
  {
#line 1254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1254
    if (! ((int )*kp != 0)) {
#line 1254
      goto while_break___2;
    }
#line 1256
    if ((int )*kp == 32) {
#line 1256
      if (kflag == 0) {
#line 1258
        tmp___1 = dp;
#line 1258
        dp ++;
#line 1258
        *tmp___1 = *kp;
#line 1259
        kflag = 1;
      } else {
#line 1256
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1261
    if ((int )*kp == 32) {
#line 1263
      key_len --;
#line 1264
      kwarn = 1;
    } else {
#line 1268
      tmp___2 = dp;
#line 1268
      dp ++;
#line 1268
      *tmp___2 = *kp;
#line 1269
      kflag = 0;
    }
#line 1254
    kp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1272
  *dp = (char )'\000';
#line 1273
  if (kwarn) {
    {
#line 1274
    png_warning(png_ptr, "extra interior spaces removed from keyword");
    }
  }
#line 1276
  if (key_len == 0UL) {
    {
#line 1278
    png_free(png_ptr, (png_voidp )*new_key);
#line 1279
    *new_key = (char *)((void *)0);
#line 1280
    png_warning(png_ptr, "Zero length keyword");
    }
  }
#line 1283
  if (key_len > 79UL) {
    {
#line 1285
    png_warning(png_ptr, "keyword length must be 1 - 79 characters");
#line 1286
    *(new_key + 79) = (char *)'\000';
#line 1287
    key_len = (png_size_t )79;
    }
  }
#line 1290
  return (key_len);
}
}
#line 1296 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_tEXt(png_structp png_ptr , png_charp key , png_charp text , png_size_t text_len ) 
{ 
  png_size_t key_len ;
  png_charp new_key ;

  {
#line 1307
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 1309
    png_warning(png_ptr, "Empty keyword in tEXt chunk");
    }
#line 1310
    return;
  } else {
    {
#line 1307
    key_len = png_check_keyword(png_ptr, key, & new_key);
    }
#line 1307
    if (key_len == 0UL) {
      {
#line 1309
      png_warning(png_ptr, "Empty keyword in tEXt chunk");
      }
#line 1310
      return;
    }
  }
#line 1313
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 1314
    text_len = (png_size_t )0;
  } else
#line 1313
  if ((int )*text == 0) {
#line 1314
    text_len = (png_size_t )0;
  } else {
    {
#line 1316
    text_len = strlen((char const   *)text);
    }
  }
  {
#line 1319
  png_write_chunk_start(png_ptr, (png_bytep )(png_tEXt), (key_len + text_len) + 1UL);
#line 1326
  png_write_chunk_data(png_ptr, (png_bytep )new_key, key_len + 1UL);
  }
#line 1327
  if (text_len) {
    {
#line 1328
    png_write_chunk_data(png_ptr, (png_bytep )text, text_len);
    }
  }
  {
#line 1330
  png_write_chunk_end(png_ptr);
#line 1331
  png_free(png_ptr, (png_voidp )new_key);
  }
#line 1332
  return;
}
}
#line 1337 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_zTXt(png_structp png_ptr , png_charp key , png_charp text , png_size_t text_len ,
                    int compression ) 
{ 
  png_size_t key_len ;
  char buf___1[1] ;
  png_charp new_key ;
  compression_state comp ;
  int tmp ;

  {
#line 1351
  comp.num_output_ptr = 0;
#line 1352
  comp.max_output_ptr = 0;
#line 1353
  comp.output_ptr = (png_charpp )((void *)0);
#line 1354
  comp.input = (char *)((void *)0);
#line 1355
  comp.input_len = 0;
#line 1357
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 1359
    png_warning(png_ptr, "Empty keyword in zTXt chunk");
    }
#line 1360
    return;
  } else {
    {
#line 1357
    key_len = png_check_keyword(png_ptr, key, & new_key);
    }
#line 1357
    if (key_len == 0UL) {
      {
#line 1359
      png_warning(png_ptr, "Empty keyword in zTXt chunk");
      }
#line 1360
      return;
    }
  }
#line 1363
  if ((unsigned long )text == (unsigned long )((void *)0)) {
    {
#line 1365
    png_write_tEXt(png_ptr, new_key, text, (png_size_t )0);
#line 1366
    png_free(png_ptr, (png_voidp )new_key);
    }
#line 1367
    return;
  } else
#line 1363
  if ((int )*text == 0) {
    {
#line 1365
    png_write_tEXt(png_ptr, new_key, text, (png_size_t )0);
#line 1366
    png_free(png_ptr, (png_voidp )new_key);
    }
#line 1367
    return;
  } else
#line 1363
  if (compression == -1) {
    {
#line 1365
    png_write_tEXt(png_ptr, new_key, text, (png_size_t )0);
#line 1366
    png_free(png_ptr, (png_voidp )new_key);
    }
#line 1367
    return;
  }
  {
#line 1370
  text_len = strlen((char const   *)text);
#line 1372
  png_free(png_ptr, (png_voidp )new_key);
#line 1375
  tmp = png_text_compress(png_ptr, text, text_len, compression, & comp);
#line 1375
  text_len = (png_size_t )tmp;
#line 1379
  png_write_chunk_start(png_ptr, (png_bytep )(png_zTXt), (key_len + text_len) + 2UL);
#line 1382
  png_write_chunk_data(png_ptr, (png_bytep )key, key_len + 1UL);
#line 1383
  buf___1[0] = (char )((png_byte )compression);
#line 1385
  png_write_chunk_data(png_ptr, (png_bytep )(buf___1), (png_size_t )1);
#line 1387
  png_write_compressed_data_out(png_ptr, & comp);
#line 1390
  png_write_chunk_end(png_ptr);
  }
#line 1391
  return;
}
}
#line 1485 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_oFFs(png_structp png_ptr , png_int_32 x_offset , png_int_32 y_offset ,
                    int unit_type ) 
{ 
  png_byte buf___1[9] ;

  {
#line 1495
  if (unit_type >= 2) {
    {
#line 1496
    png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");
    }
  }
  {
#line 1498
  png_save_int_32(buf___1, x_offset);
#line 1499
  png_save_int_32(buf___1 + 4, y_offset);
#line 1500
  buf___1[8] = (png_byte )unit_type;
#line 1502
  png_write_chunk(png_ptr, (png_bytep )(png_oFFs), buf___1, (png_size_t )9);
  }
#line 1503
  return;
}
}
#line 1508 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_pCAL(png_structp png_ptr , png_charp purpose , png_int_32 X0 , png_int_32 X1 ,
                    int type , int nparams , png_charp units , png_charpp params ) 
{ 
  png_size_t purpose_len ;
  png_size_t units_len ;
  png_size_t total_len ;
  png_uint_32p params_len ;
  png_byte buf___1[10] ;
  png_charp new_purpose ;
  int i ;
  png_size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  png_voidp tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 1522
  if (type >= 4) {
    {
#line 1523
    png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
    }
  }
  {
#line 1525
  tmp = png_check_keyword(png_ptr, purpose, & new_purpose);
#line 1525
  purpose_len = tmp + 1UL;
#line 1527
  tmp___0 = strlen((char const   *)units);
  }
#line 1527
  if (nparams == 0) {
#line 1527
    tmp___1 = 0;
  } else {
#line 1527
    tmp___1 = 1;
  }
  {
#line 1527
  units_len = tmp___0 + (size_t )tmp___1;
#line 1529
  total_len = (purpose_len + units_len) + 10UL;
#line 1531
  tmp___2 = png_malloc(png_ptr, (unsigned long )nparams * sizeof(png_uint_32 ));
#line 1531
  params_len = (png_uint_32p )tmp___2;
#line 1536
  i = 0;
  }
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1536
    if (! (i < nparams)) {
#line 1536
      goto while_break;
    }
    {
#line 1538
    tmp___3 = strlen((char const   *)*(params + i));
    }
#line 1538
    if (i == nparams - 1) {
#line 1538
      tmp___4 = 0;
    } else {
#line 1538
      tmp___4 = 1;
    }
#line 1538
    *(params_len + i) = tmp___3 + (size_t )tmp___4;
#line 1540
    total_len += *(params_len + i);
#line 1536
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1544
  png_write_chunk_start(png_ptr, (png_bytep )(png_pCAL), total_len);
#line 1545
  png_write_chunk_data(png_ptr, (png_bytep )new_purpose, purpose_len);
#line 1546
  png_save_int_32(buf___1, X0);
#line 1547
  png_save_int_32(buf___1 + 4, X1);
#line 1548
  buf___1[8] = (png_byte )type;
#line 1549
  buf___1[9] = (png_byte )nparams;
#line 1550
  png_write_chunk_data(png_ptr, buf___1, (png_size_t )10);
#line 1551
  png_write_chunk_data(png_ptr, (png_bytep )units, units_len);
#line 1553
  png_free(png_ptr, (png_voidp )new_purpose);
#line 1555
  i = 0;
  }
  {
#line 1555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1555
    if (! (i < nparams)) {
#line 1555
      goto while_break___0;
    }
    {
#line 1557
    png_write_chunk_data(png_ptr, (png_bytep )*(params + i), *(params_len + i));
#line 1555
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1561
  png_free(png_ptr, (png_voidp )params_len);
#line 1562
  png_write_chunk_end(png_ptr);
  }
#line 1563
  return;
}
}
#line 1608 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_sCAL_s(png_structp png_ptr , int unit , png_charp width , png_charp height ) 
{ 
  png_byte buf___1[64] ;
  png_size_t wlen ;
  png_size_t hlen ;
  png_size_t total_len ;

  {
  {
#line 1620
  wlen = strlen((char const   *)width);
#line 1621
  hlen = strlen((char const   *)height);
#line 1622
  total_len = (wlen + hlen) + 2UL;
  }
#line 1623
  if (total_len > 64UL) {
    {
#line 1625
    png_warning(png_ptr, "Can\'t write sCAL (buffer too small)");
    }
#line 1626
    return;
  }
  {
#line 1629
  buf___1[0] = (png_byte )unit;
#line 1630
  memcpy((void */* __restrict  */)(buf___1 + 1), (void const   */* __restrict  */)width,
         wlen + 1UL);
#line 1631
  memcpy((void */* __restrict  */)((buf___1 + wlen) + 2), (void const   */* __restrict  */)height,
         hlen);
#line 1634
  png_write_chunk(png_ptr, (png_bytep )(png_sCAL), buf___1, total_len);
  }
#line 1635
  return;
}
}
#line 1642 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_pHYs(png_structp png_ptr , png_uint_32 x_pixels_per_unit , png_uint_32 y_pixels_per_unit ,
                    int unit_type ) 
{ 
  png_byte buf___1[9] ;

  {
#line 1653
  if (unit_type >= 2) {
    {
#line 1654
    png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");
    }
  }
  {
#line 1656
  png_save_uint_32(buf___1, x_pixels_per_unit);
#line 1657
  png_save_uint_32(buf___1 + 4, y_pixels_per_unit);
#line 1658
  buf___1[8] = (png_byte )unit_type;
#line 1660
  png_write_chunk(png_ptr, (png_bytep )(png_pHYs), buf___1, (png_size_t )9);
  }
#line 1661
  return;
}
}
#line 1668 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_tIME(png_structp png_ptr , png_timep mod_time ) 
{ 
  png_byte buf___1[7] ;

  {
#line 1677
  if ((int )mod_time->month > 12) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  } else
#line 1677
  if ((int )mod_time->month < 1) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  } else
#line 1677
  if ((int )mod_time->day > 31) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  } else
#line 1677
  if ((int )mod_time->day < 1) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  } else
#line 1677
  if ((int )mod_time->hour > 23) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  } else
#line 1677
  if ((int )mod_time->second > 60) {
    {
#line 1681
    png_warning(png_ptr, "Invalid time specified for tIME chunk");
    }
#line 1682
    return;
  }
  {
#line 1685
  png_save_uint_16(buf___1, (unsigned int )mod_time->year);
#line 1686
  buf___1[2] = mod_time->month;
#line 1687
  buf___1[3] = mod_time->day;
#line 1688
  buf___1[4] = mod_time->hour;
#line 1689
  buf___1[5] = mod_time->minute;
#line 1690
  buf___1[6] = mod_time->second;
#line 1692
  png_write_chunk(png_ptr, (png_bytep )(png_tIME), buf___1, (png_size_t )7);
  }
#line 1693
  return;
}
}
#line 1697 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_start_row(png_structp png_ptr ) 
{ 
  png_size_t buf_size ;
  png_uint_32 tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;
  png_voidp tmp___2 ;
  png_voidp tmp___3 ;
  png_voidp tmp___4 ;
  png_voidp tmp___5 ;

  {
#line 1719
  if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 1719
    tmp = png_ptr->width * ((png_uint_32 )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
  } else {
#line 1719
    tmp = (png_ptr->width * (png_uint_32 )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
  }
  {
#line 1719
  buf_size = tmp + 1UL;
#line 1723
  tmp___0 = png_malloc(png_ptr, buf_size);
#line 1723
  png_ptr->row_buf = (png_bytep )tmp___0;
#line 1724
  *(png_ptr->row_buf + 0) = (png_byte )0;
  }
#line 1727
  if ((int )png_ptr->do_filter & 16) {
    {
#line 1729
    tmp___1 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1729
    png_ptr->sub_row = (png_bytep )tmp___1;
#line 1731
    *(png_ptr->sub_row + 0) = (png_byte )1;
    }
  }
#line 1735
  if ((int )png_ptr->do_filter & 224) {
    {
#line 1738
    tmp___2 = png_malloc(png_ptr, buf_size);
#line 1738
    png_ptr->prev_row = (png_bytep )tmp___2;
#line 1739
    memset((void *)png_ptr->prev_row, 0, buf_size);
    }
#line 1741
    if ((int )png_ptr->do_filter & 32) {
      {
#line 1743
      tmp___3 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1743
      png_ptr->up_row = (png_bytep )tmp___3;
#line 1745
      *(png_ptr->up_row + 0) = (png_byte )2;
      }
    }
#line 1748
    if ((int )png_ptr->do_filter & 64) {
      {
#line 1750
      tmp___4 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1750
      png_ptr->avg_row = (png_bytep )tmp___4;
#line 1752
      *(png_ptr->avg_row + 0) = (png_byte )3;
      }
    }
#line 1755
    if ((int )png_ptr->do_filter & 128) {
      {
#line 1757
      tmp___5 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1757
      png_ptr->paeth_row = (png_bytep )tmp___5;
#line 1759
      *(png_ptr->paeth_row + 0) = (png_byte )4;
      }
    }
  }
#line 1765
  if (png_ptr->interlaced) {
#line 1767
    if (! (png_ptr->transformations & 2UL)) {
#line 1769
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[0]) - 1UL) - (png_uint_32 )png_pass_ystart[0]) / (png_uint_32 )png_pass_yinc[0];
#line 1771
      png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc[0]) - 1UL) - (png_uint_32 )png_pass_start[0]) / (png_uint_32 )png_pass_inc[0];
    } else {
#line 1776
      png_ptr->num_rows = png_ptr->height;
#line 1777
      png_ptr->usr_width = png_ptr->width;
    }
  } else {
#line 1783
    png_ptr->num_rows = png_ptr->height;
#line 1784
    png_ptr->usr_width = png_ptr->width;
  }
#line 1786
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 1787
  png_ptr->zstream.next_out = png_ptr->zbuf;
#line 1788
  return;
}
}
#line 1791 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_finish_row(png_structp png_ptr ) 
{ 
  int ret ;
  png_uint_32 tmp ;

  {
#line 1814
  (png_ptr->row_number) ++;
#line 1817
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 1818
    return;
  }
#line 1822
  if (png_ptr->interlaced) {
#line 1824
    png_ptr->row_number = (png_uint_32 )0;
#line 1825
    if (png_ptr->transformations & 2UL) {
#line 1827
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
    } else {
      {
#line 1832
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1834
        png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 1835
        if ((int )png_ptr->pass >= 7) {
#line 1836
          goto while_break;
        }
#line 1837
        png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc[png_ptr->pass]) - 1UL) - (png_uint_32 )png_pass_start[png_ptr->pass]) / (png_uint_32 )png_pass_inc[png_ptr->pass];
#line 1841
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[png_ptr->pass]) - 1UL) - (png_uint_32 )png_pass_ystart[png_ptr->pass]) / (png_uint_32 )png_pass_yinc[png_ptr->pass];
#line 1845
        if (png_ptr->transformations & 2UL) {
#line 1846
          goto while_break;
        }
#line 1832
        if (! (png_ptr->usr_width == 0UL)) {
#line 1832
          if (! (png_ptr->num_rows == 0UL)) {
#line 1832
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1852
    if ((int )png_ptr->pass < 7) {
#line 1854
      if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 1855
        if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 1855
          tmp = png_ptr->width * ((png_uint_32 )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
        } else {
#line 1855
          tmp = (png_ptr->width * (png_uint_32 )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
        }
        {
#line 1855
        memset((void *)png_ptr->prev_row, 0, tmp + 1UL);
        }
      }
#line 1858
      return;
    }
  }
  {
#line 1865
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1868
    ret = deflate(& png_ptr->zstream, 4);
    }
#line 1870
    if (ret == 0) {
#line 1873
      if (! png_ptr->zstream.avail_out) {
        {
#line 1875
        png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
#line 1876
        png_ptr->zstream.next_out = png_ptr->zbuf;
#line 1877
        png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
        }
      }
    } else
#line 1880
    if (ret != 1) {
#line 1882
      if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
        {
#line 1883
        png_error(png_ptr, (png_const_charp )png_ptr->zstream.msg);
        }
      } else {
        {
#line 1885
        png_error(png_ptr, "zlib error");
        }
      }
    }
#line 1865
    if (! (ret != 1)) {
#line 1865
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1890
  if ((png_size_t )png_ptr->zstream.avail_out < png_ptr->zbuf_size) {
    {
#line 1892
    png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out);
    }
  }
  {
#line 1896
  deflateReset(& png_ptr->zstream);
#line 1897
  png_ptr->zstream.data_type = 0;
  }
#line 1898
  return;
}
}
#line 1908 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) 
{ 
  png_bytep sp___0 ;
  png_bytep dp ;
  int shift ;
  int d ;
  int value ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  int shift___0 ;
  int d___0 ;
  int value___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_bytep tmp___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  int shift___1 ;
  int d___1 ;
  int value___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_bytep tmp___1 ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_size_t pixel_bytes ;

  {
#line 1926
  if (pass < 6) {
    {
#line 1932
    if ((int )row_info->pixel_depth == 1) {
#line 1932
      goto case_1;
    }
#line 1966
    if ((int )row_info->pixel_depth == 2) {
#line 1966
      goto case_2;
    }
#line 1999
    if ((int )row_info->pixel_depth == 4) {
#line 1999
      goto case_4;
    }
#line 2032
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1940
    row_width = row_info->width;
#line 1942
    dp = row;
#line 1943
    d = 0;
#line 1944
    shift = 7;
#line 1945
    i = (png_uint_32 )png_pass_start[pass];
    {
#line 1945
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1945
      if (! (i < row_width)) {
#line 1945
        goto while_break;
      }
#line 1948
      sp___0 = row + (i >> 3);
#line 1949
      value = ((int )*sp___0 >> (7 - (int )(i & 7UL))) & 1;
#line 1950
      d |= value << shift;
#line 1952
      if (shift == 0) {
#line 1954
        shift = 7;
#line 1955
        tmp = dp;
#line 1955
        dp ++;
#line 1955
        *tmp = (png_byte )d;
#line 1956
        d = 0;
      } else {
#line 1959
        shift --;
      }
#line 1945
      i += (png_uint_32 )png_pass_inc[pass];
    }
    while_break: /* CIL Label */ ;
    }
#line 1962
    if (shift != 7) {
#line 1963
      *dp = (png_byte )d;
    }
#line 1964
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1974
    row_width___0 = row_info->width;
#line 1976
    dp___0 = row;
#line 1977
    shift___0 = 6;
#line 1978
    d___0 = 0;
#line 1979
    i___0 = (png_uint_32 )png_pass_start[pass];
    {
#line 1979
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1979
      if (! (i___0 < row_width___0)) {
#line 1979
        goto while_break___0;
      }
#line 1982
      sp___1 = row + (i___0 >> 2);
#line 1983
      value___0 = ((int )*sp___1 >> ((3 - (int )(i___0 & 3UL)) << 1)) & 3;
#line 1984
      d___0 |= value___0 << shift___0;
#line 1986
      if (shift___0 == 0) {
#line 1988
        shift___0 = 6;
#line 1989
        tmp___0 = dp___0;
#line 1989
        dp___0 ++;
#line 1989
        *tmp___0 = (png_byte )d___0;
#line 1990
        d___0 = 0;
      } else {
#line 1993
        shift___0 -= 2;
      }
#line 1979
      i___0 += (png_uint_32 )png_pass_inc[pass];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1995
    if (shift___0 != 6) {
#line 1996
      *dp___0 = (png_byte )d___0;
    }
#line 1997
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2007
    row_width___1 = row_info->width;
#line 2009
    dp___1 = row;
#line 2010
    shift___1 = 4;
#line 2011
    d___1 = 0;
#line 2012
    i___1 = (png_uint_32 )png_pass_start[pass];
    {
#line 2012
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2012
      if (! (i___1 < row_width___1)) {
#line 2012
        goto while_break___1;
      }
#line 2015
      sp___2 = row + (i___1 >> 1);
#line 2016
      value___1 = ((int )*sp___2 >> ((1 - (int )(i___1 & 1UL)) << 2)) & 15;
#line 2017
      d___1 |= value___1 << shift___1;
#line 2019
      if (shift___1 == 0) {
#line 2021
        shift___1 = 4;
#line 2022
        tmp___1 = dp___1;
#line 2022
        dp___1 ++;
#line 2022
        *tmp___1 = (png_byte )d___1;
#line 2023
        d___1 = 0;
      } else {
#line 2026
        shift___1 -= 4;
      }
#line 2012
      i___1 += (png_uint_32 )png_pass_inc[pass];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2028
    if (shift___1 != 4) {
#line 2029
      *dp___1 = (png_byte )d___1;
    }
#line 2030
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2037
    row_width___2 = row_info->width;
#line 2041
    dp___2 = row;
#line 2043
    pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 2046
    i___2 = (png_uint_32 )png_pass_start[pass];
    {
#line 2046
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2046
      if (! (i___2 < row_width___2)) {
#line 2046
        goto while_break___2;
      }
#line 2050
      sp___3 = row + i___2 * pixel_bytes;
#line 2052
      if ((unsigned long )dp___2 != (unsigned long )sp___3) {
        {
#line 2053
        memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)sp___3,
               pixel_bytes);
        }
      }
#line 2055
      dp___2 += pixel_bytes;
#line 2046
      i___2 += (png_uint_32 )png_pass_inc[pass];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2057
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2061
    row_info->width = (((row_info->width + (png_uint_32 )png_pass_inc[pass]) - 1UL) - (png_uint_32 )png_pass_start[pass]) / (png_uint_32 )png_pass_inc[pass];
#line 2065
    if ((int )row_info->pixel_depth >= 8) {
#line 2065
      row_info->rowbytes = row_info->width * ((png_uint_32 )row_info->pixel_depth >> 3);
    } else {
#line 2065
      row_info->rowbytes = (row_info->width * (png_uint_32 )row_info->pixel_depth + 7UL) >> 3;
    }
  }
#line 2068
  return;
}
}
#line 2079 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_find_filter(png_structp png_ptr , png_row_infop row_info ) 
{ 
  png_bytep prev_row ;
  png_bytep best_row ;
  png_bytep row_buf ;
  png_uint_32 mins ;
  png_uint_32 bpp ;
  png_byte filter_to_do ;
  png_uint_32 row_bytes ;
  png_bytep rp ;
  png_uint_32 sum ;
  png_uint_32 i ;
  int v ;
  int tmp ;
  png_bytep rp___0 ;
  png_bytep lp ;
  png_bytep dp ;
  png_uint_32 i___0 ;
  png_bytep rp___1 ;
  png_bytep dp___0 ;
  png_bytep lp___0 ;
  png_uint_32 sum___0 ;
  png_uint_32 lmins ;
  png_uint_32 i___1 ;
  int v___0 ;
  png_byte tmp___0 ;
  int tmp___1 ;
  png_byte tmp___2 ;
  int tmp___3 ;
  png_bytep rp___2 ;
  png_bytep dp___1 ;
  png_bytep pp ;
  png_uint_32 i___2 ;
  png_bytep rp___3 ;
  png_bytep dp___2 ;
  png_bytep pp___0 ;
  png_uint_32 sum___1 ;
  png_uint_32 lmins___0 ;
  png_uint_32 i___3 ;
  int v___1 ;
  png_bytep tmp___4 ;
  png_byte tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  int tmp___8 ;
  png_bytep rp___4 ;
  png_bytep dp___3 ;
  png_bytep pp___1 ;
  png_bytep lp___1 ;
  png_uint_32 i___4 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep tmp___11 ;
  png_bytep tmp___12 ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep rp___5 ;
  png_bytep dp___4 ;
  png_bytep pp___2 ;
  png_bytep lp___2 ;
  png_uint_32 sum___2 ;
  png_uint_32 lmins___1 ;
  png_uint_32 i___5 ;
  int v___2 ;
  png_bytep tmp___16 ;
  png_byte tmp___17 ;
  png_bytep tmp___18 ;
  png_bytep tmp___19 ;
  int tmp___20 ;
  png_bytep tmp___21 ;
  png_byte tmp___22 ;
  png_bytep tmp___23 ;
  png_bytep tmp___24 ;
  png_bytep tmp___25 ;
  int tmp___26 ;
  png_bytep rp___6 ;
  png_bytep dp___5 ;
  png_bytep pp___3 ;
  png_bytep cp ;
  png_bytep lp___3 ;
  png_uint_32 i___6 ;
  png_bytep tmp___27 ;
  png_bytep tmp___28 ;
  png_bytep tmp___29 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___30 ;
  png_bytep tmp___31 ;
  png_bytep tmp___32 ;
  int tmp___33 ;
  png_bytep tmp___34 ;
  png_bytep tmp___35 ;
  png_bytep rp___7 ;
  png_bytep dp___6 ;
  png_bytep pp___4 ;
  png_bytep cp___0 ;
  png_bytep lp___4 ;
  png_uint_32 sum___3 ;
  png_uint_32 lmins___2 ;
  png_uint_32 i___7 ;
  int v___3 ;
  png_bytep tmp___36 ;
  png_byte tmp___37 ;
  png_bytep tmp___38 ;
  png_bytep tmp___39 ;
  int tmp___40 ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int pa___0 ;
  int pb___0 ;
  int pc___0 ;
  int p___0 ;
  png_bytep tmp___41 ;
  png_bytep tmp___42 ;
  png_bytep tmp___43 ;
  int tmp___44 ;
  png_bytep tmp___45 ;
  png_byte tmp___46 ;
  png_bytep tmp___47 ;
  int tmp___48 ;

  {
#line 2084
  filter_to_do = png_ptr->do_filter;
#line 2085
  row_bytes = row_info->rowbytes;
#line 2092
  bpp = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2094
  prev_row = png_ptr->prev_row;
#line 2095
  row_buf = png_ptr->row_buf;
#line 2095
  best_row = row_buf;
#line 2096
  mins = 0xffffffffffffffffUL >> 1;
#line 2123
  if ((int )filter_to_do & 8) {
#line 2123
    if ((int )filter_to_do != 8) {
#line 2127
      sum = (png_uint_32 )0;
#line 2131
      i = (png_uint_32 )0;
#line 2131
      rp = row_buf + 1;
      {
#line 2131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2131
        if (! (i < row_bytes)) {
#line 2131
          goto while_break;
        }
#line 2133
        v = (int )*rp;
#line 2134
        if (v < 128) {
#line 2134
          tmp = v;
        } else {
#line 2134
          tmp = 256 - v;
        }
#line 2134
        sum += (png_uint_32 )tmp;
#line 2131
        i ++;
#line 2131
        rp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2172
      mins = sum;
    }
  }
#line 2176
  if ((int )filter_to_do == 16) {
#line 2181
    i___0 = (png_uint_32 )0;
#line 2181
    rp___0 = row_buf + 1;
#line 2181
    dp = png_ptr->sub_row + 1;
    {
#line 2181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2181
      if (! (i___0 < bpp)) {
#line 2181
        goto while_break___0;
      }
#line 2184
      *dp = *rp___0;
#line 2181
      i___0 ++;
#line 2181
      rp___0 ++;
#line 2181
      dp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2186
    lp = row_buf + 1;
    {
#line 2186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2186
      if (! (i___0 < row_bytes)) {
#line 2186
        goto while_break___1;
      }
#line 2189
      *dp = (png_byte )(((int )*rp___0 - (int )*lp) & 255);
#line 2186
      i___0 ++;
#line 2186
      rp___0 ++;
#line 2186
      lp ++;
#line 2186
      dp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2191
    best_row = png_ptr->sub_row;
  } else
#line 2194
  if ((int )filter_to_do & 16) {
#line 2197
    sum___0 = (png_uint_32 )0;
#line 2197
    lmins = mins;
#line 2236
    i___1 = (png_uint_32 )0;
#line 2236
    rp___1 = row_buf + 1;
#line 2236
    dp___0 = png_ptr->sub_row + 1;
    {
#line 2236
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2236
      if (! (i___1 < bpp)) {
#line 2236
        goto while_break___2;
      }
#line 2239
      tmp___0 = *rp___1;
#line 2239
      *dp___0 = tmp___0;
#line 2239
      v___0 = (int )tmp___0;
#line 2241
      if (v___0 < 128) {
#line 2241
        tmp___1 = v___0;
      } else {
#line 2241
        tmp___1 = 256 - v___0;
      }
#line 2241
      sum___0 += (png_uint_32 )tmp___1;
#line 2236
      i___1 ++;
#line 2236
      rp___1 ++;
#line 2236
      dp___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2243
    lp___0 = row_buf + 1;
    {
#line 2243
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2243
      if (! (i___1 < row_bytes)) {
#line 2243
        goto while_break___3;
      }
#line 2246
      tmp___2 = (png_byte )(((int )*rp___1 - (int )*lp___0) & 255);
#line 2246
      *dp___0 = tmp___2;
#line 2246
      v___0 = (int )tmp___2;
#line 2248
      if (v___0 < 128) {
#line 2248
        tmp___3 = v___0;
      } else {
#line 2248
        tmp___3 = 256 - v___0;
      }
#line 2248
      sum___0 += (png_uint_32 )tmp___3;
#line 2250
      if (sum___0 > lmins) {
#line 2251
        goto while_break___3;
      }
#line 2243
      i___1 ++;
#line 2243
      rp___1 ++;
#line 2243
      lp___0 ++;
#line 2243
      dp___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2285
    if (sum___0 < mins) {
#line 2287
      mins = sum___0;
#line 2288
      best_row = png_ptr->sub_row;
    }
  }
#line 2293
  if ((int )filter_to_do == 32) {
#line 2298
    i___2 = (png_uint_32 )0;
#line 2298
    rp___2 = row_buf + 1;
#line 2298
    dp___1 = png_ptr->up_row + 1;
#line 2298
    pp = prev_row + 1;
    {
#line 2298
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2298
      if (! (i___2 < row_bytes)) {
#line 2298
        goto while_break___4;
      }
#line 2302
      *dp___1 = (png_byte )(((int )*rp___2 - (int )*pp) & 255);
#line 2298
      i___2 ++;
#line 2298
      rp___2 ++;
#line 2298
      pp ++;
#line 2298
      dp___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2304
    best_row = png_ptr->up_row;
  } else
#line 2307
  if ((int )filter_to_do & 32) {
#line 2310
    sum___1 = (png_uint_32 )0;
#line 2310
    lmins___0 = mins;
#line 2346
    i___3 = (png_uint_32 )0;
#line 2346
    rp___3 = row_buf + 1;
#line 2346
    dp___2 = png_ptr->up_row + 1;
#line 2346
    pp___0 = prev_row + 1;
    {
#line 2346
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2346
      if (! (i___3 < row_bytes)) {
#line 2346
        goto while_break___5;
      }
#line 2349
      tmp___4 = dp___2;
#line 2349
      dp___2 ++;
#line 2349
      tmp___6 = rp___3;
#line 2349
      rp___3 ++;
#line 2349
      tmp___7 = pp___0;
#line 2349
      pp___0 ++;
#line 2349
      tmp___5 = (png_byte )(((int )*tmp___6 - (int )*tmp___7) & 255);
#line 2349
      *tmp___4 = tmp___5;
#line 2349
      v___1 = (int )tmp___5;
#line 2351
      if (v___1 < 128) {
#line 2351
        tmp___8 = v___1;
      } else {
#line 2351
        tmp___8 = 256 - v___1;
      }
#line 2351
      sum___1 += (png_uint_32 )tmp___8;
#line 2353
      if (sum___1 > lmins___0) {
#line 2354
        goto while_break___5;
      }
#line 2346
      i___3 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2388
    if (sum___1 < mins) {
#line 2390
      mins = sum___1;
#line 2391
      best_row = png_ptr->up_row;
    }
  }
#line 2396
  if ((int )filter_to_do == 64) {
#line 2400
    i___4 = (png_uint_32 )0;
#line 2400
    rp___4 = row_buf + 1;
#line 2400
    dp___3 = png_ptr->avg_row + 1;
#line 2400
    pp___1 = prev_row + 1;
    {
#line 2400
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2400
      if (! (i___4 < bpp)) {
#line 2400
        goto while_break___6;
      }
#line 2403
      tmp___9 = dp___3;
#line 2403
      dp___3 ++;
#line 2403
      tmp___10 = rp___4;
#line 2403
      rp___4 ++;
#line 2403
      tmp___11 = pp___1;
#line 2403
      pp___1 ++;
#line 2403
      *tmp___9 = (png_byte )(((int )*tmp___10 - (int )*tmp___11 / 2) & 255);
#line 2400
      i___4 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2405
    lp___1 = row_buf + 1;
    {
#line 2405
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2405
      if (! (i___4 < row_bytes)) {
#line 2405
        goto while_break___7;
      }
#line 2407
      tmp___12 = dp___3;
#line 2407
      dp___3 ++;
#line 2407
      tmp___13 = rp___4;
#line 2407
      rp___4 ++;
#line 2407
      tmp___14 = pp___1;
#line 2407
      pp___1 ++;
#line 2407
      tmp___15 = lp___1;
#line 2407
      lp___1 ++;
#line 2407
      *tmp___12 = (png_byte )(((int )*tmp___13 - ((int )*tmp___14 + (int )*tmp___15) / 2) & 255);
#line 2405
      i___4 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2410
    best_row = png_ptr->avg_row;
  } else
#line 2413
  if ((int )filter_to_do & 64) {
#line 2416
    sum___2 = (png_uint_32 )0;
#line 2416
    lmins___1 = mins;
#line 2451
    i___5 = (png_uint_32 )0;
#line 2451
    rp___5 = row_buf + 1;
#line 2451
    dp___4 = png_ptr->avg_row + 1;
#line 2451
    pp___2 = prev_row + 1;
    {
#line 2451
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2451
      if (! (i___5 < bpp)) {
#line 2451
        goto while_break___8;
      }
#line 2454
      tmp___16 = dp___4;
#line 2454
      dp___4 ++;
#line 2454
      tmp___18 = rp___5;
#line 2454
      rp___5 ++;
#line 2454
      tmp___19 = pp___2;
#line 2454
      pp___2 ++;
#line 2454
      tmp___17 = (png_byte )(((int )*tmp___18 - (int )*tmp___19 / 2) & 255);
#line 2454
      *tmp___16 = tmp___17;
#line 2454
      v___2 = (int )tmp___17;
#line 2456
      if (v___2 < 128) {
#line 2456
        tmp___20 = v___2;
      } else {
#line 2456
        tmp___20 = 256 - v___2;
      }
#line 2456
      sum___2 += (png_uint_32 )tmp___20;
#line 2451
      i___5 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2458
    lp___2 = row_buf + 1;
    {
#line 2458
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2458
      if (! (i___5 < row_bytes)) {
#line 2458
        goto while_break___9;
      }
#line 2460
      tmp___21 = dp___4;
#line 2460
      dp___4 ++;
#line 2460
      tmp___23 = rp___5;
#line 2460
      rp___5 ++;
#line 2460
      tmp___24 = pp___2;
#line 2460
      pp___2 ++;
#line 2460
      tmp___25 = lp___2;
#line 2460
      lp___2 ++;
#line 2460
      tmp___22 = (png_byte )(((int )*tmp___23 - ((int )*tmp___24 + (int )*tmp___25) / 2) & 255);
#line 2460
      *tmp___21 = tmp___22;
#line 2460
      v___2 = (int )tmp___22;
#line 2463
      if (v___2 < 128) {
#line 2463
        tmp___26 = v___2;
      } else {
#line 2463
        tmp___26 = 256 - v___2;
      }
#line 2463
      sum___2 += (png_uint_32 )tmp___26;
#line 2465
      if (sum___2 > lmins___1) {
#line 2466
        goto while_break___9;
      }
#line 2458
      i___5 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2500
    if (sum___2 < mins) {
#line 2502
      mins = sum___2;
#line 2503
      best_row = png_ptr->avg_row;
    }
  }
#line 2508
  if ((int )filter_to_do == 128) {
#line 2512
    i___6 = (png_uint_32 )0;
#line 2512
    rp___6 = row_buf + 1;
#line 2512
    dp___5 = png_ptr->paeth_row + 1;
#line 2512
    pp___3 = prev_row + 1;
    {
#line 2512
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2512
      if (! (i___6 < bpp)) {
#line 2512
        goto while_break___10;
      }
#line 2515
      tmp___27 = dp___5;
#line 2515
      dp___5 ++;
#line 2515
      tmp___28 = rp___6;
#line 2515
      rp___6 ++;
#line 2515
      tmp___29 = pp___3;
#line 2515
      pp___3 ++;
#line 2515
      *tmp___27 = (png_byte )(((int )*tmp___28 - (int )*tmp___29) & 255);
#line 2512
      i___6 ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2518
    lp___3 = row_buf + 1;
#line 2518
    cp = prev_row + 1;
    {
#line 2518
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2518
      if (! (i___6 < row_bytes)) {
#line 2518
        goto while_break___11;
      }
#line 2522
      tmp___30 = pp___3;
#line 2522
      pp___3 ++;
#line 2522
      b = (int )*tmp___30;
#line 2523
      tmp___31 = cp;
#line 2523
      cp ++;
#line 2523
      c = (int )*tmp___31;
#line 2524
      tmp___32 = lp___3;
#line 2524
      lp___3 ++;
#line 2524
      a = (int )*tmp___32;
#line 2526
      p = b - c;
#line 2527
      pc = a - c;
#line 2534
      if (p < 0) {
#line 2534
        pa = - p;
      } else {
#line 2534
        pa = p;
      }
#line 2535
      if (pc < 0) {
#line 2535
        pb = - pc;
      } else {
#line 2535
        pb = pc;
      }
#line 2536
      if (p + pc < 0) {
#line 2536
        pc = - (p + pc);
      } else {
#line 2536
        pc = p + pc;
      }
#line 2539
      if (pa <= pb) {
#line 2539
        if (pa <= pc) {
#line 2539
          p = a;
        } else {
#line 2539
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 2539
        if (pb <= pc) {
#line 2539
          tmp___33 = b;
        } else {
#line 2539
          tmp___33 = c;
        }
#line 2539
        p = tmp___33;
      }
#line 2541
      tmp___34 = dp___5;
#line 2541
      dp___5 ++;
#line 2541
      tmp___35 = rp___6;
#line 2541
      rp___6 ++;
#line 2541
      *tmp___34 = (png_byte )(((int )*tmp___35 - p) & 255);
#line 2518
      i___6 ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2543
    best_row = png_ptr->paeth_row;
  } else
#line 2546
  if ((int )filter_to_do & 128) {
#line 2549
    sum___3 = (png_uint_32 )0;
#line 2549
    lmins___2 = mins;
#line 2584
    i___7 = (png_uint_32 )0;
#line 2584
    rp___7 = row_buf + 1;
#line 2584
    dp___6 = png_ptr->paeth_row + 1;
#line 2584
    pp___4 = prev_row + 1;
    {
#line 2584
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2584
      if (! (i___7 < bpp)) {
#line 2584
        goto while_break___12;
      }
#line 2587
      tmp___36 = dp___6;
#line 2587
      dp___6 ++;
#line 2587
      tmp___38 = rp___7;
#line 2587
      rp___7 ++;
#line 2587
      tmp___39 = pp___4;
#line 2587
      pp___4 ++;
#line 2587
      tmp___37 = (png_byte )(((int )*tmp___38 - (int )*tmp___39) & 255);
#line 2587
      *tmp___36 = tmp___37;
#line 2587
      v___3 = (int )tmp___37;
#line 2589
      if (v___3 < 128) {
#line 2589
        tmp___40 = v___3;
      } else {
#line 2589
        tmp___40 = 256 - v___3;
      }
#line 2589
      sum___3 += (png_uint_32 )tmp___40;
#line 2584
      i___7 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2592
    lp___4 = row_buf + 1;
#line 2592
    cp___0 = prev_row + 1;
    {
#line 2592
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2592
      if (! (i___7 < row_bytes)) {
#line 2592
        goto while_break___13;
      }
#line 2596
      tmp___41 = pp___4;
#line 2596
      pp___4 ++;
#line 2596
      b___0 = (int )*tmp___41;
#line 2597
      tmp___42 = cp___0;
#line 2597
      cp___0 ++;
#line 2597
      c___0 = (int )*tmp___42;
#line 2598
      tmp___43 = lp___4;
#line 2598
      lp___4 ++;
#line 2598
      a___0 = (int )*tmp___43;
#line 2601
      p___0 = b___0 - c___0;
#line 2602
      pc___0 = a___0 - c___0;
#line 2608
      if (p___0 < 0) {
#line 2608
        pa___0 = - p___0;
      } else {
#line 2608
        pa___0 = p___0;
      }
#line 2609
      if (pc___0 < 0) {
#line 2609
        pb___0 = - pc___0;
      } else {
#line 2609
        pb___0 = pc___0;
      }
#line 2610
      if (p___0 + pc___0 < 0) {
#line 2610
        pc___0 = - (p___0 + pc___0);
      } else {
#line 2610
        pc___0 = p___0 + pc___0;
      }
#line 2612
      if (pa___0 <= pb___0) {
#line 2612
        if (pa___0 <= pc___0) {
#line 2612
          p___0 = a___0;
        } else {
#line 2612
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 2612
        if (pb___0 <= pc___0) {
#line 2612
          tmp___44 = b___0;
        } else {
#line 2612
          tmp___44 = c___0;
        }
#line 2612
        p___0 = tmp___44;
      }
#line 2626
      tmp___45 = dp___6;
#line 2626
      dp___6 ++;
#line 2626
      tmp___47 = rp___7;
#line 2626
      rp___7 ++;
#line 2626
      tmp___46 = (png_byte )(((int )*tmp___47 - p___0) & 255);
#line 2626
      *tmp___45 = tmp___46;
#line 2626
      v___3 = (int )tmp___46;
#line 2628
      if (v___3 < 128) {
#line 2628
        tmp___48 = v___3;
      } else {
#line 2628
        tmp___48 = 256 - v___3;
      }
#line 2628
      sum___3 += (png_uint_32 )tmp___48;
#line 2630
      if (sum___3 > lmins___2) {
#line 2631
        goto while_break___13;
      }
#line 2592
      i___7 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 2665
    if (sum___3 < mins) {
#line 2667
      best_row = png_ptr->paeth_row;
    }
  }
  {
#line 2673
  png_write_filtered_row(png_ptr, best_row);
  }
#line 2687
  return;
}
}
#line 2691 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwutil.c"
void png_write_filtered_row(png_structp png_ptr , png_bytep filtered_row ) 
{ 
  int ret ;
  png_bytep tptr ;

  {
#line 2698
  png_ptr->zstream.next_in = filtered_row;
#line 2699
  png_ptr->zstream.avail_in = (uInt )png_ptr->row_info.rowbytes + 1U;
  {
#line 2701
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2706
    ret = deflate(& png_ptr->zstream, 0);
    }
#line 2708
    if (ret != 0) {
#line 2710
      if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
        {
#line 2711
        png_error(png_ptr, (png_const_charp )png_ptr->zstream.msg);
        }
      } else {
        {
#line 2713
        png_error(png_ptr, "zlib error");
        }
      }
    }
#line 2717
    if (! png_ptr->zstream.avail_out) {
      {
#line 2720
      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
#line 2721
      png_ptr->zstream.next_out = png_ptr->zbuf;
#line 2722
      png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
      }
    }
#line 2701
    if (! png_ptr->zstream.avail_in) {
#line 2701
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2728
  if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2732
    tptr = png_ptr->prev_row;
#line 2733
    png_ptr->prev_row = png_ptr->row_buf;
#line 2734
    png_ptr->row_buf = tptr;
  }
  {
#line 2738
  png_write_finish_row(png_ptr);
#line 2741
  (png_ptr->flush_rows) ++;
  }
#line 2743
  if (png_ptr->flush_dist > 0UL) {
#line 2743
    if (png_ptr->flush_rows >= png_ptr->flush_dist) {
      {
#line 2746
      png_write_flush(png_ptr);
      }
    }
  }
#line 2749
  return;
}
}
#line 3386 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
void png_do_write_transformations(png_structp png_ptr ) ;
#line 18 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwtran.c"
void png_do_write_transformations(png_structp png_ptr ) 
{ 


  {
#line 23
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 24
    return;
  }
#line 79
  return;
}
}
#line 119 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 460 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
char const   png_libpng_ver[18] ;
#line 1416
png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                    void (*error_fn)(png_structp  , png_const_charp  ) ,
                                    void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 1476
void png_write_info_before_PLTE(png_structp png_ptr , png_infop info_ptr ) ;
#line 1478
void png_write_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1496
void png_convert_from_struct_tm(png_timep ptime , struct tm *ttime ) ;
#line 1500
void png_convert_from_time_t(png_timep ptime , time_t ttime ) ;
#line 1597
int png_set_interlace_handling(png_structp png_ptr ) ;
#line 1650
void png_set_flush(png_structp png_ptr , int nrows ) ;
#line 1682
void png_write_row(png_structp png_ptr , png_bytep row ) ;
#line 1686
void png_write_rows(png_structp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1690
void png_write_image(png_structp png_ptr , png_bytepp image ) ;
#line 1694
void png_write_end(png_structp png_ptr , png_infop info_ptr ) ;
#line 1716
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1720
void png_write_destroy(png_structp png_ptr ) ;
#line 1753
void png_set_filter(png_structp png_ptr , int method , int filters ) ;
#line 1831
void png_set_compression_level(png_structp png_ptr , int level ) ;
#line 1834
void png_set_compression_mem_level(png_structp png_ptr , int mem_level ) ;
#line 1837
void png_set_compression_strategy(png_structp png_ptr , int strategy ) ;
#line 1840
void png_set_compression_window_bits(png_structp png_ptr , int window_bits ) ;
#line 1843
void png_set_compression_method(png_structp png_ptr , int method ) ;
#line 1868
void png_set_error_fn(png_structp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1879
void png_set_write_fn(png_structp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                     png_bytep  ,
                                                                                     png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) ;
#line 1892
void png_set_write_status_fn(png_structp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                        png_uint_32  ,
                                                                        int  ) ) ;
#line 1981
void png_free_data(png_structp png_ptr , png_infop info_ptr , png_uint_32 mask , int num ) ;
#line 2015
png_voidp png_memcpy_check(png_structp png_ptr , png_voidp s1 , png_voidp s2 , png_uint_32 length ) ;
#line 2389
int png_handle_as_unknown(png_structp png_ptr , png_bytep chunk_name ) ;
#line 2405
void png_write_png(png_structp png_ptr , png_infop info_ptr , int transforms , void *params ) ;
#line 2862
void png_write_init(png_structp png_ptr ) ;
#line 2868
void png_write_init_3(png_structpp ptr_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ) ;
#line 2870
void png_write_init_2(png_structp png_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ,
                      png_size_t png_info_size ) ;
#line 2875
png_voidp png_create_struct(int type ) ;
#line 2878
void png_destroy_struct(png_voidp struct_ptr ) ;
#line 2964
void png_flush(png_structp png_ptr ) ;
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_info_before_PLTE(png_structp png_ptr , png_infop info_ptr ) 
{ 
  png_unknown_chunk *up ;
  int keep ;
  int tmp ;

  {
#line 29
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 30
    return;
  } else
#line 29
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 30
    return;
  }
#line 31
  if (! (png_ptr->mode & 1024UL)) {
    {
#line 33
    png_write_sig(png_ptr);
#line 42
    png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height, (int )info_ptr->bit_depth,
                   (int )info_ptr->color_type, (int )info_ptr->compression_type, (int )info_ptr->filter_type,
                   (int )info_ptr->interlace_type);
    }
#line 53
    if (info_ptr->valid & 1UL) {
      {
#line 59
      png_write_gAMA_fixed(png_ptr, info_ptr->int_gamma);
      }
    }
#line 65
    if (info_ptr->valid & 2048UL) {
      {
#line 66
      png_write_sRGB(png_ptr, (int )info_ptr->srgb_intent);
      }
    }
#line 69
    if (info_ptr->valid & 4096UL) {
      {
#line 70
      png_write_iCCP(png_ptr, info_ptr->iccp_name, 0, info_ptr->iccp_profile, (int )info_ptr->iccp_proflen);
      }
    }
#line 74
    if (info_ptr->valid & 2UL) {
      {
#line 75
      png_write_sBIT(png_ptr, & info_ptr->sig_bit, (int )info_ptr->color_type);
      }
    }
#line 78
    if (info_ptr->valid & 4UL) {
      {
#line 88
      png_write_cHRM_fixed(png_ptr, info_ptr->int_x_white, info_ptr->int_y_white,
                           info_ptr->int_x_red, info_ptr->int_y_red, info_ptr->int_x_green,
                           info_ptr->int_y_green, info_ptr->int_x_blue, info_ptr->int_y_blue);
      }
    }
#line 98
    if (info_ptr->unknown_chunks_num) {
#line 104
      up = info_ptr->unknown_chunks;
      {
#line 104
      while (1) {
        while_continue: /* CIL Label */ ;
#line 104
        if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 104
          goto while_break;
        }
        {
#line 108
        tmp = png_handle_as_unknown(png_ptr, up->name);
#line 108
        keep = tmp;
        }
#line 109
        if (keep != 1) {
#line 109
          if (up->location) {
#line 109
            if (! ((int )up->location & 2)) {
#line 109
              if (! ((int )up->location & 4)) {
#line 109
                if ((int )up->name[3] & 32) {
                  {
#line 115
                  png_write_chunk(png_ptr, up->name, up->data, up->size);
                  }
                } else
#line 109
                if (keep == 3) {
                  {
#line 115
                  png_write_chunk(png_ptr, up->name, up->data, up->size);
                  }
                } else
#line 109
                if (png_ptr->flags & 65536UL) {
                  {
#line 115
                  png_write_chunk(png_ptr, up->name, up->data, up->size);
                  }
                }
              }
            }
          }
        }
#line 104
        up ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 120
    png_ptr->mode |= 1024UL;
  }
#line 122
  return;
}
}
#line 124 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_info(png_structp png_ptr , png_infop info_ptr ) 
{ 
  int i ;
  png_unknown_chunk *up ;
  int keep ;
  int tmp ;

  {
#line 133
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 134
    return;
  } else
#line 133
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 134
    return;
  }
  {
#line 136
  png_write_info_before_PLTE(png_ptr, info_ptr);
  }
#line 138
  if (info_ptr->valid & 8UL) {
    {
#line 139
    png_write_PLTE(png_ptr, info_ptr->palette, (png_uint_32 )info_ptr->num_palette);
    }
  } else
#line 141
  if ((int )info_ptr->color_type == 3) {
    {
#line 142
    png_error(png_ptr, "Valid palette required for paletted images");
    }
  }
#line 145
  if (info_ptr->valid & 16UL) {
    {
#line 157
    png_write_tRNS(png_ptr, info_ptr->trans, & info_ptr->trans_values, (int )info_ptr->num_trans,
                   (int )info_ptr->color_type);
    }
  }
#line 162
  if (info_ptr->valid & 32UL) {
    {
#line 163
    png_write_bKGD(png_ptr, & info_ptr->background, (int )info_ptr->color_type);
    }
  }
#line 166
  if (info_ptr->valid & 64UL) {
    {
#line 167
    png_write_hIST(png_ptr, info_ptr->hist, (int )info_ptr->num_palette);
    }
  }
#line 170
  if (info_ptr->valid & 256UL) {
    {
#line 171
    png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset, (int )info_ptr->offset_unit_type);
    }
  }
#line 175
  if (info_ptr->valid & 1024UL) {
    {
#line 176
    png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0, info_ptr->pcal_X1,
                   (int )info_ptr->pcal_type, (int )info_ptr->pcal_nparams, info_ptr->pcal_units,
                   info_ptr->pcal_params);
    }
  }
#line 181
  if (info_ptr->valid & 16384UL) {
    {
#line 187
    png_write_sCAL_s(png_ptr, (int )info_ptr->scal_unit, info_ptr->scal_s_width, info_ptr->scal_s_height);
    }
  }
#line 196
  if (info_ptr->valid & 128UL) {
    {
#line 197
    png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit, info_ptr->y_pixels_per_unit,
                   (int )info_ptr->phys_unit_type);
    }
  }
#line 201
  if (info_ptr->valid & 512UL) {
    {
#line 203
    png_write_tIME(png_ptr, & info_ptr->mod_time);
#line 204
    png_ptr->mode |= 512UL;
    }
  }
#line 208
  if (info_ptr->valid & 8192UL) {
#line 209
    i = 0;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      if (! (i < (int )info_ptr->splt_palettes_num)) {
#line 209
        goto while_break;
      }
      {
#line 210
      png_write_sPLT(png_ptr, info_ptr->splt_palettes + i);
#line 209
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! (i < info_ptr->num_text)) {
#line 214
      goto while_break___0;
    }
#line 219
    if ((info_ptr->text + i)->compression > 0) {
      {
#line 230
      png_warning(png_ptr, "Unable to write international text");
#line 233
      (info_ptr->text + i)->compression = -3;
      }
    } else
#line 236
    if ((info_ptr->text + i)->compression == 0) {
      {
#line 240
      png_write_zTXt(png_ptr, (info_ptr->text + i)->key, (info_ptr->text + i)->text,
                     (png_size_t )0, (info_ptr->text + i)->compression);
#line 247
      (info_ptr->text + i)->compression = -2;
      }
    } else
#line 249
    if ((info_ptr->text + i)->compression == -1) {
      {
#line 253
      png_write_tEXt(png_ptr, (info_ptr->text + i)->key, (info_ptr->text + i)->text,
                     (png_size_t )0);
#line 260
      (info_ptr->text + i)->compression = -3;
      }
    }
#line 214
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  if (info_ptr->unknown_chunks_num) {
#line 271
    up = info_ptr->unknown_chunks;
    {
#line 271
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 271
      if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 271
        goto while_break___1;
      }
      {
#line 275
      tmp = png_handle_as_unknown(png_ptr, up->name);
#line 275
      keep = tmp;
      }
#line 276
      if (keep != 1) {
#line 276
        if (up->location) {
#line 276
          if ((int )up->location & 2) {
#line 276
            if (! ((int )up->location & 4)) {
#line 276
              if ((int )up->name[3] & 32) {
                {
#line 282
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              } else
#line 276
              if (keep == 3) {
                {
#line 282
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              } else
#line 276
              if (png_ptr->flags & 65536UL) {
                {
#line 282
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              }
            }
          }
        }
      }
#line 271
      up ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 287
  return;
}
}
#line 294 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_end(png_structp png_ptr , png_infop info_ptr ) 
{ 
  int i ;
  png_unknown_chunk *up ;
  int keep ;
  int tmp ;

  {
#line 298
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 299
    return;
  }
#line 300
  if (! (png_ptr->mode & 4UL)) {
    {
#line 301
    png_error(png_ptr, "No IDATs written into file");
    }
  }
#line 304
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 311
    if (info_ptr->valid & 512UL) {
#line 311
      if (! (png_ptr->mode & 512UL)) {
        {
#line 313
        png_write_tIME(png_ptr, & info_ptr->mod_time);
        }
      }
    }
#line 317
    i = 0;
    {
#line 317
    while (1) {
      while_continue: /* CIL Label */ ;
#line 317
      if (! (i < info_ptr->num_text)) {
#line 317
        goto while_break;
      }
#line 322
      if ((info_ptr->text + i)->compression > 0) {
        {
#line 333
        png_warning(png_ptr, "Unable to write international text");
#line 336
        (info_ptr->text + i)->compression = -3;
        }
      } else
#line 338
      if ((info_ptr->text + i)->compression >= 0) {
        {
#line 342
        png_write_zTXt(png_ptr, (info_ptr->text + i)->key, (info_ptr->text + i)->text,
                       (png_size_t )0, (info_ptr->text + i)->compression);
#line 349
        (info_ptr->text + i)->compression = -2;
        }
      } else
#line 351
      if ((info_ptr->text + i)->compression == -1) {
        {
#line 355
        png_write_tEXt(png_ptr, (info_ptr->text + i)->key, (info_ptr->text + i)->text,
                       (png_size_t )0);
#line 362
        (info_ptr->text + i)->compression = -3;
        }
      }
#line 317
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 367
    if (info_ptr->unknown_chunks_num) {
#line 373
      up = info_ptr->unknown_chunks;
      {
#line 373
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 373
        if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 373
          goto while_break___0;
        }
        {
#line 377
        tmp = png_handle_as_unknown(png_ptr, up->name);
#line 377
        keep = tmp;
        }
#line 378
        if (keep != 1) {
#line 378
          if (up->location) {
#line 378
            if ((int )up->location & 8) {
#line 378
              if ((int )up->name[3] & 32) {
                {
#line 383
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              } else
#line 378
              if (keep == 3) {
                {
#line 383
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              } else
#line 378
              if (png_ptr->flags & 65536UL) {
                {
#line 383
                png_write_chunk(png_ptr, up->name, up->data, up->size);
                }
              }
            }
          }
        }
#line 373
        up ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 390
  png_ptr->mode |= 8UL;
#line 393
  png_write_IEND(png_ptr);
  }
#line 399
  return;
}
}
#line 404 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_convert_from_struct_tm(png_timep ptime , struct tm *ttime ) 
{ 


  {
#line 408
  ptime->year = (png_uint_16 )(1900 + ttime->tm_year);
#line 409
  ptime->month = (png_byte )(ttime->tm_mon + 1);
#line 410
  ptime->day = (png_byte )ttime->tm_mday;
#line 411
  ptime->hour = (png_byte )ttime->tm_hour;
#line 412
  ptime->minute = (png_byte )ttime->tm_min;
#line 413
  ptime->second = (png_byte )ttime->tm_sec;
#line 414
  return;
}
}
#line 416 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_convert_from_time_t(png_timep ptime , time_t ttime ) 
{ 
  struct tm *tbuf ;

  {
  {
#line 422
  tbuf = gmtime((time_t const   *)(& ttime));
#line 423
  png_convert_from_struct_tm(ptime, tbuf);
  }
#line 424
  return;
}
}
#line 429 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                    void (*error_fn)(png_structp  , png_const_charp  ) ,
                                    void (*warn_fn)(png_structp  , png_const_charp  ) ) 
{ 
  png_structp png_ptr ;
  int i ;
  png_voidp tmp ;
  int tmp___0 ;
  char msg___0[80] ;
  png_voidp tmp___1 ;

  {
  {
#line 457
  tmp = png_create_struct(1);
#line 457
  png_ptr = (png_structp )tmp;
  }
#line 459
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 460
    return ((png_structp )((void *)0));
  }
  {
#line 494
  png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
#line 496
  i = 0;
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if ((int const   )*(user_png_ver + i) != (int const   )png_libpng_ver[i]) {
#line 500
      png_ptr->flags |= 131072UL;
    }
#line 497
    tmp___0 = i;
#line 497
    i ++;
#line 497
    if (! png_libpng_ver[tmp___0]) {
#line 497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (png_ptr->flags & 131072UL) {
#line 510
    if ((unsigned long )user_png_ver == (unsigned long )((void *)0)) {
#line 510
      goto _L;
    } else
#line 510
    if ((int const   )*(user_png_ver + 0) != (int const   )png_libpng_ver[0]) {
#line 510
      goto _L;
    } else
#line 510
    if ((int const   )*(user_png_ver + 0) == 49) {
#line 510
      if ((int const   )*(user_png_ver + 2) != (int const   )png_libpng_ver[2]) {
#line 510
        goto _L;
      } else {
#line 510
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 510
    if ((int const   )*(user_png_ver + 0) == 48) {
#line 510
      if ((int const   )*(user_png_ver + 2) < 57) {
        _L: /* CIL Label */ 
#line 516
        if (user_png_ver) {
          {
#line 518
          sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application was compiled with png.h from libpng-%.20s",
                  user_png_ver);
#line 520
          png_warning(png_ptr, (png_const_charp )(msg___0));
          }
        }
        {
#line 522
        sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application  is  running with png.c from libpng-%.20s",
                png_libpng_ver);
#line 524
        png_warning(png_ptr, (png_const_charp )(msg___0));
#line 529
        png_error(png_ptr, "Incompatible libpng version in application and library");
        }
      }
    }
  }
  {
#line 535
  png_ptr->zbuf_size = (png_size_t )16384;
#line 536
  tmp___1 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 536
  png_ptr->zbuf = (png_bytep )tmp___1;
#line 539
  png_set_write_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0),
                   (void (*)(png_structp  ))((void *)0));
  }
#line 560
  return (png_ptr);
}
}
#line 567 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_init(png_structp png_ptr ) 
{ 


  {
  {
#line 571
  png_write_init_2(png_ptr, "1.0.6 or earlier", (png_size_t )0, (png_size_t )0);
  }
#line 572
  return;
}
}
#line 574 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_init_2(png_structp png_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ,
                      png_size_t png_info_size ) 
{ 
  char msg___0[80] ;

  {
#line 580
  if (sizeof(png_struct ) > png_struct_size) {
#line 580
    goto _L;
  } else
#line 580
  if (sizeof(png_info ) > png_info_size) {
    _L: /* CIL Label */ 
#line 584
    png_ptr->warning_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 585
    if (user_png_ver) {
      {
#line 587
      sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application was compiled with png.h from libpng-%.20s",
              user_png_ver);
#line 589
      png_warning(png_ptr, (png_const_charp )(msg___0));
      }
    }
    {
#line 591
    sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application  is  running with png.c from libpng-%.20s",
            png_libpng_ver);
#line 593
    png_warning(png_ptr, (png_const_charp )(msg___0));
    }
  }
#line 596
  if (sizeof(png_struct ) > png_struct_size) {
    {
#line 598
    png_ptr->error_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 602
    png_error(png_ptr, "The png struct allocated by the application for writing is too small.");
    }
  }
#line 605
  if (sizeof(png_info ) > png_info_size) {
    {
#line 607
    png_ptr->error_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 611
    png_error(png_ptr, "The info struct allocated by the application for writing is too small.");
    }
  }
  {
#line 614
  png_write_init_3(& png_ptr, user_png_ver, png_struct_size);
  }
#line 615
  return;
}
}
#line 619 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_init_3(png_structpp ptr_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ) 
{ 
  png_structp png_ptr ;
  int i ;
  int tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;

  {
#line 623
  png_ptr = *ptr_ptr;
#line 628
  i = 0;
#line 630
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 631
    return;
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if ((int const   )*(user_png_ver + i) != (int const   )png_libpng_ver[i]) {
      {
#line 640
      png_ptr->warning_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 641
      png_warning(png_ptr, "Application uses deprecated png_write_init() and should be recompiled.");
      }
#line 643
      goto while_break;
    }
#line 633
    tmp = i;
#line 633
    i ++;
#line 633
    if (! png_libpng_ver[tmp]) {
#line 633
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  if (sizeof(png_struct ) > png_struct_size) {
    {
#line 657
    png_destroy_struct((png_voidp )png_ptr);
#line 658
    tmp___0 = png_create_struct(1);
#line 658
    png_ptr = (png_structp )tmp___0;
#line 659
    *ptr_ptr = png_ptr;
    }
  }
  {
#line 663
  memset((void *)png_ptr, 0, sizeof(png_struct ));
#line 682
  png_set_write_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0),
                   (void (*)(png_structp  ))((void *)0));
#line 686
  png_ptr->zbuf_size = (png_size_t )16384;
#line 687
  tmp___1 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 687
  png_ptr->zbuf = (png_bytep )tmp___1;
  }
#line 694
  return;
}
}
#line 701 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_rows(png_structp png_ptr , png_bytepp row , png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;

  {
#line 710
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 711
    return;
  }
#line 714
  i = (png_uint_32 )0;
#line 714
  rp = row;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i < num_rows)) {
#line 714
      goto while_break;
    }
    {
#line 716
    png_write_row(png_ptr, *rp);
#line 714
    i ++;
#line 714
    rp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 718
  return;
}
}
#line 723 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_image(png_structp png_ptr , png_bytepp image ) 
{ 
  png_uint_32 i ;
  int pass ;
  int num_pass ;
  png_bytepp rp ;

  {
#line 730
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 731
    return;
  }
  {
#line 737
  num_pass = png_set_interlace_handling(png_ptr);
#line 742
  pass = 0;
  }
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! (pass < num_pass)) {
#line 742
      goto while_break;
    }
#line 745
    i = (png_uint_32 )0;
#line 745
    rp = image;
    {
#line 745
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 745
      if (! (i < png_ptr->height)) {
#line 745
        goto while_break___0;
      }
      {
#line 747
      png_write_row(png_ptr, *rp);
#line 745
      i ++;
#line 745
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 742
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  return;
}
}
#line 753 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_row(png_structp png_ptr , png_bytep row ) 
{ 


  {
#line 756
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 757
    return;
  }
#line 762
  if (png_ptr->row_number == 0UL) {
#line 762
    if ((int )png_ptr->pass == 0) {
#line 765
      if (! (png_ptr->mode & 1024UL)) {
        {
#line 766
        png_error(png_ptr, "png_write_info was never called before png_write_row.");
        }
      }
      {
#line 799
      png_write_start_row(png_ptr);
      }
    }
  }
#line 804
  if (png_ptr->interlaced) {
#line 804
    if (png_ptr->transformations & 2UL) {
      {
#line 808
      if ((int )png_ptr->pass == 0) {
#line 808
        goto case_0;
      }
#line 815
      if ((int )png_ptr->pass == 1) {
#line 815
        goto case_1;
      }
#line 822
      if ((int )png_ptr->pass == 2) {
#line 822
        goto case_2;
      }
#line 829
      if ((int )png_ptr->pass == 3) {
#line 829
        goto case_3;
      }
#line 836
      if ((int )png_ptr->pass == 4) {
#line 836
        goto case_4;
      }
#line 843
      if ((int )png_ptr->pass == 5) {
#line 843
        goto case_5;
      }
#line 850
      if ((int )png_ptr->pass == 6) {
#line 850
        goto case_6;
      }
#line 806
      goto switch_break;
      case_0: /* CIL Label */ 
#line 809
      if (png_ptr->row_number & 7UL) {
        {
#line 811
        png_write_finish_row(png_ptr);
        }
#line 812
        return;
      }
#line 814
      goto switch_break;
      case_1: /* CIL Label */ 
#line 816
      if (png_ptr->row_number & 7UL) {
        {
#line 818
        png_write_finish_row(png_ptr);
        }
#line 819
        return;
      } else
#line 816
      if (png_ptr->width < 5UL) {
        {
#line 818
        png_write_finish_row(png_ptr);
        }
#line 819
        return;
      }
#line 821
      goto switch_break;
      case_2: /* CIL Label */ 
#line 823
      if ((png_ptr->row_number & 7UL) != 4UL) {
        {
#line 825
        png_write_finish_row(png_ptr);
        }
#line 826
        return;
      }
#line 828
      goto switch_break;
      case_3: /* CIL Label */ 
#line 830
      if (png_ptr->row_number & 3UL) {
        {
#line 832
        png_write_finish_row(png_ptr);
        }
#line 833
        return;
      } else
#line 830
      if (png_ptr->width < 3UL) {
        {
#line 832
        png_write_finish_row(png_ptr);
        }
#line 833
        return;
      }
#line 835
      goto switch_break;
      case_4: /* CIL Label */ 
#line 837
      if ((png_ptr->row_number & 3UL) != 2UL) {
        {
#line 839
        png_write_finish_row(png_ptr);
        }
#line 840
        return;
      }
#line 842
      goto switch_break;
      case_5: /* CIL Label */ 
#line 844
      if (png_ptr->row_number & 1UL) {
        {
#line 846
        png_write_finish_row(png_ptr);
        }
#line 847
        return;
      } else
#line 844
      if (png_ptr->width < 2UL) {
        {
#line 846
        png_write_finish_row(png_ptr);
        }
#line 847
        return;
      }
#line 849
      goto switch_break;
      case_6: /* CIL Label */ 
#line 851
      if (! (png_ptr->row_number & 1UL)) {
        {
#line 853
        png_write_finish_row(png_ptr);
        }
#line 854
        return;
      }
#line 856
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 862
  png_ptr->row_info.color_type = png_ptr->color_type;
#line 863
  png_ptr->row_info.width = png_ptr->usr_width;
#line 864
  png_ptr->row_info.channels = png_ptr->usr_channels;
#line 865
  png_ptr->row_info.bit_depth = png_ptr->usr_bit_depth;
#line 866
  png_ptr->row_info.pixel_depth = (png_byte )((int )png_ptr->row_info.bit_depth * (int )png_ptr->row_info.channels);
#line 869
  if ((int )png_ptr->row_info.pixel_depth >= 8) {
#line 869
    png_ptr->row_info.rowbytes = png_ptr->row_info.width * ((png_uint_32 )png_ptr->row_info.pixel_depth >> 3);
  } else {
#line 869
    png_ptr->row_info.rowbytes = (png_ptr->row_info.width * (png_uint_32 )png_ptr->row_info.pixel_depth + 7UL) >> 3;
  }
  {
#line 880
  png_memcpy_check(png_ptr, (png_voidp )(png_ptr->row_buf + 1), (png_voidp )row, png_ptr->row_info.rowbytes);
  }
#line 885
  if (png_ptr->interlaced) {
#line 885
    if ((int )png_ptr->pass < 6) {
#line 885
      if (png_ptr->transformations & 2UL) {
        {
#line 888
        png_do_write_interlace(& png_ptr->row_info, png_ptr->row_buf + 1, (int )png_ptr->pass);
        }
#line 891
        if (! png_ptr->row_info.width) {
          {
#line 893
          png_write_finish_row(png_ptr);
          }
#line 894
          return;
        }
      }
    }
  }
#line 900
  if (png_ptr->transformations) {
    {
#line 901
    png_do_write_transformations(png_ptr);
    }
  }
  {
#line 922
  png_write_find_filter(png_ptr, & png_ptr->row_info);
  }
#line 924
  if ((unsigned long )png_ptr->write_row_fn != (unsigned long )((void *)0)) {
    {
#line 925
    (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 926
  return;
}
}
#line 930 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_flush(png_structp png_ptr , int nrows ) 
{ 


  {
#line 934
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 935
    return;
  }
#line 936
  if (nrows < 0) {
#line 936
    png_ptr->flush_dist = (png_uint_32 )0;
  } else {
#line 936
    png_ptr->flush_dist = (png_uint_32 )nrows;
  }
#line 937
  return;
}
}
#line 940 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_flush(png_structp png_ptr ) 
{ 
  int wrote_IDAT ;
  int ret ;

  {
#line 946
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 947
    return;
  }
#line 949
  if (png_ptr->row_number >= png_ptr->num_rows) {
#line 950
    return;
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 957
    ret = deflate(& png_ptr->zstream, 2);
#line 958
    wrote_IDAT = 0;
    }
#line 961
    if (ret != 0) {
#line 963
      if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
        {
#line 964
        png_error(png_ptr, (png_const_charp )png_ptr->zstream.msg);
        }
      } else {
        {
#line 966
        png_error(png_ptr, "zlib error");
        }
      }
    }
#line 969
    if (! png_ptr->zstream.avail_out) {
      {
#line 972
      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
#line 974
      png_ptr->zstream.next_out = png_ptr->zbuf;
#line 975
      png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 976
      wrote_IDAT = 1;
      }
    }
#line 952
    if (! (wrote_IDAT == 1)) {
#line 952
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  if (png_ptr->zbuf_size != (png_size_t )png_ptr->zstream.avail_out) {
    {
#line 984
    png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out);
#line 986
    png_ptr->zstream.next_out = png_ptr->zbuf;
#line 987
    png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
    }
  }
  {
#line 989
  png_ptr->flush_rows = (png_uint_32 )0;
#line 990
  png_flush(png_ptr);
  }
#line 991
  return;
}
}
#line 995 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_structp png_ptr ;
  png_infop info_ptr ;

  {
#line 998
  png_ptr = (png_structp )((void *)0);
#line 999
  info_ptr = (png_infop )((void *)0);
#line 1006
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 1008
    png_ptr = *png_ptr_ptr;
  }
#line 1015
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 1016
    info_ptr = *info_ptr_ptr;
  }
#line 1018
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 1020
    png_free_data(png_ptr, info_ptr, (png_uint_32 )32767, -1);
    }
#line 1023
    if (png_ptr->num_chunk_list) {
      {
#line 1025
      png_free(png_ptr, (png_voidp )png_ptr->chunk_list);
#line 1026
      png_ptr->chunk_list = (png_bytep )((void *)0);
#line 1027
      png_ptr->num_chunk_list = 0;
      }
    }
    {
#line 1035
    png_destroy_struct((png_voidp )info_ptr);
#line 1037
    *info_ptr_ptr = (png_info *)((void *)0);
    }
  }
#line 1040
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 1042
    png_write_destroy(png_ptr);
#line 1047
    png_destroy_struct((png_voidp )png_ptr);
#line 1049
    *png_ptr_ptr = (png_struct *)((void *)0);
    }
  }
#line 1051
  return;
}
}
#line 1055 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_destroy(png_structp png_ptr ) 
{ 
  void (*error_fn)(png_structp  , png_const_charp  ) ;
  void (*warning_fn)(png_structp  , png_const_charp  ) ;
  png_voidp error_ptr ;

  {
  {
#line 1070
  deflateEnd(& png_ptr->zstream);
#line 1073
  png_free(png_ptr, (png_voidp )png_ptr->zbuf);
#line 1074
  png_free(png_ptr, (png_voidp )png_ptr->row_buf);
#line 1075
  png_free(png_ptr, (png_voidp )png_ptr->prev_row);
#line 1076
  png_free(png_ptr, (png_voidp )png_ptr->sub_row);
#line 1077
  png_free(png_ptr, (png_voidp )png_ptr->up_row);
#line 1078
  png_free(png_ptr, (png_voidp )png_ptr->avg_row);
#line 1079
  png_free(png_ptr, (png_voidp )png_ptr->paeth_row);
#line 1082
  png_free(png_ptr, (png_voidp )png_ptr->time_buffer);
#line 1098
  error_fn = png_ptr->error_fn;
#line 1099
  warning_fn = png_ptr->warning_fn;
#line 1100
  error_ptr = png_ptr->error_ptr;
#line 1105
  memset((void *)png_ptr, 0, sizeof(png_struct ));
#line 1107
  png_ptr->error_fn = error_fn;
#line 1108
  png_ptr->warning_fn = warning_fn;
#line 1109
  png_ptr->error_ptr = error_ptr;
  }
#line 1117
  return;
}
}
#line 1120 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_filter(png_structp png_ptr , int method , int filters ) 
{ 
  png_voidp tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;
  png_voidp tmp___2 ;

  {
#line 1124
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1125
    return;
  }
#line 1131
  if (method == 0) {
    {
#line 1137
    if ((filters & 255) == 7) {
#line 1137
      goto case_7;
    }
#line 1137
    if ((filters & 255) == 6) {
#line 1137
      goto case_7;
    }
#line 1137
    if ((filters & 255) == 5) {
#line 1137
      goto case_7;
    }
#line 1138
    if ((filters & 255) == 0) {
#line 1138
      goto case_0;
    }
#line 1139
    if ((filters & 255) == 1) {
#line 1139
      goto case_1;
    }
#line 1140
    if ((filters & 255) == 2) {
#line 1140
      goto case_2;
    }
#line 1141
    if ((filters & 255) == 3) {
#line 1141
      goto case_3;
    }
#line 1142
    if ((filters & 255) == 4) {
#line 1142
      goto case_4;
    }
#line 1143
    goto switch_default;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 1137
    png_warning(png_ptr, "Unknown row filter for method 0");
    }
    case_0: /* CIL Label */ 
#line 1138
    png_ptr->do_filter = (png_byte )8;
#line 1138
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1139
    png_ptr->do_filter = (png_byte )16;
#line 1139
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1140
    png_ptr->do_filter = (png_byte )32;
#line 1140
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1141
    png_ptr->do_filter = (png_byte )64;
#line 1141
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1142
    png_ptr->do_filter = (png_byte )128;
#line 1142
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1143
    png_ptr->do_filter = (png_byte )filters;
#line 1143
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1155
    if ((unsigned long )png_ptr->row_buf != (unsigned long )((void *)0)) {
#line 1157
      if ((int )png_ptr->do_filter & 16) {
#line 1157
        if ((unsigned long )png_ptr->sub_row == (unsigned long )((void *)0)) {
          {
#line 1159
          tmp = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1159
          png_ptr->sub_row = (png_bytep )tmp;
#line 1161
          *(png_ptr->sub_row + 0) = (png_byte )1;
          }
        }
      }
#line 1164
      if ((int )png_ptr->do_filter & 32) {
#line 1164
        if ((unsigned long )png_ptr->up_row == (unsigned long )((void *)0)) {
#line 1166
          if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
            {
#line 1168
            png_warning(png_ptr, "Can\'t add Up filter after starting");
#line 1169
            png_ptr->do_filter = (png_byte )((int )png_ptr->do_filter & -33);
            }
          } else {
            {
#line 1173
            tmp___0 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1173
            png_ptr->up_row = (png_bytep )tmp___0;
#line 1175
            *(png_ptr->up_row + 0) = (png_byte )2;
            }
          }
        }
      }
#line 1179
      if ((int )png_ptr->do_filter & 64) {
#line 1179
        if ((unsigned long )png_ptr->avg_row == (unsigned long )((void *)0)) {
#line 1181
          if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
            {
#line 1183
            png_warning(png_ptr, "Can\'t add Average filter after starting");
#line 1184
            png_ptr->do_filter = (png_byte )((int )png_ptr->do_filter & -65);
            }
          } else {
            {
#line 1188
            tmp___1 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1188
            png_ptr->avg_row = (png_bytep )tmp___1;
#line 1190
            *(png_ptr->avg_row + 0) = (png_byte )3;
            }
          }
        }
      }
#line 1194
      if ((int )png_ptr->do_filter & 128) {
#line 1194
        if ((unsigned long )png_ptr->paeth_row == (unsigned long )((void *)0)) {
#line 1197
          if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
            {
#line 1199
            png_warning(png_ptr, "Can\'t add Paeth filter after starting");
#line 1200
            png_ptr->do_filter = (png_byte )((int )png_ptr->do_filter & 127);
            }
          } else {
            {
#line 1204
            tmp___2 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 1204
            png_ptr->paeth_row = (png_bytep )tmp___2;
#line 1206
            *(png_ptr->paeth_row + 0) = (png_byte )4;
            }
          }
        }
      }
#line 1210
      if ((int )png_ptr->do_filter == 0) {
#line 1211
        png_ptr->do_filter = (png_byte )8;
      }
    }
  } else {
    {
#line 1215
    png_error(png_ptr, "Unknown custom filter method");
    }
  }
#line 1216
  return;
}
}
#line 1344 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_compression_level(png_structp png_ptr , int level ) 
{ 


  {
#line 1348
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1349
    return;
  }
#line 1350
  png_ptr->flags |= 2UL;
#line 1351
  png_ptr->zlib_level = level;
#line 1352
  return;
}
}
#line 1354 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_compression_mem_level(png_structp png_ptr , int mem_level ) 
{ 


  {
#line 1358
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1359
    return;
  }
#line 1360
  png_ptr->flags |= 4UL;
#line 1361
  png_ptr->zlib_mem_level = mem_level;
#line 1362
  return;
}
}
#line 1364 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_compression_strategy(png_structp png_ptr , int strategy ) 
{ 


  {
#line 1368
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1369
    return;
  }
#line 1370
  png_ptr->flags |= 1UL;
#line 1371
  png_ptr->zlib_strategy = strategy;
#line 1372
  return;
}
}
#line 1374 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_compression_window_bits(png_structp png_ptr , int window_bits ) 
{ 


  {
#line 1377
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1378
    return;
  }
#line 1379
  if (window_bits > 15) {
    {
#line 1380
    png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
    }
  } else
#line 1381
  if (window_bits < 8) {
    {
#line 1382
    png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
    }
  }
#line 1385
  if (window_bits == 8) {
    {
#line 1387
    png_warning(png_ptr, "Compression window is being reset to 512");
#line 1388
    window_bits = 9;
    }
  }
#line 1391
  png_ptr->flags |= 8UL;
#line 1392
  png_ptr->zlib_window_bits = window_bits;
#line 1393
  return;
}
}
#line 1395 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_compression_method(png_structp png_ptr , int method ) 
{ 


  {
#line 1399
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1400
    return;
  }
#line 1401
  if (method != 8) {
    {
#line 1402
    png_warning(png_ptr, "Only compression method 8 is supported by PNG");
    }
  }
#line 1403
  png_ptr->flags |= 16UL;
#line 1404
  png_ptr->zlib_method = method;
#line 1405
  return;
}
}
#line 1407 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_set_write_status_fn(png_structp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                        png_uint_32  ,
                                                                        int  ) ) 
{ 


  {
#line 1410
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1411
    return;
  }
#line 1412
  png_ptr->write_row_fn = write_row_fn;
#line 1413
  return;
}
}
#line 1430 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwrite.c"
void png_write_png(png_structp png_ptr , png_infop info_ptr , int transforms , void *params ) 
{ 


  {
#line 1434
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1435
    return;
  } else
#line 1434
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1435
    return;
  }
  {
#line 1443
  png_write_info(png_ptr, info_ptr);
  }
#line 1503
  if (info_ptr->valid & 32768UL) {
    {
#line 1504
    png_write_image(png_ptr, info_ptr->row_pointers);
    }
  }
  {
#line 1507
  png_write_end(png_ptr, info_ptr);
  }
#line 1509
  if (transforms == 0) {
#line 1510
    return;
  } else
#line 1509
  if ((unsigned long )params == (unsigned long )((void *)0)) {
#line 1510
    return;
  }
#line 1511
  return;
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 2912 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 2917
void png_default_flush(png_structp png_ptr ) ;
#line 28 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwio.c"
void png_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 


  {
#line 31
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 32
    (*(png_ptr->write_data_fn))(png_ptr, data, length);
    }
  } else {
    {
#line 34
    png_error(png_ptr, "Call to NULL write function");
    }
  }
#line 35
  return;
}
}
#line 43 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwio.c"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_uint_32 check ;

  {
  {
#line 52
  check = fwrite((void const   */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)((png_FILE_p )png_ptr->io_ptr));
  }
#line 54
  if (check != length) {
    {
#line 55
    png_error(png_ptr, "Write Error");
    }
  }
#line 56
  return;
}
}
#line 121 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwio.c"
void png_flush(png_structp png_ptr ) 
{ 


  {
#line 124
  if ((unsigned long )png_ptr->output_flush_fn != (unsigned long )((void *)0)) {
    {
#line 125
    (*(png_ptr->output_flush_fn))(png_ptr);
    }
  }
#line 126
  return;
}
}
#line 129 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwio.c"
void png_default_flush(png_structp png_ptr ) 
{ 
  png_FILE_p io_ptr ;

  {
#line 134
  io_ptr = (png_FILE_p )png_ptr->io_ptr;
#line 135
  if ((unsigned long )io_ptr != (unsigned long )((void *)0)) {
    {
#line 136
    fflush(io_ptr);
    }
  }
#line 138
  return;
}
}
#line 164 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngwio.c"
void png_set_write_fn(png_structp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                     png_bytep  ,
                                                                                     png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) 
{ 


  {
#line 168
  png_ptr->io_ptr = io_ptr;
#line 171
  if ((unsigned long )write_data_fn != (unsigned long )((void *)0)) {
#line 172
    png_ptr->write_data_fn = write_data_fn;
  } else {
#line 174
    png_ptr->write_data_fn = & png_default_write_data;
  }
#line 181
  if ((unsigned long )output_flush_fn != (unsigned long )((void *)0)) {
#line 182
    png_ptr->output_flush_fn = output_flush_fn;
  } else {
#line 184
    png_ptr->output_flush_fn = & png_default_flush;
  }
#line 191
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 193
    png_ptr->read_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 194
    png_warning(png_ptr, "Attempted to set both read_data_fn and write_data_fn in");
#line 196
    png_warning(png_ptr, "the same structure.  Resetting read_data_fn to NULL.");
    }
  }
#line 199
  return;
}
}
#line 73 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngtrans.c"
int png_set_interlace_handling(png_structp png_ptr ) 
{ 


  {
#line 77
  if (png_ptr->interlaced) {
#line 79
    png_ptr->transformations |= 2UL;
#line 80
    return (7);
  }
#line 83
  return (1);
}
}
#line 641 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngtrans.c"
png_voidp png_get_user_transform_ptr(png_structp png_ptr ) 
{ 


  {
#line 647
  if (png_ptr) {
#line 648
    return ((void *)0);
  }
#line 649
  return ((void *)0);
}
}
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 1426 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
void png_set_compression_buffer_size(png_structp png_ptr , png_uint_32 size ) ;
#line 1643
void png_permit_empty_plte(png_structp png_ptr , int empty_plte_permitted ) ;
#line 1927
void png_set_read_user_chunk_fn(png_structp png_ptr , png_voidp user_chunk_ptr , int (*read_user_chunk_fn)(png_structp  ,
                                                                                                           png_unknown_chunkp  ) ) ;
#line 2069
void png_set_rows(png_structp png_ptr , png_infop info_ptr , png_bytepp row_pointers ) ;
#line 2142
void png_set_bKGD(png_structp png_ptr , png_infop info_ptr , png_color_16p background ) ;
#line 2169
void png_set_cHRM_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point white_x ,
                        png_fixed_point white_y , png_fixed_point red_x , png_fixed_point red_y ,
                        png_fixed_point green_x , png_fixed_point green_y , png_fixed_point blue_x ,
                        png_fixed_point blue_y ) ;
#line 2191
void png_set_gAMA_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point int_gamma ) ;
#line 2201
void png_set_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_16p hist ) ;
#line 2210
void png_set_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 width , png_uint_32 height ,
                  int bit_depth , int color_type , int interlace_type , int compression_type ,
                  int filter_type ) ;
#line 2222
void png_set_oFFs(png_structp png_ptr , png_infop info_ptr , png_int_32 offset_x ,
                  png_int_32 offset_y , int unit_type ) ;
#line 2234
void png_set_pCAL(png_structp png_ptr , png_infop info_ptr , png_charp purpose , png_int_32 X0 ,
                  png_int_32 X1 , int type , int nparams , png_charp units , png_charpp params ) ;
#line 2245
void png_set_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 res_x , png_uint_32 res_y ,
                  int unit_type ) ;
#line 2252
void png_set_PLTE(png_structp png_ptr , png_infop info_ptr , png_colorp palette ,
                  int num_palette ) ;
#line 2261
void png_set_sBIT(png_structp png_ptr , png_infop info_ptr , png_color_8p sig_bit ) ;
#line 2271
void png_set_sRGB(png_structp png_ptr , png_infop info_ptr , int intent ) ;
#line 2273
void png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr , png_infop info_ptr , int intent ) ;
#line 2285
void png_set_iCCP(png_structp png_ptr , png_infop info_ptr , png_charp name , int compression_type ,
                  png_charp profile , png_uint_32 proflen ) ;
#line 2297
void png_set_sPLT(png_structp png_ptr , png_infop info_ptr , png_sPLT_tp entries ,
                  int nentries ) ;
#line 2316
void png_set_text(png_structp png_ptr , png_infop info_ptr , png_textp text_ptr ,
                  int num_text ) ;
#line 2326
void png_set_tIME(png_structp png_ptr , png_infop info_ptr , png_timep mod_time ) ;
#line 2337
void png_set_tRNS(png_structp png_ptr , png_infop info_ptr , png_bytep trans , int num_trans ,
                  png_color_16p trans_values ) ;
#line 2363
void png_set_sCAL_s(png_structp png_ptr , png_infop info_ptr , int unit , png_charp swidth ,
                    png_charp sheight ) ;
#line 2379
void png_set_keep_unknown_chunks(png_structp png_ptr , int keep , png_bytep chunk_list ,
                                 int num_chunks ) ;
#line 2381
void png_set_unknown_chunks(png_structp png_ptr , png_infop info_ptr , png_unknown_chunkp unknowns ,
                            int num_unknowns ) ;
#line 2383
void png_set_unknown_chunk_location(png_structp png_ptr , png_infop info_ptr , int chunk ,
                                    int location ) ;
#line 2396
void png_set_invalid(png_structp png_ptr , png_infop info_ptr , int mask ) ;
#line 3074
int png_set_text_2(png_structp png_ptr , png_infop info_ptr , png_textp text_ptr ,
                   int num_text ) ;
#line 22 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_bKGD(png_structp png_ptr , png_infop info_ptr , png_color_16p background ) 
{ 


  {
#line 26
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 27
    return;
  } else
#line 26
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 27
    return;
  }
  {
#line 29
  memcpy((void */* __restrict  */)(& info_ptr->background), (void const   */* __restrict  */)background,
         sizeof(png_color_16 ));
#line 30
  info_ptr->valid |= 32UL;
  }
#line 31
  return;
}
}
#line 86 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_cHRM_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point white_x ,
                        png_fixed_point white_y , png_fixed_point red_x , png_fixed_point red_y ,
                        png_fixed_point green_x , png_fixed_point green_y , png_fixed_point blue_x ,
                        png_fixed_point blue_y ) 
{ 


  {
#line 93
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 94
    return;
  } else
#line 93
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 94
    return;
  }
#line 96
  if (white_x < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (white_y < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (red_x < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (red_y < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (green_x < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (green_y < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (blue_x < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  } else
#line 96
  if (blue_y < 0L) {
    {
#line 101
    png_warning(png_ptr, "Ignoring attempt to set negative chromaticity value");
    }
#line 103
    return;
  }
#line 115
  if (white_x > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (white_y > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (red_x > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (red_y > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (green_x > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (green_y > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (blue_x > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  } else
#line 115
  if (blue_y > 21474L) {
    {
#line 125
    png_warning(png_ptr, "Ignoring attempt to set chromaticity value exceeding 21474.83");
    }
#line 127
    return;
  }
#line 129
  info_ptr->int_x_white = white_x;
#line 130
  info_ptr->int_y_white = white_y;
#line 131
  info_ptr->int_x_red = red_x;
#line 132
  info_ptr->int_y_red = red_y;
#line 133
  info_ptr->int_x_green = green_x;
#line 134
  info_ptr->int_y_green = green_y;
#line 135
  info_ptr->int_x_blue = blue_x;
#line 136
  info_ptr->int_y_blue = blue_y;
#line 147
  info_ptr->valid |= 4UL;
#line 148
  return;
}
}
#line 179 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_gAMA_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point int_gamma ) 
{ 
  png_fixed_point gamma ;

  {
#line 186
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 187
    return;
  } else
#line 186
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 187
    return;
  }
#line 189
  if (int_gamma > 2147483647L) {
    {
#line 191
    png_warning(png_ptr, "Limiting gamma to 21474.83");
#line 192
    gamma = (png_fixed_point )((png_uint_32 )2147483647L);
    }
  } else
#line 196
  if (int_gamma < 0L) {
    {
#line 198
    png_warning(png_ptr, "Setting negative gamma to zero");
#line 199
    gamma = (png_fixed_point )0;
    }
  } else {
#line 202
    gamma = int_gamma;
  }
#line 208
  info_ptr->int_gamma = gamma;
#line 210
  info_ptr->valid |= 1UL;
#line 211
  if (gamma == 0L) {
    {
#line 212
    png_warning(png_ptr, "Setting gamma=0");
    }
  }
#line 213
  return;
}
}
#line 217 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_16p hist ) 
{ 
  int i ;
  png_voidp tmp ;

  {
#line 223
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 224
    return;
  } else
#line 223
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 224
    return;
  }
#line 225
  if ((int )info_ptr->num_palette <= 0) {
    {
#line 228
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped.");
    }
#line 230
    return;
  } else
#line 225
  if ((int )info_ptr->num_palette > 256) {
    {
#line 228
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped.");
    }
#line 230
    return;
  }
  {
#line 234
  png_free_data(png_ptr, info_ptr, (png_uint_32 )8, 0);
#line 238
  tmp = png_malloc_warn(png_ptr, 256UL * sizeof(png_uint_16 ));
#line 238
  png_ptr->hist = (png_uint_16p )tmp;
  }
#line 240
  if ((unsigned long )png_ptr->hist == (unsigned long )((void *)0)) {
    {
#line 242
    png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
    }
#line 243
    return;
  }
#line 246
  i = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < (int )info_ptr->num_palette)) {
#line 246
      goto while_break;
    }
#line 247
    *(png_ptr->hist + i) = *(hist + i);
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  info_ptr->hist = png_ptr->hist;
#line 249
  info_ptr->valid |= 64UL;
#line 252
  info_ptr->free_me |= 8UL;
#line 256
  return;
}
}
#line 259 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 width , png_uint_32 height ,
                  int bit_depth , int color_type , int interlace_type , int compression_type ,
                  int filter_type ) 
{ 


  {
#line 266
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 267
    return;
  } else
#line 266
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 267
    return;
  }
#line 270
  if (width == 0UL) {
    {
#line 271
    png_error(png_ptr, "Image width or height is zero in IHDR");
    }
  } else
#line 270
  if (height == 0UL) {
    {
#line 271
    png_error(png_ptr, "Image width or height is zero in IHDR");
    }
  }
#line 276
  if (width > 2147483647UL) {
    {
#line 277
    png_error(png_ptr, "image size exceeds user limits in IHDR");
    }
  } else
#line 276
  if (height > 2147483647UL) {
    {
#line 277
    png_error(png_ptr, "image size exceeds user limits in IHDR");
    }
  }
#line 279
  if (width > 2147483647UL) {
    {
#line 280
    png_error(png_ptr, "Invalid image size in IHDR");
    }
  } else
#line 279
  if (height > 2147483647UL) {
    {
#line 280
    png_error(png_ptr, "Invalid image size in IHDR");
    }
  }
#line 281
  if (width > ((((0xffffffffffffffffUL >> 3) - 64UL) - 1UL) - 56UL) - 8UL) {
    {
#line 287
    png_warning(png_ptr, "Width is too large for libpng to process pixels");
    }
  }
#line 290
  if (bit_depth != 1) {
#line 290
    if (bit_depth != 2) {
#line 290
      if (bit_depth != 4) {
#line 290
        if (bit_depth != 8) {
#line 290
          if (bit_depth != 16) {
            {
#line 292
            png_error(png_ptr, "Invalid bit depth in IHDR");
            }
          }
        }
      }
    }
  }
#line 294
  if (color_type < 0) {
    {
#line 296
    png_error(png_ptr, "Invalid color type in IHDR");
    }
  } else
#line 294
  if (color_type == 1) {
    {
#line 296
    png_error(png_ptr, "Invalid color type in IHDR");
    }
  } else
#line 294
  if (color_type == 5) {
    {
#line 296
    png_error(png_ptr, "Invalid color type in IHDR");
    }
  } else
#line 294
  if (color_type > 6) {
    {
#line 296
    png_error(png_ptr, "Invalid color type in IHDR");
    }
  }
#line 298
  if (color_type == 3) {
#line 298
    if (bit_depth > 8) {
      {
#line 302
      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");
      }
    } else {
#line 298
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 298
  if (color_type == 2) {
#line 298
    goto _L;
  } else
#line 298
  if (color_type == 4) {
#line 298
    goto _L;
  } else
#line 298
  if (color_type == 6) {
    _L: /* CIL Label */ 
#line 298
    if (bit_depth < 8) {
      {
#line 302
      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");
      }
    }
  }
#line 304
  if (interlace_type >= 2) {
    {
#line 305
    png_error(png_ptr, "Unknown interlace method in IHDR");
    }
  }
#line 307
  if (compression_type != 0) {
    {
#line 308
    png_error(png_ptr, "Unknown compression method in IHDR");
    }
  }
#line 334
  if (filter_type != 0) {
    {
#line 335
    png_error(png_ptr, "Unknown filter method in IHDR");
    }
  }
#line 338
  info_ptr->width = width;
#line 339
  info_ptr->height = height;
#line 340
  info_ptr->bit_depth = (png_byte )bit_depth;
#line 341
  info_ptr->color_type = (png_byte )color_type;
#line 342
  info_ptr->compression_type = (png_byte )compression_type;
#line 343
  info_ptr->filter_type = (png_byte )filter_type;
#line 344
  info_ptr->interlace_type = (png_byte )interlace_type;
#line 345
  if ((int )info_ptr->color_type == 3) {
#line 346
    info_ptr->channels = (png_byte )1;
  } else
#line 347
  if ((int )info_ptr->color_type & 2) {
#line 348
    info_ptr->channels = (png_byte )3;
  } else {
#line 350
    info_ptr->channels = (png_byte )1;
  }
#line 351
  if ((int )info_ptr->color_type & 4) {
#line 352
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 353
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 356
  if (width > ((((0xffffffffffffffffUL >> 3) - 64UL) - 1UL) - 56UL) - 8UL) {
#line 362
    info_ptr->rowbytes = (png_size_t )0;
  } else
#line 364
  if ((int )info_ptr->pixel_depth >= 8) {
#line 364
    info_ptr->rowbytes = width * ((png_uint_32 )info_ptr->pixel_depth >> 3);
  } else {
#line 364
    info_ptr->rowbytes = (width * (png_uint_32 )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 365
  return;
}
}
#line 368 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_oFFs(png_structp png_ptr , png_infop info_ptr , png_int_32 offset_x ,
                  png_int_32 offset_y , int unit_type ) 
{ 


  {
#line 373
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 374
    return;
  } else
#line 373
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 374
    return;
  }
#line 376
  info_ptr->x_offset = offset_x;
#line 377
  info_ptr->y_offset = offset_y;
#line 378
  info_ptr->offset_unit_type = (png_byte )unit_type;
#line 379
  info_ptr->valid |= 256UL;
#line 380
  return;
}
}
#line 384 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_pCAL(png_structp png_ptr , png_infop info_ptr , png_charp purpose , png_int_32 X0 ,
                  png_int_32 X1 , int type , int nparams , png_charp units , png_charpp params ) 
{ 
  png_uint_32 length ;
  int i ;
  size_t tmp ;
  png_voidp tmp___0 ;
  size_t tmp___1 ;
  png_voidp tmp___2 ;
  png_voidp tmp___3 ;
  size_t tmp___4 ;
  png_voidp tmp___5 ;

  {
#line 393
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 394
    return;
  } else
#line 393
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 394
    return;
  }
  {
#line 396
  tmp = strlen((char const   *)purpose);
#line 396
  length = tmp + 1UL;
#line 398
  tmp___0 = png_malloc_warn(png_ptr, length);
#line 398
  info_ptr->pcal_purpose = (png_charp )tmp___0;
  }
#line 399
  if ((unsigned long )info_ptr->pcal_purpose == (unsigned long )((void *)0)) {
    {
#line 401
    png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
    }
#line 402
    return;
  }
  {
#line 404
  memcpy((void */* __restrict  */)info_ptr->pcal_purpose, (void const   */* __restrict  */)purpose,
         length);
#line 407
  info_ptr->pcal_X0 = X0;
#line 408
  info_ptr->pcal_X1 = X1;
#line 409
  info_ptr->pcal_type = (png_byte )type;
#line 410
  info_ptr->pcal_nparams = (png_byte )nparams;
#line 412
  tmp___1 = strlen((char const   *)units);
#line 412
  length = tmp___1 + 1UL;
#line 414
  tmp___2 = png_malloc_warn(png_ptr, length);
#line 414
  info_ptr->pcal_units = (png_charp )tmp___2;
  }
#line 415
  if ((unsigned long )info_ptr->pcal_units == (unsigned long )((void *)0)) {
    {
#line 417
    png_warning(png_ptr, "Insufficient memory for pCAL units.");
    }
#line 418
    return;
  }
  {
#line 420
  memcpy((void */* __restrict  */)info_ptr->pcal_units, (void const   */* __restrict  */)units,
         length);
#line 422
  tmp___3 = png_malloc_warn(png_ptr, (unsigned long )(nparams + 1) * sizeof(png_charp ));
#line 422
  info_ptr->pcal_params = (png_charpp )tmp___3;
  }
#line 424
  if ((unsigned long )info_ptr->pcal_params == (unsigned long )((void *)0)) {
    {
#line 426
    png_warning(png_ptr, "Insufficient memory for pCAL params.");
    }
#line 427
    return;
  }
#line 430
  *(info_ptr->pcal_params + nparams) = (char *)((void *)0);
#line 432
  i = 0;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < nparams)) {
#line 432
      goto while_break;
    }
    {
#line 434
    tmp___4 = strlen((char const   *)*(params + i));
#line 434
    length = tmp___4 + 1UL;
#line 436
    tmp___5 = png_malloc_warn(png_ptr, length);
#line 436
    *(info_ptr->pcal_params + i) = (png_charp )tmp___5;
    }
#line 437
    if ((unsigned long )*(info_ptr->pcal_params + i) == (unsigned long )((void *)0)) {
      {
#line 439
      png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
      }
#line 440
      return;
    }
    {
#line 442
    memcpy((void */* __restrict  */)*(info_ptr->pcal_params + i), (void const   */* __restrict  */)*(params + i),
           length);
#line 432
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  info_ptr->valid |= 1024UL;
#line 447
  info_ptr->free_me |= 128UL;
#line 449
  return;
}
}
#line 470 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_sCAL_s(png_structp png_ptr , png_infop info_ptr , int unit , png_charp swidth ,
                    png_charp sheight ) 
{ 
  png_uint_32 length ;
  size_t tmp ;
  png_voidp tmp___0 ;
  size_t tmp___1 ;
  png_voidp tmp___2 ;

  {
#line 477
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 478
    return;
  } else
#line 477
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 478
    return;
  }
  {
#line 480
  info_ptr->scal_unit = (png_byte )unit;
#line 482
  tmp = strlen((char const   *)swidth);
#line 482
  length = tmp + 1UL;
#line 484
  tmp___0 = png_malloc_warn(png_ptr, length);
#line 484
  info_ptr->scal_s_width = (png_charp )tmp___0;
  }
#line 485
  if ((unsigned long )info_ptr->scal_s_width == (unsigned long )((void *)0)) {
    {
#line 487
    png_warning(png_ptr, "Memory allocation failed while processing sCAL.");
    }
  }
  {
#line 489
  memcpy((void */* __restrict  */)info_ptr->scal_s_width, (void const   */* __restrict  */)swidth,
         length);
#line 491
  tmp___1 = strlen((char const   *)sheight);
#line 491
  length = tmp___1 + 1UL;
#line 493
  tmp___2 = png_malloc_warn(png_ptr, length);
#line 493
  info_ptr->scal_s_height = (png_charp )tmp___2;
  }
#line 494
  if ((unsigned long )info_ptr->scal_s_height == (unsigned long )((void *)0)) {
    {
#line 496
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_width);
#line 497
    png_warning(png_ptr, "Memory allocation failed while processing sCAL.");
    }
  }
  {
#line 499
  memcpy((void */* __restrict  */)info_ptr->scal_s_height, (void const   */* __restrict  */)sheight,
         length);
#line 501
  info_ptr->valid |= 16384UL;
#line 503
  info_ptr->free_me |= 256UL;
  }
#line 505
  return;
}
}
#line 511 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 res_x , png_uint_32 res_y ,
                  int unit_type ) 
{ 


  {
#line 516
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 517
    return;
  } else
#line 516
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 517
    return;
  }
#line 519
  info_ptr->x_pixels_per_unit = res_x;
#line 520
  info_ptr->y_pixels_per_unit = res_y;
#line 521
  info_ptr->phys_unit_type = (png_byte )unit_type;
#line 522
  info_ptr->valid |= 128UL;
#line 523
  return;
}
}
#line 526 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_PLTE(png_structp png_ptr , png_infop info_ptr , png_colorp palette ,
                  int num_palette ) 
{ 
  png_voidp tmp ;
  png_uint_16 tmp___0 ;

  {
#line 532
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 533
    return;
  } else
#line 532
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 533
    return;
  }
#line 535
  if (num_palette < 0) {
#line 535
    goto _L;
  } else
#line 535
  if (num_palette > 256) {
    _L: /* CIL Label */ 
#line 537
    if ((int )info_ptr->color_type == 3) {
      {
#line 538
      png_error(png_ptr, "Invalid palette length");
      }
    } else {
      {
#line 541
      png_warning(png_ptr, "Invalid palette length");
      }
#line 542
      return;
    }
  }
  {
#line 552
  png_free_data(png_ptr, info_ptr, (png_uint_32 )4096, 0);
#line 558
  tmp = png_malloc(png_ptr, 256UL * sizeof(png_color ));
#line 558
  png_ptr->palette = (png_colorp )tmp;
#line 560
  memset((void *)png_ptr->palette, 0, 256UL * sizeof(png_color ));
#line 562
  memcpy((void */* __restrict  */)png_ptr->palette, (void const   */* __restrict  */)palette,
         (unsigned long )num_palette * sizeof(png_color ));
#line 563
  info_ptr->palette = png_ptr->palette;
#line 564
  tmp___0 = (png_uint_16 )num_palette;
#line 564
  png_ptr->num_palette = tmp___0;
#line 564
  info_ptr->num_palette = tmp___0;
#line 567
  info_ptr->free_me |= 4096UL;
#line 572
  info_ptr->valid |= 8UL;
  }
#line 573
  return;
}
}
#line 576 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_sBIT(png_structp png_ptr , png_infop info_ptr , png_color_8p sig_bit ) 
{ 


  {
#line 581
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 582
    return;
  } else
#line 581
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 582
    return;
  }
  {
#line 584
  memcpy((void */* __restrict  */)(& info_ptr->sig_bit), (void const   */* __restrict  */)sig_bit,
         sizeof(png_color_8 ));
#line 585
  info_ptr->valid |= 2UL;
  }
#line 586
  return;
}
}
#line 590 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_sRGB(png_structp png_ptr , png_infop info_ptr , int intent ) 
{ 


  {
#line 594
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 595
    return;
  } else
#line 594
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 595
    return;
  }
#line 597
  info_ptr->srgb_intent = (png_byte )intent;
#line 598
  info_ptr->valid |= 2048UL;
#line 599
  return;
}
}
#line 601 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr , png_infop info_ptr , int intent ) 
{ 
  png_fixed_point int_file_gamma ;
  png_fixed_point int_white_x ;
  png_fixed_point int_white_y ;
  png_fixed_point int_red_x ;
  png_fixed_point int_red_y ;
  png_fixed_point int_green_x ;
  png_fixed_point int_green_y ;
  png_fixed_point int_blue_x ;
  png_fixed_point int_blue_y ;

  {
#line 623
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 624
    return;
  } else
#line 623
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 624
    return;
  }
  {
#line 626
  png_set_sRGB(png_ptr, info_ptr, intent);
#line 634
  int_file_gamma = 45455L;
#line 635
  png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
#line 641
  int_white_x = 31270L;
#line 642
  int_white_y = 32900L;
#line 643
  int_red_x = 64000L;
#line 644
  int_red_y = 33000L;
#line 645
  int_green_x = 30000L;
#line 646
  int_green_y = 60000L;
#line 647
  int_blue_x = 15000L;
#line 648
  int_blue_y = 6000L;
#line 650
  png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y, int_red_x, int_red_y,
                     int_green_x, int_green_y, int_blue_x, int_blue_y);
  }
#line 668
  return;
}
}
#line 673 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_iCCP(png_structp png_ptr , png_infop info_ptr , png_charp name , int compression_type ,
                  png_charp profile , png_uint_32 proflen ) 
{ 
  png_charp new_iccp_name ;
  png_charp new_iccp_profile ;
  size_t tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;

  {
#line 682
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 683
    return;
  } else
#line 682
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 683
    return;
  } else
#line 682
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 683
    return;
  } else
#line 682
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 683
    return;
  }
  {
#line 685
  tmp = strlen((char const   *)name);
#line 685
  tmp___0 = png_malloc_warn(png_ptr, tmp + 1UL);
#line 685
  new_iccp_name = (png_charp )tmp___0;
  }
#line 686
  if ((unsigned long )new_iccp_name == (unsigned long )((void *)0)) {
    {
#line 688
    png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
    }
#line 689
    return;
  }
  {
#line 691
  strcpy((char */* __restrict  */)new_iccp_name, (char const   */* __restrict  */)name);
#line 692
  tmp___1 = png_malloc_warn(png_ptr, proflen);
#line 692
  new_iccp_profile = (png_charp )tmp___1;
  }
#line 693
  if ((unsigned long )new_iccp_profile == (unsigned long )((void *)0)) {
    {
#line 695
    png_free(png_ptr, (png_voidp )new_iccp_name);
#line 696
    png_warning(png_ptr, "Insufficient memory to process iCCP profile.");
    }
#line 697
    return;
  }
  {
#line 699
  memcpy((void */* __restrict  */)new_iccp_profile, (void const   */* __restrict  */)profile,
         proflen);
#line 701
  png_free_data(png_ptr, info_ptr, (png_uint_32 )16, 0);
#line 703
  info_ptr->iccp_proflen = proflen;
#line 704
  info_ptr->iccp_name = new_iccp_name;
#line 705
  info_ptr->iccp_profile = new_iccp_profile;
#line 708
  info_ptr->iccp_compression = (png_byte )compression_type;
#line 710
  info_ptr->free_me |= 16UL;
#line 712
  info_ptr->valid |= 4096UL;
  }
#line 713
  return;
}
}
#line 717 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_text(png_structp png_ptr , png_infop info_ptr , png_textp text_ptr ,
                  int num_text ) 
{ 
  int ret ;

  {
  {
#line 722
  ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
  }
#line 723
  if (ret) {
    {
#line 724
    png_error(png_ptr, "Insufficient memory to store text");
    }
  }
#line 725
  return;
}
}
#line 727 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
int png_set_text_2(png_structp png_ptr , png_infop info_ptr , png_textp text_ptr ,
                   int num_text ) 
{ 
  int i ;
  png_textp old_text ;
  int old_max ;
  png_voidp tmp ;
  png_voidp tmp___0 ;
  png_size_t text_length ;
  png_size_t key_len ;
  png_size_t lang_len ;
  png_size_t lang_key_len ;
  png_textp textp ;
  png_voidp tmp___1 ;

  {
#line 736
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 737
    return (0);
  } else
#line 736
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 737
    return (0);
  } else
#line 736
  if (num_text == 0) {
#line 737
    return (0);
  }
#line 742
  if (info_ptr->num_text + num_text > info_ptr->max_text) {
#line 744
    if ((unsigned long )info_ptr->text != (unsigned long )((void *)0)) {
      {
#line 749
      old_max = info_ptr->max_text;
#line 750
      info_ptr->max_text = (info_ptr->num_text + num_text) + 8;
#line 751
      old_text = info_ptr->text;
#line 752
      tmp = png_malloc_warn(png_ptr, (unsigned long )info_ptr->max_text * sizeof(png_text ));
#line 752
      info_ptr->text = (png_textp )tmp;
      }
#line 754
      if ((unsigned long )info_ptr->text == (unsigned long )((void *)0)) {
        {
#line 756
        png_free(png_ptr, (png_voidp )old_text);
        }
#line 757
        return (1);
      }
      {
#line 759
      memcpy((void */* __restrict  */)info_ptr->text, (void const   */* __restrict  */)old_text,
             (unsigned long )old_max * sizeof(png_text ));
#line 761
      png_free(png_ptr, (png_voidp )old_text);
      }
    } else {
      {
#line 765
      info_ptr->max_text = num_text + 8;
#line 766
      info_ptr->num_text = 0;
#line 767
      tmp___0 = png_malloc_warn(png_ptr, (unsigned long )info_ptr->max_text * sizeof(png_text ));
#line 767
      info_ptr->text = (png_textp )tmp___0;
      }
#line 769
      if ((unsigned long )info_ptr->text == (unsigned long )((void *)0)) {
#line 770
        return (1);
      }
#line 772
      info_ptr->free_me |= 16384UL;
    }
  }
#line 778
  i = 0;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! (i < num_text)) {
#line 778
      goto while_break;
    }
#line 782
    textp = info_ptr->text + info_ptr->num_text;
#line 784
    if ((unsigned long )(text_ptr + i)->key == (unsigned long )((void *)0)) {
#line 785
      goto __Cont;
    }
    {
#line 787
    key_len = strlen((char const   *)(text_ptr + i)->key);
    }
#line 789
    if ((text_ptr + i)->compression <= 0) {
#line 791
      lang_len = (png_size_t )0;
#line 792
      lang_key_len = (png_size_t )0;
    } else {
      {
#line 809
      png_warning(png_ptr, "iTXt chunk not supported.");
      }
#line 810
      goto __Cont;
    }
#line 814
    if ((unsigned long )(text_ptr + i)->text == (unsigned long )((void *)0)) {
#line 816
      text_length = (png_size_t )0;
#line 822
      textp->compression = -1;
    } else
#line 814
    if ((int )*((text_ptr + i)->text + 0) == 0) {
#line 816
      text_length = (png_size_t )0;
#line 822
      textp->compression = -1;
    } else {
      {
#line 826
      text_length = strlen((char const   *)(text_ptr + i)->text);
#line 827
      textp->compression = (text_ptr + i)->compression;
      }
    }
    {
#line 830
    tmp___1 = png_malloc_warn(png_ptr, (((key_len + text_length) + lang_len) + lang_key_len) + 4UL);
#line 830
    textp->key = (png_charp )tmp___1;
    }
#line 832
    if ((unsigned long )textp->key == (unsigned long )((void *)0)) {
#line 833
      return (1);
    }
    {
#line 838
    memcpy((void */* __restrict  */)textp->key, (void const   */* __restrict  */)(text_ptr + i)->key,
           key_len);
#line 840
    *(textp->key + key_len) = (char )'\000';
#line 859
    textp->text = (textp->key + key_len) + 1;
    }
#line 861
    if (text_length) {
      {
#line 862
      memcpy((void */* __restrict  */)textp->text, (void const   */* __restrict  */)(text_ptr + i)->text,
             text_length);
      }
    }
#line 864
    *(textp->text + text_length) = (char )'\000';
#line 875
    textp->text_length = text_length;
#line 880
    *(info_ptr->text + info_ptr->num_text) = *textp;
#line 881
    (info_ptr->num_text) ++;
    __Cont: /* CIL Label */ 
#line 778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  return (0);
}
}
#line 889 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_tIME(png_structp png_ptr , png_infop info_ptr , png_timep mod_time ) 
{ 


  {
#line 893
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 895
    return;
  } else
#line 893
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 895
    return;
  } else
#line 893
  if (png_ptr->mode & 512UL) {
#line 895
    return;
  }
  {
#line 897
  memcpy((void */* __restrict  */)(& info_ptr->mod_time), (void const   */* __restrict  */)mod_time,
         sizeof(png_time ));
#line 898
  info_ptr->valid |= 512UL;
  }
#line 899
  return;
}
}
#line 903 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_tRNS(png_structp png_ptr , png_infop info_ptr , png_bytep trans , int num_trans ,
                  png_color_16p trans_values ) 
{ 
  png_bytep tmp ;
  png_voidp tmp___0 ;

  {
#line 908
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 909
    return;
  } else
#line 908
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 909
    return;
  }
#line 911
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
#line 919
    png_free_data(png_ptr, info_ptr, (png_uint_32 )8192, 0);
#line 922
    tmp___0 = png_malloc(png_ptr, (png_uint_32 )256);
#line 922
    tmp = (png_bytep )tmp___0;
#line 922
    info_ptr->trans = tmp;
#line 922
    png_ptr->trans = tmp;
    }
#line 924
    if (num_trans <= 256) {
      {
#line 925
      memcpy((void */* __restrict  */)info_ptr->trans, (void const   */* __restrict  */)trans,
             (png_size_t )num_trans);
      }
    }
#line 927
    info_ptr->free_me |= 8192UL;
  }
#line 933
  if ((unsigned long )trans_values != (unsigned long )((void *)0)) {
    {
#line 935
    memcpy((void */* __restrict  */)(& info_ptr->trans_values), (void const   */* __restrict  */)trans_values,
           sizeof(png_color_16 ));
    }
#line 937
    if (num_trans == 0) {
#line 938
      num_trans = 1;
    }
  }
#line 940
  info_ptr->num_trans = (png_uint_16 )num_trans;
#line 941
  info_ptr->valid |= 16UL;
#line 942
  return;
}
}
#line 946 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_sPLT(png_structp png_ptr , png_infop info_ptr , png_sPLT_tp entries ,
                  int nentries ) 
{ 
  png_sPLT_tp np ;
  int i ;
  png_voidp tmp ;
  png_sPLT_tp to ;
  png_sPLT_tp from ;
  size_t tmp___0 ;
  png_voidp tmp___1 ;
  png_voidp tmp___2 ;

  {
#line 953
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 954
    return;
  } else
#line 953
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 954
    return;
  }
  {
#line 956
  tmp = png_malloc_warn(png_ptr, (info_ptr->splt_palettes_num + (png_uint_32 )nentries) * sizeof(png_sPLT_t ));
#line 956
  np = (png_sPLT_tp )tmp;
  }
#line 958
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    {
#line 960
    png_warning(png_ptr, "No memory for sPLT palettes.");
    }
#line 961
    return;
  }
  {
#line 964
  memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)info_ptr->splt_palettes,
         info_ptr->splt_palettes_num * sizeof(png_sPLT_t ));
#line 966
  png_free(png_ptr, (png_voidp )info_ptr->splt_palettes);
#line 967
  info_ptr->splt_palettes = (png_sPLT_tp )((void *)0);
#line 969
  i = 0;
  }
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (i < nentries)) {
#line 969
      goto while_break;
    }
    {
#line 971
    to = (np + info_ptr->splt_palettes_num) + i;
#line 972
    from = entries + i;
#line 974
    tmp___0 = strlen((char const   *)from->name);
#line 974
    tmp___1 = png_malloc(png_ptr, tmp___0 + 1UL);
#line 974
    to->name = (png_charp )tmp___1;
#line 977
    strcpy((char */* __restrict  */)to->name, (char const   */* __restrict  */)from->name);
#line 978
    tmp___2 = png_malloc(png_ptr, (unsigned long )from->nentries * sizeof(png_sPLT_t ));
#line 978
    to->entries = (png_sPLT_entryp )tmp___2;
#line 981
    memcpy((void */* __restrict  */)to->entries, (void const   */* __restrict  */)from->entries,
           (unsigned long )from->nentries * sizeof(png_sPLT_t ));
#line 983
    to->nentries = from->nentries;
#line 984
    to->depth = from->depth;
#line 969
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  info_ptr->splt_palettes = np;
#line 988
  info_ptr->splt_palettes_num += (png_uint_32 )nentries;
#line 989
  info_ptr->valid |= 8192UL;
#line 991
  info_ptr->free_me |= 32UL;
#line 993
  return;
}
}
#line 997 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_unknown_chunks(png_structp png_ptr , png_infop info_ptr , png_unknown_chunkp unknowns ,
                            int num_unknowns ) 
{ 
  png_unknown_chunkp np ;
  int i ;
  png_voidp tmp ;
  png_unknown_chunkp to ;
  png_unknown_chunkp from ;
  png_voidp tmp___0 ;

  {
#line 1004
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1005
    return;
  } else
#line 1004
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1005
    return;
  } else
#line 1004
  if (num_unknowns == 0) {
#line 1005
    return;
  }
  {
#line 1007
  tmp = png_malloc_warn(png_ptr, (info_ptr->unknown_chunks_num + (png_size_t )num_unknowns) * sizeof(png_unknown_chunk ));
#line 1007
  np = (png_unknown_chunkp )tmp;
  }
#line 1010
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    {
#line 1012
    png_warning(png_ptr, "Out of memory while processing unknown chunk.");
    }
#line 1013
    return;
  }
  {
#line 1016
  memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)info_ptr->unknown_chunks,
         info_ptr->unknown_chunks_num * sizeof(png_unknown_chunk ));
#line 1018
  png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 1019
  info_ptr->unknown_chunks = (png_unknown_chunkp )((void *)0);
#line 1021
  i = 0;
  }
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1021
    if (! (i < num_unknowns)) {
#line 1021
      goto while_break;
    }
    {
#line 1023
    to = (np + info_ptr->unknown_chunks_num) + i;
#line 1024
    from = unknowns + i;
#line 1026
    strncpy((char */* __restrict  */)((png_charp )(to->name)), (char const   */* __restrict  */)((png_charp )(from->name)),
            (size_t )5);
#line 1027
    tmp___0 = png_malloc_warn(png_ptr, from->size);
#line 1027
    to->data = (png_bytep )tmp___0;
    }
#line 1028
    if ((unsigned long )to->data == (unsigned long )((void *)0)) {
      {
#line 1030
      png_warning(png_ptr, "Out of memory processing unknown chunk.");
      }
    } else {
      {
#line 1034
      memcpy((void */* __restrict  */)to->data, (void const   */* __restrict  */)from->data,
             from->size);
#line 1035
      to->size = from->size;
#line 1038
      to->location = (png_byte )(png_ptr->mode & 255UL);
      }
    }
#line 1021
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1042
  info_ptr->unknown_chunks = np;
#line 1043
  info_ptr->unknown_chunks_num += (png_size_t )num_unknowns;
#line 1045
  info_ptr->free_me |= 512UL;
#line 1047
  return;
}
}
#line 1048 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_unknown_chunk_location(png_structp png_ptr , png_infop info_ptr , int chunk ,
                                    int location ) 
{ 


  {
#line 1052
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1052
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1052
      if (chunk >= 0) {
#line 1052
        if (chunk < (int )info_ptr->unknown_chunks_num) {
#line 1054
          (info_ptr->unknown_chunks + chunk)->location = (png_byte )location;
        }
      }
    }
  }
#line 1055
  return;
}
}
#line 1061 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_permit_empty_plte(png_structp png_ptr , int empty_plte_permitted ) 
{ 


  {
#line 1067
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1068
    return;
  }
#line 1069
  png_ptr->mng_features_permitted = (png_uint_32 )((png_byte )((png_ptr->mng_features_permitted & 0xfffffffffffffffeUL) | (unsigned long )(empty_plte_permitted & 1)));
#line 1072
  return;
}
}
#line 1090 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_keep_unknown_chunks(png_structp png_ptr , int keep , png_bytep chunk_list ,
                                 int num_chunks ) 
{ 
  png_bytep new_list ;
  png_bytep p ;
  int i ;
  int old_num_chunks ;
  png_voidp tmp ;

  {
#line 1096
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1097
    return;
  }
#line 1098
  if (num_chunks == 0) {
#line 1100
    if (keep == 3) {
#line 1101
      png_ptr->flags |= 32768UL;
    } else
#line 1100
    if (keep == 2) {
#line 1101
      png_ptr->flags |= 32768UL;
    } else {
#line 1103
      png_ptr->flags &= 0xffffffffffff7fffUL;
    }
#line 1105
    if (keep == 3) {
#line 1106
      png_ptr->flags |= 65536UL;
    } else {
#line 1108
      png_ptr->flags &= 0xfffffffffffeffffUL;
    }
#line 1109
    return;
  }
#line 1111
  if ((unsigned long )chunk_list == (unsigned long )((void *)0)) {
#line 1112
    return;
  }
  {
#line 1113
  old_num_chunks = png_ptr->num_chunk_list;
#line 1114
  tmp = png_malloc(png_ptr, (png_uint_32 )(5 * (num_chunks + old_num_chunks)));
#line 1114
  new_list = (png_bytep )tmp;
  }
#line 1116
  if ((unsigned long )png_ptr->chunk_list != (unsigned long )((void *)0)) {
    {
#line 1118
    memcpy((void */* __restrict  */)new_list, (void const   */* __restrict  */)png_ptr->chunk_list,
           (png_size_t )(5 * old_num_chunks));
#line 1120
    png_free(png_ptr, (png_voidp )png_ptr->chunk_list);
#line 1121
    png_ptr->chunk_list = (png_bytep )((void *)0);
    }
  }
  {
#line 1123
  memcpy((void */* __restrict  */)(new_list + 5 * old_num_chunks), (void const   */* __restrict  */)chunk_list,
         (png_size_t )(5 * num_chunks));
#line 1125
  p = (new_list + 5 * old_num_chunks) + 4;
#line 1125
  i = 0;
  }
  {
#line 1125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1125
    if (! (i < num_chunks)) {
#line 1125
      goto while_break;
    }
#line 1126
    *p = (png_byte )keep;
#line 1125
    i ++;
#line 1125
    p += 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  png_ptr->num_chunk_list = old_num_chunks + num_chunks;
#line 1128
  png_ptr->chunk_list = new_list;
#line 1130
  png_ptr->free_me |= 1024UL;
#line 1132
  return;
}
}
#line 1136 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_read_user_chunk_fn(png_structp png_ptr , png_voidp user_chunk_ptr , int (*read_user_chunk_fn)(png_structp  ,
                                                                                                           png_unknown_chunkp  ) ) 
{ 


  {
#line 1141
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1142
    return;
  }
#line 1143
  png_ptr->read_user_chunk_fn = read_user_chunk_fn;
#line 1144
  png_ptr->user_chunk_ptr = user_chunk_ptr;
#line 1145
  return;
}
}
#line 1149 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_rows(png_structp png_ptr , png_infop info_ptr , png_bytepp row_pointers ) 
{ 


  {
#line 1154
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1155
    return;
  } else
#line 1154
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1155
    return;
  }
#line 1157
  if (info_ptr->row_pointers) {
#line 1157
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )row_pointers) {
      {
#line 1158
      png_free_data(png_ptr, info_ptr, (png_uint_32 )64, 0);
      }
    }
  }
#line 1159
  info_ptr->row_pointers = row_pointers;
#line 1160
  if (row_pointers) {
#line 1161
    info_ptr->valid |= 32768UL;
  }
#line 1162
  return;
}
}
#line 1166 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_compression_buffer_size(png_structp png_ptr , png_uint_32 size ) 
{ 
  png_voidp tmp ;

  {
#line 1169
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1170
    return;
  }
#line 1171
  if (png_ptr->zbuf) {
    {
#line 1172
    png_free(png_ptr, (png_voidp )png_ptr->zbuf);
    }
  }
  {
#line 1173
  png_ptr->zbuf_size = size;
#line 1174
  tmp = png_malloc(png_ptr, size);
#line 1174
  png_ptr->zbuf = (png_bytep )tmp;
#line 1175
  png_ptr->zstream.next_out = png_ptr->zbuf;
#line 1176
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
  }
#line 1177
  return;
}
}
#line 1180 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngset.c"
void png_set_invalid(png_structp png_ptr , png_infop info_ptr , int mask ) 
{ 


  {
#line 1183
  if (png_ptr) {
#line 1183
    if (info_ptr) {
#line 1184
      info_ptr->valid &= (unsigned long )(~ mask);
    }
  }
#line 1185
  return;
}
}
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 2018 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
png_voidp png_memset_check(png_structp png_ptr , png_voidp s1 , int value , png_uint_32 length ) ;
#line 2031
void png_chunk_error(png_structp png_ptr , png_const_charp error_message ) ;
#line 2039
void png_chunk_warning(png_structp png_ptr , png_const_charp warning_message ) ;
#line 2622
png_uint_32 png_get_uint_32(png_bytep buf___1 ) ;
#line 2623
png_uint_16 png_get_uint_16(png_bytep buf___1 ) ;
#line 2624
png_int_32 png_get_int_32(png_bytep buf___1 ) ;
#line 2626
png_uint_32 png_get_uint_31(png_structp png_ptr , png_bytep buf___1 ) ;
#line 2935
void png_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 2939
void png_crc_read(png_structp png_ptr , png_bytep buf___1 , png_size_t length ) ;
#line 2945
png_charp png_decompress_chunk(png_structp png_ptr , int comp_type , png_charp chunkdata ,
                               png_size_t chunklength , png_size_t prefix_size , png_size_t *newlength ) ;
#line 2951
int png_crc_finish(png_structp png_ptr , png_uint_32 skip ) ;
#line 2954
int png_crc_error(png_structp png_ptr ) ;
#line 3123
void png_combine_row(png_structp png_ptr , png_bytep row , int mask ) ;
#line 3132
void png_do_read_interlace(png_structp png_ptr ) ;
#line 3144
void png_read_filter_row(png_structp png_ptr , png_row_infop row_info , png_bytep row ,
                         png_bytep prev_row , int filter ) ;
#line 3155
void png_read_finish_row(png_structp png_ptr ) ;
#line 3158
void png_read_start_row(png_structp png_ptr ) ;
#line 3286
void png_handle_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3288
void png_handle_PLTE(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3290
void png_handle_IEND(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3294
void png_handle_bKGD(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3299
void png_handle_cHRM(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3304
void png_handle_gAMA(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3309
void png_handle_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3314
void png_handle_iCCP(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3324
void png_handle_oFFs(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3329
void png_handle_pCAL(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3334
void png_handle_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3339
void png_handle_sBIT(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3344
void png_handle_sCAL(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3349
void png_handle_sPLT(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3354
void png_handle_sRGB(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3359
void png_handle_tEXt(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3364
void png_handle_tIME(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3369
void png_handle_tRNS(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3374
void png_handle_zTXt(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3378
void png_handle_unknown(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) ;
#line 3381
void png_check_chunk_name(png_structp png_ptr , png_bytep chunk_name ) ;
#line 3388
void png_init_read_transformations(png_structp png_ptr ) ;
#line 43 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
png_uint_32 png_get_uint_31(png_structp png_ptr , png_bytep buf___1 ) 
{ 
  png_uint_32 i ;
  png_uint_32 tmp ;

  {
  {
#line 46
  tmp = png_get_uint_32(buf___1);
#line 46
  i = tmp;
  }
#line 47
  if (i > 2147483647UL) {
    {
#line 48
    png_error(png_ptr, "PNG unsigned integer out of range.");
    }
  }
#line 49
  return (i);
}
}
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
png_uint_32 png_get_uint_32(png_bytep buf___1 ) 
{ 
  png_uint_32 i ;

  {
#line 56
  i = ((((png_uint_32 )*buf___1 << 24) + ((png_uint_32 )*(buf___1 + 1) << 16)) + ((png_uint_32 )*(buf___1 + 2) << 8)) + (png_uint_32 )*(buf___1 + 3);
#line 61
  return (i);
}
}
#line 67 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
png_int_32 png_get_int_32(png_bytep buf___1 ) 
{ 
  png_int_32 i ;

  {
#line 70
  i = ((((png_int_32 )*buf___1 << 24) + ((png_int_32 )*(buf___1 + 1) << 16)) + ((png_int_32 )*(buf___1 + 2) << 8)) + (png_int_32 )*(buf___1 + 3);
#line 75
  return (i);
}
}
#line 79 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
png_uint_16 png_get_uint_16(png_bytep buf___1 ) 
{ 
  png_uint_16 i ;

  {
#line 82
  i = (png_uint_16 )(((int )((png_uint_16 )*buf___1) << 8) + (int )((png_uint_16 )*(buf___1 + 1)));
#line 85
  return (i);
}
}
#line 90 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_crc_read(png_structp png_ptr , png_bytep buf___1 , png_size_t length ) 
{ 


  {
  {
#line 93
  png_read_data(png_ptr, buf___1, length);
#line 94
  png_calculate_crc(png_ptr, buf___1, length);
  }
#line 95
  return;
}
}
#line 101 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
int png_crc_finish(png_structp png_ptr , png_uint_32 skip ) 
{ 
  png_size_t i ;
  png_size_t istop ;
  int tmp ;

  {
#line 105
  istop = png_ptr->zbuf_size;
#line 107
  i = skip;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i > istop)) {
#line 107
      goto while_break;
    }
    {
#line 109
    png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
#line 107
    i -= istop;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  if (i) {
    {
#line 113
    png_crc_read(png_ptr, png_ptr->zbuf, i);
    }
  }
  {
#line 116
  tmp = png_crc_error(png_ptr);
  }
#line 116
  if (tmp) {
#line 118
    if ((int )png_ptr->chunk_name[0] & 32) {
#line 118
      if (! (png_ptr->flags & 512UL)) {
        {
#line 123
        png_chunk_warning(png_ptr, "CRC error");
        }
      } else {
#line 118
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 118
    if (! ((int )png_ptr->chunk_name[0] & 32)) {
#line 118
      if (png_ptr->flags & 1024UL) {
        {
#line 123
        png_chunk_warning(png_ptr, "CRC error");
        }
      } else {
        {
#line 127
        png_chunk_error(png_ptr, "CRC error");
        }
      }
    } else {
      {
#line 127
      png_chunk_error(png_ptr, "CRC error");
      }
    }
#line 129
    return (1);
  }
#line 132
  return (0);
}
}
#line 137 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
int png_crc_error(png_structp png_ptr ) 
{ 
  png_byte crc_bytes[4] ;
  png_uint_32 crc ;
  int need_crc ;

  {
#line 142
  need_crc = 1;
#line 144
  if ((int )png_ptr->chunk_name[0] & 32) {
#line 146
    if ((png_ptr->flags & 768UL) == 768UL) {
#line 148
      need_crc = 0;
    }
  } else
#line 152
  if (png_ptr->flags & 2048UL) {
#line 153
    need_crc = 0;
  }
  {
#line 156
  png_read_data(png_ptr, crc_bytes, (png_size_t )4);
  }
#line 158
  if (need_crc) {
    {
#line 160
    crc = png_get_uint_32(crc_bytes);
    }
#line 161
    return (crc != png_ptr->crc);
  } else {
#line 164
    return (0);
  }
}
}
#line 181 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
static char msg[31]  = 
#line 181
  {      (char )'E',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )' ',      (char )'d',      (char )'e', 
        (char )'c',      (char )'o',      (char )'d',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'r', 
        (char )'e',      (char )'s',      (char )'s',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\000'};
#line 176 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
png_charp png_decompress_chunk(png_structp png_ptr , int comp_type , png_charp chunkdata ,
                               png_size_t chunklength , png_size_t prefix_size , png_size_t *newlength ) 
{ 
  png_charp text ;
  png_size_t text_size ;
  int ret ;
  png_voidp tmp ;
  png_voidp tmp___0 ;
  png_charp tmp___1 ;
  png_voidp tmp___2 ;
  char umsg[52] ;
  png_voidp tmp___3 ;
  char umsg___0[50] ;

  {
#line 185
  if (comp_type == 0) {
#line 187
    ret = 0;
#line 188
    png_ptr->zstream.next_in = (png_bytep )(chunkdata + prefix_size);
#line 189
    png_ptr->zstream.avail_in = (uInt )(chunklength - prefix_size);
#line 190
    png_ptr->zstream.next_out = png_ptr->zbuf;
#line 191
    png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 193
    text_size = (png_size_t )0;
#line 194
    text = (png_charp )((void *)0);
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! png_ptr->zstream.avail_in) {
#line 196
        goto while_break;
      }
      {
#line 198
      ret = inflate(& png_ptr->zstream, 1);
      }
#line 199
      if (ret != 0) {
#line 199
        if (ret != 1) {
#line 201
          if ((unsigned long )png_ptr->zstream.msg != (unsigned long )((void *)0)) {
            {
#line 202
            png_warning(png_ptr, (png_const_charp )png_ptr->zstream.msg);
            }
          } else {
            {
#line 204
            png_warning(png_ptr, (png_const_charp )(msg));
            }
          }
          {
#line 205
          inflateReset(& png_ptr->zstream);
#line 206
          png_ptr->zstream.avail_in = (uInt )0;
          }
#line 208
          if ((unsigned long )text == (unsigned long )((void *)0)) {
            {
#line 210
            text_size = (prefix_size + sizeof(msg)) + 1UL;
#line 211
            tmp = png_malloc_warn(png_ptr, text_size);
#line 211
            text = (png_charp )tmp;
            }
#line 212
            if ((unsigned long )text == (unsigned long )((void *)0)) {
              {
#line 214
              png_free(png_ptr, (png_voidp )chunkdata);
#line 215
              png_error(png_ptr, "Not enough memory to decompress chunk");
              }
            }
            {
#line 217
            memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)chunkdata,
                   prefix_size);
            }
          }
#line 220
          *(text + (text_size - 1UL)) = (char)0;
#line 223
          text_size = (chunklength - (png_size_t )(text - chunkdata)) - 1UL;
#line 224
          if (sizeof(msg) > text_size) {
#line 224
            text_size = text_size;
          } else {
#line 224
            text_size = sizeof(msg);
          }
          {
#line 226
          memcpy((void */* __restrict  */)(text + prefix_size), (void const   */* __restrict  */)(msg),
                 text_size + 1UL);
          }
#line 227
          goto while_break;
        }
      }
#line 229
      if (! png_ptr->zstream.avail_out) {
#line 229
        goto _L;
      } else
#line 229
      if (ret == 1) {
        _L: /* CIL Label */ 
#line 231
        if ((unsigned long )text == (unsigned long )((void *)0)) {
          {
#line 233
          text_size = (prefix_size + png_ptr->zbuf_size) - (png_size_t )png_ptr->zstream.avail_out;
#line 235
          tmp___0 = png_malloc_warn(png_ptr, text_size + 1UL);
#line 235
          text = (png_charp )tmp___0;
          }
#line 236
          if ((unsigned long )text == (unsigned long )((void *)0)) {
            {
#line 238
            png_free(png_ptr, (png_voidp )chunkdata);
#line 239
            png_error(png_ptr, "Not enough memory to decompress chunk.");
            }
          }
          {
#line 241
          memcpy((void */* __restrict  */)(text + prefix_size), (void const   */* __restrict  */)png_ptr->zbuf,
                 text_size - prefix_size);
#line 243
          memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)chunkdata,
                 prefix_size);
#line 244
          *(text + text_size) = (char)0;
          }
        } else {
          {
#line 250
          tmp___1 = text;
#line 251
          tmp___2 = png_malloc_warn(png_ptr, ((text_size + png_ptr->zbuf_size) - (png_size_t )png_ptr->zstream.avail_out) + 1UL);
#line 251
          text = (png_charp )tmp___2;
          }
#line 254
          if ((unsigned long )text == (unsigned long )((void *)0)) {
            {
#line 256
            png_free(png_ptr, (png_voidp )tmp___1);
#line 257
            png_free(png_ptr, (png_voidp )chunkdata);
#line 258
            png_error(png_ptr, "Not enough memory to decompress chunk..");
            }
          }
          {
#line 260
          memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)tmp___1,
                 text_size);
#line 261
          png_free(png_ptr, (png_voidp )tmp___1);
#line 262
          memcpy((void */* __restrict  */)(text + text_size), (void const   */* __restrict  */)png_ptr->zbuf,
                 png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out);
#line 264
          text_size += png_ptr->zbuf_size - (png_size_t )png_ptr->zstream.avail_out;
#line 265
          *(text + text_size) = (char)0;
          }
        }
#line 267
        if (ret == 1) {
#line 268
          goto while_break;
        } else {
#line 271
          png_ptr->zstream.next_out = png_ptr->zbuf;
#line 272
          png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 276
    if (ret != 1) {
#line 281
      if (ret == -5) {
        {
#line 282
        sprintf((char */* __restrict  */)(umsg), (char const   */* __restrict  */)"Buffer error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
        }
      } else
#line 284
      if (ret == -3) {
        {
#line 285
        sprintf((char */* __restrict  */)(umsg), (char const   */* __restrict  */)"Data error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
        }
      } else {
        {
#line 288
        sprintf((char */* __restrict  */)(umsg), (char const   */* __restrict  */)"Incomplete compressed datastream in %s chunk",
                png_ptr->chunk_name);
        }
      }
      {
#line 290
      png_warning(png_ptr, (png_const_charp )(umsg));
#line 295
      text_size = prefix_size;
      }
#line 296
      if ((unsigned long )text == (unsigned long )((void *)0)) {
        {
#line 298
        tmp___3 = png_malloc_warn(png_ptr, text_size + 1UL);
#line 298
        text = (png_charp )tmp___3;
        }
#line 299
        if ((unsigned long )text == (unsigned long )((void *)0)) {
          {
#line 301
          png_free(png_ptr, (png_voidp )chunkdata);
#line 302
          png_error(png_ptr, "Not enough memory for text.");
          }
        }
        {
#line 304
        memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)chunkdata,
               prefix_size);
        }
      }
#line 306
      *(text + text_size) = (char)0;
    }
    {
#line 309
    inflateReset(& png_ptr->zstream);
#line 310
    png_ptr->zstream.avail_in = (uInt )0;
#line 312
    png_free(png_ptr, (png_voidp )chunkdata);
#line 313
    chunkdata = text;
#line 314
    *newlength = text_size;
    }
  } else {
    {
#line 321
    sprintf((char */* __restrict  */)(umsg___0), (char const   */* __restrict  */)"Unknown zTXt compression type %d",
            comp_type);
#line 322
    png_warning(png_ptr, (png_const_charp )(umsg___0));
#line 327
    *(chunkdata + prefix_size) = (char)0;
#line 328
    *newlength = prefix_size;
    }
  }
#line 331
  return (chunkdata);
}
}
#line 336 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte buf___1[13] ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int interlace_type ;

  {
#line 346
  if (png_ptr->mode & 1UL) {
    {
#line 347
    png_error(png_ptr, "Out of place IHDR");
    }
  }
#line 350
  if (length != 13UL) {
    {
#line 351
    png_error(png_ptr, "Invalid IHDR chunk");
    }
  }
  {
#line 353
  png_ptr->mode |= 1UL;
#line 355
  png_crc_read(png_ptr, buf___1, (png_size_t )13);
#line 356
  png_crc_finish(png_ptr, (png_uint_32 )0);
#line 358
  width = png_get_uint_31(png_ptr, buf___1);
#line 359
  height = png_get_uint_31(png_ptr, buf___1 + 4);
#line 360
  bit_depth = (int )buf___1[8];
#line 361
  color_type = (int )buf___1[9];
#line 362
  compression_type = (int )buf___1[10];
#line 363
  filter_type = (int )buf___1[11];
#line 364
  interlace_type = (int )buf___1[12];
#line 367
  png_ptr->width = width;
#line 368
  png_ptr->height = height;
#line 369
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 370
  png_ptr->interlaced = (png_byte )interlace_type;
#line 371
  png_ptr->color_type = (png_byte )color_type;
#line 375
  png_ptr->compression_type = (png_byte )compression_type;
  }
  {
#line 381
  if ((int )png_ptr->color_type == 3) {
#line 381
    goto case_3;
  }
#line 381
  if ((int )png_ptr->color_type == 0) {
#line 381
    goto case_3;
  }
#line 384
  if ((int )png_ptr->color_type == 2) {
#line 384
    goto case_2;
  }
#line 387
  if ((int )png_ptr->color_type == 4) {
#line 387
    goto case_4;
  }
#line 390
  if ((int )png_ptr->color_type == 6) {
#line 390
    goto case_6;
  }
#line 378
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 382
  png_ptr->channels = (png_byte )1;
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 385
  png_ptr->channels = (png_byte )3;
#line 386
  goto switch_break;
  case_4: /* CIL Label */ 
#line 388
  png_ptr->channels = (png_byte )2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 391
  png_ptr->channels = (png_byte )4;
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 396
  png_ptr->pixel_depth = (png_byte )((int )png_ptr->bit_depth * (int )png_ptr->channels);
#line 398
  if ((int )png_ptr->pixel_depth >= 8) {
#line 398
    png_ptr->rowbytes = png_ptr->width * ((png_uint_32 )png_ptr->pixel_depth >> 3);
  } else {
#line 398
    png_ptr->rowbytes = (png_ptr->width * (png_uint_32 )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 402
  png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type, interlace_type,
               compression_type, filter_type);
  }
#line 404
  return;
}
}
#line 407 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_PLTE(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_color palette[256] ;
  int num ;
  int i ;
  png_colorp pal_ptr ;
  png_byte buf___1[3] ;

  {
#line 418
  if (! (png_ptr->mode & 1UL)) {
    {
#line 419
    png_error(png_ptr, "Missing IHDR before PLTE");
    }
  } else
#line 420
  if (png_ptr->mode & 4UL) {
    {
#line 422
    png_warning(png_ptr, "Invalid PLTE after IDAT");
#line 423
    png_crc_finish(png_ptr, length);
    }
#line 424
    return;
  } else
#line 426
  if (png_ptr->mode & 2UL) {
    {
#line 427
    png_error(png_ptr, "Duplicate PLTE chunk");
    }
  }
#line 429
  png_ptr->mode |= 2UL;
#line 431
  if (! ((int )png_ptr->color_type & 2)) {
    {
#line 433
    png_warning(png_ptr, "Ignoring PLTE chunk in grayscale PNG");
#line 435
    png_crc_finish(png_ptr, length);
    }
#line 436
    return;
  }
#line 446
  if (length > 768UL) {
#line 446
    goto _L;
  } else
#line 446
  if (length % 3UL) {
    _L: /* CIL Label */ 
#line 448
    if ((int )png_ptr->color_type != 3) {
      {
#line 450
      png_warning(png_ptr, "Invalid palette chunk");
#line 451
      png_crc_finish(png_ptr, length);
      }
#line 452
      return;
    } else {
      {
#line 456
      png_error(png_ptr, "Invalid palette chunk");
      }
    }
  }
#line 460
  num = (int )length / 3;
#line 463
  i = 0;
#line 463
  pal_ptr = palette;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < num)) {
#line 463
      goto while_break;
    }
    {
#line 467
    png_crc_read(png_ptr, buf___1, (png_size_t )3);
#line 468
    pal_ptr->red = buf___1[0];
#line 469
    pal_ptr->green = buf___1[1];
#line 470
    pal_ptr->blue = buf___1[2];
#line 463
    i ++;
#line 463
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  png_crc_finish(png_ptr, (png_uint_32 )0);
#line 522
  png_set_PLTE(png_ptr, info_ptr, palette, num);
  }
#line 525
  if ((int )png_ptr->color_type == 3) {
#line 527
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 527
      if (info_ptr->valid & 16UL) {
#line 529
        if ((int )png_ptr->num_trans > (int )((png_uint_16 )num)) {
          {
#line 531
          png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
#line 532
          png_ptr->num_trans = (png_uint_16 )num;
          }
        }
#line 534
        if ((int )info_ptr->num_trans > (int )((png_uint_16 )num)) {
          {
#line 536
          png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
#line 537
          info_ptr->num_trans = (png_uint_16 )num;
          }
        }
      }
    }
  }
#line 543
  return;
}
}
#line 545 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_IEND(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 


  {
#line 550
  if (! (png_ptr->mode & 1UL)) {
    {
#line 552
    png_error(png_ptr, "No image in file");
    }
  } else
#line 550
  if (! (png_ptr->mode & 4UL)) {
    {
#line 552
    png_error(png_ptr, "No image in file");
    }
  }
#line 555
  png_ptr->mode |= 24UL;
#line 557
  if (length != 0UL) {
    {
#line 559
    png_warning(png_ptr, "Incorrect IEND chunk length");
    }
  }
  {
#line 561
  png_crc_finish(png_ptr, length);
  }
#line 563
  if ((unsigned long )(& info_ptr) == (unsigned long )((void *)0)) {
#line 564
    return;
  }
#line 565
  return;
}
}
#line 568 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_gAMA(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_fixed_point igamma ;
  png_byte buf___1[4] ;
  int tmp ;
  png_uint_32 tmp___0 ;

  {
#line 579
  if (! (png_ptr->mode & 1UL)) {
    {
#line 580
    png_error(png_ptr, "Missing IHDR before gAMA");
    }
  } else
#line 581
  if (png_ptr->mode & 4UL) {
    {
#line 583
    png_warning(png_ptr, "Invalid gAMA after IDAT");
#line 584
    png_crc_finish(png_ptr, length);
    }
#line 585
    return;
  } else
#line 587
  if (png_ptr->mode & 2UL) {
    {
#line 589
    png_warning(png_ptr, "Out of place gAMA chunk");
    }
  }
#line 591
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 591
    if (info_ptr->valid & 1UL) {
#line 591
      if (! (info_ptr->valid & 2048UL)) {
        {
#line 597
        png_warning(png_ptr, "Duplicate gAMA chunk");
#line 598
        png_crc_finish(png_ptr, length);
        }
#line 599
        return;
      }
    }
  }
#line 602
  if (length != 4UL) {
    {
#line 604
    png_warning(png_ptr, "Incorrect gAMA chunk length");
#line 605
    png_crc_finish(png_ptr, length);
    }
#line 606
    return;
  }
  {
#line 609
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 610
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 610
  if (tmp) {
#line 611
    return;
  }
  {
#line 613
  tmp___0 = png_get_uint_32(buf___1);
#line 613
  igamma = (png_fixed_point )tmp___0;
  }
#line 615
  if (igamma == 0L) {
    {
#line 617
    png_warning(png_ptr, "Ignoring gAMA chunk with gamma=0");
    }
#line 619
    return;
  }
#line 623
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 623
    if (info_ptr->valid & 2048UL) {
#line 624
      if (igamma < 45000L) {
        {
#line 626
        png_warning(png_ptr, "Ignoring incorrect gAMA value when sRGB is also present");
#line 629
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gamma = (%d/100000)\n",
                (int )igamma);
        }
#line 631
        return;
      } else
#line 624
      if (igamma > 46000L) {
        {
#line 626
        png_warning(png_ptr, "Ignoring incorrect gAMA value when sRGB is also present");
#line 629
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gamma = (%d/100000)\n",
                (int )igamma);
        }
#line 631
        return;
      }
    }
  }
  {
#line 643
  png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
  }
#line 645
  return;
}
}
#line 649 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_sBIT(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_size_t truelen ;
  png_byte buf___1[4] ;
  int tmp ;

  {
#line 657
  buf___1[3] = (png_byte )0;
#line 657
  buf___1[2] = buf___1[3];
#line 657
  buf___1[1] = buf___1[2];
#line 657
  buf___1[0] = buf___1[1];
#line 659
  if (! (png_ptr->mode & 1UL)) {
    {
#line 660
    png_error(png_ptr, "Missing IHDR before sBIT");
    }
  } else
#line 661
  if (png_ptr->mode & 4UL) {
    {
#line 663
    png_warning(png_ptr, "Invalid sBIT after IDAT");
#line 664
    png_crc_finish(png_ptr, length);
    }
#line 665
    return;
  } else
#line 667
  if (png_ptr->mode & 2UL) {
    {
#line 670
    png_warning(png_ptr, "Out of place sBIT chunk");
    }
  }
#line 672
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 672
    if (info_ptr->valid & 2UL) {
      {
#line 674
      png_warning(png_ptr, "Duplicate sBIT chunk");
#line 675
      png_crc_finish(png_ptr, length);
      }
#line 676
      return;
    }
  }
#line 679
  if ((int )png_ptr->color_type == 3) {
#line 680
    truelen = (png_size_t )3;
  } else {
#line 682
    truelen = (png_size_t )png_ptr->channels;
  }
#line 684
  if (length != truelen) {
    {
#line 686
    png_warning(png_ptr, "Incorrect sBIT chunk length");
#line 687
    png_crc_finish(png_ptr, length);
    }
#line 688
    return;
  } else
#line 684
  if (length > 4UL) {
    {
#line 686
    png_warning(png_ptr, "Incorrect sBIT chunk length");
#line 687
    png_crc_finish(png_ptr, length);
    }
#line 688
    return;
  }
  {
#line 691
  png_crc_read(png_ptr, buf___1, truelen);
#line 692
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 692
  if (tmp) {
#line 693
    return;
  }
#line 695
  if ((int )png_ptr->color_type & 2) {
#line 697
    png_ptr->sig_bit.red = buf___1[0];
#line 698
    png_ptr->sig_bit.green = buf___1[1];
#line 699
    png_ptr->sig_bit.blue = buf___1[2];
#line 700
    png_ptr->sig_bit.alpha = buf___1[3];
  } else {
#line 704
    png_ptr->sig_bit.gray = buf___1[0];
#line 705
    png_ptr->sig_bit.red = buf___1[0];
#line 706
    png_ptr->sig_bit.green = buf___1[0];
#line 707
    png_ptr->sig_bit.blue = buf___1[0];
#line 708
    png_ptr->sig_bit.alpha = buf___1[1];
  }
  {
#line 710
  png_set_sBIT(png_ptr, info_ptr, & png_ptr->sig_bit);
  }
#line 711
  return;
}
}
#line 715 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_cHRM(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte buf___1[4] ;
  png_fixed_point int_x_white ;
  png_fixed_point int_y_white ;
  png_fixed_point int_x_red ;
  png_fixed_point int_y_red ;
  png_fixed_point int_x_green ;
  png_fixed_point int_y_green ;
  png_fixed_point int_x_blue ;
  png_fixed_point int_y_blue ;
  png_uint_32 uint_x ;
  png_uint_32 uint_y ;
  int tmp ;

  {
#line 729
  if (! (png_ptr->mode & 1UL)) {
    {
#line 730
    png_error(png_ptr, "Missing IHDR before cHRM");
    }
  } else
#line 731
  if (png_ptr->mode & 4UL) {
    {
#line 733
    png_warning(png_ptr, "Invalid cHRM after IDAT");
#line 734
    png_crc_finish(png_ptr, length);
    }
#line 735
    return;
  } else
#line 737
  if (png_ptr->mode & 2UL) {
    {
#line 739
    png_warning(png_ptr, "Missing PLTE before cHRM");
    }
  }
#line 741
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 741
    if (info_ptr->valid & 4UL) {
#line 741
      if (! (info_ptr->valid & 2048UL)) {
        {
#line 747
        png_warning(png_ptr, "Duplicate cHRM chunk");
#line 748
        png_crc_finish(png_ptr, length);
        }
#line 749
        return;
      }
    }
  }
#line 752
  if (length != 32UL) {
    {
#line 754
    png_warning(png_ptr, "Incorrect cHRM chunk length");
#line 755
    png_crc_finish(png_ptr, length);
    }
#line 756
    return;
  }
  {
#line 759
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 760
  uint_x = png_get_uint_32(buf___1);
#line 762
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 763
  uint_y = png_get_uint_32(buf___1);
  }
#line 765
  if (uint_x > 80000UL) {
    {
#line 768
    png_warning(png_ptr, "Invalid cHRM white point");
#line 769
    png_crc_finish(png_ptr, (png_uint_32 )24);
    }
#line 770
    return;
  } else
#line 765
  if (uint_y > 80000UL) {
    {
#line 768
    png_warning(png_ptr, "Invalid cHRM white point");
#line 769
    png_crc_finish(png_ptr, (png_uint_32 )24);
    }
#line 770
    return;
  } else
#line 765
  if (uint_x + uint_y > 100000UL) {
    {
#line 768
    png_warning(png_ptr, "Invalid cHRM white point");
#line 769
    png_crc_finish(png_ptr, (png_uint_32 )24);
    }
#line 770
    return;
  }
  {
#line 772
  int_x_white = (png_fixed_point )uint_x;
#line 773
  int_y_white = (png_fixed_point )uint_y;
#line 775
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 776
  uint_x = png_get_uint_32(buf___1);
#line 778
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 779
  uint_y = png_get_uint_32(buf___1);
  }
#line 781
  if (uint_x + uint_y > 100000UL) {
    {
#line 783
    png_warning(png_ptr, "Invalid cHRM red point");
#line 784
    png_crc_finish(png_ptr, (png_uint_32 )16);
    }
#line 785
    return;
  }
  {
#line 787
  int_x_red = (png_fixed_point )uint_x;
#line 788
  int_y_red = (png_fixed_point )uint_y;
#line 790
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 791
  uint_x = png_get_uint_32(buf___1);
#line 793
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 794
  uint_y = png_get_uint_32(buf___1);
  }
#line 796
  if (uint_x + uint_y > 100000UL) {
    {
#line 798
    png_warning(png_ptr, "Invalid cHRM green point");
#line 799
    png_crc_finish(png_ptr, (png_uint_32 )8);
    }
#line 800
    return;
  }
  {
#line 802
  int_x_green = (png_fixed_point )uint_x;
#line 803
  int_y_green = (png_fixed_point )uint_y;
#line 805
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 806
  uint_x = png_get_uint_32(buf___1);
#line 808
  png_crc_read(png_ptr, buf___1, (png_size_t )4);
#line 809
  uint_y = png_get_uint_32(buf___1);
  }
#line 811
  if (uint_x + uint_y > 100000UL) {
    {
#line 813
    png_warning(png_ptr, "Invalid cHRM blue point");
#line 814
    png_crc_finish(png_ptr, (png_uint_32 )0);
    }
#line 815
    return;
  }
#line 817
  int_x_blue = (png_fixed_point )uint_x;
#line 818
  int_y_blue = (png_fixed_point )uint_y;
#line 832
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 832
    if (info_ptr->valid & 2048UL) {
#line 834
      if (int_x_white < 30270L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_white > 32270L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_white < 31900L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_white > 33900L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_red < 63000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_red > 65000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_red < 32000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_red > 34000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_green < 29000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_green > 31000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_green < 59000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_green > 61000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_blue < 14000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_x_blue > 16000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_blue < 5000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      } else
#line 834
      if (int_y_blue > 7000L) {
        {
#line 843
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
                int_x_white, int_y_white, int_x_red, int_y_red);
#line 854
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
                int_x_green, int_y_green, int_x_blue, int_y_blue);
        }
      }
      {
#line 859
      png_crc_finish(png_ptr, (png_uint_32 )0);
      }
#line 860
      return;
    }
  }
  {
#line 869
  png_set_cHRM_fixed(png_ptr, info_ptr, int_x_white, int_y_white, int_x_red, int_y_red,
                     int_x_green, int_y_green, int_x_blue, int_y_blue);
#line 873
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 873
  if (tmp) {
#line 874
    return;
  }
#line 875
  return;
}
}
#line 879 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_sRGB(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  int intent ;
  png_byte buf___1[1] ;
  int tmp ;

  {
#line 887
  if (! (png_ptr->mode & 1UL)) {
    {
#line 888
    png_error(png_ptr, "Missing IHDR before sRGB");
    }
  } else
#line 889
  if (png_ptr->mode & 4UL) {
    {
#line 891
    png_warning(png_ptr, "Invalid sRGB after IDAT");
#line 892
    png_crc_finish(png_ptr, length);
    }
#line 893
    return;
  } else
#line 895
  if (png_ptr->mode & 2UL) {
    {
#line 897
    png_warning(png_ptr, "Out of place sRGB chunk");
    }
  }
#line 899
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 899
    if (info_ptr->valid & 2048UL) {
      {
#line 901
      png_warning(png_ptr, "Duplicate sRGB chunk");
#line 902
      png_crc_finish(png_ptr, length);
      }
#line 903
      return;
    }
  }
#line 906
  if (length != 1UL) {
    {
#line 908
    png_warning(png_ptr, "Incorrect sRGB chunk length");
#line 909
    png_crc_finish(png_ptr, length);
    }
#line 910
    return;
  }
  {
#line 913
  png_crc_read(png_ptr, buf___1, (png_size_t )1);
#line 914
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 914
  if (tmp) {
#line 915
    return;
  }
#line 917
  intent = (int )buf___1[0];
#line 919
  if (intent >= 4) {
    {
#line 921
    png_warning(png_ptr, "Unknown sRGB intent");
    }
#line 922
    return;
  }
#line 955
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 955
    if (info_ptr->valid & 4UL) {
#line 956
      if (info_ptr->int_x_white < 30270L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_white > 32270L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_white < 31900L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_white > 33900L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_red < 63000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_red > 65000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_red < 32000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_red > 34000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_green < 29000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_green > 31000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_green < 59000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_green > 61000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_blue < 14000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_x_blue > 16000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_blue < 5000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      } else
#line 956
      if (info_ptr->int_y_blue > 7000L) {
        {
#line 965
        png_warning(png_ptr, "Ignoring incorrect cHRM value when sRGB is also present");
        }
      }
    }
  }
  {
#line 971
  png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
  }
#line 972
  return;
}
}
#line 976 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_iCCP(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_charp chunkdata ;
  png_byte compression_type ;
  png_bytep pC ;
  png_charp profile ;
  png_uint_32 skip ;
  png_uint_32 profile_size ;
  png_uint_32 profile_length ;
  png_size_t slength ;
  png_size_t prefix_length ;
  png_size_t data_length ;
  png_voidp tmp ;
  int tmp___0 ;
  png_charp tmp___1 ;

  {
#line 984
  skip = (png_uint_32 )0;
#line 990
  if (! (png_ptr->mode & 1UL)) {
    {
#line 991
    png_error(png_ptr, "Missing IHDR before iCCP");
    }
  } else
#line 992
  if (png_ptr->mode & 4UL) {
    {
#line 994
    png_warning(png_ptr, "Invalid iCCP after IDAT");
#line 995
    png_crc_finish(png_ptr, length);
    }
#line 996
    return;
  } else
#line 998
  if (png_ptr->mode & 2UL) {
    {
#line 1000
    png_warning(png_ptr, "Out of place iCCP chunk");
    }
  }
#line 1002
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1002
    if (info_ptr->valid & 4096UL) {
      {
#line 1004
      png_warning(png_ptr, "Duplicate iCCP chunk");
#line 1005
      png_crc_finish(png_ptr, length);
      }
#line 1006
      return;
    }
  }
  {
#line 1018
  tmp = png_malloc(png_ptr, length + 1UL);
#line 1018
  chunkdata = (png_charp )tmp;
#line 1019
  slength = length;
#line 1020
  png_crc_read(png_ptr, (png_bytep )chunkdata, slength);
#line 1022
  tmp___0 = png_crc_finish(png_ptr, skip);
  }
#line 1022
  if (tmp___0) {
    {
#line 1024
    png_free(png_ptr, (png_voidp )chunkdata);
    }
#line 1025
    return;
  }
#line 1028
  *(chunkdata + slength) = (char)0;
#line 1030
  profile = chunkdata;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! *profile) {
#line 1030
      goto while_break;
    }
#line 1030
    profile ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1033
  profile ++;
#line 1037
  if ((unsigned long )profile >= (unsigned long )(chunkdata + slength)) {
    {
#line 1039
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1040
    png_warning(png_ptr, "Malformed iCCP chunk");
    }
#line 1041
    return;
  }
#line 1045
  tmp___1 = profile;
#line 1045
  profile ++;
#line 1045
  compression_type = (png_byte )*tmp___1;
#line 1046
  if (compression_type) {
    {
#line 1048
    png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
#line 1049
    compression_type = (png_byte )0;
    }
  }
  {
#line 1053
  prefix_length = (png_size_t )(profile - chunkdata);
#line 1054
  chunkdata = png_decompress_chunk(png_ptr, (int )compression_type, chunkdata, slength,
                                   prefix_length, & data_length);
#line 1057
  profile_length = data_length - prefix_length;
  }
#line 1059
  if (prefix_length > data_length) {
    {
#line 1061
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1062
    png_warning(png_ptr, "Profile size field missing from iCCP chunk");
    }
#line 1063
    return;
  } else
#line 1059
  if (profile_length < 4UL) {
    {
#line 1061
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1062
    png_warning(png_ptr, "Profile size field missing from iCCP chunk");
    }
#line 1063
    return;
  }
#line 1067
  pC = (png_bytep )(chunkdata + prefix_length);
#line 1068
  profile_size = (png_uint_32 )(((((int )*pC << 24) | ((int )*(pC + 1) << 16)) | ((int )*(pC + 2) << 8)) | (int )*(pC + 3));
#line 1073
  if (profile_size < profile_length) {
#line 1074
    profile_length = profile_size;
  }
#line 1076
  if (profile_size > profile_length) {
    {
#line 1078
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1079
    png_warning(png_ptr, "Ignoring truncated iCCP profile.");
    }
#line 1080
    return;
  }
  {
#line 1083
  png_set_iCCP(png_ptr, info_ptr, chunkdata, (int )compression_type, chunkdata + prefix_length,
               profile_length);
#line 1085
  png_free(png_ptr, (png_voidp )chunkdata);
  }
#line 1086
  return;
}
}
#line 1090 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_sPLT(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_bytep chunkdata ;
  png_bytep entry_start ;
  png_sPLT_t new_palette ;
  int data_length ;
  int entry_size ;
  int i ;
  png_uint_32 skip ;
  png_size_t slength ;
  png_voidp tmp ;
  int tmp___0 ;
  png_bytep tmp___1 ;
  png_voidp tmp___2 ;
  png_sPLT_entryp pp ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;

  {
#line 1101
  skip = (png_uint_32 )0;
#line 1106
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1107
    png_error(png_ptr, "Missing IHDR before sPLT");
    }
  } else
#line 1108
  if (png_ptr->mode & 4UL) {
    {
#line 1110
    png_warning(png_ptr, "Invalid sPLT after IDAT");
#line 1111
    png_crc_finish(png_ptr, length);
    }
#line 1112
    return;
  }
  {
#line 1124
  tmp = png_malloc(png_ptr, length + 1UL);
#line 1124
  chunkdata = (png_bytep )tmp;
#line 1125
  slength = length;
#line 1126
  png_crc_read(png_ptr, chunkdata, slength);
#line 1128
  tmp___0 = png_crc_finish(png_ptr, skip);
  }
#line 1128
  if (tmp___0) {
    {
#line 1130
    png_free(png_ptr, (png_voidp )chunkdata);
    }
#line 1131
    return;
  }
#line 1134
  *(chunkdata + slength) = (png_byte )0;
#line 1136
  entry_start = chunkdata;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! *entry_start) {
#line 1136
      goto while_break;
    }
#line 1136
    entry_start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1138
  entry_start ++;
#line 1141
  if ((unsigned long )entry_start > (unsigned long )(chunkdata + slength)) {
    {
#line 1143
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1144
    png_warning(png_ptr, "malformed sPLT chunk");
    }
#line 1145
    return;
  }
#line 1148
  tmp___1 = entry_start;
#line 1148
  entry_start ++;
#line 1148
  new_palette.depth = *tmp___1;
#line 1149
  if ((int )new_palette.depth == 8) {
#line 1149
    entry_size = 6;
  } else {
#line 1149
    entry_size = 10;
  }
#line 1150
  data_length = (int )(slength - (png_size_t )(entry_start - chunkdata));
#line 1153
  if (data_length % entry_size) {
    {
#line 1155
    png_free(png_ptr, (png_voidp )chunkdata);
#line 1156
    png_warning(png_ptr, "sPLT chunk has bad length");
    }
#line 1157
    return;
  }
#line 1160
  new_palette.nentries = (png_int_32 )(data_length / entry_size);
#line 1161
  if ((png_uint_32 )new_palette.nentries > 0xffffffffffffffffUL / sizeof(png_sPLT_entry )) {
    {
#line 1164
    png_warning(png_ptr, "sPLT chunk too long");
    }
#line 1165
    return;
  }
  {
#line 1167
  tmp___2 = png_malloc_warn(png_ptr, (unsigned long )new_palette.nentries * sizeof(png_sPLT_entry ));
#line 1167
  new_palette.entries = (png_sPLT_entryp )tmp___2;
  }
#line 1169
  if ((unsigned long )new_palette.entries == (unsigned long )((void *)0)) {
    {
#line 1171
    png_warning(png_ptr, "sPLT chunk requires too much memory");
    }
#line 1172
    return;
  }
#line 1176
  i = 0;
  {
#line 1176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1176
    if (! ((png_int_32 )i < new_palette.nentries)) {
#line 1176
      goto while_break___0;
    }
#line 1178
    pp = new_palette.entries + i;
#line 1180
    if ((int )new_palette.depth == 8) {
#line 1182
      tmp___3 = entry_start;
#line 1182
      entry_start ++;
#line 1182
      pp->red = (png_uint_16 )*tmp___3;
#line 1183
      tmp___4 = entry_start;
#line 1183
      entry_start ++;
#line 1183
      pp->green = (png_uint_16 )*tmp___4;
#line 1184
      tmp___5 = entry_start;
#line 1184
      entry_start ++;
#line 1184
      pp->blue = (png_uint_16 )*tmp___5;
#line 1185
      tmp___6 = entry_start;
#line 1185
      entry_start ++;
#line 1185
      pp->alpha = (png_uint_16 )*tmp___6;
    } else {
      {
#line 1189
      pp->red = png_get_uint_16(entry_start);
#line 1189
      entry_start += 2;
#line 1190
      pp->green = png_get_uint_16(entry_start);
#line 1190
      entry_start += 2;
#line 1191
      pp->blue = png_get_uint_16(entry_start);
#line 1191
      entry_start += 2;
#line 1192
      pp->alpha = png_get_uint_16(entry_start);
#line 1192
      entry_start += 2;
      }
    }
    {
#line 1194
    pp->frequency = png_get_uint_16(entry_start);
#line 1194
    entry_start += 2;
#line 1176
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1220
  new_palette.name = (png_charp )chunkdata;
#line 1222
  png_set_sPLT(png_ptr, info_ptr, & new_palette, 1);
#line 1224
  png_free(png_ptr, (png_voidp )chunkdata);
#line 1225
  png_free(png_ptr, (png_voidp )new_palette.entries);
  }
#line 1226
  return;
}
}
#line 1230 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_tRNS(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte readbuf[256] ;
  png_byte buf___1[2] ;
  png_byte buf___2[6] ;
  int tmp ;

  {
#line 1237
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1238
    png_error(png_ptr, "Missing IHDR before tRNS");
    }
  } else
#line 1239
  if (png_ptr->mode & 4UL) {
    {
#line 1241
    png_warning(png_ptr, "Invalid tRNS after IDAT");
#line 1242
    png_crc_finish(png_ptr, length);
    }
#line 1243
    return;
  } else
#line 1245
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1245
    if (info_ptr->valid & 16UL) {
      {
#line 1247
      png_warning(png_ptr, "Duplicate tRNS chunk");
#line 1248
      png_crc_finish(png_ptr, length);
      }
#line 1249
      return;
    }
  }
#line 1252
  if ((int )png_ptr->color_type == 0) {
#line 1256
    if (length != 2UL) {
      {
#line 1258
      png_warning(png_ptr, "Incorrect tRNS chunk length");
#line 1259
      png_crc_finish(png_ptr, length);
      }
#line 1260
      return;
    }
    {
#line 1263
    png_crc_read(png_ptr, buf___1, (png_size_t )2);
#line 1264
    png_ptr->num_trans = (png_uint_16 )1;
#line 1265
    png_ptr->trans_values.gray = png_get_uint_16(buf___1);
    }
  } else
#line 1267
  if ((int )png_ptr->color_type == 2) {
#line 1271
    if (length != 6UL) {
      {
#line 1273
      png_warning(png_ptr, "Incorrect tRNS chunk length");
#line 1274
      png_crc_finish(png_ptr, length);
      }
#line 1275
      return;
    }
    {
#line 1277
    png_crc_read(png_ptr, buf___2, length);
#line 1278
    png_ptr->num_trans = (png_uint_16 )1;
#line 1279
    png_ptr->trans_values.red = png_get_uint_16(buf___2);
#line 1280
    png_ptr->trans_values.green = png_get_uint_16(buf___2 + 2);
#line 1281
    png_ptr->trans_values.blue = png_get_uint_16(buf___2 + 4);
    }
  } else
#line 1283
  if ((int )png_ptr->color_type == 3) {
#line 1285
    if (! (png_ptr->mode & 2UL)) {
      {
#line 1288
      png_warning(png_ptr, "Missing PLTE before tRNS");
      }
    }
#line 1290
    if (length > (png_uint_32 )png_ptr->num_palette) {
      {
#line 1293
      png_warning(png_ptr, "Incorrect tRNS chunk length");
#line 1294
      png_crc_finish(png_ptr, length);
      }
#line 1295
      return;
    } else
#line 1290
    if (length > 256UL) {
      {
#line 1293
      png_warning(png_ptr, "Incorrect tRNS chunk length");
#line 1294
      png_crc_finish(png_ptr, length);
      }
#line 1295
      return;
    }
#line 1297
    if (length == 0UL) {
      {
#line 1299
      png_warning(png_ptr, "Zero length tRNS chunk");
#line 1300
      png_crc_finish(png_ptr, length);
      }
#line 1301
      return;
    }
    {
#line 1303
    png_crc_read(png_ptr, readbuf, length);
#line 1304
    png_ptr->num_trans = (png_uint_16 )length;
    }
  } else {
    {
#line 1308
    png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
#line 1309
    png_crc_finish(png_ptr, length);
    }
#line 1310
    return;
  }
  {
#line 1313
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1313
  if (tmp) {
#line 1314
    return;
  }
  {
#line 1316
  png_set_tRNS(png_ptr, info_ptr, readbuf, (int )png_ptr->num_trans, & png_ptr->trans_values);
  }
#line 1318
  return;
}
}
#line 1322 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_bKGD(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_size_t truelen ;
  png_byte buf___1[6] ;
  int tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1330
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1331
    png_error(png_ptr, "Missing IHDR before bKGD");
    }
  } else
#line 1332
  if (png_ptr->mode & 4UL) {
    {
#line 1334
    png_warning(png_ptr, "Invalid bKGD after IDAT");
#line 1335
    png_crc_finish(png_ptr, length);
    }
#line 1336
    return;
  } else
#line 1338
  if ((int )png_ptr->color_type == 3) {
#line 1338
    if (! (png_ptr->mode & 2UL)) {
      {
#line 1341
      png_warning(png_ptr, "Missing PLTE before bKGD");
#line 1342
      png_crc_finish(png_ptr, length);
      }
#line 1343
      return;
    } else {
#line 1338
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1345
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1345
    if (info_ptr->valid & 32UL) {
      {
#line 1347
      png_warning(png_ptr, "Duplicate bKGD chunk");
#line 1348
      png_crc_finish(png_ptr, length);
      }
#line 1349
      return;
    }
  }
#line 1352
  if ((int )png_ptr->color_type == 3) {
#line 1353
    truelen = (png_size_t )1;
  } else
#line 1354
  if ((int )png_ptr->color_type & 2) {
#line 1355
    truelen = (png_size_t )6;
  } else {
#line 1357
    truelen = (png_size_t )2;
  }
#line 1359
  if (length != truelen) {
    {
#line 1361
    png_warning(png_ptr, "Incorrect bKGD chunk length");
#line 1362
    png_crc_finish(png_ptr, length);
    }
#line 1363
    return;
  }
  {
#line 1366
  png_crc_read(png_ptr, buf___1, truelen);
#line 1367
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1367
  if (tmp) {
#line 1368
    return;
  }
#line 1374
  if ((int )png_ptr->color_type == 3) {
#line 1376
    png_ptr->background.index = buf___1[0];
#line 1377
    if (info_ptr->num_palette) {
#line 1379
      if ((int )buf___1[0] > (int )info_ptr->num_palette) {
        {
#line 1381
        png_warning(png_ptr, "Incorrect bKGD chunk index value");
        }
#line 1382
        return;
      }
#line 1384
      png_ptr->background.red = (png_uint_16 )(png_ptr->palette + buf___1[0])->red;
#line 1386
      png_ptr->background.green = (png_uint_16 )(png_ptr->palette + buf___1[0])->green;
#line 1388
      png_ptr->background.blue = (png_uint_16 )(png_ptr->palette + buf___1[0])->blue;
    }
  } else
#line 1392
  if (! ((int )png_ptr->color_type & 2)) {
    {
#line 1394
    tmp___2 = png_get_uint_16(buf___1);
#line 1394
    png_ptr->background.gray = tmp___2;
#line 1394
    tmp___1 = tmp___2;
#line 1394
    png_ptr->background.blue = tmp___1;
#line 1394
    tmp___0 = tmp___1;
#line 1394
    png_ptr->background.green = tmp___0;
#line 1394
    png_ptr->background.red = tmp___0;
    }
  } else {
    {
#line 1401
    png_ptr->background.red = png_get_uint_16(buf___1);
#line 1402
    png_ptr->background.green = png_get_uint_16(buf___1 + 2);
#line 1403
    png_ptr->background.blue = png_get_uint_16(buf___1 + 4);
    }
  }
  {
#line 1406
  png_set_bKGD(png_ptr, info_ptr, & png_ptr->background);
  }
#line 1407
  return;
}
}
#line 1411 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  unsigned int num ;
  unsigned int i ;
  png_uint_16 readbuf[256] ;
  png_byte buf___1[2] ;
  int tmp ;

  {
#line 1419
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1420
    png_error(png_ptr, "Missing IHDR before hIST");
    }
  } else
#line 1421
  if (png_ptr->mode & 4UL) {
    {
#line 1423
    png_warning(png_ptr, "Invalid hIST after IDAT");
#line 1424
    png_crc_finish(png_ptr, length);
    }
#line 1425
    return;
  } else
#line 1427
  if (! (png_ptr->mode & 2UL)) {
    {
#line 1429
    png_warning(png_ptr, "Missing PLTE before hIST");
#line 1430
    png_crc_finish(png_ptr, length);
    }
#line 1431
    return;
  } else
#line 1433
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1433
    if (info_ptr->valid & 64UL) {
      {
#line 1435
      png_warning(png_ptr, "Duplicate hIST chunk");
#line 1436
      png_crc_finish(png_ptr, length);
      }
#line 1437
      return;
    }
  }
#line 1440
  num = (unsigned int )(length / 2UL);
#line 1441
  if (num != (unsigned int )png_ptr->num_palette) {
    {
#line 1444
    png_warning(png_ptr, "Incorrect hIST chunk length");
#line 1445
    png_crc_finish(png_ptr, length);
    }
#line 1446
    return;
  } else
#line 1441
  if (num > 256U) {
    {
#line 1444
    png_warning(png_ptr, "Incorrect hIST chunk length");
#line 1445
    png_crc_finish(png_ptr, length);
    }
#line 1446
    return;
  }
#line 1449
  i = 0U;
  {
#line 1449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1449
    if (! (i < num)) {
#line 1449
      goto while_break;
    }
    {
#line 1453
    png_crc_read(png_ptr, buf___1, (png_size_t )2);
#line 1454
    readbuf[i] = png_get_uint_16(buf___1);
#line 1449
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1457
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1457
  if (tmp) {
#line 1458
    return;
  }
  {
#line 1460
  png_set_hIST(png_ptr, info_ptr, readbuf);
  }
#line 1461
  return;
}
}
#line 1465 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte buf___1[9] ;
  png_uint_32 res_x ;
  png_uint_32 res_y ;
  int unit_type ;
  int tmp ;

  {
#line 1474
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1475
    png_error(png_ptr, "Missing IHDR before pHYs");
    }
  } else
#line 1476
  if (png_ptr->mode & 4UL) {
    {
#line 1478
    png_warning(png_ptr, "Invalid pHYs after IDAT");
#line 1479
    png_crc_finish(png_ptr, length);
    }
#line 1480
    return;
  } else
#line 1482
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1482
    if (info_ptr->valid & 128UL) {
      {
#line 1484
      png_warning(png_ptr, "Duplicate pHYs chunk");
#line 1485
      png_crc_finish(png_ptr, length);
      }
#line 1486
      return;
    }
  }
#line 1489
  if (length != 9UL) {
    {
#line 1491
    png_warning(png_ptr, "Incorrect pHYs chunk length");
#line 1492
    png_crc_finish(png_ptr, length);
    }
#line 1493
    return;
  }
  {
#line 1496
  png_crc_read(png_ptr, buf___1, (png_size_t )9);
#line 1497
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1497
  if (tmp) {
#line 1498
    return;
  }
  {
#line 1500
  res_x = png_get_uint_32(buf___1);
#line 1501
  res_y = png_get_uint_32(buf___1 + 4);
#line 1502
  unit_type = (int )buf___1[8];
#line 1503
  png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
  }
#line 1504
  return;
}
}
#line 1508 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_oFFs(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte buf___1[9] ;
  png_int_32 offset_x ;
  png_int_32 offset_y ;
  int unit_type ;
  int tmp ;

  {
#line 1517
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1518
    png_error(png_ptr, "Missing IHDR before oFFs");
    }
  } else
#line 1519
  if (png_ptr->mode & 4UL) {
    {
#line 1521
    png_warning(png_ptr, "Invalid oFFs after IDAT");
#line 1522
    png_crc_finish(png_ptr, length);
    }
#line 1523
    return;
  } else
#line 1525
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1525
    if (info_ptr->valid & 256UL) {
      {
#line 1527
      png_warning(png_ptr, "Duplicate oFFs chunk");
#line 1528
      png_crc_finish(png_ptr, length);
      }
#line 1529
      return;
    }
  }
#line 1532
  if (length != 9UL) {
    {
#line 1534
    png_warning(png_ptr, "Incorrect oFFs chunk length");
#line 1535
    png_crc_finish(png_ptr, length);
    }
#line 1536
    return;
  }
  {
#line 1539
  png_crc_read(png_ptr, buf___1, (png_size_t )9);
#line 1540
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1540
  if (tmp) {
#line 1541
    return;
  }
  {
#line 1543
  offset_x = png_get_int_32(buf___1);
#line 1544
  offset_y = png_get_int_32(buf___1 + 4);
#line 1545
  unit_type = (int )buf___1[8];
#line 1546
  png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
  }
#line 1547
  return;
}
}
#line 1552 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_pCAL(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_charp purpose ;
  png_int_32 X0 ;
  png_int_32 X1 ;
  png_byte type ;
  png_byte nparams ;
  png_charp buf___1 ;
  png_charp units ;
  png_charp endptr ;
  png_charpp params ;
  png_size_t slength ;
  int i ;
  png_voidp tmp ;
  int tmp___0 ;
  png_voidp tmp___1 ;

  {
#line 1565
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1566
    png_error(png_ptr, "Missing IHDR before pCAL");
    }
  } else
#line 1567
  if (png_ptr->mode & 4UL) {
    {
#line 1569
    png_warning(png_ptr, "Invalid pCAL after IDAT");
#line 1570
    png_crc_finish(png_ptr, length);
    }
#line 1571
    return;
  } else
#line 1573
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1573
    if (info_ptr->valid & 1024UL) {
      {
#line 1575
      png_warning(png_ptr, "Duplicate pCAL chunk");
#line 1576
      png_crc_finish(png_ptr, length);
      }
#line 1577
      return;
    }
  }
  {
#line 1582
  tmp = png_malloc_warn(png_ptr, length + 1UL);
#line 1582
  purpose = (png_charp )tmp;
  }
#line 1583
  if ((unsigned long )purpose == (unsigned long )((void *)0)) {
    {
#line 1585
    png_warning(png_ptr, "No memory for pCAL purpose.");
    }
#line 1586
    return;
  }
  {
#line 1588
  slength = length;
#line 1589
  png_crc_read(png_ptr, (png_bytep )purpose, slength);
#line 1591
  tmp___0 = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1591
  if (tmp___0) {
    {
#line 1593
    png_free(png_ptr, (png_voidp )purpose);
    }
#line 1594
    return;
  }
#line 1597
  *(purpose + slength) = (char)0;
#line 1600
  buf___1 = purpose;
  {
#line 1600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1600
    if (! *buf___1) {
#line 1600
      goto while_break;
    }
#line 1600
    buf___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1603
  endptr = purpose + slength;
#line 1607
  if ((unsigned long )endptr <= (unsigned long )(buf___1 + 12)) {
    {
#line 1609
    png_warning(png_ptr, "Invalid pCAL data");
#line 1610
    png_free(png_ptr, (png_voidp )purpose);
    }
#line 1611
    return;
  }
  {
#line 1615
  X0 = png_get_int_32((png_bytep )buf___1 + 1);
#line 1616
  X1 = png_get_int_32((png_bytep )buf___1 + 5);
#line 1617
  type = (png_byte )*(buf___1 + 9);
#line 1618
  nparams = (png_byte )*(buf___1 + 10);
#line 1619
  units = buf___1 + 11;
  }
#line 1624
  if ((int )type == 0) {
#line 1624
    if ((int )nparams != 2) {
      {
#line 1629
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
#line 1630
      png_free(png_ptr, (png_voidp )purpose);
      }
#line 1631
      return;
    } else {
#line 1624
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1624
  if ((int )type == 1) {
#line 1624
    if ((int )nparams != 3) {
      {
#line 1629
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
#line 1630
      png_free(png_ptr, (png_voidp )purpose);
      }
#line 1631
      return;
    } else {
#line 1624
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1624
  if ((int )type == 2) {
#line 1624
    if ((int )nparams != 3) {
      {
#line 1629
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
#line 1630
      png_free(png_ptr, (png_voidp )purpose);
      }
#line 1631
      return;
    } else {
#line 1624
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1624
  if ((int )type == 3) {
#line 1624
    if ((int )nparams != 4) {
      {
#line 1629
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
#line 1630
      png_free(png_ptr, (png_voidp )purpose);
      }
#line 1631
      return;
    } else {
#line 1624
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1633
  if ((int )type >= 4) {
    {
#line 1635
    png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
    }
  }
#line 1638
  buf___1 = units;
  {
#line 1638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1638
    if (! *buf___1) {
#line 1638
      goto while_break___0;
    }
#line 1638
    buf___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1642
  tmp___1 = png_malloc_warn(png_ptr, (unsigned long )nparams * sizeof(png_charp ));
#line 1642
  params = (png_charpp )tmp___1;
  }
#line 1644
  if ((unsigned long )params == (unsigned long )((void *)0)) {
    {
#line 1646
    png_free(png_ptr, (png_voidp )purpose);
#line 1647
    png_warning(png_ptr, "No memory for pCAL params.");
    }
#line 1648
    return;
  }
#line 1652
  i = 0;
  {
#line 1652
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1652
    if (! (i < (int )nparams)) {
#line 1652
      goto while_break___1;
    }
#line 1654
    buf___1 ++;
#line 1657
    *(params + i) = buf___1;
    {
#line 1657
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1657
      if ((int )*buf___1 != 0) {
#line 1657
        if (! ((unsigned long )buf___1 <= (unsigned long )endptr)) {
#line 1657
          goto while_break___2;
        }
      } else {
#line 1657
        goto while_break___2;
      }
#line 1657
      buf___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1661
    if ((unsigned long )buf___1 > (unsigned long )endptr) {
      {
#line 1663
      png_warning(png_ptr, "Invalid pCAL data");
#line 1664
      png_free(png_ptr, (png_voidp )purpose);
#line 1665
      png_free(png_ptr, (png_voidp )params);
      }
#line 1666
      return;
    }
#line 1652
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1670
  png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, (int )type, (int )nparams, units,
               params);
#line 1673
  png_free(png_ptr, (png_voidp )purpose);
#line 1674
  png_free(png_ptr, (png_voidp )params);
  }
#line 1675
  return;
}
}
#line 1680 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_sCAL(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_charp buffer ;
  png_charp ep ;
  png_charp swidth ;
  png_charp sheight ;
  png_size_t slength ;
  png_voidp tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  png_voidp tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  png_voidp tmp___5 ;
  size_t tmp___6 ;

  {
#line 1696
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1697
    png_error(png_ptr, "Missing IHDR before sCAL");
    }
  } else
#line 1698
  if (png_ptr->mode & 4UL) {
    {
#line 1700
    png_warning(png_ptr, "Invalid sCAL after IDAT");
#line 1701
    png_crc_finish(png_ptr, length);
    }
#line 1702
    return;
  } else
#line 1704
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1704
    if (info_ptr->valid & 16384UL) {
      {
#line 1706
      png_warning(png_ptr, "Duplicate sCAL chunk");
#line 1707
      png_crc_finish(png_ptr, length);
      }
#line 1708
      return;
    }
  }
  {
#line 1713
  tmp = png_malloc_warn(png_ptr, length + 1UL);
#line 1713
  buffer = (png_charp )tmp;
  }
#line 1714
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1716
    png_warning(png_ptr, "Out of memory while processing sCAL chunk");
    }
#line 1717
    return;
  }
  {
#line 1719
  slength = length;
#line 1720
  png_crc_read(png_ptr, (png_bytep )buffer, slength);
#line 1722
  tmp___0 = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1722
  if (tmp___0) {
    {
#line 1724
    png_free(png_ptr, (png_voidp )buffer);
    }
#line 1725
    return;
  }
  {
#line 1728
  *(buffer + slength) = (char)0;
#line 1730
  ep = buffer + 1;
#line 1741
  tmp___1 = strlen((char const   *)ep);
#line 1741
  tmp___2 = png_malloc_warn(png_ptr, tmp___1 + 1UL);
#line 1741
  swidth = (png_charp )tmp___2;
  }
#line 1742
  if ((unsigned long )swidth == (unsigned long )((void *)0)) {
    {
#line 1744
    png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
    }
#line 1745
    return;
  }
  {
#line 1747
  tmp___3 = strlen((char const   *)ep);
#line 1747
  memcpy((void */* __restrict  */)swidth, (void const   */* __restrict  */)ep, tmp___3);
#line 1751
  ep = buffer;
  }
  {
#line 1751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1751
    if (! *ep) {
#line 1751
      goto while_break;
    }
#line 1751
    ep ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1753
  ep ++;
#line 1764
  tmp___4 = strlen((char const   *)ep);
#line 1764
  tmp___5 = png_malloc_warn(png_ptr, tmp___4 + 1UL);
#line 1764
  sheight = (png_charp )tmp___5;
  }
#line 1765
  if ((unsigned long )swidth == (unsigned long )((void *)0)) {
    {
#line 1767
    png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
    }
#line 1768
    return;
  }
  {
#line 1770
  tmp___6 = strlen((char const   *)ep);
#line 1770
  memcpy((void */* __restrict  */)sheight, (void const   */* __restrict  */)ep, tmp___6);
  }
#line 1774
  if ((unsigned long )(buffer + slength) < (unsigned long )ep) {
    {
#line 1780
    png_warning(png_ptr, "Invalid sCAL data");
#line 1781
    png_free(png_ptr, (png_voidp )buffer);
#line 1783
    png_free(png_ptr, (png_voidp )swidth);
#line 1784
    png_free(png_ptr, (png_voidp )sheight);
    }
#line 1786
    return;
  }
  {
#line 1794
  png_set_sCAL_s(png_ptr, info_ptr, (int )*(buffer + 0), swidth, sheight);
#line 1798
  png_free(png_ptr, (png_voidp )buffer);
#line 1800
  png_free(png_ptr, (png_voidp )swidth);
#line 1801
  png_free(png_ptr, (png_voidp )sheight);
  }
#line 1803
  return;
}
}
#line 1807 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_tIME(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_byte buf___1[7] ;
  png_time mod_time ;
  int tmp ;

  {
#line 1815
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1816
    png_error(png_ptr, "Out of place tIME chunk");
    }
  } else
#line 1817
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1817
    if (info_ptr->valid & 512UL) {
      {
#line 1819
      png_warning(png_ptr, "Duplicate tIME chunk");
#line 1820
      png_crc_finish(png_ptr, length);
      }
#line 1821
      return;
    }
  }
#line 1824
  if (png_ptr->mode & 4UL) {
#line 1825
    png_ptr->mode |= 8UL;
  }
#line 1827
  if (length != 7UL) {
    {
#line 1829
    png_warning(png_ptr, "Incorrect tIME chunk length");
#line 1830
    png_crc_finish(png_ptr, length);
    }
#line 1831
    return;
  }
  {
#line 1834
  png_crc_read(png_ptr, buf___1, (png_size_t )7);
#line 1835
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1835
  if (tmp) {
#line 1836
    return;
  }
  {
#line 1838
  mod_time.second = buf___1[6];
#line 1839
  mod_time.minute = buf___1[5];
#line 1840
  mod_time.hour = buf___1[4];
#line 1841
  mod_time.day = buf___1[3];
#line 1842
  mod_time.month = buf___1[2];
#line 1843
  mod_time.year = png_get_uint_16(buf___1);
#line 1845
  png_set_tIME(png_ptr, info_ptr, & mod_time);
  }
#line 1846
  return;
}
}
#line 1851 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_tEXt(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_textp text_ptr ;
  png_charp key ;
  png_charp text ;
  png_uint_32 skip ;
  png_size_t slength ;
  int ret ;
  png_voidp tmp ;
  int tmp___0 ;
  png_voidp tmp___1 ;

  {
#line 1857
  skip = (png_uint_32 )0;
#line 1863
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1864
    png_error(png_ptr, "Missing IHDR before tEXt");
    }
  }
#line 1866
  if (png_ptr->mode & 4UL) {
#line 1867
    png_ptr->mode |= 8UL;
  }
  {
#line 1878
  tmp = png_malloc_warn(png_ptr, length + 1UL);
#line 1878
  key = (png_charp )tmp;
  }
#line 1879
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 1881
    png_warning(png_ptr, "No memory to process text chunk.");
    }
#line 1882
    return;
  }
  {
#line 1884
  slength = length;
#line 1885
  png_crc_read(png_ptr, (png_bytep )key, slength);
#line 1887
  tmp___0 = png_crc_finish(png_ptr, skip);
  }
#line 1887
  if (tmp___0) {
    {
#line 1889
    png_free(png_ptr, (png_voidp )key);
    }
#line 1890
    return;
  }
#line 1893
  *(key + slength) = (char)0;
#line 1895
  text = key;
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! *text) {
#line 1895
      goto while_break;
    }
#line 1895
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1898
  if ((unsigned long )text != (unsigned long )(key + slength)) {
#line 1899
    text ++;
  }
  {
#line 1901
  tmp___1 = png_malloc_warn(png_ptr, sizeof(png_text ));
#line 1901
  text_ptr = (png_textp )tmp___1;
  }
#line 1903
  if ((unsigned long )text_ptr == (unsigned long )((void *)0)) {
    {
#line 1905
    png_warning(png_ptr, "Not enough memory to process text chunk.");
#line 1906
    png_free(png_ptr, (png_voidp )key);
    }
#line 1907
    return;
  }
  {
#line 1909
  text_ptr->compression = -1;
#line 1910
  text_ptr->key = key;
#line 1916
  text_ptr->text = text;
#line 1917
  text_ptr->text_length = strlen((char const   *)text);
#line 1919
  ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
#line 1921
  png_free(png_ptr, (png_voidp )key);
#line 1922
  png_free(png_ptr, (png_voidp )text_ptr);
  }
#line 1923
  if (ret) {
    {
#line 1924
    png_warning(png_ptr, "Insufficient memory to process text chunk.");
    }
  }
#line 1925
  return;
}
}
#line 1930 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_zTXt(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_textp text_ptr ;
  png_charp chunkdata ;
  png_charp text ;
  int comp_type ;
  int ret ;
  png_size_t slength ;
  png_size_t prefix_len ;
  png_size_t data_len ;
  png_voidp tmp ;
  int tmp___0 ;
  png_charp tmp___1 ;
  png_voidp tmp___2 ;

  {
#line 1941
  if (! (png_ptr->mode & 1UL)) {
    {
#line 1942
    png_error(png_ptr, "Missing IHDR before zTXt");
    }
  }
#line 1944
  if (png_ptr->mode & 4UL) {
#line 1945
    png_ptr->mode |= 8UL;
  }
  {
#line 1958
  tmp = png_malloc_warn(png_ptr, length + 1UL);
#line 1958
  chunkdata = (png_charp )tmp;
  }
#line 1959
  if ((unsigned long )chunkdata == (unsigned long )((void *)0)) {
    {
#line 1961
    png_warning(png_ptr, "Out of memory processing zTXt chunk.");
    }
#line 1962
    return;
  }
  {
#line 1964
  slength = length;
#line 1965
  png_crc_read(png_ptr, (png_bytep )chunkdata, slength);
#line 1966
  tmp___0 = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1966
  if (tmp___0) {
    {
#line 1968
    png_free(png_ptr, (png_voidp )chunkdata);
    }
#line 1969
    return;
  }
#line 1972
  *(chunkdata + slength) = (char)0;
#line 1974
  text = chunkdata;
  {
#line 1974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1974
    if (! *text) {
#line 1974
      goto while_break;
    }
#line 1974
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1978
  if ((unsigned long )text == (unsigned long )(chunkdata + slength)) {
    {
#line 1980
    comp_type = -1;
#line 1981
    png_warning(png_ptr, "Zero length zTXt chunk");
    }
  } else {
#line 1985
    text ++;
#line 1985
    comp_type = (int )*text;
#line 1986
    if (comp_type != 0) {
      {
#line 1988
      png_warning(png_ptr, "Unknown compression type in zTXt chunk");
#line 1989
      comp_type = 0;
      }
    }
#line 1991
    text ++;
  }
  {
#line 1993
  prefix_len = (png_size_t )(text - chunkdata);
#line 1995
  tmp___1 = png_decompress_chunk(png_ptr, comp_type, chunkdata, length, prefix_len,
                                 & data_len);
#line 1995
  chunkdata = tmp___1;
#line 1998
  tmp___2 = png_malloc_warn(png_ptr, sizeof(png_text ));
#line 1998
  text_ptr = (png_textp )tmp___2;
  }
#line 2000
  if ((unsigned long )text_ptr == (unsigned long )((void *)0)) {
    {
#line 2002
    png_warning(png_ptr, "Not enough memory to process zTXt chunk.");
#line 2003
    png_free(png_ptr, (png_voidp )chunkdata);
    }
#line 2004
    return;
  }
  {
#line 2006
  text_ptr->compression = comp_type;
#line 2007
  text_ptr->key = chunkdata;
#line 2013
  text_ptr->text = chunkdata + prefix_len;
#line 2014
  text_ptr->text_length = data_len;
#line 2016
  ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
#line 2018
  png_free(png_ptr, (png_voidp )text_ptr);
#line 2019
  png_free(png_ptr, (png_voidp )chunkdata);
  }
#line 2020
  if (ret) {
    {
#line 2021
    png_error(png_ptr, "Insufficient memory to store zTXt chunk.");
    }
  }
#line 2022
  return;
}
}
#line 2138 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_handle_unknown(png_structp png_ptr , png_infop info_ptr , png_uint_32 length ) 
{ 
  png_uint_32 skip ;
  int tmp ;
  int tmp___0 ;
  png_unknown_chunk chunk ;
  png_voidp tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2141
  skip = (png_uint_32 )0;
#line 2145
  if (png_ptr->mode & 4UL) {
    {
#line 2150
    tmp = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                 (size_t )4);
    }
#line 2150
    if (tmp) {
#line 2151
      png_ptr->mode |= 8UL;
    }
  }
  {
#line 2154
  png_check_chunk_name(png_ptr, png_ptr->chunk_name);
  }
#line 2156
  if (! ((int )png_ptr->chunk_name[0] & 32)) {
    {
#line 2159
    tmp___0 = png_handle_as_unknown(png_ptr, png_ptr->chunk_name);
    }
#line 2159
    if (tmp___0 != 3) {
#line 2159
      if ((unsigned long )png_ptr->read_user_chunk_fn == (unsigned long )((void *)0)) {
        {
#line 2166
        png_chunk_error(png_ptr, "unknown critical chunk");
        }
      }
    }
  }
#line 2170
  if (png_ptr->flags & 32768UL) {
#line 2170
    goto _L;
  } else
#line 2170
  if ((unsigned long )png_ptr->read_user_chunk_fn != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 2183
    strcpy((char */* __restrict  */)((png_charp )(chunk.name)), (char const   */* __restrict  */)((png_charp )(png_ptr->chunk_name)));
#line 2184
    tmp___1 = png_malloc(png_ptr, length);
#line 2184
    chunk.data = (png_bytep )tmp___1;
#line 2185
    chunk.size = length;
#line 2186
    png_crc_read(png_ptr, chunk.data, length);
    }
#line 2188
    if ((unsigned long )png_ptr->read_user_chunk_fn != (unsigned long )((void *)0)) {
      {
#line 2191
      tmp___3 = (*(png_ptr->read_user_chunk_fn))(png_ptr, & chunk);
      }
#line 2191
      if (tmp___3 <= 0) {
#line 2193
        if (! ((int )png_ptr->chunk_name[0] & 32)) {
          {
#line 2194
          tmp___2 = png_handle_as_unknown(png_ptr, png_ptr->chunk_name);
          }
#line 2194
          if (tmp___2 != 3) {
            {
#line 2197
            png_free(png_ptr, (png_voidp )chunk.data);
#line 2198
            png_chunk_error(png_ptr, "unknown critical chunk");
            }
          }
        }
        {
#line 2200
        png_set_unknown_chunks(png_ptr, info_ptr, & chunk, 1);
        }
      }
    } else {
      {
#line 2205
      png_set_unknown_chunks(png_ptr, info_ptr, & chunk, 1);
      }
    }
    {
#line 2206
    png_free(png_ptr, (png_voidp )chunk.data);
    }
  } else {
#line 2210
    skip = length;
  }
  {
#line 2212
  png_crc_finish(png_ptr, skip);
  }
#line 2218
  return;
}
}
#line 2228 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_check_chunk_name(png_structp png_ptr , png_bytep chunk_name ) 
{ 


  {
#line 2232
  if ((int )*(chunk_name + 0) < 65) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 0) > 122) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 0) > 90) {
#line 2232
    if ((int )*(chunk_name + 0) < 97) {
      {
#line 2235
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    } else {
#line 2232
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2232
  if ((int )*(chunk_name + 1) < 65) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 1) > 122) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 1) > 90) {
#line 2232
    if ((int )*(chunk_name + 1) < 97) {
      {
#line 2235
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    } else {
#line 2232
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2232
  if ((int )*(chunk_name + 2) < 65) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 2) > 122) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 2) > 90) {
#line 2232
    if ((int )*(chunk_name + 2) < 97) {
      {
#line 2235
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    } else {
#line 2232
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2232
  if ((int )*(chunk_name + 3) < 65) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 3) > 122) {
    {
#line 2235
    png_chunk_error(png_ptr, "invalid chunk type");
    }
  } else
#line 2232
  if ((int )*(chunk_name + 3) > 90) {
#line 2232
    if ((int )*(chunk_name + 3) < 97) {
      {
#line 2235
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    }
  }
#line 2237
  return;
}
}
#line 2250 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_combine_row(png_structp png_ptr , png_bytep row , int mask ) 
{ 
  png_uint_32 tmp ;
  png_bytep sp___0 ;
  png_bytep dp ;
  int s_inc ;
  int s_start ;
  int s_end ;
  int m ;
  int shift ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  int value ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  int s_start___0 ;
  int s_end___0 ;
  int s_inc___0 ;
  int m___0 ;
  int shift___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  int value___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  int s_start___1 ;
  int s_end___1 ;
  int s_inc___1 ;
  int m___1 ;
  int shift___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  int value___1 ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  png_size_t pixel_bytes ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_byte m___2 ;

  {
#line 2254
  if (mask == 255) {
#line 2256
    if ((int )png_ptr->row_info.pixel_depth >= 8) {
#line 2256
      tmp = png_ptr->width * ((png_uint_32 )png_ptr->row_info.pixel_depth >> 3);
    } else {
#line 2256
      tmp = (png_ptr->width * (png_uint_32 )png_ptr->row_info.pixel_depth + 7UL) >> 3;
    }
    {
#line 2256
    memcpy((void */* __restrict  */)row, (void const   */* __restrict  */)(png_ptr->row_buf + 1),
           tmp);
    }
  } else {
    {
#line 2263
    if ((int )png_ptr->row_info.pixel_depth == 1) {
#line 2263
      goto case_1;
    }
#line 2317
    if ((int )png_ptr->row_info.pixel_depth == 2) {
#line 2317
      goto case_2;
    }
#line 2369
    if ((int )png_ptr->row_info.pixel_depth == 4) {
#line 2369
      goto case_4;
    }
#line 2420
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2265
    sp___0 = png_ptr->row_buf + 1;
#line 2266
    dp = row;
#line 2268
    m = 128;
#line 2271
    row_width = png_ptr->width;
#line 2283
    s_start = 7;
#line 2284
    s_end = 0;
#line 2285
    s_inc = -1;
#line 2288
    shift = s_start;
#line 2290
    i = (png_uint_32 )0;
    {
#line 2290
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2290
      if (! (i < row_width)) {
#line 2290
        goto while_break;
      }
#line 2292
      if (m & mask) {
#line 2296
        value = ((int )*sp___0 >> shift) & 1;
#line 2297
        *dp = (png_byte )((int )*dp & (int )((png_byte )((32639 >> (7 - shift)) & 255)));
#line 2298
        *dp = (png_byte )((int )*dp | (int )((png_byte )(value << shift)));
      }
#line 2301
      if (shift == s_end) {
#line 2303
        shift = s_start;
#line 2304
        sp___0 ++;
#line 2305
        dp ++;
      } else {
#line 2308
        shift += s_inc;
      }
#line 2310
      if (m == 1) {
#line 2311
        m = 128;
      } else {
#line 2313
        m >>= 1;
      }
#line 2290
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2315
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2319
    sp___1 = png_ptr->row_buf + 1;
#line 2320
    dp___0 = row;
#line 2322
    m___0 = 128;
#line 2325
    row_width___0 = png_ptr->width;
#line 2338
    s_start___0 = 6;
#line 2339
    s_end___0 = 0;
#line 2340
    s_inc___0 = -2;
#line 2343
    shift___0 = s_start___0;
#line 2345
    i___0 = (png_uint_32 )0;
    {
#line 2345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2345
      if (! (i___0 < row_width___0)) {
#line 2345
        goto while_break___0;
      }
#line 2347
      if (m___0 & mask) {
#line 2349
        value___0 = ((int )*sp___1 >> shift___0) & 3;
#line 2350
        *dp___0 = (png_byte )((int )*dp___0 & (int )((png_byte )((16191 >> (6 - shift___0)) & 255)));
#line 2351
        *dp___0 = (png_byte )((int )*dp___0 | (int )((png_byte )(value___0 << shift___0)));
      }
#line 2354
      if (shift___0 == s_end___0) {
#line 2356
        shift___0 = s_start___0;
#line 2357
        sp___1 ++;
#line 2358
        dp___0 ++;
      } else {
#line 2361
        shift___0 += s_inc___0;
      }
#line 2362
      if (m___0 == 1) {
#line 2363
        m___0 = 128;
      } else {
#line 2365
        m___0 >>= 1;
      }
#line 2345
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2367
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2371
    sp___2 = png_ptr->row_buf + 1;
#line 2372
    dp___1 = row;
#line 2374
    m___1 = 128;
#line 2377
    row_width___1 = png_ptr->width;
#line 2390
    s_start___1 = 4;
#line 2391
    s_end___1 = 0;
#line 2392
    s_inc___1 = -4;
#line 2394
    shift___1 = s_start___1;
#line 2396
    i___1 = (png_uint_32 )0;
    {
#line 2396
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2396
      if (! (i___1 < row_width___1)) {
#line 2396
        goto while_break___1;
      }
#line 2398
      if (m___1 & mask) {
#line 2400
        value___1 = ((int )*sp___2 >> shift___1) & 15;
#line 2401
        *dp___1 = (png_byte )((int )*dp___1 & (int )((png_byte )((3855 >> (4 - shift___1)) & 255)));
#line 2402
        *dp___1 = (png_byte )((int )*dp___1 | (int )((png_byte )(value___1 << shift___1)));
      }
#line 2405
      if (shift___1 == s_end___1) {
#line 2407
        shift___1 = s_start___1;
#line 2408
        sp___2 ++;
#line 2409
        dp___1 ++;
      } else {
#line 2412
        shift___1 += s_inc___1;
      }
#line 2413
      if (m___1 == 1) {
#line 2414
        m___1 = 128;
      } else {
#line 2416
        m___1 >>= 1;
      }
#line 2396
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2418
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2422
    sp___3 = png_ptr->row_buf + 1;
#line 2423
    dp___2 = row;
#line 2424
    pixel_bytes = (png_size_t )((int )png_ptr->row_info.pixel_depth >> 3);
#line 2426
    row_width___2 = png_ptr->width;
#line 2427
    m___2 = (png_byte )128;
#line 2430
    i___2 = (png_uint_32 )0;
    {
#line 2430
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2430
      if (! (i___2 < row_width___2)) {
#line 2430
        goto while_break___2;
      }
#line 2432
      if ((int )m___2 & mask) {
        {
#line 2434
        memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)sp___3,
               pixel_bytes);
        }
      }
#line 2437
      sp___3 += pixel_bytes;
#line 2438
      dp___2 += pixel_bytes;
#line 2440
      if ((int )m___2 == 1) {
#line 2441
        m___2 = (png_byte )128;
      } else {
#line 2443
        m___2 = (png_byte )((int )m___2 >> 1);
      }
#line 2430
      i___2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2445
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2449
  return;
}
}
#line 2458 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_do_read_interlace(png_structp png_ptr ) 
{ 
  png_row_infop row_info ;
  png_bytep row ;
  int pass ;
  png_uint_32 transformations ;
  png_uint_32 final_width ;
  png_bytep sp___0 ;
  png_bytep dp ;
  int sshift ;
  int dshift ;
  int s_start ;
  int s_end ;
  int s_inc ;
  int jstop ;
  png_byte v ;
  png_uint_32 i ;
  int j ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  int sshift___0 ;
  int dshift___0 ;
  int s_start___0 ;
  int s_end___0 ;
  int s_inc___0 ;
  int jstop___0 ;
  png_uint_32 i___0 ;
  png_byte v___0 ;
  int j___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  int sshift___1 ;
  int dshift___1 ;
  int s_start___1 ;
  int s_end___1 ;
  int s_inc___1 ;
  png_uint_32 i___1 ;
  int jstop___1 ;
  png_byte v___1 ;
  int j___1 ;
  png_size_t pixel_bytes ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  int jstop___2 ;
  png_uint_32 i___2 ;
  png_byte v___2[8] ;
  int j___2 ;

  {
#line 2461
  row_info = & png_ptr->row_info;
#line 2462
  row = png_ptr->row_buf + 1;
#line 2463
  pass = (int )png_ptr->pass;
#line 2464
  transformations = png_ptr->transformations;
#line 2472
  if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 2472
    if ((unsigned long )row_info != (unsigned long )((void *)0)) {
#line 2476
      final_width = row_info->width * (png_uint_32 )png_pass_inc[pass];
      {
#line 2480
      if ((int )row_info->pixel_depth == 1) {
#line 2480
        goto case_1;
      }
#line 2535
      if ((int )row_info->pixel_depth == 2) {
#line 2535
        goto case_2;
      }
#line 2591
      if ((int )row_info->pixel_depth == 4) {
#line 2591
        goto case_4;
      }
#line 2646
      goto switch_default;
      case_1: /* CIL Label */ 
#line 2482
      sp___0 = row + ((row_info->width - 1UL) >> 3);
#line 2483
      dp = row + ((final_width - 1UL) >> 3);
#line 2486
      jstop = (int )png_pass_inc[pass];
#line 2503
      sshift = 7 - (int )((row_info->width + 7UL) & 7UL);
#line 2504
      dshift = 7 - (int )((final_width + 7UL) & 7UL);
#line 2505
      s_start = 0;
#line 2506
      s_end = 7;
#line 2507
      s_inc = 1;
#line 2510
      i = (png_uint_32 )0;
      {
#line 2510
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2510
        if (! (i < row_info->width)) {
#line 2510
          goto while_break;
        }
#line 2512
        v = (png_byte )(((int )*sp___0 >> sshift) & 1);
#line 2513
        j = 0;
        {
#line 2513
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2513
          if (! (j < jstop)) {
#line 2513
            goto while_break___0;
          }
#line 2515
          *dp = (png_byte )((int )*dp & (int )((png_byte )((32639 >> (7 - dshift)) & 255)));
#line 2516
          *dp = (png_byte )((int )*dp | (int )((png_byte )((int )v << dshift)));
#line 2517
          if (dshift == s_end) {
#line 2519
            dshift = s_start;
#line 2520
            dp --;
          } else {
#line 2523
            dshift += s_inc;
          }
#line 2513
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2525
        if (sshift == s_end) {
#line 2527
          sshift = s_start;
#line 2528
          sp___0 --;
        } else {
#line 2531
          sshift += s_inc;
        }
#line 2510
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2533
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2537
      sp___1 = row + ((row_info->width - 1UL) >> 2);
#line 2538
      dp___0 = row + ((final_width - 1UL) >> 2);
#line 2541
      jstop___0 = (int )png_pass_inc[pass];
#line 2556
      sshift___0 = (int )((3UL - ((row_info->width + 3UL) & 3UL)) << 1);
#line 2557
      dshift___0 = (int )((3UL - ((final_width + 3UL) & 3UL)) << 1);
#line 2558
      s_start___0 = 0;
#line 2559
      s_end___0 = 6;
#line 2560
      s_inc___0 = 2;
#line 2563
      i___0 = (png_uint_32 )0;
      {
#line 2563
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2563
        if (! (i___0 < row_info->width)) {
#line 2563
          goto while_break___1;
        }
#line 2568
        v___0 = (png_byte )(((int )*sp___1 >> sshift___0) & 3);
#line 2569
        j___0 = 0;
        {
#line 2569
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2569
          if (! (j___0 < jstop___0)) {
#line 2569
            goto while_break___2;
          }
#line 2571
          *dp___0 = (png_byte )((int )*dp___0 & (int )((png_byte )((16191 >> (6 - dshift___0)) & 255)));
#line 2572
          *dp___0 = (png_byte )((int )*dp___0 | (int )((png_byte )((int )v___0 << dshift___0)));
#line 2573
          if (dshift___0 == s_end___0) {
#line 2575
            dshift___0 = s_start___0;
#line 2576
            dp___0 --;
          } else {
#line 2579
            dshift___0 += s_inc___0;
          }
#line 2569
          j___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2581
        if (sshift___0 == s_end___0) {
#line 2583
          sshift___0 = s_start___0;
#line 2584
          sp___1 --;
        } else {
#line 2587
          sshift___0 += s_inc___0;
        }
#line 2563
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2589
      goto switch_break;
      case_4: /* CIL Label */ 
#line 2593
      sp___2 = row + ((row_info->width - 1UL) >> 1);
#line 2594
      dp___1 = row + ((final_width - 1UL) >> 1);
#line 2598
      jstop___1 = (int )png_pass_inc[pass];
#line 2612
      sshift___1 = (int )((1UL - ((row_info->width + 1UL) & 1UL)) << 2);
#line 2613
      dshift___1 = (int )((1UL - ((final_width + 1UL) & 1UL)) << 2);
#line 2614
      s_start___1 = 0;
#line 2615
      s_end___1 = 4;
#line 2616
      s_inc___1 = 4;
#line 2619
      i___1 = (png_uint_32 )0;
      {
#line 2619
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2619
        if (! (i___1 < row_info->width)) {
#line 2619
          goto while_break___3;
        }
#line 2621
        v___1 = (png_byte )(((int )*sp___2 >> sshift___1) & 15);
#line 2624
        j___1 = 0;
        {
#line 2624
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2624
          if (! (j___1 < jstop___1)) {
#line 2624
            goto while_break___4;
          }
#line 2626
          *dp___1 = (png_byte )((int )*dp___1 & (int )((png_byte )((3855 >> (4 - dshift___1)) & 255)));
#line 2627
          *dp___1 = (png_byte )((int )*dp___1 | (int )((png_byte )((int )v___1 << dshift___1)));
#line 2628
          if (dshift___1 == s_end___1) {
#line 2630
            dshift___1 = s_start___1;
#line 2631
            dp___1 --;
          } else {
#line 2634
            dshift___1 += s_inc___1;
          }
#line 2624
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2636
        if (sshift___1 == s_end___1) {
#line 2638
          sshift___1 = s_start___1;
#line 2639
          sp___2 --;
        } else {
#line 2642
          sshift___1 += s_inc___1;
        }
#line 2619
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2644
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2648
      pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 2649
      sp___3 = row + (row_info->width - 1UL) * pixel_bytes;
#line 2650
      dp___2 = row + (final_width - 1UL) * pixel_bytes;
#line 2652
      jstop___2 = (int )png_pass_inc[pass];
#line 2655
      i___2 = (png_uint_32 )0;
      {
#line 2655
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2655
        if (! (i___2 < row_info->width)) {
#line 2655
          goto while_break___5;
        }
        {
#line 2660
        memcpy((void */* __restrict  */)(v___2), (void const   */* __restrict  */)sp___3,
               pixel_bytes);
#line 2661
        j___2 = 0;
        }
        {
#line 2661
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2661
          if (! (j___2 < jstop___2)) {
#line 2661
            goto while_break___6;
          }
          {
#line 2663
          memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)(v___2),
                 pixel_bytes);
#line 2664
          dp___2 -= pixel_bytes;
#line 2661
          j___2 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2666
        sp___3 -= pixel_bytes;
#line 2655
        i___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2668
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2671
      row_info->width = final_width;
#line 2672
      if ((int )row_info->pixel_depth >= 8) {
#line 2672
        row_info->rowbytes = final_width * ((png_uint_32 )row_info->pixel_depth >> 3);
      } else {
#line 2672
        row_info->rowbytes = (final_width * (png_uint_32 )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 2675
  if ((unsigned long )(& transformations) == (unsigned long )((void *)0)) {
#line 2676
    return;
  }
#line 2678
  return;
}
}
#line 2683 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_read_filter_row(png_structp png_ptr , png_row_infop row_info , png_bytep row ,
                         png_bytep prev_row , int filter ) 
{ 
  png_uint_32 i ;
  png_uint_32 istop ;
  png_uint_32 bpp ;
  png_bytep rp ;
  png_bytep lp ;
  png_bytep tmp ;
  png_uint_32 i___0 ;
  png_uint_32 istop___0 ;
  png_bytep rp___0 ;
  png_bytep pp ;
  png_bytep tmp___0 ;
  png_uint_32 i___1 ;
  png_bytep rp___1 ;
  png_bytep pp___0 ;
  png_bytep lp___0 ;
  png_uint_32 bpp___0 ;
  png_uint_32 istop___1 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_uint_32 i___2 ;
  png_bytep rp___2 ;
  png_bytep pp___1 ;
  png_bytep lp___1 ;
  png_bytep cp ;
  png_uint_32 bpp___1 ;
  png_uint_32 istop___2 ;
  png_bytep tmp___4 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2691
  if (filter == 0) {
#line 2691
    goto case_0;
  }
#line 2693
  if (filter == 1) {
#line 2693
    goto case_1;
  }
#line 2708
  if (filter == 2) {
#line 2708
    goto case_2;
  }
#line 2722
  if (filter == 3) {
#line 2722
    goto case_3;
  }
#line 2746
  if (filter == 4) {
#line 2746
    goto case_4;
  }
#line 2799
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2692
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2696
  istop = row_info->rowbytes;
#line 2697
  bpp = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2698
  rp = row + bpp;
#line 2699
  lp = row;
#line 2701
  i = bpp;
  {
#line 2701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2701
    if (! (i < istop)) {
#line 2701
      goto while_break;
    }
#line 2703
    tmp = lp;
#line 2703
    lp ++;
#line 2703
    *rp = (png_byte )(((int )*rp + (int )*tmp) & 255);
#line 2704
    rp ++;
#line 2701
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2706
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2711
  istop___0 = row_info->rowbytes;
#line 2712
  rp___0 = row;
#line 2713
  pp = prev_row;
#line 2715
  i___0 = (png_uint_32 )0;
  {
#line 2715
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2715
    if (! (i___0 < istop___0)) {
#line 2715
      goto while_break___0;
    }
#line 2717
    tmp___0 = pp;
#line 2717
    pp ++;
#line 2717
    *rp___0 = (png_byte )(((int )*rp___0 + (int )*tmp___0) & 255);
#line 2718
    rp___0 ++;
#line 2715
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2720
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2725
  rp___1 = row;
#line 2726
  pp___0 = prev_row;
#line 2727
  lp___0 = row;
#line 2728
  bpp___0 = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2729
  istop___1 = row_info->rowbytes - bpp___0;
#line 2731
  i___1 = (png_uint_32 )0;
  {
#line 2731
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2731
    if (! (i___1 < bpp___0)) {
#line 2731
      goto while_break___1;
    }
#line 2733
    tmp___1 = pp___0;
#line 2733
    pp___0 ++;
#line 2733
    *rp___1 = (png_byte )(((int )*rp___1 + (int )*tmp___1 / 2) & 255);
#line 2735
    rp___1 ++;
#line 2731
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2738
  i___1 = (png_uint_32 )0;
  {
#line 2738
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2738
    if (! (i___1 < istop___1)) {
#line 2738
      goto while_break___2;
    }
#line 2740
    tmp___2 = pp___0;
#line 2740
    pp___0 ++;
#line 2740
    tmp___3 = lp___0;
#line 2740
    lp___0 ++;
#line 2740
    *rp___1 = (png_byte )(((int )*rp___1 + ((int )*tmp___2 + (int )*tmp___3) / 2) & 255);
#line 2742
    rp___1 ++;
#line 2738
    i___1 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2744
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2749
  rp___2 = row;
#line 2750
  pp___1 = prev_row;
#line 2751
  lp___1 = row;
#line 2752
  cp = prev_row;
#line 2753
  bpp___1 = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2754
  istop___2 = row_info->rowbytes - bpp___1;
#line 2756
  i___2 = (png_uint_32 )0;
  {
#line 2756
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2756
    if (! (i___2 < bpp___1)) {
#line 2756
      goto while_break___3;
    }
#line 2758
    tmp___4 = pp___1;
#line 2758
    pp___1 ++;
#line 2758
    *rp___2 = (png_byte )(((int )*rp___2 + (int )*tmp___4) & 255);
#line 2759
    rp___2 ++;
#line 2756
    i___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2762
  i___2 = (png_uint_32 )0;
  {
#line 2762
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2762
    if (! (i___2 < istop___2)) {
#line 2762
      goto while_break___4;
    }
#line 2766
    tmp___5 = lp___1;
#line 2766
    lp___1 ++;
#line 2766
    a = (int )*tmp___5;
#line 2767
    tmp___6 = pp___1;
#line 2767
    pp___1 ++;
#line 2767
    b = (int )*tmp___6;
#line 2768
    tmp___7 = cp;
#line 2768
    cp ++;
#line 2768
    c = (int )*tmp___7;
#line 2770
    p = b - c;
#line 2771
    pc = a - c;
#line 2778
    if (p < 0) {
#line 2778
      pa = - p;
    } else {
#line 2778
      pa = p;
    }
#line 2779
    if (pc < 0) {
#line 2779
      pb = - pc;
    } else {
#line 2779
      pb = pc;
    }
#line 2780
    if (p + pc < 0) {
#line 2780
      pc = - (p + pc);
    } else {
#line 2780
      pc = p + pc;
    }
#line 2792
    if (pa <= pb) {
#line 2792
      if (pa <= pc) {
#line 2792
        p = a;
      } else {
#line 2792
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2792
      if (pb <= pc) {
#line 2792
        tmp___8 = b;
      } else {
#line 2792
        tmp___8 = c;
      }
#line 2792
      p = tmp___8;
    }
#line 2794
    *rp___2 = (png_byte )(((int )*rp___2 + p) & 255);
#line 2795
    rp___2 ++;
#line 2762
    i___2 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2797
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2800
  png_warning(png_ptr, "Ignoring bad adaptive filter type");
#line 2801
  *row = (png_byte )0;
  }
#line 2802
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2804
  return;
}
}
#line 2807 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_read_finish_row(png_structp png_ptr ) 
{ 
  png_uint_32 tmp ;
  char extra ;
  int ret ;
  png_byte chunk_length[4] ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2827
  (png_ptr->row_number) ++;
#line 2828
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 2829
    return;
  }
#line 2831
  if (png_ptr->interlaced) {
    {
#line 2833
    png_ptr->row_number = (png_uint_32 )0;
#line 2834
    png_memset_check(png_ptr, (png_voidp )png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
    }
    {
#line 2835
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2837
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 2838
      if ((int )png_ptr->pass >= 7) {
#line 2839
        goto while_break;
      }
#line 2840
      png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc[png_ptr->pass]) - 1UL) - (png_uint_32 )png_pass_start[png_ptr->pass]) / (png_uint_32 )png_pass_inc[png_ptr->pass];
#line 2845
      if ((int )png_ptr->pixel_depth >= 8) {
#line 2845
        tmp = png_ptr->iwidth * ((png_uint_32 )png_ptr->pixel_depth >> 3);
      } else {
#line 2845
        tmp = (png_ptr->iwidth * (png_uint_32 )png_ptr->pixel_depth + 7UL) >> 3;
      }
#line 2845
      png_ptr->irowbytes = tmp + 1UL;
#line 2848
      if (! (png_ptr->transformations & 2UL)) {
#line 2850
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[png_ptr->pass]) - 1UL) - (png_uint_32 )png_pass_ystart[png_ptr->pass]) / (png_uint_32 )png_pass_yinc[png_ptr->pass];
#line 2854
        if (! png_ptr->num_rows) {
#line 2855
          goto __Cont;
        }
      } else {
#line 2858
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 2835
      if (! (png_ptr->iwidth == 0UL)) {
#line 2835
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2861
    if ((int )png_ptr->pass < 7) {
#line 2862
      return;
    }
  }
#line 2865
  if (! (png_ptr->flags & 32UL)) {
#line 2873
    png_ptr->zstream.next_out = (Byte *)(& extra);
#line 2874
    png_ptr->zstream.avail_out = (uInt )1;
    {
#line 2875
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2877
      if (! png_ptr->zstream.avail_in) {
        {
#line 2879
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2879
          if (! (! png_ptr->idat_size)) {
#line 2879
            goto while_break___1;
          }
          {
#line 2883
          png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2885
          png_read_data(png_ptr, chunk_length, (png_size_t )4);
#line 2886
          png_ptr->idat_size = png_get_uint_31(png_ptr, chunk_length);
#line 2887
          png_reset_crc(png_ptr);
#line 2888
          png_crc_read(png_ptr, png_ptr->chunk_name, (png_size_t )4);
#line 2889
          tmp___0 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)((png_bytep )(png_IDAT)),
                           (size_t )4);
          }
#line 2889
          if (tmp___0) {
            {
#line 2890
            png_error(png_ptr, "Not enough image data");
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2893
        png_ptr->zstream.avail_in = (uInt )png_ptr->zbuf_size;
#line 2894
        png_ptr->zstream.next_in = png_ptr->zbuf;
#line 2895
        if (png_ptr->zbuf_size > png_ptr->idat_size) {
#line 2896
          png_ptr->zstream.avail_in = (uInt )png_ptr->idat_size;
        }
        {
#line 2897
        png_crc_read(png_ptr, png_ptr->zbuf, (png_size_t )png_ptr->zstream.avail_in);
#line 2898
        png_ptr->idat_size -= (png_uint_32 )png_ptr->zstream.avail_in;
        }
      }
      {
#line 2900
      ret = inflate(& png_ptr->zstream, 1);
      }
#line 2901
      if (ret == 1) {
#line 2903
        if (! png_ptr->zstream.avail_out) {
          {
#line 2905
          png_warning(png_ptr, "Extra compressed data");
          }
        } else
#line 2903
        if (png_ptr->zstream.avail_in) {
          {
#line 2905
          png_warning(png_ptr, "Extra compressed data");
          }
        } else
#line 2903
        if (png_ptr->idat_size) {
          {
#line 2905
          png_warning(png_ptr, "Extra compressed data");
          }
        }
#line 2906
        png_ptr->mode |= 8UL;
#line 2907
        png_ptr->flags |= 32UL;
#line 2908
        goto while_break___0;
      }
#line 2910
      if (ret != 0) {
#line 2911
        if (png_ptr->zstream.msg) {
#line 2911
          tmp___1 = (char const   *)png_ptr->zstream.msg;
        } else {
#line 2911
          tmp___1 = "Decompression Error";
        }
        {
#line 2911
        png_error(png_ptr, tmp___1);
        }
      }
#line 2914
      if (! png_ptr->zstream.avail_out) {
        {
#line 2916
        png_warning(png_ptr, "Extra compressed data.");
#line 2917
        png_ptr->mode |= 8UL;
#line 2918
        png_ptr->flags |= 32UL;
        }
#line 2919
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2923
    png_ptr->zstream.avail_out = (uInt )0;
  }
#line 2926
  if (png_ptr->idat_size) {
    {
#line 2927
    png_warning(png_ptr, "Extra compression data");
    }
  } else
#line 2926
  if (png_ptr->zstream.avail_in) {
    {
#line 2927
    png_warning(png_ptr, "Extra compression data");
    }
  }
  {
#line 2929
  inflateReset(& png_ptr->zstream);
#line 2931
  png_ptr->mode |= 8UL;
  }
#line 2932
  return;
}
}
#line 2934 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrutil.c"
void png_read_start_row(png_structp png_ptr ) 
{ 
  int max_pixel_depth ;
  png_uint_32 row_bytes ;
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;
  png_voidp tmp___1 ;
  png_voidp tmp___2 ;

  {
  {
#line 2957
  png_ptr->zstream.avail_in = (uInt )0;
#line 2958
  png_init_read_transformations(png_ptr);
  }
#line 2959
  if (png_ptr->interlaced) {
#line 2961
    if (! (png_ptr->transformations & 2UL)) {
#line 2962
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[0]) - 1UL) - (png_uint_32 )png_pass_ystart[0]) / (png_uint_32 )png_pass_yinc[0];
    } else {
#line 2965
      png_ptr->num_rows = png_ptr->height;
    }
#line 2967
    png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc[png_ptr->pass]) - 1UL) - (png_uint_32 )png_pass_start[png_ptr->pass]) / (png_uint_32 )png_pass_inc[png_ptr->pass];
#line 2972
    if ((int )png_ptr->pixel_depth >= 8) {
#line 2972
      tmp = png_ptr->iwidth * ((png_uint_32 )png_ptr->pixel_depth >> 3);
    } else {
#line 2972
      tmp = (png_ptr->iwidth * (png_uint_32 )png_ptr->pixel_depth + 7UL) >> 3;
    }
#line 2972
    row_bytes = tmp + 1UL;
#line 2974
    png_ptr->irowbytes = row_bytes;
#line 2975
    if (png_ptr->irowbytes != row_bytes) {
      {
#line 2976
      png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
      }
    }
  } else {
#line 2980
    png_ptr->num_rows = png_ptr->height;
#line 2981
    png_ptr->iwidth = png_ptr->width;
#line 2982
    png_ptr->irowbytes = png_ptr->rowbytes + 1UL;
  }
#line 2984
  max_pixel_depth = (int )png_ptr->pixel_depth;
#line 3088
  row_bytes = (png_ptr->width + 7UL) & 0xfffffffffffffff8UL;
#line 3091
  if (max_pixel_depth >= 8) {
#line 3091
    tmp___0 = row_bytes * ((png_uint_32 )max_pixel_depth >> 3);
  } else {
#line 3091
    tmp___0 = (row_bytes * (png_uint_32 )max_pixel_depth + 7UL) >> 3;
  }
  {
#line 3091
  row_bytes = (tmp___0 + 1UL) + (png_uint_32 )((max_pixel_depth + 7) >> 3);
#line 3097
  tmp___1 = png_malloc(png_ptr, row_bytes + 64UL);
#line 3097
  png_ptr->big_row_buf = (png_bytep )tmp___1;
#line 3098
  png_ptr->row_buf = png_ptr->big_row_buf + 32;
  }
#line 3107
  if (png_ptr->rowbytes > 0xfffffffffffffffeUL) {
    {
#line 3108
    png_error(png_ptr, "Row has too many bytes to allocate in memory.");
    }
  }
  {
#line 3109
  tmp___2 = png_malloc(png_ptr, png_ptr->rowbytes + 1UL);
#line 3109
  png_ptr->prev_row = (png_bytep )tmp___2;
#line 3112
  png_memset_check(png_ptr, (png_voidp )png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
#line 3121
  png_ptr->flags |= 64UL;
  }
#line 3122
  return;
}
}
#line 1542 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
void png_build_grayscale_palette(int bit_depth , png_colorp palette ) ;
#line 1723
void png_set_crc_action(png_structp png_ptr , int crit_action , int ancil_action ) ;
#line 3160
void png_read_transform_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 3385
void png_do_read_transformations(png_structp png_ptr ) ;
#line 22 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrtran.c"
void png_set_crc_action(png_structp png_ptr , int crit_action , int ancil_action ) 
{ 


  {
  {
#line 29
  if (crit_action == 5) {
#line 29
    goto case_5;
  }
#line 31
  if (crit_action == 3) {
#line 31
    goto case_3;
  }
#line 35
  if (crit_action == 4) {
#line 35
    goto case_4;
  }
#line 40
  if (crit_action == 2) {
#line 40
    goto case_2;
  }
#line 44
  goto switch_default;
  case_5: /* CIL Label */ 
#line 30
  goto switch_break;
  case_3: /* CIL Label */ 
#line 32
  png_ptr->flags &= 0xfffffffffffff3ffUL;
#line 33
  png_ptr->flags |= 1024UL;
#line 34
  goto switch_break;
  case_4: /* CIL Label */ 
#line 36
  png_ptr->flags &= 0xfffffffffffff3ffUL;
#line 37
  png_ptr->flags |= 3072UL;
#line 39
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 41
  png_warning(png_ptr, "Can\'t discard critical data on CRC error.");
  }
  switch_default: /* CIL Label */ 
#line 45
  png_ptr->flags &= 0xfffffffffffff3ffUL;
#line 46
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 51
  if (ancil_action == 5) {
#line 51
    goto case_5___0;
  }
#line 53
  if (ancil_action == 3) {
#line 53
    goto case_3___0;
  }
#line 57
  if (ancil_action == 4) {
#line 57
    goto case_4___0;
  }
#line 62
  if (ancil_action == 1) {
#line 62
    goto case_1;
  }
#line 68
  goto switch_default___0;
  case_5___0: /* CIL Label */ 
#line 52
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 54
  png_ptr->flags &= 0xfffffffffffffcffUL;
#line 55
  png_ptr->flags |= 256UL;
#line 56
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 58
  png_ptr->flags &= 0xfffffffffffffcffUL;
#line 59
  png_ptr->flags |= 768UL;
#line 61
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 63
  png_ptr->flags &= 0xfffffffffffffcffUL;
#line 64
  png_ptr->flags |= 512UL;
#line 65
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 69
  png_ptr->flags &= 0xfffffffffffffcffUL;
#line 70
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 708 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrtran.c"
void png_init_read_transformations(png_structp png_ptr ) 
{ 


  {
#line 1065
  if (png_ptr) {
#line 1066
    return;
  }
#line 1068
  return;
}
}
#line 1074 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrtran.c"
void png_read_transform_info(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 1159
  if ((int )info_ptr->color_type == 3) {
#line 1160
    info_ptr->channels = (png_byte )1;
  } else
#line 1161
  if ((int )info_ptr->color_type & 2) {
#line 1162
    info_ptr->channels = (png_byte )3;
  } else {
#line 1164
    info_ptr->channels = (png_byte )1;
  }
#line 1171
  if ((int )info_ptr->color_type & 4) {
#line 1172
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 1200
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 1203
  if ((int )info_ptr->pixel_depth >= 8) {
#line 1203
    info_ptr->rowbytes = info_ptr->width * ((png_uint_32 )info_ptr->pixel_depth >> 3);
  } else {
#line 1203
    info_ptr->rowbytes = (info_ptr->width * (png_uint_32 )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 1206
  if (png_ptr) {
#line 1207
    return;
  }
#line 1209
  return;
}
}
#line 1215 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrtran.c"
void png_do_read_transformations(png_structp png_ptr ) 
{ 
  char msg___0[50] ;

  {
#line 1220
  if ((unsigned long )png_ptr->row_buf == (unsigned long )((void *)0)) {
    {
#line 1225
    sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"NULL row buffer for row %ld, pass %d",
            png_ptr->row_number, (int )png_ptr->pass);
#line 1227
    png_error(png_ptr, (png_const_charp )(msg___0));
    }
  }
#line 1439
  return;
}
}
#line 2405 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrtran.c"
void png_build_grayscale_palette(int bit_depth , png_colorp palette ) 
{ 
  int num_palette ;
  int color_inc ;
  int i ;
  int v ;

  {
#line 2414
  if ((unsigned long )palette == (unsigned long )((void *)0)) {
#line 2415
    return;
  }
  {
#line 2419
  if (bit_depth == 1) {
#line 2419
    goto case_1;
  }
#line 2423
  if (bit_depth == 2) {
#line 2423
    goto case_2;
  }
#line 2427
  if (bit_depth == 4) {
#line 2427
    goto case_4;
  }
#line 2431
  if (bit_depth == 8) {
#line 2431
    goto case_8;
  }
#line 2435
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2420
  num_palette = 2;
#line 2421
  color_inc = 255;
#line 2422
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2424
  num_palette = 4;
#line 2425
  color_inc = 85;
#line 2426
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2428
  num_palette = 16;
#line 2429
  color_inc = 17;
#line 2430
  goto switch_break;
  case_8: /* CIL Label */ 
#line 2432
  num_palette = 256;
#line 2433
  color_inc = 1;
#line 2434
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2436
  num_palette = 0;
#line 2437
  color_inc = 0;
#line 2438
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2441
  i = 0;
#line 2441
  v = 0;
  {
#line 2441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2441
    if (! (i < num_palette)) {
#line 2441
      goto while_break;
    }
#line 2443
    (palette + i)->red = (png_byte )v;
#line 2444
    (palette + i)->green = (png_byte )v;
#line 2445
    (palette + i)->blue = (png_byte )v;
#line 2441
    i ++;
#line 2441
    v += color_inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 2447
  return;
}
}
#line 1883 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
void png_set_read_fn(png_structp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                   png_bytep  ,
                                                                                   png_size_t  ) ) ;
#line 2904
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 28 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrio.c"
void png_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 


  {
#line 32
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 33
    (*(png_ptr->read_data_fn))(png_ptr, data, length);
    }
  } else {
    {
#line 35
    png_error(png_ptr, "Call to NULL read function");
    }
  }
#line 36
  return;
}
}
#line 44 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrio.c"
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_size_t check ;
  size_t tmp ;

  {
  {
#line 56
  tmp = fread((void */* __restrict  */)data, (png_size_t )1, length, (FILE */* __restrict  */)((png_FILE_p )png_ptr->io_ptr));
#line 56
  check = tmp;
  }
#line 60
  if (check != length) {
    {
#line 61
    png_error(png_ptr, "Read Error");
    }
  }
#line 62
  return;
}
}
#line 135 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngrio.c"
void png_set_read_fn(png_structp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                   png_bytep  ,
                                                                                   png_size_t  ) ) 
{ 


  {
#line 139
  png_ptr->io_ptr = io_ptr;
#line 142
  if ((unsigned long )read_data_fn != (unsigned long )((void *)0)) {
#line 143
    png_ptr->read_data_fn = read_data_fn;
  } else {
#line 145
    png_ptr->read_data_fn = & png_default_read_data;
  }
#line 151
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 153
    png_ptr->write_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 154
    png_warning(png_ptr, "It\'s an error to set both read_data_fn and write_data_fn in the ");
#line 156
    png_warning(png_ptr, "same structure.  Resetting write_data_fn to NULL.");
    }
  }
#line 161
  png_ptr->output_flush_fn = (void (*)(png_structp  ))((void *)0);
#line 163
  return;
}
}
#line 473 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
int const   png_pass_mask[7] ;
#line 474
int const   png_pass_dsp_mask[7] ;
#line 1402
int png_sig_cmp(png_bytep sig , png_size_t start , png_size_t num_to_check ) ;
#line 1411
png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                   void (*error_fn)(png_structp  , png_const_charp  ) ,
                                   void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 1483
void png_read_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1656
void png_start_read_image(png_structp png_ptr ) ;
#line 1659
void png_read_update_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1664
void png_read_rows(png_structp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) ;
#line 1670
void png_read_row(png_structp png_ptr , png_bytep row , png_bytep dsp_row ) ;
#line 1677
void png_read_image(png_structp png_ptr , png_bytepp image ) ;
#line 1699
void png_read_end(png_structp png_ptr , png_infop info_ptr ) ;
#line 1708
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) ;
#line 1712
void png_read_destroy(png_structp png_ptr , png_infop info_ptr , png_infop end_info_ptr ) ;
#line 1889
void png_set_read_status_fn(png_structp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                      png_uint_32  ,
                                                                      int  ) ) ;
#line 2059
png_uint_32 png_get_rowbytes(png_structp png_ptr , png_infop info_ptr ) ;
#line 2401
void png_read_png(png_structp png_ptr , png_infop info_ptr , int transforms , void *params ) ;
#line 2844
void png_read_init(png_structp png_ptr ) ;
#line 2850
void png_read_init_3(png_structpp ptr_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ) ;
#line 2853
void png_read_init_2(png_structp png_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ,
                     png_size_t png_info_size ) ;
#line 2886
void png_info_destroy(png_structp png_ptr , png_infop info_ptr ) ;
#line 20 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                   void (*error_fn)(png_structp  , png_const_charp  ) ,
                                   void (*warn_fn)(png_structp  , png_const_charp  ) ) 
{ 
  png_structp png_ptr ;
  int i ;
  png_voidp tmp ;
  int tmp___0 ;
  char msg___0[80] ;
  png_voidp tmp___1 ;
  int tmp___2 ;

  {
  {
#line 53
  tmp = png_create_struct(1);
#line 53
  png_ptr = (png_structp )tmp;
  }
#line 55
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 56
    return ((png_structp )((void *)0));
  }
  {
#line 96
  png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
#line 98
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((int const   )*(user_png_ver + i) != (int const   )png_libpng_ver[i]) {
#line 102
      png_ptr->flags |= 131072UL;
    }
#line 99
    tmp___0 = i;
#line 99
    i ++;
#line 99
    if (! png_libpng_ver[tmp___0]) {
#line 99
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (png_ptr->flags & 131072UL) {
#line 112
    if ((unsigned long )user_png_ver == (unsigned long )((void *)0)) {
#line 112
      goto _L;
    } else
#line 112
    if ((int const   )*(user_png_ver + 0) != (int const   )png_libpng_ver[0]) {
#line 112
      goto _L;
    } else
#line 112
    if ((int const   )*(user_png_ver + 0) == 49) {
#line 112
      if ((int const   )*(user_png_ver + 2) != (int const   )png_libpng_ver[2]) {
#line 112
        goto _L;
      } else {
#line 112
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if ((int const   )*(user_png_ver + 0) == 48) {
#line 112
      if ((int const   )*(user_png_ver + 2) < 57) {
        _L: /* CIL Label */ 
#line 118
        if (user_png_ver) {
          {
#line 120
          sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application was compiled with png.h from libpng-%.20s",
                  user_png_ver);
#line 122
          png_warning(png_ptr, (png_const_charp )(msg___0));
          }
        }
        {
#line 124
        sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application  is  running with png.c from libpng-%.20s",
                png_libpng_ver);
#line 126
        png_warning(png_ptr, (png_const_charp )(msg___0));
#line 131
        png_error(png_ptr, "Incompatible libpng version in application and library");
        }
      }
    }
  }
  {
#line 137
  png_ptr->zbuf_size = (png_size_t )16384;
#line 138
  tmp___1 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 138
  png_ptr->zbuf = (png_bytep )tmp___1;
#line 140
  png_ptr->zstream.zalloc = & png_zalloc;
#line 141
  png_ptr->zstream.zfree = & png_zfree;
#line 142
  png_ptr->zstream.opaque = (voidpf )png_ptr;
#line 144
  tmp___2 = inflateInit_(& png_ptr->zstream, "1.2.3-optipng", (int )sizeof(z_stream ));
  }
  {
#line 146
  if (tmp___2 == 0) {
#line 146
    goto case_0;
  }
#line 148
  if (tmp___2 == -2) {
#line 148
    goto case_neg_2;
  }
#line 148
  if (tmp___2 == -4) {
#line 148
    goto case_neg_2;
  }
#line 149
  if (tmp___2 == -6) {
#line 149
    goto case_neg_6;
  }
#line 150
  goto switch_default;
  case_0: /* CIL Label */ 
#line 146
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  case_neg_4: /* CIL Label */ 
  {
#line 148
  png_error(png_ptr, "zlib memory error");
  }
#line 148
  goto switch_break;
  case_neg_6: /* CIL Label */ 
  {
#line 149
  png_error(png_ptr, "zlib version error");
  }
#line 149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 150
  png_error(png_ptr, "Unknown zlib error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 153
  png_ptr->zstream.next_out = png_ptr->zbuf;
#line 154
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 156
  png_set_read_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0));
  }
#line 171
  return (png_ptr);
}
}
#line 179 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_init(png_structp png_ptr ) 
{ 


  {
  {
#line 183
  png_read_init_2(png_ptr, "1.0.6 or earlier", (png_size_t )0, (png_size_t )0);
  }
#line 184
  return;
}
}
#line 186 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_init_2(png_structp png_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ,
                     png_size_t png_info_size ) 
{ 
  char msg___0[80] ;

  {
#line 192
  if (sizeof(png_struct ) > png_struct_size) {
#line 192
    goto _L;
  } else
#line 192
  if (sizeof(png_info ) > png_info_size) {
    _L: /* CIL Label */ 
#line 196
    png_ptr->warning_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 197
    if (user_png_ver) {
      {
#line 199
      sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application was compiled with png.h from libpng-%.20s",
              user_png_ver);
#line 201
      png_warning(png_ptr, (png_const_charp )(msg___0));
      }
    }
    {
#line 203
    sprintf((char */* __restrict  */)(msg___0), (char const   */* __restrict  */)"Application  is  running with png.c from libpng-%.20s",
            png_libpng_ver);
#line 205
    png_warning(png_ptr, (png_const_charp )(msg___0));
    }
  }
#line 208
  if (sizeof(png_struct ) > png_struct_size) {
    {
#line 210
    png_ptr->error_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 214
    png_error(png_ptr, "The png struct allocated by the application for reading is too small.");
    }
  }
#line 217
  if (sizeof(png_info ) > png_info_size) {
    {
#line 219
    png_ptr->error_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 223
    png_error(png_ptr, "The info struct allocated by application for reading is too small.");
    }
  }
  {
#line 226
  png_read_init_3(& png_ptr, user_png_ver, png_struct_size);
  }
#line 227
  return;
}
}
#line 230 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_init_3(png_structpp ptr_ptr , png_const_charp user_png_ver , png_size_t png_struct_size ) 
{ 
  int i ;
  png_structp png_ptr ;
  int tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;
  int tmp___2 ;

  {
#line 238
  i = 0;
#line 240
  png_ptr = *ptr_ptr;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if ((int const   )*(user_png_ver + i) != (int const   )png_libpng_ver[i]) {
      {
#line 249
      png_ptr->warning_fn = (void (*)(png_structp  , png_const_charp  ))((void *)0);
#line 250
      png_warning(png_ptr, "Application uses deprecated png_read_init() and should be recompiled.");
      }
#line 252
      goto while_break;
    }
#line 242
    tmp = i;
#line 242
    i ++;
#line 242
    if (! png_libpng_ver[tmp]) {
#line 242
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (sizeof(png_struct ) > png_struct_size) {
    {
#line 266
    png_destroy_struct((png_voidp )png_ptr);
#line 267
    tmp___0 = png_create_struct(1);
#line 267
    *ptr_ptr = (png_structp )tmp___0;
#line 268
    png_ptr = *ptr_ptr;
    }
  }
  {
#line 272
  memset((void *)png_ptr, 0, sizeof(png_struct ));
#line 286
  png_ptr->zbuf_size = (png_size_t )16384;
#line 287
  tmp___1 = png_malloc(png_ptr, png_ptr->zbuf_size);
#line 287
  png_ptr->zbuf = (png_bytep )tmp___1;
#line 289
  png_ptr->zstream.zalloc = & png_zalloc;
#line 290
  png_ptr->zstream.zfree = & png_zfree;
#line 291
  png_ptr->zstream.opaque = (voidpf )png_ptr;
#line 293
  tmp___2 = inflateInit_(& png_ptr->zstream, "1.2.3-optipng", (int )sizeof(z_stream ));
  }
  {
#line 295
  if (tmp___2 == 0) {
#line 295
    goto case_0;
  }
#line 297
  if (tmp___2 == -2) {
#line 297
    goto case_neg_2;
  }
#line 297
  if (tmp___2 == -4) {
#line 297
    goto case_neg_2;
  }
#line 298
  if (tmp___2 == -6) {
#line 298
    goto case_neg_6;
  }
#line 299
  goto switch_default;
  case_0: /* CIL Label */ 
#line 295
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  case_neg_4: /* CIL Label */ 
  {
#line 297
  png_error(png_ptr, "zlib memory");
  }
#line 297
  goto switch_break;
  case_neg_6: /* CIL Label */ 
  {
#line 298
  png_error(png_ptr, "zlib version");
  }
#line 298
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 299
  png_error(png_ptr, "Unknown zlib error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 302
  png_ptr->zstream.next_out = png_ptr->zbuf;
#line 303
  png_ptr->zstream.avail_out = (uInt )png_ptr->zbuf_size;
#line 305
  png_set_read_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0));
  }
#line 306
  return;
}
}
#line 317 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_info(png_structp png_ptr , png_infop info_ptr ) 
{ 
  png_size_t num_checked ;
  png_size_t num_to_check ;
  int tmp ;
  int tmp___0 ;
  png_byte chunk_length[4] ;
  png_uint_32 length ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 322
  if ((int )png_ptr->sig_bytes < 8) {
    {
#line 324
    num_checked = (png_size_t )png_ptr->sig_bytes;
#line 324
    num_to_check = 8UL - num_checked;
#line 327
    png_read_data(png_ptr, & info_ptr->signature[num_checked], num_to_check);
#line 328
    png_ptr->sig_bytes = (png_byte )8;
#line 330
    tmp___0 = png_sig_cmp(info_ptr->signature, num_checked, num_to_check);
    }
#line 330
    if (tmp___0) {
#line 332
      if (num_checked < 4UL) {
        {
#line 332
        tmp = png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4UL);
        }
#line 332
        if (tmp) {
          {
#line 334
          png_error(png_ptr, "Not a PNG file");
          }
        } else {
          {
#line 336
          png_error(png_ptr, "PNG file corrupted by ASCII conversion");
          }
        }
      } else {
        {
#line 336
        png_error(png_ptr, "PNG file corrupted by ASCII conversion");
        }
      }
    }
#line 338
    if (num_checked < 3UL) {
#line 339
      png_ptr->mode |= 4096UL;
    }
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    png_read_data(png_ptr, chunk_length, (png_size_t )4);
#line 405
    length = png_get_uint_31(png_ptr, chunk_length);
#line 407
    png_reset_crc(png_ptr);
#line 408
    png_crc_read(png_ptr, png_ptr->chunk_name, (png_size_t )4);
#line 416
    tmp___1 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)((png_bytep )(png_IDAT)),
                     (size_t )4);
    }
#line 416
    if (! tmp___1) {
#line 417
      if (png_ptr->mode & 8UL) {
#line 418
        png_ptr->mode |= 8192UL;
      }
    }
    {
#line 420
    tmp___25 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IHDR),
                      (size_t )4);
    }
#line 420
    if (tmp___25) {
      {
#line 422
      tmp___24 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IEND),
                        (size_t )4);
      }
#line 422
      if (tmp___24) {
        {
#line 425
        tmp___23 = png_handle_as_unknown(png_ptr, png_ptr->chunk_name);
        }
#line 425
        if (tmp___23) {
          {
#line 427
          tmp___2 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                           (size_t )4);
          }
#line 427
          if (! tmp___2) {
#line 428
            png_ptr->mode |= 4UL;
          }
          {
#line 429
          png_handle_unknown(png_ptr, info_ptr, length);
#line 430
          tmp___4 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_PLTE),
                           (size_t )4);
          }
#line 430
          if (tmp___4) {
            {
#line 432
            tmp___3 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                             (size_t )4);
            }
#line 432
            if (! tmp___3) {
#line 434
              if (! (png_ptr->mode & 1UL)) {
                {
#line 435
                png_error(png_ptr, "Missing IHDR before IDAT");
                }
              } else
#line 436
              if ((int )png_ptr->color_type == 3) {
#line 436
                if (! (png_ptr->mode & 2UL)) {
                  {
#line 438
                  png_error(png_ptr, "Missing PLTE before IDAT");
                  }
                }
              }
#line 439
              goto while_break;
            }
          } else {
#line 431
            png_ptr->mode |= 2UL;
          }
        } else {
          {
#line 443
          tmp___22 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_PLTE),
                            (size_t )4);
          }
#line 443
          if (tmp___22) {
            {
#line 445
            tmp___21 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                              (size_t )4);
            }
#line 445
            if (tmp___21) {
              {
#line 458
              tmp___20 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_bKGD),
                                (size_t )4);
              }
#line 458
              if (tmp___20) {
                {
#line 462
                tmp___19 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_cHRM),
                                  (size_t )4);
                }
#line 462
                if (tmp___19) {
                  {
#line 466
                  tmp___18 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_gAMA),
                                    (size_t )4);
                  }
#line 466
                  if (tmp___18) {
                    {
#line 470
                    tmp___17 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_hIST),
                                      (size_t )4);
                    }
#line 470
                    if (tmp___17) {
                      {
#line 474
                      tmp___16 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_oFFs),
                                        (size_t )4);
                      }
#line 474
                      if (tmp___16) {
                        {
#line 478
                        tmp___15 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_pCAL),
                                          (size_t )4);
                        }
#line 478
                        if (tmp___15) {
                          {
#line 482
                          tmp___14 = memcmp((void const   *)(png_ptr->chunk_name),
                                            (void const   *)(png_sCAL), (size_t )4);
                          }
#line 482
                          if (tmp___14) {
                            {
#line 486
                            tmp___13 = memcmp((void const   *)(png_ptr->chunk_name),
                                              (void const   *)(png_pHYs), (size_t )4);
                            }
#line 486
                            if (tmp___13) {
                              {
#line 490
                              tmp___12 = memcmp((void const   *)(png_ptr->chunk_name),
                                                (void const   *)(png_sBIT), (size_t )4);
                              }
#line 490
                              if (tmp___12) {
                                {
#line 494
                                tmp___11 = memcmp((void const   *)(png_ptr->chunk_name),
                                                  (void const   *)(png_sRGB), (size_t )4);
                                }
#line 494
                                if (tmp___11) {
                                  {
#line 498
                                  tmp___10 = memcmp((void const   *)(png_ptr->chunk_name),
                                                    (void const   *)(png_iCCP), (size_t )4);
                                  }
#line 498
                                  if (tmp___10) {
                                    {
#line 502
                                    tmp___9 = memcmp((void const   *)(png_ptr->chunk_name),
                                                     (void const   *)(png_sPLT), (size_t )4);
                                    }
#line 502
                                    if (tmp___9) {
                                      {
#line 506
                                      tmp___8 = memcmp((void const   *)(png_ptr->chunk_name),
                                                       (void const   *)(png_tEXt),
                                                       (size_t )4);
                                      }
#line 506
                                      if (tmp___8) {
                                        {
#line 510
                                        tmp___7 = memcmp((void const   *)(png_ptr->chunk_name),
                                                         (void const   *)(png_tIME),
                                                         (size_t )4);
                                        }
#line 510
                                        if (tmp___7) {
                                          {
#line 514
                                          tmp___6 = memcmp((void const   *)(png_ptr->chunk_name),
                                                           (void const   *)(png_tRNS),
                                                           (size_t )4);
                                          }
#line 514
                                          if (tmp___6) {
                                            {
#line 518
                                            tmp___5 = memcmp((void const   *)(png_ptr->chunk_name),
                                                             (void const   *)(png_zTXt),
                                                             (size_t )4);
                                            }
#line 518
                                            if (tmp___5) {
                                              {
#line 526
                                              png_handle_unknown(png_ptr, info_ptr,
                                                                 length);
                                              }
                                            } else {
                                              {
#line 519
                                              png_handle_zTXt(png_ptr, info_ptr, length);
                                              }
                                            }
                                          } else {
                                            {
#line 515
                                            png_handle_tRNS(png_ptr, info_ptr, length);
                                            }
                                          }
                                        } else {
                                          {
#line 511
                                          png_handle_tIME(png_ptr, info_ptr, length);
                                          }
                                        }
                                      } else {
                                        {
#line 507
                                        png_handle_tEXt(png_ptr, info_ptr, length);
                                        }
                                      }
                                    } else {
                                      {
#line 503
                                      png_handle_sPLT(png_ptr, info_ptr, length);
                                      }
                                    }
                                  } else {
                                    {
#line 499
                                    png_handle_iCCP(png_ptr, info_ptr, length);
                                    }
                                  }
                                } else {
                                  {
#line 495
                                  png_handle_sRGB(png_ptr, info_ptr, length);
                                  }
                                }
                              } else {
                                {
#line 491
                                png_handle_sBIT(png_ptr, info_ptr, length);
                                }
                              }
                            } else {
                              {
#line 487
                              png_handle_pHYs(png_ptr, info_ptr, length);
                              }
                            }
                          } else {
                            {
#line 483
                            png_handle_sCAL(png_ptr, info_ptr, length);
                            }
                          }
                        } else {
                          {
#line 479
                          png_handle_pCAL(png_ptr, info_ptr, length);
                          }
                        }
                      } else {
                        {
#line 475
                        png_handle_oFFs(png_ptr, info_ptr, length);
                        }
                      }
                    } else {
                      {
#line 471
                      png_handle_hIST(png_ptr, info_ptr, length);
                      }
                    }
                  } else {
                    {
#line 467
                    png_handle_gAMA(png_ptr, info_ptr, length);
                    }
                  }
                } else {
                  {
#line 463
                  png_handle_cHRM(png_ptr, info_ptr, length);
                  }
                }
              } else {
                {
#line 459
                png_handle_bKGD(png_ptr, info_ptr, length);
                }
              }
            } else {
#line 447
              if (! (png_ptr->mode & 1UL)) {
                {
#line 448
                png_error(png_ptr, "Missing IHDR before IDAT");
                }
              } else
#line 449
              if ((int )png_ptr->color_type == 3) {
#line 449
                if (! (png_ptr->mode & 2UL)) {
                  {
#line 451
                  png_error(png_ptr, "Missing PLTE before IDAT");
                  }
                }
              }
#line 453
              png_ptr->idat_size = length;
#line 454
              png_ptr->mode |= 4UL;
#line 455
              goto while_break;
            }
          } else {
            {
#line 444
            png_handle_PLTE(png_ptr, info_ptr, length);
            }
          }
        }
      } else {
        {
#line 423
        png_handle_IEND(png_ptr, info_ptr, length);
        }
      }
    } else {
      {
#line 421
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return;
}
}
#line 532 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_update_info(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 536
  if (! (png_ptr->flags & 64UL)) {
    {
#line 537
    png_read_start_row(png_ptr);
    }
  } else {
    {
#line 539
    png_warning(png_ptr, "Ignoring extra png_read_update_info() call; row buffer not reallocated");
    }
  }
  {
#line 541
  png_read_transform_info(png_ptr, info_ptr);
  }
#line 542
  return;
}
}
#line 550 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_start_read_image(png_structp png_ptr ) 
{ 


  {
#line 554
  if (! (png_ptr->flags & 64UL)) {
    {
#line 555
    png_read_start_row(png_ptr);
    }
  }
#line 556
  return;
}
}
#line 560 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_row(png_structp png_ptr , png_bytep row , png_bytep dsp_row ) 
{ 
  int ret ;
  int tmp ;
  png_byte chunk_length[4] ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 571
  if (! (png_ptr->flags & 64UL)) {
    {
#line 572
    png_read_start_row(png_ptr);
    }
  }
#line 573
  if (png_ptr->row_number == 0UL) {
#line 573
    if ((int )png_ptr->pass == 0) {
#line 573
      tmp = 1;
    } else {
#line 573
      tmp = 0;
    }
  } else {
#line 573
    tmp = 0;
  }
#line 608
  if (png_ptr->interlaced) {
#line 608
    if (png_ptr->transformations & 2UL) {
      {
#line 612
      if ((int )png_ptr->pass == 0) {
#line 612
        goto case_0;
      }
#line 622
      if ((int )png_ptr->pass == 1) {
#line 622
        goto case_1;
      }
#line 632
      if ((int )png_ptr->pass == 2) {
#line 632
        goto case_2;
      }
#line 642
      if ((int )png_ptr->pass == 3) {
#line 642
        goto case_3;
      }
#line 652
      if ((int )png_ptr->pass == 4) {
#line 652
        goto case_4;
      }
#line 662
      if ((int )png_ptr->pass == 5) {
#line 662
        goto case_5;
      }
#line 672
      if ((int )png_ptr->pass == 6) {
#line 672
        goto case_6;
      }
#line 610
      goto switch_break;
      case_0: /* CIL Label */ 
#line 613
      if (png_ptr->row_number & 7UL) {
#line 615
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 616
          png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
          }
        }
        {
#line 618
        png_read_finish_row(png_ptr);
        }
#line 619
        return;
      }
#line 621
      goto switch_break;
      case_1: /* CIL Label */ 
#line 623
      if (png_ptr->row_number & 7UL) {
#line 623
        goto _L;
      } else
#line 623
      if (png_ptr->width < 5UL) {
        _L: /* CIL Label */ 
#line 625
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 626
          png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
          }
        }
        {
#line 628
        png_read_finish_row(png_ptr);
        }
#line 629
        return;
      }
#line 631
      goto switch_break;
      case_2: /* CIL Label */ 
#line 633
      if ((png_ptr->row_number & 7UL) != 4UL) {
#line 635
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 635
          if (png_ptr->row_number & 4UL) {
            {
#line 636
            png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
            }
          }
        }
        {
#line 638
        png_read_finish_row(png_ptr);
        }
#line 639
        return;
      }
#line 641
      goto switch_break;
      case_3: /* CIL Label */ 
#line 643
      if (png_ptr->row_number & 3UL) {
#line 643
        goto _L___0;
      } else
#line 643
      if (png_ptr->width < 3UL) {
        _L___0: /* CIL Label */ 
#line 645
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 646
          png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
          }
        }
        {
#line 648
        png_read_finish_row(png_ptr);
        }
#line 649
        return;
      }
#line 651
      goto switch_break;
      case_4: /* CIL Label */ 
#line 653
      if ((png_ptr->row_number & 3UL) != 2UL) {
#line 655
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 655
          if (png_ptr->row_number & 2UL) {
            {
#line 656
            png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
            }
          }
        }
        {
#line 658
        png_read_finish_row(png_ptr);
        }
#line 659
        return;
      }
#line 661
      goto switch_break;
      case_5: /* CIL Label */ 
#line 663
      if (png_ptr->row_number & 1UL) {
#line 663
        goto _L___1;
      } else
#line 663
      if (png_ptr->width < 2UL) {
        _L___1: /* CIL Label */ 
#line 665
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 666
          png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
          }
        }
        {
#line 668
        png_read_finish_row(png_ptr);
        }
#line 669
        return;
      }
#line 671
      goto switch_break;
      case_6: /* CIL Label */ 
#line 673
      if (! (png_ptr->row_number & 1UL)) {
        {
#line 675
        png_read_finish_row(png_ptr);
        }
#line 676
        return;
      }
#line 678
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 683
  if (! (png_ptr->mode & 4UL)) {
    {
#line 684
    png_error(png_ptr, "Invalid attempt to read row data");
    }
  }
#line 686
  png_ptr->zstream.next_out = png_ptr->row_buf;
#line 687
  png_ptr->zstream.avail_out = (uInt )png_ptr->irowbytes;
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! png_ptr->zstream.avail_in) {
      {
#line 692
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 692
        if (! (! png_ptr->idat_size)) {
#line 692
          goto while_break___0;
        }
        {
#line 696
        png_crc_finish(png_ptr, (png_uint_32 )0);
#line 698
        png_read_data(png_ptr, chunk_length, (png_size_t )4);
#line 699
        png_ptr->idat_size = png_get_uint_31(png_ptr, chunk_length);
#line 701
        png_reset_crc(png_ptr);
#line 702
        png_crc_read(png_ptr, png_ptr->chunk_name, (png_size_t )4);
#line 703
        tmp___0 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                         (size_t )4);
        }
#line 703
        if (tmp___0) {
          {
#line 704
          png_error(png_ptr, "Not enough image data");
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 706
      png_ptr->zstream.avail_in = (uInt )png_ptr->zbuf_size;
#line 707
      png_ptr->zstream.next_in = png_ptr->zbuf;
#line 708
      if (png_ptr->zbuf_size > png_ptr->idat_size) {
#line 709
        png_ptr->zstream.avail_in = (uInt )png_ptr->idat_size;
      }
      {
#line 710
      png_crc_read(png_ptr, png_ptr->zbuf, (png_size_t )png_ptr->zstream.avail_in);
#line 712
      png_ptr->idat_size -= (png_uint_32 )png_ptr->zstream.avail_in;
      }
    }
    {
#line 714
    ret = inflate(& png_ptr->zstream, 1);
    }
#line 715
    if (ret == 1) {
#line 717
      if (png_ptr->zstream.avail_out) {
        {
#line 719
        png_error(png_ptr, "Extra compressed data");
        }
      } else
#line 717
      if (png_ptr->zstream.avail_in) {
        {
#line 719
        png_error(png_ptr, "Extra compressed data");
        }
      } else
#line 717
      if (png_ptr->idat_size) {
        {
#line 719
        png_error(png_ptr, "Extra compressed data");
        }
      }
#line 720
      png_ptr->mode |= 8UL;
#line 721
      png_ptr->flags |= 32UL;
#line 722
      goto while_break;
    }
#line 724
    if (ret != 0) {
#line 725
      if (png_ptr->zstream.msg) {
#line 725
        tmp___1 = (char const   *)png_ptr->zstream.msg;
      } else {
#line 725
        tmp___1 = "Decompression error";
      }
      {
#line 725
      png_error(png_ptr, tmp___1);
      }
    }
#line 688
    if (! png_ptr->zstream.avail_out) {
#line 688
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  png_ptr->row_info.color_type = png_ptr->color_type;
#line 731
  png_ptr->row_info.width = png_ptr->iwidth;
#line 732
  png_ptr->row_info.channels = png_ptr->channels;
#line 733
  png_ptr->row_info.bit_depth = png_ptr->bit_depth;
#line 734
  png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
#line 735
  if ((int )png_ptr->row_info.pixel_depth >= 8) {
#line 735
    png_ptr->row_info.rowbytes = png_ptr->row_info.width * ((png_uint_32 )png_ptr->row_info.pixel_depth >> 3);
  } else {
#line 735
    png_ptr->row_info.rowbytes = (png_ptr->row_info.width * (png_uint_32 )png_ptr->row_info.pixel_depth + 7UL) >> 3;
  }
#line 738
  if (*(png_ptr->row_buf + 0)) {
    {
#line 739
    png_read_filter_row(png_ptr, & png_ptr->row_info, png_ptr->row_buf + 1, png_ptr->prev_row + 1,
                        (int )*(png_ptr->row_buf + 0));
    }
  }
  {
#line 743
  png_memcpy_check(png_ptr, (png_voidp )png_ptr->prev_row, (png_voidp )png_ptr->row_buf,
                   png_ptr->rowbytes + 1UL);
  }
#line 756
  if (png_ptr->transformations) {
    {
#line 757
    png_do_read_transformations(png_ptr);
    }
  } else
#line 756
  if (png_ptr->flags & 4194304UL) {
    {
#line 757
    png_do_read_transformations(png_ptr);
    }
  }
#line 761
  if (png_ptr->interlaced) {
#line 761
    if (png_ptr->transformations & 2UL) {
#line 764
      if ((int )png_ptr->pass < 6) {
        {
#line 769
        png_do_read_interlace(png_ptr);
        }
      }
#line 771
      if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
        {
#line 772
        png_combine_row(png_ptr, dsp_row, (int )png_pass_dsp_mask[png_ptr->pass]);
        }
      }
#line 774
      if ((unsigned long )row != (unsigned long )((void *)0)) {
        {
#line 775
        png_combine_row(png_ptr, row, (int )png_pass_mask[png_ptr->pass]);
        }
      }
    } else {
#line 761
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 781
    if ((unsigned long )row != (unsigned long )((void *)0)) {
      {
#line 782
      png_combine_row(png_ptr, row, 255);
      }
    }
#line 783
    if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
      {
#line 784
      png_combine_row(png_ptr, dsp_row, 255);
      }
    }
  }
  {
#line 786
  png_read_finish_row(png_ptr);
  }
#line 788
  if ((unsigned long )png_ptr->read_row_fn != (unsigned long )((void *)0)) {
    {
#line 789
    (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 790
  return;
}
}
#line 818 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_rows(png_structp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;
  png_bytepp dp ;
  png_bytep rptr ;
  png_bytepp tmp ;
  png_bytep dptr ;
  png_bytepp tmp___0 ;
  png_bytep rptr___0 ;
  png_bytep dptr___0 ;

  {
#line 827
  rp = row;
#line 828
  dp = display_row;
#line 829
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 829
    if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 830
      i = (png_uint_32 )0;
      {
#line 830
      while (1) {
        while_continue: /* CIL Label */ ;
#line 830
        if (! (i < num_rows)) {
#line 830
          goto while_break;
        }
        {
#line 832
        tmp = rp;
#line 832
        rp ++;
#line 832
        rptr = *tmp;
#line 833
        tmp___0 = dp;
#line 833
        dp ++;
#line 833
        dptr = *tmp___0;
#line 835
        png_read_row(png_ptr, rptr, dptr);
#line 830
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 829
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 837
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 838
    i = (png_uint_32 )0;
    {
#line 838
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 838
      if (! (i < num_rows)) {
#line 838
        goto while_break___0;
      }
      {
#line 840
      rptr___0 = *rp;
#line 841
      png_read_row(png_ptr, rptr___0, (png_bytep )((void *)0));
#line 842
      rp ++;
#line 838
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 844
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 845
    i = (png_uint_32 )0;
    {
#line 845
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 845
      if (! (i < num_rows)) {
#line 845
        goto while_break___1;
      }
      {
#line 847
      dptr___0 = *dp;
#line 848
      png_read_row(png_ptr, (png_bytep )((void *)0), dptr___0);
#line 849
      dp ++;
#line 845
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 851
  return;
}
}
#line 867 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_image(png_structp png_ptr , png_bytepp image ) 
{ 
  png_uint_32 i ;
  png_uint_32 image_height ;
  int pass ;
  int j ;
  png_bytepp rp ;

  {
  {
#line 877
  pass = png_set_interlace_handling(png_ptr);
#line 886
  image_height = png_ptr->height;
#line 887
  png_ptr->num_rows = image_height;
#line 889
  j = 0;
  }
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    if (! (j < pass)) {
#line 889
      goto while_break;
    }
#line 891
    rp = image;
#line 892
    i = (png_uint_32 )0;
    {
#line 892
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 892
      if (! (i < image_height)) {
#line 892
        goto while_break___0;
      }
      {
#line 894
      png_read_row(png_ptr, *rp, (png_bytep )((void *)0));
#line 895
      rp ++;
#line 892
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 889
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return;
}
}
#line 906 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_end(png_structp png_ptr , png_infop info_ptr ) 
{ 
  png_byte chunk_length[4] ;
  png_uint_32 length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  {
#line 913
  png_crc_finish(png_ptr, (png_uint_32 )0);
  }
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 975
    png_read_data(png_ptr, chunk_length, (png_size_t )4);
#line 976
    length = png_get_uint_31(png_ptr, chunk_length);
#line 978
    png_reset_crc(png_ptr);
#line 979
    png_crc_read(png_ptr, png_ptr->chunk_name, (png_size_t )4);
#line 983
    tmp___21 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IHDR),
                      (size_t )4);
    }
#line 983
    if (tmp___21) {
      {
#line 985
      tmp___20 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IEND),
                        (size_t )4);
      }
#line 985
      if (tmp___20) {
        {
#line 988
        tmp___19 = png_handle_as_unknown(png_ptr, png_ptr->chunk_name);
        }
#line 988
        if (tmp___19) {
          {
#line 990
          tmp = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                       (size_t )4);
          }
#line 990
          if (! tmp) {
#line 992
            if (length > 0UL) {
              {
#line 993
              png_error(png_ptr, "Too many IDAT\'s found");
              }
            } else
#line 992
            if (png_ptr->mode & 8192UL) {
              {
#line 993
              png_error(png_ptr, "Too many IDAT\'s found");
              }
            }
          }
          {
#line 995
          png_handle_unknown(png_ptr, info_ptr, length);
#line 996
          tmp___0 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_PLTE),
                           (size_t )4);
          }
#line 996
          if (! tmp___0) {
#line 997
            png_ptr->mode |= 2UL;
          }
        } else {
          {
#line 1000
          tmp___18 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_IDAT),
                            (size_t )4);
          }
#line 1000
          if (tmp___18) {
            {
#line 1009
            tmp___17 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_PLTE),
                              (size_t )4);
            }
#line 1009
            if (tmp___17) {
              {
#line 1012
              tmp___16 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_bKGD),
                                (size_t )4);
              }
#line 1012
              if (tmp___16) {
                {
#line 1016
                tmp___15 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_cHRM),
                                  (size_t )4);
                }
#line 1016
                if (tmp___15) {
                  {
#line 1020
                  tmp___14 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_gAMA),
                                    (size_t )4);
                  }
#line 1020
                  if (tmp___14) {
                    {
#line 1024
                    tmp___13 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_hIST),
                                      (size_t )4);
                    }
#line 1024
                    if (tmp___13) {
                      {
#line 1028
                      tmp___12 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_oFFs),
                                        (size_t )4);
                      }
#line 1028
                      if (tmp___12) {
                        {
#line 1032
                        tmp___11 = memcmp((void const   *)(png_ptr->chunk_name), (void const   *)(png_pCAL),
                                          (size_t )4);
                        }
#line 1032
                        if (tmp___11) {
                          {
#line 1036
                          tmp___10 = memcmp((void const   *)(png_ptr->chunk_name),
                                            (void const   *)(png_sCAL), (size_t )4);
                          }
#line 1036
                          if (tmp___10) {
                            {
#line 1040
                            tmp___9 = memcmp((void const   *)(png_ptr->chunk_name),
                                             (void const   *)(png_pHYs), (size_t )4);
                            }
#line 1040
                            if (tmp___9) {
                              {
#line 1044
                              tmp___8 = memcmp((void const   *)(png_ptr->chunk_name),
                                               (void const   *)(png_sBIT), (size_t )4);
                              }
#line 1044
                              if (tmp___8) {
                                {
#line 1048
                                tmp___7 = memcmp((void const   *)(png_ptr->chunk_name),
                                                 (void const   *)(png_sRGB), (size_t )4);
                                }
#line 1048
                                if (tmp___7) {
                                  {
#line 1052
                                  tmp___6 = memcmp((void const   *)(png_ptr->chunk_name),
                                                   (void const   *)(png_iCCP), (size_t )4);
                                  }
#line 1052
                                  if (tmp___6) {
                                    {
#line 1056
                                    tmp___5 = memcmp((void const   *)(png_ptr->chunk_name),
                                                     (void const   *)(png_sPLT), (size_t )4);
                                    }
#line 1056
                                    if (tmp___5) {
                                      {
#line 1060
                                      tmp___4 = memcmp((void const   *)(png_ptr->chunk_name),
                                                       (void const   *)(png_tEXt),
                                                       (size_t )4);
                                      }
#line 1060
                                      if (tmp___4) {
                                        {
#line 1064
                                        tmp___3 = memcmp((void const   *)(png_ptr->chunk_name),
                                                         (void const   *)(png_tIME),
                                                         (size_t )4);
                                        }
#line 1064
                                        if (tmp___3) {
                                          {
#line 1068
                                          tmp___2 = memcmp((void const   *)(png_ptr->chunk_name),
                                                           (void const   *)(png_tRNS),
                                                           (size_t )4);
                                          }
#line 1068
                                          if (tmp___2) {
                                            {
#line 1072
                                            tmp___1 = memcmp((void const   *)(png_ptr->chunk_name),
                                                             (void const   *)(png_zTXt),
                                                             (size_t )4);
                                            }
#line 1072
                                            if (tmp___1) {
                                              {
#line 1080
                                              png_handle_unknown(png_ptr, info_ptr,
                                                                 length);
                                              }
                                            } else {
                                              {
#line 1073
                                              png_handle_zTXt(png_ptr, info_ptr, length);
                                              }
                                            }
                                          } else {
                                            {
#line 1069
                                            png_handle_tRNS(png_ptr, info_ptr, length);
                                            }
                                          }
                                        } else {
                                          {
#line 1065
                                          png_handle_tIME(png_ptr, info_ptr, length);
                                          }
                                        }
                                      } else {
                                        {
#line 1061
                                        png_handle_tEXt(png_ptr, info_ptr, length);
                                        }
                                      }
                                    } else {
                                      {
#line 1057
                                      png_handle_sPLT(png_ptr, info_ptr, length);
                                      }
                                    }
                                  } else {
                                    {
#line 1053
                                    png_handle_iCCP(png_ptr, info_ptr, length);
                                    }
                                  }
                                } else {
                                  {
#line 1049
                                  png_handle_sRGB(png_ptr, info_ptr, length);
                                  }
                                }
                              } else {
                                {
#line 1045
                                png_handle_sBIT(png_ptr, info_ptr, length);
                                }
                              }
                            } else {
                              {
#line 1041
                              png_handle_pHYs(png_ptr, info_ptr, length);
                              }
                            }
                          } else {
                            {
#line 1037
                            png_handle_sCAL(png_ptr, info_ptr, length);
                            }
                          }
                        } else {
                          {
#line 1033
                          png_handle_pCAL(png_ptr, info_ptr, length);
                          }
                        }
                      } else {
                        {
#line 1029
                        png_handle_oFFs(png_ptr, info_ptr, length);
                        }
                      }
                    } else {
                      {
#line 1025
                      png_handle_hIST(png_ptr, info_ptr, length);
                      }
                    }
                  } else {
                    {
#line 1021
                    png_handle_gAMA(png_ptr, info_ptr, length);
                    }
                  }
                } else {
                  {
#line 1017
                  png_handle_cHRM(png_ptr, info_ptr, length);
                  }
                }
              } else {
                {
#line 1013
                png_handle_bKGD(png_ptr, info_ptr, length);
                }
              }
            } else {
              {
#line 1010
              png_handle_PLTE(png_ptr, info_ptr, length);
              }
            }
          } else {
#line 1005
            if (length > 0UL) {
              {
#line 1006
              png_error(png_ptr, "Too many IDAT\'s found");
              }
            } else
#line 1005
            if (png_ptr->mode & 8192UL) {
              {
#line 1006
              png_error(png_ptr, "Too many IDAT\'s found");
              }
            }
            {
#line 1007
            png_crc_finish(png_ptr, length);
            }
          }
        }
      } else {
        {
#line 986
        png_handle_IEND(png_ptr, info_ptr, length);
        }
      }
    } else {
      {
#line 984
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    }
#line 915
    if (! (! (png_ptr->mode & 16UL))) {
#line 915
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1082
  return;
}
}
#line 1086 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) 
{ 
  png_structp png_ptr ;
  png_infop info_ptr ;
  png_infop end_info_ptr ;

  {
#line 1090
  png_ptr = (png_structp )((void *)0);
#line 1091
  info_ptr = (png_infop )((void *)0);
#line 1091
  end_info_ptr = (png_infop )((void *)0);
#line 1098
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 1099
    png_ptr = *png_ptr_ptr;
  }
#line 1101
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 1102
    info_ptr = *info_ptr_ptr;
  }
#line 1104
  if ((unsigned long )end_info_ptr_ptr != (unsigned long )((void *)0)) {
#line 1105
    end_info_ptr = *end_info_ptr_ptr;
  }
  {
#line 1112
  png_read_destroy(png_ptr, info_ptr, end_info_ptr);
  }
#line 1114
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 1117
    png_free_data(png_ptr, info_ptr, (png_uint_32 )16384, -1);
#line 1124
    png_destroy_struct((png_voidp )info_ptr);
#line 1126
    *info_ptr_ptr = (png_info *)((void *)0);
    }
  }
#line 1129
  if ((unsigned long )end_info_ptr != (unsigned long )((void *)0)) {
    {
#line 1132
    png_free_data(png_ptr, end_info_ptr, (png_uint_32 )16384, -1);
#line 1138
    png_destroy_struct((png_voidp )end_info_ptr);
#line 1140
    *end_info_ptr_ptr = (png_info *)((void *)0);
    }
  }
#line 1143
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 1149
    png_destroy_struct((png_voidp )png_ptr);
#line 1151
    *png_ptr_ptr = (png_struct *)((void *)0);
    }
  }
#line 1153
  return;
}
}
#line 1156 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_destroy(png_structp png_ptr , png_infop info_ptr , png_infop end_info_ptr ) 
{ 
  void (*error_fn)(png_structp  , png_const_charp  ) ;
  void (*warning_fn)(png_structp  , png_const_charp  ) ;
  png_voidp error_ptr ;

  {
#line 1170
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 1171
    png_info_destroy(png_ptr, info_ptr);
    }
  }
#line 1173
  if ((unsigned long )end_info_ptr != (unsigned long )((void *)0)) {
    {
#line 1174
    png_info_destroy(png_ptr, end_info_ptr);
    }
  }
  {
#line 1176
  png_free(png_ptr, (png_voidp )png_ptr->zbuf);
#line 1177
  png_free(png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 1178
  png_free(png_ptr, (png_voidp )png_ptr->prev_row);
  }
#line 1191
  if (png_ptr->free_me & 4096UL) {
    {
#line 1192
    png_zfree((voidpf )png_ptr, (voidpf )png_ptr->palette);
    }
  }
#line 1193
  png_ptr->free_me &= 0xffffffffffffefffUL;
#line 1202
  if (png_ptr->free_me & 8192UL) {
    {
#line 1203
    png_free(png_ptr, (png_voidp )png_ptr->trans);
    }
  }
#line 1204
  png_ptr->free_me &= 0xffffffffffffdfffUL;
#line 1213
  if (png_ptr->free_me & 8UL) {
    {
#line 1214
    png_free(png_ptr, (png_voidp )png_ptr->hist);
    }
  }
  {
#line 1215
  png_ptr->free_me &= 0xfffffffffffffff7UL;
#line 1257
  png_free(png_ptr, (png_voidp )png_ptr->time_buffer);
#line 1260
  inflateEnd(& png_ptr->zstream);
#line 1278
  error_fn = png_ptr->error_fn;
#line 1279
  warning_fn = png_ptr->warning_fn;
#line 1280
  error_ptr = png_ptr->error_ptr;
#line 1285
  memset((void *)png_ptr, 0, sizeof(png_struct ));
#line 1287
  png_ptr->error_fn = error_fn;
#line 1288
  png_ptr->warning_fn = warning_fn;
#line 1289
  png_ptr->error_ptr = error_ptr;
  }
#line 1298
  return;
}
}
#line 1300 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_set_read_status_fn(png_structp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                      png_uint_32  ,
                                                                      int  ) ) 
{ 


  {
#line 1303
  png_ptr->read_row_fn = read_row_fn;
#line 1304
  return;
}
}
#line 1309 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngread.c"
void png_read_png(png_structp png_ptr , png_infop info_ptr , int transforms , void *params ) 
{ 
  int row ;
  png_voidp tmp ;
  png_uint_32 tmp___0 ;
  png_voidp tmp___1 ;

  {
  {
#line 1326
  png_read_info(png_ptr, info_ptr);
  }
#line 1327
  if (info_ptr->height > 0xffffffffffffffffUL / sizeof(png_bytep )) {
    {
#line 1328
    png_error(png_ptr, "Image is too high to process with png_read_png()");
    }
  }
  {
#line 1428
  png_read_update_info(png_ptr, info_ptr);
#line 1433
  png_free_data(png_ptr, info_ptr, (png_uint_32 )64, 0);
  }
#line 1435
  if ((unsigned long )info_ptr->row_pointers == (unsigned long )((void *)0)) {
    {
#line 1437
    tmp = png_malloc(png_ptr, info_ptr->height * sizeof(png_bytep ));
#line 1437
    info_ptr->row_pointers = (png_bytepp )tmp;
#line 1440
    info_ptr->free_me |= 64UL;
#line 1442
    row = 0;
    }
    {
#line 1442
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1442
      if (! (row < (int )info_ptr->height)) {
#line 1442
        goto while_break;
      }
      {
#line 1444
      tmp___0 = png_get_rowbytes(png_ptr, info_ptr);
#line 1444
      tmp___1 = png_malloc(png_ptr, tmp___0);
#line 1444
      *(info_ptr->row_pointers + row) = (png_bytep )tmp___1;
#line 1442
      row ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1449
  png_read_image(png_ptr, info_ptr->row_pointers);
#line 1450
  info_ptr->valid |= 32768UL;
#line 1453
  png_read_end(png_ptr, info_ptr);
  }
#line 1455
  if (transforms == 0) {
#line 1456
    return;
  } else
#line 1455
  if ((unsigned long )params == (unsigned long )((void *)0)) {
#line 1456
    return;
  }
#line 1458
  return;
}
}
#line 1389 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
png_uint_32 png_access_version_number(void) ;
#line 1394
void png_set_sig_bytes(png_structp png_ptr , int num_bytes ) ;
#line 1408
int png_check_sig(png_bytep sig , int num ) ;
#line 1431
int png_reset_zstream(png_structp png_ptr ) ;
#line 1461
png_infop png_create_info_struct(png_structp png_ptr ) ;
#line 1466
void png_info_init(png_infop info_ptr ) ;
#line 1472
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) ;
#line 1488
png_charp png_convert_to_rfc1123(png_structp png_ptr , png_timep ptime ) ;
#line 1704
void png_destroy_info_struct(png_structp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1857
void png_init_io(png_structp png_ptr , png_FILE_p fp ) ;
#line 1887
png_voidp png_get_io_ptr(png_structp png_ptr ) ;
#line 1986
void png_data_freer(png_structp png_ptr , png_infop info_ptr , int freer , png_uint_32 mask ) ;
#line 2466
png_charp png_get_copyright(png_structp png_ptr ) ;
#line 2467
png_charp png_get_header_ver(png_structp png_ptr ) ;
#line 2468
png_charp png_get_header_version(png_structp png_ptr ) ;
#line 2469
png_charp png_get_libpng_ver(png_structp png_ptr ) ;
#line 2545
int png_mmx_support(void) ;
#line 2782
png_byte const   png_sig[8] ;
#line 2826
png_byte const   png_iTXt[5] ;
#line 23 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
char const   png_libpng_ver[18]  = 
#line 23 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
  {      (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'.', 
        (char const   )'1',      (char const   )'2',      (char const   )'-',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 29 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_sig[8]  = 
#line 29
  {      (png_byte const   )137,      (png_byte const   )80,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 33 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_IHDR[5]  = {      (png_byte const   )73,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )82, 
        (png_byte const   )'\000'};
#line 34 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_IDAT[5]  = {      (png_byte const   )73,      (png_byte const   )68,      (png_byte const   )65,      (png_byte const   )84, 
        (png_byte const   )'\000'};
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_IEND[5]  = {      (png_byte const   )73,      (png_byte const   )69,      (png_byte const   )78,      (png_byte const   )68, 
        (png_byte const   )'\000'};
#line 36 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_PLTE[5]  = {      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84,      (png_byte const   )69, 
        (png_byte const   )'\000'};
#line 37 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_bKGD[5]  = {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68, 
        (png_byte const   )'\000'};
#line 38 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_cHRM[5]  = {      (png_byte const   )99,      (png_byte const   )72,      (png_byte const   )82,      (png_byte const   )77, 
        (png_byte const   )'\000'};
#line 39 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_gAMA[5]  = {      (png_byte const   )103,      (png_byte const   )65,      (png_byte const   )77,      (png_byte const   )65, 
        (png_byte const   )'\000'};
#line 40 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_hIST[5]  = {      (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84, 
        (png_byte const   )'\000'};
#line 41 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_iCCP[5]  = {      (png_byte const   )105,      (png_byte const   )67,      (png_byte const   )67,      (png_byte const   )80, 
        (png_byte const   )'\000'};
#line 42 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_iTXt[5]  = {      (png_byte const   )105,      (png_byte const   )84,      (png_byte const   )88,      (png_byte const   )116, 
        (png_byte const   )'\000'};
#line 43 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_oFFs[5]  = {      (png_byte const   )111,      (png_byte const   )70,      (png_byte const   )70,      (png_byte const   )115, 
        (png_byte const   )'\000'};
#line 44 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_pCAL[5]  = {      (png_byte const   )112,      (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76, 
        (png_byte const   )'\000'};
#line 45 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_sCAL[5]  = {      (png_byte const   )115,      (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76, 
        (png_byte const   )'\000'};
#line 46 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_pHYs[5]  = {      (png_byte const   )112,      (png_byte const   )72,      (png_byte const   )89,      (png_byte const   )115, 
        (png_byte const   )'\000'};
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_sBIT[5]  = {      (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73,      (png_byte const   )84, 
        (png_byte const   )'\000'};
#line 48 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_sPLT[5]  = {      (png_byte const   )115,      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84, 
        (png_byte const   )'\000'};
#line 49 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_sRGB[5]  = {      (png_byte const   )115,      (png_byte const   )82,      (png_byte const   )71,      (png_byte const   )66, 
        (png_byte const   )'\000'};
#line 50 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_tEXt[5]  = {      (png_byte const   )116,      (png_byte const   )69,      (png_byte const   )88,      (png_byte const   )116, 
        (png_byte const   )'\000'};
#line 51 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_tIME[5]  = {      (png_byte const   )116,      (png_byte const   )73,      (png_byte const   )77,      (png_byte const   )69, 
        (png_byte const   )'\000'};
#line 52 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_tRNS[5]  = {      (png_byte const   )116,      (png_byte const   )82,      (png_byte const   )78,      (png_byte const   )83, 
        (png_byte const   )'\000'};
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_byte const   png_zTXt[5]  = {      (png_byte const   )122,      (png_byte const   )84,      (png_byte const   )88,      (png_byte const   )116, 
        (png_byte const   )'\000'};
#line 59 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_start[7]  = {      (int const   )0,      (int const   )4,      (int const   )0,      (int const   )2, 
        (int const   )0,      (int const   )1,      (int const   )0};
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_inc[7]  = {      (int const   )8,      (int const   )8,      (int const   )4,      (int const   )4, 
        (int const   )2,      (int const   )2,      (int const   )1};
#line 65 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_ystart[7]  = {      (int const   )0,      (int const   )0,      (int const   )4,      (int const   )0, 
        (int const   )2,      (int const   )0,      (int const   )1};
#line 68 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_yinc[7]  = {      (int const   )8,      (int const   )8,      (int const   )8,      (int const   )4, 
        (int const   )4,      (int const   )2,      (int const   )2};
#line 81 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_mask[7]  = {      (int const   )128,      (int const   )8,      (int const   )136,      (int const   )34, 
        (int const   )170,      (int const   )85,      (int const   )255};
#line 84 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int const   png_pass_dsp_mask[7]  = {      (int const   )255,      (int const   )15,      (int const   )255,      (int const   )51, 
        (int const   )255,      (int const   )85,      (int const   )255};
#line 97 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_set_sig_bytes(png_structp png_ptr , int num_bytes ) 
{ 
  int tmp ;

  {
#line 101
  if (num_bytes > 8) {
    {
#line 102
    png_error(png_ptr, "Too many bytes for PNG signature.");
    }
  }
#line 104
  if (num_bytes < 0) {
#line 104
    tmp = 0;
  } else {
#line 104
    tmp = num_bytes;
  }
#line 104
  png_ptr->sig_bytes = (png_byte )tmp;
#line 105
  return;
}
}
#line 115 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int png_sig_cmp(png_bytep sig , png_size_t start , png_size_t num_to_check ) 
{ 
  png_byte png_signature[8] ;
  int tmp ;

  {
#line 118
  png_signature[0] = (png_byte )137;
#line 118
  png_signature[1] = (png_byte )80;
#line 118
  png_signature[2] = (png_byte )78;
#line 118
  png_signature[3] = (png_byte )71;
#line 118
  png_signature[4] = (png_byte )13;
#line 118
  png_signature[5] = (png_byte )10;
#line 118
  png_signature[6] = (png_byte )26;
#line 118
  png_signature[7] = (png_byte )10;
#line 119
  if (num_to_check > 8UL) {
#line 120
    num_to_check = (png_size_t )8;
  } else
#line 121
  if (num_to_check < 1UL) {
#line 122
    return (-1);
  }
#line 124
  if (start > 7UL) {
#line 125
    return (-1);
  }
#line 127
  if (start + num_to_check > 8UL) {
#line 128
    num_to_check = 8UL - start;
  }
  {
#line 130
  tmp = memcmp((void const   *)(sig + start), (void const   *)(& png_signature[start]),
               num_to_check);
  }
#line 130
  return (tmp);
}
}
#line 138 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int png_check_sig(png_bytep sig , int num ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 141
  tmp = png_sig_cmp(sig, (png_size_t )0, (png_size_t )num);
  }
#line 141
  if (tmp) {
#line 141
    tmp___0 = 0;
  } else {
#line 141
    tmp___0 = 1;
  }
#line 141
  return (tmp___0);
}
}
#line 151 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
voidpf png_zalloc(voidpf png_ptr , uInt items , uInt size ) 
{ 
  png_voidp ptr ;
  png_structp p ;
  png_uint_32 save_flags ;
  png_uint_32 num_bytes ;
  png_voidp tmp ;

  {
#line 156
  p = (png_structp )png_ptr;
#line 157
  save_flags = p->flags;
#line 160
  if ((png_uint_32 )items > 0xffffffffffffffffUL / (png_uint_32 )size) {
    {
#line 162
    png_warning((png_structp )png_ptr, "Potential overflow in png_zalloc()");
    }
#line 163
    return ((void *)0);
  }
  {
#line 165
  num_bytes = (png_uint_32 )items * (png_uint_32 )size;
#line 167
  p->flags |= 1048576UL;
#line 168
  tmp = png_malloc((png_structp )png_ptr, num_bytes);
#line 168
  ptr = tmp;
#line 169
  p->flags = save_flags;
  }
#line 186
  return (ptr);
}
}
#line 193 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_zfree(voidpf png_ptr , voidpf ptr ) 
{ 


  {
  {
#line 197
  png_free((png_structp )png_ptr, ptr);
  }
#line 198
  return;
}
}
#line 203 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_reset_crc(png_structp png_ptr ) 
{ 


  {
  {
#line 206
  png_ptr->crc = crc32((uLong )0, (Bytef const   *)0, (uInt )0);
  }
#line 207
  return;
}
}
#line 214 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_calculate_crc(png_structp png_ptr , png_bytep ptr , png_size_t length ) 
{ 
  int need_crc ;

  {
#line 217
  need_crc = 1;
#line 219
  if ((int )png_ptr->chunk_name[0] & 32) {
#line 221
    if ((png_ptr->flags & 768UL) == 768UL) {
#line 223
      need_crc = 0;
    }
  } else
#line 227
  if (png_ptr->flags & 2048UL) {
#line 228
    need_crc = 0;
  }
#line 231
  if (need_crc) {
    {
#line 232
    png_ptr->crc = crc32(png_ptr->crc, (Bytef const   *)ptr, (uInt )length);
    }
  }
#line 233
  return;
}
}
#line 241 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_infop png_create_info_struct(png_structp png_ptr ) 
{ 
  png_infop info_ptr ;
  png_voidp tmp ;

  {
#line 247
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 247
    return ((png_infop )((void *)0));
  }
  {
#line 252
  tmp = png_create_struct(2);
#line 252
  info_ptr = (png_infop )tmp;
  }
#line 254
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 255
    png_info_init_3(& info_ptr, sizeof(png_info ));
    }
  }
#line 257
  return (info_ptr);
}
}
#line 265 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_destroy_info_struct(png_structp png_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_infop info_ptr ;

  {
#line 268
  info_ptr = (png_infop )((void *)0);
#line 271
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 272
    info_ptr = *info_ptr_ptr;
  }
#line 274
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 276
    png_info_destroy(png_ptr, info_ptr);
#line 282
    png_destroy_struct((png_voidp )info_ptr);
#line 284
    *info_ptr_ptr = (png_info *)((void *)0);
    }
  }
#line 286
  return;
}
}
#line 294 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_info_init(png_infop info_ptr ) 
{ 


  {
  {
#line 298
  png_info_init_3(& info_ptr, (png_size_t )0);
  }
#line 299
  return;
}
}
#line 302 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) 
{ 
  png_infop info_ptr ;
  png_voidp tmp ;

  {
#line 305
  info_ptr = *ptr_ptr;
#line 309
  if (sizeof(png_info ) > png_info_struct_size) {
    {
#line 311
    png_destroy_struct((png_voidp )info_ptr);
#line 312
    tmp = png_create_struct(2);
#line 312
    info_ptr = (png_infop )tmp;
#line 313
    *ptr_ptr = info_ptr;
    }
  }
  {
#line 317
  memset((void *)info_ptr, 0, sizeof(png_info ));
  }
#line 318
  return;
}
}
#line 321 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_data_freer(png_structp png_ptr , png_infop info_ptr , int freer , png_uint_32 mask ) 
{ 


  {
#line 326
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 327
    return;
  } else
#line 326
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 327
    return;
  }
#line 328
  if (freer == 1) {
#line 329
    info_ptr->free_me |= mask;
  } else
#line 330
  if (freer == 2) {
#line 331
    info_ptr->free_me &= ~ mask;
  } else {
    {
#line 333
    png_warning(png_ptr, "Unknown freer parameter in png_data_freer.");
    }
  }
#line 335
  return;
}
}
#line 338 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_free_data(png_structp png_ptr , png_infop info_ptr , png_uint_32 mask , int num ) 
{ 
  int i ;
  int i___0 ;
  int i___1 ;
  int i___2 ;
  int row ;

  {
#line 343
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 344
    return;
  } else
#line 343
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 344
    return;
  }
#line 349
  if ((mask & 16384UL) & info_ptr->free_me) {
#line 354
    if (num != -1) {
#line 356
      if (info_ptr->text) {
#line 356
        if ((info_ptr->text + num)->key) {
          {
#line 358
          png_free(png_ptr, (png_voidp )(info_ptr->text + num)->key);
#line 359
          (info_ptr->text + num)->key = (png_charp )((void *)0);
          }
        }
      }
    } else {
#line 365
      i = 0;
      {
#line 365
      while (1) {
        while_continue: /* CIL Label */ ;
#line 365
        if (! (i < info_ptr->num_text)) {
#line 365
          goto while_break;
        }
        {
#line 366
        png_free_data(png_ptr, info_ptr, (png_uint_32 )16384, i);
#line 365
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 367
      png_free(png_ptr, (png_voidp )info_ptr->text);
#line 368
      info_ptr->text = (png_textp )((void *)0);
#line 369
      info_ptr->num_text = 0;
      }
    }
  }
#line 377
  if ((mask & 8192UL) & info_ptr->free_me) {
    {
#line 382
    png_free(png_ptr, (png_voidp )info_ptr->trans);
#line 383
    info_ptr->valid &= 0xffffffffffffffefUL;
#line 387
    info_ptr->trans = (png_bytep )((void *)0);
    }
  }
#line 394
  if ((mask & 256UL) & info_ptr->free_me) {
    {
#line 400
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_width);
#line 401
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_height);
#line 402
    info_ptr->scal_s_width = (png_charp )((void *)0);
#line 403
    info_ptr->scal_s_height = (png_charp )((void *)0);
#line 405
    info_ptr->valid &= 0xffffffffffffbfffUL;
    }
  }
#line 412
  if ((mask & 128UL) & info_ptr->free_me) {
    {
#line 417
    png_free(png_ptr, (png_voidp )info_ptr->pcal_purpose);
#line 418
    png_free(png_ptr, (png_voidp )info_ptr->pcal_units);
#line 419
    info_ptr->pcal_purpose = (png_charp )((void *)0);
#line 420
    info_ptr->pcal_units = (png_charp )((void *)0);
    }
#line 421
    if ((unsigned long )info_ptr->pcal_params != (unsigned long )((void *)0)) {
#line 424
      i___0 = 0;
      {
#line 424
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 424
        if (! (i___0 < (int )info_ptr->pcal_nparams)) {
#line 424
          goto while_break___0;
        }
        {
#line 426
        png_free(png_ptr, (png_voidp )*(info_ptr->pcal_params + i___0));
#line 427
        *(info_ptr->pcal_params + i___0) = (char *)((void *)0);
#line 424
        i___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 429
      png_free(png_ptr, (png_voidp )info_ptr->pcal_params);
#line 430
      info_ptr->pcal_params = (png_charpp )((void *)0);
      }
    }
#line 432
    info_ptr->valid &= 0xfffffffffffffbffUL;
  }
#line 439
  if ((mask & 16UL) & info_ptr->free_me) {
    {
#line 444
    png_free(png_ptr, (png_voidp )info_ptr->iccp_name);
#line 445
    png_free(png_ptr, (png_voidp )info_ptr->iccp_profile);
#line 446
    info_ptr->iccp_name = (png_charp )((void *)0);
#line 447
    info_ptr->iccp_profile = (png_charp )((void *)0);
#line 448
    info_ptr->valid &= 0xffffffffffffefffUL;
    }
  }
#line 455
  if ((mask & 32UL) & info_ptr->free_me) {
#line 460
    if (num != -1) {
#line 462
      if (info_ptr->splt_palettes) {
        {
#line 464
        png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + num)->name);
#line 465
        png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + num)->entries);
#line 466
        (info_ptr->splt_palettes + num)->name = (png_charp )((void *)0);
#line 467
        (info_ptr->splt_palettes + num)->entries = (png_sPLT_entryp )((void *)0);
        }
      }
    } else {
#line 472
      if (info_ptr->splt_palettes_num) {
#line 475
        i___1 = 0;
        {
#line 475
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 475
          if (! (i___1 < (int )info_ptr->splt_palettes_num)) {
#line 475
            goto while_break___1;
          }
          {
#line 476
          png_free_data(png_ptr, info_ptr, (png_uint_32 )32, i___1);
#line 475
          i___1 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 478
        png_free(png_ptr, (png_voidp )info_ptr->splt_palettes);
#line 479
        info_ptr->splt_palettes = (png_sPLT_tp )((void *)0);
#line 480
        info_ptr->splt_palettes_num = (png_uint_32 )0;
        }
      }
#line 482
      info_ptr->valid &= 0xffffffffffffdfffUL;
    }
  }
#line 489
  if ((mask & 512UL) & info_ptr->free_me) {
#line 494
    if (num != -1) {
#line 496
      if (info_ptr->unknown_chunks) {
        {
#line 498
        png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + num)->data);
#line 499
        (info_ptr->unknown_chunks + num)->data = (png_byte *)((void *)0);
        }
      }
    } else
#line 506
    if (info_ptr->unknown_chunks_num) {
#line 508
      i___2 = 0;
      {
#line 508
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 508
        if (! (i___2 < (int )info_ptr->unknown_chunks_num)) {
#line 508
          goto while_break___2;
        }
        {
#line 509
        png_free_data(png_ptr, info_ptr, (png_uint_32 )512, i___2);
#line 508
        i___2 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 511
      png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 512
      info_ptr->unknown_chunks = (png_unknown_chunkp )((void *)0);
#line 513
      info_ptr->unknown_chunks_num = (png_size_t )0;
      }
    }
  }
#line 522
  if ((mask & 8UL) & info_ptr->free_me) {
    {
#line 527
    png_free(png_ptr, (png_voidp )info_ptr->hist);
#line 528
    info_ptr->hist = (png_uint_16p )((void *)0);
#line 529
    info_ptr->valid &= 0xffffffffffffffbfUL;
    }
  }
#line 538
  if ((mask & 4096UL) & info_ptr->free_me) {
    {
#line 543
    png_zfree((voidpf )png_ptr, (voidpf )info_ptr->palette);
#line 544
    info_ptr->palette = (png_colorp )((void *)0);
#line 545
    info_ptr->valid &= 0xfffffffffffffff7UL;
#line 549
    info_ptr->num_palette = (png_uint_16 )0;
    }
  }
#line 555
  if ((mask & 64UL) & info_ptr->free_me) {
#line 560
    if (info_ptr->row_pointers) {
#line 563
      row = 0;
      {
#line 563
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 563
        if (! (row < (int )info_ptr->height)) {
#line 563
          goto while_break___3;
        }
        {
#line 565
        png_free(png_ptr, (png_voidp )*(info_ptr->row_pointers + row));
#line 566
        *(info_ptr->row_pointers + row) = (png_byte *)((void *)0);
#line 563
        row ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 568
      png_free(png_ptr, (png_voidp )info_ptr->row_pointers);
#line 569
      info_ptr->row_pointers = (png_bytepp )((void *)0);
      }
    }
#line 571
    info_ptr->valid &= 0xffffffffffff7fffUL;
  }
#line 576
  if (num == -1) {
#line 577
    info_ptr->free_me &= ~ mask;
  } else {
#line 579
    info_ptr->free_me &= ~ (mask & 0xffffffffffffbddfUL);
  }
#line 581
  return;
}
}
#line 587 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_info_destroy(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
  {
#line 592
  png_free_data(png_ptr, info_ptr, (png_uint_32 )32767, -1);
  }
#line 595
  if (png_ptr->num_chunk_list) {
    {
#line 597
    png_free(png_ptr, (png_voidp )png_ptr->chunk_list);
#line 598
    png_ptr->chunk_list = (png_bytep )((void *)0);
#line 599
    png_ptr->num_chunk_list = 0;
    }
  }
  {
#line 603
  png_info_init_3(& info_ptr, sizeof(png_info ));
  }
#line 604
  return;
}
}
#line 611 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_voidp png_get_io_ptr(png_structp png_ptr ) 
{ 


  {
#line 614
  return (png_ptr->io_ptr);
}
}
#line 625 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
void png_init_io(png_structp png_ptr , png_FILE_p fp ) 
{ 


  {
#line 629
  png_ptr->io_ptr = (png_voidp )fp;
#line 630
  return;
}
}
#line 640 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
static char const   short_months[12][4]  = 
#line 640
  { {        (char const   )'J',        (char const   )'a',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'F',        (char const   )'e',        (char const   )'b',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'p',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'l',        (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'u',        (char const   )'g',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'e',        (char const   )'p',        (char const   )'\000'}, 
   {        (char const   )'O',        (char const   )'c',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'N',        (char const   )'o',        (char const   )'v',        (char const   )'\000'}, 
   {        (char const   )'D',        (char const   )'e',        (char const   )'c',        (char const   )'\000'}};
#line 637 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_charp png_convert_to_rfc1123(png_structp png_ptr , png_timep ptime ) 
{ 
  png_voidp tmp ;

  {
#line 644
  if ((unsigned long )png_ptr->time_buffer == (unsigned long )((void *)0)) {
    {
#line 646
    tmp = png_malloc(png_ptr, 29UL * sizeof(char ));
#line 646
    png_ptr->time_buffer = (png_charp )tmp;
    }
  }
  {
#line 672
  sprintf((char */* __restrict  */)png_ptr->time_buffer, (char const   */* __restrict  */)"%d %s %d %02d:%02d:%02d +0000",
          (int )ptime->day % 32, short_months[((int )ptime->month - 1) % 12], (int )ptime->year,
          (int )ptime->hour % 24, (int )ptime->minute % 60, (int )ptime->second % 61);
  }
#line 678
  return (png_ptr->time_buffer);
}
}
#line 692 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_charp png_get_copyright(png_structp png_ptr ) 
{ 


  {
#line 695
  if ((unsigned long )(& png_ptr) != (unsigned long )((void *)0)) {
#line 696
    return ((png_charp )"\n libpng version 1.2.12 - June 27, 2006\n   Copyright (c) 1998-2006 Glenn Randers-Pehrson\n   Copyright (c) 1996-1997 Andreas Dilger\n   Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
  }
#line 700
  return ((png_charp )"");
}
}
#line 711 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_charp png_get_libpng_ver(png_structp png_ptr ) 
{ 


  {
#line 715
  if ((unsigned long )(& png_ptr) != (unsigned long )((void *)0)) {
#line 716
    return ((png_charp )"1.2.12-optipng");
  }
#line 717
  return ((png_charp )"");
}
}
#line 720 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_charp png_get_header_ver(png_structp png_ptr ) 
{ 


  {
#line 724
  if ((unsigned long )(& png_ptr) != (unsigned long )((void *)0)) {
#line 725
    return ((png_charp )"1.2.12-optipng");
  }
#line 726
  return ((png_charp )"");
}
}
#line 729 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_charp png_get_header_version(png_structp png_ptr ) 
{ 


  {
#line 733
  if ((unsigned long )(& png_ptr) != (unsigned long )((void *)0)) {
#line 734
    return ((png_charp )" libpng version 1.2.12-optipng (header)\n");
  }
#line 735
  return ((png_charp )"");
}
}
#line 740 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int png_handle_as_unknown(png_structp png_ptr , png_bytep chunk_name ) 
{ 
  int i ;
  png_bytep p ;
  int tmp ;

  {
#line 746
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 746
    if ((unsigned long )chunk_name == (unsigned long )((void *)0)) {
#line 747
      return (0);
    } else {
#line 746
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 746
  if (png_ptr->num_chunk_list <= 0) {
#line 747
    return (0);
  }
#line 748
  p = (png_ptr->chunk_list + png_ptr->num_chunk_list * 5) - 5;
#line 749
  i = png_ptr->num_chunk_list;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! i) {
#line 749
      goto while_break;
    }
    {
#line 750
    tmp = memcmp((void const   *)chunk_name, (void const   *)p, (size_t )4);
    }
#line 750
    if (! tmp) {
#line 751
      return ((int )*(p + 4));
    }
#line 749
    i --;
#line 749
    p -= 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (0);
}
}
#line 757 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int png_reset_zstream(png_structp png_ptr ) 
{ 
  int tmp ;

  {
  {
#line 760
  tmp = inflateReset(& png_ptr->zstream);
  }
#line 760
  return (tmp);
}
}
#line 765 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
png_uint_32 png_access_version_number(void) 
{ 


  {
#line 769
  return ((png_uint_32 )10212);
}
}
#line 826 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.c"
int png_mmx_support(void) 
{ 


  {
#line 829
  return (-1);
}
}
#line 326 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
png_voidp png_create_struct(int type ) 
{ 
  png_size_t size ;
  png_voidp struct_ptr ;
  void *tmp ;

  {
#line 343
  if (type == 2) {
#line 344
    size = sizeof(png_info );
  } else
#line 345
  if (type == 1) {
#line 346
    size = sizeof(png_struct );
  } else {
#line 348
    return ((void *)0);
  }
  {
#line 369
  tmp = malloc(size);
#line 369
  struct_ptr = tmp;
  }
#line 372
  if ((unsigned long )struct_ptr != (unsigned long )((void *)0)) {
    {
#line 373
    memset(struct_ptr, 0, size);
    }
  }
#line 375
  return (struct_ptr);
}
}
#line 380 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
void png_destroy_struct(png_voidp struct_ptr ) 
{ 


  {
#line 393
  if ((unsigned long )struct_ptr != (unsigned long )((void *)0)) {
    {
#line 411
    free(struct_ptr);
    }
  }
#line 415
  return;
}
}
#line 423 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
png_voidp png_malloc(png_structp png_ptr , png_uint_32 size ) 
{ 
  png_voidp ret ;

  {
#line 447
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 448
    return ((void *)0);
  } else
#line 447
  if (size == 0UL) {
#line 448
    return ((void *)0);
  }
#line 475
  if (size != size) {
#line 476
    ret = (void *)0;
  } else {
    {
#line 478
    ret = malloc(size);
    }
  }
#line 483
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 483
    if ((png_ptr->flags & 1048576UL) == 0UL) {
      {
#line 484
      png_error(png_ptr, "Out of Memory");
      }
    }
  }
#line 487
  return (ret);
}
}
#line 492 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
void png_free(png_structp png_ptr , png_voidp ptr ) 
{ 


  {
#line 495
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 496
    return;
  } else
#line 495
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 496
    return;
  }
  {
#line 520
  free(ptr);
  }
#line 523
  return;
}
}
#line 535 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
png_voidp png_malloc_warn(png_structp png_ptr , png_uint_32 size ) 
{ 
  png_voidp ptr ;
  png_uint_32 save_flags ;
  png_voidp tmp ;

  {
  {
#line 539
  save_flags = png_ptr->flags;
#line 541
  png_ptr->flags |= 1048576UL;
#line 542
  tmp = png_malloc(png_ptr, size);
#line 542
  ptr = tmp;
#line 543
  png_ptr->flags = save_flags;
  }
#line 544
  return (ptr);
}
}
#line 548 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
png_voidp png_memcpy_check(png_structp png_ptr , png_voidp s1 , png_voidp s2 , png_uint_32 length ) 
{ 
  png_size_t size ;
  void *tmp ;

  {
#line 554
  size = length;
#line 555
  if (size != length) {
    {
#line 556
    png_error(png_ptr, "Overflow in png_memcpy_check.");
    }
  }
  {
#line 558
  tmp = memcpy((void */* __restrict  */)s1, (void const   */* __restrict  */)s2, size);
  }
#line 558
  return (tmp);
}
}
#line 561 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngmem.c"
png_voidp png_memset_check(png_structp png_ptr , png_voidp s1 , int value , png_uint_32 length ) 
{ 
  png_size_t size ;
  void *tmp ;

  {
#line 567
  size = length;
#line 568
  if (size != length) {
    {
#line 569
    png_error(png_ptr, "Overflow in png_memset_check.");
    }
  }
  {
#line 571
  tmp = memset(s1, value, size);
  }
#line 571
  return (tmp);
}
}
#line 1421 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
png_uint_32 png_get_compression_buffer_size(png_structp png_ptr ) ;
#line 1929
png_voidp png_get_user_chunk_ptr(png_structp png_ptr ) ;
#line 2055
png_uint_32 png_get_valid(png_structp png_ptr , png_infop info_ptr , png_uint_32 flag ) ;
#line 2065
png_bytepp png_get_rows(png_structp png_ptr , png_infop info_ptr ) ;
#line 2074
png_byte png_get_channels(png_structp png_ptr , png_infop info_ptr ) ;
#line 2079
png_uint_32 png_get_image_width(png_structp png_ptr , png_infop info_ptr ) ;
#line 2083
png_uint_32 png_get_image_height(png_structp png_ptr , png_infop info_ptr ) ;
#line 2087
png_byte png_get_bit_depth(png_structp png_ptr , png_infop info_ptr ) ;
#line 2091
png_byte png_get_color_type(png_structp png_ptr , png_infop info_ptr ) ;
#line 2095
png_byte png_get_filter_type(png_structp png_ptr , png_infop info_ptr ) ;
#line 2099
png_byte png_get_interlace_type(png_structp png_ptr , png_infop info_ptr ) ;
#line 2103
png_byte png_get_compression_type(png_structp png_ptr , png_infop info_ptr ) ;
#line 2107
png_uint_32 png_get_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) ;
#line 2109
png_uint_32 png_get_x_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) ;
#line 2111
png_uint_32 png_get_y_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) ;
#line 2121
png_int_32 png_get_x_offset_pixels(png_structp png_ptr , png_infop info_ptr ) ;
#line 2123
png_int_32 png_get_y_offset_pixels(png_structp png_ptr , png_infop info_ptr ) ;
#line 2125
png_int_32 png_get_x_offset_microns(png_structp png_ptr , png_infop info_ptr ) ;
#line 2127
png_int_32 png_get_y_offset_microns(png_structp png_ptr , png_infop info_ptr ) ;
#line 2133
png_bytep png_get_signature(png_structp png_ptr , png_infop info_ptr ) ;
#line 2137
png_uint_32 png_get_bKGD(png_structp png_ptr , png_infop info_ptr , png_color_16p *background ) ;
#line 2154
png_uint_32 png_get_cHRM_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point *white_x ,
                               png_fixed_point *white_y , png_fixed_point *red_x ,
                               png_fixed_point *red_y , png_fixed_point *green_x ,
                               png_fixed_point *green_y , png_fixed_point *blue_x ,
                               png_fixed_point *blue_y ) ;
#line 2182
png_uint_32 png_get_gAMA_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point *int_file_gamma ) ;
#line 2196
png_uint_32 png_get_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_16p *hist ) ;
#line 2205
png_uint_32 png_get_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 *width ,
                         png_uint_32 *height , int *bit_depth , int *color_type ,
                         int *interlace_type , int *compression_type , int *filter_type ) ;
#line 2216
png_uint_32 png_get_oFFs(png_structp png_ptr , png_infop info_ptr , png_int_32 *offset_x ,
                         png_int_32 *offset_y , int *unit_type ) ;
#line 2228
png_uint_32 png_get_pCAL(png_structp png_ptr , png_infop info_ptr , png_charp *purpose ,
                         png_int_32 *X0 , png_int_32 *X1 , int *type , int *nparams ,
                         png_charp *units , png_charpp *params ) ;
#line 2240
png_uint_32 png_get_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 *res_x ,
                         png_uint_32 *res_y , int *unit_type ) ;
#line 2249
png_uint_32 png_get_PLTE(png_structp png_ptr , png_infop info_ptr , png_colorp *palette ,
                         int *num_palette ) ;
#line 2256
png_uint_32 png_get_sBIT(png_structp png_ptr , png_infop info_ptr , png_color_8p *sig_bit ) ;
#line 2266
png_uint_32 png_get_sRGB(png_structp png_ptr , png_infop info_ptr , int *file_srgb_intent ) ;
#line 2278
png_uint_32 png_get_iCCP(png_structp png_ptr , png_infop info_ptr , png_charpp name ,
                         int *compression_type , png_charpp profile , png_uint_32 *proflen ) ;
#line 2292
png_uint_32 png_get_sPLT(png_structp png_ptr , png_infop info_ptr , png_sPLT_tpp spalettes ) ;
#line 2303
png_uint_32 png_get_text(png_structp png_ptr , png_infop info_ptr , png_textp *text_ptr ,
                         int *num_text ) ;
#line 2321
png_uint_32 png_get_tIME(png_structp png_ptr , png_infop info_ptr , png_timep *mod_time ) ;
#line 2331
png_uint_32 png_get_tRNS(png_structp png_ptr , png_infop info_ptr , png_bytep *trans ,
                         int *num_trans , png_color_16p *trans_values ) ;
#line 2351
png_uint_32 png_get_sCAL_s(png_structp png_ptr , png_infop info_ptr , int *unit ,
                           png_charpp width , png_charpp height ) ;
#line 2385
png_uint_32 png_get_unknown_chunks(png_structp png_ptr , png_infop info_ptr , png_unknown_chunkpp unknowns ) ;
#line 16 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_valid(png_structp png_ptr , png_infop info_ptr , png_uint_32 flag ) 
{ 


  {
#line 19
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 19
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 20
      return (info_ptr->valid & flag);
    } else {
#line 22
      return ((png_uint_32 )0);
    }
  } else {
#line 22
    return ((png_uint_32 )0);
  }
}
}
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_rowbytes(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 28
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 28
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 29
      return (info_ptr->rowbytes);
    } else {
#line 31
      return ((png_uint_32 )0);
    }
  } else {
#line 31
    return ((png_uint_32 )0);
  }
}
}
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_bytepp png_get_rows(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 38
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 38
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 39
      return (info_ptr->row_pointers);
    } else {
#line 41
      return ((png_bytepp )0);
    }
  } else {
#line 41
    return ((png_bytepp )0);
  }
}
}
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_image_width(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 50
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 50
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 52
      return (info_ptr->width);
    }
  }
#line 54
  return ((png_uint_32 )0);
}
}
#line 57 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_image_height(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 60
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 60
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 62
      return (info_ptr->height);
    }
  }
#line 64
  return ((png_uint_32 )0);
}
}
#line 67 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_bit_depth(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 70
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 70
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 72
      return (info_ptr->bit_depth);
    }
  }
#line 74
  return ((png_byte )0);
}
}
#line 77 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_color_type(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 80
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 80
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 82
      return (info_ptr->color_type);
    }
  }
#line 84
  return ((png_byte )0);
}
}
#line 87 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_filter_type(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 90
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 90
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 92
      return (info_ptr->filter_type);
    }
  }
#line 94
  return ((png_byte )0);
}
}
#line 97 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_interlace_type(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 100
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 100
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 102
      return (info_ptr->interlace_type);
    }
  }
#line 104
  return ((png_byte )0);
}
}
#line 107 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_compression_type(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 110
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 110
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 112
      return (info_ptr->compression_type);
    }
  }
#line 114
  return ((png_byte )0);
}
}
#line 117 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_x_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 120
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 120
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 122
      if (info_ptr->valid & 128UL) {
#line 125
        if ((int )info_ptr->phys_unit_type != 1) {
#line 126
          return ((png_uint_32 )0);
        } else {
#line 127
          return (info_ptr->x_pixels_per_unit);
        }
      }
    }
  }
#line 132
  return ((png_uint_32 )0);
}
}
#line 135 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_y_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 138
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 138
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 140
      if (info_ptr->valid & 128UL) {
#line 143
        if ((int )info_ptr->phys_unit_type != 1) {
#line 144
          return ((png_uint_32 )0);
        } else {
#line 145
          return (info_ptr->y_pixels_per_unit);
        }
      }
    }
  }
#line 150
  return ((png_uint_32 )0);
}
}
#line 153 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_pixels_per_meter(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 156
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 156
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 158
      if (info_ptr->valid & 128UL) {
#line 161
        if ((int )info_ptr->phys_unit_type != 1) {
#line 163
          return ((png_uint_32 )0);
        } else
#line 161
        if (info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit) {
#line 163
          return ((png_uint_32 )0);
        } else {
#line 164
          return (info_ptr->x_pixels_per_unit);
        }
      }
    }
  }
#line 169
  return ((png_uint_32 )0);
}
}
#line 194 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_int_32 png_get_x_offset_microns(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 197
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 197
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 199
      if (info_ptr->valid & 256UL) {
#line 202
        if ((int )info_ptr->offset_unit_type != 1) {
#line 203
          return ((png_int_32 )0);
        } else {
#line 204
          return (info_ptr->x_offset);
        }
      }
    }
  }
#line 209
  return ((png_int_32 )0);
}
}
#line 212 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_int_32 png_get_y_offset_microns(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 215
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 215
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 217
      if (info_ptr->valid & 256UL) {
#line 220
        if ((int )info_ptr->offset_unit_type != 1) {
#line 221
          return ((png_int_32 )0);
        } else {
#line 222
          return (info_ptr->y_offset);
        }
      }
    }
  }
#line 227
  return ((png_int_32 )0);
}
}
#line 230 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_int_32 png_get_x_offset_pixels(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 233
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 233
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 235
      if (info_ptr->valid & 256UL) {
#line 238
        if ((int )info_ptr->offset_unit_type != 0) {
#line 239
          return ((png_int_32 )0);
        } else {
#line 240
          return (info_ptr->x_offset);
        }
      }
    }
  }
#line 245
  return ((png_int_32 )0);
}
}
#line 248 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_int_32 png_get_y_offset_pixels(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 251
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 251
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 253
      if (info_ptr->valid & 256UL) {
#line 256
        if ((int )info_ptr->offset_unit_type != 0) {
#line 257
          return ((png_int_32 )0);
        } else {
#line 258
          return (info_ptr->y_offset);
        }
      }
    }
  }
#line 263
  return ((png_int_32 )0);
}
}
#line 342 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_byte png_get_channels(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 345
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 345
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 346
      return (info_ptr->channels);
    } else {
#line 348
      return ((png_byte )0);
    }
  } else {
#line 348
    return ((png_byte )0);
  }
}
}
#line 351 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_bytep png_get_signature(png_structp png_ptr , png_infop info_ptr ) 
{ 


  {
#line 354
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 354
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 355
      return (info_ptr->signature);
    } else {
#line 357
      return ((png_bytep )((void *)0));
    }
  } else {
#line 357
    return ((png_bytep )((void *)0));
  }
}
}
#line 361 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_bKGD(png_structp png_ptr , png_infop info_ptr , png_color_16p *background ) 
{ 


  {
#line 365
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 365
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 365
      if (info_ptr->valid & 32UL) {
#line 365
        if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 369
          *background = & info_ptr->background;
#line 370
          return ((png_uint_32 )32);
        }
      }
    }
  }
#line 372
  return ((png_uint_32 )0);
}
}
#line 408 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_cHRM_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point *white_x ,
                               png_fixed_point *white_y , png_fixed_point *red_x ,
                               png_fixed_point *red_y , png_fixed_point *green_x ,
                               png_fixed_point *green_y , png_fixed_point *blue_x ,
                               png_fixed_point *blue_y ) 
{ 


  {
#line 414
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 414
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 414
      if (info_ptr->valid & 4UL) {
#line 417
        if ((unsigned long )white_x != (unsigned long )((void *)0)) {
#line 418
          *white_x = info_ptr->int_x_white;
        }
#line 419
        if ((unsigned long )white_y != (unsigned long )((void *)0)) {
#line 420
          *white_y = info_ptr->int_y_white;
        }
#line 421
        if ((unsigned long )red_x != (unsigned long )((void *)0)) {
#line 422
          *red_x = info_ptr->int_x_red;
        }
#line 423
        if ((unsigned long )red_y != (unsigned long )((void *)0)) {
#line 424
          *red_y = info_ptr->int_y_red;
        }
#line 425
        if ((unsigned long )green_x != (unsigned long )((void *)0)) {
#line 426
          *green_x = info_ptr->int_x_green;
        }
#line 427
        if ((unsigned long )green_y != (unsigned long )((void *)0)) {
#line 428
          *green_y = info_ptr->int_y_green;
        }
#line 429
        if ((unsigned long )blue_x != (unsigned long )((void *)0)) {
#line 430
          *blue_x = info_ptr->int_x_blue;
        }
#line 431
        if ((unsigned long )blue_y != (unsigned long )((void *)0)) {
#line 432
          *blue_y = info_ptr->int_y_blue;
        }
#line 433
        return ((png_uint_32 )4);
      }
    }
  }
#line 435
  return ((png_uint_32 )0);
}
}
#line 456 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_gAMA_fixed(png_structp png_ptr , png_infop info_ptr , png_fixed_point *int_file_gamma ) 
{ 


  {
#line 460
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 460
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 460
      if (info_ptr->valid & 1UL) {
#line 460
        if ((unsigned long )int_file_gamma != (unsigned long )((void *)0)) {
#line 464
          *int_file_gamma = info_ptr->int_gamma;
#line 465
          return ((png_uint_32 )1);
        }
      }
    }
  }
#line 467
  return ((png_uint_32 )0);
}
}
#line 473 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_sRGB(png_structp png_ptr , png_infop info_ptr , int *file_srgb_intent ) 
{ 


  {
#line 476
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 476
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 476
      if (info_ptr->valid & 2048UL) {
#line 476
        if ((unsigned long )file_srgb_intent != (unsigned long )((void *)0)) {
#line 480
          *file_srgb_intent = (int )info_ptr->srgb_intent;
#line 481
          return ((png_uint_32 )2048);
        }
      }
    }
  }
#line 483
  return ((png_uint_32 )0);
}
}
#line 488 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_iCCP(png_structp png_ptr , png_infop info_ptr , png_charpp name ,
                         int *compression_type , png_charpp profile , png_uint_32 *proflen ) 
{ 


  {
#line 493
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 493
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 493
      if (info_ptr->valid & 4096UL) {
#line 493
        if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 493
          if ((unsigned long )profile != (unsigned long )((void *)0)) {
#line 493
            if ((unsigned long )proflen != (unsigned long )((void *)0)) {
#line 497
              *name = info_ptr->iccp_name;
#line 498
              *profile = info_ptr->iccp_profile;
#line 501
              *proflen = (png_uint_32 )((int )info_ptr->iccp_proflen);
#line 502
              *compression_type = (int )info_ptr->iccp_compression;
#line 503
              return ((png_uint_32 )4096);
            }
          }
        }
      }
    }
  }
#line 505
  return ((png_uint_32 )0);
}
}
#line 510 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_sPLT(png_structp png_ptr , png_infop info_ptr , png_sPLT_tpp spalettes ) 
{ 


  {
#line 514
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 514
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 514
      if ((unsigned long )spalettes != (unsigned long )((void *)0)) {
#line 515
        *spalettes = info_ptr->splt_palettes;
      }
    }
  }
#line 516
  return (info_ptr->splt_palettes_num);
}
}
#line 521 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_hIST(png_structp png_ptr , png_infop info_ptr , png_uint_16p *hist ) 
{ 


  {
#line 524
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 524
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 524
      if (info_ptr->valid & 64UL) {
#line 524
        if ((unsigned long )hist != (unsigned long )((void *)0)) {
#line 528
          *hist = info_ptr->hist;
#line 529
          return ((png_uint_32 )64);
        }
      }
    }
  }
#line 531
  return ((png_uint_32 )0);
}
}
#line 535 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_IHDR(png_structp png_ptr , png_infop info_ptr , png_uint_32 *width ,
                         png_uint_32 *height , int *bit_depth , int *color_type ,
                         int *interlace_type , int *compression_type , int *filter_type ) 
{ 


  {
#line 542
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 542
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 542
      if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 542
        if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 542
          if ((unsigned long )bit_depth != (unsigned long )((void *)0)) {
#line 542
            if ((unsigned long )color_type != (unsigned long )((void *)0)) {
#line 546
              *width = info_ptr->width;
#line 547
              *height = info_ptr->height;
#line 548
              *bit_depth = (int )info_ptr->bit_depth;
#line 549
              if ((int )info_ptr->bit_depth < 1) {
                {
#line 550
                png_error(png_ptr, "Invalid bit depth");
                }
              } else
#line 549
              if ((int )info_ptr->bit_depth > 16) {
                {
#line 550
                png_error(png_ptr, "Invalid bit depth");
                }
              }
#line 551
              *color_type = (int )info_ptr->color_type;
#line 552
              if ((int )info_ptr->color_type > 6) {
                {
#line 553
                png_error(png_ptr, "Invalid color type");
                }
              }
#line 554
              if ((unsigned long )compression_type != (unsigned long )((void *)0)) {
#line 555
                *compression_type = (int )info_ptr->compression_type;
              }
#line 556
              if ((unsigned long )filter_type != (unsigned long )((void *)0)) {
#line 557
                *filter_type = (int )info_ptr->filter_type;
              }
#line 558
              if ((unsigned long )interlace_type != (unsigned long )((void *)0)) {
#line 559
                *interlace_type = (int )info_ptr->interlace_type;
              }
#line 562
              if (*width == 0UL) {
                {
#line 563
                png_error(png_ptr, "Invalid image width");
                }
              } else
#line 562
              if (*width > 2147483647UL) {
                {
#line 563
                png_error(png_ptr, "Invalid image width");
                }
              }
#line 564
              if (*height == 0UL) {
                {
#line 565
                png_error(png_ptr, "Invalid image height");
                }
              } else
#line 564
              if (*height > 2147483647UL) {
                {
#line 565
                png_error(png_ptr, "Invalid image height");
                }
              }
#line 566
              if (info_ptr->width > ((((0xffffffffffffffffUL >> 3) - 64UL) - 1UL) - 56UL) - 8UL) {
                {
#line 573
                png_warning(png_ptr, "Width too large for libpng to process image data.");
                }
              }
#line 576
              return ((png_uint_32 )1);
            }
          }
        }
      }
    }
  }
#line 578
  return ((png_uint_32 )0);
}
}
#line 582 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_oFFs(png_structp png_ptr , png_infop info_ptr , png_int_32 *offset_x ,
                         png_int_32 *offset_y , int *unit_type ) 
{ 


  {
#line 586
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 586
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 586
      if (info_ptr->valid & 256UL) {
#line 586
        if ((unsigned long )offset_x != (unsigned long )((void *)0)) {
#line 586
          if ((unsigned long )offset_y != (unsigned long )((void *)0)) {
#line 586
            if ((unsigned long )unit_type != (unsigned long )((void *)0)) {
#line 590
              *offset_x = info_ptr->x_offset;
#line 591
              *offset_y = info_ptr->y_offset;
#line 592
              *unit_type = (int )info_ptr->offset_unit_type;
#line 593
              return ((png_uint_32 )256);
            }
          }
        }
      }
    }
  }
#line 595
  return ((png_uint_32 )0);
}
}
#line 600 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_pCAL(png_structp png_ptr , png_infop info_ptr , png_charp *purpose ,
                         png_int_32 *X0 , png_int_32 *X1 , int *type , int *nparams ,
                         png_charp *units , png_charpp *params ) 
{ 


  {
#line 605
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 605
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 605
      if (info_ptr->valid & 1024UL) {
#line 605
        if ((unsigned long )purpose != (unsigned long )((void *)0)) {
#line 605
          if ((unsigned long )X0 != (unsigned long )((void *)0)) {
#line 605
            if ((unsigned long )X1 != (unsigned long )((void *)0)) {
#line 605
              if ((unsigned long )type != (unsigned long )((void *)0)) {
#line 605
                if ((unsigned long )nparams != (unsigned long )((void *)0)) {
#line 605
                  if ((unsigned long )units != (unsigned long )((void *)0)) {
#line 605
                    if ((unsigned long )params != (unsigned long )((void *)0)) {
#line 610
                      *purpose = info_ptr->pcal_purpose;
#line 611
                      *X0 = info_ptr->pcal_X0;
#line 612
                      *X1 = info_ptr->pcal_X1;
#line 613
                      *type = (int )info_ptr->pcal_type;
#line 614
                      *nparams = (int )info_ptr->pcal_nparams;
#line 615
                      *units = info_ptr->pcal_units;
#line 616
                      *params = info_ptr->pcal_params;
#line 617
                      return ((png_uint_32 )1024);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 619
  return ((png_uint_32 )0);
}
}
#line 641 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_sCAL_s(png_structp png_ptr , png_infop info_ptr , int *unit ,
                           png_charpp width , png_charpp height ) 
{ 


  {
#line 645
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 645
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 645
      if (info_ptr->valid & 16384UL) {
#line 648
        *unit = (int )info_ptr->scal_unit;
#line 649
        *width = info_ptr->scal_s_width;
#line 650
        *height = info_ptr->scal_s_height;
#line 651
        return ((png_uint_32 )16384);
      }
    }
  }
#line 653
  return ((png_uint_32 )0);
}
}
#line 660 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_pHYs(png_structp png_ptr , png_infop info_ptr , png_uint_32 *res_x ,
                         png_uint_32 *res_y , int *unit_type ) 
{ 
  png_uint_32 retval ;

  {
#line 664
  retval = (png_uint_32 )0;
#line 666
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 666
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 666
      if (info_ptr->valid & 128UL) {
#line 670
        if ((unsigned long )res_x != (unsigned long )((void *)0)) {
#line 672
          *res_x = info_ptr->x_pixels_per_unit;
#line 673
          retval |= 128UL;
        }
#line 675
        if ((unsigned long )res_y != (unsigned long )((void *)0)) {
#line 677
          *res_y = info_ptr->y_pixels_per_unit;
#line 678
          retval |= 128UL;
        }
#line 680
        if ((unsigned long )unit_type != (unsigned long )((void *)0)) {
#line 682
          *unit_type = (int )info_ptr->phys_unit_type;
#line 683
          retval |= 128UL;
        }
      }
    }
  }
#line 686
  return (retval);
}
}
#line 690 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_PLTE(png_structp png_ptr , png_infop info_ptr , png_colorp *palette ,
                         int *num_palette ) 
{ 


  {
#line 694
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 694
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 694
      if (info_ptr->valid & 8UL) {
#line 694
        if ((unsigned long )palette != (unsigned long )((void *)0)) {
#line 698
          *palette = info_ptr->palette;
#line 699
          *num_palette = (int )info_ptr->num_palette;
#line 701
          return ((png_uint_32 )8);
        }
      }
    }
  }
#line 703
  return ((png_uint_32 )0);
}
}
#line 707 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_sBIT(png_structp png_ptr , png_infop info_ptr , png_color_8p *sig_bit ) 
{ 


  {
#line 710
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 710
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 710
      if (info_ptr->valid & 2UL) {
#line 710
        if ((unsigned long )sig_bit != (unsigned long )((void *)0)) {
#line 714
          *sig_bit = & info_ptr->sig_bit;
#line 715
          return ((png_uint_32 )2);
        }
      }
    }
  }
#line 717
  return ((png_uint_32 )0);
}
}
#line 722 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_text(png_structp png_ptr , png_infop info_ptr , png_textp *text_ptr ,
                         int *num_text ) 
{ 


  {
#line 726
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 726
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 726
      if (info_ptr->num_text > 0) {
#line 731
        if ((unsigned long )text_ptr != (unsigned long )((void *)0)) {
#line 732
          *text_ptr = info_ptr->text;
        }
#line 733
        if ((unsigned long )num_text != (unsigned long )((void *)0)) {
#line 734
          *num_text = info_ptr->num_text;
        }
#line 735
        return ((png_uint_32 )info_ptr->num_text);
      }
    }
  }
#line 737
  if ((unsigned long )num_text != (unsigned long )((void *)0)) {
#line 738
    *num_text = 0;
  }
#line 739
  return ((png_uint_32 )0);
}
}
#line 744 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_tIME(png_structp png_ptr , png_infop info_ptr , png_timep *mod_time ) 
{ 


  {
#line 747
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 747
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 747
      if (info_ptr->valid & 512UL) {
#line 747
        if ((unsigned long )mod_time != (unsigned long )((void *)0)) {
#line 751
          *mod_time = & info_ptr->mod_time;
#line 752
          return ((png_uint_32 )512);
        }
      }
    }
  }
#line 754
  return ((png_uint_32 )0);
}
}
#line 759 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_tRNS(png_structp png_ptr , png_infop info_ptr , png_bytep *trans ,
                         int *num_trans , png_color_16p *trans_values ) 
{ 
  png_uint_32 retval ;

  {
#line 763
  retval = (png_uint_32 )0;
#line 764
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 764
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 764
      if (info_ptr->valid & 16UL) {
#line 767
        if ((int )info_ptr->color_type == 3) {
#line 769
          if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 771
            *trans = info_ptr->trans;
#line 772
            retval |= 16UL;
          }
#line 774
          if ((unsigned long )trans_values != (unsigned long )((void *)0)) {
#line 775
            *trans_values = & info_ptr->trans_values;
          }
        } else {
#line 779
          if ((unsigned long )trans_values != (unsigned long )((void *)0)) {
#line 781
            *trans_values = & info_ptr->trans_values;
#line 782
            retval |= 16UL;
          }
#line 784
          if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 785
            *trans = (png_bytep )((void *)0);
          }
        }
#line 787
        if ((unsigned long )num_trans != (unsigned long )((void *)0)) {
#line 789
          *num_trans = (int )info_ptr->num_trans;
#line 790
          retval |= 16UL;
        }
      }
    }
  }
#line 793
  return (retval);
}
}
#line 798 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_unknown_chunks(png_structp png_ptr , png_infop info_ptr , png_unknown_chunkpp unknowns ) 
{ 


  {
#line 802
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 802
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 802
      if ((unsigned long )unknowns != (unsigned long )((void *)0)) {
#line 803
        *unknowns = info_ptr->unknown_chunks;
      }
    }
  }
#line 804
  return (info_ptr->unknown_chunks_num);
}
}
#line 817 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_voidp png_get_user_chunk_ptr(png_structp png_ptr ) 
{ 
  png_voidp tmp ;

  {
#line 820
  if (png_ptr) {
#line 820
    tmp = png_ptr->user_chunk_ptr;
  } else {
#line 820
    tmp = (void *)0;
  }
#line 820
  return (tmp);
}
}
#line 825 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngget.c"
png_uint_32 png_get_compression_buffer_size(png_structp png_ptr ) 
{ 
  png_size_t tmp ;

  {
#line 828
  if (png_ptr) {
#line 828
    tmp = png_ptr->zbuf_size;
  } else {
#line 828
    tmp = (png_size_t )0L;
  }
#line 828
  return (tmp);
}
}
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 1872 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/png.h"
png_voidp png_get_error_ptr(png_structp png_ptr ) ;
#line 20 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
static void png_default_error(png_structp png_ptr , png_const_charp error_message ) ;
#line 23
static void png_default_warning(png_structp png_ptr , png_const_charp warning_message ) ;
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
void png_error(png_structp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 71
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 71
    if ((unsigned long )png_ptr->error_fn != (unsigned long )((void *)0)) {
      {
#line 72
      (*(png_ptr->error_fn))(png_ptr, error_message);
      }
    }
  }
  {
#line 76
  png_default_error(png_ptr, error_message);
  }
#line 77
  return;
}
}
#line 84 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
void png_warning(png_structp png_ptr , png_const_charp warning_message ) 
{ 
  int offset ;

  {
#line 87
  offset = 0;
#line 88
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 95
    if ((int const   )*warning_message == 35) {
#line 97
      offset = 1;
      {
#line 97
      while (1) {
        while_continue: /* CIL Label */ ;
#line 97
        if (! (offset < 15)) {
#line 97
          goto while_break;
        }
#line 98
        if ((int const   )*(warning_message + offset) == 32) {
#line 99
          goto while_break;
        }
#line 97
        offset ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 102
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 102
      if ((unsigned long )png_ptr->warning_fn != (unsigned long )((void *)0)) {
        {
#line 103
        (*(png_ptr->warning_fn))(png_ptr, warning_message + offset);
        }
      }
    }
  } else {
    {
#line 106
    png_default_warning(png_ptr, warning_message + offset);
    }
  }
#line 107
  return;
}
}
#line 116 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
static char const   png_digit[16]  = 
#line 116
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F'};
#line 121 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
static void png_format_buffer(png_structp png_ptr , png_charp buffer , png_const_charp error_message ) 
{ 
  int iout ;
  int iin ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 125
  iout = 0;
#line 125
  iin = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (iin < 4)) {
#line 127
      goto while_break;
    }
#line 129
    tmp = iin;
#line 129
    iin ++;
#line 129
    c = (int )png_ptr->chunk_name[tmp];
#line 130
    if (c < 65) {
#line 130
      goto _L;
    } else
#line 130
    if (c > 122) {
#line 130
      goto _L;
    } else
#line 130
    if (c > 90) {
#line 130
      if (c < 97) {
        _L: /* CIL Label */ 
#line 132
        tmp___0 = iout;
#line 132
        iout ++;
#line 132
        *(buffer + tmp___0) = (char )'[';
#line 133
        tmp___1 = iout;
#line 133
        iout ++;
#line 133
        *(buffer + tmp___1) = (char )png_digit[(c & 240) >> 4];
#line 134
        tmp___2 = iout;
#line 134
        iout ++;
#line 134
        *(buffer + tmp___2) = (char )png_digit[c & 15];
#line 135
        tmp___3 = iout;
#line 135
        iout ++;
#line 135
        *(buffer + tmp___3) = (char )']';
      } else {
#line 139
        tmp___4 = iout;
#line 139
        iout ++;
#line 139
        *(buffer + tmp___4) = (char )((png_byte )c);
      }
    } else {
#line 139
      tmp___4 = iout;
#line 139
      iout ++;
#line 139
      *(buffer + tmp___4) = (char )((png_byte )c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if ((unsigned long )error_message == (unsigned long )((void *)0)) {
#line 144
    *(buffer + iout) = (char)0;
  } else {
    {
#line 147
    tmp___5 = iout;
#line 147
    iout ++;
#line 147
    *(buffer + tmp___5) = (char )':';
#line 148
    tmp___6 = iout;
#line 148
    iout ++;
#line 148
    *(buffer + tmp___6) = (char )' ';
#line 149
    strncpy((char */* __restrict  */)(buffer + iout), (char const   */* __restrict  */)error_message,
            (size_t )63);
#line 150
    *(buffer + (iout + 63)) = (char)0;
    }
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
void png_chunk_error(png_structp png_ptr , png_const_charp error_message ) 
{ 
  char msg___0[82] ;

  {
#line 158
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 159
    png_error(png_ptr, error_message);
    }
  }
  {
#line 160
  png_format_buffer(png_ptr, msg___0, error_message);
#line 161
  png_error(png_ptr, (png_const_charp )(msg___0));
  }
#line 162
  return;
}
}
#line 164 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
void png_chunk_warning(png_structp png_ptr , png_const_charp warning_message ) 
{ 
  char msg___0[82] ;

  {
#line 168
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 169
    png_warning(png_ptr, warning_message);
    }
  }
  {
#line 170
  png_format_buffer(png_ptr, msg___0, warning_message);
#line 171
  png_warning(png_ptr, (png_const_charp )(msg___0));
  }
#line 172
  return;
}
}
#line 179 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
static void png_default_error(png_structp png_ptr , png_const_charp error_message ) 
{ 


  {
  {
#line 205
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng error: %s\n",
          error_message);
  }
#line 220
  if (png_ptr) {
    {
#line 221
    abort();
    }
  }
#line 228
  return;
}
}
#line 235 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
static void png_default_warning(png_structp png_ptr , png_const_charp warning_message ) 
{ 


  {
  {
#line 261
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng warning: %s\n",
          warning_message);
  }
#line 268
  if (png_ptr) {
#line 269
    return;
  }
#line 270
  return;
}
}
#line 277 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
void png_set_error_fn(png_structp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) 
{ 


  {
#line 281
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 282
    return;
  }
#line 283
  png_ptr->error_ptr = error_ptr;
#line 284
  png_ptr->error_fn = error_fn;
#line 285
  png_ptr->warning_fn = warning_fn;
#line 286
  return;
}
}
#line 293 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/libpng/pngerror.c"
png_voidp png_get_error_ptr(png_structp png_ptr ) 
{ 


  {
#line 296
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 297
    return ((void *)0);
  }
#line 298
  return (png_ptr->error_ptr);
}
}
#line 69 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.h"
void minitiff_read_info(struct minitiff_info *tiff_ptr , FILE *fp ) ;
#line 70
void minitiff_read_row(struct minitiff_info *tiff_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *fp ) ;
#line 87
void minitiff_error(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) ;
#line 88
void minitiff_warning(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) ;
#line 95
char const   minitiff_sig_m[4] ;
#line 96
char const   minitiff_sig_i[4] ;
#line 23 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_read  =    "Error reading TIFF file";
#line 26 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_notiff  =    "Not a TIFF file";
#line 29 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_invalid  =    "Invalid TIFF file";
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_unsupported  =    "Unsupported data format in TIFF file";
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_compr  =    "Unsupported compression in TIFF file";
#line 38 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_err_memory  =    "Out of memory";
#line 41 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_warn_tag  =    "Unrecognized tag(s) in TIFF file";
#line 44 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_warn_metadata  =    "Unrecognized EXIF/IPTC/XMP metadata in TIFF file";
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static char const   *tiff_warn_multiple  =    "Selected first image from multi-image TIFF file";
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static unsigned int get_ushort_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 64
  return (((unsigned int )*(buf_ptr + 0) << 8) + (unsigned int )*(buf_ptr + 1));
}
}
#line 68 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static unsigned int get_ushort_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 71
  return ((unsigned int )*(buf_ptr + 0) + ((unsigned int )*(buf_ptr + 1) << 8));
}
}
#line 75 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static unsigned long get_ulong_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 78
  return (((((unsigned long )*(buf_ptr + 0) << 24) + ((unsigned long )*(buf_ptr + 1) << 16)) + ((unsigned long )*(buf_ptr + 2) << 8)) + (unsigned long )*(buf_ptr + 3));
}
}
#line 84 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static unsigned long get_ulong_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 87
  return ((((unsigned long )*(buf_ptr + 0) + ((unsigned long )*(buf_ptr + 1) << 8)) + ((unsigned long )*(buf_ptr + 2) << 16)) + ((unsigned long )*(buf_ptr + 3) << 24));
}
}
#line 93 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static unsigned long get_ulong_value(struct minitiff_get_struct *get_ptr , int tag_type ,
                                     unsigned char const   *buf_ptr ) 
{ 
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 99
  if (tag_type == 1) {
#line 99
    goto case_1;
  }
#line 101
  if (tag_type == 3) {
#line 101
    goto case_3;
  }
#line 103
  if (tag_type == 4) {
#line 103
    goto case_4;
  }
#line 105
  goto switch_default;
  case_1: /* CIL Label */ 
#line 100
  return ((unsigned long )*(buf_ptr + 0));
  case_3: /* CIL Label */ 
  {
#line 102
  tmp = (*(get_ptr->get_ushort))(buf_ptr);
  }
#line 102
  return ((unsigned long )tmp);
  case_4: /* CIL Label */ 
  {
#line 104
  tmp___0 = (*(get_ptr->get_ulong))(buf_ptr);
  }
#line 104
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 106
  return (0xffffffffffffffffUL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
static size_t read_ulong_values(struct minitiff_get_struct *get_ptr , int tag_type ,
                                unsigned long *values , size_t count , FILE *fp ) 
{ 
  unsigned char buf___1[4] ;
  size_t value_size ;
  size_t i ;
  size_t tmp ;

  {
#line 118
  if (tag_type == 1) {
#line 119
    value_size = (size_t )1;
  } else
#line 120
  if (tag_type == 3) {
#line 121
    value_size = (size_t )2;
  } else
#line 122
  if (tag_type == 4) {
#line 123
    value_size = (size_t )4;
  } else {
#line 125
    return ((size_t )0);
  }
#line 127
  i = (size_t )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < count)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp = fread((void */* __restrict  */)(buf___1), value_size, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 129
    if (tmp != 1UL) {
#line 130
      goto while_break;
    }
    {
#line 131
    *(values + i) = get_ulong_value(get_ptr, tag_type, (unsigned char const   *)(buf___1));
#line 127
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (i);
}
}
#line 141 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
void minitiff_read_info(struct minitiff_info *tiff_ptr , FILE *fp ) 
{ 
  struct minitiff_get_struct getter ;
  unsigned char buf___1[12] ;
  unsigned char *vbuf ;
  long dir_offset ;
  unsigned int dir_size ;
  unsigned int i ;
  unsigned int tag_id ;
  unsigned int tag_type ;
  size_t count ;
  size_t bits_per_sample_count ;
  unsigned int bits_per_sample_tag_type ;
  unsigned int strip_offsets_tag_type ;
  long bits_per_sample_offset ;
  long strip_offsets_offset ;
  int unknown_tag_found ;
  int unknown_metadata_found ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  void *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  unsigned long tmp___20 ;
  size_t tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long values[4] ;
  int tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;

  {
  {
#line 146
  vbuf = buf___1 + 8;
#line 157
  tmp = fread((void */* __restrict  */)(buf___1), (size_t )8, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 157
  if (tmp != 1UL) {
#line 158
    goto err_read;
  }
  {
#line 159
  tmp___1 = memcmp((void const   *)(buf___1), (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 159
  if (tmp___1 == 0) {
#line 161
    tiff_ptr->byte_order = 'M';
#line 162
    getter.get_ushort = & get_ushort_m;
#line 163
    getter.get_ulong = & get_ulong_m;
  } else {
    {
#line 165
    tmp___0 = memcmp((void const   *)(buf___1), (void const   *)(minitiff_sig_i),
                     (size_t )4);
    }
#line 165
    if (tmp___0 == 0) {
#line 167
      tiff_ptr->byte_order = 'I';
#line 168
      getter.get_ushort = & get_ushort_i;
#line 169
      getter.get_ulong = & get_ulong_i;
    } else {
      {
#line 173
      minitiff_error(tiff_ptr, tiff_err_notiff);
      }
#line 174
      return;
    }
  }
  {
#line 176
  bits_per_sample_count = (size_t )0;
#line 177
  strip_offsets_tag_type = 0U;
#line 177
  bits_per_sample_tag_type = strip_offsets_tag_type;
#line 178
  strip_offsets_offset = 0L;
#line 178
  bits_per_sample_offset = strip_offsets_offset;
#line 179
  tmp___2 = (*(getter.get_ulong))((unsigned char const   *)(buf___1 + 4));
#line 179
  dir_offset = (long )tmp___2;
  }
#line 180
  if (dir_offset < 8L) {
#line 181
    goto err_invalid;
  }
  {
#line 182
  tmp___3 = fseek(fp, dir_offset, 0);
  }
#line 182
  if (tmp___3 != 0) {
#line 183
    goto err_read;
  }
  {
#line 186
  tmp___4 = fread((void */* __restrict  */)(buf___1), (size_t )2, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 186
  if (tmp___4 != 1UL) {
#line 187
    goto err_read;
  }
  {
#line 188
  dir_size = (*(getter.get_ushort))((unsigned char const   *)(buf___1));
#line 189
  unknown_metadata_found = 0;
#line 189
  unknown_tag_found = unknown_metadata_found;
#line 190
  i = 0U;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < dir_size)) {
#line 190
      goto while_break;
    }
    {
#line 192
    tmp___5 = fread((void */* __restrict  */)(buf___1), (size_t )12, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 192
    if (tmp___5 != 1UL) {
#line 193
      goto err_read;
    }
    {
#line 194
    tag_id = (*(getter.get_ushort))((unsigned char const   *)(buf___1));
#line 195
    tag_type = (*(getter.get_ushort))((unsigned char const   *)(buf___1 + 2));
#line 196
    tmp___6 = (*(getter.get_ulong))((unsigned char const   *)(buf___1 + 4));
#line 196
    count = tmp___6;
    }
#line 197
    if (count == 0UL) {
#line 198
      goto err_unsupported;
    }
    {
#line 201
    if (tag_id == 254U) {
#line 201
      goto case_254;
    }
#line 206
    if (tag_id == 256U) {
#line 206
      goto case_256;
    }
#line 211
    if (tag_id == 257U) {
#line 211
      goto case_257;
    }
#line 216
    if (tag_id == 258U) {
#line 216
      goto case_258;
    }
#line 227
    if (tag_id == 259U) {
#line 227
      goto case_259;
    }
#line 233
    if (tag_id == 262U) {
#line 233
      goto case_262;
    }
#line 239
    if (tag_id == 273U) {
#line 239
      goto case_273;
    }
#line 257
    if (tag_id == 274U) {
#line 257
      goto case_274;
    }
#line 262
    if (tag_id == 277U) {
#line 262
      goto case_277;
    }
#line 268
    if (tag_id == 278U) {
#line 268
      goto case_278;
    }
#line 274
    if (tag_id == 279U) {
#line 274
      goto case_279;
    }
#line 278
    if (tag_id == 317U) {
#line 278
      goto case_317;
    }
#line 278
    if (tag_id == 284U) {
#line 278
      goto case_317;
    }
#line 298
    if (tag_id == 316U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 315U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 306U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 305U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 297U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 285U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 296U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 287U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 286U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 283U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 282U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 281U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 280U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 272U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 271U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 270U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 269U) {
#line 298
      goto case_316;
    }
#line 306
    if (tag_id == 50341U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 40965U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 34853U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 34665U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 33723U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 700U) {
#line 306
      goto case_50341;
    }
#line 313
    goto switch_default;
    case_254: /* CIL Label */ 
#line 202
    if (count != 1UL) {
#line 204
      goto err_unsupported;
    } else {
      {
#line 202
      tmp___7 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 202
      if ((tmp___7 & 0xfffffffffffffffdUL) != 0UL) {
#line 204
        goto err_unsupported;
      }
    }
#line 205
    goto switch_break;
    case_256: /* CIL Label */ 
#line 207
    if (count != 1UL) {
#line 208
      goto err_unsupported;
    }
    {
#line 209
    tmp___8 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 209
    tiff_ptr->width = tmp___8;
    }
#line 210
    goto switch_break;
    case_257: /* CIL Label */ 
#line 212
    if (count != 1UL) {
#line 213
      goto err_unsupported;
    }
    {
#line 214
    tmp___9 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 214
    tiff_ptr->height = tmp___9;
    }
#line 215
    goto switch_break;
    case_258: /* CIL Label */ 
#line 217
    if (count == 1UL) {
      {
#line 218
      tmp___10 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 218
      tiff_ptr->bits_per_sample = (unsigned int )tmp___10;
      }
    } else {
      {
#line 222
      bits_per_sample_count = count;
#line 223
      bits_per_sample_tag_type = tag_type;
#line 224
      tmp___11 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 224
      bits_per_sample_offset = (long )tmp___11;
      }
    }
#line 226
    goto switch_break;
    case_259: /* CIL Label */ 
#line 228
    if (count == 1UL) {
      {
#line 228
      tmp___12 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 228
      if (tmp___12 == 1UL) {
#line 229
        tiff_ptr->compression = 1U;
      } else {
        {
#line 231
        minitiff_error(tiff_ptr, tiff_err_compr);
        }
      }
    } else {
      {
#line 231
      minitiff_error(tiff_ptr, tiff_err_compr);
      }
    }
#line 232
    goto switch_break;
    case_262: /* CIL Label */ 
#line 234
    if (count != 1UL) {
#line 235
      goto err_unsupported;
    }
    {
#line 236
    tmp___13 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 236
    tiff_ptr->photometric = (unsigned int )tmp___13;
    }
#line 238
    goto switch_break;
    case_273: /* CIL Label */ 
#line 240
    tiff_ptr->strip_offsets_count = count;
#line 241
    if (count == 1UL) {
#line 243
      if ((unsigned long )tiff_ptr->strip_offsets != (unsigned long )((void *)0)) {
#line 244
        goto err_invalid;
      }
      {
#line 245
      tmp___14 = malloc(sizeof(long ));
#line 245
      tiff_ptr->strip_offsets = (long *)tmp___14;
      }
#line 246
      if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
#line 247
        goto err_memory;
      }
      {
#line 248
      tmp___15 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 248
      *(tiff_ptr->strip_offsets + 0) = (long )tmp___15;
      }
    } else {
      {
#line 253
      strip_offsets_tag_type = tag_type;
#line 254
      tmp___16 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 254
      strip_offsets_offset = (long )tmp___16;
      }
    }
#line 256
    goto switch_break;
    case_274: /* CIL Label */ 
#line 258
    if (count != 1UL) {
      {
#line 259
      minitiff_warning(tiff_ptr, "Non-default TIFF image orientation");
      }
    } else {
      {
#line 258
      tmp___17 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 258
      if (tmp___17 != 1UL) {
        {
#line 259
        minitiff_warning(tiff_ptr, "Non-default TIFF image orientation");
        }
      }
    }
#line 261
    goto switch_break;
    case_277: /* CIL Label */ 
#line 263
    if (count != 1UL) {
#line 264
      goto err_unsupported;
    }
    {
#line 265
    tmp___18 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 265
    tiff_ptr->samples_per_pixel = (unsigned int )tmp___18;
    }
#line 267
    goto switch_break;
    case_278: /* CIL Label */ 
#line 269
    if (count != 1UL) {
#line 270
      goto err_unsupported;
    }
    {
#line 271
    tmp___19 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 271
    tiff_ptr->rows_per_strip = (unsigned int )tmp___19;
    }
#line 273
    goto switch_break;
    case_279: /* CIL Label */ 
#line 276
    goto switch_break;
    case_317: /* CIL Label */ 
    case_284: /* CIL Label */ 
#line 279
    if (count != 1UL) {
#line 280
      goto err_unsupported;
    } else {
      {
#line 279
      tmp___20 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 279
      if (tmp___20 != 1UL) {
#line 280
        goto err_unsupported;
      }
    }
#line 281
    goto switch_break;
    case_316: /* CIL Label */ 
    case_315: /* CIL Label */ 
    case_306: /* CIL Label */ 
    case_305: /* CIL Label */ 
    case_297: /* CIL Label */ 
    case_285: /* CIL Label */ 
    case_296: /* CIL Label */ 
    case_287: /* CIL Label */ 
    case_286: /* CIL Label */ 
    case_283: /* CIL Label */ 
    case_282: /* CIL Label */ 
    case_281: /* CIL Label */ 
    case_280: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 300
    goto switch_break;
    case_50341: /* CIL Label */ 
    case_40965: /* CIL Label */ 
    case_34853: /* CIL Label */ 
    case_34665: /* CIL Label */ 
    case_33723: /* CIL Label */ 
    case_700: /* CIL Label */ 
#line 307
    if (! unknown_metadata_found) {
      {
#line 309
      unknown_metadata_found = 1;
#line 310
      minitiff_warning(tiff_ptr, tiff_warn_metadata);
      }
    }
#line 312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 314
    if (! unknown_tag_found) {
      {
#line 316
      unknown_tag_found = 1;
#line 317
      minitiff_warning(tiff_ptr, tiff_warn_tag);
      }
    }
#line 319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  tmp___21 = fread((void */* __restrict  */)(buf___1), (size_t )4, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 324
  if (tmp___21 != 1UL) {
#line 325
    goto err_read;
  }
  {
#line 326
  tmp___22 = (*(getter.get_ulong))((unsigned char const   *)(buf___1));
  }
#line 326
  if (tmp___22 != 0UL) {
    {
#line 327
    minitiff_warning(tiff_ptr, tiff_warn_multiple);
    }
  }
#line 330
  if (bits_per_sample_offset != 0L) {
#line 333
    count = bits_per_sample_count;
#line 334
    if (count != (size_t )tiff_ptr->samples_per_pixel) {
#line 335
      goto err_invalid;
    }
#line 336
    if (count > 4UL) {
#line 337
      goto err_unsupported;
    }
    {
#line 338
    tmp___23 = fseek(fp, bits_per_sample_offset, 0);
    }
#line 338
    if (tmp___23 != 0) {
#line 339
      goto err_read;
    }
    {
#line 340
    tmp___24 = read_ulong_values(& getter, (int )bits_per_sample_tag_type, values,
                                 count, fp);
    }
#line 340
    if (tmp___24 != count) {
#line 342
      goto err_read;
    }
    {
#line 343
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 343
      count --;
#line 343
      if (! (count > 0UL)) {
#line 343
        goto while_break___0;
      }
#line 344
      if (values[0] != values[count]) {
#line 345
        goto err_unsupported;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    tiff_ptr->bits_per_sample = (unsigned int )values[0];
  }
#line 348
  if (strip_offsets_offset != 0L) {
#line 350
    count = tiff_ptr->strip_offsets_count;
#line 351
    if (count == 0UL) {
#line 352
      goto err_invalid;
    } else
#line 351
    if (count > tiff_ptr->height) {
#line 352
      goto err_invalid;
    }
    {
#line 353
    tmp___25 = malloc(count * sizeof(long ));
#line 353
    tiff_ptr->strip_offsets = (long *)tmp___25;
    }
#line 354
    if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
#line 355
      goto err_memory;
    }
    {
#line 356
    tmp___26 = fseek(fp, strip_offsets_offset, 0);
    }
#line 356
    if (tmp___26 != 0) {
#line 357
      goto err_read;
    }
    {
#line 358
    tmp___27 = read_ulong_values(& getter, (int )strip_offsets_tag_type, (unsigned long *)tiff_ptr->strip_offsets,
                                 count, fp);
    }
#line 358
    if (tmp___27 != count) {
#line 360
      goto err_read;
    }
  }
#line 364
  return;
  err_read: 
  {
#line 368
  minitiff_error(tiff_ptr, tiff_err_read);
  }
  err_invalid: 
  {
#line 370
  minitiff_error(tiff_ptr, tiff_err_invalid);
  }
  err_unsupported: 
  {
#line 372
  minitiff_error(tiff_ptr, tiff_err_unsupported);
  }
  err_memory: 
  {
#line 374
  minitiff_error(tiff_ptr, tiff_err_memory);
  }
#line 375
  return;
}
}
#line 381 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/tiffread.c"
void minitiff_read_row(struct minitiff_info *tiff_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *fp ) 
{ 
  size_t row_size ;
  size_t strip_index ;
  unsigned int bytes_per_sample ;
  unsigned int sample_max ;
  long offset ;
  size_t i ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;

  {
#line 393
  bytes_per_sample = (tiff_ptr->bits_per_sample + 7U) / 8U;
#line 394
  row_size = (tiff_ptr->width * (size_t )tiff_ptr->samples_per_pixel) * (size_t )bytes_per_sample;
#line 400
  strip_index = row_index / (size_t )tiff_ptr->rows_per_strip;
#line 401
  if (strip_index >= tiff_ptr->strip_offsets_count) {
#line 402
    goto err_invalid;
  }
#line 403
  offset = (long )((size_t )*(tiff_ptr->strip_offsets + strip_index) + row_size * (row_index % (unsigned long )tiff_ptr->rows_per_strip));
#line 405
  if (offset <= 0L) {
#line 406
    goto err_invalid;
  }
  {
#line 407
  tmp___0 = ftell(fp);
  }
#line 407
  if (tmp___0 != offset) {
    {
#line 408
    tmp = fseek(fp, offset, 0);
    }
#line 408
    if (tmp != 0) {
#line 409
      goto err_read;
    }
  }
  {
#line 412
  tmp___1 = fread((void */* __restrict  */)row_ptr, row_size, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 412
  if (tmp___1 != 1UL) {
#line 413
    goto err_read;
  }
#line 414
  if (tiff_ptr->photometric == 0U) {
#line 416
    if (bytes_per_sample > 1U) {
#line 417
      goto err_unsupported;
    }
#line 418
    sample_max = (unsigned int )((1 << tiff_ptr->bits_per_sample) - 1);
#line 419
    i = (size_t )0;
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 419
      if (! (i < row_size)) {
#line 419
        goto while_break;
      }
#line 420
      *(row_ptr + i) = (unsigned char )(sample_max - (unsigned int )*(row_ptr + i));
#line 419
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 424
  return;
  err_read: 
  {
#line 428
  minitiff_error(tiff_ptr, tiff_err_read);
  }
  err_invalid: 
  {
#line 430
  minitiff_error(tiff_ptr, tiff_err_invalid);
  }
  err_unsupported: 
  {
#line 432
  minitiff_error(tiff_ptr, tiff_err_unsupported);
  }
#line 433
  return;
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmio.h"
void (*pnm_error)(pnm_struct *pnm_ptr , char const   *msg ) ;
#line 77
void pnm_write_header(FILE *fp , pnm_struct *pnm_ptr ) ;
#line 78
void pnm_write_row(FILE *fp , pnm_struct *pnm_ptr , unsigned int *row_ptr ) ;
#line 17 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmwrite.c"
static char const   *pnm_err_param  =    "invalid parameter(s)";
#line 18 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmwrite.c"
static char const   *pnm_err_write  =    "write error";
#line 31 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmwrite.c"
void pnm_write_header(FILE *fp , pnm_struct *pnm_ptr ) 
{ 


  {
#line 34
  if ((unsigned long )pnm_ptr == (unsigned long )((void *)0)) {
    {
#line 35
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  } else
#line 34
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 35
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  }
#line 36
  if (pnm_ptr->type_code < 1U) {
    {
#line 37
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  } else
#line 36
  if (pnm_ptr->type_code > 6U) {
    {
#line 37
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  }
#line 38
  if (pnm_ptr->width <= 0U) {
    {
#line 40
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  } else
#line 38
  if (pnm_ptr->height <= 0U) {
    {
#line 40
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  } else
#line 38
  if (pnm_ptr->maxval <= 0U) {
    {
#line 40
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  } else
#line 38
  if (pnm_ptr->maxval > 65535U) {
    {
#line 40
    (*pnm_error)(pnm_ptr, pnm_err_param);
    }
  }
  {
#line 43
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"P%c\n%d %d\n",
          pnm_ptr->type_code + 48U, pnm_ptr->width, pnm_ptr->height);
  }
#line 45
  if (pnm_ptr->type_code % 3U != 1U) {
    {
#line 46
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n",
            pnm_ptr->maxval);
    }
  }
#line 47
  return;
}
}
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmwrite.c"
void pnm_write_row(FILE *fp , pnm_struct *pnm_ptr , unsigned int *row_ptr ) 
{ 
  unsigned int type_code ;
  unsigned int sample_count ;
  int tmp ;
  unsigned int row_size ;
  unsigned int i ;
  int is_raw ;
  int j ;
  char ch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 55
  type_code = pnm_ptr->type_code;
#line 56
  if (type_code % 3U == 0U) {
#line 56
    tmp = 3;
  } else {
#line 56
    tmp = 1;
  }
#line 56
  sample_count = (unsigned int )tmp;
#line 57
  row_size = sample_count * pnm_ptr->width;
#line 59
  is_raw = type_code >= 4U;
#line 64
  if (type_code % 3U == 1U) {
#line 66
    if (is_raw) {
#line 68
      i = 0U;
      {
#line 68
      while (1) {
        while_continue: /* CIL Label */ ;
#line 68
        if (! (i < row_size)) {
#line 68
          goto while_break;
        }
#line 70
        ch = (char)0;
#line 71
        j = 7;
        {
#line 71
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 71
          if (j >= 0) {
#line 71
            if (! (i < row_size)) {
#line 71
              goto while_break___0;
            }
          } else {
#line 71
            goto while_break___0;
          }
#line 72
          if ((*(row_ptr + i) & 1U) == 0U) {
#line 73
            ch = (char )((int )ch | (int )((char )(1 << j)));
          }
#line 71
          j --;
#line 71
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 74
        tmp___0 = _IO_putc((int )ch, fp);
        }
#line 74
        if (tmp___0 == -1) {
          {
#line 75
          (*pnm_error)(pnm_ptr, pnm_err_write);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 80
      i = 0U;
      {
#line 80
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 80
        if (! (i < row_size)) {
#line 80
          goto while_break___1;
        }
#line 81
        if (*(row_ptr + i) & 1U) {
#line 81
          tmp___1 = '0';
        } else {
#line 81
          tmp___1 = '1';
        }
        {
#line 81
        tmp___2 = _IO_putc((int )((char )tmp___1), fp);
        }
#line 81
        if (tmp___2 == -1) {
          {
#line 82
          (*pnm_error)(pnm_ptr, pnm_err_write);
          }
        }
#line 80
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 83
      tmp___3 = _IO_putc('\n', fp);
      }
#line 83
      if (tmp___3 == -1) {
        {
#line 84
        (*pnm_error)(pnm_ptr, pnm_err_write);
        }
      }
    }
  } else
#line 89
  if (is_raw) {
#line 91
    if (pnm_ptr->maxval <= 255U) {
#line 93
      i = 0U;
      {
#line 93
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 93
        if (! (i < row_size)) {
#line 93
          goto while_break___2;
        }
        {
#line 94
        tmp___4 = _IO_putc((int )((char )*(row_ptr + i)), fp);
        }
#line 94
        if (tmp___4 == -1) {
          {
#line 95
          (*pnm_error)(pnm_ptr, pnm_err_write);
          }
        }
#line 93
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 99
      i = 0U;
      {
#line 99
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 99
        if (! (i < row_size)) {
#line 99
          goto while_break___3;
        }
        {
#line 100
        tmp___5 = _IO_putc((int )((char )(*(row_ptr + i) >> 8)), fp);
        }
#line 100
        if (tmp___5 == -1) {
          {
#line 102
          (*pnm_error)(pnm_ptr, pnm_err_write);
          }
        } else {
          {
#line 100
          tmp___6 = _IO_putc((int )((char )*(row_ptr + i)), fp);
          }
#line 100
          if (tmp___6 == -1) {
            {
#line 102
            (*pnm_error)(pnm_ptr, pnm_err_write);
            }
          }
        }
#line 99
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 107
    tmp___7 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%u",
                      *(row_ptr + 0));
    }
#line 107
    if (tmp___7 == -1) {
      {
#line 108
      (*pnm_error)(pnm_ptr, pnm_err_write);
      }
    }
#line 109
    i = 1U;
    {
#line 109
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 109
      if (! (i < row_size)) {
#line 109
        goto while_break___4;
      }
      {
#line 110
      tmp___8 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %u",
                        *(row_ptr + i));
      }
#line 110
      if (tmp___8 == -1) {
        {
#line 111
        (*pnm_error)(pnm_ptr, pnm_err_write);
        }
      }
#line 109
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 112
    tmp___9 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
    }
#line 112
    if (tmp___9 == -1) {
      {
#line 113
      (*pnm_error)(pnm_ptr, pnm_err_write);
      }
    }
  }
#line 116
  return;
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 639 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 69 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmio.h"
void pnm_read_header(FILE *fp , pnm_struct *pnm_ptr ) ;
#line 70
void pnm_read_row(FILE *fp , pnm_struct *pnm_ptr , unsigned int *row_ptr ) ;
#line 17 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static char const   *pnm_err_param___0  =    "Invalid parameter(s)";
#line 18 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static char const   *pnm_err_read  =    "Error reading PNM data";
#line 19 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static char const   *pnm_err_notpnm  =    "Not a PNM file";
#line 20 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static char const   *pnm_err_badpnm  =    "Invalid PNM file";
#line 42 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static int pnm_getchar(FILE *fp ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 44
  tmp = _IO_getc(fp);
#line 44
  ch = tmp;
  }
#line 47
  if (ch == 35) {
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 50
      ch = _IO_getc(fp);
      }
#line 49
      if (ch != -1) {
#line 49
        if (ch != 10) {
#line 49
          if (! (ch != 13)) {
#line 49
            goto while_break;
          }
        } else {
#line 49
          goto while_break;
        }
      } else {
#line 49
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 55
  if (ch == 13) {
    {
#line 57
    ch = _IO_getc(fp);
    }
#line 58
    if (ch != -1) {
#line 58
      if (ch != 10) {
        {
#line 60
        ungetc(ch, fp);
#line 61
        ch = '\n';
        }
      }
    }
  }
#line 65
  return (ch);
}
}
#line 72 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
static int pnm_getint(FILE *fp ) 
{ 
  int result ;
  int ch ;

  {
#line 74
  result = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    ch = pnm_getchar(fp);
    }
#line 81
    if (ch == -1) {
#line 82
      return (-1);
    }
#line 78
    if (! (ch == 32)) {
#line 78
      if (! (ch == 9)) {
#line 78
        if (! (ch == 10)) {
#line 78
          if (! (ch == 13)) {
#line 78
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (ch >= 48) {
#line 84
    if (! (ch <= 57)) {
#line 85
      return (-1);
    }
  } else {
#line 85
    return (-1);
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 90
    result = result * 10 + (ch - 48);
#line 91
    ch = pnm_getchar(fp);
    }
#line 88
    if (ch >= 48) {
#line 88
      if (! (ch <= 57)) {
#line 88
        goto while_break___0;
      }
    } else {
#line 88
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  if (ch == -1) {
#line 96
    return (-1);
  } else
#line 97
  if (! (ch == 32)) {
#line 97
    if (! (ch == 9)) {
#line 97
      if (! (ch == 10)) {
#line 97
        if (! (ch == 13)) {
#line 98
          return (-1);
        }
      }
    }
  }
#line 101
  return (result);
}
}
#line 108 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
void pnm_read_header(FILE *fp , pnm_struct *pnm_ptr ) 
{ 
  int ch ;

  {
#line 113
  if ((unsigned long )pnm_ptr == (unsigned long )((void *)0)) {
    {
#line 114
    (*pnm_error)(pnm_ptr, pnm_err_param___0);
    }
  } else
#line 113
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 114
    (*pnm_error)(pnm_ptr, pnm_err_param___0);
    }
  }
  {
#line 117
  ch = _IO_getc(fp);
  }
#line 118
  if (ch != 80) {
    {
#line 119
    (*pnm_error)(pnm_ptr, pnm_err_notpnm);
    }
  }
  {
#line 120
  ch = _IO_getc(fp);
  }
#line 121
  if (ch < 49) {
    {
#line 122
    (*pnm_error)(pnm_ptr, pnm_err_notpnm);
    }
  } else
#line 121
  if (ch > 54) {
    {
#line 122
    (*pnm_error)(pnm_ptr, pnm_err_notpnm);
    }
  }
  {
#line 123
  pnm_ptr->type_code = (unsigned int )(ch - 48);
#line 124
  ch = pnm_getchar(fp);
  }
#line 125
  if (! (ch == 32)) {
#line 125
    if (! (ch == 9)) {
#line 125
      if (! (ch == 10)) {
#line 125
        if (! (ch == 13)) {
          {
#line 126
          (*pnm_error)(pnm_ptr, pnm_err_notpnm);
          }
        }
      }
    }
  }
  {
#line 129
  ch = pnm_getint(fp);
  }
#line 129
  if (ch <= 0) {
    {
#line 130
    (*pnm_error)(pnm_ptr, pnm_err_badpnm);
    }
  }
  {
#line 131
  pnm_ptr->width = (unsigned int )ch;
#line 132
  ch = pnm_getint(fp);
  }
#line 132
  if (ch <= 0) {
    {
#line 133
    (*pnm_error)(pnm_ptr, pnm_err_badpnm);
    }
  }
#line 134
  pnm_ptr->height = (unsigned int )ch;
#line 135
  if (pnm_ptr->type_code % 3U == 1U) {
#line 136
    pnm_ptr->maxval = 1U;
  } else {
    {
#line 139
    ch = pnm_getint(fp);
    }
#line 139
    if (ch <= 0) {
      {
#line 140
      (*pnm_error)(pnm_ptr, pnm_err_badpnm);
      }
    }
#line 141
    pnm_ptr->maxval = (unsigned int )ch;
  }
#line 143
  if (pnm_ptr->maxval > 65535U) {
    {
#line 144
    (*pnm_error)(pnm_ptr, pnm_err_badpnm);
    }
  }
#line 145
  return;
}
}
#line 151 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmread.c"
void pnm_read_row(FILE *fp , pnm_struct *pnm_ptr , unsigned int *row_ptr ) 
{ 
  unsigned int type_code ;
  unsigned int sample_count ;
  int tmp ;
  unsigned int row_size ;
  unsigned int i ;
  int is_raw ;
  int ch ;
  int j ;
  unsigned int uch ;
  int tmp___0 ;

  {
#line 153
  type_code = pnm_ptr->type_code;
#line 154
  if (type_code % 3U == 0U) {
#line 154
    tmp = 3;
  } else {
#line 154
    tmp = 1;
  }
#line 154
  sample_count = (unsigned int )tmp;
#line 155
  row_size = sample_count * pnm_ptr->width;
#line 157
  is_raw = type_code >= 4U;
#line 162
  if (type_code % 3U == 1U) {
#line 164
    if (is_raw) {
#line 166
      i = 0U;
      {
#line 166
      while (1) {
        while_continue: /* CIL Label */ ;
#line 166
        if (! (i < row_size)) {
#line 166
          goto while_break;
        }
        {
#line 168
        ch = _IO_getc(fp);
        }
#line 169
        if (ch == -1) {
          {
#line 170
          (*pnm_error)(pnm_ptr, pnm_err_read);
          }
        }
#line 171
        j = 7;
        {
#line 171
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 171
          if (j >= 0) {
#line 171
            if (! (i < row_size)) {
#line 171
              goto while_break___0;
            }
          } else {
#line 171
            goto while_break___0;
          }
#line 172
          *(row_ptr + i) = (unsigned int )(1 - ((ch >> j) & 1));
#line 171
          j --;
#line 171
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 177
      i = 0U;
      {
#line 177
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 177
        if (! (i < row_size)) {
#line 177
          goto while_break___1;
        }
        {
#line 179
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 181
          ch = pnm_getchar(fp);
          }
#line 182
          if (ch == -1) {
            {
#line 183
            (*pnm_error)(pnm_ptr, pnm_err_read);
            }
          }
#line 179
          if (! (ch == 32)) {
#line 179
            if (! (ch == 9)) {
#line 179
              if (! (ch == 10)) {
#line 179
                if (! (ch == 13)) {
#line 179
                  goto while_break___2;
                }
              }
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 185
        if (ch != 48) {
#line 185
          if (ch != 49) {
            {
#line 186
            (*pnm_error)(pnm_ptr, pnm_err_badpnm);
            }
          }
        }
#line 187
        if (ch == 48) {
#line 187
          *(row_ptr + i) = 1U;
        } else {
#line 187
          *(row_ptr + i) = 0U;
        }
#line 177
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else
#line 193
  if (is_raw) {
#line 195
    if (pnm_ptr->maxval <= 255U) {
#line 197
      i = 0U;
      {
#line 197
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 197
        if (! (i < row_size)) {
#line 197
          goto while_break___3;
        }
        {
#line 199
        ch = _IO_getc(fp);
        }
#line 200
        if (ch == -1) {
          {
#line 201
          (*pnm_error)(pnm_ptr, pnm_err_read);
          }
        }
#line 202
        *(row_ptr + i) = (unsigned int )ch;
#line 197
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 207
      i = 0U;
      {
#line 207
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 207
        if (! (i < row_size)) {
#line 207
          goto while_break___4;
        }
        {
#line 209
        tmp___0 = _IO_getc(fp);
#line 209
        uch = (unsigned int )tmp___0;
#line 210
        ch = _IO_getc(fp);
        }
#line 211
        if (ch == -1) {
          {
#line 212
          (*pnm_error)(pnm_ptr, pnm_err_read);
          }
        }
#line 213
        *(row_ptr + i) = (uch << 8) + (unsigned int )ch;
#line 207
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  } else {
#line 219
    i = 0U;
    {
#line 219
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 219
      if (! (i < row_size)) {
#line 219
        goto while_break___5;
      }
      {
#line 221
      ch = pnm_getint(fp);
      }
#line 221
      if (ch < 0) {
        {
#line 222
        (*pnm_error)(pnm_ptr, pnm_err_badpnm);
        }
      }
#line 223
      *(row_ptr + i) = (unsigned int )ch;
#line 219
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 227
  return;
}
}
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 63 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmio.h"
void (*pnm_warning)(pnm_struct *pnm_ptr , char const   *msg ) ;
#line 18 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmerror.c"
void pnm_default_error(pnm_struct *pnm_ptr , char const   *msg___0 ) 
{ 


  {
#line 20
  if (& pnm_ptr) {
    {
#line 21
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg___0);
    }
  }
  {
#line 22
  exit(1);
  }
}
}
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmerror.c"
void pnm_default_warning(pnm_struct *pnm_ptr , char const   *msg___0 ) 
{ 


  {
#line 27
  if (& pnm_ptr) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg___0);
    }
  }
#line 29
  return;
}
}
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmerror.c"
void (*pnm_error)(pnm_struct *pnm_ptr , char const   *msg )  =    & pnm_default_error;
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pnm/pnmerror.c"
void (*pnm_warning)(pnm_struct *pnm_ptr , char const   *msg )  =    & pnm_default_warning;
#line 66 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxtern.h"
int pngx_sig_is_tiff(png_bytep sig , png_size_t len ) ;
#line 68
png_charp pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 73
png_voidp pngx_zmalloc(png_structp png_ptr , png_uint_32 size ) ;
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.h"
void minitiff_init_info(struct minitiff_info *minitiff_ptr ) ;
#line 62
void minitiff_validate_info(struct minitiff_info *tiff_ptr ) ;
#line 63
void minitiff_destroy_info(struct minitiff_info *minitiff_ptr ) ;
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrtif.c"
static png_structp pngx_err_ptr  =    (png_structp )((void *)0);
#line 13 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrtif.c"
static void pngx_tiff_error(char const   *msg___0 ) 
{ 


  {
  {
#line 15
  png_error(pngx_err_ptr, msg___0);
  }
#line 16
  return;
}
}
#line 19 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrtif.c"
static void pngx_tiff_warning(char const   *msg___0 ) 
{ 


  {
  {
#line 21
  png_warning(pngx_err_ptr, msg___0);
  }
#line 22
  return;
}
}
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrtif.c"
int pngx_sig_is_tiff(png_bytep sig , png_size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 28
  if (len <= 8UL) {
#line 29
    return (-1);
  }
  {
#line 30
  tmp = memcmp((void const   *)sig, (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 30
  if (tmp == 0) {
#line 30
    tmp___1 = 1;
  } else {
    {
#line 30
    tmp___0 = memcmp((void const   *)sig, (void const   *)(minitiff_sig_i), (size_t )4);
    }
#line 30
    if (tmp___0 == 0) {
#line 30
      tmp___1 = 1;
    } else {
#line 30
      tmp___1 = 0;
    }
  }
#line 30
  return (tmp___1);
}
}
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrtif.c"
png_charp pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  struct minitiff_info tiff_info ;
  unsigned int width ;
  unsigned int height ;
  unsigned int pixel_size ;
  unsigned int sample_depth ;
  unsigned int sample_max ;
  int color_type ;
  int sample_overflow ;
  png_uint_32 rowbytes ;
  png_bytepp row_pointers ;
  png_bytep row ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int tmp ;
  png_voidp tmp___0 ;
  png_voidp tmp___1 ;
  unsigned int b ;
  png_byte b___0 ;
  unsigned int b___1 ;

  {
  {
#line 47
  pngx_err_ptr = png_ptr;
#line 48
  minitiff_init_info(& tiff_info);
#line 49
  tiff_info.error_handler = & pngx_tiff_error;
#line 50
  tiff_info.warning_handler = & pngx_tiff_warning;
#line 51
  minitiff_read_info(& tiff_info, fp);
#line 52
  minitiff_validate_info(& tiff_info);
#line 54
  width = (unsigned int )tiff_info.width;
#line 55
  height = (unsigned int )tiff_info.height;
#line 56
  pixel_size = tiff_info.samples_per_pixel;
#line 57
  sample_depth = tiff_info.bits_per_sample;
  }
  {
#line 60
  if (pixel_size == 1U) {
#line 60
    goto case_1;
  }
#line 63
  if (pixel_size == 2U) {
#line 63
    goto case_2;
  }
#line 66
  if (pixel_size == 3U) {
#line 66
    goto case_3;
  }
#line 69
  if (pixel_size == 4U) {
#line 69
    goto case_4;
  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ 
#line 61
  color_type = 0;
#line 62
  goto switch_break;
  case_2: /* CIL Label */ 
#line 64
  color_type = 4;
#line 65
  goto switch_break;
  case_3: /* CIL Label */ 
#line 67
  color_type = 2;
#line 68
  goto switch_break;
  case_4: /* CIL Label */ 
#line 70
  color_type = 6;
#line 71
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 73
  png_error(png_ptr, "Unsupported TIFF color space");
  }
#line 74
  return ((png_charp )((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (sample_depth > 16U) {
    {
#line 77
    png_error(png_ptr, "Unsupported TIFF sample depth");
    }
  }
#line 78
  sample_max = (unsigned int )((1 << sample_depth) - 1);
#line 79
  sample_overflow = 0;
#line 81
  if (sample_depth <= 8U) {
#line 81
    tmp = 8;
  } else {
#line 81
    tmp = 16;
  }
  {
#line 81
  png_set_IHDR(png_ptr, info_ptr, (png_uint_32 )width, (png_uint_32 )height, tmp,
               color_type, 0, 0, 0);
#line 86
  rowbytes = png_get_rowbytes(png_ptr, info_ptr);
#line 87
  tmp___0 = png_malloc(png_ptr, (unsigned long )height * sizeof(png_bytep ));
#line 87
  row_pointers = (png_bytepp )tmp___0;
#line 88
  i = 0U;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < height)) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___1 = pngx_zmalloc(png_ptr, rowbytes);
#line 89
    *(row_pointers + i) = (png_bytep )tmp___1;
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  png_set_rows(png_ptr, info_ptr, row_pointers);
  }
#line 92
  if (sample_depth <= 8U) {
#line 94
    i = 0U;
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 94
      if (! (i < height)) {
#line 94
        goto while_break___0;
      }
      {
#line 96
      row = *(row_pointers + i);
#line 97
      minitiff_read_row(& tiff_info, row, (size_t )i, fp);
      }
#line 98
      if (sample_depth < 8U) {
#line 100
        j = 0U;
        {
#line 100
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 100
          if (! (j < pixel_size * width)) {
#line 100
            goto while_break___1;
          }
#line 102
          b = (unsigned int )*(row + j);
#line 103
          if (b > sample_max) {
#line 105
            b = sample_max;
#line 106
            sample_overflow = 1;
          }
#line 108
          *(row + j) = (png_byte )((b * 255U + sample_max / 2U) / sample_max);
#line 100
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 111
      if (tiff_info.photometric == 0U) {
#line 113
        j = 0U;
        {
#line 113
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 113
          if (! (j < pixel_size * width)) {
#line 113
            goto while_break___2;
          }
#line 114
          *(row + j) = (png_byte )(255 - (int )*(row + j));
#line 113
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 94
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 120
    i = 0U;
    {
#line 120
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 120
      if (! (i < height)) {
#line 120
        goto while_break___3;
      }
      {
#line 122
      row = *(row_pointers + i);
#line 123
      minitiff_read_row(& tiff_info, row, (size_t )i, fp);
      }
#line 124
      if (tiff_info.byte_order == 73) {
#line 127
        k = 0U;
#line 127
        j = k;
        {
#line 127
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 127
          if (! (j < pixel_size * width)) {
#line 127
            goto while_break___4;
          }
#line 129
          b___0 = *(row + k);
#line 130
          *(row + k) = *(row + (k + 1U));
#line 131
          *(row + (k + 1U)) = b___0;
#line 127
          j ++;
#line 127
          k += 2U;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 134
      if (sample_depth < 16U) {
#line 136
        k = 0U;
#line 136
        j = k;
        {
#line 136
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 136
          if (! (k < pixel_size * width)) {
#line 136
            goto while_break___5;
          }
#line 138
          b___1 = (unsigned int )(((int )*(row + k) << 8) + (int )*(row + (k + 1U)));
#line 139
          if (b___1 > sample_max) {
#line 141
            b___1 = sample_max;
#line 142
            sample_overflow = 1;
          }
#line 144
          b___1 = (b___1 * 65535U + sample_max / 2U) / sample_max;
#line 145
          *(row + k) = (png_byte )(b___1 >> 8);
#line 146
          *(row + (k + 1U)) = (png_byte )(b___1 & 255U);
#line 136
          j ++;
#line 136
          k += 2U;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 120
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 152
  if (sample_overflow) {
    {
#line 153
    png_warning(png_ptr, "Overflow in TIFF samples");
    }
  }
  {
#line 155
  minitiff_destroy_info(& tiff_info);
  }
#line 156
  return ((png_charp )"TIFF");
}
}
#line 60 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxtern.h"
int pngx_sig_is_pnm(png_bytep sig , png_size_t len ) ;
#line 62
png_charp pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 11 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrpnm.c"
static png_structp pngx_err_ptr___0  =    (png_structp )((void *)0);
#line 14 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrpnm.c"
static void pngx_pnm_error(pnm_struct *pnm_ptr , char const   *msg___0 ) 
{ 


  {
  {
#line 17
  png_error(pngx_err_ptr___0, msg___0);
  }
#line 18
  if (& pnm_ptr) {
#line 19
    return;
  }
#line 20
  return;
}
}
#line 23 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrpnm.c"
static void pngx_pnm_warning(pnm_struct *pnm_ptr , char const   *msg___0 ) 
{ 


  {
  {
#line 26
  png_warning(pngx_err_ptr___0, msg___0);
  }
#line 27
  if (& pnm_ptr) {
#line 28
    return;
  }
#line 29
  return;
}
}
#line 32 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrpnm.c"
int pngx_sig_is_pnm(png_bytep sig , png_size_t len ) 
{ 
  unsigned short const   **tmp ;

  {
#line 35
  if (len < 8UL) {
#line 36
    return (-1);
  }
#line 37
  if ((int )*(sig + 0) == 80) {
#line 37
    if ((int )*(sig + 1) >= 49) {
#line 37
      if ((int )*(sig + 1) <= 54) {
        {
#line 37
        tmp = __ctype_b_loc();
        }
#line 37
        if ((int const   )*(*tmp + (int )*(sig + 2)) & 8192) {
#line 40
          return (1);
        } else
#line 37
        if ((int )*(sig + 2) == 35) {
#line 40
          return (1);
        }
      }
    }
  }
#line 41
  return (0);
}
}
#line 45 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrpnm.c"
png_charp pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  pnm_struct pnminfo ;
  unsigned int pnmsample_size ;
  int pnmoverflow ;
  unsigned int *pnmrow ;
  png_uint_32 rowbytes ;
  png_bytepp row_pointers ;
  unsigned int sig_bit ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  png_voidp tmp ;
  int tmp___0 ;
  int tmp___1 ;
  png_color_8 sbit ;
  png_voidp tmp___2 ;
  png_voidp tmp___3 ;
  unsigned int b ;
  png_uint_32 b___0 ;

  {
  {
#line 57
  pngx_err_ptr___0 = png_ptr;
#line 58
  pnm_error = & pngx_pnm_error;
#line 59
  pnm_warning = & pngx_pnm_warning;
#line 60
  pnmoverflow = 0;
#line 62
  pnm_read_header(fp, & pnminfo);
  }
#line 64
  if (pnminfo.type_code == 3U) {
#line 65
    pnmsample_size = 3U;
  } else
#line 64
  if (pnminfo.type_code == 6U) {
#line 65
    pnmsample_size = 3U;
  } else {
#line 67
    pnmsample_size = 1U;
  }
#line 68
  if (pnminfo.maxval > 65535U) {
    {
#line 69
    png_error(png_ptr, "Sample depth too big in PNM");
    }
  } else
#line 70
  if (pnminfo.maxval > 255U) {
#line 71
    pnmsample_size *= 2U;
  } else
#line 72
  if (pnminfo.maxval <= 0U) {
    {
#line 73
    png_error(png_ptr, "[internal error] Invalid sample depth in PNM");
    }
  }
  {
#line 75
  tmp = png_malloc(png_ptr, (unsigned long )(pnmsample_size * pnminfo.width) * sizeof(unsigned int ));
#line 75
  pnmrow = (unsigned int *)tmp;
  }
#line 78
  if (pnmsample_size <= 2U) {
#line 78
    tmp___0 = 0;
  } else {
#line 78
    tmp___0 = 2;
  }
#line 78
  if (pnminfo.maxval <= 255U) {
#line 78
    tmp___1 = 8;
  } else {
#line 78
    tmp___1 = 16;
  }
  {
#line 78
  png_set_IHDR(png_ptr, info_ptr, (png_uint_32 )pnminfo.width, (png_uint_32 )pnminfo.height,
               tmp___1, tmp___0, 0, 0, 0);
#line 84
  sig_bit = 16U;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((1U << sig_bit) - 1U > pnminfo.maxval)) {
#line 84
      goto while_break;
    }
#line 84
    sig_bit --;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  if ((1U << sig_bit) - 1U != pnminfo.maxval) {
    {
#line 87
    png_warning(png_ptr, "Possibly inexact sample conversion from PNM to PNG");
    }
  } else
#line 89
  if (sig_bit != 8U) {
#line 89
    if (sig_bit != 16U) {
#line 89
      if (pnmsample_size > 1U) {
#line 89
        goto _L;
      } else
#line 89
      if (8U % sig_bit != 0U) {
        _L: /* CIL Label */ 
        {
#line 93
        sbit.gray = (png_byte )sig_bit;
#line 93
        sbit.blue = sbit.gray;
#line 93
        sbit.green = sbit.blue;
#line 93
        sbit.red = sbit.green;
#line 94
        sbit.alpha = (png_byte )0;
#line 95
        png_set_sBIT(png_ptr, info_ptr, & sbit);
        }
      }
    }
  }
  {
#line 98
  rowbytes = png_get_rowbytes(png_ptr, info_ptr);
#line 99
  tmp___2 = png_malloc(png_ptr, (unsigned long )pnminfo.height * sizeof(png_bytep ));
#line 99
  row_pointers = (png_bytepp )tmp___2;
#line 101
  i = 0U;
  }
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! (i < pnminfo.height)) {
#line 101
      goto while_break___0;
    }
    {
#line 102
    tmp___3 = pngx_zmalloc(png_ptr, rowbytes);
#line 102
    *(row_pointers + i) = (png_bytep )tmp___3;
#line 101
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  png_set_rows(png_ptr, info_ptr, row_pointers);
  }
#line 105
  if (pnminfo.maxval <= 255U) {
#line 107
    i = 0U;
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 107
      if (! (i < pnminfo.height)) {
#line 107
        goto while_break___1;
      }
      {
#line 109
      pnm_read_row(fp, & pnminfo, pnmrow);
      }
#line 110
      if (pnminfo.maxval == 255U) {
#line 112
        j = 0U;
        {
#line 112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 112
          if (! (j < pnmsample_size * pnminfo.width)) {
#line 112
            goto while_break___2;
          }
#line 113
          *(*(row_pointers + i) + j) = (png_byte )*(pnmrow + j);
#line 112
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 117
        j = 0U;
        {
#line 117
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 117
          if (! (j < pnmsample_size * pnminfo.width)) {
#line 117
            goto while_break___3;
          }
#line 119
          b = *(pnmrow + j);
#line 120
          if (b > pnminfo.maxval) {
#line 122
            b = pnminfo.maxval;
#line 123
            pnmoverflow = 1;
          }
#line 125
          *(*(row_pointers + i) + j) = (png_byte )((b * 255U + pnminfo.maxval / 2U) / pnminfo.maxval);
#line 117
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 107
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 133
    i = 0U;
    {
#line 133
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 133
      if (! (i < pnminfo.height)) {
#line 133
        goto while_break___4;
      }
      {
#line 135
      pnm_read_row(fp, & pnminfo, pnmrow);
      }
#line 136
      if (pnminfo.maxval == 65535U) {
#line 138
        k = 0U;
#line 138
        j = k;
        {
#line 138
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 138
          if (! (k < pnmsample_size * pnminfo.width)) {
#line 138
            goto while_break___5;
          }
#line 140
          *(*(row_pointers + i) + k) = (png_byte )(*(pnmrow + j) / 256U);
#line 141
          *(*(row_pointers + i) + (k + 1U)) = (png_byte )(*(pnmrow + j) % 256U);
#line 138
          j ++;
#line 138
          k += 2U;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 146
        k = 0U;
#line 146
        j = k;
        {
#line 146
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 146
          if (! (k < pnmsample_size * pnminfo.width)) {
#line 146
            goto while_break___6;
          }
#line 148
          b___0 = (png_uint_32 )*(pnmrow + j);
#line 149
          if (b___0 > (png_uint_32 )pnminfo.maxval) {
#line 151
            b___0 = (png_uint_32 )pnminfo.maxval;
#line 152
            pnmoverflow = 1;
          }
#line 154
          b___0 = (b___0 * 65535UL + (png_uint_32 )(pnminfo.maxval / 2U)) / (png_uint_32 )pnminfo.maxval;
#line 155
          *(*(row_pointers + i) + k) = (png_byte )(b___0 / 256UL);
#line 156
          *(*(row_pointers + i) + (k + 1U)) = (png_byte )(b___0 % 256UL);
#line 146
          j ++;
#line 146
          k += 2U;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 133
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 162
  free((void *)pnmrow);
  }
#line 164
  if (pnmoverflow) {
    {
#line 165
    png_warning(png_ptr, "Overflow in PNM pixels");
    }
  }
  {
#line 170
  if (pnminfo.type_code == 4U) {
#line 170
    goto case_4;
  }
#line 170
  if (pnminfo.type_code == 1U) {
#line 170
    goto case_4;
  }
#line 173
  if (pnminfo.type_code == 5U) {
#line 173
    goto case_5;
  }
#line 173
  if (pnminfo.type_code == 2U) {
#line 173
    goto case_5;
  }
#line 176
  if (pnminfo.type_code == 6U) {
#line 176
    goto case_6;
  }
#line 176
  if (pnminfo.type_code == 3U) {
#line 176
    goto case_6;
  }
#line 178
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 171
  return ((png_charp )"PBM");
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 174
  return ((png_charp )"PGM");
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 177
  return ((png_charp )"PPM");
  switch_default: /* CIL Label */ 
#line 179
  return ((png_charp )"PNM");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 54 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxtern.h"
int pngx_sig_is_jpeg(png_bytep sig , png_size_t len ) ;
#line 56
png_charp pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 26 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jp2[12]  = 
#line 26 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrjpg.c"
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )12, 
        (png_byte const   )106,      (png_byte const   )80,      (png_byte const   )32,      (png_byte const   )32, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )135,      (png_byte const   )10};
#line 29 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jpc[4]  = {      (png_byte const   )255,      (png_byte const   )79,      (png_byte const   )255,      (png_byte const   )81};
#line 33 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrjpg.c"
int pngx_sig_is_jpeg(png_bytep sig , png_size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 36
  if (len < 12UL) {
#line 37
    return (-1);
  }
#line 38
  if ((int )*(sig + 0) == 255) {
#line 38
    if ((int )*(sig + 1) == 216) {
#line 38
      if ((int )*(sig + 2) == 255) {
#line 38
        if ((int )*(sig + 3) >= 224) {
#line 38
          if ((int )*(sig + 3) <= 253) {
#line 40
            return (1);
          }
        }
      }
    }
  }
  {
#line 41
  tmp = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jp2), (size_t )12);
  }
#line 41
  if (tmp == 0) {
#line 42
    return (2);
  }
  {
#line 43
  tmp___0 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jpc), (size_t )4);
  }
#line 43
  if (tmp___0 == 0) {
#line 44
    return (2);
  }
#line 45
  return (0);
}
}
#line 49 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrjpg.c"
png_charp pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  png_byte buf___1[12] ;
  int sig_code ;
  size_t tmp ;

  {
  {
#line 55
  tmp = fread((void */* __restrict  */)(buf___1), (size_t )12, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 55
  if (tmp != 1UL) {
#line 56
    if (& info_ptr) {
      {
#line 57
      png_error(png_ptr, "Can\'t read file");
      }
    }
  }
  {
#line 58
  sig_code = pngx_sig_is_jpeg(buf___1, (png_size_t )12);
  }
  {
#line 61
  if (sig_code == 1) {
#line 61
    goto case_1;
  }
#line 63
  if (sig_code == 2) {
#line 63
    goto case_2;
  }
#line 65
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 62
  png_error(png_ptr, "JPEG support is not implemented");
  }
  case_2: /* CIL Label */ 
  {
#line 64
  png_error(png_ptr, "JPEG-2000 support is not implemented");
  }
  switch_default: /* CIL Label */ 
  {
#line 66
  png_error(png_ptr, "Inconsistent input file");
  }
  switch_break: /* CIL Label */ ;
  }
#line 68
  return ((png_charp )"JPEG");
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 48 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxtern.h"
int pngx_sig_is_gif(png_bytep sig , png_size_t len ) ;
#line 50
png_charp pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 76
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) ;
#line 106 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.h"
void GIFReadScreen(struct GIFScreen *screen , FILE *fp ) ;
#line 114
void GIFInitImage(struct GIFImage *image , struct GIFScreen *screen , unsigned char **rows ) ;
#line 125
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned char *buf___1 ,
                      unsigned int size ) ;
#line 135
int GIFReadNextBlock(struct GIFImage *image , struct GIFExtension *ext , FILE *fp ) ;
#line 144
void GIFGetGraphicCtl(struct GIFExtension *ext , struct GIFGraphicCtlExt *graphicExt ) ;
#line 155
unsigned char *GIFGetColorTable(struct GIFImage *image , unsigned int *numColors ) ;
#line 162
void (*GIFError)(char const   *msg ) ;
#line 163
void (*GIFWarning)(char const   *msg ) ;
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static png_structp pngx_err_ptr___1  =    (png_structp )((void *)0);
#line 12 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static void pngx_gif_error(char const   *msg___0 ) 
{ 


  {
  {
#line 15
  png_error(pngx_err_ptr___1, msg___0);
  }
#line 16
  return;
}
}
#line 18 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static void pngx_gif_warning(char const   *msg___0 ) 
{ 


  {
  {
#line 21
  png_warning(pngx_err_ptr___1, msg___0);
  }
#line 22
  return;
}
}
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
int pngx_sig_is_gif(png_bytep sig , png_size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 28
  if (len < 6UL) {
#line 29
    return (-1);
  }
  {
#line 30
  tmp = memcmp((void const   *)sig, (void const   *)"GIF87a", (size_t )6);
  }
#line 30
  if (tmp == 0) {
#line 32
    return (1);
  } else {
    {
#line 30
    tmp___0 = memcmp((void const   *)sig, (void const   *)"GIF89a", (size_t )6);
    }
#line 30
    if (tmp___0 == 0) {
#line 32
      return (1);
    }
  }
#line 33
  return (0);
}
}
#line 37 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static void pngx_set_GIF_palette(png_structp png_ptr , png_infop info_ptr , unsigned char *color_table ,
                                 int num_colors ) 
{ 
  png_color palette[256] ;
  int i ;

  {
#line 44
  if (! (num_colors <= 256)) {
    {
#line 44
    __assert_fail("num_colors <= 256", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c",
                  44U, "pngx_set_GIF_palette");
    }
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < num_colors)) {
#line 45
      goto while_break;
    }
#line 47
    palette[i].red = *(color_table + 3 * i);
#line 48
    palette[i].green = *(color_table + (3 * i + 1));
#line 49
    palette[i].blue = *(color_table + (3 * i + 2));
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  png_set_PLTE(png_ptr, info_ptr, palette, num_colors);
  }
#line 52
  return;
}
}
#line 55 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static void pngx_set_GIF_transparent(png_structp png_ptr , png_infop info_ptr , unsigned int transparent ) 
{ 
  png_byte trans[256] ;
  unsigned int i ;

  {
#line 62
  if (! (transparent < 256U)) {
    {
#line 62
    __assert_fail("transparent < 256", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c",
                  62U, "pngx_set_GIF_transparent");
    }
  }
#line 63
  i = 0U;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < transparent)) {
#line 63
      goto while_break;
    }
#line 64
    trans[i] = (png_byte )255;
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  trans[transparent] = (png_byte )0;
#line 66
  png_set_tRNS(png_ptr, info_ptr, trans, (int )(transparent + 1U), (png_color_16p )((void *)0));
  }
#line 67
  return;
}
}
#line 91 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static unsigned char *buf  =    (unsigned char *)((void *)0);
#line 92 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
static unsigned int bufsize  =    1024U;
#line 88 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrgif.c"
png_charp pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  struct GIFScreen screen ;
  struct GIFImage image ;
  struct GIFExtension ext ;
  struct GIFGraphicCtlExt graphicExt ;
  unsigned char *colorTable ;
  unsigned int numColors ;
  int multiImage ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_bytepp row_pointers ;
  png_uint_32 i ;
  png_voidp tmp ;
  png_voidp tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 105
  pngx_err_ptr___1 = png_ptr;
#line 106
  GIFError = & pngx_gif_error;
#line 107
  GIFWarning = & pngx_gif_warning;
#line 110
  GIFReadScreen(& screen, fp);
#line 113
  width = (png_uint_32 )screen.Width;
#line 114
  height = (png_uint_32 )screen.Height;
#line 115
  png_set_IHDR(png_ptr, info_ptr, width, height, 8, 3, 0, 0, 0);
#line 120
  tmp = png_malloc(png_ptr, height * sizeof(png_bytep ));
#line 120
  row_pointers = (png_bytepp )tmp;
#line 122
  i = (png_uint_32 )0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < height)) {
#line 122
      goto while_break;
    }
    {
#line 124
    tmp___0 = png_malloc(png_ptr, width);
#line 124
    *(row_pointers + i) = (png_bytep )tmp___0;
#line 125
    memset((void *)*(row_pointers + i), (int )screen.Background, width);
#line 122
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 128
    tmp___1 = malloc((size_t )bufsize);
#line 128
    buf = (unsigned char *)tmp___1;
    }
  }
  {
#line 130
  GIFInitImage(& image, & screen, row_pointers);
#line 131
  GIFInitExtension(& ext, & screen, buf, bufsize);
#line 132
  png_set_rows(png_ptr, info_ptr, row_pointers);
#line 133
  multiImage = 0;
  }
#line 136
  if (screen.GlobalColorFlag) {
    {
#line 137
    pngx_set_GIF_palette(png_ptr, info_ptr, screen.GlobalColorTable, (int )screen.GlobalNumColors);
    }
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 143
    tmp___2 = GIFReadNextBlock(& image, & ext, fp);
    }
    {
#line 145
    if (tmp___2 == 59) {
#line 145
      goto case_59;
    }
#line 151
    if (tmp___2 == 44) {
#line 151
      goto case_44;
    }
#line 175
    if (tmp___2 == 33) {
#line 175
      goto case_33;
    }
#line 143
    goto switch_break;
    case_59: /* CIL Label */ 
#line 147
    if ((unsigned long )image.Rows != (unsigned long )((void *)0)) {
      {
#line 148
      png_error(png_ptr, "Empty GIF file");
      }
    }
#line 149
    return ((png_charp )"GIF");
    case_44: /* CIL Label */ 
#line 153
    if ((unsigned long )image.Rows != (unsigned long )((void *)0)) {
#line 155
      if (image.InterlaceFlag) {
        {
#line 156
        pngx_set_interlace_type(png_ptr, info_ptr, 1);
        }
      }
      {
#line 158
      colorTable = GIFGetColorTable(& image, & numColors);
      }
#line 159
      if ((unsigned long )colorTable != (unsigned long )(screen.GlobalColorTable)) {
        {
#line 160
        pngx_set_GIF_palette(png_ptr, info_ptr, colorTable, (int )numColors);
        }
      }
#line 162
      image.Rows = (unsigned char **)((void *)0);
    } else
#line 166
    if (! multiImage) {
      {
#line 168
      png_error(png_ptr, "Multi-image/animated GIF cannot be properly converted to PNG");
#line 170
      multiImage = 1;
      }
    }
#line 173
    goto switch_break;
    case_33: /* CIL Label */ 
#line 177
    if ((unsigned long )image.Rows != (unsigned long )((void *)0)) {
#line 177
      if ((int )ext.Label == 249) {
        {
#line 179
        GIFGetGraphicCtl(& ext, & graphicExt);
        }
#line 180
        if (graphicExt.TransparentFlag) {
          {
#line 181
          pngx_set_GIF_transparent(png_ptr, info_ptr, graphicExt.Transparent);
          }
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 694 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 31 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxtern.h"
png_charp pngx_png_name(char const   *filename ) ;
#line 34
png_charp pngx_read_external(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 38
int pngx_sig_is_png_jng_mng(png_bytep sig , png_size_t len ) ;
#line 42
int pngx_sig_is_bmp(png_bytep sig , png_size_t len ) ;
#line 44
png_charp pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *fp ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 10 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxread.c"
png_charp pngx_png_name(char const   *filename ) 
{ 
  png_charp result ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 14
  tmp = strlen(filename);
#line 14
  len = tmp;
  }
#line 15
  if (len >= 4UL) {
#line 15
    if ((int const   )*(filename + (len - 4UL)) == 46) {
      {
#line 15
      tmp___0 = tolower((int )*(filename + (len - 3UL)));
      }
#line 15
      if (tmp___0 == 112) {
        {
#line 15
        tmp___1 = tolower((int )*(filename + (len - 2UL)));
        }
#line 15
        if (tmp___1 == 110) {
          {
#line 15
          tmp___2 = tolower((int )*(filename + (len - 1UL)));
          }
#line 15
          if (tmp___2 == 103) {
#line 19
            return ((png_charp )filename);
          }
        }
      }
    }
  }
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    len --;
#line 23
    if ((int const   )*(filename + len) == 46) {
#line 24
      goto while_break;
    }
#line 20
    if (! (len > 0UL)) {
#line 20
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  if ((int const   )*(filename + len) != 46) {
    {
#line 27
    len = strlen(filename);
    }
  }
  {
#line 28
  tmp___3 = malloc(len + 5UL);
#line 28
  result = (png_charp )tmp___3;
#line 29
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)filename);
#line 30
  strcpy((char */* __restrict  */)(result + len), (char const   */* __restrict  */)".png");
  }
#line 31
  return (result);
}
}
#line 35 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxread.c"
int pngx_sig_is_png_jng_mng(png_bytep sig , png_size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 38
  if (len < 4UL) {
#line 39
    return (-1);
  }
  {
#line 40
  tmp = memcmp((void const   *)sig, (void const   *)"\211PNG", (size_t )4);
  }
#line 40
  if (tmp == 0) {
#line 43
    return (1);
  } else {
    {
#line 40
    tmp___0 = memcmp((void const   *)sig, (void const   *)"\212MNG", (size_t )4);
    }
#line 40
    if (tmp___0 == 0) {
#line 43
      return (1);
    } else {
      {
#line 40
      tmp___1 = memcmp((void const   *)sig, (void const   *)"\213JNG", (size_t )4);
      }
#line 40
      if (tmp___1 == 0) {
#line 43
        return (1);
      }
    }
  }
#line 44
  return (0);
}
}
#line 48 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxread.c"
png_charp pngx_read_external(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  png_byte buf___1[256] ;
  png_size_t num ;
  int tmp ;
  png_charp tmp___0 ;
  int tmp___1 ;
  png_charp tmp___2 ;
  int tmp___3 ;
  png_charp tmp___4 ;
  int tmp___5 ;
  png_charp tmp___6 ;
  int tmp___7 ;
  png_charp tmp___8 ;
  int tmp___9 ;

  {
  {
#line 54
  num = fread((void */* __restrict  */)(buf___1), (size_t )1, sizeof(buf___1), (FILE */* __restrict  */)fp);
#line 55
  rewind(fp);
#line 57
  tmp = pngx_sig_is_png_jng_mng(buf___1, num);
  }
#line 57
  if (tmp > 0) {
#line 58
    return ((png_charp )((void *)0));
  }
  {
#line 60
  tmp___1 = pngx_sig_is_bmp(buf___1, num);
  }
#line 60
  if (tmp___1 > 0) {
    {
#line 61
    tmp___0 = pngx_read_bmp(png_ptr, info_ptr, fp);
    }
#line 61
    return (tmp___0);
  }
  {
#line 62
  tmp___3 = pngx_sig_is_gif(buf___1, num);
  }
#line 62
  if (tmp___3 > 0) {
    {
#line 63
    tmp___2 = pngx_read_gif(png_ptr, info_ptr, fp);
    }
#line 63
    return (tmp___2);
  }
  {
#line 64
  tmp___5 = pngx_sig_is_jpeg(buf___1, num);
  }
#line 64
  if (tmp___5 > 0) {
    {
#line 65
    tmp___4 = pngx_read_jpeg(png_ptr, info_ptr, fp);
    }
#line 65
    return (tmp___4);
  }
  {
#line 66
  tmp___7 = pngx_sig_is_pnm(buf___1, num);
  }
#line 66
  if (tmp___7 > 0) {
    {
#line 67
    tmp___6 = pngx_read_pnm(png_ptr, info_ptr, fp);
    }
#line 67
    return (tmp___6);
  }
  {
#line 68
  tmp___9 = pngx_sig_is_tiff(buf___1, num);
  }
#line 68
  if (tmp___9 > 0) {
    {
#line 69
    tmp___8 = pngx_read_tiff(png_ptr, info_ptr, fp);
    }
#line 69
    return (tmp___8);
  }
  {
#line 71
  png_error(png_ptr, "Unrecognized image file format");
  }
#line 72
  return ((png_charp )((void *)0));
}
}
#line 76 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxread.c"
png_voidp pngx_zmalloc(png_structp png_ptr , png_uint_32 size ) 
{ 
  png_voidp result ;
  void *tmp ;

  {
#line 81
  if (size == 0UL) {
#line 82
    return ((void *)0);
  }
  {
#line 84
  tmp = calloc(size, (size_t )1);
#line 84
  result = tmp;
  }
#line 85
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 85
    if ((png_ptr->flags & 1048576UL) == 0UL) {
      {
#line 86
      png_error(png_ptr, "Out of memory!");
      }
    }
  }
#line 88
  return (result);
}
}
#line 92 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxread.c"
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) 
{ 


  {
#line 96
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 96
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 98
      if (interlace_type < 0) {
        {
#line 99
        png_error(png_ptr, "Unknown interlace method in IHDR");
        }
      } else
#line 98
      if (interlace_type >= 2) {
        {
#line 99
        png_error(png_ptr, "Unknown interlace method in IHDR");
        }
      }
#line 100
      info_ptr->interlace_type = (png_byte )interlace_type;
    }
  }
#line 102
  return;
}
}
#line 93 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrbmp.c"
static unsigned int bmp_get_word(png_bytep ptr ) 
{ 


  {
#line 96
  return ((unsigned int )*(ptr + 0) + ((unsigned int )*(ptr + 1) << 8));
}
}
#line 99 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrbmp.c"
static png_uint_32 bmp_get_dword(png_bytep ptr ) 
{ 


  {
#line 102
  return ((((png_uint_32 )*(ptr + 0) + ((png_uint_32 )*(ptr + 1) << 8)) + ((png_uint_32 )*(ptr + 2) << 16)) + ((png_uint_32 )*(ptr + 3) << 24));
}
}
#line 110 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrbmp.c"
int pngx_sig_is_bmp(png_bytep sig , png_size_t len ) 
{ 
  unsigned int tmp ;

  {
#line 113
  if (len <= 4UL) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp = bmp_get_word(sig);
  }
#line 115
  return (tmp == 19778U);
}
}
#line 119 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/pngxrbmp.c"
png_charp pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *fp ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  unsigned int pixdepth ;
  unsigned int palnum ;
  unsigned int palsize ;
  int topdown ;
  png_size_t rowsize ;
  png_byte bfh[138] ;
  png_bytep bih ;
  png_byte rgbq[4] ;
  png_uint_32 offbits ;
  png_uint_32 bihsize ;
  png_uint_32 skip ;
  png_uint_32 compression ;
  int bit_depth ;
  int color_type ;
  png_color palette[256] ;
  png_color_8 sig_bit ;
  png_uint_32 rowbytes ;
  png_bytepp row_pointers ;
  png_bytep sample_ptr ;
  png_bytep dest_ptr ;
  unsigned int i ;
  png_uint_32 x ;
  png_uint_32 y ;
  png_uint_32 yend ;
  int yinc ;
  size_t tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  png_voidp tmp___5 ;
  png_voidp tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  png_byte tmp___9 ;
  png_byte r ;
  png_byte g ;
  png_byte b ;
  unsigned int pixel15 ;
  unsigned int r___0 ;
  unsigned int g___0 ;
  unsigned int b___0 ;

  {
#line 127
  bih = bfh + 14;
#line 142
  i = 0U;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    tmp = fread((void */* __restrict  */)(bfh), (size_t )18, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 144
    if (tmp != 1UL) {
#line 145
      goto err_read;
    }
    {
#line 146
    tmp___0 = bmp_get_word(bfh + 0);
    }
#line 146
    if (tmp___0 == 19778U) {
#line 147
      goto while_break;
    }
#line 148
    if (i > 0U) {
      {
#line 149
      png_error(png_ptr, "Not a BMP file");
      }
    }
    {
#line 150
    tmp___1 = fread((void */* __restrict  */)(bfh), (size_t )110, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 150
    if (tmp___1 != 1UL) {
#line 151
      goto err_read;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  offbits = bmp_get_dword(bfh + 10);
#line 155
  bihsize = bmp_get_dword(bfh + 14);
#line 156
  skip = (offbits - bihsize) - 14UL;
  }
#line 157
  if (bihsize < 12UL) {
    {
#line 159
    png_error(png_ptr, "Not a BMP file or Invalid BMP file");
    }
  } else
#line 157
  if (bihsize > 124UL) {
    {
#line 159
    png_error(png_ptr, "Not a BMP file or Invalid BMP file");
    }
  } else
#line 157
  if (offbits < bihsize + 14UL) {
    {
#line 159
    png_error(png_ptr, "Not a BMP file or Invalid BMP file");
    }
  }
  {
#line 161
  tmp___2 = fread((void */* __restrict  */)(bih + 4), bihsize - 4UL, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 161
  if (tmp___2 != 1UL) {
#line 162
    goto err_read;
  }
#line 164
  if (bihsize == 12UL) {
    {
#line 166
    tmp___3 = bmp_get_word(bih + 4);
#line 166
    width = (png_uint_32 )tmp___3;
#line 167
    tmp___4 = bmp_get_word(bih + 6);
#line 167
    height = (png_uint_32 )tmp___4;
#line 168
    pixdepth = bmp_get_word(bih + 10);
#line 169
    topdown = 0;
#line 170
    compression = (png_uint_32 )0L;
#line 171
    palsize = 3U;
    }
  } else {
    {
#line 175
    width = bmp_get_dword(bih + 4);
#line 176
    height = bmp_get_dword(bih + 8);
#line 177
    pixdepth = bmp_get_word(bih + 14);
#line 178
    topdown = 0;
#line 179
    compression = bmp_get_dword(bih + 16);
#line 180
    palsize = 4U;
    }
#line 181
    if ((png_int_32 )height < 0L) {
#line 183
      height = (png_uint_32 )(- ((png_int_32 )height));
#line 184
      topdown = 1;
    }
  }
#line 189
  if ((png_int_32 )width <= 0L) {
    {
#line 190
    png_error(png_ptr, "Invalid BMP file");
    }
  } else
#line 189
  if ((png_int_32 )height <= 0L) {
    {
#line 190
    png_error(png_ptr, "Invalid BMP file");
    }
  } else
#line 189
  if (pixdepth == 0U) {
    {
#line 190
    png_error(png_ptr, "Invalid BMP file");
    }
  }
#line 191
  if (compression != 0UL) {
    {
#line 192
    png_error(png_ptr, "Unsupported compression type in BMP");
    }
  }
#line 193
  if (32U % pixdepth != 0U) {
#line 193
    if (pixdepth != 24U) {
      {
#line 194
      png_error(png_ptr, "Invalid pixel depth in BMP");
      }
    }
  }
#line 197
  if (pixdepth <= 8U) {
#line 199
    palnum = (unsigned int )(skip / (png_uint_32 )palsize);
#line 200
    if (palnum > 256U) {
#line 201
      palnum = 256U;
    }
#line 202
    skip -= (png_uint_32 )(palsize * palnum);
#line 203
    rowbytes = (((width + (png_uint_32 )(32U / pixdepth)) - 1UL) / (png_uint_32 )(32U / pixdepth)) * 4UL;
#line 203
    rowsize = rowbytes;
#line 204
    bit_depth = (int )pixdepth;
#line 205
    if (palnum > 0U) {
#line 205
      color_type = 3;
    } else {
#line 205
      color_type = 0;
    }
  } else {
#line 209
    palnum = 0U;
#line 210
    bit_depth = 8;
#line 211
    color_type = 2;
#line 212
    if (width > 0xfffffffffffffffcUL / (png_size_t )(pixdepth / 8U)) {
      {
#line 213
      png_error(png_ptr, "Can\'t handle exceedingly large BMP dimensions");
      }
    }
#line 215
    if (pixdepth == 16U) {
#line 217
      rowsize = (width * 2UL + 3UL) & 0xfffffffffffffffcUL;
#line 218
      rowbytes = (width * 3UL + 3UL) & 0xfffffffffffffffcUL;
    } else
#line 220
    if (pixdepth == 24U) {
#line 221
      rowsize = (width * 3UL + 3UL) & 0xfffffffffffffffcUL;
#line 221
      rowbytes = rowsize;
    } else
#line 222
    if (pixdepth == 32U) {
#line 223
      rowsize = width * 4UL;
#line 223
      rowbytes = rowsize;
    } else {
#line 225
      goto err_read;
    }
  }
  {
#line 229
  png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type, 0, 0, 0);
  }
#line 232
  if (pixdepth == 16U) {
    {
#line 234
    sig_bit.blue = (png_byte )5;
#line 234
    sig_bit.green = sig_bit.blue;
#line 234
    sig_bit.red = sig_bit.green;
#line 235
    png_set_sBIT(png_ptr, info_ptr, & sig_bit);
    }
  }
  {
#line 239
  tmp___5 = png_malloc(png_ptr, height * sizeof(png_bytep ));
#line 239
  row_pointers = (png_bytepp )tmp___5;
#line 240
  y = (png_uint_32 )0;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (y < height)) {
#line 240
      goto while_break___0;
    }
    {
#line 241
    tmp___6 = pngx_zmalloc(png_ptr, rowbytes);
#line 241
    *(row_pointers + y) = (png_bytep )tmp___6;
#line 240
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 242
  png_set_rows(png_ptr, info_ptr, row_pointers);
  }
#line 244
  if (palnum > 0U) {
#line 246
    i = 0U;
    {
#line 246
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 246
      if (! (i < palnum)) {
#line 246
        goto while_break___1;
      }
      {
#line 248
      tmp___7 = fread((void */* __restrict  */)(rgbq), (size_t )palsize, (size_t )1,
                      (FILE */* __restrict  */)fp);
      }
#line 248
      if (tmp___7 != 1UL) {
#line 249
        goto err_read;
      }
#line 250
      palette[i].red = rgbq[2];
#line 251
      palette[i].green = rgbq[1];
#line 252
      palette[i].blue = rgbq[0];
#line 246
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 254
    png_set_PLTE(png_ptr, info_ptr, palette, (int )palnum);
    }
  }
#line 257
  if (skip > 0UL) {
    {
#line 258
    fseek(fp, (long )skip, 1);
    }
  }
#line 261
  if (topdown) {
#line 263
    y = (png_uint_32 )0;
#line 264
    yend = height - 1UL;
#line 265
    yinc = 1;
  } else {
#line 269
    y = height - 1UL;
#line 270
    yend = (png_uint_32 )0;
#line 271
    yinc = -1;
  }
  {
#line 273
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 275
    tmp___8 = fread((void */* __restrict  */)*(row_pointers + y), rowsize, (size_t )1,
                    (FILE */* __restrict  */)fp);
    }
#line 275
    if (tmp___8 != 1UL) {
#line 276
      goto err_read;
    }
#line 277
    if (pixdepth == 24U) {
#line 279
      sample_ptr = *(row_pointers + y);
#line 280
      x = (png_uint_32 )0;
      {
#line 280
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 280
        if (! (x < width)) {
#line 280
          goto while_break___3;
        }
#line 282
        tmp___9 = *(sample_ptr + 0);
#line 283
        *(sample_ptr + 0) = *(sample_ptr + 2);
#line 284
        *(sample_ptr + 2) = tmp___9;
#line 280
        x ++;
#line 280
        sample_ptr += 3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 287
    if (pixdepth == 32U) {
#line 289
      dest_ptr = *(row_pointers + y);
#line 289
      sample_ptr = dest_ptr;
#line 290
      x = (png_uint_32 )0;
      {
#line 290
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 290
        if (! (x < width)) {
#line 290
          goto while_break___4;
        }
#line 292
        r = *(sample_ptr + 2);
#line 293
        g = *(sample_ptr + 1);
#line 294
        b = *(sample_ptr + 0);
#line 295
        *(dest_ptr + 0) = r;
#line 296
        *(dest_ptr + 1) = g;
#line 297
        *(dest_ptr + 2) = b;
#line 290
        x ++;
#line 290
        sample_ptr += 4;
#line 290
        dest_ptr += 3;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 300
    if (pixdepth == 16U) {
#line 302
      sample_ptr = *(row_pointers + y) + 2UL * (width - 1UL);
#line 303
      dest_ptr = *(row_pointers + y) + 3UL * (width - 1UL);
#line 304
      x = (png_uint_32 )0;
      {
#line 304
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 304
        if (! (x < width)) {
#line 304
          goto while_break___5;
        }
#line 306
        pixel15 = (unsigned int )((int )*(sample_ptr + 0) + ((int )*(sample_ptr + 1) << 8));
#line 307
        r___0 = (pixel15 & 31744U) >> 10;
#line 308
        g___0 = (pixel15 & 992U) >> 5;
#line 309
        b___0 = pixel15 & 31U;
#line 310
        *(dest_ptr + 0) = (png_byte )((r___0 * 255U + 15U) / 31U);
#line 311
        *(dest_ptr + 1) = (png_byte )((g___0 * 255U + 15U) / 31U);
#line 312
        *(dest_ptr + 2) = (png_byte )((b___0 * 255U + 15U) / 31U);
#line 304
        x ++;
#line 304
        sample_ptr -= 2;
#line 304
        dest_ptr -= 3;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 315
    if (y == yend) {
#line 316
      goto while_break___2;
    }
#line 317
    y += (png_uint_32 )yinc;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 320
  return ((png_charp )"BMP");
  err_read: 
  {
#line 323
  png_error(png_ptr, "Error reading BMP");
  }
#line 324
  return ((png_charp )((void *)0));
}
}
#line 21 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
void minitiff_init_info(struct minitiff_info *minitiff_ptr ) 
{ 


  {
  {
#line 23
  memset((void *)minitiff_ptr, 0, sizeof(*minitiff_ptr));
#line 24
  minitiff_ptr->photometric = 4294967295U;
  }
#line 25
  return;
}
}
#line 31 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
void minitiff_validate_info(struct minitiff_info *tiff_ptr ) 
{ 


  {
#line 33
  if (tiff_ptr->width == 0UL) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->height == 0UL) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->bits_per_sample == 0U) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->samples_per_pixel == 0U) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  }
#line 36
  if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
    {
#line 37
    minitiff_error(tiff_ptr, "Invalid TIFF strip info");
    }
  } else
#line 36
  if (tiff_ptr->rows_per_strip == 0U) {
    {
#line 37
    minitiff_error(tiff_ptr, "Invalid TIFF strip info");
    }
  }
#line 38
  if (tiff_ptr->photometric >= 3U) {
    {
#line 39
    minitiff_error(tiff_ptr, "Unknown photometric interpretation");
    }
  }
#line 40
  return;
}
}
#line 46 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
void minitiff_destroy_info(struct minitiff_info *minitiff_ptr ) 
{ 


  {
#line 48
  if ((unsigned long )minitiff_ptr->strip_offsets != (unsigned long )((void *)0)) {
    {
#line 49
    free((void *)minitiff_ptr->strip_offsets);
    }
  }
#line 50
  return;
}
}
#line 56 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
static void minitiff_default_error_handler(char const   *msg___0 ) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg___0);
#line 59
  exit(1);
  }
}
}
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
void minitiff_error(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) 
{ 


  {
#line 64
  if ((unsigned long )minitiff_ptr->error_handler != (unsigned long )((void *)0)) {
    {
#line 65
    (*(minitiff_ptr->error_handler))(msg___0);
    }
  } else {
    {
#line 67
    minitiff_default_error_handler(msg___0);
    }
  }
  {
#line 68
  abort();
  }
}
}
#line 71 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
static void minitiff_default_warning_handler(char const   *msg___0 ) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg___0);
  }
#line 74
  return;
}
}
#line 76 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
void minitiff_warning(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) 
{ 


  {
#line 78
  if ((unsigned long )minitiff_ptr->warning_handler != (unsigned long )((void *)0)) {
    {
#line 79
    (*(minitiff_ptr->warning_handler))(msg___0);
    }
  } else {
    {
#line 81
    minitiff_default_warning_handler(msg___0);
    }
  }
#line 82
  return;
}
}
#line 89 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
char const   minitiff_sig_m[4]  = {      (char const   )77,      (char const   )77,      (char const   )0,      (char const   )42};
#line 90 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/minitiff/minitiff.c"
char const   minitiff_sig_i[4]  = {      (char const   )73,      (char const   )73,      (char const   )42,      (char const   )0};
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static char const   *ErrRead  =    "Error reading file or unexpected end of file";
#line 50
static void GIFReadNextImage(struct GIFImage *image , FILE *fp ) ;
#line 51
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *fp ) ;
#line 52
static void ReadImageData(struct GIFImage *image , FILE *fp ) ;
#line 53
static void SkipDataBlocks(FILE *fp ) ;
#line 54
static int ReadDataBlock(unsigned char *buf___1 , FILE *fp ) ;
#line 55
static int LZWGetCode(int code_size___0 , int flag , FILE *fp ) ;
#line 56
static int LZWReadByte(int flag , int input_code_size , FILE *fp ) ;
#line 62 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void GIFReadScreen(struct GIFScreen *screen , FILE *fp ) 
{ 
  unsigned char buf___1[7] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 67
  tmp = fread((void */* __restrict  */)(buf___1), (size_t )6, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 67
  if (tmp <= 0UL) {
    {
#line 67
    (*GIFError)(ErrRead);
    }
  }
  {
#line 68
  tmp___0 = strncmp((char const   *)((char *)(buf___1)), "GIF", (size_t )3);
  }
#line 68
  if (tmp___0 != 0) {
    {
#line 69
    (*GIFError)("Not a GIF file");
    }
  }
  {
#line 70
  tmp___1 = strncmp((char const   *)((char *)(buf___1) + 3), "87a", (size_t )3);
  }
#line 70
  if (tmp___1 != 0) {
    {
#line 70
    tmp___2 = strncmp((char const   *)((char *)(buf___1) + 3), "89a", (size_t )3);
    }
#line 70
    if (tmp___2 != 0) {
      {
#line 72
      (*GIFWarning)("Invalid GIF version number, not \"87a\" or \"89a\"");
      }
    }
  }
  {
#line 75
  tmp___3 = fread((void */* __restrict  */)(buf___1), (size_t )7, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 75
  if (tmp___3 <= 0UL) {
    {
#line 75
    (*GIFError)(ErrRead);
    }
  }
#line 76
  screen->Width = (unsigned int )((int )*((buf___1 + 0) + 0) + ((int )*((buf___1 + 0) + 1) << 8));
#line 77
  screen->Height = (unsigned int )((int )*((buf___1 + 2) + 0) + ((int )*((buf___1 + 2) + 1) << 8));
#line 78
  if ((int )buf___1[4] & 128) {
#line 78
    screen->GlobalColorFlag = 1U;
  } else {
#line 78
    screen->GlobalColorFlag = 0U;
  }
#line 79
  screen->ColorResolution = (unsigned int )((((int )buf___1[4] & 112) >> 3) + 1);
#line 80
  if ((int )buf___1[4] & 8) {
#line 80
    screen->SortFlag = 1U;
  } else {
#line 80
    screen->SortFlag = 0U;
  }
#line 81
  screen->GlobalNumColors = (unsigned int )(2 << ((int )buf___1[4] & 7));
#line 82
  screen->Background = (unsigned int )buf___1[5];
#line 83
  screen->PixelAspectRatio = (unsigned int )buf___1[6];
#line 85
  if (screen->GlobalColorFlag) {
    {
#line 88
    tmp___4 = fread((void */* __restrict  */)(screen->GlobalColorTable), (size_t )(3U * screen->GlobalNumColors),
                    (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 88
    if (tmp___4 <= 0UL) {
      {
#line 88
      (*GIFError)(ErrRead);
      }
    }
  }
#line 92
  if (screen->Width == 0U) {
    {
#line 93
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 92
  if (screen->Height == 0U) {
    {
#line 93
    (*GIFError)("Invalid image dimensions");
    }
  }
#line 94
  if (screen->Background > 0U) {
#line 96
    if (screen->GlobalColorFlag) {
#line 96
      if (screen->Background >= screen->GlobalNumColors) {
#line 103
        screen->Background = 0U;
      } else {
#line 96
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 96
    if (! screen->GlobalColorFlag) {
#line 103
      screen->Background = 0U;
    }
  }
#line 106
  return;
}
}
#line 112 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void GIFInitImage(struct GIFImage *image , struct GIFScreen *screen , unsigned char **rows ) 
{ 


  {
#line 115
  image->Screen = screen;
#line 116
  image->Rows = rows;
#line 117
  return;
}
}
#line 123 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned char *buf___1 ,
                      unsigned int size ) 
{ 


  {
#line 126
  ext->Screen = screen;
#line 127
  ext->BufferSize = size;
#line 128
  ext->Buffer = buf___1;
#line 129
  return;
}
}
#line 135 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
int GIFReadNextBlock(struct GIFImage *image , struct GIFExtension *ext , FILE *fp ) 
{ 
  int ch ;
  int foundBogus ;

  {
#line 141
  foundBogus = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    ch = _IO_getc(fp);
    }
#line 144
    if (ch == -1) {
      {
#line 144
      (*GIFError)(ErrRead);
      }
    }
    {
#line 147
    if (ch == 44) {
#line 147
      goto case_44;
    }
#line 150
    if (ch == 33) {
#line 150
      goto case_33;
    }
#line 153
    if (ch == 59) {
#line 153
      goto case_59;
    }
#line 155
    goto switch_default;
    case_44: /* CIL Label */ 
    {
#line 148
    GIFReadNextImage(image, fp);
    }
#line 149
    return (ch);
    case_33: /* CIL Label */ 
    {
#line 151
    GIFReadNextExtension(ext, fp);
    }
#line 152
    return (ch);
    case_59: /* CIL Label */ 
#line 154
    return (ch);
    switch_default: /* CIL Label */ 
#line 156
    if (! foundBogus) {
      {
#line 157
      (*GIFWarning)("Bogus data in GIF");
      }
    }
#line 158
    foundBogus = 1;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 167 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void GIFReadNextImage(struct GIFImage *image , FILE *fp ) 
{ 
  struct GIFScreen *screen ;
  unsigned char buf___1[9] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 173
  tmp = fread((void */* __restrict  */)(buf___1), (size_t )9, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 173
  if (tmp <= 0UL) {
    {
#line 173
    (*GIFError)(ErrRead);
    }
  }
#line 174
  if ((unsigned long )image == (unsigned long )((void *)0)) {
    {
#line 176
    SkipDataBlocks(fp);
    }
#line 177
    return;
  }
#line 180
  image->LeftPos = (unsigned int )((int )*((buf___1 + 0) + 0) + ((int )*((buf___1 + 0) + 1) << 8));
#line 181
  image->TopPos = (unsigned int )((int )*((buf___1 + 2) + 0) + ((int )*((buf___1 + 2) + 1) << 8));
#line 182
  image->Width = (unsigned int )((int )*((buf___1 + 4) + 0) + ((int )*((buf___1 + 4) + 1) << 8));
#line 183
  image->Height = (unsigned int )((int )*((buf___1 + 6) + 0) + ((int )*((buf___1 + 6) + 1) << 8));
#line 184
  if ((int )buf___1[8] & 128) {
#line 184
    image->LocalColorFlag = 1U;
  } else {
#line 184
    image->LocalColorFlag = 0U;
  }
#line 185
  if ((int )buf___1[8] & 64) {
#line 185
    image->InterlaceFlag = 1U;
  } else {
#line 185
    image->InterlaceFlag = 0U;
  }
#line 186
  if ((int )buf___1[8] & 32) {
#line 186
    image->SortFlag = 1U;
  } else {
#line 186
    image->SortFlag = 0U;
  }
#line 187
  if (image->LocalColorFlag) {
#line 187
    image->LocalNumColors = (unsigned int )(2 << ((int )buf___1[8] & 7));
  } else {
#line 187
    image->LocalNumColors = 0U;
  }
#line 189
  if (image->LocalColorFlag) {
    {
#line 192
    tmp___0 = fread((void */* __restrict  */)(image->LocalColorTable), (size_t )(3U * image->LocalNumColors),
                    (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 192
    if (tmp___0 <= 0UL) {
      {
#line 192
      (*GIFError)(ErrRead);
      }
    }
  }
#line 196
  screen = image->Screen;
#line 198
  if (image->Width == 0U) {
    {
#line 201
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 198
  if (image->Height == 0U) {
    {
#line 201
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 198
  if (image->LeftPos + image->Width > screen->Width) {
    {
#line 201
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 198
  if (image->TopPos + image->Height > screen->Height) {
    {
#line 201
    (*GIFError)("Invalid image dimensions");
    }
  }
  {
#line 203
  ReadImageData(image, fp);
  }
#line 204
  return;
}
}
#line 210 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *fp ) 
{ 
  unsigned char *ptr ;
  unsigned int len ;
  int count ;
  int label ;
  void *tmp ;

  {
  {
#line 216
  label = _IO_getc(fp);
  }
#line 216
  if (label == -1) {
    {
#line 216
    (*GIFError)(ErrRead);
    }
  }
#line 218
  if ((unsigned long )ext != (unsigned long )((void *)0)) {
#line 219
    ext->Label = (unsigned char )label;
  }
#line 220
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
    {
#line 222
    SkipDataBlocks(fp);
    }
#line 223
    return;
  } else
#line 220
  if ((unsigned long )ext->Buffer == (unsigned long )((void *)0)) {
    {
#line 222
    SkipDataBlocks(fp);
    }
#line 223
    return;
  }
#line 226
  ptr = ext->Buffer;
#line 227
  len = ext->BufferSize;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (len < 255U) {
      {
#line 232
      len += 1024U;
#line 233
      ext->BufferSize += 1024U;
#line 234
      tmp = realloc((void *)ext->Buffer, (size_t )ext->BufferSize);
#line 234
      ext->Buffer = (unsigned char *)tmp;
      }
    }
    {
#line 236
    count = ReadDataBlock(ptr, fp);
    }
#line 237
    if (count == 0) {
#line 238
      goto while_break;
    }
#line 239
    ptr += count;
#line 240
    len -= (unsigned int )count;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 325 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int ZeroDataBlock  =    0;
#line 327 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int ReadDataBlock(unsigned char *buf___1 , FILE *fp ) 
{ 
  int count ;
  size_t tmp ;

  {
  {
#line 331
  count = _IO_getc(fp);
  }
#line 331
  if (count == -1) {
    {
#line 331
    (*GIFError)(ErrRead);
    }
  }
#line 332
  if (count > 0) {
    {
#line 334
    ZeroDataBlock = 0;
#line 335
    tmp = fread((void */* __restrict  */)buf___1, (size_t )((unsigned int )count),
                (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 335
    if (tmp <= 0UL) {
      {
#line 335
      (*GIFError)(ErrRead);
      }
    }
  } else {
#line 338
    ZeroDataBlock = 1;
  }
#line 340
  return (count);
}
}
#line 343 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void SkipDataBlocks(FILE *fp ) 
{ 
  int count ;
  unsigned char buf___1[255] ;
  size_t tmp ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 350
    count = _IO_getc(fp);
    }
#line 350
    if (count == -1) {
      {
#line 350
      (*GIFError)(ErrRead);
      }
    }
#line 351
    if (count > 0) {
      {
#line 353
      tmp = fread((void */* __restrict  */)(buf___1), (size_t )((unsigned int )count),
                  (size_t )1, (FILE */* __restrict  */)fp);
      }
#line 353
      if (tmp <= 0UL) {
        {
#line 353
        (*GIFError)(ErrRead);
        }
      }
    } else {
#line 356
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 362 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static unsigned char buf___0[280]  ;
#line 363 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int curbit  ;
#line 363 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int lastbit  ;
#line 363 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int done  ;
#line 363 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int last_byte  ;
#line 360 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int LZWGetCode(int code_size___0 , int flag , FILE *fp ) 
{ 
  int count ;
  int i ;
  int j ;
  int ret ;

  {
#line 366
  if (flag) {
#line 367
    curbit = 0;
#line 368
    lastbit = 0;
#line 369
    done = 0;
#line 370
    return (0);
  }
#line 373
  if (curbit + code_size___0 >= lastbit) {
#line 374
    if (done) {
#line 375
      if (curbit >= lastbit) {
        {
#line 376
        (*GIFError)("GIF/LZW error: ran off the end of my bits");
        }
      }
#line 377
      return (-1);
    }
    {
#line 379
    buf___0[0] = buf___0[last_byte - 2];
#line 380
    buf___0[1] = buf___0[last_byte - 1];
#line 382
    count = ReadDataBlock(& buf___0[2], fp);
    }
#line 382
    if (count == 0) {
#line 383
      done = 1;
    }
#line 385
    last_byte = 2 + count;
#line 386
    curbit = (curbit - lastbit) + 16;
#line 387
    lastbit = (2 + count) * 8;
  }
#line 390
  ret = 0;
#line 391
  i = curbit;
#line 391
  j = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (j < code_size___0)) {
#line 391
      goto while_break;
    }
#line 392
    ret |= (((int )buf___0[i / 8] & (1 << i % 8)) != 0) << j;
#line 391
    i ++;
#line 391
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  curbit += code_size___0;
#line 396
  return (ret);
}
}
#line 401 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int fresh  =    0;
#line 403 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int code_size  ;
#line 403 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int set_code_size  ;
#line 404 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int max_code  ;
#line 404 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int max_code_size  ;
#line 405 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int firstcode  ;
#line 405 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int oldcode  ;
#line 406 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int clear_code  ;
#line 406 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int end_code  ;
#line 407 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int table[2][4096]  ;
#line 408 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int stack[8192]  ;
#line 408 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int *sp  ;
#line 399 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static int LZWReadByte(int flag , int input_code_size , FILE *fp ) 
{ 
  int code ;
  int incode ;
  register int i ;
  int tmp ;
  int count ;
  unsigned char buf___1[260] ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 411
  if (flag) {
    {
#line 412
    set_code_size = input_code_size;
#line 413
    code_size = set_code_size + 1;
#line 414
    clear_code = 1 << set_code_size;
#line 415
    end_code = clear_code + 1;
#line 416
    max_code_size = 2 * clear_code;
#line 417
    max_code = clear_code + 2;
#line 419
    LZWGetCode(0, 1, fp);
#line 421
    fresh = 1;
#line 423
    i = 0;
    }
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      if (! (i < clear_code)) {
#line 423
        goto while_break;
      }
#line 424
      table[0][i] = 0;
#line 425
      table[1][i] = i;
#line 423
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 427
      if (! (i < 1 << 12)) {
#line 427
        goto while_break___0;
      }
#line 428
      table[1][0] = 0;
#line 428
      table[0][i] = table[1][0];
#line 427
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 430
    sp = stack;
#line 432
    return (0);
  } else
#line 433
  if (fresh) {
#line 434
    fresh = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 436
      oldcode = LZWGetCode(code_size, 0, fp);
#line 436
      firstcode = oldcode;
      }
#line 435
      if (! (firstcode == clear_code)) {
#line 435
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 439
    return (firstcode);
  }
#line 442
  if ((unsigned long )sp > (unsigned long )(stack)) {
#line 443
    sp --;
#line 443
    return (*sp);
  }
  {
#line 445
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 445
    code = LZWGetCode(code_size, 0, fp);
    }
#line 445
    if (! (code >= 0)) {
#line 445
      goto while_break___2;
    }
#line 446
    if (code == clear_code) {
#line 447
      i = 0;
      {
#line 447
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 447
        if (! (i < clear_code)) {
#line 447
          goto while_break___3;
        }
#line 448
        table[0][i] = 0;
#line 449
        table[1][i] = i;
#line 447
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 451
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 451
        if (! (i < 1 << 12)) {
#line 451
          goto while_break___4;
        }
#line 452
        tmp = 0;
#line 452
        table[1][i] = tmp;
#line 452
        table[0][i] = tmp;
#line 451
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 453
      code_size = set_code_size + 1;
#line 454
      max_code_size = 2 * clear_code;
#line 455
      max_code = clear_code + 2;
#line 456
      sp = stack;
#line 457
      oldcode = LZWGetCode(code_size, 0, fp);
#line 457
      firstcode = oldcode;
      }
#line 459
      return (firstcode);
    } else
#line 460
    if (code == end_code) {
#line 464
      if (ZeroDataBlock) {
#line 465
        return (-2);
      }
      {
#line 467
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 467
        count = ReadDataBlock(buf___1, fp);
        }
#line 467
        if (! (count > 0)) {
#line 467
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 474
      return (-2);
    }
#line 477
    incode = code;
#line 479
    if (code >= max_code) {
#line 480
      tmp___0 = sp;
#line 480
      sp ++;
#line 480
      *tmp___0 = firstcode;
#line 481
      code = oldcode;
    }
    {
#line 484
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 484
      if (! (code >= clear_code)) {
#line 484
        goto while_break___6;
      }
#line 485
      tmp___1 = sp;
#line 485
      sp ++;
#line 485
      *tmp___1 = table[1][code];
#line 486
      if (code == table[0][code]) {
        {
#line 487
        (*GIFError)("GIF/LZW error: circular table entry");
        }
      }
#line 488
      code = table[0][code];
    }
    while_break___6: /* CIL Label */ ;
    }
#line 491
    tmp___2 = sp;
#line 491
    sp ++;
#line 491
    firstcode = table[1][code];
#line 491
    *tmp___2 = firstcode;
#line 493
    code = max_code;
#line 493
    if (code < 1 << 12) {
#line 494
      table[0][code] = oldcode;
#line 495
      table[1][code] = firstcode;
#line 496
      max_code ++;
#line 497
      if (max_code >= max_code_size) {
#line 497
        if (max_code_size < 1 << 12) {
#line 499
          max_code_size *= 2;
#line 500
          code_size ++;
        }
      }
    }
#line 504
    oldcode = incode;
#line 506
    if ((unsigned long )sp > (unsigned long )(stack)) {
#line 507
      sp --;
#line 507
      return (*sp);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 509
  return (code);
}
}
#line 513 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void ReadImageData(struct GIFImage *image , FILE *fp ) 
{ 
  int minCodeSize ;
  int interlaced ;
  int val ;
  int pass ;
  unsigned int width ;
  unsigned int height ;
  unsigned int numColors ;
  unsigned int xpos ;
  unsigned int ypos ;
  unsigned char **rows ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 522
  minCodeSize = _IO_getc(fp);
  }
#line 522
  if (minCodeSize == -1) {
    {
#line 522
    (*GIFError)(ErrRead);
    }
  }
#line 523
  if (minCodeSize >= 12) {
    {
#line 524
    (*GIFError)("GIF/LZW error: invalid LZW code size");
    }
  }
  {
#line 526
  tmp = LZWReadByte(1, minCodeSize, fp);
  }
#line 526
  if (tmp < 0) {
    {
#line 527
    (*GIFError)("Error reading GIF image");
    }
  }
#line 530
  rows = image->Rows;
#line 531
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
    {
#line 535
    SkipDataBlocks(fp);
    }
#line 541
    return;
  }
  {
#line 544
  width = image->Width;
#line 545
  height = image->Height;
#line 546
  interlaced = (int )image->InterlaceFlag;
#line 547
  GIFGetColorTable(image, & numColors);
#line 548
  ypos = 0U;
#line 548
  xpos = ypos;
#line 549
  pass = 0;
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 550
    val = LZWReadByte(0, minCodeSize, fp);
    }
#line 550
    if (! (val >= 0)) {
#line 550
      goto while_break;
    }
#line 552
    if ((unsigned int )val >= numColors) {
      {
#line 554
      (*GIFWarning)("Pixel value out of range");
#line 555
      val = (int )(numColors - 1U);
      }
    }
#line 557
    *(*(rows + ypos) + xpos) = (unsigned char )val;
#line 558
    xpos ++;
#line 558
    if (xpos == width) {
#line 560
      xpos = 0U;
#line 561
      if (interlaced) {
        {
#line 566
        if (pass == 1) {
#line 566
          goto case_1;
        }
#line 566
        if (pass == 0) {
#line 566
          goto case_1;
        }
#line 569
        if (pass == 2) {
#line 569
          goto case_2;
        }
#line 572
        if (pass == 3) {
#line 572
          goto case_3;
        }
#line 563
        goto switch_break;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 567
        ypos += 8U;
#line 568
        goto switch_break;
        case_2: /* CIL Label */ 
#line 570
        ypos += 4U;
#line 571
        goto switch_break;
        case_3: /* CIL Label */ 
#line 573
        ypos += 2U;
#line 574
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 576
        if (ypos >= height) {
#line 578
          pass ++;
          {
#line 580
          if (pass == 1) {
#line 580
            goto case_1___0;
          }
#line 583
          if (pass == 2) {
#line 583
            goto case_2___0;
          }
#line 586
          if (pass == 3) {
#line 586
            goto case_3___0;
          }
#line 589
          goto switch_default;
          case_1___0: /* CIL Label */ 
#line 581
          ypos = 4U;
#line 582
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
#line 584
          ypos = 2U;
#line 585
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
#line 587
          ypos = 1U;
#line 588
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 590
          goto fini;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 595
        ypos ++;
      }
    }
#line 597
    if (ypos >= height) {
#line 598
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  fini: 
  {
#line 602
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 602
    tmp___0 = LZWReadByte(0, minCodeSize, fp);
    }
#line 602
    if (! (tmp___0 >= 0)) {
#line 602
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 604
  return;
}
}
#line 611 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void GIFGetGraphicCtl(struct GIFExtension *ext , struct GIFGraphicCtlExt *graphicExt ) 
{ 
  unsigned char *buf___1 ;

  {
#line 614
  buf___1 = ext->Buffer;
#line 616
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 617
    return;
  }
#line 618
  if ((int )ext->Label != 249) {
    {
#line 620
    (*GIFWarning)("Not a graphic control extension");
    }
#line 621
    return;
  }
#line 623
  if (ext->BufferSize < 4U) {
    {
#line 625
    (*GIFWarning)("Broken graphic control extension");
    }
#line 626
    return;
  }
#line 629
  graphicExt->DisposalMethod = (unsigned int )(((int )*(buf___1 + 0) >> 2) & 7);
#line 630
  graphicExt->InputFlag = (unsigned int )(((int )*(buf___1 + 0) >> 1) & 1);
#line 631
  graphicExt->TransparentFlag = (unsigned int )((int )*(buf___1 + 0) & 1);
#line 632
  graphicExt->DelayTime = (unsigned int )((int )*((buf___1 + 1) + 0) + ((int )*((buf___1 + 1) + 1) << 8));
#line 633
  graphicExt->Transparent = (unsigned int )*(buf___1 + 3);
#line 634
  return;
}
}
#line 645 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static unsigned char DefaultColorTable[24]  = 
#line 645
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0};
#line 660 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
unsigned char *GIFGetColorTable(struct GIFImage *image , unsigned int *numColors ) 
{ 
  struct GIFScreen *screen ;

  {
#line 665
  if (image->LocalColorFlag) {
#line 667
    *numColors = image->LocalNumColors;
#line 668
    return (image->LocalColorTable);
  }
#line 671
  screen = image->Screen;
#line 672
  if (screen->GlobalColorFlag) {
#line 674
    *numColors = screen->GlobalNumColors;
#line 675
    return (screen->GlobalColorTable);
  }
#line 678
  *numColors = (unsigned int )(sizeof(DefaultColorTable) / 3UL);
#line 679
  return (DefaultColorTable);
}
}
#line 687 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void GIFDefaultError(char const   *msg___0 ) 
{ 


  {
  {
#line 689
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg___0);
#line 690
  exit(1);
  }
}
}
#line 693 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
static void GIFDefaultWarning(char const   *msg___0 ) 
{ 


  {
  {
#line 695
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg___0);
  }
#line 696
  return;
}
}
#line 698 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void (*GIFError)(char const   *msg )  =    & GIFDefaultError;
#line 701 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/lib/pngxtern/gif/gifread.c"
void (*GIFWarning)(char const   *msg )  =    & GIFDefaultWarning;
#line 125 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 124 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.h"
char *string_lower(char *str ) ;
#line 136
char *string_upper(char *str ) ;
#line 146
int string_prefix_cmp(char const   *str , char const   *prefix ) ;
#line 147
int string_prefix_case_cmp(char const   *str , char const   *prefix ) ;
#line 157
int string_prefix_min_cmp(char const   *str , char const   *prefix , size_t minlen ) ;
#line 158
int string_prefix_min_case_cmp(char const   *str , char const   *prefix , size_t minlen ) ;
#line 168
int string_suffix_cmp(char const   *str , char const   *suffix ) ;
#line 169
int string_suffix_case_cmp(char const   *str , char const   *suffix ) ;
#line 82 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
char *string_lower(char *str ) 
{ 
  char *sptr ;
  int tmp ;

  {
#line 86
  sptr = str;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((int )*sptr != 0)) {
#line 86
      goto while_break;
    }
    {
#line 87
    tmp = tolower((int )*sptr);
#line 87
    *sptr = (char )tmp;
#line 86
    sptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (str);
}
}
#line 97 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
char *string_upper(char *str ) 
{ 
  char *sptr ;
  int tmp ;

  {
#line 101
  sptr = str;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((int )*sptr != 0)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp = toupper((int )*sptr);
#line 102
    *sptr = (char )tmp;
#line 101
    sptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (str);
}
}
#line 111 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_prefix_cmp(char const   *str , char const   *prefix ) 
{ 
  int cs ;
  int cp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    tmp___0 = prefix;
#line 115
    prefix ++;
#line 115
    cp = (int )*tmp___0;
#line 115
    if (! (cp != 0)) {
#line 115
      goto while_break;
    }
#line 117
    tmp = str;
#line 117
    str ++;
#line 117
    cs = (int )*tmp;
#line 117
    if (cs == 0) {
#line 118
      return (-1);
    }
#line 119
    if (cs < cp) {
#line 120
      return (-1);
    }
#line 121
    if (cs > cp) {
#line 122
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (0);
}
}
#line 131 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_prefix_case_cmp(char const   *str , char const   *prefix ) 
{ 
  int cs ;
  int cp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    tmp___0 = prefix;
#line 135
    prefix ++;
#line 135
    cp = toupper((int )*tmp___0);
    }
#line 135
    if (! (cp != 0)) {
#line 135
      goto while_break;
    }
    {
#line 137
    tmp = str;
#line 137
    str ++;
#line 137
    cs = toupper((int )*tmp);
    }
#line 137
    if (cs == 0) {
#line 138
      return (-1);
    }
#line 139
    if (cs < cp) {
#line 140
      return (-1);
    }
#line 141
    if (cs > cp) {
#line 142
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (0);
}
}
#line 151 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_prefix_min_cmp(char const   *str , char const   *prefix , size_t minlen ) 
{ 
  int cs ;
  int cp ;
  size_t matchlen ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 156
  matchlen = (size_t )0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    tmp___1 = prefix;
#line 157
    prefix ++;
#line 157
    cp = (int )*tmp___1;
#line 157
    if (! (cp != 0)) {
#line 157
      goto while_break;
    }
#line 159
    tmp = str;
#line 159
    str ++;
#line 159
    cs = (int )*tmp;
#line 159
    if (cs == 0) {
#line 160
      return (-1);
    }
#line 161
    if (cs == cp) {
#line 162
      matchlen ++;
    } else {
#line 164
      if (cs < cp) {
#line 164
        tmp___0 = -1;
      } else {
#line 164
        tmp___0 = 1;
      }
#line 164
      return (tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (matchlen >= minlen) {
#line 166
    tmp___2 = 0;
  } else {
#line 166
    tmp___2 = 1;
  }
#line 166
  return (tmp___2);
}
}
#line 173 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_prefix_min_case_cmp(char const   *str , char const   *prefix , size_t minlen ) 
{ 
  int cs ;
  int cp ;
  size_t matchlen ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 179
  matchlen = (size_t )0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    tmp___1 = prefix;
#line 180
    prefix ++;
#line 180
    cp = toupper((int )*tmp___1);
    }
#line 180
    if (! (cp != 0)) {
#line 180
      goto while_break;
    }
    {
#line 182
    tmp = str;
#line 182
    str ++;
#line 182
    cs = toupper((int )*tmp);
    }
#line 182
    if (cs == 0) {
#line 183
      return (-1);
    }
#line 184
    if (cs == cp) {
#line 185
      matchlen ++;
    } else {
#line 187
      if (cs < cp) {
#line 187
        tmp___0 = -1;
      } else {
#line 187
        tmp___0 = 1;
      }
#line 187
      return (tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (matchlen >= minlen) {
#line 189
    tmp___2 = 0;
  } else {
#line 189
    tmp___2 = 1;
  }
#line 189
  return (tmp___2);
}
}
#line 196 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_suffix_cmp(char const   *str , char const   *suffix ) 
{ 
  size_t str_len ;
  size_t suffix_len ;
  int tmp ;

  {
  {
#line 200
  str_len = strlen(str);
#line 201
  suffix_len = strlen(suffix);
  }
#line 202
  if (str_len < suffix_len) {
#line 203
    return (-1);
  }
  {
#line 204
  tmp = strcmp((str + str_len) - suffix_len, suffix);
  }
#line 204
  return (tmp);
}
}
#line 211 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/strutil.c"
int string_suffix_case_cmp(char const   *str , char const   *suffix ) 
{ 
  size_t str_len ;
  size_t suffix_len ;
  int tmp ;

  {
  {
#line 215
  str_len = strlen(str);
#line 216
  suffix_len = strlen(suffix);
  }
#line 217
  if (str_len < suffix_len) {
#line 218
    return (-1);
  }
  {
#line 219
  tmp = strcasecmp((str + str_len) - suffix_len, suffix);
  }
#line 219
  return (tmp);
}
}
#line 731 "/usr/include/stdio.h"
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 44 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 26 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.h"
int osys_fattr_cpy(char const   *destname , char const   *srcname ) ;
#line 34
char *osys_fname_mkbak(char *buffer , size_t bufsize___0 , char const   *fname ) ;
#line 45
char *osys_fname_chext(char *buffer , size_t bufsize___0 , char const   *oldname ,
                       char const   *newext ) ;
#line 56
int osys_fname_cmp(char const   *name1 , char const   *name2 ) ;
#line 66
size_t osys_fread_at(FILE *stream , long offset , int whence , void *block , size_t blocksize ) ;
#line 77
size_t osys_fwrite_at(FILE *stream , long offset , int whence , void const   *block ,
                      size_t blocksize ) ;
#line 76 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
int osys_fattr_cpy(char const   *destname , char const   *srcname ) 
{ 
  struct stat sbuf ;
  int mode ;
  struct utimbuf utbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp = stat((char const   */* __restrict  */)srcname, (struct stat */* __restrict  */)(& sbuf));
  }
#line 84
  if (tmp != 0) {
#line 85
    return (-1);
  }
  {
#line 87
  mode = (int )sbuf.st_mode;
#line 88
  utbuf.actime = sbuf.st_atim.tv_sec;
#line 89
  utbuf.modtime = sbuf.st_mtim.tv_sec;
#line 91
  tmp___0 = utime(destname, (struct utimbuf  const  *)(& utbuf));
  }
#line 91
  if (tmp___0 == 0) {
    {
#line 91
    tmp___1 = chmod(destname, (__mode_t )mode);
    }
#line 91
    if (tmp___1 == 0) {
#line 92
      return (0);
    } else {
#line 94
      return (-1);
    }
  } else {
#line 94
    return (-1);
  }
}
}
#line 136 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
char *osys_fname_mkbak(char *buffer , size_t bufsize___0 , char const   *fname ) 
{ 
  size_t tmp ;

  {
  {
#line 138
  tmp = strlen(fname);
  }
#line 138
  if (tmp + sizeof(".bak") > bufsize___0) {
#line 139
    return ((char *)((void *)0));
  }
  {
#line 147
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)fname);
#line 148
  strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)".bak");
  }
#line 149
  return (buffer);
}
}
#line 163 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
char *osys_fname_chext(char *buffer , size_t bufsize___0 , char const   *oldname ,
                       char const   *newext ) 
{ 
  size_t i ;
  size_t pos ;
  char tmp ;
  char tmp___0 ;

  {
#line 168
  if ((int const   )*(newext + 0) != 46) {
#line 169
    return ((char *)((void *)0));
  }
#line 170
  i = (size_t )0;
#line 170
  pos = (size_t )-1;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((int const   )*(oldname + i) != 0)) {
#line 170
      goto while_break;
    }
#line 172
    if (i >= bufsize___0) {
#line 173
      return ((char *)((void *)0));
    }
#line 174
    tmp = (char )*(oldname + i);
#line 174
    *(buffer + i) = tmp;
#line 174
    if ((int )tmp == 46) {
#line 175
      pos = i;
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (i > pos) {
#line 178
    i = pos;
  }
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (i >= bufsize___0) {
#line 182
      return ((char *)((void *)0));
    }
#line 183
    tmp___0 = (char )*newext;
#line 183
    *(buffer + i) = tmp___0;
#line 183
    if ((int )tmp___0 == 0) {
#line 184
      return (buffer);
    }
#line 179
    i ++;
#line 179
    newext ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 196 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
int osys_fname_cmp(char const   *name1 , char const   *name2 ) 
{ 
  int tmp ;

  {
  {
#line 205
  tmp = strcmp(name1, name2);
  }
#line 205
  return (tmp);
}
}
#line 217 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
size_t osys_fread_at(FILE *stream , long offset , int whence , void *block , size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 223
  tmp = fflush(stream);
  }
#line 223
  if (tmp != 0) {
#line 225
    return ((size_t )0);
  } else
#line 223
  if ((unsigned long )block == (unsigned long )((void *)0)) {
#line 225
    return ((size_t )0);
  } else
#line 223
  if (blocksize == 0UL) {
#line 225
    return ((size_t )0);
  } else {
    {
#line 223
    tmp___0 = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
    }
#line 223
    if (tmp___0 != 0) {
#line 225
      return ((size_t )0);
    }
  }
  {
#line 226
  tmp___1 = fseek(stream, offset, whence);
  }
#line 226
  if (tmp___1 == 0) {
    {
#line 227
    result = fread((void */* __restrict  */)block, (size_t )1, blocksize, (FILE */* __restrict  */)stream);
    }
  } else {
#line 229
    result = (size_t )0;
  }
  {
#line 230
  tmp___2 = fflush(stream);
  }
#line 230
  if (tmp___2 != 0) {
#line 230
    result = (size_t )0;
  }
  {
#line 231
  tmp___3 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 231
  if (tmp___3 != 0) {
#line 231
    result = (size_t )0;
  }
  {
#line 232
  tmp___4 = fflush(stream);
  }
#line 232
  if (tmp___4 != 0) {
#line 232
    result = (size_t )0;
  }
#line 233
  return (result);
}
}
#line 244 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/osys.c"
size_t osys_fwrite_at(FILE *stream , long offset , int whence , void const   *block ,
                      size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 250
  tmp = fflush(stream);
  }
#line 250
  if (tmp != 0) {
#line 252
    return ((size_t )0);
  } else
#line 250
  if ((unsigned long )block == (unsigned long )((void *)0)) {
#line 252
    return ((size_t )0);
  } else
#line 250
  if (blocksize == 0UL) {
#line 252
    return ((size_t )0);
  } else {
    {
#line 250
    tmp___0 = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
    }
#line 250
    if (tmp___0 != 0) {
#line 252
      return ((size_t )0);
    }
  }
  {
#line 253
  tmp___1 = fseek(stream, offset, whence);
  }
#line 253
  if (tmp___1 == 0) {
    {
#line 254
    result = fwrite((void const   */* __restrict  */)block, (size_t )1, blocksize,
                    (FILE */* __restrict  */)stream);
    }
  } else {
#line 256
    result = (size_t )0;
  }
  {
#line 257
  tmp___2 = fflush(stream);
  }
#line 257
  if (tmp___2 != 0) {
#line 257
    result = (size_t )0;
  }
  {
#line 258
  tmp___3 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 258
  if (tmp___3 != 0) {
#line 258
    result = (size_t )0;
  }
  {
#line 259
  tmp___4 = fflush(stream);
  }
#line 259
  if (tmp___4 != 0) {
#line 259
    result = (size_t )0;
  }
#line 260
  return (result);
}
}
#line 57 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.h"
int bitset_count(bitset_t set ) ;
#line 70
bitset_t string_to_bitset(char const   *str , char **end_ptr ) ;
#line 80
char *bitset_to_string(bitset_t set , char *str_buf , size_t str_buf_size ) ;
#line 102
int bitset_parse(char const   *text , bitset_t *out_bitset ) ;
#line 42 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.c"
int bitset_count(bitset_t set ) 
{ 
  int result ;
  unsigned int i ;

  {
#line 47
  if (set < 0) {
#line 48
    return (-1);
  }
#line 50
  result = 0;
#line 51
  i = 0U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((unsigned long )i < 8UL * sizeof(bitset_t ) - 1UL)) {
#line 51
      goto while_break;
    }
#line 52
    if ((set & (1 << i)) != 0) {
#line 53
      result ++;
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (result);
}
}
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.c"
bitset_t string_to_bitset(char const   *str , char **end_ptr ) 
{ 
  bitset_t result ;
  char const   *ptr ;
  int overflow ;
  unsigned short const   **tmp ;

  {
#line 69
  ptr = str;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp = __ctype_b_loc();
    }
#line 70
    if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 70
      goto while_break;
    }
#line 70
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((int const   )*ptr != 48) {
#line 71
    if ((int const   )*ptr != 49) {
#line 73
      if ((unsigned long )end_ptr != (unsigned long )((void *)0)) {
#line 74
        *end_ptr = (char *)str;
      }
#line 75
      return (0);
    }
  }
#line 78
  result = 0;
#line 79
  overflow = 0;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if ((int const   )*ptr == 48) {
#line 82
      goto _L;
    } else
#line 82
    if ((int const   )*ptr == 49) {
      _L: /* CIL Label */ 
#line 84
      result = (result << 1) | (int )((int const   )*ptr - 48);
#line 85
      if (result < 0) {
#line 86
        overflow = 1;
      }
    } else {
#line 90
      if ((unsigned long )end_ptr != (unsigned long )((void *)0)) {
#line 91
        *end_ptr = (char *)ptr;
      }
#line 92
      if (overflow) {
#line 93
        result |= 1 << (8UL * sizeof(bitset_t ) - 1UL);
      }
#line 94
      return (result);
    }
#line 80
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 103 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.c"
char *bitset_to_string(bitset_t set , char *str_buf , size_t str_buf_size ) 
{ 
  char *ptr ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 110
  i = (int )((8UL * sizeof(bitset_t ) - 1UL) - 1UL);
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i > 0)) {
#line 110
      goto while_break;
    }
#line 111
    if ((set & (1 << i)) != 0) {
#line 112
      goto while_break;
    }
#line 110
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if ((size_t )(i + 1) >= str_buf_size) {
#line 114
    return ((char *)((void *)0));
  }
#line 116
  ptr = str_buf;
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    if (! (i >= 0)) {
#line 117
      goto while_break___0;
    }
#line 120
    tmp = ptr;
#line 120
    ptr ++;
#line 120
    if ((set & (1 << i)) != 0) {
#line 120
      tmp___0 = '1';
    } else {
#line 120
      tmp___0 = '0';
    }
#line 120
    *tmp = (char )tmp___0;
#line 117
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  *ptr = (char)0;
#line 123
  return (str_buf);
}
}
#line 130 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/cbitset.c"
int bitset_parse(char const   *text , bitset_t *out_bitset ) 
{ 
  unsigned int num1 ;
  unsigned int num2 ;
  unsigned int i ;
  int is_range ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 138
  *out_bitset = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 141
      tmp = __ctype_b_loc();
      }
#line 141
      if (! ((int const   )*(*tmp + (int )*text) & 8192)) {
#line 141
        goto while_break___0;
      }
#line 141
      text ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 142
    if ((int const   )*text == 0) {
#line 143
      return (0);
    }
#line 145
    num1 = 4294967295U;
#line 146
    num2 = 0U;
#line 147
    is_range = 0;
    {
#line 148
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 148
      if ((int const   )*text >= 48) {
#line 148
        if (! ((int const   )*text <= 57)) {
#line 148
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 148
      if (! ((int const   )*text == 45)) {
#line 148
        goto while_break___1;
      }
#line 150
      if ((int const   )*text == 45) {
#line 152
        is_range = 1;
#line 153
        if (num1 == 4294967295U) {
#line 154
          num1 = 0U;
        }
#line 155
        num2 = (unsigned int )((8UL * sizeof(bitset_t ) - 1UL) - 1UL);
#line 156
        text ++;
      } else {
#line 160
        num2 = 0U;
        {
#line 160
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 160
          if ((int const   )*text >= 48) {
#line 160
            if (! ((int const   )*text <= 57)) {
#line 160
              goto while_break___2;
            }
          } else {
#line 160
            goto while_break___2;
          }
#line 162
          num2 = 10U * num2 + (unsigned int )((int const   )*text - 48);
#line 163
          if ((unsigned long )num2 > 8UL * sizeof(bitset_t ) - 1UL) {
#line 164
            num2 = (unsigned int )(8UL * sizeof(bitset_t ) - 1UL);
          }
#line 160
          text ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 166
        if (! is_range) {
#line 167
          num1 = num2;
        }
      }
      {
#line 169
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 169
        tmp___0 = __ctype_b_loc();
        }
#line 169
        if (! ((int const   )*(*tmp___0 + (int )*text) & 8192)) {
#line 169
          goto while_break___3;
        }
#line 169
        text ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 172
    if ((unsigned long )num2 >= 8UL * sizeof(bitset_t ) - 1UL) {
#line 174
      num2 = (unsigned int )((8UL * sizeof(bitset_t ) - 1UL) - 1UL);
#line 175
      *out_bitset |= 1 << (8UL * sizeof(bitset_t ) - 1UL);
    }
#line 177
    i = num1;
    {
#line 177
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 177
      if (! (i <= num2)) {
#line 177
        goto while_break___4;
      }
#line 178
      *out_bitset |= 1 << i;
#line 177
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 180
    if ((int const   )*text == 0) {
#line 181
      return (0);
    }
#line 182
    if ((int const   )*text != 44) {
#line 182
      if ((int const   )*text != 59) {
#line 183
        return (-1);
      }
    }
#line 139
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 99 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opng.h"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) ;
#line 108
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) ;
#line 53 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) 
{ 
  int result ;
  int error ;

  {
#line 56
  result = 1;
#line 56
  error = 0;
#line 60
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 61
    return (0);
  } else
#line 60
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 61
    return (0);
  }
#line 65
  if (info_ptr->width > 0UL) {
#line 65
    if (info_ptr->height > 0UL) {
#line 67
      if (info_ptr->width > 2147483647UL) {
#line 71
        error = 1;
      } else
#line 67
      if (info_ptr->height > 2147483647UL) {
#line 71
        error = 1;
      } else
#line 67
      if ((int )info_ptr->bit_depth == 0) {
#line 71
        error = 1;
      } else
#line 67
      if ((int )info_ptr->bit_depth > 16) {
#line 71
        error = 1;
      } else
#line 67
      if ((int )info_ptr->interlace_type >= 2) {
#line 71
        error = 1;
      }
    } else {
#line 74
      result = 0;
    }
  } else {
#line 74
    result = 0;
  }
#line 77
  if ((int )info_ptr->color_type & 1) {
#line 79
    if (info_ptr->valid & 8UL) {
#line 81
      if ((unsigned long )info_ptr->palette == (unsigned long )((void *)0)) {
#line 82
        error = 1;
      } else
#line 81
      if ((int )info_ptr->num_palette == 0) {
#line 82
        error = 1;
      }
    } else {
#line 85
      result = 0;
    }
  }
#line 89
  if (info_ptr->valid & 32768UL) {
#line 91
    if ((unsigned long )info_ptr->row_pointers == (unsigned long )((void *)0)) {
#line 92
      error = 1;
    }
  } else {
#line 95
    result = 0;
  }
#line 97
  if (error) {
    {
#line 98
    png_error(png_ptr, "Inconsistent data in libpng");
    }
  }
#line 99
  return (result);
}
}
#line 129 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
static int opng_insert_palette_entry(png_colorp palette , int *num_palette , png_bytep trans ,
                                     int *num_trans , int max_tuples , unsigned int red ,
                                     unsigned int green , unsigned int blue , unsigned int alpha ,
                                     int *index___0 ) 
{ 
  int low ;
  int high ;
  int mid ;
  int cmp ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 137
  if (*num_palette >= 0) {
#line 137
    if (! (*num_palette <= max_tuples)) {
      {
#line 137
      __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    137U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 137
    __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  137U, "opng_insert_palette_entry");
    }
  }
#line 138
  if (*num_trans >= 0) {
#line 138
    if (! (*num_trans <= *num_palette)) {
      {
#line 138
      __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    138U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 138
    __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  138U, "opng_insert_palette_entry");
    }
  }
#line 141
  if (alpha < 255U) {
#line 143
    low = 0;
#line 144
    high = *num_trans - 1;
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
#line 145
      if (! (low <= high)) {
#line 145
        goto while_break;
      }
#line 147
      mid = (low + high) / 2;
#line 148
      if ((int )alpha != (int )*(trans + mid)) {
#line 148
        cmp = (int )alpha - (int )*(trans + mid);
      } else {
#line 148
        if ((int )red != (int )(palette + mid)->red) {
#line 148
          tmp___2 = (int )red - (int )(palette + mid)->red;
        } else {
#line 148
          if ((int )green != (int )(palette + mid)->green) {
#line 148
            tmp___1 = (int )green - (int )(palette + mid)->green;
          } else {
#line 148
            tmp___1 = (int )blue - (int )(palette + mid)->blue;
          }
#line 148
          tmp___2 = tmp___1;
        }
#line 148
        cmp = tmp___2;
      }
#line 151
      if (cmp < 0) {
#line 152
        high = mid - 1;
      } else
#line 153
      if (cmp > 0) {
#line 154
        low = mid + 1;
      } else {
#line 157
        *index___0 = mid;
#line 158
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 164
    low = *num_trans;
#line 165
    high = *num_palette - 1;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! (low <= high)) {
#line 166
        goto while_break___0;
      }
#line 168
      mid = (low + high) / 2;
#line 169
      if ((int )red != (int )(palette + mid)->red) {
#line 169
        cmp = (int )red - (int )(palette + mid)->red;
      } else {
#line 169
        if ((int )green != (int )(palette + mid)->green) {
#line 169
          tmp___3 = (int )green - (int )(palette + mid)->green;
        } else {
#line 169
          tmp___3 = (int )blue - (int )(palette + mid)->blue;
        }
#line 169
        cmp = tmp___3;
      }
#line 171
      if (cmp < 0) {
#line 172
        high = mid - 1;
      } else
#line 173
      if (cmp > 0) {
#line 174
        low = mid + 1;
      } else {
#line 177
        *index___0 = mid;
#line 178
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 184
  if (*num_palette + 1 == max_tuples) {
#line 186
    tmp___5 = -1;
#line 186
    *index___0 = tmp___5;
#line 186
    tmp___4 = tmp___5;
#line 186
    *num_trans = tmp___4;
#line 186
    *num_palette = tmp___4;
#line 187
    return (-1);
  }
#line 191
  if (low >= 0) {
#line 191
    if (! (low <= *num_palette)) {
      {
#line 191
      __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    191U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 191
    __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  191U, "opng_insert_palette_entry");
    }
  }
#line 192
  i = *num_palette;
  {
#line 192
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 192
    if (! (i > low)) {
#line 192
      goto while_break___1;
    }
#line 193
    *(palette + i) = *(palette + (i - 1));
#line 192
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 194
  (palette + low)->red = (png_byte )red;
#line 195
  (palette + low)->green = (png_byte )green;
#line 196
  (palette + low)->blue = (png_byte )blue;
#line 197
  (*num_palette) ++;
#line 198
  if (alpha < 255U) {
#line 200
    if (! (low <= *num_trans)) {
      {
#line 200
      __assert_fail("low <= *num_trans", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    200U, "opng_insert_palette_entry");
      }
    }
#line 201
    i = *num_trans;
    {
#line 201
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 201
      if (! (i > low)) {
#line 201
        goto while_break___2;
      }
#line 202
      *(trans + i) = *(trans + (i - 1));
#line 201
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 203
    *(trans + low) = (png_byte )alpha;
#line 204
    (*num_trans) ++;
  }
#line 206
  return (1);
}
}
#line 213 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
static void opng_get_alpha_row(png_structp png_ptr , png_infop info_ptr , png_bytep row ,
                               png_bytep alpha_row ) 
{ 
  png_bytep sample_ptr ;
  png_uint_32 width ;
  png_uint_32 i ;
  unsigned int channels ;
  png_color_16 *trans_values ;
  png_byte trans_red ;
  png_byte trans_green ;
  png_byte trans_blue ;
  int tmp___1 ;
  png_byte trans_gray ;
  int tmp___3 ;

  {
#line 222
  if (! ((int )info_ptr->bit_depth == 8)) {
    {
#line 222
    __assert_fail("info_ptr->bit_depth == 8", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  222U, "opng_get_alpha_row");
    }
  }
#line 223
  if (! (! ((int )info_ptr->color_type & 1))) {
    {
#line 223
    __assert_fail("!(info_ptr->color_type & 1)", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  223U, "opng_get_alpha_row");
    }
  }
#line 225
  width = info_ptr->width;
#line 226
  if (! ((int )info_ptr->color_type & 4)) {
#line 228
    if (! (info_ptr->valid & 16UL)) {
      {
#line 230
      memset((void *)alpha_row, 255, width);
      }
#line 231
      return;
    }
#line 233
    trans_values = & info_ptr->trans_values;
#line 234
    if ((int )info_ptr->color_type == 2) {
#line 236
      trans_red = (png_byte )trans_values->red;
#line 237
      trans_green = (png_byte )trans_values->green;
#line 238
      trans_blue = (png_byte )trans_values->blue;
#line 239
      i = (png_uint_32 )0;
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! (i < width)) {
#line 239
          goto while_break;
        }
#line 240
        if ((int )*(row + 3UL * i) == (int )trans_red) {
#line 240
          if ((int )*(row + (3UL * i + 1UL)) == (int )trans_green) {
#line 240
            if ((int )*(row + (3UL * i + 2UL)) == (int )trans_blue) {
#line 240
              tmp___1 = 0;
            } else {
#line 240
              tmp___1 = 255;
            }
          } else {
#line 240
            tmp___1 = 255;
          }
        } else {
#line 240
          tmp___1 = 255;
        }
#line 240
        *(alpha_row + i) = (png_byte )tmp___1;
#line 239
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 246
      trans_gray = (png_byte )trans_values->gray;
#line 247
      if (! ((int )info_ptr->color_type == 0)) {
        {
#line 247
        __assert_fail("info_ptr->color_type == 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                      247U, "opng_get_alpha_row");
        }
      }
#line 248
      i = (png_uint_32 )0;
      {
#line 248
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 248
        if (! (i < width)) {
#line 248
          goto while_break___0;
        }
#line 249
        if ((int )*(row + i) == (int )trans_gray) {
#line 249
          tmp___3 = 0;
        } else {
#line 249
          tmp___3 = 255;
        }
#line 249
        *(alpha_row + i) = (png_byte )tmp___3;
#line 248
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 251
    return;
  }
#line 255
  if ((int )png_ptr->usr_channels > 0) {
#line 255
    channels = (unsigned int )png_ptr->usr_channels;
  } else {
#line 255
    channels = (unsigned int )info_ptr->channels;
  }
#line 257
  sample_ptr = row;
#line 258
  if (! (png_ptr->transformations & 32768UL)) {
#line 260
    sample_ptr += channels - 1U;
  } else
#line 258
  if (png_ptr->flags & 128UL) {
#line 260
    sample_ptr += channels - 1U;
  }
#line 261
  i = (png_uint_32 )0;
  {
#line 261
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 261
    if (! (i < width)) {
#line 261
      goto while_break___1;
    }
#line 262
    *alpha_row = *sample_ptr;
#line 261
    i ++;
#line 261
    sample_ptr += channels;
#line 261
    alpha_row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 271 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_analyze_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep component_ptr ;
  png_uint_32 height ;
  png_uint_32 width ;
  png_uint_32 i ;
  png_uint_32 j ;
  unsigned int bit_depth ;
  unsigned int byte_depth ;
  unsigned int color_type ;
  unsigned int channels ;
  unsigned int sample_size ;
  unsigned int offset_color ;
  unsigned int offset_alpha ;
  png_color_16p background ;

  {
#line 283
  bit_depth = (unsigned int )info_ptr->bit_depth;
#line 284
  if (bit_depth < 8U) {
#line 285
    return ((png_uint_32 )0);
  }
#line 287
  color_type = (unsigned int )info_ptr->color_type;
#line 288
  if (color_type & 1U) {
#line 289
    return ((png_uint_32 )0);
  }
#line 291
  byte_depth = bit_depth / 8U;
#line 292
  if ((int )png_ptr->usr_channels > 0) {
#line 292
    channels = (unsigned int )png_ptr->usr_channels;
  } else {
#line 292
    channels = (unsigned int )info_ptr->channels;
  }
#line 294
  sample_size = channels * byte_depth;
#line 297
  reductions &= 0xfffffffffffffc9dUL;
#line 301
  if (bit_depth <= 8U) {
#line 302
    reductions &= 0xfffffffffffffffeUL;
  }
#line 303
  if (! (color_type & 2U)) {
#line 304
    reductions &= 0xffffffffffffffefUL;
  }
#line 305
  if (! (color_type & 4U)) {
#line 306
    reductions &= 0xffffffffffffff7fUL;
  }
#line 308
  offset_alpha = 0U;
#line 308
  offset_color = offset_alpha;
#line 309
  if (png_ptr->transformations & 32768UL) {
#line 309
    if (! (png_ptr->flags & 128UL)) {
#line 311
      offset_color = byte_depth;
    } else {
#line 313
      offset_alpha = (channels - 1U) * byte_depth;
    }
  } else {
#line 313
    offset_alpha = (channels - 1U) * byte_depth;
  }
#line 316
  if (reductions & 16UL) {
#line 316
    if (info_ptr->valid & 32UL) {
#line 319
      background = & info_ptr->background;
#line 320
      if ((int )background->red != (int )background->green) {
#line 322
        reductions &= 0xffffffffffffffefUL;
      } else
#line 320
      if ((int )background->red != (int )background->blue) {
#line 322
        reductions &= 0xffffffffffffffefUL;
      }
    }
  }
#line 326
  row_ptr = info_ptr->row_pointers;
#line 327
  height = info_ptr->height;
#line 328
  width = info_ptr->width;
#line 329
  i = (png_uint_32 )0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (i < height)) {
#line 329
      goto while_break;
    }
#line 331
    if (reductions == 0UL) {
#line 332
      return ((png_uint_32 )0);
    }
#line 335
    if (reductions & 1UL) {
#line 337
      component_ptr = *row_ptr;
#line 338
      j = (png_uint_32 )0;
      {
#line 338
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 338
        if (! (j < (png_uint_32 )channels * width)) {
#line 338
          goto while_break___0;
        }
#line 340
        if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 342
          reductions &= 0xfffffffffffffffeUL;
#line 343
          goto while_break___0;
        }
#line 338
        j ++;
#line 338
        component_ptr += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 348
    if (bit_depth == 8U) {
#line 351
      if (reductions & 16UL) {
#line 353
        component_ptr = *row_ptr + offset_color;
#line 354
        j = (png_uint_32 )0;
        {
#line 354
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 354
          if (! (j < width)) {
#line 354
            goto while_break___1;
          }
#line 356
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 359
            reductions &= 0xffffffffffffffefUL;
#line 360
            goto while_break___1;
          } else
#line 356
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 359
            reductions &= 0xffffffffffffffefUL;
#line 360
            goto while_break___1;
          }
#line 354
          j ++;
#line 354
          component_ptr += sample_size;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 366
      if (reductions & 128UL) {
#line 368
        component_ptr = *row_ptr + offset_alpha;
#line 369
        j = (png_uint_32 )0;
        {
#line 369
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 369
          if (! (j < width)) {
#line 369
            goto while_break___2;
          }
#line 371
          if ((int )*(component_ptr + 0) != 255) {
#line 373
            reductions &= 0xffffffffffffff7fUL;
#line 374
            goto while_break___2;
          }
#line 369
          j ++;
#line 369
          component_ptr += sample_size;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 382
      if (reductions & 16UL) {
#line 384
        component_ptr = *row_ptr + offset_color;
#line 385
        j = (png_uint_32 )0;
        {
#line 385
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 385
          if (! (j < width)) {
#line 385
            goto while_break___3;
          }
#line 387
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 392
            reductions &= 0xffffffffffffffefUL;
#line 393
            goto while_break___3;
          } else
#line 387
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 4)) {
#line 392
            reductions &= 0xffffffffffffffefUL;
#line 393
            goto while_break___3;
          } else
#line 387
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 3)) {
#line 392
            reductions &= 0xffffffffffffffefUL;
#line 393
            goto while_break___3;
          } else
#line 387
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 5)) {
#line 392
            reductions &= 0xffffffffffffffefUL;
#line 393
            goto while_break___3;
          }
#line 385
          j ++;
#line 385
          component_ptr += sample_size;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 399
      if (reductions & 128UL) {
#line 401
        component_ptr = *row_ptr + offset_alpha;
#line 402
        j = (png_uint_32 )0;
        {
#line 402
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 402
          if (! (j < width)) {
#line 402
            goto while_break___4;
          }
#line 404
          if ((int )*(component_ptr + 0) != 255) {
#line 406
            reductions &= 0xffffffffffffff7fUL;
#line 407
            goto while_break___4;
          } else
#line 404
          if ((int )*(component_ptr + 1) != 255) {
#line 406
            reductions &= 0xffffffffffffff7fUL;
#line 407
            goto while_break___4;
          }
#line 402
          j ++;
#line 402
          component_ptr += sample_size;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 329
    i ++;
#line 329
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  return (reductions);
}
}
#line 426 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_reduce_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_ptr ;
  png_bytep dest_ptr ;
  png_uint_32 height ;
  png_uint_32 width ;
  png_uint_32 i ;
  png_uint_32 j ;
  unsigned int src_bit_depth ;
  unsigned int dest_bit_depth ;
  unsigned int src_byte_depth ;
  unsigned int dest_byte_depth ;
  unsigned int src_color_type ;
  unsigned int dest_color_type ;
  unsigned int src_channels ;
  unsigned int dest_channels ;
  unsigned int src_sample_size ;
  unsigned int dest_sample_size ;
  unsigned int src_offset_alpha ;
  unsigned int tran_tbl[8] ;
  unsigned int k ;
  int tmp___3 ;
  int tmp___4 ;
  png_color_8p sig_bit_ptr ;
  png_byte max_sig_bit ;
  png_byte tmp___6 ;
  png_color_16p trans_values ;
  png_byte tmp___7 ;
  png_byte tmp___8 ;
  png_byte tmp___9 ;
  png_byte tmp___10 ;

  {
  {
#line 442
  reductions = opng_analyze_bits(png_ptr, info_ptr, reductions);
  }
#line 444
  if (png_ptr->transformations & 32768UL) {
#line 445
    reductions |= 128UL;
  }
#line 446
  if (reductions == 0UL) {
#line 447
    return ((png_uint_32 )0);
  }
#line 450
  src_bit_depth = (unsigned int )info_ptr->bit_depth;
#line 451
  if (! (src_bit_depth >= 8U)) {
    {
#line 451
    __assert_fail("src_bit_depth >= 8", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  451U, "opng_reduce_bits");
    }
  }
#line 452
  if (reductions & 1UL) {
#line 454
    if (! (src_bit_depth == 16U)) {
      {
#line 454
      __assert_fail("src_bit_depth == 16", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    454U, "opng_reduce_bits");
      }
    }
#line 455
    dest_bit_depth = 8U;
  } else {
#line 458
    dest_bit_depth = src_bit_depth;
  }
#line 460
  src_byte_depth = src_bit_depth / 8U;
#line 461
  dest_byte_depth = dest_bit_depth / 8U;
#line 463
  dest_color_type = (unsigned int )info_ptr->color_type;
#line 463
  src_color_type = dest_color_type;
#line 464
  if (reductions & 16UL) {
#line 466
    if (! (src_color_type & 2U)) {
      {
#line 466
      __assert_fail("src_color_type & 2", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    466U, "opng_reduce_bits");
      }
    }
#line 467
    dest_color_type &= 4294967293U;
  }
#line 469
  if (reductions & 128UL) {
#line 471
    if (! (src_color_type & 4U)) {
      {
#line 471
      __assert_fail("src_color_type & 4", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    471U, "opng_reduce_bits");
      }
    }
#line 472
    dest_color_type &= 4294967291U;
  }
#line 475
  if ((int )png_ptr->usr_channels > 0) {
#line 475
    src_channels = (unsigned int )png_ptr->usr_channels;
  } else {
#line 475
    src_channels = (unsigned int )info_ptr->channels;
  }
#line 477
  if (dest_color_type & 2U) {
#line 477
    tmp___3 = 3;
  } else {
#line 477
    tmp___3 = 1;
  }
#line 477
  if (dest_color_type & 4U) {
#line 477
    tmp___4 = 1;
  } else {
#line 477
    tmp___4 = 0;
  }
#line 477
  dest_channels = (unsigned int )(tmp___3 + tmp___4);
#line 481
  src_sample_size = src_channels * src_byte_depth;
#line 482
  dest_sample_size = dest_channels * dest_byte_depth;
#line 483
  if (! (src_sample_size > dest_sample_size)) {
    {
#line 483
    __assert_fail("src_sample_size > dest_sample_size", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  483U, "opng_reduce_bits");
    }
  }
#line 485
  if (! (png_ptr->transformations & 32768UL)) {
#line 487
    src_offset_alpha = (src_channels - 1U) * src_byte_depth;
  } else
#line 485
  if (png_ptr->flags & 128UL) {
#line 487
    src_offset_alpha = (src_channels - 1U) * src_byte_depth;
  } else {
#line 489
    src_offset_alpha = 0U;
  }
#line 492
  k = 0U;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (k < 4U * dest_byte_depth)) {
#line 492
      goto while_break;
    }
#line 493
    tran_tbl[k] = (k * src_bit_depth) / dest_bit_depth;
#line 492
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  if (reductions & 16UL) {
#line 496
    if (dest_color_type & 4U) {
#line 496
      if (src_offset_alpha != 0U) {
#line 500
        tran_tbl[dest_byte_depth] = tran_tbl[3U * dest_byte_depth];
#line 501
        if (dest_byte_depth == 2U) {
#line 502
          tran_tbl[dest_byte_depth + 1U] = tran_tbl[3U * dest_byte_depth + 1U];
        }
      }
    }
  }
#line 506
  if (src_channels == 2U) {
#line 506
    goto _L;
  } else
#line 506
  if (src_channels == 4U) {
    _L: /* CIL Label */ 
#line 506
    if (! (dest_color_type & 4U)) {
#line 506
      if (src_offset_alpha == 0U) {
#line 510
        k = 0U;
        {
#line 510
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 510
          if (! (k < dest_sample_size)) {
#line 510
            goto while_break___0;
          }
#line 512
          if (dest_byte_depth == 1U) {
#line 514
            tran_tbl[k] = tran_tbl[k + 1U];
#line 515
            k ++;
          } else {
#line 519
            tran_tbl[k] = tran_tbl[k + 2U];
#line 520
            tran_tbl[k + 1U] = tran_tbl[k + 3U];
#line 521
            k += 2U;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 527
  row_ptr = info_ptr->row_pointers;
#line 528
  height = info_ptr->height;
#line 529
  width = info_ptr->width;
#line 530
  i = (png_uint_32 )0;
  {
#line 530
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 530
    if (! (i < height)) {
#line 530
      goto while_break___1;
    }
#line 532
    dest_ptr = *row_ptr;
#line 532
    src_ptr = dest_ptr;
#line 533
    j = (png_uint_32 )0;
    {
#line 533
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 533
      if (! (j < width)) {
#line 533
        goto while_break___2;
      }
#line 535
      k = 0U;
      {
#line 535
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 535
        if (! (k < dest_sample_size)) {
#line 535
          goto while_break___3;
        }
#line 536
        *(dest_ptr + k) = *(src_ptr + tran_tbl[k]);
#line 535
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 537
      src_ptr += src_sample_size;
#line 538
      dest_ptr += dest_sample_size;
#line 533
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 530
    i ++;
#line 530
    row_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 543
  if (reductions & 16UL) {
#line 545
    if (info_ptr->valid & 32UL) {
#line 546
      info_ptr->background.gray = info_ptr->background.red;
    }
#line 547
    if (info_ptr->valid & 2UL) {
#line 549
      sig_bit_ptr = & info_ptr->sig_bit;
#line 550
      max_sig_bit = sig_bit_ptr->red;
#line 551
      if ((int )max_sig_bit < (int )sig_bit_ptr->green) {
#line 552
        max_sig_bit = sig_bit_ptr->green;
      }
#line 553
      if ((int )max_sig_bit < (int )sig_bit_ptr->blue) {
#line 554
        max_sig_bit = sig_bit_ptr->blue;
      }
#line 555
      tmp___6 = max_sig_bit;
#line 555
      info_ptr->sig_bit.gray = tmp___6;
#line 555
      png_ptr->sig_bit.gray = tmp___6;
    }
#line 557
    if (info_ptr->valid & 16UL) {
#line 559
      trans_values = & info_ptr->trans_values;
#line 560
      if ((int )trans_values->red == (int )trans_values->green) {
#line 562
        trans_values->gray = trans_values->red;
      } else
#line 560
      if ((int )trans_values->red == (int )trans_values->blue) {
#line 562
        trans_values->gray = trans_values->red;
      } else {
        {
#line 566
        png_free_data(png_ptr, info_ptr, (png_uint_32 )8192, -1);
#line 567
        info_ptr->valid &= 0xffffffffffffffefUL;
        }
      }
    }
  }
#line 573
  tmp___7 = (png_byte )dest_bit_depth;
#line 573
  info_ptr->bit_depth = tmp___7;
#line 573
  png_ptr->bit_depth = tmp___7;
#line 574
  tmp___8 = (png_byte )dest_color_type;
#line 574
  info_ptr->color_type = tmp___8;
#line 574
  png_ptr->color_type = tmp___8;
#line 575
  tmp___9 = (png_byte )dest_channels;
#line 575
  info_ptr->channels = tmp___9;
#line 575
  png_ptr->channels = tmp___9;
#line 576
  tmp___10 = (png_byte )(dest_bit_depth * dest_channels);
#line 576
  info_ptr->pixel_depth = tmp___10;
#line 576
  png_ptr->pixel_depth = tmp___10;
#line 578
  if (reductions & 128UL) {
#line 580
    png_ptr->transformations &= 0xffffffffffff7fffUL;
#line 581
    if ((int )png_ptr->usr_channels > 0) {
#line 582
      png_ptr->usr_channels = (png_byte )((int )png_ptr->usr_channels - 1);
    }
  }
#line 585
  return (reductions);
}
}
#line 594 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_reduce_palette_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_sample_ptr ;
  png_bytep dest_sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 i ;
  png_uint_32 j ;
  unsigned int src_bit_depth ;
  unsigned int dest_bit_depth ;
  unsigned int src_mask_init ;
  unsigned int src_mask ;
  unsigned int src_shift ;
  unsigned int dest_shift ;
  unsigned int sample ;
  unsigned int dest_buf ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 608
  if (! (reductions & 2UL)) {
#line 611
    return ((png_uint_32 )0);
  } else
#line 608
  if ((int )info_ptr->color_type != 3) {
#line 611
    return ((png_uint_32 )0);
  } else
#line 608
  if ((int )info_ptr->num_palette > 16) {
#line 611
    return ((png_uint_32 )0);
  }
#line 613
  row_ptr = info_ptr->row_pointers;
#line 614
  height = info_ptr->height;
#line 615
  width = info_ptr->width;
#line 616
  if ((int )png_ptr->usr_bit_depth > 0) {
#line 617
    src_bit_depth = (unsigned int )png_ptr->usr_bit_depth;
  } else {
#line 619
    src_bit_depth = (unsigned int )info_ptr->bit_depth;
  }
#line 622
  if (! ((int )info_ptr->num_palette > 0)) {
    {
#line 622
    __assert_fail("info_ptr->num_palette > 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  622U, "opng_reduce_palette_bits");
    }
  }
#line 623
  if ((int )info_ptr->num_palette <= 2) {
#line 624
    dest_bit_depth = 1U;
  } else
#line 625
  if ((int )info_ptr->num_palette <= 4) {
#line 626
    dest_bit_depth = 2U;
  } else
#line 627
  if ((int )info_ptr->num_palette <= 16) {
#line 628
    dest_bit_depth = 4U;
  } else {
#line 630
    dest_bit_depth = 8U;
  }
#line 631
  if (dest_bit_depth >= src_bit_depth) {
#line 632
    return ((png_uint_32 )0);
  }
#line 635
  if (src_bit_depth == 8U) {
#line 637
    i = (png_uint_32 )0;
    {
#line 637
    while (1) {
      while_continue: /* CIL Label */ ;
#line 637
      if (! (i < height)) {
#line 637
        goto while_break;
      }
#line 639
      dest_sample_ptr = *row_ptr;
#line 639
      src_sample_ptr = dest_sample_ptr;
#line 640
      dest_shift = 8U;
#line 641
      dest_buf = 0U;
#line 642
      j = (png_uint_32 )0;
      {
#line 642
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 642
        if (! (j < width)) {
#line 642
          goto while_break___0;
        }
#line 644
        dest_shift -= dest_bit_depth;
#line 645
        if (dest_shift > 0U) {
#line 646
          dest_buf |= (unsigned int )((int )*src_sample_ptr << dest_shift);
        } else {
#line 649
          tmp___0 = dest_sample_ptr;
#line 649
          dest_sample_ptr ++;
#line 649
          *tmp___0 = (png_byte )(dest_buf | (unsigned int )*src_sample_ptr);
#line 650
          dest_shift = 8U;
#line 651
          dest_buf = 0U;
        }
#line 653
        src_sample_ptr ++;
#line 642
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 655
      if (dest_shift != 0U) {
#line 656
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 637
      i ++;
#line 637
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 661
    src_mask_init = (unsigned int )((1 << (8U + src_bit_depth)) - (1 << 8));
#line 662
    i = (png_uint_32 )0;
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 662
      if (! (i < height)) {
#line 662
        goto while_break___1;
      }
#line 664
      dest_sample_ptr = *row_ptr;
#line 664
      src_sample_ptr = dest_sample_ptr;
#line 665
      dest_shift = 8U;
#line 665
      src_shift = dest_shift;
#line 666
      src_mask = src_mask_init;
#line 667
      dest_buf = 0U;
#line 668
      j = (png_uint_32 )0;
      {
#line 668
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 668
        if (! (j < width)) {
#line 668
          goto while_break___2;
        }
#line 670
        src_shift -= src_bit_depth;
#line 671
        src_mask >>= src_bit_depth;
#line 672
        sample = ((unsigned int )*src_sample_ptr & src_mask) >> src_shift;
#line 673
        dest_shift -= dest_bit_depth;
#line 674
        if (dest_shift > 0U) {
#line 675
          dest_buf |= sample << dest_shift;
        } else {
#line 678
          tmp___1 = dest_sample_ptr;
#line 678
          dest_sample_ptr ++;
#line 678
          *tmp___1 = (png_byte )(dest_buf | sample);
#line 679
          dest_shift = 8U;
#line 680
          dest_buf = 0U;
        }
#line 682
        if (src_shift == 0U) {
#line 684
          src_shift = 8U;
#line 685
          src_mask = src_mask_init;
#line 686
          src_sample_ptr ++;
        }
#line 668
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 689
      if (dest_shift != 0U) {
#line 690
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 662
      i ++;
#line 662
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 695
  tmp___4 = (png_byte )dest_bit_depth;
#line 695
  info_ptr->pixel_depth = tmp___4;
#line 695
  tmp___3 = tmp___4;
#line 695
  png_ptr->pixel_depth = tmp___3;
#line 695
  tmp___2 = tmp___3;
#line 695
  info_ptr->bit_depth = tmp___2;
#line 695
  png_ptr->bit_depth = tmp___2;
#line 698
  return ((png_uint_32 )2);
}
}
#line 707 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_reduce_rgb_to_palette(png_structp png_ptr , png_infop info_ptr ,
                                       png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_bytep alpha_row ;
  png_uint_32 height ;
  png_uint_32 width ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_color palette[256] ;
  png_byte trans[256] ;
  int num_palette ;
  int num_trans ;
  int index___0 ;
  unsigned int channels ;
  unsigned int red ;
  unsigned int green ;
  unsigned int blue ;
  unsigned int alpha ;
  unsigned int prev_red ;
  unsigned int prev_green ;
  unsigned int prev_blue ;
  unsigned int prev_alpha ;
  png_voidp tmp ;
  int tmp___1 ;
  int tmp___4 ;
  png_byte tmp___6 ;
  png_byte tmp___7 ;
  png_byte tmp___8 ;
  png_uint_32 tmp___9 ;

  {
#line 725
  if (! (reductions & 32UL)) {
#line 729
    return ((png_uint_32 )0);
  } else
#line 725
  if ((int )info_ptr->bit_depth != 8) {
#line 729
    return ((png_uint_32 )0);
  } else
#line 725
  if ((int )info_ptr->color_type & 1) {
#line 729
    return ((png_uint_32 )0);
  } else
#line 725
  if (! ((int )info_ptr->color_type & 2)) {
#line 729
    return ((png_uint_32 )0);
  }
  {
#line 731
  row_ptr = info_ptr->row_pointers;
#line 732
  height = info_ptr->height;
#line 733
  width = info_ptr->width;
#line 734
  channels = (unsigned int )info_ptr->channels;
#line 735
  tmp = png_malloc(png_ptr, width);
#line 735
  alpha_row = (png_bytep )tmp;
#line 738
  num_trans = 0;
#line 738
  num_palette = num_trans;
#line 739
  prev_alpha = 4294967295U;
#line 739
  prev_blue = prev_alpha;
#line 739
  prev_green = prev_blue;
#line 739
  prev_red = prev_green;
#line 740
  i = (png_uint_32 )0;
  }
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (i < height)) {
#line 740
      goto while_break;
    }
    {
#line 742
    sample_ptr = *row_ptr;
#line 743
    opng_get_alpha_row(png_ptr, info_ptr, *row_ptr, alpha_row);
#line 744
    j = (png_uint_32 )0;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 744
      if (! (j < width)) {
#line 744
        goto while_break___0;
      }
#line 746
      red = (unsigned int )*(sample_ptr + 0);
#line 747
      green = (unsigned int )*(sample_ptr + 1);
#line 748
      blue = (unsigned int )*(sample_ptr + 2);
#line 749
      alpha = (unsigned int )*(alpha_row + j);
#line 751
      if (red != prev_red) {
#line 751
        goto _L;
      } else
#line 751
      if (green != prev_green) {
#line 751
        goto _L;
      } else
#line 751
      if (blue != prev_blue) {
#line 751
        goto _L;
      } else
#line 751
      if (alpha != prev_alpha) {
        _L: /* CIL Label */ 
        {
#line 754
        prev_red = red;
#line 755
        prev_green = green;
#line 756
        prev_blue = blue;
#line 757
        prev_alpha = alpha;
#line 758
        tmp___1 = opng_insert_palette_entry(palette, & num_palette, trans, & num_trans,
                                            256, red, green, blue, alpha, & index___0);
        }
#line 758
        if (tmp___1 < 0) {
#line 762
          if (! (num_palette < 0)) {
            {
#line 762
            __assert_fail("num_palette < 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                          762U, "opng_reduce_rgb_to_palette");
            }
          }
#line 763
          i = height;
#line 764
          goto while_break___0;
        }
      }
#line 744
      j ++;
#line 744
      sample_ptr += channels;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 740
    i ++;
#line 740
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if (num_palette >= 0) {
#line 780
    if (num_palette > 0) {
#line 780
      if (! (num_palette <= 256)) {
        {
#line 780
        __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                      780U, "opng_reduce_rgb_to_palette");
        }
      }
    } else {
      {
#line 780
      __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    780U, "opng_reduce_rgb_to_palette");
      }
    }
#line 781
    if (num_trans >= 0) {
#line 781
      if (! (num_trans <= num_palette)) {
        {
#line 781
        __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                      781U, "opng_reduce_rgb_to_palette");
        }
      }
    } else {
      {
#line 781
      __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    781U, "opng_reduce_rgb_to_palette");
      }
    }
#line 782
    if (width <= 384UL) {
#line 782
      if (height <= 384UL) {
#line 782
        if ((int )((width * height) * (png_uint_32 )(channels - 1U)) <= 3 * num_palette + num_trans) {
#line 784
          num_palette = -1;
        }
      }
    }
  }
#line 787
  if (num_palette < 0) {
    {
#line 789
    png_free(png_ptr, (png_voidp )alpha_row);
    }
#line 790
    return ((png_uint_32 )0);
  }
#line 794
  row_ptr = info_ptr->row_pointers;
#line 795
  index___0 = -1;
#line 796
  prev_alpha = 4294967295U;
#line 796
  prev_blue = prev_alpha;
#line 796
  prev_green = prev_blue;
#line 796
  prev_red = prev_green;
#line 797
  i = (png_uint_32 )0;
  {
#line 797
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 797
    if (! (i < height)) {
#line 797
      goto while_break___1;
    }
    {
#line 799
    sample_ptr = *row_ptr;
#line 800
    opng_get_alpha_row(png_ptr, info_ptr, *row_ptr, alpha_row);
#line 801
    j = (png_uint_32 )0;
    }
    {
#line 801
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 801
      if (! (j < width)) {
#line 801
        goto while_break___2;
      }
#line 803
      red = (unsigned int )*(sample_ptr + 0);
#line 804
      green = (unsigned int )*(sample_ptr + 1);
#line 805
      blue = (unsigned int )*(sample_ptr + 2);
#line 806
      alpha = (unsigned int )*(alpha_row + j);
#line 808
      if (red != prev_red) {
#line 808
        goto _L___0;
      } else
#line 808
      if (green != prev_green) {
#line 808
        goto _L___0;
      } else
#line 808
      if (blue != prev_blue) {
#line 808
        goto _L___0;
      } else
#line 808
      if (alpha != prev_alpha) {
        _L___0: /* CIL Label */ 
        {
#line 811
        prev_red = red;
#line 812
        prev_green = green;
#line 813
        prev_blue = blue;
#line 814
        prev_alpha = alpha;
#line 815
        tmp___4 = opng_insert_palette_entry(palette, & num_palette, trans, & num_trans,
                                            256, red, green, blue, alpha, & index___0);
        }
#line 815
        if (tmp___4 != 0) {
#line 818
          index___0 = -1;
        }
      }
#line 820
      if (! (index___0 >= 0)) {
        {
#line 820
        __assert_fail("index >= 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                      820U, "opng_reduce_rgb_to_palette");
        }
      }
#line 821
      *(*row_ptr + j) = (png_byte )index___0;
#line 801
      j ++;
#line 801
      sample_ptr += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 797
    i ++;
#line 797
    row_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 826
  tmp___6 = (png_byte )3;
#line 826
  info_ptr->color_type = tmp___6;
#line 826
  png_ptr->color_type = tmp___6;
#line 827
  tmp___7 = (png_byte )1;
#line 827
  info_ptr->channels = tmp___7;
#line 827
  png_ptr->channels = tmp___7;
#line 828
  tmp___8 = (png_byte )8;
#line 828
  info_ptr->pixel_depth = tmp___8;
#line 828
  png_ptr->pixel_depth = tmp___8;
#line 829
  png_set_PLTE(png_ptr, info_ptr, palette, num_palette);
  }
#line 830
  if (num_trans > 0) {
    {
#line 831
    png_set_tRNS(png_ptr, info_ptr, trans, num_trans, (png_color_16p )((void *)0));
    }
  }
  {
#line 833
  png_free(png_ptr, (png_voidp )alpha_row);
#line 835
  result = (png_uint_32 )32;
  }
#line 836
  if (reductions & 2UL) {
    {
#line 837
    tmp___9 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 837
    result |= tmp___9;
    }
  }
#line 838
  return (result);
}
}
#line 848 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
void opng_analyze_sample_usage(png_structp png_ptr , png_infop info_ptr , png_bytep usage_map ) 
{ 
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 i ;
  png_uint_32 j ;
  unsigned int bit_depth ;
  unsigned int init_shift ;
  unsigned int init_mask ;
  unsigned int shift ;
  unsigned int mask ;

  {
#line 859
  row_ptr = info_ptr->row_pointers;
#line 860
  height = info_ptr->height;
#line 861
  width = info_ptr->width;
#line 862
  if ((int )png_ptr->usr_bit_depth > 0) {
#line 863
    bit_depth = (unsigned int )png_ptr->usr_bit_depth;
  } else {
#line 865
    bit_depth = (unsigned int )info_ptr->bit_depth;
  }
  {
#line 868
  memset((void *)usage_map, 0, (size_t )256);
  }
#line 871
  if (bit_depth == 8U) {
#line 873
    i = (png_uint_32 )0;
    {
#line 873
    while (1) {
      while_continue: /* CIL Label */ ;
#line 873
      if (! (i < height)) {
#line 873
        goto while_break;
      }
#line 874
      j = (png_uint_32 )0;
#line 874
      sample_ptr = *row_ptr;
      {
#line 874
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 874
        if (! (j < width)) {
#line 874
          goto while_break___0;
        }
#line 875
        *(usage_map + *sample_ptr) = (png_byte )1;
#line 874
        j ++;
#line 874
        sample_ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 873
      i ++;
#line 873
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 879
    if (! (bit_depth < 8U)) {
      {
#line 879
      __assert_fail("bit_depth < 8", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    879U, "opng_analyze_sample_usage");
      }
    }
#line 880
    init_shift = 8U - bit_depth;
#line 881
    init_mask = (unsigned int )((1 << 8) - (1 << init_shift));
#line 882
    i = (png_uint_32 )0;
    {
#line 882
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 882
      if (! (i < height)) {
#line 882
        goto while_break___1;
      }
#line 883
      j = (png_uint_32 )0;
#line 883
      sample_ptr = *row_ptr;
      {
#line 883
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 883
        if (! (j < width)) {
#line 883
          goto while_break___2;
        }
#line 885
        mask = init_mask;
#line 886
        shift = init_shift;
        {
#line 887
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 889
          *(usage_map + (((unsigned int )*sample_ptr & mask) >> shift)) = (png_byte )1;
#line 890
          mask >>= bit_depth;
#line 891
          shift -= bit_depth;
#line 892
          j ++;
#line 887
          if (mask > 0U) {
#line 887
            if (! (j < width)) {
#line 887
              goto while_break___3;
            }
          } else {
#line 887
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 883
        sample_ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 882
      i ++;
#line 882
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 898
  if (info_ptr->valid & 32UL) {
#line 899
    *(usage_map + info_ptr->background.index) = (png_byte )1;
  }
#line 900
  return;
}
}
#line 908 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_reduce_palette(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_colorp palette ;
  png_bytep trans ;
  png_bytepp rows ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte is_used[256] ;
  int num_palette ;
  int num_trans ;
  int last_color_index ;
  int last_trans_index ;
  int is_gray ;
  int k ;
  png_color_16 gray_trans ;
  png_byte crt_trans_value ;
  png_byte last_trans_value ;
  int tmp___0 ;
  png_uint_32 tmp___3 ;
  png_color_8p sig_bit_ptr ;
  png_byte max_sig_bit ;
  png_byte tmp___4 ;
  png_byte tmp___5 ;

  {
#line 925
  if (! (reductions & 322UL)) {
#line 929
    return ((png_uint_32 )0);
  } else
#line 925
  if ((int )info_ptr->color_type != 3) {
#line 929
    return ((png_uint_32 )0);
  }
#line 931
  height = info_ptr->height;
#line 932
  width = info_ptr->width;
#line 933
  palette = info_ptr->palette;
#line 934
  num_palette = (int )info_ptr->num_palette;
#line 935
  rows = info_ptr->row_pointers;
#line 936
  if (info_ptr->valid & 16UL) {
#line 938
    trans = info_ptr->trans;
#line 939
    num_trans = (int )info_ptr->num_trans;
#line 940
    if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 940
      if (! (num_trans > 0)) {
        {
#line 940
        __assert_fail("trans != ((void *)0) && num_trans > 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                      940U, "opng_reduce_palette");
        }
      }
    } else {
      {
#line 940
      __assert_fail("trans != ((void *)0) && num_trans > 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                    940U, "opng_reduce_palette");
      }
    }
  } else {
#line 944
    trans = (png_bytep )((void *)0);
#line 945
    num_trans = 0;
  }
  {
#line 950
  opng_analyze_sample_usage(png_ptr, info_ptr, is_used);
  }
#line 952
  if (reductions & 64UL) {
#line 952
    if ((int )info_ptr->bit_depth == 8) {
#line 952
      tmp___0 = 1;
    } else {
#line 952
      tmp___0 = 0;
    }
  } else {
#line 952
    tmp___0 = 0;
  }
#line 952
  is_gray = tmp___0;
#line 954
  last_trans_index = -1;
#line 954
  last_color_index = last_trans_index;
#line 955
  k = 0;
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 955
    if (! (k < 256)) {
#line 955
      goto while_break;
    }
#line 957
    if (! is_used[k]) {
#line 958
      goto __Cont;
    }
#line 959
    last_color_index = k;
#line 960
    if (k < num_trans) {
#line 960
      if ((int )*(trans + k) < 255) {
#line 961
        last_trans_index = k;
      }
    }
#line 962
    if (is_gray) {
#line 963
      if ((int )(palette + k)->red != (int )(palette + k)->green) {
#line 965
        is_gray = 0;
      } else
#line 963
      if ((int )(palette + k)->red != (int )(palette + k)->blue) {
#line 965
        is_gray = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 955
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  if (! (last_color_index >= 0)) {
    {
#line 967
    __assert_fail("last_color_index >= 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  967U, "opng_reduce_palette");
    }
  }
#line 968
  if (last_color_index >= num_palette) {
    {
#line 970
    png_warning(png_ptr, "Too few colors in palette");
#line 972
    num_palette = last_color_index + 1;
#line 973
    info_ptr->num_palette = (png_uint_16 )num_palette;
    }
  }
#line 975
  if (num_trans > num_palette) {
    {
#line 977
    png_warning(png_ptr, "Too many alpha values in tRNS");
#line 978
    info_ptr->num_trans = info_ptr->num_palette;
    }
  }
#line 980
  num_trans = last_trans_index + 1;
#line 981
  if (! (num_trans <= num_palette)) {
    {
#line 981
    __assert_fail("num_trans <= num_palette", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c",
                  981U, "opng_reduce_palette");
    }
  }
#line 984
  if (is_gray) {
#line 984
    if (num_trans > 0) {
#line 986
      gray_trans.gray = (png_uint_16 )(palette + last_trans_index)->red;
#line 987
      last_trans_value = *(trans + last_trans_index);
#line 988
      k = 0;
      {
#line 988
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 988
        if (! (k <= last_color_index)) {
#line 988
          goto while_break___0;
        }
#line 990
        if (! is_used[k]) {
#line 991
          goto __Cont___0;
        }
#line 992
        if (k <= last_trans_index) {
#line 994
          crt_trans_value = *(trans + k);
#line 996
          if ((int )crt_trans_value < 255) {
#line 996
            if ((int )(palette + k)->red != (int )gray_trans.gray) {
#line 998
              is_gray = 0;
#line 999
              goto while_break___0;
            }
          }
        } else {
#line 1003
          crt_trans_value = (png_byte )255;
        }
#line 1005
        if ((int )(palette + k)->red == (int )gray_trans.gray) {
#line 1005
          if ((int )crt_trans_value != (int )last_trans_value) {
#line 1008
            is_gray = 0;
#line 1009
            goto while_break___0;
          }
        }
        __Cont___0: /* CIL Label */ 
#line 988
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1015
  result = (png_uint_32 )0;
#line 1018
  if (info_ptr->valid & 16UL) {
#line 1018
    if (num_trans == 0) {
      {
#line 1020
      png_free_data(png_ptr, info_ptr, (png_uint_32 )8192, -1);
#line 1021
      info_ptr->valid &= 0xffffffffffffffefUL;
#line 1022
      result = (png_uint_32 )256;
      }
    }
  }
#line 1025
  if (reductions & 256UL) {
#line 1027
    if (num_palette != last_color_index + 1) {
#line 1031
      info_ptr->num_palette = (png_uint_16 )(last_color_index + 1);
#line 1032
      result = (png_uint_32 )256;
    }
#line 1035
    if (info_ptr->valid & 16UL) {
#line 1035
      if ((int )info_ptr->num_trans != num_trans) {
#line 1039
        info_ptr->num_trans = (png_uint_16 )num_trans;
#line 1040
        result = (png_uint_32 )256;
      }
    }
  }
#line 1044
  if (reductions & 2UL) {
    {
#line 1045
    tmp___3 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 1045
    result |= tmp___3;
    }
  }
#line 1046
  if ((int )info_ptr->bit_depth < 8) {
#line 1047
    return (result);
  } else
#line 1046
  if (! is_gray) {
#line 1047
    return (result);
  }
#line 1050
  i = (png_uint_32 )0;
  {
#line 1050
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1050
    if (! (i < height)) {
#line 1050
      goto while_break___1;
    }
#line 1051
    j = (png_uint_32 )0;
    {
#line 1051
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1051
      if (! (j < width)) {
#line 1051
        goto while_break___2;
      }
#line 1052
      *(*(rows + i) + j) = (palette + *(*(rows + i) + j))->red;
#line 1051
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1050
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1055
  if (info_ptr->valid & 32UL) {
#line 1056
    info_ptr->background.gray = (png_uint_16 )(palette + info_ptr->background.index)->red;
  }
#line 1057
  if (info_ptr->valid & 64UL) {
    {
#line 1059
    png_free_data(png_ptr, info_ptr, (png_uint_32 )8, -1);
#line 1060
    info_ptr->valid &= 0xffffffffffffffbfUL;
    }
  }
#line 1062
  if (info_ptr->valid & 2UL) {
#line 1064
    sig_bit_ptr = & info_ptr->sig_bit;
#line 1065
    max_sig_bit = sig_bit_ptr->red;
#line 1066
    if ((int )max_sig_bit < (int )sig_bit_ptr->green) {
#line 1067
      max_sig_bit = sig_bit_ptr->green;
    }
#line 1068
    if ((int )max_sig_bit < (int )sig_bit_ptr->blue) {
#line 1069
      max_sig_bit = sig_bit_ptr->blue;
    }
#line 1070
    tmp___4 = max_sig_bit;
#line 1070
    info_ptr->sig_bit.gray = tmp___4;
#line 1070
    png_ptr->sig_bit.gray = tmp___4;
  }
#line 1072
  if (info_ptr->valid & 16UL) {
    {
#line 1073
    png_set_tRNS(png_ptr, info_ptr, (png_bytep )((void *)0), 0, & gray_trans);
    }
  }
  {
#line 1076
  tmp___5 = (png_byte )0;
#line 1076
  info_ptr->color_type = tmp___5;
#line 1076
  png_ptr->color_type = tmp___5;
#line 1077
  png_free_data(png_ptr, info_ptr, (png_uint_32 )4096, -1);
#line 1078
  info_ptr->valid &= 0xfffffffffffffff7UL;
  }
#line 1079
  return ((png_uint_32 )64);
}
}
#line 1091 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngreduc.c"
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  int tmp ;
  png_uint_32 tmp___0 ;
  png_uint_32 tmp___1 ;

  {
  {
#line 1099
  tmp = opng_validate_image(png_ptr, info_ptr);
  }
#line 1099
  if (! tmp) {
    {
#line 1101
    png_warning(png_ptr, "Image reduction requires the presence of the critical info");
    }
#line 1103
    return ((png_uint_32 )0);
  }
  {
#line 1120
  result = opng_reduce_bits(png_ptr, info_ptr, reductions);
#line 1121
  tmp___0 = opng_reduce_palette(png_ptr, info_ptr, reductions);
#line 1121
  result |= tmp___0;
#line 1122
  tmp___1 = opng_reduce_rgb_to_palette(png_ptr, info_ptr, reductions);
#line 1122
  result |= tmp___1;
  }
#line 1123
  return (result);
}
}
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opng.h"
png_uint_32 opng_get_io_state(png_structp png_ptr ) ;
#line 64
png_bytep opng_get_io_chunk_name(png_structp png_ptr ) ;
#line 86
void opng_set_read_fn(png_structp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) ;
#line 88
void opng_set_write_fn(png_structp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                       void (*output_flush_fn)(png_structp  ) ) ;
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_structp opng_priv_read_ptr  ;
#line 25 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_structp opng_priv_write_ptr  ;
#line 28 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static void (*opng_priv_read_fn)(png_structp  , png_bytep  , png_size_t  )  ;
#line 28 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static void (*opng_priv_write_fn)(png_structp  , png_bytep  , png_size_t  )  ;
#line 31 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static int opng_priv_read_io_state  ;
#line 31 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static int opng_priv_write_io_state  ;
#line 34 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_byte opng_priv_read_crt_chunk_hdr[8]  ;
#line 34 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_byte opng_priv_write_crt_chunk_hdr[8]  ;
#line 37 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static unsigned int opng_priv_read_crt_chunk_hdr_len  ;
#line 37 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static unsigned int opng_priv_write_crt_chunk_hdr_len  ;
#line 40 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_uint_32 opng_priv_read_crt_len  ;
#line 40 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static png_uint_32 opng_priv_write_crt_len  ;
#line 43 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
static char const   *opng_priv_errmsg  =    "Internal OPNGIO error: incorrect use of the opng_ functions";
#line 48 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
void opng_priv_read_write(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  void (*io_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
  int *io_state_ptr ;
  int io_state_op ;
  png_bytep io_crt_chunk_hdr ;
  unsigned int *io_crt_chunk_hdr_len_ptr ;
  png_uint_32 *io_crt_len_ptr ;
  png_uint_32 tmp___2 ;

  {
#line 57
  if ((unsigned long )png_ptr == (unsigned long )opng_priv_read_ptr) {
#line 59
    io_data_fn = opng_priv_read_fn;
#line 60
    io_state_ptr = & opng_priv_read_io_state;
#line 61
    io_state_op = 1;
#line 62
    io_crt_chunk_hdr = opng_priv_read_crt_chunk_hdr;
#line 63
    io_crt_chunk_hdr_len_ptr = & opng_priv_read_crt_chunk_hdr_len;
#line 64
    io_crt_len_ptr = & opng_priv_read_crt_len;
  } else
#line 66
  if ((unsigned long )png_ptr == (unsigned long )opng_priv_write_ptr) {
#line 68
    io_data_fn = opng_priv_write_fn;
#line 69
    io_state_ptr = & opng_priv_write_io_state;
#line 70
    io_state_op = 2;
#line 71
    io_crt_chunk_hdr = opng_priv_write_crt_chunk_hdr;
#line 72
    io_crt_chunk_hdr_len_ptr = & opng_priv_write_crt_chunk_hdr_len;
#line 73
    io_crt_len_ptr = & opng_priv_write_crt_len;
  } else {
    {
#line 77
    png_error(png_ptr, opng_priv_errmsg);
    }
#line 78
    return;
  }
  {
#line 83
  if ((*io_state_ptr & 240) == 16) {
#line 83
    goto case_16;
  }
#line 92
  if ((*io_state_ptr & 240) == 32) {
#line 92
    goto case_32;
  }
#line 121
  if ((*io_state_ptr & 240) == 64) {
#line 121
    goto case_64;
  }
#line 134
  if ((*io_state_ptr & 240) == 128) {
#line 134
    goto case_128;
  }
#line 81
  goto switch_break;
  case_16: /* CIL Label */ 
#line 87
  if (! (length <= 8UL)) {
    {
#line 87
    __assert_fail("length <= 8", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c",
                  87U, "opng_priv_read_write");
    }
  }
  {
#line 88
  (*io_data_fn)(png_ptr, data, length);
#line 89
  *io_state_ptr = io_state_op | 32;
#line 90
  *io_crt_chunk_hdr_len_ptr = 0U;
  }
#line 91
  return;
  case_32: /* CIL Label */ 
#line 96
  if (! (length + (png_size_t )*io_crt_chunk_hdr_len_ptr <= 8UL)) {
    {
#line 96
    __assert_fail("length + *io_crt_chunk_hdr_len_ptr <= 8", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c",
                  96U, "opng_priv_read_write");
    }
  }
#line 97
  if (io_state_op == 1) {
#line 99
    if (*io_crt_chunk_hdr_len_ptr == 0U) {
      {
#line 100
      (*io_data_fn)(png_ptr, io_crt_chunk_hdr, (png_size_t )8);
      }
    }
    {
#line 101
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(io_crt_chunk_hdr + *io_crt_chunk_hdr_len_ptr),
           length);
#line 102
    *io_crt_chunk_hdr_len_ptr = (unsigned int )((png_size_t )*io_crt_chunk_hdr_len_ptr + length);
    }
#line 103
    if (*io_crt_chunk_hdr_len_ptr < 8U) {
#line 104
      return;
    }
    {
#line 105
    *io_crt_len_ptr = png_get_uint_32(io_crt_chunk_hdr);
#line 106
    memcpy((void */* __restrict  */)(png_ptr->chunk_name), (void const   */* __restrict  */)(io_crt_chunk_hdr + 4),
           (size_t )4);
    }
  } else {
    {
#line 110
    memcpy((void */* __restrict  */)(io_crt_chunk_hdr + *io_crt_chunk_hdr_len_ptr),
           (void const   */* __restrict  */)data, length);
#line 111
    *io_crt_chunk_hdr_len_ptr = (unsigned int )((png_size_t )*io_crt_chunk_hdr_len_ptr + length);
    }
#line 112
    if (*io_crt_chunk_hdr_len_ptr < 8U) {
#line 113
      return;
    }
    {
#line 114
    *io_crt_len_ptr = png_get_uint_32(io_crt_chunk_hdr);
#line 115
    memcpy((void */* __restrict  */)(png_ptr->chunk_name), (void const   */* __restrict  */)(io_crt_chunk_hdr + 4),
           (size_t )4);
#line 116
    (*io_data_fn)(png_ptr, io_crt_chunk_hdr, (png_size_t )8);
    }
  }
#line 118
  *io_crt_chunk_hdr_len_ptr = 0U;
#line 119
  *io_state_ptr = io_state_op | 64;
#line 120
  return;
  case_64: /* CIL Label */ 
#line 123
  if (length == 0UL) {
#line 124
    return;
  }
#line 125
  if (*io_crt_len_ptr > 0UL) {
#line 127
    if (! (length <= *io_crt_len_ptr)) {
      {
#line 127
      __assert_fail("length <= *io_crt_len_ptr", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c",
                    127U, "opng_priv_read_write");
      }
    }
    {
#line 128
    (*io_data_fn)(png_ptr, data, length);
#line 129
    tmp___2 = *io_crt_len_ptr - length;
#line 129
    *io_crt_len_ptr = tmp___2;
    }
#line 129
    if (tmp___2 == 0UL) {
#line 130
      *io_state_ptr = io_state_op | 128;
    }
#line 131
    return;
  }
  case_128: /* CIL Label */ 
#line 138
  if (! (length == 4UL)) {
    {
#line 138
    __assert_fail("length == 4", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c",
                  138U, "opng_priv_read_write");
    }
  }
  {
#line 139
  (*io_data_fn)(png_ptr, data, (png_size_t )4);
#line 140
  *io_state_ptr = io_state_op | 32;
  }
#line 141
  return;
  switch_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 150 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
png_uint_32 opng_get_io_state(png_structp png_ptr ) 
{ 


  {
#line 155
  if ((unsigned long )png_ptr == (unsigned long )opng_priv_read_ptr) {
#line 156
    return ((png_uint_32 )opng_priv_read_io_state);
  } else
#line 157
  if ((unsigned long )png_ptr == (unsigned long )opng_priv_write_ptr) {
#line 158
    return ((png_uint_32 )opng_priv_write_io_state);
  }
  {
#line 159
  png_error(png_ptr, opng_priv_errmsg);
  }
#line 161
  return ((png_uint_32 )0);
}
}
#line 164 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
png_bytep opng_get_io_chunk_name(png_structp png_ptr ) 
{ 


  {
#line 167
  return (png_ptr->chunk_name);
}
}
#line 175 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
void opng_set_read_fn(png_structp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) 
{ 


  {
  {
#line 179
  opng_priv_read_ptr = png_ptr;
#line 180
  opng_priv_write_ptr = (png_structp )((void *)0);
#line 181
  opng_priv_read_fn = read_data_fn;
#line 182
  png_set_read_fn(png_ptr, io_ptr, & opng_priv_read_write);
#line 183
  opng_priv_read_io_state = 17;
  }
#line 184
  return;
}
}
#line 186 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/opngio.c"
void opng_set_write_fn(png_structp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                       void (*output_flush_fn)(png_structp  ) ) 
{ 


  {
  {
#line 190
  opng_priv_write_ptr = png_ptr;
#line 191
  opng_priv_read_ptr = (png_structp )((void *)0);
#line 192
  opng_priv_write_fn = write_data_fn;
#line 193
  png_set_write_fn(png_ptr, io_ptr, & opng_priv_read_write, output_flush_fn);
#line 194
  opng_priv_write_io_state = 18;
  }
#line 195
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 385
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 47 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *msg_intro  =    "OptiPNG 0.5.3: Advanced PNG optimizer.\nCopyright (C) 2001-2006 Cosmin Truta.\n\n";
#line 51 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *msg_license  =    "This program is open-source software. See LICENSE for more details.\n\nPortions of this software are based in part on the work of:\n  Jean-loup Gailly and Mark Adler (zlib)\n  Glenn Randers-Pehrson and the PNG Development Group (libpng)\n  Miyasaka Masaru (BMP support)\n  David Koblas (GIF support)\n\n";
#line 61 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *msg_short_help  =    "Type \"optipng -h\" for advanced help.\n\nUsage:\n    optipng [options] files ...\nFiles:\n    Image files of type: PNG, BMP, GIF, PNM or TIFF\nBasic options:\n    -h, -help\t\tshow the advanced help\n    -v\t\t\tverbose mode / show copyright, version and build info\n    -o  <level>\t\toptimization level (0-7)\t\tdefault 2\n    -i  <type>\t\tinterlace type (0-1)\t\t\tdefault <input>\n    -k, -keep\t\tkeep a backup of the modified files\n    -q, -quiet\t\tquiet mode\nExamples:\n    optipng file.png\t\t\t(default speed)\n    optipng -o5 file.png\t\t(moderately slow)\n    optipng -o7 file.png\t\t(very slow)\n";
#line 80 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *msg_help  =    "Usage:\n    optipng [options] files ...\nFiles:\n    Image files of type: PNG, BMP, GIF, PNM or TIFF\nBasic options:\n    -h, -help\t\tshow this help\n    -v\t\t\tverbose mode / show copyright, version and build info\n    -o  <level>\t\toptimization level (0-7)\t\tdefault 2\n    -i  <type>\t\tinterlace type (0-1)\t\t\tdefault <input>\n    -k, -keep\t\tkeep a backup of the modified files\n    -q, -quiet\t\tquiet mode\nAdvanced options:\n    -zc <levels>\tzlib compression levels (1-9)\t\tdefault 9\n    -zm <levels>\tzlib memory levels (1-9)\t\tdefault 8\n    -zs <strategies>\tzlib compression strategies (0-3)\tdefault 0-3\n    -zw <window size>\tzlib window size (32k,16k,8k,4k,2k,1k,512)\n    -f  <filters>\tPNG delta filters (0-5)\t\t\tdefault 0,5\n    -nb\t\t\tno bit depth reduction\n    -nc\t\t\tno color type reduction\n    -np\t\t\tno palette reduction\n    -nz\t\t\tno IDAT recompression (also disable reductions)\n    -fix\t\tenable error recovery\n    -force\t\twrite a new output, even if it is larger than the input\n    -full\t\tproduce a full report on IDAT (might reduce speed)\n    -log <file>\t\tlog messages to <file>\n    -preserve\t\tpreserve file attributes if possible\n    -simulate\t\trun in simulation mode, do not create output files\n    --\t\t\tstop option switch parsing\nOptimization level presets:\n    -o0  <=>  -nz\n    -o1  <=>  [apply libpng heuristics]\t\t(1 trial)\n    -o2  <=>  -zc9 -zm8 -zs0-3 -f0,5\t\t(8 trials)\n    -o3  <=>  -zc9 -zm8-9 -zs0-3 -f0,5\t\t(16 trials)\n    -o4  <=>  -zc9 -zm8 -zs0-3 -f0-5\t\t(24 trials)\n    -o5  <=>  -zc9 -zm8-9 -zs0-3 -f0-5\t\t(48 trials)\n    -o6  <=>  -zc1-9 -zm8 -zs0-3 -f0-5\t\t(120 trials)\n    -o7  <=>  -zc1-9 -zm8-9 -zs0-3 -f0-5\t(240 trials)\nNotes:\n  - The option names are case-insensitive and can be abbreviated.\n  - Range arguments are cumulative; e.g.\n    -f0 -f3-5  <=>  -f0,3-5\n    -zs0 -zs1 -zs2-3  <=>  -zs0,1,2,3  <=>  -zs0-3\n  - The libpng heuristics consist of:\n    -o1  <=>  -zc9 -zm8 -zs0 -f0\t\t(if PLTE is present)\n    -o1  <=>  -zc9 -zm8 -zs1 -f5\t\t(if PLTE is not present)\n  - The most exhaustive search  -zc1-9 -zm1-9 -zs0-3 -f0-5  (1080 trials)\n    is offered only as an advanced option, and it is not recomended.\nExamples:\n    optipng file.png\t\t\t\t(default speed)\n    optipng -o5 file.png\t\t\t(moderately slow)\n    optipng -o7 file.png\t\t\t(very slow)\n    optipng -i1 -o7 -v -full -sim experiment.png -log experiment.log\n";
#line 155 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *compr_level_presets[8]  = 
#line 155
  {      "",      "",      "9",      "9", 
        "9",      "9",      "-",      "-"};
#line 157 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *compr_level_mask  =    "1-9";
#line 161 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *mem_level_presets[8]  = 
#line 161
  {      "",      "",      "8",      "8-", 
        "8",      "8-",      "8",      "8-"};
#line 163 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *mem_level_mask  =    "1-9";
#line 167 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *strategy_presets[8]  = 
#line 167
  {      "",      "",      "-",      "-", 
        "-",      "-",      "-",      "-"};
#line 169 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *strategy_mask  =    "0-3";
#line 173 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *filter_presets[8]  = 
#line 173
  {      "",      "",      "0,5",      "0,5", 
        "-",      "-",      "-",      "-"};
#line 175 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *filter_mask  =    "0-5";
#line 179 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_bKGD[4]  = {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68};
#line 180 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_hIST[4]  = {      (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84};
#line 181 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_sBIT[4]  = {      (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73,      (png_byte const   )84};
#line 182 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_tRNS[4]  = {      (png_byte const   )116,      (png_byte const   )82,      (png_byte const   )78,      (png_byte const   )83};
#line 184 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_IDAT[4]  = {      (png_byte const   )73,      (png_byte const   )68,      (png_byte const   )65,      (png_byte const   )84};
#line 185 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_byte const   sig_IEND[4]  = {      (png_byte const   )73,      (png_byte const   )69,      (png_byte const   )78,      (png_byte const   )68};
#line 190 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
struct exception_context the_exception_context[1]  ;
#line 194 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static struct opng_image_struct opng_image  ;
#line 214 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static struct opng_info_struct opng_info  ;
#line 229 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static struct cmdline_struct cmdline  ;
#line 242 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static struct global_struct global  ;
#line 250 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_structp read_ptr  ;
#line 250 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_structp write_ptr  ;
#line 251 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_infop read_info_ptr  ;
#line 251 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_infop write_info_ptr  ;
#line 252 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_infop read_end_info_ptr  ;
#line 252 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_infop write_end_info_ptr  ;
#line 261 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_internal_error(char const   *msg___0 ) 
{ 
  char const   *fmt ;

  {
  {
#line 264
  fmt = "[internal error] %s\n";
#line 266
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt, msg___0);
  }
#line 267
  if ((unsigned long )global.logfile != (unsigned long )((void *)0)) {
    {
#line 269
    fprintf((FILE */* __restrict  */)global.logfile, (char const   */* __restrict  */)fmt,
            msg___0);
#line 270
    fflush(global.logfile);
    }
  }
  {
#line 272
  abort();
  }
}
}
#line 277 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_free(void *ptr ) 
{ 


  {
#line 281
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 282
    free(ptr);
    }
  }
#line 283
  return;
}
}
#line 287 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int opng_bitset_min(bitset_t set ) 
{ 
  unsigned int i ;

  {
#line 292
  i = 0U;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! ((unsigned long )i < 8UL * sizeof(bitset_t ) - 1UL)) {
#line 292
      goto while_break;
    }
#line 293
    if ((set & (1 << i)) != 0) {
#line 294
      return ((int )i);
    }
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return (-1);
}
}
#line 300 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_printf(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  FILE *confile ;

  {
  {
#line 306
  __builtin_va_start(arg_ptr, fmt);
  }
#line 309
  if ((int const   )*(fmt + 0) == 33) {
#line 311
    fmt ++;
#line 312
    confile = stderr;
  } else {
#line 315
    confile = stdout;
  }
#line 316
  if (cmdline.quiet) {
#line 317
    confile = (FILE *)((void *)0);
  }
#line 319
  if ((unsigned long )confile != (unsigned long )((void *)0)) {
    {
#line 320
    vfprintf((FILE */* __restrict  */)confile, (char const   */* __restrict  */)fmt,
             arg_ptr);
    }
  }
#line 321
  if ((unsigned long )global.logfile != (unsigned long )((void *)0)) {
    {
#line 323
    vfprintf((FILE */* __restrict  */)global.logfile, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 324
    fflush(global.logfile);
    }
  }
  {
#line 327
  __builtin_va_end(arg_ptr);
  }
#line 328
  return;
}
}
#line 335
static void opng_print_image_info(int print_dim , int print_type , int print_interlaced ) ;
#line 335 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static char const   *color_type_name[7]  = {      "grayscale",      "[invalid]",      "RGB",      "palette", 
        "grayscale-alpha",      "[invalid]",      "RGB-alpha"};
#line 332 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_print_image_info(int print_dim , int print_type , int print_interlaced ) 
{ 
  int something_printed ;
  char const   *tmp___0 ;

  {
#line 340
  something_printed = 0;
#line 342
  if (print_dim) {
    {
#line 344
    opng_printf("%ux%u", (unsigned int )opng_image.width, (unsigned int )opng_image.height);
#line 346
    something_printed = 1;
    }
  }
#line 348
  if (print_type) {
#line 350
    if (something_printed) {
      {
#line 351
      opng_printf(" ");
      }
    }
#line 352
    if (! (opng_image.color_type < 7)) {
      {
#line 352
      __assert_fail("opng_image.color_type < 7", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    352U, "opng_print_image_info");
      }
    }
    {
#line 353
    opng_printf("%d-bit %s", opng_image.bit_depth, color_type_name[opng_image.color_type]);
#line 355
    something_printed = 1;
    }
  }
#line 357
  if (print_interlaced) {
#line 359
    if (something_printed) {
      {
#line 360
      opng_printf(" ");
      }
    }
#line 361
    if (opng_image.interlace_type == 1) {
#line 361
      tmp___0 = "interlaced";
    } else {
#line 361
      tmp___0 = "non-interlaced";
    }
    {
#line 361
    opng_printf(tmp___0);
    }
  }
#line 364
  return;
}
}
#line 368 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_print_percentage(png_uint_32 num , png_uint_32 denom ) 
{ 


  {
#line 371
  if (num <= 21474836UL) {
#line 371
    if (denom <= 21474836UL) {
#line 372
      num *= 100UL;
    } else {
#line 374
      denom = (denom + 50UL) / 100UL;
    }
  } else {
#line 374
    denom = (denom + 50UL) / 100UL;
  }
#line 376
  if (denom == 0UL) {
    {
#line 378
    opng_printf("INFTY%%");
    }
#line 379
    return;
  }
  {
#line 382
  num += denom / 200UL;
#line 383
  opng_printf("%lu.%02u%%", num / denom, (unsigned int )(((num % denom) * 100UL) / denom));
  }
#line 386
  return;
}
}
#line 390 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_print_size_difference(png_uint_32 init_size , png_uint_32 final_size ,
                                       int print_percentage ) 
{ 
  long difference ;
  int increase ;
  char const   *tmp ;

  {
#line 394
  difference = (long )final_size - (long )init_size;
#line 397
  if (difference == 0L) {
    {
#line 399
    opng_printf("no change");
    }
#line 400
    return;
  }
#line 403
  increase = 1;
#line 404
  if (difference < 0L) {
#line 406
    difference = - difference;
#line 407
    increase = 0;
  }
  {
#line 410
  opng_printf("%ld bytes", difference);
  }
#line 411
  if (print_percentage) {
#line 411
    if (init_size > 0UL) {
      {
#line 413
      opng_printf(" = ");
#line 414
      opng_print_percentage((png_uint_32 )difference, init_size);
      }
    }
  }
#line 416
  if (increase) {
#line 416
    tmp = " increase";
  } else {
#line 416
    tmp = " decrease";
  }
  {
#line 416
  opng_printf(tmp);
  }
#line 417
  return;
}
}
#line 424
static int opng_progress(void) ;
#line 424 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int const   progress_factor[7]  = {      (int const   )1,      (int const   )1,      (int const   )2,      (int const   )4, 
        (int const   )8,      (int const   )16,      (int const   )32};
#line 421 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int opng_progress(void) 
{ 
  png_uint_32 height ;
  png_uint_32 crt_row ;
  png_uint_32 progress ;
  int i ;

  {
#line 428
  if (opng_info.crt_row >= opng_info.last_row) {
#line 428
    if (opng_info.crt_ipass >= opng_info.last_ipass) {
      {
#line 431
      opng_printf("100%%");
      }
#line 432
      return (1);
    }
  }
#line 435
  if (opng_image.interlace_type == 1) {
#line 437
    if (! (opng_info.crt_ipass < 7)) {
      {
#line 437
      __assert_fail("opng_info.crt_ipass < 7", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    437U, "opng_progress");
      }
    }
#line 440
    height = opng_image.height;
#line 441
    crt_row = opng_info.crt_row;
#line 442
    if (height > 33554431UL) {
#line 445
      height = (height + 32UL) / 64UL;
#line 446
      crt_row = (crt_row + 32UL) / 64UL;
    }
#line 450
    progress = (png_uint_32 )0;
#line 451
    i = 0;
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
#line 451
      if (! (i < opng_info.crt_ipass)) {
#line 451
        goto while_break;
      }
#line 452
      progress += (png_uint_32 )progress_factor[i] * height;
#line 451
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 453
    progress += (png_uint_32 )progress_factor[i] * crt_row;
#line 455
    height *= 64UL;
#line 456
    if (progress < height) {
      {
#line 457
      opng_print_percentage(progress, height);
      }
    } else {
      {
#line 459
      opng_printf("100%%");
      }
    }
  } else {
#line 463
    if (! (opng_info.crt_ipass == 0)) {
      {
#line 463
      __assert_fail("opng_info.crt_ipass == 0", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    463U, "opng_progress");
      }
    }
    {
#line 464
    opng_print_percentage(opng_info.crt_row, opng_image.height);
    }
  }
#line 466
  return (0);
}
}
#line 471 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_error(png_structp png_ptr , png_const_charp msg___0 ) 
{ 


  {
#line 474
  if (& png_ptr) {
#line 476
    opng_info.valid = 0;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 477
      the_exception_context[0].v.etmp = (char const   */* volatile  */)msg___0;
#line 477
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 479
  return;
}
}
#line 483 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_warning(png_structp png_ptr , png_const_charp msg___0 ) 
{ 


  {
#line 486
  if (& png_ptr) {
    {
#line 488
    opng_info.valid = 0;
#line 489
    opng_printf("!Warning: %s\n", msg___0);
    }
  }
#line 491
  return;
}
}
#line 495 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int opng_handle_as_unknown(png_bytep chunk_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 498
  if (((int )*(chunk_type + 0) & 32) == 0) {
#line 503
    return (0);
  } else {
    {
#line 498
    tmp = memcmp((void const   *)chunk_type, (void const   *)(sig_bKGD), (size_t )4);
    }
#line 498
    if (tmp == 0) {
#line 503
      return (0);
    } else {
      {
#line 498
      tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_hIST), (size_t )4);
      }
#line 498
      if (tmp___0 == 0) {
#line 503
        return (0);
      } else {
        {
#line 498
        tmp___1 = memcmp((void const   *)chunk_type, (void const   *)(sig_sBIT), (size_t )4);
        }
#line 498
        if (tmp___1 == 0) {
#line 503
          return (0);
        } else {
          {
#line 498
          tmp___2 = memcmp((void const   *)chunk_type, (void const   *)(sig_tRNS),
                           (size_t )4);
          }
#line 498
          if (tmp___2 == 0) {
#line 503
            return (0);
          }
        }
      }
    }
  }
#line 504
  return (1);
}
}
#line 509 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_set_keep_unknown_chunk(png_structp png_ptr , png_bytep chunk_type ) 
{ 
  png_byte chunk_name[5] ;
  int tmp ;

  {
  {
#line 514
  memcpy((void */* __restrict  */)(chunk_name), (void const   */* __restrict  */)chunk_type,
         (size_t )4);
#line 515
  chunk_name[4] = (png_byte )0;
#line 516
  tmp = png_handle_as_unknown(png_ptr, chunk_name);
  }
#line 516
  if (! tmp) {
    {
#line 517
    png_set_keep_unknown_chunks(png_ptr, 3, chunk_name, 1);
    }
  }
#line 519
  return;
}
}
#line 523 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_read_write_status(png_structp png_ptr , png_uint_32 row_num , int pass ) 
{ 


  {
#line 526
  if (& png_ptr) {
#line 528
    opng_info.crt_row = row_num;
#line 529
    opng_info.crt_ipass = pass;
  }
#line 531
  return;
}
}
#line 538 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int crt_chunk_is_idat  ;
#line 539 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static long idat_offset  ;
#line 540 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static png_uint_32 crt_idat_crc  ;
#line 535 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_read_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  FILE *fp ;
  png_voidp tmp ;
  int io_state ;
  png_uint_32 tmp___0 ;
  int io_state_loc ;
  png_bytep chunk_sig ;
  size_t tmp___3 ;
  png_uint_32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  png_byte buf___1[4] ;
  size_t num ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 541
  tmp = png_get_io_ptr(png_ptr);
#line 541
  fp = (FILE *)tmp;
#line 542
  tmp___0 = opng_get_io_state(png_ptr);
#line 542
  io_state = (int )tmp___0;
#line 543
  io_state_loc = io_state & 240;
  }
#line 546
  if ((io_state & 15) == 0) {
    {
#line 547
    png_error(png_ptr, "[libpng error] No info in png_ptr->io_state");
    }
  } else
#line 546
  if ((io_state & 240) == 0) {
    {
#line 547
    png_error(png_ptr, "[libpng error] No info in png_ptr->io_state");
    }
  }
#line 549
  if (length == 0UL) {
#line 550
    return;
  }
#line 551
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 551
    __assert_fail("data != NULL", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  551U, "opng_read_write_data");
    }
  }
#line 553
  if (io_state & 1) {
#line 555
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
      {
#line 555
      __assert_fail("fp != NULL", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    555U, "opng_read_write_data");
      }
    }
    {
#line 556
    tmp___3 = fread((void */* __restrict  */)data, length, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 556
    if (tmp___3 != 1UL) {
      {
#line 557
      png_error(png_ptr, "Can\'t read the input file or unexpected end of file");
      }
    }
  }
#line 562
  opng_info.file_size += length;
#line 563
  if (io_state_loc == 32) {
#line 565
    if (length != 8UL) {
      {
#line 566
      png_error(png_ptr, "[libpng error] Incorrect amount of data for I/O");
      }
    }
    {
#line 567
    chunk_sig = data + 4;
#line 568
    tmp___6 = memcmp((void const   *)chunk_sig, (void const   *)(sig_IDAT), (size_t )4);
    }
#line 568
    if (tmp___6 == 0) {
      {
#line 570
      crt_chunk_is_idat = 1;
#line 571
      (opng_info.num_idat_chunks) ++;
#line 572
      tmp___4 = png_get_uint_32(data);
#line 572
      opng_info.idat_size += tmp___4;
      }
#line 576
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 578
        if (opng_info.idat_size > opng_info.best_idat_size) {
#line 578
          if (! cmdline.full) {
#line 578
            goto _L;
          } else {
#line 578
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 578
        if (opng_info.idat_size > 2147483647UL) {
          _L: /* CIL Label */ 
          {
#line 581
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 581
            the_exception_context[0].v.etmp = (char const   */* volatile  */)((void *)0);
#line 581
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 586
      crt_chunk_is_idat = 0;
#line 587
      tmp___5 = opng_handle_as_unknown(chunk_sig);
      }
#line 587
      if (tmp___5) {
        {
#line 588
        opng_set_keep_unknown_chunk(png_ptr, chunk_sig);
        }
      }
    }
  }
#line 593
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 594
    return;
  } else
#line 593
  if (! (io_state & 2)) {
#line 594
    return;
  }
  {
#line 602
  if (io_state_loc == 16) {
#line 602
    goto case_16;
  }
#line 608
  if (io_state_loc == 32) {
#line 608
    goto case_32;
  }
#line 661
  if (io_state_loc == 64) {
#line 661
    goto case_64;
  }
#line 667
  if (io_state_loc == 128) {
#line 667
    goto case_128;
  }
#line 600
  goto switch_break;
  case_16: /* CIL Label */ 
#line 605
  idat_offset = 0L;
#line 606
  goto switch_break;
  case_32: /* CIL Label */ 
#line 610
  if (crt_chunk_is_idat) {
#line 612
    if (! (opng_info.total_idat_size <= 2147483647UL)) {
      {
#line 612
      opng_internal_error("Exceedingly large IDAT size - not handled");
      }
    }
#line 614
    if (opng_info.num_idat_chunks == 1U) {
      {
#line 617
      idat_offset = ftell(fp);
#line 619
      png_save_uint_32(data, opng_info.total_idat_size);
#line 621
      crt_idat_crc = crc32((uLong )0, sig_IDAT, (uInt )4);
      }
    } else {
#line 626
      opng_info.file_size -= 8UL;
#line 627
      return;
    }
  } else {
#line 634
    if (! (opng_info.num_idat_chunks == 0U)) {
#line 634
      if (! (opng_info.idat_size == opng_info.total_idat_size)) {
#line 634
        if (! (opng_info.total_idat_size == 0UL)) {
          {
#line 634
          opng_internal_error("Inconsistent IDAT");
          }
        }
      }
    }
#line 638
    if (idat_offset != 0L) {
      {
#line 646
      png_save_uint_32(buf___1, crt_idat_crc);
#line 647
      num = fwrite((void const   */* __restrict  */)(buf___1), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)fp);
#line 648
      opng_info.file_size += 4UL;
      }
#line 650
      if (! (opng_info.total_idat_size == 0UL)) {
        {
#line 650
        opng_internal_error("Got lost...");
        }
      }
      {
#line 651
      opng_info.total_idat_size = opng_info.idat_size;
#line 652
      png_save_uint_32(buf___1, opng_info.idat_size);
#line 653
      tmp___7 = osys_fwrite_at(fp, idat_offset, 0, (void const   *)(buf___1), (size_t )4);
#line 653
      num += tmp___7;
      }
#line 654
      if (num != 8UL) {
        {
#line 655
        png_error(png_ptr, "Can\'t finalize IDAT");
        }
      }
#line 656
      idat_offset = 0L;
    }
  }
#line 659
  goto switch_break;
  case_64: /* CIL Label */ 
#line 663
  if (crt_chunk_is_idat) {
    {
#line 664
    crt_idat_crc = crc32(crt_idat_crc, (Bytef const   *)data, (uInt )length);
    }
  }
#line 665
  goto switch_break;
  case_128: /* CIL Label */ 
#line 669
  if (crt_chunk_is_idat) {
#line 671
    if (opng_info.idat_size < opng_info.total_idat_size) {
#line 675
      opng_info.file_size -= 4UL;
#line 676
      return;
    } else
#line 671
    if (opng_info.total_idat_size == 0UL) {
#line 675
      opng_info.file_size -= 4UL;
#line 676
      return;
    }
    {
#line 678
    png_save_uint_32(data, crt_idat_crc);
#line 679
    idat_offset = 0L;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 683
  tmp___8 = fwrite((void const   */* __restrict  */)data, length, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 683
  if (tmp___8 != 1UL) {
    {
#line 684
    png_error(png_ptr, "Can\'t write the output file");
    }
  }
#line 685
  return;
}
}
#line 689 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_get_image_info(png_structp png_ptr , png_infop info_ptr , png_infop end_info_ptr ,
                                int get_ancillary ) 
{ 
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;
  png_uint_32 tmp___1 ;
  png_uint_32 tmp___2 ;

  {
  {
#line 693
  memset((void *)(& opng_image), 0, sizeof(opng_image));
#line 696
  png_get_IHDR(png_ptr, info_ptr, & opng_image.width, & opng_image.height, & opng_image.bit_depth,
               & opng_image.color_type, & opng_image.interlace_type, & opng_image.compression_type,
               & opng_image.filter_type);
#line 700
  opng_image.row_pointers = png_get_rows(png_ptr, info_ptr);
#line 701
  png_get_PLTE(png_ptr, info_ptr, & opng_image.palette, & opng_image.num_palette);
  }
#line 704
  if (! get_ancillary) {
#line 705
    return;
  }
  {
#line 707
  tmp = png_get_bKGD(png_ptr, info_ptr, & opng_image.background_ptr);
  }
#line 707
  if (tmp) {
#line 712
    opng_image.background = *(opng_image.background_ptr);
#line 713
    opng_image.background_ptr = & opng_image.background;
  }
  {
#line 715
  png_get_hIST(png_ptr, info_ptr, & opng_image.hist);
#line 716
  tmp___0 = png_get_sBIT(png_ptr, info_ptr, & opng_image.sig_bit_ptr);
  }
#line 716
  if (tmp___0) {
#line 719
    opng_image.sig_bit = *(opng_image.sig_bit_ptr);
#line 720
    opng_image.sig_bit_ptr = & opng_image.sig_bit;
  }
  {
#line 722
  tmp___1 = png_get_tRNS(png_ptr, info_ptr, & opng_image.trans, & opng_image.num_trans,
                         & opng_image.trans_values_ptr);
  }
#line 722
  if (tmp___1) {
#line 727
    if ((unsigned long )opng_image.trans_values_ptr != (unsigned long )((void *)0)) {
#line 729
      opng_image.trans_values = *(opng_image.trans_values_ptr);
#line 730
      opng_image.trans_values_ptr = & opng_image.trans_values;
    }
  }
  {
#line 733
  tmp___2 = png_get_unknown_chunks(png_ptr, info_ptr, & opng_image.unknowns);
#line 733
  opng_image.num_unknowns = (int )tmp___2;
  }
#line 736
  if ((unsigned long )(& end_info_ptr) == (unsigned long )((void *)0)) {
#line 737
    return;
  }
#line 738
  return;
}
}
#line 742 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_set_image_info(png_structp png_ptr , png_infop info_ptr , png_infop end_info_ptr ,
                                int set_ancillary ) 
{ 
  int i ;

  {
  {
#line 747
  png_set_IHDR(png_ptr, info_ptr, opng_image.width, opng_image.height, opng_image.bit_depth,
               opng_image.color_type, opng_image.interlace_type, opng_image.compression_type,
               opng_image.filter_type);
#line 751
  png_set_rows(write_ptr, write_info_ptr, opng_image.row_pointers);
  }
#line 752
  if ((unsigned long )opng_image.palette != (unsigned long )((void *)0)) {
    {
#line 753
    png_set_PLTE(png_ptr, info_ptr, opng_image.palette, opng_image.num_palette);
    }
  }
#line 756
  if (! set_ancillary) {
#line 757
    return;
  }
#line 759
  if ((unsigned long )opng_image.background_ptr != (unsigned long )((void *)0)) {
    {
#line 760
    png_set_bKGD(png_ptr, info_ptr, opng_image.background_ptr);
    }
  }
#line 761
  if ((unsigned long )opng_image.hist != (unsigned long )((void *)0)) {
    {
#line 762
    png_set_hIST(png_ptr, info_ptr, opng_image.hist);
    }
  }
#line 763
  if ((unsigned long )opng_image.sig_bit_ptr != (unsigned long )((void *)0)) {
    {
#line 764
    png_set_sBIT(png_ptr, info_ptr, opng_image.sig_bit_ptr);
    }
  }
#line 765
  if ((unsigned long )opng_image.trans != (unsigned long )((void *)0)) {
    {
#line 766
    png_set_tRNS(png_ptr, info_ptr, opng_image.trans, opng_image.num_trans, opng_image.trans_values_ptr);
    }
  } else
#line 765
  if ((unsigned long )opng_image.trans_values_ptr != (unsigned long )((void *)0)) {
    {
#line 766
    png_set_tRNS(png_ptr, info_ptr, opng_image.trans, opng_image.num_trans, opng_image.trans_values_ptr);
    }
  }
#line 769
  if (opng_image.num_unknowns != 0) {
    {
#line 772
    png_set_unknown_chunks(png_ptr, info_ptr, opng_image.unknowns, opng_image.num_unknowns);
#line 775
    i = 0;
    }
    {
#line 775
    while (1) {
      while_continue: /* CIL Label */ ;
#line 775
      if (! (i < opng_image.num_unknowns)) {
#line 775
        goto while_break;
      }
      {
#line 776
      png_set_unknown_chunk_location(png_ptr, info_ptr, i, (int )(opng_image.unknowns + i)->location);
#line 775
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 780
  if ((unsigned long )(& end_info_ptr) == (unsigned long )((void *)0)) {
#line 781
    return;
  }
#line 782
  return;
}
}
#line 786 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_free_image_info(void) 
{ 
  png_uint_32 i ;
  int j ;

  {
#line 792
  if ((unsigned long )opng_image.row_pointers == (unsigned long )((void *)0)) {
#line 793
    return;
  }
#line 795
  i = (png_uint_32 )0;
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! (i < opng_image.height)) {
#line 795
      goto while_break;
    }
    {
#line 796
    opng_free((void *)*(opng_image.row_pointers + i));
#line 795
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 797
  opng_free((void *)opng_image.row_pointers);
#line 798
  opng_free((void *)opng_image.palette);
#line 799
  opng_free((void *)opng_image.hist);
#line 800
  opng_free((void *)opng_image.trans);
#line 801
  j = 0;
  }
  {
#line 801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 801
    if (! (j < opng_image.num_unknowns)) {
#line 801
      goto while_break___0;
    }
    {
#line 802
    opng_free((void *)(opng_image.unknowns + j)->data);
#line 801
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 803
  opng_free((void *)opng_image.unknowns);
#line 807
  memset((void *)(& opng_image), 0, sizeof(opng_image));
  }
#line 808
  return;
}
}
#line 812 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_read_png(FILE *infile___0 ) 
{ 
  png_uint_32 reductions ;
  char const   *extern_fmt ;
  char const   *err_msg ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_charp tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 818
  opng_info.valid = 1;
#line 819
  opng_info.idat_size = (png_uint_32 )0;
#line 819
  opng_info.file_size = opng_info.idat_size;
#line 820
  opng_info.num_idat_chunks = 0U;
#line 822
  if (! ((unsigned long )infile___0 != (unsigned long )((void *)0))) {
    {
#line 822
    __assert_fail("infile != NULL", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  822U, "opng_read_png");
    }
  }
  {
#line 824
  exception__prev = the_exception_context[0].penv;
#line 824
  the_exception_context[0].penv = & exception__env;
#line 824
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 824
  if (tmp___2 == 0) {
#line 824
    if (& exception__prev) {
      {
#line 826
      read_end_info_ptr = (png_infop )((void *)0);
#line 826
      read_info_ptr = read_end_info_ptr;
#line 827
      read_ptr = png_create_read_struct("1.2.12-optipng", (void *)0, & opng_error,
                                        & opng_warning);
      }
#line 829
      if ((unsigned long )read_ptr != (unsigned long )((void *)0)) {
        {
#line 831
        read_info_ptr = png_create_info_struct(read_ptr);
        }
#line 832
        if ((unsigned long )read_info_ptr != (unsigned long )((void *)0)) {
          {
#line 833
          read_end_info_ptr = png_create_info_struct(read_ptr);
          }
        }
      }
#line 835
      if ((unsigned long )read_end_info_ptr == (unsigned long )((void *)0)) {
        {
#line 836
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 836
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 836
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 838
      png_set_keep_unknown_chunks(read_ptr, 3, (png_bytep )((void *)0), 0);
#line 839
      opng_set_read_fn(read_ptr, (png_voidp )infile___0, & opng_read_write_data);
#line 842
      tmp___0 = pngx_read_external(read_ptr, read_info_ptr, infile___0);
#line 842
      extern_fmt = (char const   *)tmp___0;
      }
#line 843
      if ((unsigned long )extern_fmt != (unsigned long )((void *)0)) {
        {
#line 845
        opng_printf("%s format detected\n", extern_fmt);
#line 846
        opng_info.input_is_png = 0;
#line 847
        fseek(infile___0, 0L, 2);
#line 848
        tmp___1 = ftell(infile___0);
#line 848
        opng_info.file_size = (png_uint_32 )tmp___1;
#line 849
        opng_info.idat_size = (png_uint_32 )0;
        }
      } else {
        {
#line 854
        png_read_png(read_ptr, read_info_ptr, 0, (void *)0);
#line 855
        opng_info.input_is_png = 1;
        }
      }
    }
#line 858
    the_exception_context[0].caught = 0;
  } else {
#line 858
    the_exception_context[0].caught = 1;
  }
#line 858
  the_exception_context[0].penv = exception__prev;
#line 858
  if (! (! the_exception_context[0].caught)) {
    {
#line 858
    err_msg = (char const   *)the_exception_context[0].v.etmp;
#line 862
    tmp___3 = opng_validate_image(read_ptr, read_info_ptr);
    }
#line 862
    if (tmp___3) {
      {
#line 863
      opng_warning(read_ptr, err_msg);
      }
    } else {
      {
#line 867
      png_data_freer(read_ptr, read_info_ptr, 1, (png_uint_32 )32767);
#line 869
      png_data_freer(read_ptr, read_end_info_ptr, 1, (png_uint_32 )32767);
#line 871
      png_destroy_read_struct(& read_ptr, & read_info_ptr, & read_end_info_ptr);
      }
      {
#line 873
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 873
        the_exception_context[0].v.etmp = (char const   */* volatile  */)err_msg;
#line 873
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 877
  opng_get_image_info(read_ptr, read_info_ptr, read_end_info_ptr, 0);
#line 878
  opng_print_image_info(1, 1, 1);
#line 879
  opng_printf("\n");
#line 882
  reductions = (png_uint_32 )1011;
  }
#line 883
  if (cmdline.nb) {
#line 884
    reductions &= 0xfffffffffffffffcUL;
  }
#line 885
  if (cmdline.nc) {
#line 886
    reductions &= 0xffffffffffffff0fUL;
  }
#line 887
  if (cmdline.np) {
#line 888
    reductions &= 0xfffffffffffffcffUL;
  }
  {
#line 889
  reductions = opng_reduce_image(read_ptr, read_info_ptr, reductions);
#line 889
  opng_info.reductions = reductions;
#line 892
  opng_get_image_info(read_ptr, read_info_ptr, read_end_info_ptr, 1);
  }
#line 894
  if (reductions != 0UL) {
#line 896
    if (reductions & 243UL) {
      {
#line 898
      opng_printf("The image is losslessly reduced to ");
#line 899
      opng_print_image_info(0, 1, 0);
#line 900
      opng_printf("\n");
      }
    }
#line 902
    if (reductions & 768UL) {
      {
#line 903
      opng_printf("The color palette or transparency is losslessly reduced.\n");
      }
    }
  }
  {
#line 909
  png_data_freer(read_ptr, read_info_ptr, 2, (png_uint_32 )32767);
#line 911
  png_data_freer(read_ptr, read_end_info_ptr, 2, (png_uint_32 )32767);
#line 913
  png_destroy_read_struct(& read_ptr, & read_info_ptr, & read_end_info_ptr);
  }
#line 914
  return;
}
}
#line 927
static void opng_write_png(FILE *outfile___0 , int compression_level , int memory_level ,
                           int compression_strategy , int filter ) ;
#line 927 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static int filter_table[6]  = {      8,      16,      32,      64, 
        128,      248};
#line 920 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_write_png(FILE *outfile___0 , int compression_level , int memory_level ,
                           int compression_strategy , int filter ) 
{ 
  char const   * volatile  err_msg ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 933
  if (compression_level >= 1) {
#line 933
    if (! (compression_level <= 9)) {
      {
#line 933
      __assert_fail("compression_level >= COMPR_LEVEL_MIN && compression_level <= COMPR_LEVEL_MAX",
                    "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    934U, "opng_write_png");
      }
    }
  } else {
    {
#line 933
    __assert_fail("compression_level >= COMPR_LEVEL_MIN && compression_level <= COMPR_LEVEL_MAX",
                  "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  934U, "opng_write_png");
    }
  }
#line 935
  if (memory_level >= 1) {
#line 935
    if (! (memory_level <= 9)) {
      {
#line 935
      __assert_fail("memory_level >= MEM_LEVEL_MIN && memory_level <= MEM_LEVEL_MAX",
                    "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    936U, "opng_write_png");
      }
    }
  } else {
    {
#line 935
    __assert_fail("memory_level >= MEM_LEVEL_MIN && memory_level <= MEM_LEVEL_MAX",
                  "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  936U, "opng_write_png");
    }
  }
#line 937
  if (compression_strategy >= 0) {
#line 937
    if (! (compression_strategy <= 3)) {
      {
#line 937
      __assert_fail("compression_strategy >= STRATEGY_MIN && compression_strategy <= STRATEGY_MAX",
                    "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    938U, "opng_write_png");
      }
    }
  } else {
    {
#line 937
    __assert_fail("compression_strategy >= STRATEGY_MIN && compression_strategy <= STRATEGY_MAX",
                  "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  938U, "opng_write_png");
    }
  }
#line 939
  if (filter >= 0) {
#line 939
    if (! (filter <= 5)) {
      {
#line 939
      __assert_fail("filter >= FILTER_MIN && filter <= FILTER_MAX", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    940U, "opng_write_png");
      }
    }
  } else {
    {
#line 939
    __assert_fail("filter >= FILTER_MIN && filter <= FILTER_MAX", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  940U, "opng_write_png");
    }
  }
  {
#line 942
  opng_info.idat_size = (png_uint_32 )0;
#line 942
  opng_info.file_size = opng_info.idat_size;
#line 943
  opng_info.num_idat_chunks = 0U;
#line 945
  exception__prev = the_exception_context[0].penv;
#line 945
  the_exception_context[0].penv = & exception__env;
#line 945
  tmp___4 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 945
  if (tmp___4 == 0) {
#line 945
    if (& exception__prev) {
      {
#line 947
      write_end_info_ptr = (png_infop )((void *)0);
#line 947
      write_info_ptr = write_end_info_ptr;
#line 948
      write_ptr = png_create_write_struct("1.2.12-optipng", (void *)0, & opng_error,
                                          & opng_warning);
      }
#line 950
      if ((unsigned long )write_ptr != (unsigned long )((void *)0)) {
        {
#line 952
        write_info_ptr = png_create_info_struct(write_ptr);
        }
#line 953
        if ((unsigned long )write_info_ptr != (unsigned long )((void *)0)) {
          {
#line 954
          write_end_info_ptr = png_create_info_struct(write_ptr);
          }
        }
      }
#line 956
      if ((unsigned long )write_end_info_ptr == (unsigned long )((void *)0)) {
        {
#line 957
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 957
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 957
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 959
      png_set_compression_level(write_ptr, compression_level);
#line 960
      png_set_compression_mem_level(write_ptr, memory_level);
#line 961
      png_set_compression_strategy(write_ptr, compression_strategy);
#line 962
      png_set_filter(write_ptr, 0, filter_table[filter]);
      }
#line 963
      if (compression_strategy != 2) {
#line 963
        if (compression_strategy != 3) {
#line 966
          if (cmdline.window_bits > 0) {
            {
#line 967
            png_set_compression_window_bits(write_ptr, cmdline.window_bits);
            }
          }
        } else {
          {
#line 974
          png_set_compression_window_bits(write_ptr, 9);
          }
        }
      } else {
        {
#line 974
        png_set_compression_window_bits(write_ptr, 9);
        }
      }
      {
#line 978
      png_set_keep_unknown_chunks(write_ptr, 3, (png_bytep )((void *)0), 0);
      }
#line 982
      if ((unsigned long )outfile___0 != (unsigned long )((void *)0)) {
#line 982
        tmp___3 = 1;
      } else
#line 982
      if (opng_info.reductions != 0UL) {
#line 982
        tmp___3 = 1;
      } else {
#line 982
        tmp___3 = 0;
      }
      {
#line 982
      opng_set_image_info(write_ptr, write_info_ptr, write_end_info_ptr, tmp___3);
      }
#line 986
      if ((unsigned long )outfile___0 == (unsigned long )((void *)0)) {
#line 988
        opng_info.last_ipass = 0;
#line 989
        if (! cmdline.full) {
#line 991
          opng_info.last_row = opng_image.height - 1UL;
#line 992
          if (opng_image.interlace_type == 1) {
#line 994
            if (opng_image.height >= 8UL) {
#line 996
              opng_info.last_row &= 0xfffffffffffffffeUL;
#line 997
              opng_info.last_ipass = 6;
            } else {
#line 1000
              opng_info.last_row = (png_uint_32 )0;
            }
          }
          {
#line 1002
          png_set_write_status_fn(write_ptr, & opng_read_write_status);
          }
        } else {
#line 1005
          opng_info.last_row = (png_uint_32 )0;
        }
      }
      {
#line 1009
      opng_set_write_fn(write_ptr, (png_voidp )outfile___0, & opng_read_write_data,
                        (void (*)(png_structp  ))((void *)0));
#line 1010
      png_write_png(write_ptr, write_info_ptr, 0, (void *)0);
#line 1012
      err_msg = (char const   */* volatile  */)((void *)0);
      }
    }
#line 1014
    the_exception_context[0].caught = 0;
  } else {
#line 1014
    the_exception_context[0].caught = 1;
  }
#line 1014
  the_exception_context[0].penv = exception__prev;
#line 1014
  if (! (! the_exception_context[0].caught)) {
#line 1014
    err_msg = the_exception_context[0].v.etmp;
#line 1017
    opng_info.idat_size = 2147483648UL;
  }
  {
#line 1021
  png_destroy_info_struct(write_ptr, & write_end_info_ptr);
#line 1022
  png_destroy_write_struct(& write_ptr, & write_info_ptr);
  }
#line 1024
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1025
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1025
      the_exception_context[0].v.etmp = err_msg;
#line 1025
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1026
  return;
}
}
#line 1030 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_copy_png(FILE *infile___0 , FILE *outfile___0 ) 
{ 
  png_bytep volatile   buf___1 ;
  png_uint_32 buf_size ;
  png_uint_32 length ;
  png_byte chunk_name[4] ;
  char const   * volatile  err_msg ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_voidp tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  png_voidp tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1038
  if ((unsigned long )infile___0 != (unsigned long )((void *)0)) {
#line 1038
    if (! ((unsigned long )outfile___0 != (unsigned long )((void *)0))) {
      {
#line 1038
      __assert_fail("infile != NULL && outfile != NULL", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    1038U, "opng_copy_png");
      }
    }
  } else {
    {
#line 1038
    __assert_fail("infile != NULL && outfile != NULL", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                  1038U, "opng_copy_png");
    }
  }
  {
#line 1040
  opng_info.idat_size = (png_uint_32 )0;
#line 1040
  opng_info.file_size = opng_info.idat_size;
#line 1041
  opng_info.num_idat_chunks = 0U;
#line 1043
  write_ptr = png_create_write_struct("1.2.12-optipng", (void *)0, & opng_error, & opng_warning);
  }
#line 1045
  if ((unsigned long )write_ptr == (unsigned long )((void *)0)) {
    {
#line 1046
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1046
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 1046
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1047
  opng_set_write_fn(write_ptr, (png_voidp )outfile___0, & opng_read_write_data, (void (*)(png_structp  ))((void *)0));
#line 1049
  exception__prev = the_exception_context[0].penv;
#line 1049
  the_exception_context[0].penv = & exception__env;
#line 1049
  tmp___7 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1049
  if (tmp___7 == 0) {
#line 1049
    if (& exception__prev) {
      {
#line 1051
      buf_size = (png_uint_32 )4096;
#line 1052
      tmp___0 = png_malloc(write_ptr, buf_size);
#line 1052
      buf___1 = (png_bytep volatile   )((png_bytep )tmp___0);
#line 1055
      tmp___1 = fread((void */* __restrict  */)buf___1, (size_t )8, (size_t )1, (FILE */* __restrict  */)infile___0);
      }
#line 1055
      if (tmp___1 != 1UL) {
#line 1055
        goto _L;
      } else {
        {
#line 1055
        tmp___2 = png_sig_cmp((png_bytep )buf___1, (png_size_t )0, (png_size_t )8);
        }
#line 1055
        if (tmp___2 != 0) {
          _L: /* CIL Label */ 
          {
#line 1056
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1056
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Not a PNG file";
#line 1056
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 1058
      png_write_sig(write_ptr);
      }
      {
#line 1073
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1076
        tmp___3 = fread((void */* __restrict  */)buf___1, (size_t )8, (size_t )1,
                        (FILE */* __restrict  */)infile___0);
        }
#line 1076
        if (tmp___3 != 1UL) {
          {
#line 1077
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1077
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1077
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1078
        length = png_get_uint_32((png_bytep )buf___1);
#line 1079
        memcpy((void */* __restrict  */)(chunk_name), (void const   */* __restrict  */)(buf___1 + 4),
               (size_t )4);
        }
#line 1080
        if (length > buf_size) {
          {
#line 1083
          opng_free((void *)buf___1);
#line 1084
          buf_size = length;
#line 1085
          tmp___4 = png_malloc(write_ptr, buf_size);
#line 1085
          buf___1 = (png_bytep volatile   )((png_bytep )tmp___4);
          }
        }
        {
#line 1087
        tmp___5 = fread((void */* __restrict  */)buf___1, (size_t )1, length, (FILE */* __restrict  */)infile___0);
        }
#line 1087
        if (tmp___5 != length) {
          {
#line 1088
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 1088
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1088
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 1089
        png_write_chunk(write_ptr, chunk_name, (png_bytep )buf___1, length);
#line 1090
        fread((void */* __restrict  */)buf___1, (size_t )4, (size_t )1, (FILE */* __restrict  */)infile___0);
#line 1073
        tmp___6 = memcmp((void const   *)(chunk_name), (void const   *)(sig_IEND),
                         (size_t )4);
        }
#line 1073
        if (! (tmp___6 != 0)) {
#line 1073
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1093
      err_msg = (char const   */* volatile  */)((void *)0);
    }
#line 1095
    the_exception_context[0].caught = 0;
  } else {
#line 1095
    the_exception_context[0].caught = 1;
  }
#line 1095
  the_exception_context[0].penv = exception__prev;
#line 1095
  if (! the_exception_context[0].caught) {
#line 1095
    tmp___8 = 1;
  } else {
#line 1095
    err_msg = the_exception_context[0].v.etmp;
#line 1095
    tmp___8 = 0;
  }
  {
#line 1099
  opng_free((void *)buf___1);
#line 1100
  png_destroy_write_struct(& write_ptr, (png_infopp )((void *)0));
  }
#line 1102
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1103
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1103
      the_exception_context[0].v.etmp = err_msg;
#line 1103
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1104
  return;
}
}
#line 1108 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_init_iteration(int cmdline_set , char const   *preset , char const   *mask ,
                                int *output_set ) 
{ 
  bitset_t set ;
  int tmp ;
  int tmp___0 ;

  {
#line 1114
  *output_set = cmdline_set;
#line 1115
  if (*output_set == 0) {
#line 1115
    goto _L;
  } else
#line 1115
  if (cmdline.optim_level >= 0) {
    _L: /* CIL Label */ 
    {
#line 1117
    tmp = bitset_parse(preset, & set);
    }
#line 1117
    if (! (tmp == 0)) {
      {
#line 1117
      opng_internal_error("Invalid iteration preset");
      }
    }
#line 1118
    *output_set |= set;
  }
  {
#line 1120
  tmp___0 = bitset_parse(mask, & set);
  }
#line 1120
  if (! (tmp___0 == 0)) {
    {
#line 1120
    opng_internal_error("Invalid iteration mask");
    }
  }
#line 1121
  *output_set &= set;
#line 1122
  return;
}
}
#line 1126 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_init_iterations(void) 
{ 
  bitset_t compr_level_set ;
  bitset_t mem_level_set ;
  bitset_t strategy_set ;
  bitset_t filter_set ;
  int preset_index ;
  int t1 ;
  int t2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1137
  preset_index = cmdline.optim_level;
#line 1138
  if (preset_index < 0) {
#line 1139
    preset_index = 2;
  } else
#line 1140
  if (preset_index > 7) {
#line 1141
    preset_index = 7;
  }
  {
#line 1146
  opng_init_iteration(cmdline.compr_level_set, compr_level_presets[preset_index],
                      compr_level_mask, & compr_level_set);
#line 1148
  opng_init_iteration(cmdline.mem_level_set, mem_level_presets[preset_index], mem_level_mask,
                      & mem_level_set);
#line 1150
  opng_init_iteration(cmdline.strategy_set, strategy_presets[preset_index], strategy_mask,
                      & strategy_set);
#line 1152
  opng_init_iteration(cmdline.filter_set, filter_presets[preset_index], filter_mask,
                      & filter_set);
  }
#line 1156
  if (compr_level_set == 0) {
#line 1157
    compr_level_set |= 1 << 9;
  }
#line 1158
  if (mem_level_set == 0) {
#line 1159
    mem_level_set |= 1 << 8;
  }
#line 1160
  if (opng_image.bit_depth < 8) {
#line 1160
    goto _L;
  } else
#line 1160
  if ((unsigned long )opng_image.palette != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1162
    if (strategy_set == 0) {
#line 1163
      strategy_set |= 1;
    }
#line 1164
    if (filter_set == 0) {
#line 1165
      filter_set |= 1;
    }
  } else {
#line 1169
    if (strategy_set == 0) {
#line 1170
      strategy_set |= 1 << 1;
    }
#line 1171
    if (filter_set == 0) {
#line 1172
      filter_set |= 1 << 5;
    }
  }
  {
#line 1176
  opng_info.compr_level_set = compr_level_set;
#line 1177
  opng_info.mem_level_set = mem_level_set;
#line 1178
  opng_info.strategy_set = strategy_set;
#line 1179
  opng_info.filter_set = filter_set;
#line 1180
  tmp = bitset_count(compr_level_set);
#line 1180
  tmp___0 = bitset_count(strategy_set & -4);
#line 1180
  t1 = tmp * tmp___0;
#line 1182
  t2 = bitset_count(strategy_set & 3);
#line 1183
  tmp___1 = bitset_count(mem_level_set);
#line 1183
  tmp___2 = bitset_count(filter_set);
#line 1183
  opng_info.num_iterations = ((t1 + t2) * tmp___1) * tmp___2;
  }
#line 1186
  if (opng_info.num_iterations <= 0) {
    {
#line 1187
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1187
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Invalid iteration parameters (-zc, -zm, -zs, -f)";
#line 1187
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1188
  return;
}
}
#line 1192 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_iterate(void) 
{ 
  bitset_t compr_level_set ;
  bitset_t mem_level_set ;
  bitset_t strategy_set ;
  bitset_t filter_set ;
  int compr_level ;
  int mem_level ;
  int strategy ;
  int filter ;
  int counter ;
  bitset_t saved_level_set ;

  {
#line 1199
  if (! (opng_info.num_iterations > 0)) {
    {
#line 1199
    opng_internal_error("Iteration not initialized");
    }
  }
#line 1200
  if (opng_info.num_iterations == 1) {
#line 1200
    if (! cmdline.simulate) {
#line 1200
      if (cmdline.force) {
#line 1200
        goto _L;
      } else
#line 1200
      if (! opng_info.input_is_png) {
        _L: /* CIL Label */ 
        {
#line 1204
        opng_info.best_idat_size = (png_uint_32 )0;
#line 1204
        opng_info.best_file_size = opng_info.best_idat_size;
#line 1205
        opng_info.best_compr_level = opng_bitset_min(opng_info.compr_level_set);
#line 1206
        opng_info.best_mem_level = opng_bitset_min(opng_info.mem_level_set);
#line 1207
        opng_info.best_strategy = opng_bitset_min(opng_info.strategy_set);
#line 1208
        opng_info.best_filter = opng_bitset_min(opng_info.filter_set);
        }
#line 1209
        return;
      }
    }
  }
  {
#line 1213
  compr_level_set = opng_info.compr_level_set;
#line 1214
  mem_level_set = opng_info.mem_level_set;
#line 1215
  strategy_set = opng_info.strategy_set;
#line 1216
  filter_set = opng_info.filter_set;
#line 1217
  opng_info.best_idat_size = 2147483648UL;
#line 1217
  opng_info.best_file_size = opng_info.best_idat_size;
#line 1218
  opng_info.best_filter = -1;
#line 1218
  opng_info.best_strategy = opng_info.best_filter;
#line 1218
  opng_info.best_mem_level = opng_info.best_strategy;
#line 1218
  opng_info.best_compr_level = opng_info.best_mem_level;
#line 1222
  opng_printf("Trying...\n");
#line 1223
  counter = 0;
#line 1224
  filter = 0;
  }
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1224
    if (! (filter <= 5)) {
#line 1224
      goto while_break;
    }
#line 1225
    if ((filter_set & (1 << filter)) != 0) {
#line 1226
      strategy = 0;
      {
#line 1226
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1226
        if (! (strategy <= 3)) {
#line 1226
          goto while_break___0;
        }
#line 1227
        if ((strategy_set & (1 << strategy)) != 0) {
#line 1231
          saved_level_set = compr_level_set;
#line 1232
          if (strategy == 2) {
#line 1234
            compr_level_set = 0;
#line 1235
            compr_level_set |= 1 << 1;
          } else
#line 1237
          if (strategy == 3) {
#line 1239
            compr_level_set = 0;
#line 1240
            compr_level_set |= 1 << 9;
          }
#line 1242
          compr_level = 9;
          {
#line 1242
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1242
            if (! (compr_level >= 1)) {
#line 1242
              goto while_break___1;
            }
#line 1244
            if ((compr_level_set & (1 << compr_level)) != 0) {
#line 1246
              mem_level = 9;
              {
#line 1246
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1246
                if (! (mem_level >= 1)) {
#line 1246
                  goto while_break___2;
                }
#line 1248
                if ((mem_level_set & (1 << mem_level)) != 0) {
                  {
#line 1250
                  counter ++;
#line 1251
                  opng_printf("  zc = %d  zm = %d  zs = %d  f = %d\t\t", compr_level,
                              mem_level, strategy, filter);
#line 1254
                  opng_write_png((FILE *)((void *)0), compr_level, mem_level, strategy,
                                 filter);
                  }
#line 1256
                  if (opng_info.idat_size > 2147483647UL) {
                    {
#line 1258
                    opng_printf("IDAT too big");
                    }
#line 1259
                    if (cmdline.ver) {
                      {
#line 1261
                      opng_printf(" ... abandoned at ");
#line 1262
                      opng_progress();
                      }
                    }
                    {
#line 1264
                    opng_printf("\n");
                    }
#line 1265
                    goto __Cont;
                  }
                  {
#line 1267
                  opng_printf("IDAT size = %lu\n", opng_info.idat_size);
                  }
#line 1269
                  if (opng_info.best_idat_size < opng_info.idat_size) {
#line 1270
                    goto __Cont;
                  }
#line 1271
                  if (opng_info.best_idat_size == opng_info.idat_size) {
#line 1271
                    if (opng_info.best_strategy >= 2) {
#line 1273
                      goto __Cont;
                    }
                  }
#line 1274
                  opng_info.best_file_size = opng_info.file_size;
#line 1275
                  opng_info.best_idat_size = opng_info.idat_size;
#line 1276
                  opng_info.best_compr_level = compr_level;
#line 1277
                  opng_info.best_mem_level = mem_level;
#line 1278
                  opng_info.best_strategy = strategy;
#line 1279
                  opng_info.best_filter = filter;
                }
                __Cont: /* CIL Label */ 
#line 1246
                mem_level --;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 1242
            compr_level --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1282
          compr_level_set = saved_level_set;
        }
#line 1226
        strategy ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1224
    filter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  if (! (counter == opng_info.num_iterations)) {
    {
#line 1285
    opng_internal_error("Inconsistent iteration counter");
    }
  }
#line 1288
  if (opng_info.best_idat_size > 2147483647UL) {
    {
#line 1289
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1289
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"No satisfactory IDAT was found";
#line 1289
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1290
  return;
}
}
#line 1297 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static FILE *infile  ;
#line 1297 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static FILE *outfile  ;
#line 1294 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void opng_optimize_png(char const   *filename ) 
{ 
  enum __anonenum_action_828115248  volatile  action ;
  png_uint_32 init_file_size ;
  png_uint_32 init_idat_size ;
  char bak_filename[4096] ;
  char out_filename[4096] ;
  long out_file_size ;
  char const   * volatile  err_msg ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  jmp_buf *exception__prev___0 ;
  jmp_buf exception__env___0 ;
  jmp_buf *exception__prev___1 ;
  jmp_buf exception__env___1 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___15 ;
  jmp_buf *exception__prev___2 ;
  jmp_buf exception__env___2 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 1304
  opng_printf("** Processing %s\n", filename);
#line 1306
  memset((void *)(& opng_info), 0, sizeof(opng_info));
#line 1307
  action = (enum __anonenum_action_828115248  volatile  )0;
  }
#line 1308
  if (cmdline.force) {
#line 1309
    action = (enum __anonenum_action_828115248  volatile  )2;
  }
  {
#line 1311
  err_msg = (char const   */* volatile  */)((void *)0);
#line 1313
  infile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 1313
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 1314
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1314
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the input file";
#line 1314
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1315
  exception__prev = the_exception_context[0].penv;
#line 1315
  the_exception_context[0].penv = & exception__env;
#line 1315
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1315
  if (tmp == 0) {
#line 1315
    if (& exception__prev) {
      {
#line 1317
      opng_read_png(infile);
      }
    }
#line 1319
    the_exception_context[0].caught = 0;
  } else {
#line 1319
    the_exception_context[0].caught = 1;
  }
#line 1319
  the_exception_context[0].penv = exception__prev;
#line 1319
  if (! the_exception_context[0].caught) {
#line 1319
    tmp___0 = 1;
  } else {
#line 1319
    err_msg = the_exception_context[0].v.etmp;
#line 1319
    tmp___0 = 0;
  }
  {
#line 1323
  fclose(infile);
  }
#line 1324
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1325
      the_exception_context[0].v.etmp = err_msg;
#line 1325
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1328
  if (opng_info.num_idat_chunks > 1U) {
#line 1329
    action = (enum __anonenum_action_828115248  volatile  )1;
  }
#line 1332
  if (! opng_info.input_is_png) {
    {
#line 1334
    tmp___2 = string_suffix_case_cmp(filename, ".png");
    }
#line 1334
    if (tmp___2 != 0) {
      {
#line 1336
      action = (enum __anonenum_action_828115248  volatile  )3;
#line 1338
      tmp___1 = osys_fname_chext(out_filename, sizeof(out_filename), filename, ".png");
      }
#line 1338
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 1340
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1340
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create the output file (name too long)";
#line 1340
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 1343
      action = (enum __anonenum_action_828115248  volatile  )2;
    }
  }
#line 1347
  if ((unsigned int volatile   )action == (unsigned int volatile   )3) {
#line 1349
    if (! cmdline.simulate) {
      {
#line 1349
      outfile = fopen((char const   */* __restrict  */)(out_filename), (char const   */* __restrict  */)"rb");
      }
#line 1349
      if ((unsigned long )outfile != (unsigned long )((void *)0)) {
        {
#line 1351
        fclose(outfile);
        }
#line 1352
        if (! cmdline.keep) {
          {
#line 1353
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1353
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"The output file exists, try backing it up (use -keep)";
#line 1353
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 1355
    tmp___3 = osys_fname_mkbak(bak_filename, sizeof(bak_filename), (char const   *)(out_filename));
    }
#line 1355
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 1357
      bak_filename[0] = (char )'\000';
    }
  } else {
    {
#line 1361
    tmp___4 = osys_fname_mkbak(bak_filename, sizeof(bak_filename), filename);
    }
#line 1361
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 1363
      bak_filename[0] = (char )'\000';
    }
  }
#line 1366
  if ((int )bak_filename[0] == 0) {
    {
#line 1367
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1367
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create backup file (name too long)";
#line 1367
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1369
  if (! cmdline.simulate) {
    {
#line 1369
    outfile = fopen((char const   */* __restrict  */)(bak_filename), (char const   */* __restrict  */)"rb");
    }
#line 1369
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      {
#line 1371
      fclose(outfile);
      }
      {
#line 1372
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1372
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"The backup file name exists, can\'t prepare the output file";
#line 1372
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1376
  if (! opng_info.valid) {
    {
#line 1378
    opng_printf("!Recoverable errors encountered. ");
    }
#line 1379
    if (cmdline.fix) {
      {
#line 1381
      opng_info.valid = 1;
#line 1382
      opng_printf("!Fixing...\n");
      }
#line 1383
      if ((unsigned int volatile   )action != (unsigned int volatile   )3) {
#line 1384
        action = (enum __anonenum_action_828115248  volatile  )2;
      }
#line 1385
      (global.fix_count) ++;
    } else {
      {
#line 1389
      opng_printf("!Rerun the program with the -fix option.\n");
      }
      {
#line 1390
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1390
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Previous error(s) not fixed";
#line 1390
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 1395
  if (cmdline.interlace >= 0) {
#line 1395
    if (opng_image.interlace_type != cmdline.interlace) {
#line 1398
      opng_image.interlace_type = cmdline.interlace;
#line 1399
      action = (enum __anonenum_action_828115248  volatile  )2;
    }
  }
  {
#line 1402
  init_file_size = opng_info.file_size;
#line 1403
  opng_info.total_idat_size = opng_info.idat_size;
#line 1403
  init_idat_size = opng_info.total_idat_size;
#line 1404
  opng_printf("Input file size = %lu bytes\n", init_file_size);
  }
#line 1406
  if (opng_info.input_is_png) {
    {
#line 1407
    opng_printf("Input IDAT size = %lu bytes\n", init_idat_size);
    }
  }
#line 1410
  if (opng_info.input_is_png) {
#line 1410
    if (cmdline.nz) {
#line 1410
      if ((unsigned int volatile   )action == (unsigned int volatile   )2) {
        {
#line 1411
        opng_printf("!Warning: IDAT recompression is enforced.\n");
        }
      }
    }
  }
#line 1414
  if ((unsigned int volatile   )action == (unsigned int volatile   )3) {
#line 1414
    goto _L;
  } else
#line 1414
  if ((unsigned int volatile   )action == (unsigned int volatile   )2) {
#line 1414
    goto _L;
  } else
#line 1414
  if (! cmdline.nz) {
    _L: /* CIL Label */ 
    {
#line 1416
    opng_init_iterations();
#line 1417
    opng_iterate();
    }
#line 1418
    if (opng_info.best_compr_level >= 0) {
#line 1418
      if (opng_info.best_mem_level >= 0) {
#line 1418
        if (opng_info.best_strategy >= 0) {
#line 1418
          if (! (opng_info.best_filter >= 0)) {
            {
#line 1418
            opng_internal_error("Incorrect iteration results");
            }
          }
        } else {
          {
#line 1418
          opng_internal_error("Incorrect iteration results");
          }
        }
      } else {
        {
#line 1418
        opng_internal_error("Incorrect iteration results");
        }
      }
    } else {
      {
#line 1418
      opng_internal_error("Incorrect iteration results");
      }
    }
    {
#line 1423
    opng_printf("\nSelecting parameters:\n  zc = %d  zm = %d  zs = %d  f = %d", opng_info.best_compr_level,
                opng_info.best_mem_level, opng_info.best_strategy, opng_info.best_filter);
    }
#line 1427
    if (opng_info.best_idat_size != 0UL) {
      {
#line 1428
      opng_printf("\t\tIDAT size = %lu", opng_info.best_idat_size);
      }
    }
    {
#line 1430
    opng_printf("\n");
    }
#line 1431
    if ((unsigned int volatile   )action != (unsigned int volatile   )3) {
#line 1433
      if (opng_info.reductions != 0UL) {
#line 1435
        if (opng_info.best_file_size < init_file_size) {
#line 1436
          action = (enum __anonenum_action_828115248  volatile  )2;
        }
      } else
#line 1440
      if (opng_info.best_idat_size < init_idat_size) {
#line 1441
        action = (enum __anonenum_action_828115248  volatile  )2;
      }
#line 1443
      if ((unsigned int volatile   )action == (unsigned int volatile   )2) {
#line 1444
        opng_info.total_idat_size = opng_info.best_idat_size;
      }
    }
  }
#line 1449
  if ((unsigned int volatile   )action == (unsigned int volatile   )0) {
    {
#line 1451
    opng_printf("\n%s is already optimized.\n\n", filename);
    }
#line 1452
    return;
  }
#line 1455
  out_file_size = 0L;
#line 1456
  if ((unsigned int volatile   )action == (unsigned int volatile   )1) {
#line 1456
    goto _L___0;
  } else
#line 1456
  if ((unsigned int volatile   )action == (unsigned int volatile   )2) {
    _L___0: /* CIL Label */ 
#line 1458
    if (cmdline.simulate) {
      {
#line 1460
      opng_printf("\nSimulation mode: %s not changed.\n\n", filename);
      }
#line 1461
      return;
    }
    {
#line 1465
    tmp___5 = rename(filename, (char const   *)(bak_filename));
    }
#line 1465
    if (tmp___5 != 0) {
      {
#line 1466
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1466
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the input file";
#line 1466
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1467
    exception__prev___0 = the_exception_context[0].penv;
#line 1467
    the_exception_context[0].penv = & exception__env___0;
#line 1467
    tmp___8 = _setjmp((struct __jmp_buf_tag *)(exception__env___0));
    }
#line 1467
    if (tmp___8 == 0) {
#line 1467
      if (& exception__prev___0) {
        {
#line 1469
        outfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
        }
#line 1469
        if ((unsigned long )outfile == (unsigned long )((void *)0)) {
          {
#line 1470
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 1470
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the output file";
#line 1470
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 1472
        if ((unsigned int volatile   )action == (unsigned int volatile   )1) {
          {
#line 1474
          infile = fopen((char const   */* __restrict  */)(bak_filename), (char const   */* __restrict  */)"rb");
          }
#line 1474
          if ((unsigned long )infile == (unsigned long )((void *)0)) {
            {
#line 1475
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 1475
              the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t reopen the input file";
#line 1475
              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                      1);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
          }
          {
#line 1476
          exception__prev___1 = the_exception_context[0].penv;
#line 1476
          the_exception_context[0].penv = & exception__env___1;
#line 1476
          tmp___6 = _setjmp((struct __jmp_buf_tag *)(exception__env___1));
          }
#line 1476
          if (tmp___6 == 0) {
#line 1476
            if (& exception__prev___1) {
              {
#line 1478
              opng_copy_png(infile, outfile);
              }
            }
#line 1480
            the_exception_context[0].caught = 0;
          } else {
#line 1480
            the_exception_context[0].caught = 1;
          }
#line 1480
          the_exception_context[0].penv = exception__prev___1;
#line 1480
          if (! the_exception_context[0].caught) {
#line 1480
            tmp___7 = 1;
          } else {
#line 1480
            err_msg = the_exception_context[0].v.etmp;
#line 1480
            tmp___7 = 0;
          }
          {
#line 1484
          fclose(infile);
          }
#line 1485
          if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
            {
#line 1486
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 1486
              the_exception_context[0].v.etmp = err_msg;
#line 1486
              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                      1);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 1490
          opng_write_png(outfile, opng_info.best_compr_level, opng_info.best_mem_level,
                         opng_info.best_strategy, opng_info.best_filter);
          }
        }
        {
#line 1494
        out_file_size = ftell(outfile);
        }
      }
#line 1496
      the_exception_context[0].caught = 0;
    } else {
#line 1496
      the_exception_context[0].caught = 1;
    }
#line 1496
    the_exception_context[0].penv = exception__prev___0;
#line 1496
    if (! (! the_exception_context[0].caught)) {
#line 1496
      err_msg = the_exception_context[0].v.etmp;
#line 1498
      if ((unsigned long )outfile != (unsigned long )((void *)0)) {
        {
#line 1499
        fclose(outfile);
        }
      }
      {
#line 1501
      tmp___9 = remove(filename);
      }
#line 1501
      if (tmp___9 != 0) {
        {
#line 1502
        opng_printf("!Warning: The original file was not recovered from the backup.\n");
        }
      } else {
        {
#line 1501
        tmp___10 = rename((char const   *)(bak_filename), filename);
        }
#line 1501
        if (tmp___10 != 0) {
          {
#line 1502
          opng_printf("!Warning: The original file was not recovered from the backup.\n");
          }
        }
      }
      {
#line 1504
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1504
        the_exception_context[0].v.etmp = err_msg;
#line 1504
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
#line 1506
    fclose(outfile);
    }
#line 1508
    if (cmdline.preserve) {
      {
#line 1511
      osys_fattr_cpy(filename, (char const   *)(bak_filename));
      }
    }
#line 1513
    if (! cmdline.keep) {
      {
#line 1516
      tmp___11 = remove((char const   *)(bak_filename));
      }
#line 1516
      if (tmp___11 != 0) {
        {
#line 1517
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 1517
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t remove the backup file";
#line 1517
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 1522
    if (! ((unsigned int volatile   )action == (unsigned int volatile   )3)) {
      {
#line 1522
      __assert_fail("action == create", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    1522U, "opng_optimize_png");
      }
    }
#line 1524
    if (cmdline.simulate) {
      {
#line 1526
      opng_printf("\nSimulation mode: %s not created.\n\n", out_filename);
      }
#line 1527
      return;
    }
#line 1531
    if (! ((int )out_filename[0] == (int )*(filename + 0))) {
      {
#line 1531
      __assert_fail("out_filename[0] == filename[0]", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                    1531U, "opng_optimize_png");
      }
    }
    {
#line 1532
    opng_info.total_idat_size = opng_info.best_idat_size;
#line 1533
    outfile = fopen((char const   */* __restrict  */)(out_filename), (char const   */* __restrict  */)"rb");
    }
#line 1533
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      {
#line 1535
      fclose(outfile);
      }
#line 1536
      if (! cmdline.keep) {
        {
#line 1536
        __assert_fail("cmdline.keep", "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c",
                      1536U, "opng_optimize_png");
        }
      }
      {
#line 1538
      tmp___15 = rename((char const   *)(out_filename), (char const   *)(bak_filename));
      }
#line 1538
      if (tmp___15 != 0) {
        {
#line 1539
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 1539
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the output file";
#line 1539
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
    {
#line 1541
    outfile = fopen((char const   */* __restrict  */)(out_filename), (char const   */* __restrict  */)"wb");
    }
#line 1541
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      {
#line 1542
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 1542
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the output file";
#line 1542
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    {
#line 1543
    exception__prev___2 = the_exception_context[0].penv;
#line 1543
    the_exception_context[0].penv = & exception__env___2;
#line 1543
    tmp___16 = _setjmp((struct __jmp_buf_tag *)(exception__env___2));
    }
#line 1543
    if (tmp___16 == 0) {
#line 1543
      if (& exception__prev___2) {
        {
#line 1545
        opng_write_png(outfile, opng_info.best_compr_level, opng_info.best_mem_level,
                       opng_info.best_strategy, opng_info.best_filter);
#line 1548
        out_file_size = ftell(outfile);
        }
      }
#line 1550
      the_exception_context[0].caught = 0;
    } else {
#line 1550
      the_exception_context[0].caught = 1;
    }
#line 1550
    the_exception_context[0].penv = exception__prev___2;
#line 1550
    if (! the_exception_context[0].caught) {
#line 1550
      tmp___17 = 1;
    } else {
#line 1550
      err_msg = the_exception_context[0].v.etmp;
#line 1550
      tmp___17 = 0;
    }
    {
#line 1554
    fclose(outfile);
    }
#line 1555
    if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
      {
#line 1556
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 1556
        the_exception_context[0].v.etmp = err_msg;
#line 1556
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1558
    if (cmdline.preserve) {
      {
#line 1559
      osys_fattr_cpy((char const   *)(out_filename), filename);
      }
    }
  }
  {
#line 1562
  opng_printf("\nNew IDAT size = %lu bytes", opng_info.idat_size);
  }
#line 1564
  if (opng_info.input_is_png) {
    {
#line 1566
    opng_printf(" (");
#line 1567
    opng_print_size_difference(init_idat_size, opng_info.idat_size, 0);
#line 1568
    opng_printf(")");
    }
  }
  {
#line 1570
  opng_printf("\nNew file size = %lu bytes (", opng_info.file_size);
#line 1572
  opng_print_size_difference(init_file_size, opng_info.file_size, 1);
#line 1573
  opng_printf(")\n\n");
  }
#line 1574
  if (! (out_file_size == (long )opng_info.file_size)) {
    {
#line 1574
    opng_internal_error("Inconsistent file size");
    }
  }
#line 1576
  return;
}
}
#line 1580 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void parse_args(int argc , char **argv ) 
{ 
  char *arg ;
  int cmd ;
  int stop_switch ;
  int i ;
  bitset_t set ;
  bitset_t interlace_set ;
  bitset_t optim_level_set ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int wsize ;
  int wbits ;
  char wk ;
  int nscanf ;
  int tmp___27 ;
  int tmp___28 ;

  {
  {
#line 1589
  memset((void *)(& cmdline), 0, sizeof(cmdline));
#line 1590
  cmdline.interlace = -1;
#line 1590
  cmdline.optim_level = cmdline.interlace;
#line 1591
  optim_level_set = 0;
#line 1591
  interlace_set = optim_level_set;
#line 1594
  stop_switch = 0;
#line 1595
  i = 1;
  }
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (! (i < argc)) {
#line 1595
      goto while_break;
    }
#line 1597
    arg = *(argv + i);
#line 1598
    if ((int )*(arg + 0) != 45) {
#line 1600
      cmdline.has_files = 1;
#line 1601
      goto __Cont;
    } else
#line 1598
    if (stop_switch) {
#line 1600
      cmdline.has_files = 1;
#line 1601
      goto __Cont;
    }
    {
#line 1604
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1604
      arg ++;
#line 1604
      if (! ((int )*(arg + 0) == 45)) {
#line 1604
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1606
    *(*(argv + i) + 0) = (char)0;
#line 1607
    if ((int )*(*(argv + i) + 1) == 45) {
#line 1607
      if ((int )*(arg + 0) == 0) {
#line 1609
        stop_switch = 1;
#line 1610
        goto __Cont;
      }
    }
    {
#line 1613
    string_lower(arg);
#line 1614
    cmd = 0;
#line 1616
    tmp___15 = strcmp((char const   *)arg, "?");
    }
#line 1616
    if (tmp___15 == 0) {
#line 1619
      cmdline.help = 1;
    } else {
      {
#line 1616
      tmp___16 = string_prefix_min_cmp("help", (char const   *)arg, (size_t )1);
      }
#line 1616
      if (tmp___16 == 0) {
#line 1619
        cmdline.help = 1;
      } else {
        {
#line 1621
        tmp___14 = strcmp((char const   *)arg, "v");
        }
#line 1621
        if (tmp___14 == 0) {
#line 1623
          cmdline.ver = 1;
        } else {
          {
#line 1625
          tmp___13 = string_prefix_min_cmp("keep", (char const   *)arg, (size_t )1);
          }
#line 1625
          if (tmp___13 == 0) {
#line 1627
            cmdline.keep = 1;
          } else {
            {
#line 1629
            tmp___12 = string_prefix_min_cmp("quiet", (char const   *)arg, (size_t )1);
            }
#line 1629
            if (tmp___12 == 0) {
#line 1631
              cmdline.quiet = 1;
            } else {
              {
#line 1633
              tmp___11 = string_prefix_min_cmp("fix", (char const   *)arg, (size_t )2);
              }
#line 1633
              if (tmp___11 == 0) {
#line 1635
                cmdline.fix = 1;
              } else {
                {
#line 1637
                tmp___10 = string_prefix_min_cmp("force", (char const   *)arg, (size_t )2);
                }
#line 1637
                if (tmp___10 == 0) {
#line 1639
                  cmdline.force = 1;
                } else {
                  {
#line 1641
                  tmp___9 = string_prefix_min_cmp("full", (char const   *)arg, (size_t )2);
                  }
#line 1641
                  if (tmp___9 == 0) {
#line 1643
                    cmdline.full = 1;
                  } else {
                    {
#line 1645
                    tmp___8 = string_prefix_min_cmp("log", (char const   *)arg, (size_t )2);
                    }
#line 1645
                    if (tmp___8 == 0) {
#line 1647
                      cmdline.log = 1;
#line 1648
                      i ++;
#line 1648
                      if (i < argc) {
#line 1648
                        if ((int )*(*(argv + i) + 0) != 45) {
                          {
#line 1650
                          tmp = string_suffix_case_cmp((char const   *)*(argv + i),
                                                       ".log");
                          }
#line 1650
                          if (tmp != 0) {
                            {
#line 1651
                            while (1) {
                              while_continue___1: /* CIL Label */ ;
                              {
#line 1651
                              the_exception_context[0].v.etmp = (char const   */* volatile  */)"To prevent accidental data corruption, the log file name must end with \".log\"";
#line 1651
                              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                                      1);
                              }
                            }
                            while_break___1: /* CIL Label */ ;
                            }
                          }
                          {
#line 1653
                          global.logfile = fopen((char const   */* __restrict  */)*(argv + i),
                                                 (char const   */* __restrict  */)"a");
                          }
#line 1653
                          if ((unsigned long )global.logfile == (unsigned long )((void *)0)) {
                            {
#line 1654
                            while (1) {
                              while_continue___2: /* CIL Label */ ;
                              {
#line 1654
                              the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open log file";
#line 1654
                              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                                      1);
                              }
                            }
                            while_break___2: /* CIL Label */ ;
                            }
                          }
#line 1655
                          *(*(argv + i) + 0) = (char)0;
                        } else {
#line 1648
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
                        {
#line 1658
                        while (1) {
                          while_continue___3: /* CIL Label */ ;
                          {
#line 1658
                          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Missing log file name";
#line 1658
                          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                                  1);
                          }
                        }
                        while_break___3: /* CIL Label */ ;
                        }
                      }
                    } else {
                      {
#line 1660
                      tmp___7 = string_prefix_min_cmp("preserve", (char const   *)arg,
                                                      (size_t )2);
                      }
#line 1660
                      if (tmp___7 == 0) {
#line 1662
                        cmdline.preserve = 1;
                      } else {
                        {
#line 1664
                        tmp___6 = string_prefix_min_cmp("simulate", (char const   *)arg,
                                                        (size_t )2);
                        }
#line 1664
                        if (tmp___6 == 0) {
#line 1666
                          cmdline.simulate = 1;
                        } else {
                          {
#line 1668
                          tmp___5 = strcmp((char const   *)arg, "no");
                          }
#line 1668
                          if (tmp___5 == 0) {
                            {
#line 1670
                            opng_printf("!Warning: Option -no is deprecated. Use -simulate.\n\n");
#line 1671
                            cmdline.simulate = 1;
                            }
                          } else {
                            {
#line 1673
                            tmp___4 = strcmp((char const   *)arg, "nb");
                            }
#line 1673
                            if (tmp___4 == 0) {
#line 1675
                              cmdline.nb = 1;
                            } else {
                              {
#line 1677
                              tmp___3 = strcmp((char const   *)arg, "nc");
                              }
#line 1677
                              if (tmp___3 == 0) {
#line 1679
                                cmdline.nc = 1;
                              } else {
                                {
#line 1681
                                tmp___2 = strcmp((char const   *)arg, "np");
                                }
#line 1681
                                if (tmp___2 == 0) {
#line 1683
                                  cmdline.np = 1;
                                } else {
                                  {
#line 1685
                                  tmp___1 = strcmp((char const   *)arg, "nz");
                                  }
#line 1685
                                  if (tmp___1 == 0) {
#line 1687
                                    cmdline.nz = 1;
                                  } else {
#line 1692
                                    cmd = (int )*(arg + 0);
#line 1693
                                    if (cmd == 122) {
                                      {
#line 1694
                                      arg ++;
#line 1694
                                      cmd = toupper((int )*(arg + 0));
                                      }
                                    }
#line 1695
                                    if ((int )*(arg + 1) < 97) {
#line 1695
                                      goto _L___2;
                                    } else
#line 1695
                                    if ((int )*(arg + 1) > 122) {
                                      _L___2: /* CIL Label */ 
#line 1695
                                      if (cmd != 0) {
                                        {
#line 1695
                                        tmp___0 = strchr("fioCMSW", cmd);
                                        }
#line 1695
                                        if (tmp___0) {
#line 1698
                                          arg ++;
#line 1699
                                          if ((int )*(arg + 0) == 0) {
#line 1701
                                            i ++;
#line 1701
                                            if (i < argc) {
#line 1702
                                              arg = *(argv + i);
                                            } else {
#line 1704
                                              arg = (char *)"[NULL]";
                                            }
                                          }
                                        } else {
#line 1695
                                          goto _L___1;
                                        }
                                      } else {
#line 1695
                                        goto _L___1;
                                      }
                                    } else {
                                      _L___1: /* CIL Label */ 
#line 1709
                                      *(*(argv + i) + 0) = (char )'-';
                                      {
#line 1710
                                      while (1) {
                                        while_continue___4: /* CIL Label */ ;
                                        {
#line 1710
                                        the_exception_context[0].v.etmp = (char const   */* volatile  */)*(argv + i);
#line 1710
                                        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                                                1);
                                        }
                                      }
                                      while_break___4: /* CIL Label */ ;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1717
    if (cmd == 0) {
#line 1717
      goto case_0;
    }
#line 1719
    if (cmd == 102) {
#line 1719
      goto case_102;
    }
#line 1726
    if (cmd == 105) {
#line 1726
      goto case_105;
    }
#line 1736
    if (cmd == 111) {
#line 1736
      goto case_111;
    }
#line 1757
    if (cmd == 67) {
#line 1757
      goto case_67;
    }
#line 1764
    if (cmd == 77) {
#line 1764
      goto case_77;
    }
#line 1771
    if (cmd == 83) {
#line 1771
      goto case_83;
    }
#line 1778
    if (cmd == 87) {
#line 1778
      goto case_87;
    }
#line 1808
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1718
    goto __Cont;
    case_102: /* CIL Label */ 
    {
#line 1721
    tmp___17 = bitset_parse((char const   *)arg, & set);
    }
#line 1721
    if (tmp___17 != 0) {
      {
#line 1722
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1722
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"filter(s)";
#line 1722
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1723
    cmdline.filter_set |= set;
#line 1724
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 1728
    tmp___18 = bitset_parse((char const   *)arg, & set);
    }
#line 1728
    if (tmp___18 != 0) {
#line 1728
      goto _L___3;
    } else {
      {
#line 1728
      tmp___19 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d",
                        & cmdline.interlace);
      }
#line 1728
      if (tmp___19 < 1) {
#line 1728
        goto _L___3;
      } else
#line 1728
      if ((cmdline.interlace & -2) != 0) {
        _L___3: /* CIL Label */ 
        {
#line 1731
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1731
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"interlace type";
#line 1731
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
    {
#line 1732
    interlace_set |= set;
#line 1732
    tmp___20 = bitset_count(interlace_set);
    }
#line 1732
    if (tmp___20 != 1) {
      {
#line 1733
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1733
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"multiple interlace types are not permitted";
#line 1733
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1734
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 1738
    tmp___21 = bitset_parse((char const   *)arg, & set);
    }
#line 1738
    if (tmp___21 != 0) {
#line 1738
      goto _L___4;
    } else {
      {
#line 1738
      tmp___22 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d",
                        & cmdline.optim_level);
      }
#line 1738
      if (tmp___22 < 1) {
        _L___4: /* CIL Label */ 
        {
#line 1740
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 1740
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"optimization level";
#line 1740
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
    {
#line 1741
    optim_level_set |= set;
#line 1741
    tmp___23 = bitset_count(optim_level_set);
    }
#line 1741
    if (tmp___23 != 1) {
      {
#line 1742
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 1742
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"multiple optimization levels are not permitted";
#line 1742
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 1743
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 1759
    tmp___24 = bitset_parse((char const   *)arg, & set);
    }
#line 1759
    if (tmp___24 != 0) {
      {
#line 1760
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1760
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"compression level(s)";
#line 1760
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 1761
    cmdline.compr_level_set |= set;
#line 1762
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1766
    tmp___25 = bitset_parse((char const   *)arg, & set);
    }
#line 1766
    if (tmp___25 != 0) {
      {
#line 1767
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 1767
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"memory level(s)";
#line 1767
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 1768
    cmdline.mem_level_set |= set;
#line 1769
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 1773
    tmp___26 = bitset_parse((char const   *)arg, & set);
    }
#line 1773
    if (tmp___26 != 0) {
      {
#line 1774
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1774
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"strategy";
#line 1774
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1775
    cmdline.strategy_set |= set;
#line 1776
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 1783
    tmp___27 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%u%c",
                      & wsize, & wk);
#line 1783
    nscanf = tmp___27;
    }
#line 1784
    if (nscanf == 0) {
#line 1785
      wsize = 0U;
    } else
#line 1786
    if (nscanf == 2) {
      {
#line 1788
      tmp___28 = tolower((int )wk);
      }
#line 1788
      if (tmp___28 == 107) {
#line 1788
        if (wsize <= 32U) {
#line 1789
          wsize *= 1024U;
        } else {
#line 1791
          wsize = 0U;
        }
      } else {
#line 1791
        wsize = 0U;
      }
    }
#line 1793
    wbits = 15;
    {
#line 1793
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1793
      if (! (wbits >= 8)) {
#line 1793
        goto while_break___13;
      }
#line 1794
      if (1U << wbits == wsize) {
#line 1795
        goto while_break___13;
      }
#line 1793
      wbits --;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1796
    if (wbits < 8) {
      {
#line 1797
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 1797
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"window size";
#line 1797
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    } else
#line 1799
    if (wbits == 8) {
#line 1800
      wbits = 9;
    }
#line 1802
    if (cmdline.window_bits > 0) {
#line 1802
      if (cmdline.window_bits != wbits) {
        {
#line 1803
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 1803
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"multiple window sizes are not permitted";
#line 1803
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___15: /* CIL Label */ ;
        }
      } else {
#line 1805
        cmdline.window_bits = wbits;
      }
    } else {
#line 1805
      cmdline.window_bits = wbits;
    }
#line 1806
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1811
    if (! (cmd == 0)) {
      {
#line 1811
      opng_internal_error("Error in command-line parsing");
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1815
    *(arg + 0) = (char)0;
    __Cont: /* CIL Label */ 
#line 1595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1819
  if (cmdline.optim_level == 0) {
#line 1820
    cmdline.nz = 1;
  }
#line 1821
  if (cmdline.nz) {
#line 1822
    cmdline.np = 1;
#line 1822
    cmdline.nc = cmdline.np;
#line 1822
    cmdline.nb = cmdline.nc;
  }
#line 1823
  return;
}
}
#line 1827 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
static void process_args(int argc , char **argv ) 
{ 
  char const   *err_msg ;
  int volatile   i ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp ;

  {
#line 1833
  i = (int volatile   )1;
  {
#line 1833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1833
    if (! (i < (int volatile   )argc)) {
#line 1833
      goto while_break;
    }
#line 1835
    if ((int )*(*(argv + i) + 0) == 0) {
#line 1836
      goto __Cont;
    }
    {
#line 1837
    exception__prev = the_exception_context[0].penv;
#line 1837
    the_exception_context[0].penv = & exception__env;
#line 1837
    tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
    }
#line 1837
    if (tmp == 0) {
#line 1837
      if (& exception__prev) {
        {
#line 1839
        opng_optimize_png((char const   *)*(argv + i));
        }
      }
#line 1841
      the_exception_context[0].caught = 0;
    } else {
#line 1841
      the_exception_context[0].caught = 1;
    }
#line 1841
    the_exception_context[0].penv = exception__prev;
#line 1841
    if (! (! the_exception_context[0].caught)) {
      {
#line 1841
      err_msg = (char const   *)the_exception_context[0].v.etmp;
#line 1843
      opng_printf("!\nError: %s\n\n", err_msg);
#line 1844
      (global.err_count) ++;
      }
    }
    {
#line 1846
    opng_free_image_info();
    }
    __Cont: /* CIL Label */ 
#line 1833
    i += (int volatile   )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1848
  return;
}
}
#line 1852 "/home/khheo/project/ibingo-experiment/optipng-0.5.3/src/optipng.c"
int main(int argc , char **argv ) 
{ 
  char const   *err_msg ;
  int result ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  char const   *tmp___0 ;
  png_charp tmp___1 ;

  {
  {
#line 1858
  memset((void *)(& global), 0, sizeof(global));
#line 1859
  exception__prev = the_exception_context[0].penv;
#line 1859
  the_exception_context[0].penv = & exception__env;
#line 1859
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1859
  if (tmp == 0) {
#line 1859
    if (& exception__prev) {
      {
#line 1861
      parse_args(argc, argv);
      }
    }
#line 1863
    the_exception_context[0].caught = 0;
  } else {
#line 1863
    the_exception_context[0].caught = 1;
  }
#line 1863
  the_exception_context[0].penv = exception__prev;
#line 1863
  if (! (! the_exception_context[0].caught)) {
#line 1863
    err_msg = (char const   *)the_exception_context[0].v.etmp;
#line 1865
    if ((int const   )*(err_msg + 0) < 65) {
      {
#line 1866
      opng_printf("!Invalid option: %s\n", err_msg);
      }
    } else
#line 1865
    if ((int const   )*(err_msg + 0) > 90) {
      {
#line 1866
      opng_printf("!Invalid option: %s\n", err_msg);
      }
    } else {
      {
#line 1868
      opng_printf("!%s\n", err_msg);
      }
    }
#line 1869
    return (1);
  }
  {
#line 1872
  result = 0;
#line 1874
  opng_printf(msg_intro);
  }
#line 1875
  if (cmdline.ver) {
    {
#line 1877
    opng_printf(msg_license);
#line 1878
    tmp___0 = zlibVersion();
#line 1878
    tmp___1 = png_get_libpng_ver((png_structp )((void *)0));
#line 1878
    opng_printf("Compiled with libpng version %s and zlib version %s\n\n", tmp___1,
                tmp___0);
    }
  }
#line 1881
  if (cmdline.help) {
    {
#line 1883
    opng_printf(msg_help);
    }
#line 1884
    if (cmdline.has_files) {
      {
#line 1886
      opng_printf("!Warning: No files processed.\n");
#line 1887
      cmdline.has_files = 0;
#line 1888
      result = 1;
      }
    }
  } else
#line 1891
  if (! cmdline.ver) {
#line 1891
    if (! cmdline.has_files) {
      {
#line 1892
      opng_printf(msg_short_help);
      }
    }
  }
#line 1894
  if (cmdline.has_files) {
    {
#line 1896
    process_args(argc, argv);
    }
#line 1897
    if (global.err_count > 0U) {
      {
#line 1899
      opng_printf("!%u error(s) encountered.\n", global.err_count);
      }
#line 1900
      if (global.fix_count > 0U) {
        {
#line 1901
        opng_printf("!%u error(s) have been fixed.\n", global.fix_count);
        }
      }
#line 1902
      result = 1;
    }
  }
#line 1906
  if ((unsigned long )global.logfile != (unsigned long )((void *)0)) {
    {
#line 1907
    fclose(global.logfile);
    }
  }
#line 1909
  return (result);
}
}
