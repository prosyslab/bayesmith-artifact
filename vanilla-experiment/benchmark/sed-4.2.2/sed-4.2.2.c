/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 64 "./selinux/selinux.h"
typedef unsigned short security_class_t;
#line 34 "./selinux/context.h"
typedef int context_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 32 "/home/khheo/project/benchmark/sed/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_545983685 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_545983685 __mbstate_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 55 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 718 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 54 "/home/khheo/project/benchmark/sed/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 58 "/home/khheo/project/benchmark/sed/lib/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 43 "/home/khheo/project/benchmark/sed/sed/utils.h"
struct buffer ;
#line 41 "/home/khheo/project/benchmark/sed/sed/utils.c"
struct open_file {
   FILE *fp ;
   char *name ;
   struct open_file *link ;
   unsigned int temp : 1 ;
};
#line 498 "/home/khheo/project/benchmark/sed/sed/utils.c"
struct buffer {
   size_t allocated ;
   size_t length ;
   char *b ;
};
#line 41 "/home/khheo/project/benchmark/sed/sed/fmt.c"
typedef long COST;
#line 103
struct Word ;
#line 103 "/home/khheo/project/benchmark/sed/sed/fmt.c"
typedef struct Word WORD;
#line 105 "/home/khheo/project/benchmark/sed/sed/fmt.c"
struct Word {
   char const   *text ;
   short length ;
   short space ;
   unsigned int paren : 1 ;
   unsigned int period : 1 ;
   unsigned int punct : 1 ;
   unsigned int final : 1 ;
   short line_length ;
   COST best_cost ;
   WORD *next_break ;
};
#line 62 "../lib/regex.h"
typedef int __re_idx_t;
#line 63 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 64 "../lib/regex.h"
typedef unsigned long __re_long_size_t;
#line 80 "../lib/regex.h"
typedef unsigned long reg_syntax_t;
#line 424
struct re_dfa_t ;
#line 424 "../lib/regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 489 "../lib/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 500 "../lib/regex.h"
typedef int regoff_t;
#line 507 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 50 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct regex {
   regex_t pattern ;
   int flags ;
   size_t sz ;
   char re[1] ;
};
#line 72
enum text_types {
    TEXT_BUFFER = 0,
    TEXT_REPLACEMENT = 1,
    TEXT_REGEX = 2
} ;
#line 78
enum posixicity_types {
    POSIXLY_EXTENDED = 0,
    POSIXLY_CORRECT = 1,
    POSIXLY_BASIC = 2
} ;
#line 32 "../basicdefs.h"
typedef unsigned long countT;
#line 28 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct sed_cmd ;
#line 28 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct vector {
   struct sed_cmd *v ;
   size_t v_allocated ;
   size_t v_length ;
};
#line 38 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct output {
   char *name ;
   _Bool missing_newline ;
   FILE *fp ;
   struct output *link ;
};
#line 45 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct text_buf {
   char *text ;
   size_t text_length ;
};
#line 57
enum replacement_types {
    REPL_ASIS = 0,
    REPL_UPPERCASE = 1,
    REPL_LOWERCASE = 2,
    REPL_UPPERCASE_FIRST = 4,
    REPL_LOWERCASE_FIRST = 8,
    REPL_MODIFIERS = 12,
    REPL_UPPERCASE_UPPERCASE = 5,
    REPL_UPPERCASE_LOWERCASE = 6,
    REPL_LOWERCASE_UPPERCASE = 9,
    REPL_LOWERCASE_LOWERCASE = 10
} ;
#line 84
enum addr_state {
    RANGE_INACTIVE = 0,
    RANGE_ACTIVE = 1,
    RANGE_CLOSED = 2
} ;
#line 90
enum addr_types {
    ADDR_IS_NULL = 0,
    ADDR_IS_REGEX = 1,
    ADDR_IS_NUM = 2,
    ADDR_IS_NUM_MOD = 3,
    ADDR_IS_STEP = 4,
    ADDR_IS_STEP_MOD = 5,
    ADDR_IS_LAST = 6
} ;
#line 100 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct addr {
   enum addr_types addr_type ;
   countT addr_number ;
   countT addr_step ;
   struct regex *addr_regex ;
};
#line 108 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct replacement {
   char *prefix ;
   size_t prefix_length ;
   int subst_id ;
   enum replacement_types repl_type ;
   struct replacement *next ;
};
#line 116 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct subst {
   struct regex *regx ;
   struct replacement *replacement ;
   countT numb ;
   struct output *outf ;
   unsigned int global : 1 ;
   unsigned int print : 2 ;
   unsigned int eval : 1 ;
   unsigned int max_id : 4 ;
};
#line 140 "/home/khheo/project/benchmark/sed/sed/sed.h"
union __anonunion_x_936425645 {
   struct text_buf cmd_txt ;
   int int_arg ;
   countT jump_index ;
   char *fname ;
   struct subst *cmd_subst ;
   struct output *outf ;
   FILE *fp ;
   unsigned char *translate ;
   char **translatemb ;
};
#line 140 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct sed_cmd {
   struct addr *a1 ;
   struct addr *a2 ;
   enum addr_state range_state ;
   char addr_bang ;
   char cmd ;
   union __anonunion_x_936425645 x ;
};
#line 52 "/home/khheo/project/benchmark/sed/sed/execute.c"
struct line {
   char *text ;
   char *active ;
   size_t length ;
   size_t alloc ;
   _Bool chomped ;
   mbstate_t mbstate ;
};
#line 65 "/home/khheo/project/benchmark/sed/sed/execute.c"
struct append_queue {
   char const   *fname ;
   char *text ;
   size_t textlen ;
   struct append_queue *next ;
   _Bool free ;
};
#line 74 "/home/khheo/project/benchmark/sed/sed/execute.c"
struct input {
   char **file_list ;
   countT bad_count ;
   countT line_number ;
   _Bool reset_at_next_file ;
   _Bool (*read_fn)(struct input * ) ;
   char *out_file_name ;
   char const   *in_file_name ;
   struct stat st ;
   FILE *fp ;
   _Bool no_buffering ;
};
#line 823 "/usr/include/stdio.h"
struct obstack ;
#line 142 "../lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "../lib/obstack.h"
union __anonunion_temp_267926141 {
   long tempint ;
   void *tempptr ;
};
#line 149 "../lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_267926141 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 39 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct prog_info {
   unsigned char const   *base ;
   unsigned char const   *cur ;
   unsigned char const   *end ;
   FILE *file ;
};
#line 56 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct error_info {
   char const   *name ;
   countT line ;
   countT string_expr_count ;
};
#line 69 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct sed_label {
   countT v_index ;
   char *name ;
   struct error_info err_info ;
   struct sed_label *next ;
};
#line 76 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct special_files {
   struct output outf ;
   FILE **pfp ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 25 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 52
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 54
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 56
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 58
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 60
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 62
void *x2realloc(void *p , size_t *pn ) ;
#line 63
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 65
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 97
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 99
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 99 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 102
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 102
    tmp = -1;
  } else {
#line 102
    tmp = -2;
  }
#line 102
  if ((size_t )tmp / s < n) {
    {
#line 103
    xalloc_die();
    }
  }
  {
#line 104
  tmp___0 = xmalloc(n * s);
  }
#line 104
  return (tmp___0);
}
}
#line 110
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 112
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 112 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 115
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 115
    tmp = -1;
  } else {
#line 115
    tmp = -2;
  }
#line 115
  if ((size_t )tmp / s < n) {
    {
#line 116
    xalloc_die();
    }
  }
  {
#line 117
  tmp___0 = xrealloc(p, n * s);
  }
#line 117
  return (tmp___0);
}
}
#line 175 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 178
  n = *pn;
#line 180
  if (! p) {
#line 182
    if (! n) {
#line 190
      n = 128UL / s;
#line 191
      n += (size_t )(! n);
    }
  } else {
#line 200
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 201
      xalloc_die();
      }
    }
#line 202
    n += (n + 1UL) / 2UL;
  }
  {
#line 205
  *pn = n;
#line 206
  tmp = xrealloc(p, n * s);
  }
#line 206
  return (tmp);
}
}
#line 212
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 214
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 214 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 217
  if (sizeof(char ) == 1UL) {
    {
#line 217
    tmp = xmalloc(n);
#line 217
    tmp___1 = tmp;
    }
  } else {
    {
#line 217
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 217
    tmp___1 = tmp___0;
    }
  }
#line 217
  return ((char *)tmp___1);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/sed/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 25 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 42 "/home/khheo/project/benchmark/sed/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/sed/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 31 "/home/khheo/project/benchmark/sed/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/khheo/project/benchmark/sed/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "./wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/sed/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/sed/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2012);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/sed/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/sed/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/sed/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/sed/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-sed@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU sed", "http://www.gnu.org/software/sed/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/sed/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/sed/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 133 "./unistd.h"
#pragma GCC diagnostic push
#line 133
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 133
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1852
#pragma GCC diagnostic pop
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 48 "/home/khheo/project/benchmark/sed/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 133 "./unistd.h"
#pragma GCC diagnostic push
#line 133
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 133
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1852
#pragma GCC diagnostic pop
#line 259 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 179 "/home/khheo/project/benchmark/sed/lib/tempname.c"
static char const   letters[63]  = 
#line 179 "/home/khheo/project/benchmark/sed/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 200 "/home/khheo/project/benchmark/sed/lib/tempname.c"
static uint64_t value  ;
#line 195 "/home/khheo/project/benchmark/sed/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 203
  fd = -1;
#line 204
  tmp = __errno_location();
#line 204
  save_errno = *tmp;
#line 220
  attempts = 238328U;
#line 223
  tmp___0 = strlen((char const   *)tmpl);
#line 223
  len = (int )tmp___0;
  }
#line 224
  if (len < 6 + suffixlen) {
    {
#line 226
    tmp___1 = __errno_location();
#line 226
    *tmp___1 = 22;
    }
#line 227
    return (-1);
  } else {
    {
#line 224
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 224
    if (tmp___2) {
      {
#line 226
      tmp___1 = __errno_location();
#line 226
      *tmp___1 = 22;
      }
#line 227
      return (-1);
    }
  }
  {
#line 231
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 239
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 240
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 243
  tmp___3 = getpid();
#line 243
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 245
  count = 0U;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (count < attempts)) {
#line 245
      goto while_break;
    }
#line 247
    v = value;
#line 250
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 251
    v /= 62UL;
#line 252
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 253
    v /= 62UL;
#line 254
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 255
    v /= 62UL;
#line 256
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 257
    v /= 62UL;
#line 258
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 259
    v /= 62UL;
#line 260
    *(XXXXXX + 5) = (char )letters[v % 62UL];
    {
#line 264
    if (kind == 0) {
#line 264
      goto case_0;
    }
#line 270
    if (kind == 1) {
#line 270
      goto case_1;
    }
#line 274
    if (kind == 2) {
#line 274
      goto case_2;
    }
#line 292
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 265
    fd = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    }
#line 268
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 271
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    }
#line 272
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 279
    tmp___6 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
    }
#line 279
    if (tmp___6 < 0) {
      {
#line 281
      tmp___5 = __errno_location();
      }
#line 281
      if (*tmp___5 == 2) {
        {
#line 283
        tmp___4 = __errno_location();
#line 283
        *tmp___4 = save_errno;
        }
#line 284
        return (0);
      } else {
#line 288
        return (-1);
      }
    }
#line 290
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 293
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/khheo/project/benchmark/sed/lib/tempname.c",
                  293U, "gen_tempname");
#line 294
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 297
    if (fd >= 0) {
      {
#line 299
      tmp___7 = __errno_location();
#line 299
      *tmp___7 = save_errno;
      }
#line 300
      return (fd);
    } else {
      {
#line 302
      tmp___8 = __errno_location();
      }
#line 302
      if (*tmp___8 != 17) {
#line 303
        return (-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 245
    value += 7777UL;
#line 245
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  tmp___9 = __errno_location();
#line 307
  *tmp___9 = 17;
  }
#line 308
  return (-1);
}
}
#line 40 "/home/khheo/project/benchmark/sed/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 42
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/sed/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 52 "/home/khheo/project/benchmark/sed/lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 24 "/home/khheo/project/benchmark/sed/lib/acl.h"
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 25
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 28
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 44 "/home/khheo/project/benchmark/sed/lib/quote.h"
char const   *quote(char const   *arg ) ;
#line 85 "/home/khheo/project/benchmark/sed/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 85
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 85
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 272
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/sed/lib/set-mode-acl.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 41
  if (desc != -1) {
    {
#line 42
    tmp = fchmod(desc, mode);
    }
#line 42
    return (tmp);
  } else {
    {
#line 44
    tmp___0 = chmod(name, mode);
    }
#line 44
    return (tmp___0);
  }
}
}
#line 55 "/home/khheo/project/benchmark/sed/lib/set-mode-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 686
  tmp = chmod_or_fchmod(name, desc, mode);
  }
#line 686
  return (tmp);
}
}
#line 692 "/home/khheo/project/benchmark/sed/lib/set-mode-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 695
  tmp = qset_acl(name, desc, mode);
#line 695
  ret = tmp;
  }
#line 696
  if (ret != 0) {
    {
#line 697
    tmp___0 = quote(name);
#line 697
    tmp___1 = gettext("setting permissions for %s");
#line 697
    tmp___2 = __errno_location();
#line 697
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 698
  return (ret);
}
}
#line 35 "./selinux/selinux.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 35
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 68 "./selinux/selinux.h"
__inline int getcon(char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 70
  tmp = __errno_location();
#line 70
  *tmp = 95;
  }
#line 70
  return (-1);
}
}
#line 71 "./selinux/selinux.h"
__inline void freecon(char *con  __attribute__((__unused__)) ) 
{ 


  {
#line 72
  return;
}
}
#line 77 "./selinux/selinux.h"
__inline int setfscreatecon(char *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 79
  tmp = __errno_location();
#line 79
  *tmp = 95;
  }
#line 79
  return (-1);
}
}
#line 80 "./selinux/selinux.h"
__inline int matchpathcon(char const   *file  __attribute__((__unused__)) , mode_t m  __attribute__((__unused__)) ,
                          char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 84
  tmp = __errno_location();
#line 84
  *tmp = 95;
  }
#line 84
  return (-1);
}
}
#line 85 "./selinux/selinux.h"
__inline int getfilecon(char const   *file  __attribute__((__unused__)) , char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 88
  tmp = __errno_location();
#line 88
  *tmp = 95;
  }
#line 88
  return (-1);
}
}
#line 93 "./selinux/selinux.h"
__inline int fgetfilecon(int fd , char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 95
  tmp = __errno_location();
#line 95
  *tmp = 95;
  }
#line 95
  return (-1);
}
}
#line 96 "./selinux/selinux.h"
__inline int setfilecon(char const   *file  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 99
  tmp = __errno_location();
#line 99
  *tmp = 95;
  }
#line 99
  return (-1);
}
}
#line 104 "./selinux/selinux.h"
__inline int fsetfilecon(int fd  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 107
  tmp = __errno_location();
#line 107
  *tmp = 95;
  }
#line 107
  return (-1);
}
}
#line 118 "./selinux/selinux.h"
__inline int security_compute_create(char *scon  __attribute__((__unused__)) , char *tcon  __attribute__((__unused__)) ,
                                     security_class_t tclass  __attribute__((__unused__)) ,
                                     char **newcon  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 123
  tmp = __errno_location();
#line 123
  *tmp = 95;
  }
#line 123
  return (-1);
}
}
#line 124 "./selinux/selinux.h"
__inline int matchpathcon_init_prefix(char const   *path  __attribute__((__unused__)) ,
                                      char const   *prefix  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 127
  tmp = __errno_location();
#line 127
  *tmp = 95;
  }
#line 127
  return (-1);
}
}
#line 132
#pragma GCC diagnostic push
#line 132
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 132
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 7 "./selinux/context.h"
#pragma GCC diagnostic push
#line 7
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 7
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 35 "./selinux/context.h"
__inline context_t context_new(char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 36
  tmp = __errno_location();
#line 36
  *tmp = 95;
  }
#line 36
  return (0);
}
}
#line 37 "./selinux/context.h"
__inline char *context_str(context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 38
  tmp = __errno_location();
#line 38
  *tmp = 95;
  }
#line 38
  return ((char *)((void *)0));
}
}
#line 39 "./selinux/context.h"
__inline void context_free(context_t c  __attribute__((__unused__)) ) 
{ 


  {
#line 39
  return;
}
}
#line 41 "./selinux/context.h"
__inline int context_user_set(context_t sc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 43
  tmp = __errno_location();
#line 43
  *tmp = 95;
  }
#line 43
  return (-1);
}
}
#line 54
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 236 "/home/khheo/project/benchmark/sed/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg ) ;
#line 324
char *quotearg(char const   *arg ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg ) ;
#line 363
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/sed/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 25 "/home/khheo/project/benchmark/sed/lib/xalloc.h"
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 25
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 44 "/home/khheo/project/benchmark/sed/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 34 "/home/khheo/project/benchmark/sed/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 60 "./wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 75 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 75 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 89 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 89
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 102 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 107 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  e = *tmp;
  }
#line 111
  if (o) {
#line 111
    tmp___0 = o;
  } else {
#line 111
    tmp___0 = & default_quoting_options;
  }
  {
#line 111
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 111
  p = (struct quoting_options *)tmp___1;
#line 113
  tmp___2 = __errno_location();
#line 113
  *tmp___2 = e;
  }
#line 114
  return (p);
}
}
#line 118 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 121
  if (o) {
#line 121
    tmp = o;
  } else {
#line 121
    tmp = & default_quoting_options;
  }
#line 121
  return (tmp->style);
}
}
#line 126 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 129
  if (o) {
#line 129
    tmp = o;
  } else {
#line 129
    tmp = & default_quoting_options;
  }
#line 129
  tmp->style = s;
#line 130
  return;
}
}
#line 137 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  if (o) {
#line 141
    tmp = o;
  } else {
#line 141
    tmp = & default_quoting_options;
  }
#line 141
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 153 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 157
  if (! o) {
#line 158
    o = & default_quoting_options;
  }
#line 159
  r = o->flags;
#line 160
  o->flags = i;
#line 161
  return (r);
}
}
#line 164 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 168
  if (! o) {
#line 169
    o = & default_quoting_options;
  }
#line 170
  o->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
#line 172
    abort();
    }
  } else
#line 171
  if (! right_quote) {
    {
#line 172
    abort();
    }
  }
#line 173
  o->left_quote = left_quote;
#line 174
  o->right_quote = right_quote;
#line 175
  return;
}
}
#line 178 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___0 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote("`", quoting_style);
#line 313
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___0 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___6 = i == argsize;
    }
#line 343
    if (tmp___6) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (i + quote_string_len <= argsize) {
          {
#line 349
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___0 == 0) {
#line 354
            if (elide_outer_quotes) {
#line 355
              goto force_outer_quoting_style;
            }
#line 356
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 359
    c = (unsigned char )*(arg + i);
    {
#line 362
    if ((int )c == 0) {
#line 362
      goto case_0___0;
    }
#line 388
    if ((int )c == 63) {
#line 388
      goto case_63;
    }
#line 426
    if ((int )c == 7) {
#line 426
      goto case_7___0;
    }
#line 427
    if ((int )c == 8) {
#line 427
      goto case_8___0;
    }
#line 428
    if ((int )c == 12) {
#line 428
      goto case_12;
    }
#line 429
    if ((int )c == 10) {
#line 429
      goto case_10;
    }
#line 430
    if ((int )c == 13) {
#line 430
      goto case_13;
    }
#line 431
    if ((int )c == 9) {
#line 431
      goto case_9;
    }
#line 432
    if ((int )c == 11) {
#line 432
      goto case_11;
    }
#line 433
    if ((int )c == 92) {
#line 433
      goto case_92;
    }
#line 452
    if ((int )c == 125) {
#line 452
      goto case_125;
    }
#line 452
    if ((int )c == 123) {
#line 452
      goto case_125;
    }
#line 456
    if ((int )c == 126) {
#line 456
      goto case_126;
    }
#line 456
    if ((int )c == 35) {
#line 456
      goto case_126;
    }
#line 468
    if ((int )c == 124) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 96) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 94) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 91) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 62) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 61) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 60) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 59) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 42) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 41) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 40) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 38) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 36) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 34) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 33) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 32) {
#line 468
      goto case_124;
    }
#line 478
    if ((int )c == 39) {
#line 478
      goto case_39___0;
    }
#line 500
    if ((int )c == 122) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 121) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 120) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 119) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 118) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 117) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 116) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 115) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 114) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 113) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 112) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 111) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 110) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 109) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 108) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 107) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 106) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 105) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 104) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 103) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 102) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 101) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 100) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 99) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 98) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 97) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 95) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 93) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 90) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 89) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 88) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 87) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 86) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 85) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 84) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 83) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 82) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 81) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 80) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 79) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 78) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 77) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 76) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 75) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 74) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 73) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 72) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 71) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 70) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 69) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 68) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 67) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 66) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 65) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 58) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 57) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 56) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 55) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 54) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 53) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 52) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 51) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 50) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 49) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 48) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 47) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 46) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 45) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 44) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 43) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 37) {
#line 500
      goto case_122;
    }
#line 513
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 363
    if (backslash_escapes) {
#line 365
      if (elide_outer_quotes) {
#line 366
        goto force_outer_quoting_style;
      }
      {
#line 367
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer___0 + len) = (char )'\\';
        }
#line 367
        len ++;
#line 367
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 373
      if (i + 1UL < argsize) {
#line 373
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 373
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 375
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 375
              if (len < buffersize) {
#line 375
                *(buffer___0 + len) = (char )'0';
              }
#line 375
              len ++;
#line 375
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 376
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 376
              if (len < buffersize) {
#line 376
                *(buffer___0 + len) = (char )'0';
              }
#line 376
              len ++;
#line 376
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 378
      c = (unsigned char )'0';
    } else
#line 384
    if (flags & 1) {
#line 385
      goto __Cont;
    }
#line 386
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 391
    if ((unsigned int )quoting_style == 2U) {
#line 391
      goto case_2___0;
    }
#line 396
    if ((unsigned int )quoting_style == 3U) {
#line 396
      goto case_3___0;
    }
#line 421
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 392
    if (elide_outer_quotes) {
#line 393
      goto force_outer_quoting_style;
    }
#line 394
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 397
    if (flags & 4) {
#line 397
      if (i + 2UL < argsize) {
#line 397
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 403
            goto case_62;
          }
#line 416
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 406
          if (elide_outer_quotes) {
#line 407
            goto force_outer_quoting_style;
          }
#line 408
          c = (unsigned char )*(arg + (i + 2UL));
#line 409
          i += 2UL;
          {
#line 410
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 410
            if (len < buffersize) {
#line 410
              *(buffer___0 + len) = (char )'?';
            }
#line 410
            len ++;
#line 410
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 411
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 411
            if (len < buffersize) {
#line 411
              *(buffer___0 + len) = (char )'\"';
            }
#line 411
            len ++;
#line 411
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 412
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 412
            if (len < buffersize) {
#line 412
              *(buffer___0 + len) = (char )'\"';
            }
#line 412
            len ++;
#line 412
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 413
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 413
            if (len < buffersize) {
#line 413
              *(buffer___0 + len) = (char )'?';
            }
#line 413
            len ++;
#line 413
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 414
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 417
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 419
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 422
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 424
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 426
    esc = (unsigned char )'a';
#line 426
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 427
    esc = (unsigned char )'b';
#line 427
    goto c_escape;
    case_12: /* CIL Label */ 
#line 428
    esc = (unsigned char )'f';
#line 428
    goto c_escape;
    case_10: /* CIL Label */ 
#line 429
    esc = (unsigned char )'n';
#line 429
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 430
    esc = (unsigned char )'r';
#line 430
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 431
    esc = (unsigned char )'t';
#line 431
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 432
    esc = (unsigned char )'v';
#line 432
    goto c_escape;
    case_92: /* CIL Label */ 
#line 433
    esc = c;
#line 436
    if (backslash_escapes) {
#line 436
      if (elide_outer_quotes) {
#line 436
        if (quote_string_len) {
#line 437
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 440
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 442
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 445
    if (backslash_escapes) {
#line 447
      c = esc;
#line 448
      goto store_escape;
    }
#line 450
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 453
    if (argsize == 0xffffffffffffffffUL) {
#line 453
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 453
      tmp___1 = argsize == 1UL;
    }
#line 453
    if (! tmp___1) {
#line 454
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 457
    if (i != 0UL) {
#line 458
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 473
    if ((unsigned int )quoting_style == 2U) {
#line 473
      if (elide_outer_quotes) {
#line 475
        goto force_outer_quoting_style;
      }
    }
#line 476
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 479
    if ((unsigned int )quoting_style == 2U) {
#line 481
      if (elide_outer_quotes) {
#line 482
        goto force_outer_quoting_style;
      }
      {
#line 483
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 483
        if (len < buffersize) {
#line 483
          *(buffer___0 + len) = (char )'\'';
        }
#line 483
        len ++;
#line 483
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 484
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 484
        if (len < buffersize) {
#line 484
          *(buffer___0 + len) = (char )'\\';
        }
#line 484
        len ++;
#line 484
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 485
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 485
        if (len < buffersize) {
#line 485
          *(buffer___0 + len) = (char )'\'';
        }
#line 485
        len ++;
#line 485
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 487
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 511
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 525
    if (unibyte_locale) {
      {
#line 527
      m = (size_t )1;
#line 528
      tmp___2 = __ctype_b_loc();
#line 528
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 533
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 535
      m = (size_t )0;
#line 536
      printable = (_Bool)1;
      }
#line 537
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 538
        argsize = strlen(arg);
        }
      }
      {
#line 540
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 543
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 543
        bytes = tmp___3;
        }
#line 545
        if (bytes == 0UL) {
#line 546
          goto while_break___14;
        } else
#line 547
        if (bytes == 0xffffffffffffffffUL) {
#line 549
          printable = (_Bool)0;
#line 550
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xfffffffffffffffeUL) {
#line 554
          printable = (_Bool)0;
          {
#line 555
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 555
            if (i + m < argsize) {
#line 555
              if (! *(arg + (i + m))) {
#line 555
                goto while_break___15;
              }
            } else {
#line 555
              goto while_break___15;
            }
#line 556
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 557
          goto while_break___14;
        } else {
#line 565
          if (elide_outer_quotes) {
#line 565
            if ((unsigned int )quoting_style == 2U) {
#line 569
              j = (size_t )1;
              {
#line 569
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 569
                if (! (j < bytes)) {
#line 569
                  goto while_break___16;
                }
                {
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 573
                  goto case_124___0;
                }
#line 576
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 574
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 577
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 569
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 581
          tmp___4 = iswprint((wint_t )w);
          }
#line 581
          if (! tmp___4) {
#line 582
            printable = (_Bool)0;
          }
#line 583
          m += bytes;
        }
        {
#line 540
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 540
        if (tmp___5) {
#line 540
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 589
    if (1UL < m) {
#line 589
      goto _L___0;
    } else
#line 589
    if (backslash_escapes) {
#line 589
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 593
        ilim = i + m;
        {
#line 595
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 597
          if (backslash_escapes) {
#line 597
            if (! printable) {
#line 599
              if (elide_outer_quotes) {
#line 600
                goto force_outer_quoting_style;
              }
              {
#line 601
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 601
                if (len < buffersize) {
#line 601
                  *(buffer___0 + len) = (char )'\\';
                }
#line 601
                len ++;
#line 601
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 602
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 602
                if (len < buffersize) {
#line 602
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 602
                len ++;
#line 602
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 603
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 603
                if (len < buffersize) {
#line 603
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 603
                len ++;
#line 603
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 604
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 597
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 606
          if (is_right_quote) {
            {
#line 608
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 608
              if (len < buffersize) {
#line 608
                *(buffer___0 + len) = (char )'\\';
              }
#line 608
              len ++;
#line 608
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 609
            is_right_quote = (_Bool)0;
          }
#line 611
          if (ilim <= i + 1UL) {
#line 612
            goto while_break___17;
          }
          {
#line 613
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 613
            if (len < buffersize) {
#line 613
              *(buffer___0 + len) = (char )c;
            }
#line 613
            len ++;
#line 613
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 614
          i ++;
#line 614
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 617
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 622
    if (backslash_escapes) {
#line 622
      goto _L___3;
    } else
#line 622
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 622
      if (quote_these_too) {
#line 622
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 622
          goto _L___2;
        }
      } else {
#line 622
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 622
    if (! is_right_quote) {
#line 626
      goto store_c;
    }
    store_escape: 
#line 629
    if (elide_outer_quotes) {
#line 630
      goto force_outer_quoting_style;
    }
    {
#line 631
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 631
      if (len < buffersize) {
#line 631
        *(buffer___0 + len) = (char )'\\';
      }
#line 631
      len ++;
#line 631
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 634
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 634
      if (len < buffersize) {
#line 634
        *(buffer___0 + len) = (char )c;
      }
#line 634
      len ++;
#line 634
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 637
  if (len == 0UL) {
#line 637
    if ((unsigned int )quoting_style == 2U) {
#line 637
      if (elide_outer_quotes) {
#line 639
        goto force_outer_quoting_style;
      }
    }
  }
#line 641
  if (quote_string) {
#line 641
    if (! elide_outer_quotes) {
      {
#line 642
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 642
        if (! *quote_string) {
#line 642
          goto while_break___25;
        }
        {
#line 643
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 643
          if (len < buffersize) {
#line 643
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 643
          len ++;
#line 643
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 642
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 645
  if (len < buffersize) {
#line 646
    *(buffer___0 + len) = (char )'\000';
  }
#line 647
  return (len);
  force_outer_quoting_style: 
  {
#line 652
  tmp___7 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 652
  return (tmp___7);
}
}
#line 667 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 672
  if (o) {
#line 672
    tmp = o;
  } else {
#line 672
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 672
  p = tmp;
#line 673
  tmp___0 = __errno_location();
#line 673
  e = *tmp___0;
#line 674
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 674
  r = tmp___1;
#line 677
  tmp___2 = __errno_location();
#line 677
  *tmp___2 = e;
  }
#line 678
  return (r);
}
}
#line 682 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 686
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 686
  return (tmp);
}
}
#line 695 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 699
  if (o) {
#line 699
    tmp = o;
  } else {
#line 699
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 699
  p = tmp;
#line 700
  tmp___0 = __errno_location();
#line 700
  e = *tmp___0;
  }
#line 702
  if (size) {
#line 702
    tmp___1 = 0;
  } else {
#line 702
    tmp___1 = 1;
  }
  {
#line 702
  flags = (int )(p->flags | (int const   )tmp___1);
#line 703
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 703
  bufsize = tmp___2 + 1UL;
#line 707
  tmp___3 = xcharalloc(bufsize);
#line 707
  buf = tmp___3;
#line 708
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 711
  tmp___4 = __errno_location();
#line 711
  *tmp___4 = e;
  }
#line 712
  if (size) {
#line 713
    *size = bufsize - 1UL;
  }
#line 714
  return (buf);
}
}
#line 726 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static char slot0[256]  ;
#line 727 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 728 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 729 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 731 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 734
  sv = slotvec;
#line 736
  i = 1U;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < nslots)) {
#line 736
      goto while_break;
    }
    {
#line 737
    free((void *)(sv + i)->val);
#line 736
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 740
    free((void *)(sv + 0)->val);
#line 741
    slotvec0.size = sizeof(slot0);
#line 742
    slotvec0.val = slot0;
    }
  }
#line 744
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 746
    free((void *)sv);
#line 747
    slotvec = & slotvec0;
    }
  }
#line 749
  nslots = 1U;
#line 750
  return;
}
}
#line 760 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 764
  tmp = __errno_location();
#line 764
  e = *tmp;
#line 766
  n0 = (unsigned int )n;
#line 767
  sv = slotvec;
  }
#line 769
  if (n < 0) {
    {
#line 770
    abort();
    }
  }
#line 772
  if (nslots <= n0) {
#line 779
    n1 = (size_t )(n0 + 1U);
#line 780
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 782
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 782
      tmp___0 = -1;
    } else {
#line 782
      tmp___0 = -2;
    }
#line 782
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 783
      xalloc_die();
      }
    }
#line 785
    if (preallocated) {
#line 785
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 785
      tmp___1 = sv;
    }
    {
#line 785
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 785
    sv = (struct slotvec *)tmp___2;
#line 785
    slotvec = sv;
    }
#line 786
    if (preallocated) {
#line 787
      *sv = slotvec0;
    }
    {
#line 788
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 789
    nslots = (unsigned int )n1;
    }
  }
  {
#line 793
  size = (sv + n)->size;
#line 794
  val = (sv + n)->val;
#line 796
  flags = (int )(options->flags | 1);
#line 797
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 797
  qsize = tmp___3;
  }
#line 803
  if (size <= qsize) {
#line 805
    size = qsize + 1UL;
#line 805
    (sv + n)->size = size;
#line 806
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 807
      free((void *)val);
      }
    }
    {
#line 808
    val = xcharalloc(size);
#line 808
    (sv + n)->val = val;
#line 809
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 815
  tmp___4 = __errno_location();
#line 815
  *tmp___4 = e;
  }
#line 816
  return (val);
}
}
#line 820 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 823
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 823
  return (tmp);
}
}
#line 826 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 829
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 829
  return (tmp);
}
}
#line 832 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 835
  tmp = quotearg_n(0, arg);
  }
#line 835
  return (tmp);
}
}
#line 838 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 841
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 841
  return (tmp);
}
}
#line 844 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 847
  tmp = quoting_options_from_style(s);
#line 847
  o = tmp;
#line 848
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 848
  return (tmp___0);
}
}
#line 851 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 855
  tmp = quoting_options_from_style(s);
#line 855
  o = tmp;
#line 856
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 856
  return (tmp___0);
}
}
#line 859 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 862
  tmp = quotearg_n_style(0, s, arg);
  }
#line 862
  return (tmp);
}
}
#line 865 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 868
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 868
  return (tmp);
}
}
#line 871 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 875
  options = default_quoting_options;
#line 876
  set_char_quoting(& options, ch, 1);
#line 877
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 877
  return (tmp);
}
}
#line 880 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 883
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 883
  return (tmp);
}
}
#line 886 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 889
  tmp = quotearg_char(arg, (char )':');
  }
#line 889
  return (tmp);
}
}
#line 892 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 895
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 895
  return (tmp);
}
}
#line 898 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 902
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 902
  return (tmp);
}
}
#line 906 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 911
  o = default_quoting_options;
#line 912
  set_custom_quoting(& o, left_quote, right_quote);
#line 913
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 913
  return (tmp);
}
}
#line 916 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 920
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 920
  return (tmp);
}
}
#line 923 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 927
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 927
  return (tmp);
}
}
#line 933 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 941 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 944
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 944
  return ((char const   *)tmp);
}
}
#line 947 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 950
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 950
  return (tmp);
}
}
#line 953 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 956
  tmp = quote_n_mem(n, arg, (size_t )-1);
  }
#line 956
  return (tmp);
}
}
#line 959 "/home/khheo/project/benchmark/sed/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 962
  tmp = quote_n(0, arg);
  }
#line 962
  return (tmp);
}
}
#line 65 "/home/khheo/project/benchmark/sed/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 69
void freea(void *p ) ;
#line 65 "/home/khheo/project/benchmark/sed/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 69 "/home/khheo/project/benchmark/sed/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 75
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 77
  if (nplus >= n) {
    {
#line 79
    tmp = malloc(nplus);
#line 79
    p = (char *)tmp;
    }
#line 81
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 85
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 88
      *((int *)p + -1) = 336984906;
#line 91
      slot = (uintptr_t )p % 257UL;
#line 92
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 93
      mmalloca_results[slot] = (void *)p;
#line 95
      return ((void *)p);
    }
  }
#line 99
  return ((void *)0);
}
}
#line 110 "/home/khheo/project/benchmark/sed/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 114
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 120
    if (*((int *)p + -1) == 336984906) {
#line 124
      slot = (uintptr_t )p % 257UL;
#line 125
      chain = & mmalloca_results[slot];
      {
#line 126
      while (1) {
        while_continue: /* CIL Label */ ;
#line 126
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 126
          goto while_break;
        }
#line 128
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 131
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 132
          *chain = ((struct header *)p_begin)->next;
#line 133
          free((void *)p_begin);
          }
#line 134
          return;
        }
#line 136
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 141
  return;
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 52 "./stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 133 "./unistd.h"
#pragma GCC diagnostic push
#line 133
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 133
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1852
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 116 "/home/khheo/project/benchmark/sed/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 119 "/home/khheo/project/benchmark/sed/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1___0[51] ;
  char buf2___0[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 124
  cp = (char const   *)charset_aliases;
#line 125
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 129
    base = "charset.alias";
#line 134
    tmp = getenv("CHARSETALIASDIR");
#line 134
    dir = (char const   *)tmp;
    }
#line 135
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 136
      dir = "/usr/local/lib";
    } else
#line 135
    if ((int const   )*(dir + 0) == 0) {
#line 136
      dir = "/usr/local/lib";
    }
    {
#line 140
    tmp___0 = strlen(dir);
#line 140
    dir_len___0 = tmp___0;
#line 141
    tmp___1 = strlen(base);
#line 141
    base_len___0 = tmp___1;
    }
#line 142
    if (dir_len___0 > 0UL) {
#line 142
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 142
        tmp___2 = 1;
      } else {
#line 142
        tmp___2 = 0;
      }
    } else {
#line 142
      tmp___2 = 0;
    }
    {
#line 142
    add_slash = tmp___2;
#line 143
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 143
    file_name = (char *)tmp___3;
    }
#line 144
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 146
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 147
      if (add_slash) {
#line 148
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 149
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base,
             base_len___0 + 1UL);
      }
    }
#line 153
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 155
      cp = "";
    } else {
      {
#line 167
      fd = open((char const   *)file_name, 131072);
      }
#line 169
      if (fd < 0) {
#line 171
        cp = "";
      } else {
        {
#line 176
        fp = fdopen(fd, "r");
        }
#line 177
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 180
          close(fd);
#line 181
          cp = "";
          }
        } else {
#line 186
          res_ptr = (char *)((void *)0);
#line 187
          res_size = (size_t )0;
          {
#line 189
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 197
            c = getc_unlocked(fp);
            }
#line 198
            if (c == -1) {
#line 199
              goto while_break;
            }
#line 200
            if (c == 10) {
#line 201
              goto __Cont;
            } else
#line 200
            if (c == 32) {
#line 201
              goto __Cont;
            } else
#line 200
            if (c == 9) {
#line 201
              goto __Cont;
            }
#line 202
            if (c == 35) {
              {
#line 205
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 206
                c = getc_unlocked(fp);
                }
#line 205
                if (c == -1) {
#line 205
                  goto while_break___0;
                } else
#line 205
                if (c == 10) {
#line 205
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 208
              if (c == -1) {
#line 209
                goto while_break;
              }
#line 210
              goto __Cont;
            }
            {
#line 212
            ungetc(c, fp);
#line 213
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1___0, buf2___0);
            }
#line 213
            if (tmp___4 < 2) {
#line 214
              goto while_break;
            }
            {
#line 215
            l1 = strlen((char const   *)(buf1___0));
#line 216
            l2 = strlen((char const   *)(buf2___0));
#line 217
            old_res_ptr = res_ptr;
            }
#line 218
            if (res_size == 0UL) {
              {
#line 220
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 221
              tmp___5 = malloc(res_size + 1UL);
#line 221
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 225
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 226
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 226
              res_ptr = (char *)tmp___6;
              }
            }
#line 228
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 231
              res_size = (size_t )0;
#line 232
              free((void *)old_res_ptr);
              }
#line 233
              goto while_break;
            }
            {
#line 235
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1___0));
#line 236
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2___0));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 238
          fclose(fp);
          }
#line 239
          if (res_size == 0UL) {
#line 240
            cp = "";
          } else {
#line 243
            *(res_ptr + res_size) = (char )'\000';
#line 244
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 249
      free((void *)file_name);
      }
    }
#line 343
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 346
  return (cp);
}
}
#line 358 "/home/khheo/project/benchmark/sed/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 369
  tmp = nl_langinfo(14);
#line 369
  codeset = (char const   *)tmp;
  }
#line 526
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 528
    codeset = "";
  }
  {
#line 531
  aliases = get_charset_aliases();
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! ((int const   )*aliases != 0)) {
#line 531
      goto while_break;
    }
    {
#line 534
    tmp___3 = strcmp(codeset, aliases);
    }
#line 534
    if (tmp___3 == 0) {
      {
#line 537
      tmp___2 = strlen(aliases);
#line 537
      codeset = (aliases + tmp___2) + 1;
      }
#line 538
      goto while_break;
    } else
#line 534
    if ((int const   )*(aliases + 0) == 42) {
#line 534
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 537
        tmp___2 = strlen(aliases);
#line 537
        codeset = (aliases + tmp___2) + 1;
        }
#line 538
        goto while_break;
      }
    }
    {
#line 531
    tmp___0 = strlen(aliases);
#line 531
    aliases += tmp___0 + 1UL;
#line 531
    tmp___1 = strlen(aliases);
#line 531
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  if ((int const   )*(codeset + 0) == 0) {
#line 545
    codeset = "ASCII";
  }
#line 554
  return (codeset);
}
}
#line 23 "/home/khheo/project/benchmark/sed/lib/file-has-acl.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 23 "/home/khheo/project/benchmark/sed/lib/acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 85 "/home/khheo/project/benchmark/sed/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 85
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 85
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 272
#pragma GCC diagnostic pop
#line 483 "/home/khheo/project/benchmark/sed/lib/file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 


  {
#line 917
  return (0);
}
}
#line 24 "/home/khheo/project/benchmark/sed/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 39 "/home/khheo/project/benchmark/sed/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 41
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/sed/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 49 "/home/khheo/project/benchmark/sed/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 137 "/home/khheo/project/benchmark/sed/lib/c-ctype.h"
int c_tolower(int c )  __attribute__((__const__)) ;
#line 28 "/home/khheo/project/benchmark/sed/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/sed/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 31
  p1 = (unsigned char const   *)s1;
#line 32
  p2 = (unsigned char const   *)s2;
#line 35
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 36
    return (0);
  } else
#line 35
  if (n == 0UL) {
#line 36
    return (0);
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    tmp = c_tolower((int )*p1);
#line 40
    c1 = (unsigned char )tmp;
#line 41
    tmp___0 = c_tolower((int )*p2);
#line 41
    c2 = (unsigned char )tmp___0;
#line 43
    n --;
    }
#line 43
    if (n == 0UL) {
#line 44
      goto while_break;
    } else
#line 43
    if ((int )c1 == 0) {
#line 44
      goto while_break;
    }
#line 46
    p1 ++;
#line 47
    p2 ++;
#line 38
    if (! ((int )c1 == (int )c2)) {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return ((int )c1 - (int )c2);
}
}
#line 28 "/home/khheo/project/benchmark/sed/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 28 "/home/khheo/project/benchmark/sed/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 31
  p1 = (unsigned char const   *)s1;
#line 32
  p2 = (unsigned char const   *)s2;
#line 35
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 36
    return (0);
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    tmp = c_tolower((int )*p1);
#line 40
    c1 = (unsigned char )tmp;
#line 41
    tmp___0 = c_tolower((int )*p2);
#line 41
    c2 = (unsigned char )tmp___0;
    }
#line 43
    if ((int )c1 == 0) {
#line 44
      goto while_break;
    }
#line 46
    p1 ++;
#line 47
    p2 ++;
#line 38
    if (! ((int )c1 == (int )c2)) {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return ((int )c1 - (int )c2);
}
}
#line 26 "/home/khheo/project/benchmark/sed/lib/acl.h"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) ;
#line 27
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 85 "/home/khheo/project/benchmark/sed/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 85
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 85
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 272
#pragma GCC diagnostic pop
#line 41 "/home/khheo/project/benchmark/sed/lib/copy-acl.c"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 583
  tmp = qset_acl(dst_name, dest_desc, mode);
  }
#line 583
  return (tmp);
}
}
#line 599 "/home/khheo/project/benchmark/sed/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 603
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 603
  ret = tmp;
  }
  {
#line 606
  if (ret == -2) {
#line 606
    goto case_neg_2;
  }
#line 610
  if (ret == -1) {
#line 610
    goto case_neg_1;
  }
#line 614
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 607
  tmp___0 = quote(src_name);
#line 607
  tmp___1 = __errno_location();
#line 607
  error(0, *tmp___1, "%s", tmp___0);
  }
#line 608
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 611
  tmp___2 = quote(dst_name);
#line 611
  tmp___3 = gettext("preserving permissions for %s");
#line 611
  tmp___4 = __errno_location();
#line 611
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  }
#line 612
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 615
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 617
  return (ret);
}
}
#line 122 "/home/khheo/project/benchmark/sed/lib/c-ctype.h"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 124
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 125
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 126
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 127
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 128
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 129
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 130
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 131
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 132
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 133
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 134
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 135
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 138
int c_toupper(int c )  __attribute__((__const__)) ;
#line 28 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 28 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 31
  if (c >= 0) {
#line 31
    if (c <= 127) {
#line 31
      tmp = 1;
    } else {
#line 31
      tmp = 0;
    }
  } else {
#line 31
    tmp = 0;
  }
#line 31
  return ((_Bool )tmp);
}
}
#line 34
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 34 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 40
  if (c >= 48) {
#line 40
    if (c <= 57) {
#line 40
      tmp = 1;
    } else {
#line 40
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 40
  if ((c & -33) >= 65) {
#line 40
    if ((c & -33) <= 90) {
#line 40
      tmp = 1;
    } else {
#line 40
      tmp = 0;
    }
  } else {
#line 40
    tmp = 0;
  }
#line 40
  return ((_Bool )tmp);
}
}
#line 69
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 69 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 74
  if ((c & -33) >= 65) {
#line 74
    if ((c & -33) <= 90) {
#line 74
      tmp = 1;
    } else {
#line 74
      tmp = 0;
    }
  } else {
#line 74
    tmp = 0;
  }
#line 74
  return ((_Bool )tmp);
}
}
#line 98
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 98 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 101
  if (c == 32) {
#line 101
    tmp = 1;
  } else
#line 101
  if (c == 9) {
#line 101
    tmp = 1;
  } else {
#line 101
    tmp = 0;
  }
#line 101
  return ((_Bool )tmp);
}
}
#line 104
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 104 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 108
  if ((c & -32) == 0) {
#line 108
    tmp = 1;
  } else
#line 108
  if (c == 127) {
#line 108
    tmp = 1;
  } else {
#line 108
    tmp = 0;
  }
#line 108
  return ((_Bool )tmp);
}
}
#line 138
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 138 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 142
  if (c >= 48) {
#line 142
    if (c <= 57) {
#line 142
      tmp = 1;
    } else {
#line 142
      tmp = 0;
    }
  } else {
#line 142
    tmp = 0;
  }
#line 142
  return ((_Bool )tmp);
}
}
#line 155
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 155 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 159
  if (c >= 97) {
#line 159
    if (c <= 122) {
#line 159
      tmp = 1;
    } else {
#line 159
      tmp = 0;
    }
  } else {
#line 159
    tmp = 0;
  }
#line 159
  return ((_Bool )tmp);
}
}
#line 175
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 175 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 179
  if (c >= 33) {
#line 179
    if (c <= 126) {
#line 179
      tmp = 1;
    } else {
#line 179
      tmp = 0;
    }
  } else {
#line 179
    tmp = 0;
  }
#line 179
  return ((_Bool )tmp);
}
}
#line 209
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 209 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 213
  if (c >= 32) {
#line 213
    if (c <= 126) {
#line 213
      tmp = 1;
    } else {
#line 213
      tmp = 0;
    }
  } else {
#line 213
    tmp = 0;
  }
#line 213
  return ((_Bool )tmp);
}
}
#line 243
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 243 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 247
  if (c >= 33) {
#line 247
    if (c <= 126) {
#line 247
      if (c >= 48) {
#line 247
        if (c <= 57) {
#line 247
          tmp = 0;
        } else {
#line 247
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 247
      if ((c & -33) >= 65) {
#line 247
        if ((c & -33) <= 90) {
#line 247
          tmp = 0;
        } else {
#line 247
          tmp = 1;
        }
      } else {
#line 247
        tmp = 1;
      }
    } else {
#line 247
      tmp = 0;
    }
  } else {
#line 247
    tmp = 0;
  }
#line 247
  return ((_Bool )tmp);
}
}
#line 267
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 267 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 270
  if (c == 32) {
#line 270
    tmp = 1;
  } else
#line 270
  if (c == 9) {
#line 270
    tmp = 1;
  } else
#line 270
  if (c == 10) {
#line 270
    tmp = 1;
  } else
#line 270
  if (c == 11) {
#line 270
    tmp = 1;
  } else
#line 270
  if (c == 12) {
#line 270
    tmp = 1;
  } else
#line 270
  if (c == 13) {
#line 270
    tmp = 1;
  } else {
#line 270
    tmp = 0;
  }
#line 270
  return ((_Bool )tmp);
}
}
#line 274
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 274 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 278
  if (c >= 65) {
#line 278
    if (c <= 90) {
#line 278
      tmp = 1;
    } else {
#line 278
      tmp = 0;
    }
  } else {
#line 278
    tmp = 0;
  }
#line 278
  return ((_Bool )tmp);
}
}
#line 294
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 294 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 300
  if (c >= 48) {
#line 300
    if (c <= 57) {
#line 300
      tmp = 1;
    } else {
#line 300
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 300
  if ((c & -33) >= 65) {
#line 300
    if ((c & -33) <= 70) {
#line 300
      tmp = 1;
    } else {
#line 300
      tmp = 0;
    }
  } else {
#line 300
    tmp = 0;
  }
#line 300
  return ((_Bool )tmp);
}
}
#line 321
int c_tolower(int c )  __attribute__((__const__)) ;
#line 321 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 325
  if (c >= 65) {
#line 325
    if (c <= 90) {
#line 325
      tmp = (c - 65) + 97;
    } else {
#line 325
      tmp = c;
    }
  } else {
#line 325
    tmp = c;
  }
#line 325
  return (tmp);
}
}
#line 360
int c_toupper(int c )  __attribute__((__const__)) ;
#line 360 "/home/khheo/project/benchmark/sed/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 364
  if (c >= 97) {
#line 364
    if (c <= 122) {
#line 364
      tmp = (c - 97) + 65;
    } else {
#line 364
      tmp = c;
    }
  } else {
#line 364
    tmp = c;
  }
#line 364
  return (tmp);
}
}
#line 29 "/home/khheo/project/benchmark/sed/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/sed/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/sed/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 137
extern struct _IO_FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 606
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 757
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 739
extern int ( __attribute__((__nonnull__(1))) mkostemp)(char *__template , int __flags ) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 811 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 133 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 133
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 133
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1852
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 23 "/home/khheo/project/benchmark/sed/sed/utils.h"
void panic(char const   *str  , ...) ;
#line 25
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) ;
#line 26
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) ;
#line 27
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 28
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 29
void ck_fflush(FILE *stream ) ;
#line 30
void ck_fclose(FILE *stream ) ;
#line 31
char const   *follow_symlink(char const   *fname ) ;
#line 32
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) ;
#line 33
FILE *ck_mkstemp(char **p_filename , char const   *tmpdir , char const   *base , char const   *mode ) ;
#line 35
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) ;
#line 37
void *ck_malloc(size_t size ) ;
#line 39
void *ck_realloc(void *ptr , size_t size ) ;
#line 40
char *ck_strdup(char const   *str ) ;
#line 41
void *ck_memdup(void const   *buf , size_t len ) ;
#line 43
struct buffer *init_buffer(void) ;
#line 44
char *get_buffer(struct buffer *b___0 ) ;
#line 45
size_t size_buffer(struct buffer *b___0 ) ;
#line 46
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) ;
#line 47
char *add1_buffer(struct buffer *b___0 , int c ) ;
#line 48
void free_buffer(struct buffer *b___0 ) ;
#line 50 "/home/khheo/project/benchmark/sed/sed/utils.h"
char const   *myname  ;
#line 56 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fwriting)(FILE *__fp ) ;
#line 49 "/home/khheo/project/benchmark/sed/sed/utils.c"
static struct open_file *open_files  =    (struct open_file *)((void *)0);
#line 50
static void do_ck_fclose(FILE *fp ) ;
#line 54 "/home/khheo/project/benchmark/sed/sed/utils.c"
void panic(char const   *str  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
#line 60
  __builtin_va_start(ap, str);
#line 61
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str,
           ap);
#line 62
  __builtin_va_end(ap);
#line 63
  _IO_putc('\n', stderr);
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! open_files) {
#line 66
      goto while_break;
    }
#line 68
    if (open_files->temp) {
      {
#line 70
      fclose(open_files->fp);
#line 71
      tmp = __errno_location();
#line 71
      *tmp = 0;
#line 72
      unlink((char const   *)open_files->name);
#line 73
      tmp___3 = __errno_location();
      }
#line 73
      if (*tmp___3 != 0) {
        {
#line 74
        tmp___0 = __errno_location();
#line 74
        tmp___1 = strerror(*tmp___0);
#line 74
        tmp___2 = gettext("cannot remove %s: %s");
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                open_files->name, tmp___1);
        }
      }
    }
#line 77
    open_files = open_files->link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  exit(4);
  }
}
}
#line 85
static char const   *utils_fp_name(FILE *fp ) ;
#line 86 "/home/khheo/project/benchmark/sed/sed/utils.c"
static char const   *utils_fp_name(FILE *fp ) 
{ 
  struct open_file *p ;

  {
#line 92
  p = open_files;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! p) {
#line 92
      goto while_break;
    }
#line 93
    if ((unsigned long )p->fp == (unsigned long )fp) {
#line 94
      return ((char const   *)p->name);
    }
#line 92
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if ((unsigned long )fp == (unsigned long )stdin) {
#line 96
    return ("stdin");
  } else
#line 97
  if ((unsigned long )fp == (unsigned long )stdout) {
#line 98
    return ("stdout");
  } else
#line 99
  if ((unsigned long )fp == (unsigned long )stderr) {
#line 100
    return ("stderr");
  }
#line 102
  return ("<unknown>");
}
}
#line 105 "/home/khheo/project/benchmark/sed/sed/utils.c"
static void register_open_file(FILE *fp , char const   *name , int temp ) 
{ 
  struct open_file *p ;
  void *tmp ;

  {
#line 112
  p = open_files;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! p) {
#line 112
      goto while_break;
    }
#line 114
    if ((unsigned long )fp == (unsigned long )p->fp) {
      {
#line 116
      free((void *)p->name);
      }
#line 117
      goto while_break;
    }
#line 112
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (! p) {
    {
#line 122
    tmp = ck_malloc(sizeof(struct open_file ));
#line 122
    p = (struct open_file *)tmp;
#line 123
    p->link = open_files;
#line 124
    open_files = p;
    }
  }
  {
#line 126
  p->name = ck_strdup(name);
#line 127
  p->fp = fp;
#line 128
  p->temp = 0U;
  }
#line 129
  return;
}
}
#line 132 "/home/khheo/project/benchmark/sed/sed/utils.c"
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 140
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 141
  if (! fp) {
#line 143
    if (fail) {
      {
#line 144
      tmp = __errno_location();
#line 144
      tmp___0 = strerror(*tmp);
#line 144
      tmp___1 = gettext("couldn\'t open file %s: %s");
#line 144
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 146
    return ((FILE *)((void *)0));
  }
  {
#line 149
  register_open_file(fp, name, 0);
  }
#line 150
  return (fp);
}
}
#line 154 "/home/khheo/project/benchmark/sed/sed/utils.c"
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 163
  fp = fdopen(fd, mode);
  }
#line 164
  if (! fp) {
#line 166
    if (fail) {
      {
#line 167
      tmp = __errno_location();
#line 167
      tmp___0 = strerror(*tmp);
#line 167
      tmp___1 = gettext("couldn\'t attach to %s: %s");
#line 167
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 169
    return ((FILE *)((void *)0));
  }
  {
#line 172
  register_open_file(fp, name, 0);
  }
#line 173
  return (fp);
}
}
#line 176 "/home/khheo/project/benchmark/sed/sed/utils.c"
FILE *ck_mkstemp(char **p_filename , char const   *tmpdir , char const   *base , char const   *mode ) 
{ 
  char *template ;
  FILE *fp ;
  int fd ;
  int save_umask ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  __mode_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 187
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
#line 188
    tmp = getenv("TMPDIR");
#line 188
    tmpdir = (char const   *)tmp;
    }
  }
#line 189
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
    {
#line 191
    tmp___0 = getenv("TMP");
#line 191
    tmpdir = (char const   *)tmp___0;
    }
#line 192
    if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
#line 194
      tmpdir = "/tmp";
    }
  }
  {
#line 200
  tmp___1 = strlen(tmpdir);
#line 200
  tmp___2 = strlen(base);
#line 200
  tmp___3 = xmalloc((tmp___1 + tmp___2) + 8UL);
#line 200
  template = (char *)tmp___3;
#line 201
  sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/%sXXXXXX",
          tmpdir, base);
#line 207
  tmp___4 = umask((__mode_t )448);
#line 207
  save_umask = (int )tmp___4;
#line 208
  fd = mkostemp(template, 0);
#line 209
  umask((__mode_t )save_umask);
  }
#line 210
  if (fd == -1) {
    {
#line 211
    tmp___5 = __errno_location();
#line 211
    tmp___6 = strerror(*tmp___5);
#line 211
    tmp___7 = gettext("couldn\'t open temporary file %s: %s");
#line 211
    panic((char const   *)tmp___7, template, tmp___6);
    }
  }
  {
#line 213
  *p_filename = template;
#line 214
  fp = fdopen(fd, mode);
#line 215
  register_open_file(fp, (char const   *)template, 1);
  }
#line 216
  return (fp);
}
}
#line 220 "/home/khheo/project/benchmark/sed/sed/utils.c"
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 227
  clearerr(stream);
  }
#line 228
  if (size) {
    {
#line 228
    tmp___3 = fwrite((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 228
    if (tmp___3 != nmemb) {
      {
#line 229
      tmp = __errno_location();
#line 229
      tmp___0 = strerror(*tmp);
#line 229
      tmp___1 = utils_fp_name(stream);
#line 229
      tmp___2 = ngettext("couldn\'t write %d item to %s: %s", "couldn\'t write %d items to %s: %s",
                         nmemb);
#line 229
      panic((char const   *)tmp___2, nmemb, tmp___1, tmp___0);
      }
    }
  }
#line 232
  return;
}
}
#line 235 "/home/khheo/project/benchmark/sed/sed/utils.c"
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 242
  clearerr(stream);
  }
#line 243
  if (size) {
    {
#line 243
    nmemb = fread((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 243
    if (nmemb <= 0UL) {
      {
#line 243
      tmp___3 = ferror(stream);
      }
#line 243
      if (tmp___3) {
        {
#line 244
        tmp = __errno_location();
#line 244
        tmp___0 = strerror(*tmp);
#line 244
        tmp___1 = utils_fp_name(stream);
#line 244
        tmp___2 = gettext("read error on %s: %s");
#line 244
        panic((char const   *)tmp___2, tmp___1, tmp___0);
        }
      }
    }
  }
#line 246
  return (nmemb);
}
}
#line 249 "/home/khheo/project/benchmark/sed/sed/utils.c"
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) 
{ 
  ssize_t result ;
  _Bool error___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 259
  tmp = ferror(stream);
#line 259
  error___0 = (_Bool )tmp;
  }
#line 260
  if (! error___0) {
    {
#line 262
    result = getdelim((char **/* __restrict  */)text, (size_t */* __restrict  */)buflen,
                      (int )buffer_delimiter___0, (FILE */* __restrict  */)stream);
#line 263
    tmp___0 = ferror(stream);
#line 263
    error___0 = (_Bool )tmp___0;
    }
  }
#line 266
  if (error___0) {
    {
#line 267
    tmp___1 = __errno_location();
#line 267
    tmp___2 = strerror(*tmp___1);
#line 267
    tmp___3 = utils_fp_name(stream);
#line 267
    tmp___4 = gettext("read error on %s: %s");
#line 267
    panic((char const   *)tmp___4, tmp___3, tmp___2);
    }
  }
#line 269
  return ((size_t )result);
}
}
#line 273 "/home/khheo/project/benchmark/sed/sed/utils.c"
void ck_fflush(FILE *stream ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 277
  tmp = __fwriting(stream);
  }
#line 277
  if (! (tmp != 0)) {
#line 278
    return;
  }
  {
#line 280
  clearerr(stream);
#line 281
  tmp___3 = fflush(stream);
  }
#line 281
  if (tmp___3 == -1) {
    {
#line 281
    tmp___4 = __errno_location();
    }
#line 281
    if (*tmp___4 != 9) {
      {
#line 282
      tmp___0 = __errno_location();
#line 282
      tmp___1 = strerror(*tmp___0);
#line 282
      tmp___2 = utils_fp_name(stream);
#line 282
      panic("couldn\'t flush %s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 283
  return;
}
}
#line 286 "/home/khheo/project/benchmark/sed/sed/utils.c"
void ck_fclose(FILE *stream ) 
{ 
  struct open_file r ;
  struct open_file *prev ;
  struct open_file *cur ;

  {
#line 295
  r.link = open_files;
#line 296
  prev = & r;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    cur = prev->link;
#line 297
    if (! cur) {
#line 297
      goto while_break;
    }
#line 299
    if (! stream) {
      {
#line 301
      do_ck_fclose(cur->fp);
#line 302
      prev->link = cur->link;
#line 303
      free((void *)cur->name);
#line 304
      free((void *)cur);
      }
    } else
#line 299
    if ((unsigned long )stream == (unsigned long )cur->fp) {
      {
#line 301
      do_ck_fclose(cur->fp);
#line 302
      prev->link = cur->link;
#line 303
      free((void *)cur->name);
#line 304
      free((void *)cur);
      }
    } else {
#line 307
      prev = cur;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  open_files = r.link;
#line 315
  if (! stream) {
    {
#line 317
    do_ck_fclose(stdout);
#line 318
    do_ck_fclose(stderr);
    }
  }
#line 320
  return;
}
}
#line 323 "/home/khheo/project/benchmark/sed/sed/utils.c"
static void do_ck_fclose(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 327
  ck_fflush(fp);
#line 328
  clearerr(fp);
#line 330
  tmp___2 = fclose(fp);
  }
#line 330
  if (tmp___2 == -1) {
    {
#line 331
    tmp = __errno_location();
#line 331
    tmp___0 = strerror(*tmp);
#line 331
    tmp___1 = utils_fp_name(fp);
#line 331
    panic("couldn\'t close %s: %s", tmp___1, tmp___0);
    }
  }
#line 332
  return;
}
}
#line 342 "/home/khheo/project/benchmark/sed/sed/utils.c"
static char *buf1  ;
#line 342 "/home/khheo/project/benchmark/sed/sed/utils.c"
static char *buf2  ;
#line 343 "/home/khheo/project/benchmark/sed/sed/utils.c"
static int buf_size  ;
#line 338 "/home/khheo/project/benchmark/sed/sed/utils.c"
char const   *follow_symlink(char const   *fname ) 
{ 
  struct stat statbuf ;
  char const   *buf ;
  char const   *c ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int len ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 346
  buf = fname;
#line 349
  if (buf_size == 0) {
    {
#line 351
    tmp = ck_malloc((size_t )4097);
#line 351
    buf1 = (char *)tmp;
#line 352
    tmp___0 = ck_malloc((size_t )4097);
#line 352
    buf2 = (char *)tmp___0;
#line 353
    buf_size = 4097;
    }
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    rc = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& statbuf));
    }
#line 356
    if (rc == 0) {
#line 356
      if (! ((statbuf.st_mode & 40960U) == 40960U)) {
#line 356
        goto while_break;
      }
    } else {
#line 356
      goto while_break;
    }
#line 359
    if ((unsigned long )buf == (unsigned long )buf2) {
      {
#line 361
      strcpy((char */* __restrict  */)buf1, (char const   */* __restrict  */)buf2);
#line 362
      buf = (char const   *)buf1;
      }
    }
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 365
      tmp___3 = readlink((char const   */* __restrict  */)buf, (char */* __restrict  */)buf2,
                         (size_t )buf_size);
#line 365
      rc = (int )tmp___3;
      }
#line 365
      if (! (rc == buf_size)) {
#line 365
        goto while_break___0;
      }
      {
#line 367
      buf_size *= 2;
#line 368
      tmp___1 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 368
      buf1 = (char *)tmp___1;
#line 369
      tmp___2 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 369
      buf2 = (char *)tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    if (rc < 0) {
      {
#line 372
      tmp___4 = __errno_location();
#line 372
      tmp___5 = strerror(*tmp___4);
#line 372
      tmp___6 = gettext("couldn\'t follow symlink %s: %s");
#line 372
      panic((char const   *)tmp___6, buf, tmp___5);
      }
    } else {
#line 374
      *(buf2 + rc) = (char )'\000';
    }
#line 376
    if ((int )*(buf2 + 0) != 47) {
      {
#line 376
      tmp___9 = strrchr(buf, '/');
#line 376
      c = (char const   *)tmp___9;
      }
#line 376
      if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 380
        len = (int )((c - buf) + 1L);
#line 381
        if ((len + rc) + 1 > buf_size) {
          {
#line 383
          buf_size = (len + rc) + 1;
#line 384
          tmp___7 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 384
          buf1 = (char *)tmp___7;
#line 385
          tmp___8 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 385
          buf2 = (char *)tmp___8;
          }
        }
#line 389
        if ((unsigned long )buf != (unsigned long )buf1) {
          {
#line 390
          memcpy((void */* __restrict  */)buf1, (void const   */* __restrict  */)buf,
                 (size_t )len);
          }
        }
        {
#line 393
        memcpy((void */* __restrict  */)(buf1 + len), (void const   */* __restrict  */)buf2,
               (size_t )(rc + 1));
#line 394
        buf = (char const   *)buf1;
        }
      } else {
#line 401
        buf = (char const   *)buf2;
      }
    } else {
#line 401
      buf = (char const   *)buf2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  if (rc < 0) {
    {
#line 406
    tmp___10 = __errno_location();
#line 406
    tmp___11 = strerror(*tmp___10);
#line 406
    tmp___12 = gettext("cannot stat %s: %s");
#line 406
    panic((char const   *)tmp___12, buf, tmp___11);
    }
  }
#line 408
  return (buf);
}
}
#line 415 "/home/khheo/project/benchmark/sed/sed/utils.c"
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) 
{ 
  int rd ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 420
  tmp = rename(from, to);
#line 420
  rd = tmp;
  }
#line 421
  if (rd != -1) {
#line 422
    return;
  }
#line 424
  if (unlink_if_fail) {
    {
#line 426
    tmp___0 = __errno_location();
#line 426
    save_errno = *tmp___0;
#line 427
    tmp___1 = __errno_location();
#line 427
    *tmp___1 = 0;
#line 428
    unlink(unlink_if_fail);
#line 431
    tmp___5 = __errno_location();
    }
#line 431
    if (*tmp___5 != 0) {
      {
#line 432
      tmp___2 = __errno_location();
#line 432
      tmp___3 = strerror(*tmp___2);
#line 432
      tmp___4 = gettext("cannot remove %s: %s");
#line 432
      panic((char const   *)tmp___4, unlink_if_fail, tmp___3);
      }
    }
    {
#line 434
    tmp___6 = __errno_location();
#line 434
    *tmp___6 = save_errno;
    }
  }
  {
#line 437
  tmp___7 = __errno_location();
#line 437
  tmp___8 = strerror(*tmp___7);
#line 437
  tmp___9 = gettext("cannot rename %s: %s");
#line 437
  panic((char const   *)tmp___9, from, tmp___8);
  }
#line 438
  return;
}
}
#line 444 "/home/khheo/project/benchmark/sed/sed/utils.c"
void *ck_malloc(size_t size ) 
{ 
  void *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 448
  if (size) {
#line 448
    tmp = size;
  } else {
#line 448
    tmp = (size_t )1;
  }
  {
#line 448
  tmp___0 = calloc((size_t )1, tmp);
#line 448
  ret = tmp___0;
  }
#line 449
  if (! ret) {
    {
#line 450
    panic("couldn\'t allocate memory");
    }
  }
#line 451
  return (ret);
}
}
#line 455 "/home/khheo/project/benchmark/sed/sed/utils.c"
void *ck_realloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 462
  if (size == 0UL) {
    {
#line 464
    free(ptr);
    }
#line 465
    return ((void *)0);
  }
#line 467
  if (! ptr) {
    {
#line 468
    tmp = ck_malloc(size);
    }
#line 468
    return (tmp);
  }
  {
#line 469
  ret = realloc(ptr, size);
  }
#line 470
  if (! ret) {
    {
#line 471
    panic("couldn\'t re-allocate memory");
    }
  }
#line 472
  return (ret);
}
}
#line 476 "/home/khheo/project/benchmark/sed/sed/utils.c"
char *ck_strdup(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 480
  tmp = strlen(str);
#line 480
  tmp___0 = ck_malloc((tmp + 1UL) * sizeof(char ));
#line 480
  ret = (char *)tmp___0;
#line 481
  tmp___1 = strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
#line 481
  return (tmp___1);
}
}
#line 485 "/home/khheo/project/benchmark/sed/sed/utils.c"
void *ck_memdup(void const   *buf , size_t len ) 
{ 
  void *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 490
  tmp = ck_malloc(len);
#line 490
  ret = tmp;
#line 491
  tmp___0 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)buf,
                   len);
  }
#line 491
  return (tmp___0);
}
}
#line 507 "/home/khheo/project/benchmark/sed/sed/utils.c"
struct buffer *init_buffer(void) 
{ 
  struct buffer *b___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 510
  tmp = ck_malloc(sizeof(struct buffer ));
#line 510
  b___0 = (struct buffer *)tmp;
#line 511
  tmp___0 = ck_malloc(50UL * sizeof(char ));
#line 511
  b___0->b = (char *)tmp___0;
#line 512
  b___0->allocated = (size_t )50;
#line 513
  b___0->length = (size_t )0;
  }
#line 514
  return (b___0);
}
}
#line 517 "/home/khheo/project/benchmark/sed/sed/utils.c"
char *get_buffer(struct buffer *b___0 ) 
{ 


  {
#line 521
  return (b___0->b);
}
}
#line 524 "/home/khheo/project/benchmark/sed/sed/utils.c"
size_t size_buffer(struct buffer *b___0 ) 
{ 


  {
#line 528
  return (b___0->length);
}
}
#line 531
static void resize_buffer(struct buffer *b___0 , size_t newlen ) ;
#line 532 "/home/khheo/project/benchmark/sed/sed/utils.c"
static void resize_buffer(struct buffer *b___0 , size_t newlen ) 
{ 
  char *try ;
  size_t alen ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 537
  try = (char *)((void *)0);
#line 538
  alen = b___0->allocated;
#line 540
  if (newlen <= alen) {
#line 541
    return;
  }
#line 542
  alen *= 2UL;
#line 543
  if (newlen < alen) {
    {
#line 544
    tmp = realloc((void *)b___0->b, alen);
#line 544
    try = (char *)tmp;
    }
  }
#line 545
  if (! try) {
    {
#line 547
    alen = newlen;
#line 548
    tmp___0 = ck_realloc((void *)b___0->b, alen * sizeof(char ));
#line 548
    try = (char *)tmp___0;
    }
  }
#line 550
  b___0->allocated = alen;
#line 551
  b___0->b = try;
#line 552
  return;
}
}
#line 554 "/home/khheo/project/benchmark/sed/sed/utils.c"
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) 
{ 
  char *result ;
  void *tmp ;

  {
#line 561
  if (b___0->allocated - b___0->length < n) {
    {
#line 562
    resize_buffer(b___0, b___0->length + n);
    }
  }
  {
#line 563
  tmp = memcpy((void */* __restrict  */)(b___0->b + b___0->length), (void const   */* __restrict  */)p,
               n);
#line 563
  result = (char *)tmp;
#line 564
  b___0->length += n;
  }
#line 565
  return (result);
}
}
#line 568 "/home/khheo/project/benchmark/sed/sed/utils.c"
char *add1_buffer(struct buffer *b___0 , int c ) 
{ 
  char *result ;
  size_t tmp ;

  {
#line 579
  if (c != -1) {
#line 582
    if (b___0->allocated - b___0->length < 1UL) {
      {
#line 583
      resize_buffer(b___0, b___0->length + 1UL);
      }
    }
#line 584
    tmp = b___0->length;
#line 584
    (b___0->length) ++;
#line 584
    result = b___0->b + tmp;
#line 585
    *result = (char )c;
#line 586
    return (result);
  }
#line 589
  return ((char *)((void *)0));
}
}
#line 592 "/home/khheo/project/benchmark/sed/sed/utils.c"
void free_buffer(struct buffer *b___0 ) 
{ 


  {
#line 596
  if (b___0) {
    {
#line 597
    free((void *)b___0->b);
    }
  }
  {
#line 598
  free((void *)b___0);
  }
#line 599
  return;
}
}
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 241 "/home/khheo/project/benchmark/sed/sed/sed.h"
int mb_cur_max  ;
#line 242 "/home/khheo/project/benchmark/sed/sed/sed.h"
_Bool is_utf8  ;
#line 263
int brlen(int ch , mbstate_t *cur_stat ) ;
#line 264
void initialize_mbcs(void) ;
#line 30 "/home/khheo/project/benchmark/sed/sed/mbcs.c"
int brlen(int ch , mbstate_t *cur_stat ) 
{ 
  char c ;
  int result ;
  size_t tmp ;

  {
  {
#line 34
  c = (char )ch;
#line 37
  tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)(& c),
                (size_t )1, (mbstate_t */* __restrict  */)cur_stat);
#line 37
  result = (int )tmp;
  }
#line 40
  if (result == -1) {
    {
#line 42
    memset((void *)cur_stat, 0, sizeof(mbstate_t ));
    }
#line 43
    return (1);
  }
#line 46
  return (result);
}
}
#line 49 "/home/khheo/project/benchmark/sed/sed/mbcs.c"
void initialize_mbcs(void) 
{ 
  char const   *codeset_name ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 55
  codeset_name = locale_charset();
#line 56
  tmp = strcmp(codeset_name, "UTF-8");
#line 56
  is_utf8 = (_Bool )(tmp == 0);
#line 58
  tmp___0 = __ctype_get_mb_cur_max();
#line 58
  mb_cur_max = (int )tmp___0;
  }
#line 59
  return;
}
}
#line 545 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 204 "/home/khheo/project/benchmark/sed/sed/sed.h"
void fmt(char const   *line___0 , char const   *line_end , int max_length , FILE *output_file___0 ) ;
#line 127 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static _Bool get_paragraph(void) ;
#line 128
static int get_line(int c ) ;
#line 129
static int get_space(int c ) ;
#line 130
static int copy_rest(int c ) ;
#line 131
static _Bool same_para(int c ) ;
#line 132
static void flush_paragraph(void) ;
#line 133
static void fmt_paragraph(void) ;
#line 134
static void check_punctuation(WORD *w ) ;
#line 135
static COST base_cost(WORD *this ) ;
#line 136
static COST line_cost(WORD *next , int len ) ;
#line 137
static void put_paragraph(WORD *finish ) ;
#line 138
static void put_line(WORD *w , int indent ) ;
#line 139
static void put_word(WORD *w ) ;
#line 140
static void put_space(int space ) ;
#line 147 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int max_width  ;
#line 150 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static char const   *parabuf  ;
#line 153 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static char const   *end_of_parabuf  ;
#line 156 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static FILE *outfile  ;
#line 161 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int best_width  ;
#line 166 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int in_column  ;
#line 169 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int out_column  ;
#line 173 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static WORD words[1000]  ;
#line 178 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static WORD *word_limit  ;
#line 181 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int first_indent  ;
#line 184 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int other_indent  ;
#line 187 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int next_char  ;
#line 192 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int last_line_length  ;
#line 196 "/home/khheo/project/benchmark/sed/sed/fmt.c"
void fmt(char const   *line___0 , char const   *line_end , int max_length , FILE *output_file___0 ) 
{ 
  char const   *tmp ;
  _Bool tmp___0 ;

  {
#line 199
  parabuf = line___0;
#line 200
  end_of_parabuf = line_end;
#line 201
  outfile = output_file___0;
#line 203
  max_width = max_length;
#line 204
  best_width = (max_width * 187) / 200;
#line 206
  in_column = 0;
#line 207
  other_indent = 0;
#line 208
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 208
    next_char = -1;
  } else {
#line 208
    tmp = parabuf;
#line 208
    parabuf ++;
#line 208
    next_char = (int )*tmp;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    tmp___0 = get_paragraph();
    }
#line 209
    if (! tmp___0) {
#line 209
      goto while_break;
    }
    {
#line 211
    fmt_paragraph();
#line 212
    put_paragraph(word_limit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 223 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static _Bool get_paragraph(void) 
{ 
  register int c ;
  char const   *tmp ;
  _Bool tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 228
  last_line_length = 0;
#line 229
  c = next_char;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (c == 10)) {
#line 233
      if (! (c == -1)) {
#line 233
        goto while_break;
      }
    }
    {
#line 235
    c = copy_rest(c);
    }
#line 236
    if (c == -1) {
#line 238
      next_char = -1;
#line 239
      return ((_Bool)0);
    }
    {
#line 241
    putc_unlocked('\n', outfile);
    }
#line 242
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 242
      c = -1;
    } else {
#line 242
      tmp = parabuf;
#line 242
      parabuf ++;
#line 242
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  first_indent = in_column;
#line 248
  word_limit = words;
#line 249
  c = get_line(c);
#line 253
  other_indent = in_column;
  }
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 254
    tmp___0 = same_para(c);
    }
#line 254
    if (tmp___0) {
#line 254
      if (! (in_column == other_indent)) {
#line 254
        goto while_break___0;
      }
    } else {
#line 254
      goto while_break___0;
    }
    {
#line 255
    c = get_line(c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  tmp___1 = 1U;
#line 257
  (word_limit - 1)->final = tmp___1;
#line 257
  (word_limit - 1)->period = tmp___1;
#line 258
  next_char = c;
#line 259
  return ((_Bool)1);
}
}
#line 265 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int copy_rest(int c ) 
{ 
  char const   *tmp ;

  {
#line 268
  out_column = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (c != 10) {
#line 269
      if (! (c != -1)) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
#line 271
    putc_unlocked(c, outfile);
    }
#line 272
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 272
      c = -1;
    } else {
#line 272
      tmp = parabuf;
#line 272
      parabuf ++;
#line 272
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (c);
}
}
#line 281 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static _Bool same_para(int c ) 
{ 
  int tmp ;

  {
#line 284
  if (c != 10) {
#line 284
    if (c != -1) {
#line 284
      tmp = 1;
    } else {
#line 284
      tmp = 0;
    }
  } else {
#line 284
    tmp = 0;
  }
#line 284
  return ((_Bool )tmp);
}
}
#line 295 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int get_line(int c ) 
{ 
  int start ;
  register WORD *end_of_word ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 301
  end_of_word = & words[998];
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    word_limit->text = parabuf - 1;
    {
#line 309
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 310
      if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 310
        c = -1;
      } else {
#line 310
        tmp = parabuf;
#line 310
        parabuf ++;
#line 310
        c = (int )*tmp;
      }
#line 309
      if (c != -1) {
        {
#line 309
        tmp___0 = __ctype_b_loc();
        }
#line 309
        if ((int const   )*(*tmp___0 + c) & 8192) {
#line 309
          goto while_break___0;
        }
      } else {
#line 309
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 312
    word_limit->length = (short )((parabuf - word_limit->text) - (long )(c != -1));
#line 313
    in_column += (int )word_limit->length;
#line 315
    check_punctuation(word_limit);
#line 319
    start = in_column;
#line 320
    c = get_space(c);
#line 321
    word_limit->space = (short )(in_column - start);
    }
#line 322
    if (c == -1) {
#line 322
      tmp___1 = 1;
    } else
#line 322
    if (word_limit->period) {
#line 322
      if (c == 10) {
#line 322
        tmp___1 = 1;
      } else
#line 322
      if ((int )word_limit->space > 1) {
#line 322
        tmp___1 = 1;
      } else {
#line 322
        tmp___1 = 0;
      }
    } else {
#line 322
      tmp___1 = 0;
    }
#line 322
    word_limit->final = (unsigned int )tmp___1;
#line 325
    if (c == 10) {
#line 325
      goto _L;
    } else
#line 325
    if (c == -1) {
      _L: /* CIL Label */ 
#line 326
      if (word_limit->final) {
#line 326
        word_limit->space = (short)2;
      } else {
#line 326
        word_limit->space = (short)1;
      }
    }
#line 327
    if ((unsigned long )word_limit == (unsigned long )end_of_word) {
      {
#line 328
      flush_paragraph();
      }
    }
#line 329
    word_limit ++;
#line 330
    if (c == -1) {
#line 332
      in_column = first_indent;
#line 333
      return (-1);
    }
#line 303
    if (! (c != 10)) {
#line 303
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  in_column = 0;
#line 339
  if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 339
    c = -1;
  } else {
#line 339
    tmp___2 = parabuf;
#line 339
    parabuf ++;
#line 339
    c = (int )*tmp___2;
  }
  {
#line 340
  tmp___3 = get_space(c);
  }
#line 340
  return (tmp___3);
}
}
#line 346 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static int get_space(int c ) 
{ 
  char const   *tmp ;

  {
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (c == 32) {
#line 352
      in_column ++;
    } else
#line 353
    if (c == 9) {
#line 354
      in_column = (in_column / 8 + 1) * 8;
    } else {
#line 356
      return (c);
    }
#line 357
    if ((unsigned long )parabuf == (unsigned long )end_of_parabuf) {
#line 357
      c = -1;
    } else {
#line 357
      tmp = parabuf;
#line 357
      parabuf ++;
#line 357
      c = (int )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 363 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void check_punctuation(WORD *w ) 
{ 
  register char const   *start ;
  register char const   *finish ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 368
  start = w->text;
#line 369
  finish = start + ((int )w->length - 1);
#line 370
  tmp = strchr("([`\'\"", (int )*start);
#line 370
  w->paren = (unsigned int )((unsigned long )tmp != (unsigned long )((void *)0));
#line 371
  tmp___0 = __ctype_b_loc();
#line 371
  w->punct = (unsigned int )(((int const   )*(*tmp___0 + (int )*finish) & 4) != (int const   )0);
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    tmp___1 = strchr(")]\'\"", (int )*finish);
    }
#line 372
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 372
      if (! ((unsigned long )finish > (unsigned long )start)) {
#line 372
        goto while_break;
      }
    } else {
#line 372
      goto while_break;
    }
#line 373
    finish --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  tmp___2 = strchr(".?!", (int )*finish);
#line 374
  w->period = (unsigned int )((unsigned long )tmp___2 != (unsigned long )((void *)0));
  }
#line 375
  return;
}
}
#line 380 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void flush_paragraph(void) 
{ 
  WORD *split_point ;
  register WORD *w ;
  COST best_break ;

  {
  {
#line 392
  fmt_paragraph();
#line 396
  split_point = word_limit;
#line 397
  best_break = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
#line 398
  w = words[0].next_break;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! ((unsigned long )w != (unsigned long )word_limit)) {
#line 398
      goto while_break;
    }
#line 400
    if (w->best_cost - (w->next_break)->best_cost < best_break) {
#line 402
      split_point = w;
#line 403
      best_break = w->best_cost - (w->next_break)->best_cost;
    }
#line 405
    if ((unsigned long )best_break <= ~ (1UL << (8UL * sizeof(COST ) - 1UL)) - 9UL) {
#line 406
      best_break += 9L;
    }
#line 398
    w = w->next_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  put_paragraph(split_point);
#line 413
  memmove((void *)((char *)(words)), (void const   *)((char *)split_point), (unsigned long )((word_limit - split_point) + 1L) * sizeof(WORD ));
#line 415
  word_limit -= split_point - words;
  }
#line 416
  return;
}
}
#line 422 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void fmt_paragraph(void) 
{ 
  register WORD *start ;
  register WORD *w ;
  register int len ;
  register COST wcost ;
  register COST best ;
  int saved_length ;
  COST tmp ;
  COST tmp___0 ;

  {
#line 430
  word_limit->best_cost = (COST )0;
#line 431
  saved_length = (int )word_limit->length;
#line 432
  word_limit->length = (short )max_width;
#line 434
  start = word_limit - 1;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! ((unsigned long )start >= (unsigned long )(words))) {
#line 434
      goto while_break;
    }
#line 436
    best = (COST )(~ (1UL << (8UL * sizeof(COST ) - 1UL)));
#line 437
    if ((unsigned long )start == (unsigned long )(words)) {
#line 437
      len = first_indent;
    } else {
#line 437
      len = other_indent;
    }
#line 441
    w = start;
#line 442
    len += (int )w->length;
    {
#line 443
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 445
      w ++;
#line 449
      tmp = line_cost(w, len);
#line 449
      wcost = tmp + w->best_cost;
      }
#line 450
      if ((unsigned long )start == (unsigned long )(words)) {
#line 450
        if (last_line_length > 0) {
#line 451
          wcost += ((COST )((len - last_line_length) * 10) * (COST )((len - last_line_length) * 10)) / 2L;
        }
      }
#line 452
      if (wcost < best) {
#line 454
        best = wcost;
#line 455
        start->next_break = w;
#line 456
        start->line_length = (short )len;
      }
#line 458
      len += (int )(w - 1)->space + (int )w->length;
#line 443
      if (! (len < max_width)) {
#line 443
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 461
    tmp___0 = base_cost(start);
#line 461
    start->best_cost = best + tmp___0;
#line 434
    start --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  word_limit->length = (short )saved_length;
#line 465
  return;
}
}
#line 470 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static COST base_cost(WORD *this ) 
{ 
  register COST cost ;

  {
#line 475
  cost = 4900L;
#line 477
  if ((unsigned long )this > (unsigned long )(words)) {
#line 479
    if ((this - 1)->period) {
#line 481
      if ((this - 1)->final) {
#line 482
        cost -= 2500L;
      } else {
#line 484
        cost += 360000L;
      }
    } else
#line 486
    if ((this - 1)->punct) {
#line 487
      cost -= 1600L;
    } else
#line 488
    if ((unsigned long )this > (unsigned long )(words + 1)) {
#line 488
      if ((this - 2)->final) {
#line 489
        cost += 40000L / (COST )((int )(this - 1)->length + 2);
      }
    }
  }
#line 492
  if (this->paren) {
#line 493
    cost -= 1600L;
  } else
#line 494
  if (this->final) {
#line 495
    cost += 22500L / (COST )((int )this->length + 2);
  }
#line 497
  return (cost);
}
}
#line 503 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static COST line_cost(WORD *next , int len ) 
{ 
  register int n ;
  register COST cost ;

  {
#line 509
  if ((unsigned long )next == (unsigned long )word_limit) {
#line 510
    return ((COST )0);
  }
#line 511
  n = best_width - len;
#line 512
  cost = (COST )(n * 10) * (COST )(n * 10);
#line 513
  if ((unsigned long )next->next_break != (unsigned long )word_limit) {
#line 515
    n = len - (int )next->line_length;
#line 516
    cost += ((COST )(n * 10) * (COST )(n * 10)) / 2L;
  }
#line 518
  return (cost);
}
}
#line 524 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void put_paragraph(WORD *finish ) 
{ 
  register WORD *w ;

  {
  {
#line 529
  put_line(words, first_indent);
#line 530
  w = words[0].next_break;
  }
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((unsigned long )w != (unsigned long )finish)) {
#line 530
      goto while_break;
    }
    {
#line 531
    put_line(w, other_indent);
#line 530
    w = w->next_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 537 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void put_line(WORD *w , int indent ) 
{ 
  register WORD *endline ;

  {
  {
#line 541
  out_column = 0;
#line 542
  put_space(indent);
#line 544
  endline = w->next_break - 1;
  }
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! ((unsigned long )w != (unsigned long )endline)) {
#line 545
      goto while_break;
    }
    {
#line 547
    put_word(w);
#line 548
    put_space((int )w->space);
#line 545
    w ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  put_word(w);
#line 551
  last_line_length = out_column;
#line 552
  putc_unlocked('\n', outfile);
  }
#line 553
  return;
}
}
#line 557 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void put_word(WORD *w ) 
{ 
  register char const   *s ;
  register int n ;
  char const   *tmp ;

  {
#line 563
  s = w->text;
#line 564
  n = (int )w->length;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (n != 0)) {
#line 564
      goto while_break;
    }
    {
#line 565
    tmp = s;
#line 565
    s ++;
#line 565
    putc_unlocked((int )*tmp, outfile);
#line 564
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  out_column += (int )w->length;
#line 567
  return;
}
}
#line 571 "/home/khheo/project/benchmark/sed/sed/fmt.c"
static void put_space(int space ) 
{ 
  int tmp ;

  {
#line 574
  out_column += space;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    tmp = space;
#line 575
    space --;
#line 575
    if (! tmp) {
#line 575
      goto while_break;
    }
    {
#line 576
    putc_unlocked(' ', outfile);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 538 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 548
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 563
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__string ,
                          __re_idx_t __length , __re_idx_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 184 "/home/khheo/project/benchmark/sed/sed/sed.h"
void bad_prog(char const   *why ) ;
#line 185
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) ;
#line 192
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) ;
#line 193
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) ;
#line 206
int extended_regexp_flags ;
#line 225
enum posixicity_types posixicity ;
#line 34 "/home/khheo/project/benchmark/sed/sed/regexp.c"
static char const   errors[72]  = 
#line 34 "/home/khheo/project/benchmark/sed/sed/regexp.c"
  {      (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'o',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'\000'};
#line 44 "/home/khheo/project/benchmark/sed/sed/regexp.c"
static void compile_regex_1(struct regex *new_regex , int needed_sub ) 
{ 
  char const   *error___0 ;
  int syntax ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  char buf[200] ;
  char *tmp___3 ;

  {
#line 64
  if (extended_regexp_flags & 1) {
#line 64
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 64
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
#line 64
  syntax = (int )tmp;
#line 68
  syntax = (int )((unsigned long )syntax & ~ (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 69
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  {
#line 73
  if ((unsigned int )posixicity == 0U) {
#line 73
    goto case_0;
  }
#line 76
  if ((unsigned int )posixicity == 1U) {
#line 76
    goto case_1;
  }
#line 79
  if ((unsigned int )posixicity == 2U) {
#line 79
    goto case_2;
  }
#line 71
  goto switch_break;
  case_0: /* CIL Label */ 
#line 74
  syntax = (int )((unsigned long )syntax & ~ (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 75
  goto switch_break;
  case_1: /* CIL Label */ 
#line 77
  syntax = (int )((unsigned long )syntax | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  syntax = (int )((unsigned long )syntax | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
#line 81
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  if (new_regex->flags & (1 << 1)) {
#line 85
    tmp___0 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 85
    tmp___0 = 0UL;
  }
#line 85
  syntax = (int )((unsigned long )syntax | tmp___0);
#line 88
  if (needed_sub) {
#line 88
    tmp___1 = 0UL;
  } else {
#line 88
    tmp___1 = ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 88
  syntax = (int )((unsigned long )syntax | tmp___1);
#line 91
  tmp___2 = malloc((size_t )(1 << sizeof(char ) * 8UL));
#line 91
  new_regex->pattern.fastmap = (char *)tmp___2;
  }
#line 94
  if (new_regex->flags & (1 << 2)) {
#line 97
    syntax = (int )((unsigned long )syntax & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1));
#line 98
    syntax = (int )((unsigned long )syntax | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
#line 101
  re_set_syntax((reg_syntax_t )syntax);
#line 102
  error___0 = re_compile_pattern((char const   *)(new_regex->re), new_regex->sz, & new_regex->pattern);
#line 104
  new_regex->pattern.newline_anchor = (unsigned int )((new_regex->flags & (1 << 2)) != 0);
#line 106
  new_regex->pattern.translate = (unsigned char *)((void *)0);
  }
#line 119
  if (error___0) {
    {
#line 120
    bad_prog(error___0);
    }
  }
#line 124
  if (needed_sub) {
#line 124
    if (new_regex->pattern.re_nsub < (size_t )(needed_sub - 1)) {
#line 124
      if ((unsigned int )posixicity == 0U) {
        {
#line 129
        tmp___3 = gettext("invalid reference \\%d on `s\' command\'s RHS");
#line 129
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___3,
                needed_sub - 1);
#line 131
        bad_prog((char const   *)(buf));
        }
      }
    }
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/sed/sed/regexp.c"
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) 
{ 
  struct regex *new_regex ;
  size_t re_len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 145
  tmp___0 = size_buffer(b___0);
  }
#line 145
  if (tmp___0 == 0UL) {
#line 147
    if (flags > 0) {
      {
#line 148
      tmp = gettext(errors + sizeof("no previous regular expression"));
#line 148
      bad_prog((char const   *)tmp);
      }
    }
#line 149
    return ((struct regex *)((void *)0));
  }
  {
#line 152
  re_len = size_buffer(b___0);
#line 153
  tmp___1 = ck_malloc((sizeof(struct regex ) + re_len) - 1UL);
#line 153
  new_regex = (struct regex *)tmp___1;
#line 154
  new_regex->flags = flags;
#line 155
  tmp___2 = get_buffer(b___0);
#line 155
  memcpy((void */* __restrict  */)(new_regex->re), (void const   */* __restrict  */)tmp___2,
         re_len);
#line 161
  new_regex->sz = normalize_text(new_regex->re, re_len, (enum text_types )2);
#line 164
  compile_regex_1(new_regex, needed_sub);
  }
#line 165
  return (new_regex);
}
}
#line 216 "/home/khheo/project/benchmark/sed/sed/regexp.c"
static struct regex *regex_last  ;
#line 206 "/home/khheo/project/benchmark/sed/sed/regexp.c"
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) 
{ 
  int ret ;
  char *tmp ;
  struct re_registers *tmp___0 ;

  {
#line 226
  if (! regex) {
#line 228
    regex = regex_last;
#line 229
    if (! regex_last) {
      {
#line 230
      tmp = gettext(errors);
#line 230
      bad_prog((char const   *)tmp);
      }
    }
  } else {
#line 233
    regex_last = regex;
  }
#line 245
  if (regex->pattern.no_sub) {
#line 245
    if (regsize) {
      {
#line 246
      compile_regex_1(regex, regsize);
      }
    }
  }
#line 248
  regex->pattern.regs_allocated = 1U;
#line 250
  if (regsize) {
#line 250
    tmp___0 = regarray;
  } else {
#line 250
    tmp___0 = (struct re_registers *)((void *)0);
  }
  {
#line 250
  ret = re_search(& regex->pattern, (char const   *)buf, (__re_idx_t )buflen, (__re_idx_t )buf_start_offset,
                  (regoff_t )(buflen - buf_start_offset), tmp___0);
  }
#line 254
  return (ret > -1);
}
}
#line 284 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 288
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 294 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream ) ;
#line 766
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 189 "/home/khheo/project/benchmark/sed/sed/sed.h"
void rewind_read_files(void) ;
#line 200
int process_files(struct vector *the_program___0 , char **argv ) ;
#line 209
char buffer_delimiter ;
#line 213
_Bool unbuffered ;
#line 216
_Bool no_default_output ;
#line 219
_Bool separate_files ;
#line 222
_Bool follow_symlinks ;
#line 228
countT lcmd_out_line_len ;
#line 231
char *in_place_extension ;
#line 234
char *read_mode ;
#line 235
char *write_mode ;
#line 481 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 133 "../lib/unistd.h"
#pragma GCC diagnostic push
#line 133
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 133
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1852
#pragma GCC diagnostic pop
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 35 "../lib/selinux/selinux.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 35
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 132
#pragma GCC diagnostic push
#line 132
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 132
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 7 "../lib/selinux/context.h"
#pragma GCC diagnostic push
#line 7
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 7
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 54
#pragma GCC diagnostic pop
#line 111 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool replaced  =    (_Bool)0;
#line 114 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct output output_file  ;
#line 117 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct line line  ;
#line 120 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct line s_accum  ;
#line 123 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct line hold  ;
#line 127 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct line buffer  ;
#line 129 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct append_queue *append_head  =    (struct append_queue *)((void *)0);
#line 130 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct append_queue *append_tail  =    (struct append_queue *)((void *)0);
#line 135
static void resize_line(struct line *lb , size_t len ) ;
#line 136 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void resize_line(struct line *lb , size_t len ) 
{ 
  int inactive ;
  void *tmp ;

  {
#line 142
  inactive = (int )(lb->active - lb->text);
#line 146
  if ((size_t )inactive > lb->alloc * 2UL) {
    {
#line 148
    memmove((void *)lb->text, (void const   *)lb->active, lb->length);
#line 149
    lb->alloc += (size_t )(lb->active - lb->text);
#line 150
    lb->active = lb->text;
#line 151
    inactive = 0;
    }
#line 153
    if (lb->alloc > len) {
#line 154
      return;
    }
  }
#line 157
  lb->alloc *= 2UL;
#line 158
  if (lb->alloc < len) {
#line 159
    lb->alloc = len;
  }
#line 160
  if (lb->alloc < 50UL) {
#line 161
    lb->alloc = (size_t )50;
  }
  {
#line 163
  tmp = ck_realloc((void *)lb->text, ((size_t )inactive + lb->alloc) * sizeof(char ));
#line 163
  lb->text = (char *)tmp;
#line 164
  lb->active = lb->text + inactive;
  }
#line 165
  return;
}
}
#line 168
static void str_append(struct line *to , char const   *string , size_t length ) ;
#line 169 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void str_append(struct line *to , char const   *string , size_t length ) 
{ 
  size_t new_length ;
  size_t n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 175
  new_length = to->length + length;
#line 177
  if (to->alloc < new_length) {
    {
#line 178
    resize_line(to, new_length);
    }
  }
  {
#line 179
  memcpy((void */* __restrict  */)(to->active + to->length), (void const   */* __restrict  */)string,
         length);
#line 180
  to->length = new_length;
  }
#line 182
  if (mb_cur_max > 1) {
#line 182
    if (! is_utf8) {
      {
#line 183
      while (1) {
        while_continue: /* CIL Label */ ;
#line 183
        if (! length) {
#line 183
          goto while_break;
        }
#line 185
        if (mb_cur_max == 1) {
#line 185
          tmp___0 = (size_t )1;
        } else {
          {
#line 185
          tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)string,
                        length, (mbstate_t */* __restrict  */)(& to->mbstate));
#line 185
          tmp___0 = tmp;
          }
        }
#line 185
        n = tmp___0;
#line 188
        if (n == 0xffffffffffffffffUL) {
          {
#line 190
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 191
          n = (size_t )1;
          }
        } else
#line 188
        if (n == 0xfffffffffffffffeUL) {
          {
#line 190
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 191
          n = (size_t )1;
          }
        }
#line 194
        if (n > 0UL) {
#line 196
          string += n;
#line 197
          length -= n;
        } else {
#line 200
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 202
  return;
}
}
#line 204 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) 
{ 
  mbstate_t from_stat ;
  wchar_t wc ;
  int n ;
  wint_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  wint_t tmp___6 ;
  wint_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
#line 210
  if ((unsigned int )type == 0U) {
    {
#line 212
    str_append(to, string, length);
    }
#line 213
    return;
  }
#line 216
  if (to->alloc - to->length < length * (size_t )mb_cur_max) {
    {
#line 217
    resize_line(to, to->length + length * (size_t )mb_cur_max);
    }
  }
  {
#line 219
  memcpy((void */* __restrict  */)(& from_stat), (void const   */* __restrict  */)(& to->mbstate),
         sizeof(mbstate_t ));
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! length) {
#line 220
      goto while_break;
    }
#line 223
    if (mb_cur_max == 1) {
      {
#line 223
      tmp = btowc((int )*((unsigned char *)string));
#line 223
      wc = (wchar_t )tmp;
#line 223
      tmp___1 = (size_t )1;
      }
    } else {
      {
#line 223
      tmp___0 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)string,
                        length, (mbstate_t */* __restrict  */)(& from_stat));
#line 223
      tmp___1 = tmp___0;
      }
    }
#line 223
    n = (int )tmp___1;
#line 226
    if (n == -1) {
      {
#line 228
      memset((void *)(& to->mbstate), 0, sizeof(from_stat));
#line 229
      n = 1;
      }
    }
#line 232
    if (n > 0) {
#line 233
      string += n;
#line 233
      length -= (size_t )n;
    } else {
      {
#line 237
      str_append(to, string, length);
      }
#line 238
      return;
    }
#line 242
    if ((unsigned int )type & 12U) {
#line 244
      if ((unsigned int )type & 4U) {
        {
#line 245
        tmp___2 = towupper((wint_t )wc);
#line 245
        wc = (wchar_t )tmp___2;
        }
      } else {
        {
#line 247
        tmp___3 = towlower((wint_t )wc);
#line 247
        wc = (wchar_t )tmp___3;
        }
      }
#line 249
      type = (enum replacement_types )((unsigned int )type & 4294967283U);
#line 250
      if ((unsigned int )type == 0U) {
#line 252
        if (mb_cur_max == 1) {
          {
#line 252
          tmp___4 = wctob((wint_t )wc);
#line 252
          *(to->active + to->length) = (char )tmp___4;
#line 252
          n = 1;
          }
        } else {
          {
#line 252
          tmp___5 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc,
                            (mbstate_t */* __restrict  */)(& to->mbstate));
#line 252
          n = (int )tmp___5;
          }
        }
        {
#line 253
        to->length += (size_t )n;
#line 254
        str_append(to, string, length);
        }
#line 255
        return;
      }
    } else
#line 259
    if ((unsigned int )type & 1U) {
      {
#line 260
      tmp___6 = towupper((wint_t )wc);
#line 260
      wc = (wchar_t )tmp___6;
      }
    } else {
      {
#line 262
      tmp___7 = towlower((wint_t )wc);
#line 262
      wc = (wchar_t )tmp___7;
      }
    }
#line 265
    if (mb_cur_max == 1) {
      {
#line 265
      tmp___8 = wctob((wint_t )wc);
#line 265
      *(to->active + to->length) = (char )tmp___8;
#line 265
      n = 1;
      }
    } else {
      {
#line 265
      tmp___9 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc, (mbstate_t */* __restrict  */)(& to->mbstate));
#line 265
      n = (int )tmp___9;
      }
    }
#line 266
    to->length += (size_t )n;
#line 267
    if (n == -1) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Case conversion produced an invalid character!");
#line 270
      abort();
      }
    } else
#line 267
    if (n == -2) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Case conversion produced an invalid character!");
#line 270
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 277
static void line_init(struct line *buf , struct line *state , size_t initial_size ) ;
#line 278 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void line_init(struct line *buf , struct line *state , size_t initial_size ) 
{ 
  void *tmp ;

  {
  {
#line 284
  tmp = ck_malloc(initial_size * sizeof(char ));
#line 284
  buf->text = (char *)tmp;
#line 285
  buf->active = buf->text;
#line 286
  buf->alloc = initial_size;
#line 287
  buf->length = (size_t )0;
#line 288
  buf->chomped = (_Bool)1;
  }
#line 290
  if (state) {
    {
#line 291
    memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
           sizeof(buf->mbstate));
    }
  } else {
    {
#line 293
    memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
    }
  }
#line 294
  return;
}
}
#line 298
static void line_reset(struct line *buf , struct line *state ) ;
#line 299 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void line_reset(struct line *buf , struct line *state ) 
{ 


  {
#line 303
  if (buf->alloc == 0UL) {
    {
#line 304
    line_init(buf, state, (size_t )50);
    }
  } else {
#line 307
    buf->length = (size_t )0;
#line 308
    if (state) {
      {
#line 309
      memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
             sizeof(buf->mbstate));
      }
    } else {
      {
#line 311
      memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
      }
    }
  }
#line 313
  return;
}
}
#line 318
static void line_copy(struct line *from , struct line *to , int state ) ;
#line 319 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void line_copy(struct line *from , struct line *to , int state ) 
{ 
  void *tmp ;

  {
#line 326
  to->alloc += (size_t )(to->active - to->text);
#line 328
  if (to->alloc < from->length) {
#line 330
    to->alloc *= 2UL;
#line 331
    if (to->alloc < from->length) {
#line 332
      to->alloc = from->length;
    }
#line 333
    if (to->alloc < 50UL) {
#line 334
      to->alloc = (size_t )50;
    }
    {
#line 337
    free((void *)to->text);
#line 338
    tmp = ck_malloc(to->alloc * sizeof(char ));
#line 338
    to->text = (char *)tmp;
    }
  }
  {
#line 341
  to->active = to->text;
#line 342
  to->length = from->length;
#line 343
  to->chomped = from->chomped;
#line 344
  memcpy((void */* __restrict  */)to->active, (void const   */* __restrict  */)from->active,
         from->length);
  }
#line 346
  if (state) {
    {
#line 347
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 348
  return;
}
}
#line 352
static void line_append(struct line *from , struct line *to , int state ) ;
#line 353 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void line_append(struct line *from , struct line *to , int state ) 
{ 


  {
  {
#line 359
  str_append(to, (char const   *)(& buffer_delimiter), (size_t )1);
#line 360
  str_append(to, (char const   *)from->active, from->length);
#line 361
  to->chomped = from->chomped;
  }
#line 363
  if (state) {
    {
#line 364
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 365
  return;
}
}
#line 369
static void line_exchange(struct line *a , struct line *b___0 , int state ) ;
#line 370 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void line_exchange(struct line *a , struct line *b___0 , int state ) 
{ 
  struct line t ;

  {
#line 378
  if (state) {
    {
#line 380
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, sizeof(struct line ));
#line 381
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, sizeof(struct line ));
#line 382
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           sizeof(struct line ));
    }
  } else {
    {
#line 386
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, (unsigned long )(& ((struct line *)0)->mbstate));
#line 387
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, (unsigned long )(& ((struct line *)0)->mbstate));
#line 388
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           (unsigned long )(& ((struct line *)0)->mbstate));
    }
  }
#line 390
  return;
}
}
#line 394
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) ;
#line 395 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) 
{ 


  {
#line 399
  return ((_Bool)0);
}
}
#line 402
static _Bool read_file_line(struct input *input ) ;
#line 407 "/home/khheo/project/benchmark/sed/sed/execute.c"
static char *b  ;
#line 408 "/home/khheo/project/benchmark/sed/sed/execute.c"
static size_t blen  ;
#line 403 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool read_file_line(struct input *input ) 
{ 
  long result ;
  size_t tmp ;

  {
  {
#line 410
  tmp = ck_getdelim(& b, & blen, buffer_delimiter, input->fp);
#line 410
  result = (long )tmp;
  }
#line 411
  if (result <= 0L) {
#line 412
    return ((_Bool)0);
  }
#line 415
  if ((int )*(b + (result - 1L)) == (int )buffer_delimiter) {
#line 416
    result --;
  } else {
#line 418
    line.chomped = (_Bool)0;
  }
  {
#line 420
  str_append(& line, (char const   *)b, (size_t )result);
  }
#line 421
  return ((_Bool)1);
}
}
#line 425
__inline static void output_missing_newline(struct output *outf ) ;
#line 426 "/home/khheo/project/benchmark/sed/sed/execute.c"
__inline static void output_missing_newline(struct output *outf ) 
{ 


  {
#line 430
  if (outf->missing_newline) {
    {
#line 432
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
#line 433
    outf->missing_newline = (_Bool)0;
    }
  }
#line 435
  return;
}
}
#line 437
__inline static void flush_output(FILE *fp ) ;
#line 438 "/home/khheo/project/benchmark/sed/sed/execute.c"
__inline static void flush_output(FILE *fp ) 
{ 


  {
#line 442
  if ((unsigned long )fp != (unsigned long )stdout) {
    {
#line 443
    ck_fflush(fp);
    }
  } else
#line 442
  if (unbuffered) {
    {
#line 443
    ck_fflush(fp);
    }
  }
#line 444
  return;
}
}
#line 446
static void output_line(char const   *text , size_t length , int nl , struct output *outf ) ;
#line 447 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void output_line(char const   *text , size_t length , int nl , struct output *outf ) 
{ 


  {
#line 454
  if (! text) {
#line 455
    return;
  }
  {
#line 457
  output_missing_newline(outf);
  }
#line 458
  if (length) {
    {
#line 459
    ck_fwrite((void const   *)text, (size_t )1, length, outf->fp);
    }
  }
#line 460
  if (nl) {
    {
#line 461
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
    }
  } else {
#line 463
    outf->missing_newline = (_Bool)1;
  }
  {
#line 465
  flush_output(outf->fp);
  }
#line 466
  return;
}
}
#line 468
static struct append_queue *next_append_slot(void) ;
#line 469 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct append_queue *next_append_slot(void) 
{ 
  struct append_queue *n ;
  void *tmp ;

  {
  {
#line 472
  tmp = ck_malloc(sizeof(struct append_queue ));
#line 472
  n = (struct append_queue *)tmp;
#line 474
  n->fname = (char const   *)((void *)0);
#line 475
  n->text = (char *)((void *)0);
#line 476
  n->textlen = (size_t )0;
#line 477
  n->next = (struct append_queue *)((void *)0);
#line 478
  n->free = (_Bool)0;
  }
#line 480
  if (append_tail) {
#line 481
    append_tail->next = n;
  } else {
#line 483
    append_head = n;
  }
#line 484
  append_tail = n;
#line 484
  return (append_tail);
}
}
#line 487
static void release_append_queue(void) ;
#line 488 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void release_append_queue(void) 
{ 
  struct append_queue *p ;
  struct append_queue *q ;

  {
#line 493
  p = append_head;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! p) {
#line 493
      goto while_break;
    }
#line 495
    if (p->free) {
      {
#line 496
      free((void *)p->text);
      }
    }
    {
#line 498
    q = p->next;
#line 499
    free((void *)p);
#line 493
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  append_tail = (struct append_queue *)((void *)0);
#line 501
  append_head = append_tail;
#line 502
  return;
}
}
#line 504
static void dump_append_queue(void) ;
#line 505 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void dump_append_queue(void) 
{ 
  struct append_queue *p ;
  char buf[8192] ;
  size_t cnt ;
  FILE *fp ;

  {
  {
#line 510
  output_missing_newline(& output_file);
#line 511
  p = append_head;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! p) {
#line 511
      goto while_break;
    }
#line 513
    if (p->text) {
      {
#line 514
      ck_fwrite((void const   *)p->text, (size_t )1, p->textlen, output_file.fp);
      }
    }
#line 516
    if (p->fname) {
      {
#line 526
      fp = ck_fopen(p->fname, (char const   *)read_mode, 0);
      }
#line 527
      if (fp) {
        {
#line 529
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 529
          cnt = ck_fread((void *)(buf), (size_t )1, sizeof(buf), fp);
          }
#line 529
          if (! (cnt > 0UL)) {
#line 529
            goto while_break___0;
          }
          {
#line 530
          ck_fwrite((void const   *)(buf), (size_t )1, cnt, output_file.fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 531
        ck_fclose(fp);
        }
      }
    }
#line 511
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 536
  flush_output(output_file.fp);
#line 537
  release_append_queue();
  }
#line 538
  return;
}
}
#line 542
static char *get_backup_file_name(char const   *name ) ;
#line 543 "/home/khheo/project/benchmark/sed/sed/execute.c"
static char *get_backup_file_name(char const   *name ) 
{ 
  char *old_asterisk ;
  char *asterisk ;
  char *backup ;
  char *p ;
  int name_length ;
  size_t tmp ;
  int backup_length ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 548
  tmp = strlen(name);
#line 548
  name_length = (int )tmp;
#line 548
  tmp___0 = strlen((char const   *)in_place_extension);
#line 548
  backup_length = (int )tmp___0;
#line 551
  asterisk = in_place_extension - 1;
#line 551
  old_asterisk = asterisk + 1;
  }
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 551
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 551
    if (! asterisk) {
#line 551
      goto while_break;
    }
#line 554
    backup_length += name_length - 1;
#line 551
    old_asterisk = asterisk + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  tmp___1 = xmalloc((size_t )(backup_length + 1));
#line 556
  backup = (char *)tmp___1;
#line 556
  p = backup;
#line 559
  asterisk = in_place_extension - 1;
#line 559
  old_asterisk = asterisk + 1;
  }
  {
#line 559
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 559
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 559
    if (! asterisk) {
#line 559
      goto while_break___0;
    }
    {
#line 563
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)old_asterisk,
           (size_t )(asterisk - old_asterisk));
#line 564
    p += asterisk - old_asterisk;
#line 565
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)name);
#line 566
    p += name_length;
#line 559
    old_asterisk = asterisk + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 570
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)old_asterisk);
  }
#line 571
  return (backup);
}
}
#line 575
static void open_next_file(char const   *name , struct input *input ) ;
#line 576 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void open_next_file(char const   *name , struct input *input ) 
{ 
  char const   *ptr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  int input_fd ;
  char *tmpdir ;
  char *p ;
  char *old_fscreatecon ;
  int reset_fscreatecon ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 581
  buffer.length = (size_t )0;
#line 583
  if ((int const   )*(name + 0) == 45) {
#line 583
    if ((int const   )*(name + 1) == 0) {
#line 583
      if (! in_place_extension) {
        {
#line 585
        clearerr_unlocked(stdin);
#line 589
        input->fp = stdin;
        }
      } else {
#line 583
        goto _L___0;
      }
    } else {
#line 583
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 592
    tmp___2 = ck_fopen(name, (char const   *)read_mode, 0);
#line 592
    input->fp = tmp___2;
    }
#line 592
    if (! tmp___2) {
      {
#line 594
      tmp = __errno_location();
#line 594
      tmp___0 = strerror(*tmp);
#line 594
      ptr = (char const   *)tmp___0;
#line 595
      tmp___1 = gettext("%s: can\'t read %s: %s\n");
#line 595
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              myname, name, ptr);
#line 596
      input->read_fn = & read_always_fail;
#line 597
      (input->bad_count) ++;
      }
#line 598
      return;
    }
  }
#line 601
  input->read_fn = & read_file_line;
#line 603
  if (follow_symlinks) {
    {
#line 604
    input->in_file_name = follow_symlink(name);
    }
  } else {
#line 606
    input->in_file_name = name;
  }
#line 608
  if (in_place_extension) {
    {
#line 613
    reset_fscreatecon = 0;
#line 614
    memset((void *)(& old_fscreatecon), 0, sizeof(old_fscreatecon));
#line 617
    tmpdir = ck_strdup(input->in_file_name);
#line 618
    p = strrchr((char const   *)tmpdir, '/');
    }
#line 618
    if (p) {
#line 619
      *p = (char)0;
    } else {
      {
#line 621
      strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)".");
      }
    }
    {
#line 623
    tmp___4 = fileno(input->fp);
#line 623
    tmp___5 = isatty(tmp___4);
    }
#line 623
    if (tmp___5) {
      {
#line 624
      tmp___3 = gettext("couldn\'t edit %s: is a terminal");
#line 624
      panic((char const   *)tmp___3, input->in_file_name);
      }
    }
    {
#line 626
    input_fd = fileno(input->fp);
#line 627
    fstat(input_fd, & input->st);
    }
#line 628
    if (! ((input->st.st_mode & 61440U) == 32768U)) {
      {
#line 629
      tmp___6 = gettext("couldn\'t edit %s: not a regular file");
#line 629
      panic((char const   *)tmp___6, input->in_file_name);
      }
    }
    {
#line 652
    output_file.fp = ck_mkstemp(& input->out_file_name, (char const   *)tmpdir, "sed",
                                (char const   *)write_mode);
#line 654
    output_file.missing_newline = (_Bool)0;
#line 655
    free((void *)tmpdir);
    }
#line 657
    if (reset_fscreatecon) {
      {
#line 659
      setfscreatecon(old_fscreatecon);
#line 660
      freecon(old_fscreatecon);
      }
    }
#line 663
    if (! output_file.fp) {
      {
#line 664
      tmp___17 = __errno_location();
#line 664
      tmp___18 = strerror(*tmp___17);
#line 664
      tmp___19 = gettext("couldn\'t open temporary file %s: %s");
#line 664
      panic((char const   *)tmp___19, input->out_file_name, tmp___18);
      }
    }
  } else {
#line 668
    if (input->fp) {
#line 668
      if (unbuffered) {
        {
#line 669
        setvbuf((FILE */* __restrict  */)input->fp, (char */* __restrict  */)((void *)0),
                2, (size_t )0);
        }
      }
    }
#line 670
    output_file.fp = stdout;
  }
#line 672
  return;
}
}
#line 676
static void closedown(struct input *input ) ;
#line 677 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void closedown(struct input *input ) 
{ 
  char const   *target_name ;
  int input_fd ;
  int output_fd ;
  int tmp ;
  char *backup_file_name ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 681
  input->read_fn = & read_always_fail;
#line 682
  if (! input->fp) {
#line 683
    return;
  }
#line 685
  if (in_place_extension) {
#line 685
    if ((unsigned long )output_file.fp != (unsigned long )((void *)0)) {
      {
#line 690
      target_name = input->in_file_name;
#line 691
      input_fd = fileno(input->fp);
#line 692
      output_fd = fileno(output_file.fp);
#line 694
      tmp = fchown(output_fd, input->st.st_uid, input->st.st_gid);
      }
#line 694
      if (tmp == -1) {
        {
#line 695
        fchown(output_fd, (__uid_t )-1, input->st.st_gid);
        }
      }
      {
#line 697
      copy_acl(input->in_file_name, input_fd, (char const   *)input->out_file_name,
               output_fd, input->st.st_mode);
#line 701
      ck_fclose(input->fp);
#line 702
      ck_fclose(output_file.fp);
#line 703
      tmp___1 = strcmp((char const   *)in_place_extension, "*");
      }
#line 703
      if (tmp___1 != 0) {
        {
#line 705
        tmp___0 = get_backup_file_name(target_name);
#line 705
        backup_file_name = tmp___0;
#line 706
        ck_rename(target_name, (char const   *)backup_file_name, (char const   *)input->out_file_name);
#line 707
        free((void *)backup_file_name);
        }
      }
      {
#line 710
      ck_rename((char const   *)input->out_file_name, target_name, (char const   *)input->out_file_name);
#line 711
      free((void *)input->out_file_name);
      }
    } else {
      {
#line 714
      ck_fclose(input->fp);
      }
    }
  } else {
    {
#line 714
    ck_fclose(input->fp);
    }
  }
#line 716
  input->fp = (FILE *)((void *)0);
#line 717
  return;
}
}
#line 720
static void reset_addresses(struct vector *vec ) ;
#line 721 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void reset_addresses(struct vector *vec ) 
{ 
  struct sed_cmd *cur_cmd ;
  int n ;
  int tmp ;

  {
#line 728
  cur_cmd = vec->v;
#line 728
  n = (int )vec->v_length;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    tmp = n;
#line 728
    n --;
#line 728
    if (! tmp) {
#line 728
      goto while_break;
    }
#line 729
    if (cur_cmd->a1) {
#line 729
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 729
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 732
          cur_cmd->range_state = (enum addr_state )1;
        } else {
#line 734
          cur_cmd->range_state = (enum addr_state )0;
        }
      } else {
#line 734
        cur_cmd->range_state = (enum addr_state )0;
      }
    } else {
#line 734
      cur_cmd->range_state = (enum addr_state )0;
    }
#line 728
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 739
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                int append ) ;
#line 740 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                int append ) 
{ 
  char **tmp ;
  _Bool tmp___0 ;

  {
#line 746
  if (append_head) {
    {
#line 747
    dump_append_queue();
    }
  }
#line 748
  replaced = (_Bool)0;
#line 749
  if (! append) {
#line 750
    line.length = (size_t )0;
  }
#line 751
  line.chomped = (_Bool)1;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 753
    tmp___0 = (*(input->read_fn))(input);
    }
#line 753
    if (tmp___0) {
#line 753
      goto while_break;
    }
    {
#line 755
    closedown(input);
    }
#line 757
    if (! *(input->file_list)) {
#line 758
      return ((_Bool)0);
    }
#line 760
    if (input->reset_at_next_file) {
      {
#line 762
      input->line_number = (countT )0;
#line 763
      hold.length = (size_t )0;
#line 764
      reset_addresses(the_program___0);
#line 765
      rewind_read_files();
      }
#line 770
      if (in_place_extension) {
#line 771
        output_file.missing_newline = (_Bool)0;
      }
#line 773
      input->reset_at_next_file = separate_files;
    }
    {
#line 776
    tmp = input->file_list;
#line 776
    (input->file_list) ++;
#line 776
    open_next_file((char const   *)*tmp, input);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  (input->line_number) ++;
#line 780
  return ((_Bool)1);
}
}
#line 784
static _Bool last_file_with_data_p(struct input *input ) ;
#line 785 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool last_file_with_data_p(struct input *input ) 
{ 
  int ch ;
  char **tmp ;

  {
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 793
    closedown(input);
    }
#line 794
    if (! *(input->file_list)) {
#line 795
      return ((_Bool)1);
    }
    {
#line 796
    tmp = input->file_list;
#line 796
    (input->file_list) ++;
#line 796
    open_next_file((char const   *)*tmp, input);
    }
#line 797
    if (input->fp) {
      {
#line 799
      ch = getc_unlocked(input->fp);
      }
#line 799
      if (ch != -1) {
        {
#line 801
        ungetc(ch, input->fp);
        }
#line 802
        return ((_Bool)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 809
static _Bool test_eof(struct input *input ) ;
#line 810 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool test_eof(struct input *input ) 
{ 
  int ch ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
#line 816
  if (buffer.length) {
#line 817
    return ((_Bool)0);
  }
#line 818
  if (! input->fp) {
#line 819
    if (separate_files) {
#line 819
      tmp___0 = 1;
    } else {
      {
#line 819
      tmp = last_file_with_data_p(input);
      }
#line 819
      if (tmp) {
#line 819
        tmp___0 = 1;
      } else {
#line 819
        tmp___0 = 0;
      }
    }
#line 819
    return ((_Bool )tmp___0);
  }
  {
#line 820
  tmp___3 = feof_unlocked(input->fp);
  }
#line 820
  if (tmp___3) {
#line 821
    if (separate_files) {
#line 821
      tmp___2 = 1;
    } else {
      {
#line 821
      tmp___1 = last_file_with_data_p(input);
      }
#line 821
      if (tmp___1) {
#line 821
        tmp___2 = 1;
      } else {
#line 821
        tmp___2 = 0;
      }
    }
#line 821
    return ((_Bool )tmp___2);
  }
  {
#line 822
  ch = getc_unlocked(input->fp);
  }
#line 822
  if (ch == -1) {
#line 823
    if (separate_files) {
#line 823
      tmp___5 = 1;
    } else {
      {
#line 823
      tmp___4 = last_file_with_data_p(input);
      }
#line 823
      if (tmp___4) {
#line 823
        tmp___5 = 1;
      } else {
#line 823
        tmp___5 = 0;
      }
    }
#line 823
    return ((_Bool )tmp___5);
  }
  {
#line 824
  ungetc(ch, input->fp);
  }
#line 825
  return ((_Bool)0);
}
}
#line 830
static _Bool match_an_address_p(struct addr *addr , struct input *input ) ;
#line 831 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool match_an_address_p(struct addr *addr , struct input *input ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 838
  if ((unsigned int )addr->addr_type == 0U) {
#line 838
    goto case_0;
  }
#line 841
  if ((unsigned int )addr->addr_type == 1U) {
#line 841
    goto case_1;
  }
#line 844
  if ((unsigned int )addr->addr_type == 3U) {
#line 844
    goto case_3;
  }
#line 849
  if ((unsigned int )addr->addr_type == 5U) {
#line 849
    goto case_5;
  }
#line 849
  if ((unsigned int )addr->addr_type == 4U) {
#line 849
    goto case_5;
  }
#line 855
  if ((unsigned int )addr->addr_type == 6U) {
#line 855
    goto case_6;
  }
#line 860
  goto switch_default;
  case_0: /* CIL Label */ 
#line 839
  return ((_Bool)1);
  case_1: /* CIL Label */ 
  {
#line 842
  tmp = match_regex(addr->addr_regex, line.active, line.length, (size_t )0, (struct re_registers *)((void *)0),
                    0);
  }
#line 842
  return ((_Bool )tmp);
  case_3: /* CIL Label */ 
#line 845
  if (input->line_number >= addr->addr_number) {
#line 845
    if ((input->line_number - addr->addr_number) % addr->addr_step == 0UL) {
#line 845
      tmp___0 = 1;
    } else {
#line 845
      tmp___0 = 0;
    }
  } else {
#line 845
    tmp___0 = 0;
  }
#line 845
  return ((_Bool )tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 853
  return ((_Bool )(addr->addr_number <= input->line_number));
  case_6: /* CIL Label */ 
  {
#line 856
  tmp___1 = test_eof(input);
  }
#line 856
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 861
  panic("INTERNAL ERROR: bad address type");
  }
  switch_break: /* CIL Label */ ;
  }
#line 864
  return ((_Bool)0);
}
}
#line 868
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) ;
#line 869 "/home/khheo/project/benchmark/sed/sed/execute.c"
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 874
  if (! cmd->a1) {
#line 875
    return ((_Bool)1);
  }
#line 877
  if ((unsigned int )cmd->range_state != 1U) {
#line 882
    if ((unsigned int )(cmd->a1)->addr_type == 2U) {
#line 884
      if (! cmd->a2) {
#line 885
        return ((_Bool )(input->line_number == (cmd->a1)->addr_number));
      }
#line 887
      if ((unsigned int )cmd->range_state == 2U) {
#line 889
        return ((_Bool)0);
      } else
#line 887
      if (input->line_number < (cmd->a1)->addr_number) {
#line 889
        return ((_Bool)0);
      }
    } else {
#line 893
      if (! cmd->a2) {
        {
#line 894
        tmp = match_an_address_p(cmd->a1, input);
        }
#line 894
        return (tmp);
      }
      {
#line 896
      tmp___0 = match_an_address_p(cmd->a1, input);
      }
#line 896
      if (! tmp___0) {
#line 897
        return ((_Bool)0);
      }
    }
#line 901
    cmd->range_state = (enum addr_state )1;
    {
#line 904
    if ((unsigned int )(cmd->a2)->addr_type == 1U) {
#line 904
      goto case_1;
    }
#line 907
    if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 907
      goto case_2;
    }
#line 912
    if ((unsigned int )(cmd->a2)->addr_type == 4U) {
#line 912
      goto case_4;
    }
#line 915
    if ((unsigned int )(cmd->a2)->addr_type == 5U) {
#line 915
      goto case_5;
    }
#line 919
    goto switch_default;
    case_1: /* CIL Label */ 
#line 906
    return ((_Bool)1);
    case_2: /* CIL Label */ 
#line 909
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 910
      cmd->range_state = (enum addr_state )2;
    }
#line 911
    return ((_Bool)1);
    case_4: /* CIL Label */ 
#line 913
    (cmd->a2)->addr_number = input->line_number + (cmd->a2)->addr_step;
#line 914
    return ((_Bool)1);
    case_5: /* CIL Label */ 
#line 916
    (cmd->a2)->addr_number = (input->line_number + (cmd->a2)->addr_step) - input->line_number % (cmd->a2)->addr_step;
#line 918
    return ((_Bool)1);
    switch_default: /* CIL Label */ 
#line 920
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 927
  if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 933
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 934
      cmd->range_state = (enum addr_state )2;
    }
#line 936
    return ((_Bool )(input->line_number <= (cmd->a2)->addr_number));
  }
  {
#line 940
  tmp___1 = match_an_address_p(cmd->a2, input);
  }
#line 940
  if (tmp___1) {
#line 941
    cmd->range_state = (enum addr_state )2;
  }
#line 943
  return ((_Bool)1);
}
}
#line 947
static void do_list(int line_len ) ;
#line 948 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void do_list(int line_len ) 
{ 
  unsigned char *p ;
  countT len ;
  countT width ;
  char obuf[180] ;
  char *o ;
  size_t olen ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  countT tmp___11 ;

  {
  {
#line 952
  p = (unsigned char *)line.active;
#line 953
  len = line.length;
#line 954
  width = (countT )0;
#line 958
  fp = output_file.fp;
#line 960
  output_missing_newline(& output_file);
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    tmp___11 = len;
#line 961
    len --;
#line 961
    if (! tmp___11) {
#line 961
      goto while_break;
    }
#line 962
    o = obuf;
#line 968
    if (((int )*p & -128) == 0) {
      {
#line 968
      tmp___10 = __ctype_b_loc();
      }
#line 968
      if ((int const   )*(*tmp___10 + (int )*p) & 16384) {
#line 972
        tmp = o;
#line 972
        o ++;
#line 972
        *tmp = (char )*p;
#line 973
        if ((int )*p == 92) {
#line 974
          tmp___0 = o;
#line 974
          o ++;
#line 974
          *tmp___0 = (char )'\\';
        }
      } else {
#line 968
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 976
      tmp___1 = o;
#line 976
      o ++;
#line 976
      *tmp___1 = (char )'\\';
      {
#line 979
      if ((int )*p == 7) {
#line 979
        goto case_7;
      }
#line 983
      if ((int )*p == 8) {
#line 983
        goto case_8;
      }
#line 984
      if ((int )*p == 12) {
#line 984
        goto case_12;
      }
#line 985
      if ((int )*p == 10) {
#line 985
        goto case_10;
      }
#line 986
      if ((int )*p == 13) {
#line 986
        goto case_13;
      }
#line 987
      if ((int )*p == 9) {
#line 987
        goto case_9;
      }
#line 988
      if ((int )*p == 11) {
#line 988
        goto case_11;
      }
#line 989
      goto switch_default;
      case_7: /* CIL Label */ 
#line 979
      tmp___2 = o;
#line 979
      o ++;
#line 979
      *tmp___2 = (char )'a';
#line 979
      goto switch_break;
      case_8: /* CIL Label */ 
#line 983
      tmp___3 = o;
#line 983
      o ++;
#line 983
      *tmp___3 = (char )'b';
#line 983
      goto switch_break;
      case_12: /* CIL Label */ 
#line 984
      tmp___4 = o;
#line 984
      o ++;
#line 984
      *tmp___4 = (char )'f';
#line 984
      goto switch_break;
      case_10: /* CIL Label */ 
#line 985
      tmp___5 = o;
#line 985
      o ++;
#line 985
      *tmp___5 = (char )'n';
#line 985
      goto switch_break;
      case_13: /* CIL Label */ 
#line 986
      tmp___6 = o;
#line 986
      o ++;
#line 986
      *tmp___6 = (char )'r';
#line 986
      goto switch_break;
      case_9: /* CIL Label */ 
#line 987
      tmp___7 = o;
#line 987
      o ++;
#line 987
      *tmp___7 = (char )'t';
#line 987
      goto switch_break;
      case_11: /* CIL Label */ 
#line 988
      tmp___8 = o;
#line 988
      o ++;
#line 988
      *tmp___8 = (char )'v';
#line 988
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 990
      sprintf((char */* __restrict  */)o, (char const   */* __restrict  */)"%03o",
              (int )*p);
#line 991
      tmp___9 = strlen((char const   *)o);
#line 991
      o += tmp___9;
      }
#line 992
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 995
    olen = (size_t )(o - obuf);
#line 996
    if (width + olen >= (countT )line_len) {
#line 996
      if (line_len > 0) {
        {
#line 997
        ck_fwrite((void const   *)"\\\n", (size_t )1, (size_t )2, fp);
#line 998
        width = (countT )0;
        }
      }
    }
    {
#line 1000
    ck_fwrite((void const   *)(obuf), (size_t )1, olen, fp);
#line 1001
    width += olen;
#line 961
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1003
  ck_fwrite((void const   *)"$\n", (size_t )1, (size_t )2, fp);
#line 1004
  flush_output(fp);
  }
#line 1005
  return;
}
}
#line 1008 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void append_replacement(struct line *buf , struct replacement *p , struct re_registers *regs___0 ) 
{ 
  enum replacement_types repl_mod ;
  int i ;
  enum replacement_types curr_type ;

  {
#line 1011
  repl_mod = (enum replacement_types )0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    if (! p) {
#line 1013
      goto while_break;
    }
#line 1015
    i = p->subst_id;
#line 1021
    if ((unsigned int )p->repl_type & 12U) {
#line 1021
      curr_type = p->repl_type;
    } else {
#line 1021
      curr_type = (enum replacement_types )((unsigned int )p->repl_type | (unsigned int )repl_mod);
    }
#line 1025
    repl_mod = (enum replacement_types )0;
#line 1026
    if (p->prefix_length) {
      {
#line 1028
      str_append_modified(buf, (char const   *)p->prefix, p->prefix_length, curr_type);
#line 1030
      curr_type = (enum replacement_types )((unsigned int )curr_type & 4294967283U);
      }
    }
#line 1033
    if (0 <= i) {
#line 1035
      if (*(regs___0->end + i) == *(regs___0->start + i)) {
#line 1035
        if ((unsigned int )p->repl_type & 12U) {
#line 1039
          repl_mod = (enum replacement_types )((unsigned int )curr_type & 12U);
        } else {
#line 1035
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1041
      if (*(regs___0->end + i) != *(regs___0->start + i)) {
        {
#line 1042
        str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                            (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                            curr_type);
        }
      }
    }
#line 1013
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  return;
}
}
#line 1049
static void do_subst(struct subst *sub ) ;
#line 1059 "/home/khheo/project/benchmark/sed/sed/execute.c"
static struct re_registers regs  ;
#line 1050 "/home/khheo/project/benchmark/sed/sed/execute.c"
static void do_subst(struct subst *sub ) 
{ 
  size_t start ;
  size_t last_end ;
  countT count ;
  _Bool again ;
  int tmp ;
  size_t offset ;
  size_t matched ;
  int tmp___0 ;
  FILE *pipe_fp ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1054
  start = (size_t )0;
#line 1055
  last_end = (size_t )0;
#line 1056
  count = (countT )0;
#line 1057
  again = (_Bool)1;
#line 1061
  line_reset(& s_accum, & line);
#line 1065
  tmp = match_regex(sub->regx, line.active, line.length, start, & regs, (int )(sub->max_id + 1U));
  }
#line 1065
  if (! tmp) {
#line 1067
    return;
  }
#line 1069
  if (! sub->replacement) {
#line 1069
    if (sub->numb <= 1UL) {
#line 1071
      if (*(regs.start + 0) == 0) {
#line 1071
        if (! sub->global) {
#line 1074
          replaced = (_Bool)1;
#line 1076
          line.active += *(regs.end + 0);
#line 1077
          line.length -= (size_t )*(regs.end + 0);
#line 1078
          line.alloc -= (size_t )*(regs.end + 0);
#line 1079
          goto post_subst;
        } else {
#line 1071
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1081
      if ((size_t )*(regs.end + 0) == line.length) {
#line 1084
        replaced = (_Bool)1;
#line 1086
        line.length = (size_t )*(regs.start + 0);
#line 1087
        goto post_subst;
      }
    }
  }
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    offset = (size_t )*(regs.start + 0);
#line 1094
    matched = (size_t )(*(regs.end + 0) - *(regs.start + 0));
#line 1097
    if (start < offset) {
      {
#line 1098
      str_append(& s_accum, (char const   *)(line.active + start), offset - start);
      }
    }
#line 1109
    if (matched > 0UL) {
#line 1109
      goto _L___1;
    } else
#line 1109
    if (count == 0UL) {
#line 1109
      goto _L___1;
    } else
#line 1109
    if (offset > last_end) {
      _L___1: /* CIL Label */ 
#line 1109
      count ++;
#line 1109
      if (count >= sub->numb) {
        {
#line 1113
        replaced = (_Bool)1;
#line 1116
        append_replacement(& s_accum, sub->replacement, & regs);
#line 1117
        again = (_Bool )sub->global;
        }
      } else {
#line 1109
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1124
      if (matched == 0UL) {
#line 1126
        if (start < line.length) {
#line 1127
          matched = (size_t )1;
        } else {
#line 1129
          goto while_break;
        }
      }
      {
#line 1132
      str_append(& s_accum, (char const   *)(line.active + offset), matched);
      }
    }
#line 1138
    start = offset + matched;
#line 1139
    last_end = (size_t )*(regs.end + 0);
#line 1091
    if (again) {
#line 1091
      if (start <= line.length) {
        {
#line 1091
        tmp___0 = match_regex(sub->regx, line.active, line.length, start, & regs,
                              (int )(sub->max_id + 1U));
        }
#line 1091
        if (! tmp___0) {
#line 1091
          goto while_break;
        }
      } else {
#line 1091
        goto while_break;
      }
    } else {
#line 1091
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1147
  if (start < line.length) {
    {
#line 1148
    str_append(& s_accum, (char const   *)(line.active + start), line.length - start);
    }
  }
  {
#line 1149
  s_accum.chomped = line.chomped;
#line 1153
  line_exchange(& line, & s_accum, 0);
  }
#line 1156
  if (count < sub->numb) {
#line 1157
    return;
  }
  post_subst: 
#line 1160
  if (sub->print & 1U) {
    {
#line 1161
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1163
  if (sub->eval) {
    {
#line 1167
    line_reset(& s_accum, (struct line *)((void *)0));
#line 1169
    str_append(& line, "", (size_t )1);
#line 1170
    pipe_fp = popen((char const   *)line.active, "r");
    }
#line 1172
    if ((unsigned long )pipe_fp != (unsigned long )((void *)0)) {
      {
#line 1174
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1174
        tmp___2 = feof_unlocked(pipe_fp);
        }
#line 1174
        if (tmp___2) {
#line 1174
          goto while_break___0;
        }
        {
#line 1177
        tmp___1 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ), (size_t )4096,
                                 (FILE */* __restrict  */)pipe_fp);
#line 1177
        n = (int )tmp___1;
        }
#line 1178
        if (n > 0) {
          {
#line 1179
          str_append(& s_accum, (char const   *)(buf), (size_t )n);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1182
      pclose(pipe_fp);
#line 1187
      line_exchange(& line, & s_accum, 1);
      }
#line 1188
      if (line.length) {
#line 1188
        if ((int )*(line.active + (line.length - 1UL)) == (int )buffer_delimiter) {
#line 1190
          (line.length) --;
        }
      }
    } else {
      {
#line 1193
      tmp___3 = gettext("error in subprocess");
#line 1193
      panic((char const   *)tmp___3);
      }
    }
  }
#line 1199
  if (sub->print & 2U) {
    {
#line 1200
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1201
  if (sub->outf) {
    {
#line 1202
    output_line((char const   *)line.active, line.length, (int )line.chomped, sub->outf);
    }
  }
#line 1203
  return;
}
}
#line 1260
static int execute_program(struct vector *vec , struct input *input ) ;
#line 1261 "/home/khheo/project/benchmark/sed/sed/execute.c"
static int execute_program(struct vector *vec , struct input *input ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct sed_cmd *end_cmd ;
  struct append_queue *aq ;
  struct append_queue *tmp ;
  char *p ;
  void *tmp___0 ;
  FILE *pipe_fp ;
  int cmd_length ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  countT tmp___4 ;
  countT tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  char *p___0 ;
  void *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  struct append_queue *aq___0 ;
  struct append_queue *tmp___14 ;
  struct append_queue *aq___1 ;
  size_t buflen ;
  char *text ;
  int result ;
  size_t tmp___15 ;
  int tmp___16 ;
  char *p___1 ;
  void *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int idx ;
  int prev_idx ;
  char **trans ;
  mbstate_t mbstate ;
  int mbclen ;
  int i ;
  size_t tmp___20 ;
  _Bool move_remain_buffer ;
  int trans_len ;
  size_t tmp___21 ;
  int new_len ;
  int move_len ;
  int move_offset ;
  char *move_from ;
  char *move_to ;
  int tmp___22 ;
  unsigned char *p___2 ;
  unsigned char *e ;
  _Bool tmp___23 ;

  {
#line 1269
  cur_cmd = vec->v;
#line 1270
  end_cmd = vec->v + vec->v_length;
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1271
    if (! ((unsigned long )cur_cmd < (unsigned long )end_cmd)) {
#line 1271
      goto while_break;
    }
    {
#line 1273
    tmp___23 = match_address_p(cur_cmd, input);
    }
#line 1273
    if ((int )tmp___23 != (int )cur_cmd->addr_bang) {
      {
#line 1277
      if ((int )cur_cmd->cmd == 97) {
#line 1277
        goto case_97;
      }
#line 1286
      if ((int )cur_cmd->cmd == 98) {
#line 1286
        goto case_98;
      }
#line 1286
      if ((int )cur_cmd->cmd == 123) {
#line 1286
        goto case_98;
      }
#line 1292
      if ((int )cur_cmd->cmd == 58) {
#line 1292
        goto case_58;
      }
#line 1292
      if ((int )cur_cmd->cmd == 35) {
#line 1292
        goto case_58;
      }
#line 1292
      if ((int )cur_cmd->cmd == 125) {
#line 1292
        goto case_58;
      }
#line 1296
      if ((int )cur_cmd->cmd == 99) {
#line 1296
        goto case_99;
      }
#line 1304
      if ((int )cur_cmd->cmd == 100) {
#line 1304
        goto case_100;
      }
#line 1307
      if ((int )cur_cmd->cmd == 68) {
#line 1307
        goto case_68;
      }
#line 1323
      if ((int )cur_cmd->cmd == 101) {
#line 1323
        goto case_101;
      }
#line 1380
      if ((int )cur_cmd->cmd == 103) {
#line 1380
        goto case_103;
      }
#line 1391
      if ((int )cur_cmd->cmd == 71) {
#line 1391
        goto case_71;
      }
#line 1400
      if ((int )cur_cmd->cmd == 104) {
#line 1400
        goto case_104;
      }
#line 1405
      if ((int )cur_cmd->cmd == 72) {
#line 1405
        goto case_72;
      }
#line 1410
      if ((int )cur_cmd->cmd == 105) {
#line 1410
        goto case_105;
      }
#line 1416
      if ((int )cur_cmd->cmd == 108) {
#line 1416
        goto case_108;
      }
#line 1422
      if ((int )cur_cmd->cmd == 76) {
#line 1422
        goto case_76;
      }
#line 1432
      if ((int )cur_cmd->cmd == 110) {
#line 1432
        goto case_110;
      }
#line 1439
      if ((int )cur_cmd->cmd == 78) {
#line 1439
        goto case_78;
      }
#line 1452
      if ((int )cur_cmd->cmd == 112) {
#line 1452
        goto case_112;
      }
#line 1456
      if ((int )cur_cmd->cmd == 80) {
#line 1456
        goto case_80;
      }
#line 1464
      if ((int )cur_cmd->cmd == 113) {
#line 1464
        goto case_113;
      }
#line 1469
      if ((int )cur_cmd->cmd == 81) {
#line 1469
        goto case_81;
      }
#line 1472
      if ((int )cur_cmd->cmd == 114) {
#line 1472
        goto case_114;
      }
#line 1480
      if ((int )cur_cmd->cmd == 82) {
#line 1480
        goto case_82;
      }
#line 1500
      if ((int )cur_cmd->cmd == 115) {
#line 1500
        goto case_115;
      }
#line 1504
      if ((int )cur_cmd->cmd == 116) {
#line 1504
        goto case_116;
      }
#line 1513
      if ((int )cur_cmd->cmd == 84) {
#line 1513
        goto case_84;
      }
#line 1523
      if ((int )cur_cmd->cmd == 119) {
#line 1523
        goto case_119;
      }
#line 1529
      if ((int )cur_cmd->cmd == 87) {
#line 1529
        goto case_87;
      }
#line 1538
      if ((int )cur_cmd->cmd == 120) {
#line 1538
        goto case_120;
      }
#line 1543
      if ((int )cur_cmd->cmd == 121) {
#line 1543
        goto case_121;
      }
#line 1621
      if ((int )cur_cmd->cmd == 122) {
#line 1621
        goto case_122;
      }
#line 1625
      if ((int )cur_cmd->cmd == 61) {
#line 1625
        goto case_61;
      }
#line 1632
      if ((int )cur_cmd->cmd == 70) {
#line 1632
        goto case_70;
      }
#line 1639
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 1279
      tmp = next_append_slot();
#line 1279
      aq = tmp;
#line 1280
      aq->text = cur_cmd->x.cmd_txt.text;
#line 1281
      aq->textlen = cur_cmd->x.cmd_txt.text_length;
      }
#line 1283
      goto switch_break;
      case_98: /* CIL Label */ 
      case_123: /* CIL Label */ 
#line 1287
      cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1288
      goto while_continue;
      case_58: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_125: /* CIL Label */ 
#line 1294
      goto switch_break;
      case_99: /* CIL Label */ 
#line 1297
      if ((unsigned int )cur_cmd->range_state != 1U) {
        {
#line 1298
        output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                    1, & output_file);
        }
      }
      case_100: /* CIL Label */ 
#line 1305
      return (-1);
      case_68: /* CIL Label */ 
      {
#line 1309
      tmp___0 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1309
      p = (char *)tmp___0;
      }
#line 1310
      if (! p) {
#line 1311
        return (-1);
      }
#line 1313
      p ++;
#line 1314
      line.alloc -= (size_t )(p - line.active);
#line 1315
      line.length -= (size_t )(p - line.active);
#line 1316
      line.active += p - line.active;
#line 1319
      cur_cmd = vec->v;
#line 1320
      goto while_continue;
      case_101: /* CIL Label */ 
      {
#line 1326
      cmd_length = (int )cur_cmd->x.cmd_txt.text_length;
#line 1327
      line_reset(& s_accum, (struct line *)((void *)0));
      }
#line 1329
      if (! cmd_length) {
        {
#line 1331
        str_append(& line, "", (size_t )1);
#line 1332
        pipe_fp = popen((char const   *)line.active, "r");
        }
      } else {
        {
#line 1336
        *(cur_cmd->x.cmd_txt.text + (cmd_length - 1)) = (char)0;
#line 1337
        pipe_fp = popen((char const   *)cur_cmd->x.cmd_txt.text, "r");
#line 1338
        output_missing_newline(& output_file);
        }
      }
#line 1341
      if ((unsigned long )pipe_fp != (unsigned long )((void *)0)) {
        {
#line 1345
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1345
          tmp___2 = feof_unlocked(pipe_fp);
          }
#line 1345
          if (tmp___2) {
#line 1345
            goto while_break___0;
          }
          {
#line 1346
          tmp___1 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ),
                                   (size_t )4096, (FILE */* __restrict  */)pipe_fp);
#line 1346
          n = (int )tmp___1;
          }
#line 1346
          if (n > 0) {
#line 1348
            if (! cmd_length) {
              {
#line 1349
              str_append(& s_accum, (char const   *)(buf), (size_t )n);
              }
            } else {
              {
#line 1351
              ck_fwrite((void const   *)(buf), (size_t )1, (size_t )n, output_file.fp);
              }
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1354
        pclose(pipe_fp);
        }
#line 1355
        if (! cmd_length) {
#line 1358
          if (s_accum.length) {
#line 1358
            if ((int )*(s_accum.active + (s_accum.length - 1UL)) == (int )buffer_delimiter) {
#line 1360
              (s_accum.length) --;
            }
          }
          {
#line 1366
          line_exchange(& line, & s_accum, 1);
          }
        } else {
          {
#line 1369
          flush_output(output_file.fp);
          }
        }
      } else {
        {
#line 1373
        tmp___3 = gettext("error in subprocess");
#line 1373
        panic((char const   *)tmp___3);
        }
      }
#line 1377
      goto switch_break;
      case_103: /* CIL Label */ 
      {
#line 1388
      line_copy(& hold, & line, 1);
      }
#line 1389
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 1397
      line_append(& hold, & line, 1);
      }
#line 1398
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 1402
      line_copy(& line, & hold, 1);
      }
#line 1403
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 1407
      line_append(& line, & hold, 1);
      }
#line 1408
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 1411
      output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                  1, & output_file);
      }
#line 1414
      goto switch_break;
      case_108: /* CIL Label */ 
#line 1417
      if (cur_cmd->x.int_arg == -1) {
#line 1417
        tmp___4 = lcmd_out_line_len;
      } else {
#line 1417
        tmp___4 = (countT )cur_cmd->x.int_arg;
      }
      {
#line 1417
      do_list((int )tmp___4);
      }
#line 1420
      goto switch_break;
      case_76: /* CIL Label */ 
      {
#line 1423
      output_missing_newline(& output_file);
      }
#line 1424
      if (cur_cmd->x.int_arg == -1) {
#line 1424
        tmp___5 = lcmd_out_line_len;
      } else {
#line 1424
        tmp___5 = (countT )cur_cmd->x.int_arg;
      }
      {
#line 1424
      fmt((char const   *)line.active, (char const   *)(line.active + line.length),
          (int )tmp___5, output_file.fp);
#line 1429
      flush_output(output_file.fp);
      }
#line 1430
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1433
      if (! no_default_output) {
        {
#line 1434
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1435
      tmp___6 = test_eof(input);
      }
#line 1435
      if (tmp___6) {
#line 1436
        return (-1);
      } else {
        {
#line 1435
        tmp___7 = read_pattern_space(input, vec, 0);
        }
#line 1435
        if (! tmp___7) {
#line 1436
          return (-1);
        }
      }
#line 1437
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 1440
      str_append(& line, (char const   *)(& buffer_delimiter), (size_t )1);
#line 1442
      tmp___8 = test_eof(input);
      }
#line 1442
      if (tmp___8) {
#line 1442
        goto _L;
      } else {
        {
#line 1442
        tmp___9 = read_pattern_space(input, vec, 1);
        }
#line 1442
        if (! tmp___9) {
          _L: /* CIL Label */ 
#line 1444
          (line.length) --;
#line 1445
          if ((unsigned int )posixicity == 0U) {
#line 1445
            if (! no_default_output) {
              {
#line 1446
              output_line((char const   *)line.active, line.length, (int )line.chomped,
                          & output_file);
              }
            }
          }
#line 1448
          return (-1);
        }
      }
#line 1450
      goto switch_break;
      case_112: /* CIL Label */ 
      {
#line 1453
      output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
      }
#line 1454
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1458
      tmp___10 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1458
      p___0 = (char *)tmp___10;
      }
#line 1459
      if (p___0) {
#line 1459
        tmp___11 = 1;
      } else {
#line 1459
        tmp___11 = (int )line.chomped;
      }
#line 1459
      if (p___0) {
#line 1459
        tmp___12 = (size_t )(p___0 - line.active);
      } else {
#line 1459
        tmp___12 = line.length;
      }
      {
#line 1459
      output_line((char const   *)line.active, tmp___12, tmp___11, & output_file);
      }
#line 1462
      goto switch_break;
      case_113: /* CIL Label */ 
#line 1465
      if (! no_default_output) {
        {
#line 1466
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1467
      dump_append_queue();
      }
      case_81: /* CIL Label */ 
#line 1470
      if (cur_cmd->x.int_arg == -1) {
#line 1470
        tmp___13 = 0;
      } else {
#line 1470
        tmp___13 = cur_cmd->x.int_arg;
      }
#line 1470
      return (tmp___13);
      case_114: /* CIL Label */ 
#line 1473
      if (cur_cmd->x.fname) {
        {
#line 1475
        tmp___14 = next_append_slot();
#line 1475
        aq___0 = tmp___14;
#line 1476
        aq___0->fname = (char const   *)cur_cmd->x.fname;
        }
      }
#line 1478
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1481
      if (cur_cmd->x.fp) {
        {
#line 1481
        tmp___16 = feof_unlocked(cur_cmd->x.fp);
        }
#line 1481
        if (! tmp___16) {
          {
#line 1485
          text = (char *)((void *)0);
#line 1488
          tmp___15 = ck_getdelim(& text, & buflen, buffer_delimiter, cur_cmd->x.fp);
#line 1488
          result = (int )tmp___15;
          }
#line 1490
          if (result != -1) {
            {
#line 1492
            aq___1 = next_append_slot();
#line 1493
            aq___1->free = (_Bool)1;
#line 1494
            aq___1->text = text;
#line 1495
            aq___1->textlen = (size_t )result;
            }
          }
        }
      }
#line 1498
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 1501
      do_subst(cur_cmd->x.cmd_subst);
      }
#line 1502
      goto switch_break;
      case_116: /* CIL Label */ 
#line 1505
      if (replaced) {
#line 1507
        replaced = (_Bool)0;
#line 1508
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1509
        goto while_continue;
      }
#line 1511
      goto switch_break;
      case_84: /* CIL Label */ 
#line 1514
      if (! replaced) {
#line 1516
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1517
        goto while_continue;
      } else {
#line 1520
        replaced = (_Bool)0;
      }
#line 1521
      goto switch_break;
      case_119: /* CIL Label */ 
#line 1524
      if (cur_cmd->x.fp) {
        {
#line 1525
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    cur_cmd->x.outf);
        }
      }
#line 1527
      goto switch_break;
      case_87: /* CIL Label */ 
#line 1530
      if (cur_cmd->x.fp) {
        {
#line 1532
        tmp___17 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1532
        p___1 = (char *)tmp___17;
        }
#line 1533
        if (p___1) {
#line 1533
          tmp___18 = 1;
        } else {
#line 1533
          tmp___18 = (int )line.chomped;
        }
#line 1533
        if (p___1) {
#line 1533
          tmp___19 = (size_t )(p___1 - line.active);
        } else {
#line 1533
          tmp___19 = line.length;
        }
        {
#line 1533
        output_line((char const   *)line.active, tmp___19, tmp___18, cur_cmd->x.outf);
        }
      }
#line 1536
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 1540
      line_exchange(& line, & hold, 0);
      }
#line 1541
      goto switch_break;
      case_121: /* CIL Label */ 
#line 1545
      if (mb_cur_max > 1) {
        {
#line 1550
        memset((void *)(& mbstate), 0, sizeof(mbstate_t ));
#line 1551
        idx = 0;
        }
        {
#line 1551
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1551
          if (! ((size_t )idx < line.length)) {
#line 1551
            goto while_break___1;
          }
#line 1554
          if (mb_cur_max == 1) {
#line 1554
            mbclen = 1;
          } else {
            {
#line 1554
            tmp___20 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)(line.active + idx),
                               line.length - (size_t )idx, (mbstate_t */* __restrict  */)(& mbstate));
#line 1554
            mbclen = (int )tmp___20;
            }
          }
#line 1559
          if ((size_t )mbclen == 0xffffffffffffffffUL) {
#line 1561
            mbclen = 1;
          } else
#line 1559
          if ((size_t )mbclen == 0xfffffffffffffffeUL) {
#line 1561
            mbclen = 1;
          } else
#line 1559
          if (mbclen == 0) {
#line 1561
            mbclen = 1;
          }
#line 1563
          trans = cur_cmd->x.translatemb;
#line 1565
          i = 0;
          {
#line 1565
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1565
            if (! ((unsigned long )*(trans + 2 * i) != (unsigned long )((void *)0))) {
#line 1565
              goto while_break___2;
            }
            {
#line 1567
            tmp___22 = strncmp((char const   *)(line.active + idx), (char const   *)*(trans + 2 * i),
                               (size_t )mbclen);
            }
#line 1567
            if (tmp___22 == 0) {
              {
#line 1569
              move_remain_buffer = (_Bool)0;
#line 1570
              tmp___21 = strlen((char const   *)*(trans + (2 * i + 1)));
#line 1570
              trans_len = (int )tmp___21;
              }
#line 1572
              if (mbclen < trans_len) {
#line 1575
                new_len = (int )(((line.length + 1UL) + (size_t )trans_len) - (size_t )mbclen);
#line 1577
                if (line.alloc < (size_t )new_len) {
                  {
#line 1580
                  resize_line(& line, (size_t )new_len);
                  }
                }
#line 1582
                move_remain_buffer = (_Bool)1;
              } else
#line 1584
              if (mbclen > trans_len) {
#line 1587
                move_remain_buffer = (_Bool)1;
              }
#line 1589
              prev_idx = idx;
#line 1590
              if (move_remain_buffer) {
                {
#line 1595
                move_from = (line.active + idx) + mbclen;
#line 1596
                move_to = (line.active + idx) + trans_len;
#line 1597
                move_len = (int )(((line.length + 1UL) - (size_t )idx) - (size_t )mbclen);
#line 1598
                move_offset = trans_len - mbclen;
#line 1599
                memmove((void *)move_to, (void const   *)move_from, (size_t )move_len);
#line 1600
                line.length += (size_t )move_offset;
#line 1601
                idx += move_offset;
                }
              }
              {
#line 1603
              strncpy((char */* __restrict  */)(line.active + prev_idx), (char const   */* __restrict  */)*(trans + (2 * i + 1)),
                      (size_t )trans_len);
              }
#line 1605
              goto while_break___2;
            }
#line 1565
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1608
          idx += mbclen;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 1614
        p___2 = (unsigned char *)line.active;
#line 1615
        e = p___2 + line.length;
        {
#line 1615
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1615
          if (! ((unsigned long )p___2 < (unsigned long )e)) {
#line 1615
            goto while_break___3;
          }
#line 1616
          *p___2 = *(cur_cmd->x.translate + *p___2);
#line 1615
          p___2 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1619
      goto switch_break;
      case_122: /* CIL Label */ 
#line 1622
      line.length = (size_t )0;
#line 1623
      goto switch_break;
      case_61: /* CIL Label */ 
      {
#line 1626
      output_missing_newline(& output_file);
#line 1627
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%lu\n",
              input->line_number);
#line 1629
      flush_output(output_file.fp);
      }
#line 1630
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 1633
      output_missing_newline(& output_file);
#line 1634
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%s\n",
              input->in_file_name);
#line 1636
      flush_output(output_file.fp);
      }
#line 1637
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1640
      panic("INTERNAL ERROR: Bad cmd %c", (int )cur_cmd->cmd);
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1693
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1696
  if (! no_default_output) {
    {
#line 1697
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1698
  return (-1);
}
}
#line 1709 "/home/khheo/project/benchmark/sed/sed/execute.c"
static char dash[2]  = {      (char )'-',      (char )'\000'};
#line 1710 "/home/khheo/project/benchmark/sed/sed/execute.c"
static char *stdin_argv[2]  = {      dash,      (char *)((void *)0)};
#line 1704 "/home/khheo/project/benchmark/sed/sed/execute.c"
int process_files(struct vector *the_program___0 , char **argv ) 
{ 
  struct input input ;
  int status ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1714
  line_init(& line, (struct line *)((void *)0), (size_t )50);
#line 1715
  line_init(& hold, (struct line *)((void *)0), (size_t )0);
#line 1716
  line_init(& buffer, (struct line *)((void *)0), (size_t )0);
#line 1721
  input.reset_at_next_file = (_Bool)1;
  }
#line 1722
  if (argv) {
#line 1722
    if (*argv) {
#line 1723
      input.file_list = argv;
    } else {
#line 1722
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1724
  if (in_place_extension) {
    {
#line 1725
    tmp = gettext("no input files");
#line 1725
    panic((char const   *)tmp);
    }
  } else {
#line 1727
    input.file_list = stdin_argv;
  }
#line 1729
  input.bad_count = (countT )0;
#line 1730
  input.line_number = (countT )0;
#line 1731
  input.read_fn = & read_always_fail;
#line 1732
  input.fp = (FILE *)((void *)0);
#line 1734
  status = 0;
  {
#line 1735
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1735
    tmp___0 = read_pattern_space(& input, the_program___0, 0);
    }
#line 1735
    if (! tmp___0) {
#line 1735
      goto while_break;
    }
    {
#line 1737
    status = execute_program(the_program___0, & input);
    }
#line 1738
    if (status == -1) {
#line 1739
      status = 0;
    } else {
#line 1741
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1743
  closedown(& input);
  }
#line 1758
  if (input.bad_count) {
#line 1759
    status = 2;
  }
#line 1761
  return (status);
}
}
#line 689 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 466 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 186 "/home/khheo/project/benchmark/sed/sed/sed.h"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) ;
#line 187
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) ;
#line 188
void check_final_program(struct vector *program ) ;
#line 190
void finish_program(struct vector *program ) ;
#line 125 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 180 "../lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 81 "/home/khheo/project/benchmark/sed/sed/compile.c"
FILE *my_stdin  ;
#line 81 "/home/khheo/project/benchmark/sed/sed/compile.c"
FILE *my_stdout  ;
#line 81 "/home/khheo/project/benchmark/sed/sed/compile.c"
FILE *my_stderr  ;
#line 82 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct special_files special_files[4]  = {      {{(char *)"/dev/stdin", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdin}, 
        {{(char *)"/dev/stdout", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdout}, 
        {{(char *)"/dev/stderr", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stderr}, 
        {{(char *)((void *)0), (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      (FILE **)((void *)0)}};
#line 91 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct prog_info prog  ;
#line 92 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct error_info cur_input  ;
#line 96 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_label *jumps  =    (struct sed_label *)((void *)0);
#line 97 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_label *labels  =    (struct sed_label *)((void *)0);
#line 101 "/home/khheo/project/benchmark/sed/sed/compile.c"
static _Bool first_script  =    (_Bool)1;
#line 104 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct buffer *pending_text  =    (struct buffer *)((void *)0);
#line 105 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct text_buf *old_text_buf  =    (struct text_buf *)((void *)0);
#line 109 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_label *blocks  =    (struct sed_label *)((void *)0);
#line 112 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct obstack obs  ;
#line 115 "/home/khheo/project/benchmark/sed/sed/compile.c"
static char const   errors___0[762]  = 
#line 115
  {      (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'!',      (char const   )'\'', 
        (char const   )'s',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )',',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'+',      (char const   )'N', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'~',      (char const   )'N',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'`',      (char const   )'{', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'a',      (char const   )'\'', 
        (char const   )',',      (char const   )' ',      (char const   )'`',      (char const   )'c', 
        (char const   )'\'',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'i',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'e', 
        (char const   )'s',      (char const   )'n',      (char const   )'\'',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'\000', 
        (char const   )':',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'e',      (char const   )'s',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'n',      (char const   )'\'',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'c',      (char const   )'c',      (char const   )'e', 
        (char const   )'p',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'m',      (char const   )'i',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'`', 
        (char const   )'s',      (char const   )'\'',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'`',      (char const   )'y',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'p',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'g',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'`',      (char const   )'s',      (char const   )'\'', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'\000',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'`',      (char const   )'y', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'\000', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'i', 
        (char const   )'m',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'l',      (char const   )'e',      (char const   )'-', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000',      (char const   )'e', 
        (char const   )'x',      (char const   )'p',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'0', 
        (char const   )'\000',      (char const   )'u',      (char const   )'n',      (char const   )'k', 
        (char const   )'n',      (char const   )'o',      (char const   )'w',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )':',      (char const   )' ',      (char const   )'`',      (char const   )'%', 
        (char const   )'c',      (char const   )'\'',      (char const   )'\000',      (char const   )'i', 
        (char const   )'n',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000'};
#line 171 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct output *file_read  =    (struct output *)((void *)0);
#line 172 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct output *file_write  =    (struct output *)((void *)0);
#line 176 "/home/khheo/project/benchmark/sed/sed/compile.c"
void bad_command(char ch ) 
{ 
  char const   *msg ;
  char *tmp ;
  char *unknown_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 180
  tmp = gettext((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0"));
#line 180
  msg = (char const   *)tmp;
#line 181
  tmp___0 = strlen(msg);
#line 181
  tmp___1 = xmalloc(tmp___0);
#line 181
  unknown_cmd = (char *)tmp___1;
#line 182
  sprintf((char */* __restrict  */)unknown_cmd, (char const   */* __restrict  */)msg,
          (int )ch);
#line 183
  bad_prog((char const   *)unknown_cmd);
  }
#line 184
  return;
}
}
#line 187 "/home/khheo/project/benchmark/sed/sed/compile.c"
void bad_prog(char const   *why ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 191
  if (cur_input.name) {
    {
#line 192
    tmp = gettext("%s: file %s line %lu: %s\n");
#line 192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            myname, cur_input.name, cur_input.line, why);
    }
  } else {
    {
#line 195
    tmp___0 = gettext("%s: -e expression #%lu, char %lu: %s\n");
#line 195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            myname, cur_input.string_expr_count, (unsigned long )(prog.cur - prog.base),
            why);
    }
  }
  {
#line 200
  exit(1);
  }
}
}
#line 207
static int inchar(void) ;
#line 208 "/home/khheo/project/benchmark/sed/sed/compile.c"
static int inchar(void) 
{ 
  int ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
#line 211
  ch = -1;
#line 213
  if (prog.cur) {
#line 215
    if ((unsigned long )prog.cur < (unsigned long )prog.end) {
#line 216
      tmp = prog.cur;
#line 216
      (prog.cur) ++;
#line 216
      ch = (int )*tmp;
    }
  } else
#line 218
  if (prog.file) {
    {
#line 220
    tmp___0 = feof_unlocked(prog.file);
    }
#line 220
    if (! tmp___0) {
      {
#line 221
      ch = getc_unlocked(prog.file);
      }
    }
  }
#line 223
  if (ch == 10) {
#line 224
    (cur_input.line) ++;
  }
#line 225
  return (ch);
}
}
#line 229
static void savchar(int ch ) ;
#line 230 "/home/khheo/project/benchmark/sed/sed/compile.c"
static void savchar(int ch ) 
{ 


  {
#line 234
  if (ch == -1) {
#line 235
    return;
  }
#line 236
  if (ch == 10) {
#line 236
    if (cur_input.line > 0UL) {
#line 237
      (cur_input.line) --;
    }
  }
#line 238
  if (prog.cur) {
#line 240
    if ((unsigned long )prog.cur <= (unsigned long )prog.base) {
      {
#line 241
      panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
      }
    } else {
#line 240
      (prog.cur) --;
#line 240
      if ((int const   )*(prog.cur) != (int const   )ch) {
        {
#line 241
        panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
        }
      }
    }
  } else {
    {
#line 245
    ungetc(ch, prog.file);
    }
  }
#line 246
  return;
}
}
#line 249
static int in_nonblank(void) ;
#line 250 "/home/khheo/project/benchmark/sed/sed/compile.c"
static int in_nonblank(void) 
{ 
  int ch ;
  unsigned short const   **tmp ;

  {
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    ch = inchar();
#line 254
    tmp = __ctype_b_loc();
    }
#line 254
    if (! ((int const   )*(*tmp + ch) & 1)) {
#line 254
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (ch);
}
}
#line 261
static countT in_integer(int ch ) ;
#line 262 "/home/khheo/project/benchmark/sed/sed/compile.c"
static countT in_integer(int ch ) 
{ 
  countT num ;
  unsigned short const   **tmp ;

  {
#line 266
  num = (countT )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    tmp = __ctype_b_loc();
    }
#line 268
    if (! ((int const   )*(*tmp + (int )((unsigned char )ch)) & 2048)) {
#line 268
      goto while_break;
    }
    {
#line 270
    num = (num * 10UL + (countT )ch) - 48UL;
#line 271
    ch = inchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  savchar(ch);
  }
#line 274
  return (num);
}
}
#line 277
static int add_then_next(struct buffer *b___0 , int ch ) ;
#line 278 "/home/khheo/project/benchmark/sed/sed/compile.c"
static int add_then_next(struct buffer *b___0 , int ch ) 
{ 
  int tmp ;

  {
  {
#line 283
  add1_buffer(b___0, ch);
#line 284
  tmp = inchar();
  }
#line 284
  return (tmp);
}
}
#line 287
static char *convert_number(char *result , char *buf , char const   *bufend , int base ) ;
#line 288 "/home/khheo/project/benchmark/sed/sed/compile.c"
static char *convert_number(char *result , char *buf , char const   *bufend , int base ) 
{ 
  int n ;
  int max ;
  char *p ;
  int d ;

  {
#line 295
  n = 0;
#line 296
  max = 1;
#line 299
  p = buf + 1;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if ((unsigned long )p < (unsigned long )bufend) {
#line 299
      if (! (max <= 255)) {
#line 299
        goto while_break;
      }
    } else {
#line 299
      goto while_break;
    }
#line 301
    d = -1;
    {
#line 304
    if ((int )*p == 48) {
#line 304
      goto case_48;
    }
#line 305
    if ((int )*p == 49) {
#line 305
      goto case_49;
    }
#line 306
    if ((int )*p == 50) {
#line 306
      goto case_50;
    }
#line 307
    if ((int )*p == 51) {
#line 307
      goto case_51;
    }
#line 308
    if ((int )*p == 52) {
#line 308
      goto case_52;
    }
#line 309
    if ((int )*p == 53) {
#line 309
      goto case_53;
    }
#line 310
    if ((int )*p == 54) {
#line 310
      goto case_54;
    }
#line 311
    if ((int )*p == 55) {
#line 311
      goto case_55;
    }
#line 312
    if ((int )*p == 56) {
#line 312
      goto case_56;
    }
#line 313
    if ((int )*p == 57) {
#line 313
      goto case_57;
    }
#line 314
    if ((int )*p == 97) {
#line 314
      goto case_97;
    }
#line 314
    if ((int )*p == 65) {
#line 314
      goto case_97;
    }
#line 315
    if ((int )*p == 98) {
#line 315
      goto case_98;
    }
#line 315
    if ((int )*p == 66) {
#line 315
      goto case_98;
    }
#line 316
    if ((int )*p == 99) {
#line 316
      goto case_99;
    }
#line 316
    if ((int )*p == 67) {
#line 316
      goto case_99;
    }
#line 317
    if ((int )*p == 100) {
#line 317
      goto case_100;
    }
#line 317
    if ((int )*p == 68) {
#line 317
      goto case_100;
    }
#line 318
    if ((int )*p == 101) {
#line 318
      goto case_101;
    }
#line 318
    if ((int )*p == 69) {
#line 318
      goto case_101;
    }
#line 319
    if ((int )*p == 102) {
#line 319
      goto case_102;
    }
#line 319
    if ((int )*p == 70) {
#line 319
      goto case_102;
    }
#line 302
    goto switch_break;
    case_48: /* CIL Label */ 
#line 304
    d = 0;
#line 304
    goto switch_break;
    case_49: /* CIL Label */ 
#line 305
    d = 1;
#line 305
    goto switch_break;
    case_50: /* CIL Label */ 
#line 306
    d = 2;
#line 306
    goto switch_break;
    case_51: /* CIL Label */ 
#line 307
    d = 3;
#line 307
    goto switch_break;
    case_52: /* CIL Label */ 
#line 308
    d = 4;
#line 308
    goto switch_break;
    case_53: /* CIL Label */ 
#line 309
    d = 5;
#line 309
    goto switch_break;
    case_54: /* CIL Label */ 
#line 310
    d = 6;
#line 310
    goto switch_break;
    case_55: /* CIL Label */ 
#line 311
    d = 7;
#line 311
    goto switch_break;
    case_56: /* CIL Label */ 
#line 312
    d = 8;
#line 312
    goto switch_break;
    case_57: /* CIL Label */ 
#line 313
    d = 9;
#line 313
    goto switch_break;
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 314
    d = 10;
#line 314
    goto switch_break;
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 315
    d = 11;
#line 315
    goto switch_break;
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 316
    d = 12;
#line 316
    goto switch_break;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 317
    d = 13;
#line 317
    goto switch_break;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 318
    d = 14;
#line 318
    goto switch_break;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 319
    d = 15;
#line 319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 321
    if (d < 0) {
#line 322
      goto while_break;
    } else
#line 321
    if (base <= d) {
#line 322
      goto while_break;
    }
#line 323
    n = n * base + d;
#line 299
    p ++;
#line 299
    max *= base;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if ((unsigned long )p == (unsigned long )(buf + 1)) {
#line 326
    *result = *buf;
  } else {
#line 328
    *result = (char )n;
  }
#line 329
  return (p);
}
}
#line 334
static struct buffer *read_filename(void) ;
#line 335 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct buffer *read_filename(void) 
{ 
  struct buffer *b___0 ;
  int ch ;

  {
  {
#line 341
  b___0 = init_buffer();
#line 342
  ch = in_nonblank();
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (ch != -1) {
#line 343
      if (! (ch != 10)) {
#line 343
        goto while_break;
      }
    } else {
#line 343
      goto while_break;
    }
    {
#line 353
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  add1_buffer(b___0, '\000');
  }
#line 356
  return (b___0);
}
}
#line 359
static struct output *get_openfile(struct output **file_ptrs , char const   *mode ,
                                   int fail ) ;
#line 360 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct output *get_openfile(struct output **file_ptrs , char const   *mode ,
                                   int fail ) 
{ 
  struct buffer *b___0 ;
  char *file_name ;
  struct output *p ;
  int tmp ;
  struct special_files *special ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 370
  b___0 = read_filename();
#line 371
  file_name = get_buffer(b___0);
#line 372
  p = *file_ptrs;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! p) {
#line 372
      goto while_break;
    }
    {
#line 373
    tmp = strcmp((char const   *)p->name, (char const   *)file_name);
    }
#line 373
    if (tmp == 0) {
#line 374
      goto while_break;
    }
#line 372
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  if ((unsigned int )posixicity == 0U) {
#line 379
    special = special_files;
#line 383
    my_stdin = stdin;
#line 383
    my_stdout = stdout;
#line 383
    my_stderr = stderr;
#line 384
    special = special_files;
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 384
      if (! special->outf.name) {
#line 384
        goto while_break___0;
      }
      {
#line 385
      tmp___0 = strcmp((char const   *)special->outf.name, (char const   *)file_name);
      }
#line 385
      if (tmp___0 == 0) {
        {
#line 387
        special->outf.fp = *(special->pfp);
#line 388
        free_buffer(b___0);
        }
#line 389
        return (& special->outf);
      }
#line 384
      special ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 393
  if (! p) {
#line 395
    __h = & obs;
#line 395
    __o = __h;
#line 395
    __len = (int )sizeof(struct output );
#line 395
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 395
      _obstack_newchunk(__o, __len);
      }
    }
#line 395
    __o->next_free += __len;
#line 395
    __o1 = __h;
#line 395
    __value = (void *)__o1->object_base;
#line 395
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 395
      __o1->maybe_empty_object = 1U;
    }
#line 395
    if (sizeof(long ) < sizeof(void *)) {
#line 395
      tmp___1 = __o1->object_base;
    } else {
#line 395
      tmp___1 = (char *)0;
    }
#line 395
    if (sizeof(long ) < sizeof(void *)) {
#line 395
      tmp___2 = __o1->object_base;
    } else {
#line 395
      tmp___2 = (char *)0;
    }
#line 395
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 395
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 395
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 395
    __o1->object_base = __o1->next_free;
#line 395
    p = (struct output *)__value;
#line 396
    p->name = ck_strdup((char const   *)file_name);
#line 397
    p->fp = ck_fopen((char const   *)p->name, mode, fail);
#line 398
    p->missing_newline = (_Bool)0;
#line 399
    p->link = *file_ptrs;
#line 400
    *file_ptrs = p;
    }
  }
  {
#line 402
  free_buffer(b___0);
  }
#line 403
  return (p);
}
}
#line 407
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) ;
#line 408 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) 
{ 
  struct sed_cmd *cmd ;
  struct vector *v ;
  void *tmp ;

  {
#line 415
  v = *vectorp;
#line 416
  if (v->v_length == v->v_allocated) {
    {
#line 418
    v->v_allocated += 40UL;
#line 419
    tmp = ck_realloc((void *)v->v, v->v_allocated * sizeof(struct sed_cmd ));
#line 419
    v->v = (struct sed_cmd *)tmp;
    }
  }
#line 422
  cmd = v->v + v->v_length;
#line 423
  cmd->a1 = (struct addr *)((void *)0);
#line 424
  cmd->a2 = (struct addr *)((void *)0);
#line 425
  cmd->range_state = (enum addr_state )0;
#line 426
  cmd->addr_bang = (char)0;
#line 427
  cmd->cmd = (char )'\000';
#line 429
  *vectorp = v;
#line 430
  return (cmd);
}
}
#line 433
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) ;
#line 434 "/home/khheo/project/benchmark/sed/sed/compile.c"
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) 
{ 
  int ch ;
  int state ;
  int delim ;
  _Bool pending_mb ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 440
  state = 0;
#line 442
  pending_mb = (_Bool)0;
#line 444
  ch = inchar();
  }
#line 445
  if (ch == 94) {
    {
#line 446
    ch = add_then_next(b___0, ch);
    }
  }
#line 447
  if (ch == 93) {
    {
#line 448
    ch = add_then_next(b___0, ch);
    }
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (mb_cur_max == 1) {
#line 458
      tmp___0 = 1;
    } else {
      {
#line 458
      tmp = brlen(ch, cur_stat);
#line 458
      tmp___0 = tmp;
      }
    }
#line 458
    pending_mb = (_Bool )(tmp___0 != 1);
    {
#line 463
    if (ch == 10) {
#line 463
      goto case_10;
    }
#line 463
    if (ch == -1) {
#line 463
      goto case_10;
    }
#line 468
    if (ch == 61) {
#line 468
      goto case_61;
    }
#line 468
    if (ch == 58) {
#line 468
      goto case_61;
    }
#line 468
    if (ch == 46) {
#line 468
      goto case_61;
    }
#line 484
    if (ch == 91) {
#line 484
      goto case_91;
    }
#line 492
    if (ch == 93) {
#line 492
      goto case_93;
    }
#line 503
    goto switch_default;
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 464
    return (ch);
    case_61: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 469
    if (pending_mb) {
#line 470
      goto __Cont;
    }
#line 472
    if (state == 1) {
#line 474
      delim = ch;
#line 475
      state = 2;
    } else
#line 477
    if (state == 2) {
#line 477
      if (ch == delim) {
#line 478
        state = 3;
      } else {
#line 480
        goto switch_break;
      }
    } else {
#line 480
      goto switch_break;
    }
#line 482
    goto __Cont;
    case_91: /* CIL Label */ 
#line 485
    if (pending_mb) {
#line 486
      goto __Cont;
    }
#line 488
    if (state == 0) {
#line 489
      state = 1;
    }
#line 490
    goto __Cont;
    case_93: /* CIL Label */ 
#line 493
    if (pending_mb) {
#line 494
      goto __Cont;
    }
#line 496
    if (state == 0) {
#line 497
      return (ch);
    } else
#line 496
    if (state == 1) {
#line 497
      return (ch);
    } else
#line 498
    if (state == 3) {
#line 499
      state = 0;
    }
#line 501
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 510
    state &= -2;
    __Cont: /* CIL Label */ 
    {
#line 456
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 514
static struct buffer *match_slash(int slash , int regex ) ;
#line 515 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct buffer *match_slash(int slash , int regex ) 
{ 
  struct buffer *b___0 ;
  int ch ;
  mbstate_t cur_stat ;
  int tmp ;
  int tmp___0 ;
  _Bool pending_mb ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 524
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
  }
#line 527
  if (mb_cur_max == 1) {
#line 527
    tmp___0 = 1;
  } else {
    {
#line 527
    tmp = brlen(slash, & cur_stat);
#line 527
    tmp___0 = tmp;
    }
  }
#line 527
  if (tmp___0 == -2) {
    {
#line 528
    bad_prog(((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths"));
    }
  }
  {
#line 530
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
#line 532
  b___0 = init_buffer();
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 533
    ch = inchar();
    }
#line 533
    if (ch != -1) {
#line 533
      if (! (ch != 10)) {
#line 533
        goto while_break;
      }
    } else {
#line 533
      goto while_break;
    }
#line 535
    if (mb_cur_max == 1) {
#line 535
      tmp___2 = 1;
    } else {
      {
#line 535
      tmp___1 = mbsinit((mbstate_t const   *)(& cur_stat));
#line 535
      tmp___2 = tmp___1;
      }
    }
#line 535
    if (tmp___2) {
#line 535
      tmp___3 = 0;
    } else {
#line 535
      tmp___3 = 1;
    }
#line 535
    pending_mb = (_Bool )tmp___3;
#line 536
    if (mb_cur_max == 1) {
#line 536
      tmp___5 = 1;
    } else {
      {
#line 536
      tmp___4 = brlen(ch, & cur_stat);
#line 536
      tmp___5 = tmp___4;
      }
    }
#line 536
    if (tmp___5 == 1) {
#line 536
      if (! pending_mb) {
#line 538
        if (ch == slash) {
#line 539
          return (b___0);
        } else
#line 540
        if (ch == 92) {
          {
#line 542
          ch = inchar();
          }
#line 543
          if (ch == -1) {
#line 544
            goto while_break;
          } else
#line 546
          if (ch == 110) {
#line 546
            if (regex) {
#line 547
              ch = '\n';
            } else {
#line 546
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 549
          if (ch != 10) {
#line 549
            if (ch != slash) {
              {
#line 550
              add1_buffer(b___0, '\\');
              }
            } else
#line 549
            if (! regex) {
#line 549
              if (ch == 38) {
                {
#line 550
                add1_buffer(b___0, '\\');
                }
              }
            }
          }
        } else
#line 552
        if (ch == 91) {
#line 552
          if (regex) {
            {
#line 554
            add1_buffer(b___0, ch);
#line 555
            ch = snarf_char_class(b___0, & cur_stat);
            }
#line 556
            if (ch != 93) {
#line 557
              goto while_break;
            }
          }
        }
      }
    }
    {
#line 561
    add1_buffer(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if (ch == 10) {
    {
#line 565
    savchar(ch);
    }
  }
  {
#line 566
  free_buffer(b___0);
  }
#line 567
  return ((struct buffer *)((void *)0));
}
}
#line 570
static int mark_subst_opts(struct subst *cmd ) ;
#line 571 "/home/khheo/project/benchmark/sed/sed/compile.c"
static int mark_subst_opts(struct subst *cmd ) 
{ 
  int flags ;
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 575
  flags = 0;
#line 578
  cmd->global = 0U;
#line 579
  cmd->print = 0U;
#line 580
  cmd->eval = 0U;
#line 581
  cmd->numb = (countT )0;
#line 582
  cmd->outf = (struct output *)((void *)0);
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 585
    ch = in_nonblank();
    }
    {
#line 588
    if (ch == 73) {
#line 588
      goto case_73;
    }
#line 588
    if (ch == 105) {
#line 588
      goto case_73;
    }
#line 613
    if (ch == 77) {
#line 613
      goto case_77;
    }
#line 613
    if (ch == 109) {
#line 613
      goto case_77;
    }
#line 619
    if (ch == 101) {
#line 619
      goto case_101;
    }
#line 623
    if (ch == 112) {
#line 623
      goto case_112;
    }
#line 629
    if (ch == 103) {
#line 629
      goto case_103;
    }
#line 635
    if (ch == 119) {
#line 635
      goto case_119;
    }
#line 640
    if (ch == 57) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 56) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 55) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 54) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 53) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 52) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 51) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 50) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 49) {
#line 640
      goto case_57;
    }
#line 640
    if (ch == 48) {
#line 640
      goto case_57;
    }
#line 649
    if (ch == 35) {
#line 649
      goto case_35;
    }
#line 649
    if (ch == 125) {
#line 649
      goto case_35;
    }
#line 654
    if (ch == 59) {
#line 654
      goto case_59;
    }
#line 654
    if (ch == 10) {
#line 654
      goto case_59;
    }
#line 654
    if (ch == -1) {
#line 654
      goto case_59;
    }
#line 657
    if (ch == 13) {
#line 657
      goto case_13;
    }
#line 662
    goto switch_default;
    case_73: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 589
    if ((unsigned int )posixicity == 2U) {
      {
#line 590
      tmp = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 590
      bad_prog((char const   *)tmp);
      }
    }
#line 591
    flags |= 1 << 1;
#line 592
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 614
    if ((unsigned int )posixicity == 2U) {
      {
#line 615
      tmp___0 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 615
      bad_prog((char const   *)tmp___0);
      }
    }
#line 616
    flags |= 1 << 2;
#line 617
    goto switch_break;
    case_101: /* CIL Label */ 
#line 620
    cmd->eval = 1U;
#line 621
    goto switch_break;
    case_112: /* CIL Label */ 
#line 624
    if (cmd->print) {
      {
#line 625
      tmp___1 = gettext((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'"));
#line 625
      bad_prog((char const   *)tmp___1);
      }
    }
#line 626
    cmd->print |= (unsigned int )(1 << cmd->eval);
#line 627
    goto switch_break;
    case_103: /* CIL Label */ 
#line 630
    if (cmd->global) {
      {
#line 631
      tmp___2 = gettext(((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command"));
#line 631
      bad_prog((char const   *)tmp___2);
      }
    }
#line 632
    cmd->global = 1U;
#line 633
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 636
    cmd->outf = get_openfile(& file_write, (char const   *)write_mode, 1);
    }
#line 637
    return (flags);
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 641
    if (cmd->numb) {
      {
#line 642
      tmp___3 = gettext((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command"));
#line 642
      bad_prog((char const   *)tmp___3);
      }
    }
    {
#line 643
    cmd->numb = in_integer(ch);
    }
#line 644
    if (! cmd->numb) {
      {
#line 645
      tmp___4 = gettext(((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command"));
#line 645
      bad_prog((char const   *)tmp___4);
      }
    }
#line 646
    goto switch_break;
    case_35: /* CIL Label */ 
    case_125: /* CIL Label */ 
    {
#line 650
    savchar(ch);
    }
    case_59: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 655
    return (flags);
    case_13: /* CIL Label */ 
    {
#line 658
    tmp___5 = inchar();
    }
#line 658
    if (tmp___5 == 10) {
#line 659
      return (flags);
    }
    switch_default: /* CIL Label */ 
    {
#line 663
    tmp___6 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 663
    bad_prog((char const   *)tmp___6);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 670
static char *read_label(void) ;
#line 671 "/home/khheo/project/benchmark/sed/sed/compile.c"
static char *read_label(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 678
  b___0 = init_buffer();
#line 679
  ch = in_nonblank();
  }
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    if (ch != -1) {
#line 681
      if (ch != 10) {
        {
#line 681
        tmp = __ctype_b_loc();
        }
#line 681
        if ((int const   )*(*tmp + ch) & 1) {
#line 681
          goto while_break;
        } else
#line 681
        if (ch != 59) {
#line 681
          if (ch != 125) {
#line 681
            if (! (ch != 35)) {
#line 681
              goto while_break;
            }
          } else {
#line 681
            goto while_break;
          }
        } else {
#line 681
          goto while_break;
        }
      } else {
#line 681
        goto while_break;
      }
    } else {
#line 681
      goto while_break;
    }
    {
#line 683
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  savchar(ch);
#line 686
  add1_buffer(b___0, '\000');
#line 687
  tmp___0 = get_buffer(b___0);
#line 687
  ret = ck_strdup((char const   *)tmp___0);
#line 688
  free_buffer(b___0);
  }
#line 689
  return (ret);
}
}
#line 696
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) ;
#line 698 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) 
{ 
  struct sed_label *ret ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 705
  __h = & obs;
#line 705
  __o = __h;
#line 705
  __len = (int )sizeof(struct sed_label );
#line 705
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 705
    _obstack_newchunk(__o, __len);
    }
  }
#line 705
  __o->next_free += __len;
#line 705
  __o1 = __h;
#line 705
  __value = (void *)__o1->object_base;
#line 705
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 705
    __o1->maybe_empty_object = 1U;
  }
#line 705
  if (sizeof(long ) < sizeof(void *)) {
#line 705
    tmp = __o1->object_base;
  } else {
#line 705
    tmp = (char *)0;
  }
#line 705
  if (sizeof(long ) < sizeof(void *)) {
#line 705
    tmp___0 = __o1->object_base;
  } else {
#line 705
    tmp___0 = (char *)0;
  }
#line 705
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 705
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 705
    __o1->next_free = __o1->chunk_limit;
  }
#line 705
  __o1->object_base = __o1->next_free;
#line 705
  ret = (struct sed_label *)__value;
#line 706
  ret->v_index = idx;
#line 707
  ret->name = name;
#line 708
  if (err_info) {
    {
#line 709
    memcpy((void */* __restrict  */)(& ret->err_info), (void const   */* __restrict  */)err_info,
           sizeof(ret->err_info));
    }
  }
#line 710
  ret->next = list;
#line 711
  return (ret);
}
}
#line 714
static struct sed_label *release_label(struct sed_label *list_head ) ;
#line 715 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct sed_label *release_label(struct sed_label *list_head ) 
{ 
  struct sed_label *ret ;

  {
#line 721
  if (! list_head) {
#line 722
    return ((struct sed_label *)((void *)0));
  }
  {
#line 723
  ret = list_head->next;
#line 725
  free((void *)list_head->name);
  }
#line 731
  return (ret);
}
}
#line 734 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) 
{ 
  struct replacement *r ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 737
  __h = & obs;
#line 737
  __o = __h;
#line 737
  __len = (int )sizeof(struct replacement );
#line 737
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 737
    _obstack_newchunk(__o, __len);
    }
  }
#line 737
  __o->next_free += __len;
#line 737
  __o1 = __h;
#line 737
  __value = (void *)__o1->object_base;
#line 737
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 737
    __o1->maybe_empty_object = 1U;
  }
#line 737
  if (sizeof(long ) < sizeof(void *)) {
#line 737
    tmp = __o1->object_base;
  } else {
#line 737
    tmp = (char *)0;
  }
#line 737
  if (sizeof(long ) < sizeof(void *)) {
#line 737
    tmp___0 = __o1->object_base;
  } else {
#line 737
    tmp___0 = (char *)0;
  }
#line 737
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 737
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 737
    __o1->next_free = __o1->chunk_limit;
  }
#line 737
  __o1->object_base = __o1->next_free;
#line 737
  r = (struct replacement *)__value;
#line 739
  r->prefix = text;
#line 740
  r->prefix_length = length;
#line 741
  r->subst_id = -1;
#line 742
  r->repl_type = type;
#line 745
  return (r);
}
}
#line 748
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) ;
#line 749 "/home/khheo/project/benchmark/sed/sed/compile.c"
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) 
{ 
  char *base ;
  char *p ;
  char *text_end ;
  enum replacement_types repl_type ;
  enum replacement_types save_type ;
  struct replacement root ;
  struct replacement *tail ;
  void *tmp ;
  struct replacement *tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct replacement *tmp___2 ;
  struct replacement *tmp___3 ;

  {
  {
#line 758
  repl_type = (enum replacement_types )0;
#line 758
  save_type = (enum replacement_types )0;
#line 762
  sub->max_id = 0U;
#line 763
  tmp = ck_memdup((void const   *)((void *)text), length * sizeof(char ));
#line 763
  base = (char *)tmp;
#line 764
  length = normalize_text(base, length, (enum text_types )1);
#line 766
  text_end = base + length;
#line 767
  tail = & root;
#line 769
  p = base;
  }
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! ((unsigned long )p < (unsigned long )text_end)) {
#line 769
      goto while_break;
    }
#line 771
    if ((int )*p == 92) {
      {
#line 774
      tmp___0 = new_replacement(base, (size_t )(p - base), repl_type);
#line 774
      tail->next = tmp___0;
#line 774
      tail = tmp___0;
#line 777
      repl_type = save_type;
#line 781
      p ++;
      }
#line 782
      if ((unsigned long )p == (unsigned long )text_end) {
#line 783
        (tail->prefix_length) ++;
      } else
#line 785
      if ((unsigned int )posixicity == 2U) {
        {
#line 785
        tmp___1 = __ctype_b_loc();
        }
#line 785
        if ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 2048) {
#line 785
          goto _L;
        } else {
#line 787
          *(p + -1) = *p;
#line 788
          (tail->prefix_length) ++;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 795
        if ((int )*p == 57) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 56) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 55) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 54) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 53) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 52) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 51) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 50) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 49) {
#line 795
          goto case_57;
        }
#line 795
        if ((int )*p == 48) {
#line 795
          goto case_57;
        }
#line 801
        if ((int )*p == 76) {
#line 801
          goto case_76;
        }
#line 806
        if ((int )*p == 85) {
#line 806
          goto case_85;
        }
#line 811
        if ((int )*p == 69) {
#line 811
          goto case_69;
        }
#line 816
        if ((int )*p == 108) {
#line 816
          goto case_108;
        }
#line 821
        if ((int )*p == 117) {
#line 821
          goto case_117;
        }
#line 826
        goto switch_default;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 796
        tail->subst_id = (int )*p - 48;
#line 797
        if (sub->max_id < (unsigned int )tail->subst_id) {
#line 798
          sub->max_id = (unsigned int )tail->subst_id;
        }
#line 799
        goto switch_break;
        case_76: /* CIL Label */ 
#line 802
        repl_type = (enum replacement_types )2;
#line 803
        save_type = (enum replacement_types )2;
#line 804
        goto switch_break;
        case_85: /* CIL Label */ 
#line 807
        repl_type = (enum replacement_types )1;
#line 808
        save_type = (enum replacement_types )1;
#line 809
        goto switch_break;
        case_69: /* CIL Label */ 
#line 812
        repl_type = (enum replacement_types )0;
#line 813
        save_type = (enum replacement_types )0;
#line 814
        goto switch_break;
        case_108: /* CIL Label */ 
#line 817
        save_type = repl_type;
#line 818
        repl_type = (enum replacement_types )((unsigned int )repl_type | 8U);
#line 819
        goto switch_break;
        case_117: /* CIL Label */ 
#line 822
        save_type = repl_type;
#line 823
        repl_type = (enum replacement_types )((unsigned int )repl_type | 4U);
#line 824
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 827
        *(p + -1) = *p;
#line 828
        (tail->prefix_length) ++;
        switch_break: /* CIL Label */ ;
        }
      }
#line 831
      base = p + 1;
    } else
#line 833
    if ((int )*p == 38) {
      {
#line 836
      tmp___2 = new_replacement(base, (size_t )(p - base), repl_type);
#line 836
      tail->next = tmp___2;
#line 836
      tail = tmp___2;
#line 839
      repl_type = save_type;
#line 840
      tail->subst_id = 0;
#line 841
      base = p + 1;
      }
    }
#line 769
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if ((unsigned long )base < (unsigned long )text_end) {
    {
#line 846
    tmp___3 = new_replacement(base, (size_t )(text_end - base), repl_type);
#line 846
    tail->next = tmp___3;
#line 846
    tail = tmp___3;
    }
  }
#line 849
  tail->next = (struct replacement *)((void *)0);
#line 850
  sub->replacement = root.next;
#line 851
  return;
}
}
#line 853
static void read_text(struct text_buf *buf , int leadin_ch ) ;
#line 854 "/home/khheo/project/benchmark/sed/sed/compile.c"
static void read_text(struct text_buf *buf , int leadin_ch ) 
{ 
  int ch ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 862
  if (buf) {
#line 864
    if (pending_text) {
      {
#line 865
      free_buffer(pending_text);
      }
    }
    {
#line 866
    pending_text = init_buffer();
#line 867
    buf->text = (char *)((void *)0);
#line 868
    buf->text_length = (size_t )0;
#line 869
    old_text_buf = buf;
    }
  }
#line 873
  if (leadin_ch == -1) {
#line 874
    return;
  }
#line 876
  if (leadin_ch != 10) {
    {
#line 877
    add1_buffer(pending_text, leadin_ch);
    }
  }
  {
#line 879
  ch = inchar();
  }
  {
#line 880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 880
    if (ch != -1) {
#line 880
      if (! (ch != 10)) {
#line 880
        goto while_break;
      }
    } else {
#line 880
      goto while_break;
    }
#line 882
    if (ch == 92) {
      {
#line 884
      ch = inchar();
      }
#line 885
      if (ch != -1) {
        {
#line 886
        add1_buffer(pending_text, '\\');
        }
      }
    }
#line 889
    if (ch == -1) {
      {
#line 891
      add1_buffer(pending_text, '\n');
      }
#line 892
      return;
    }
    {
#line 895
    ch = add_then_next(pending_text, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 898
  add1_buffer(pending_text, '\n');
  }
#line 899
  if (! buf) {
#line 900
    buf = old_text_buf;
  }
  {
#line 901
  tmp = size_buffer(pending_text);
#line 901
  tmp___0 = get_buffer(pending_text);
#line 901
  buf->text_length = normalize_text(tmp___0, tmp, (enum text_types )0);
#line 903
  tmp___1 = get_buffer(pending_text);
#line 903
  tmp___2 = ck_memdup((void const   *)((void *)tmp___1), buf->text_length * sizeof(char ));
#line 903
  buf->text = (char *)tmp___2;
#line 904
  free_buffer(pending_text);
#line 905
  pending_text = (struct buffer *)((void *)0);
  }
#line 906
  return;
}
}
#line 913
static _Bool compile_address(struct addr *addr , int ch ) ;
#line 914 "/home/khheo/project/benchmark/sed/sed/compile.c"
static _Bool compile_address(struct addr *addr , int ch ) 
{ 
  int flags ;
  struct buffer *b___0 ;
  char *tmp ;
  countT step ;
  int tmp___0 ;
  countT tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 919
  addr->addr_type = (enum addr_types )0;
#line 920
  addr->addr_step = (countT )0;
#line 921
  addr->addr_number = ~ ((countT )0);
#line 922
  addr->addr_regex = (struct regex *)((void *)0);
#line 924
  if (ch == 47) {
#line 924
    goto _L___1;
  } else
#line 924
  if (ch == 92) {
    _L___1: /* CIL Label */ 
#line 926
    flags = 0;
#line 928
    addr->addr_type = (enum addr_types )1;
#line 929
    if (ch == 92) {
      {
#line 930
      ch = inchar();
      }
    }
    {
#line 931
    b___0 = match_slash(ch, 1);
    }
#line 931
    if (! b___0) {
      {
#line 932
      tmp = gettext((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address"));
#line 932
      bad_prog((char const   *)tmp);
      }
    }
    {
#line 934
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 936
      ch = in_nonblank();
      }
#line 937
      if ((unsigned int )posixicity == 2U) {
#line 938
        goto posix_address_modifier;
      }
      {
#line 941
      if (ch == 73) {
#line 941
        goto case_73;
      }
#line 957
      if (ch == 77) {
#line 957
        goto case_77;
      }
#line 961
      goto posix_address_modifier;
      case_73: /* CIL Label */ 
#line 942
      flags |= 1 << 1;
#line 943
      goto switch_break;
      case_77: /* CIL Label */ 
#line 958
      flags |= 1 << 2;
#line 959
      goto switch_break;
      posix_address_modifier: 
      switch_default: /* CIL Label */ 
      {
#line 963
      savchar(ch);
#line 964
      addr->addr_regex = compile_regex(b___0, flags, 0);
#line 965
      free_buffer(b___0);
      }
#line 966
      return ((_Bool)1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 970
    tmp___3 = __ctype_b_loc();
    }
#line 970
    if ((int const   )*(*tmp___3 + (int )((unsigned char )ch)) & 2048) {
      {
#line 972
      addr->addr_number = in_integer(ch);
#line 973
      addr->addr_type = (enum addr_types )2;
#line 974
      ch = in_nonblank();
      }
#line 975
      if (ch != 126) {
        {
#line 977
        savchar(ch);
        }
      } else
#line 975
      if ((unsigned int )posixicity == 2U) {
        {
#line 977
        savchar(ch);
        }
      } else {
        {
#line 981
        tmp___0 = in_nonblank();
#line 981
        tmp___1 = in_integer(tmp___0);
#line 981
        step = tmp___1;
        }
#line 982
        if (step > 0UL) {
#line 984
          addr->addr_step = step;
#line 985
          addr->addr_type = (enum addr_types )3;
        }
      }
    } else
#line 989
    if (ch == 43) {
#line 989
      goto _L___0;
    } else
#line 989
    if (ch == 126) {
      _L___0: /* CIL Label */ 
#line 989
      if ((unsigned int )posixicity != 2U) {
        {
#line 991
        tmp___2 = in_nonblank();
#line 991
        addr->addr_step = in_integer(tmp___2);
        }
#line 992
        if (! (addr->addr_step == 0UL)) {
#line 994
          if (ch == 43) {
#line 995
            addr->addr_type = (enum addr_types )4;
          } else {
#line 997
            addr->addr_type = (enum addr_types )5;
          }
        }
      } else {
#line 989
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 999
    if (ch == 36) {
#line 1001
      addr->addr_type = (enum addr_types )6;
    } else {
#line 1004
      return ((_Bool)0);
    }
  }
#line 1006
  return ((_Bool)1);
}
}
#line 1011
static struct vector *compile_program(struct vector *vector ) ;
#line 1012 "/home/khheo/project/benchmark/sed/sed/compile.c"
static struct vector *compile_program(struct vector *vector ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct buffer *b___0 ;
  int ch ;
  void *tmp ;
  struct addr a ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  long tmp___12 ;
  char *version ;
  char *tmp___13 ;
  char *compared_version ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  countT tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  struct output *tmp___30 ;
  struct buffer *b2 ;
  int flags ;
  int slash ;
  char *tmp___31 ;
  char *tmp___32 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  size_t len ;
  size_t dest_len ;
  int slash___0 ;
  struct buffer *b2___0 ;
  char *src_buf ;
  char *dest_buf ;
  char *tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  size_t tmp___40 ;
  int i ;
  int j ;
  int idx ;
  int src_char_num ;
  size_t *src_lens ;
  void *tmp___41 ;
  char **trans_pairs ;
  size_t mbclen ;
  mbstate_t cur_stat ;
  size_t tmp___42 ;
  int tmp___43 ;
  void *tmp___44 ;
  char *tmp___45 ;
  void *tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  char *tmp___49 ;
  unsigned char *translate ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___50 ;
  char *tmp___51 ;
  unsigned char *ustring ;
  char *tmp___52 ;
  unsigned char *tmp___53 ;
  char *tmp___54 ;
  size_t tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;

  {
#line 1020
  if (! vector) {
    {
#line 1022
    tmp = ck_malloc(sizeof(struct vector ));
#line 1022
    vector = (struct vector *)tmp;
#line 1023
    vector->v = (struct sed_cmd *)((void *)0);
#line 1024
    vector->v_allocated = (size_t )0;
#line 1025
    vector->v_length = (size_t )0;
#line 1027
    _obstack_begin(& obs, 0, 0, (void *(*)(long  ))(& ck_malloc), (void (*)(void * ))(& free));
    }
  }
#line 1029
  if (pending_text) {
    {
#line 1030
    read_text((struct text_buf *)((void *)0), '\n');
    }
  }
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1036
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1036
      ch = inchar();
      }
#line 1036
      if (! (ch == 59)) {
        {
#line 1036
        tmp___0 = __ctype_b_loc();
        }
#line 1036
        if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
#line 1036
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1038
    if (ch == -1) {
#line 1039
      goto while_break;
    }
    {
#line 1041
    cur_cmd = next_cmd_entry(& vector);
#line 1042
    tmp___8 = compile_address(& a, ch);
    }
#line 1042
    if (tmp___8) {
#line 1044
      if ((unsigned int )a.addr_type == 4U) {
        {
#line 1046
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1046
        bad_prog((char const   *)tmp___1);
        }
      } else
#line 1044
      if ((unsigned int )a.addr_type == 5U) {
        {
#line 1046
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1046
        bad_prog((char const   *)tmp___1);
        }
      }
      {
#line 1048
      tmp___2 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1048
      cur_cmd->a1 = (struct addr *)tmp___2;
#line 1049
      ch = in_nonblank();
      }
#line 1050
      if (ch == 44) {
        {
#line 1052
        tmp___4 = in_nonblank();
#line 1052
        tmp___5 = compile_address(& a, tmp___4);
        }
#line 1052
        if (! tmp___5) {
          {
#line 1053
          tmp___3 = gettext(errors___0 + sizeof("multiple `!\'s"));
#line 1053
          bad_prog((char const   *)tmp___3);
          }
        }
        {
#line 1055
        tmp___6 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1055
        cur_cmd->a2 = (struct addr *)tmp___6;
#line 1056
        ch = in_nonblank();
        }
      }
#line 1059
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 1059
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 1059
          if (! cur_cmd->a2) {
            {
#line 1063
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1063
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1059
          if ((unsigned int )(cur_cmd->a2)->addr_type != 1U) {
            {
#line 1063
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1063
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1059
          if ((unsigned int )posixicity == 2U) {
            {
#line 1063
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1063
            bad_prog((char const   *)tmp___7);
            }
          }
        }
      }
    }
#line 1065
    if (ch == 33) {
      {
#line 1067
      cur_cmd->addr_bang = (char)1;
#line 1068
      ch = in_nonblank();
      }
#line 1069
      if (ch == 33) {
        {
#line 1070
        tmp___9 = gettext(errors___0);
#line 1070
        bad_prog((char const   *)tmp___9);
        }
      }
    }
#line 1075
    if ((unsigned int )posixicity == 2U) {
      {
#line 1079
      if (ch == 87) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 82) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 84) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 81) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 76) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 122) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 118) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 70) {
#line 1079
        goto case_87;
      }
#line 1079
      if (ch == 101) {
#line 1079
        goto case_87;
      }
#line 1083
      if (ch == 114) {
#line 1083
        goto case_114;
      }
#line 1083
      if (ch == 61) {
#line 1083
        goto case_114;
      }
#line 1083
      if (ch == 108) {
#line 1083
        goto case_114;
      }
#line 1083
      if (ch == 105) {
#line 1083
        goto case_114;
      }
#line 1083
      if (ch == 97) {
#line 1083
        goto case_114;
      }
#line 1076
      goto switch_break;
      case_87: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_101: /* CIL Label */ 
      {
#line 1080
      bad_command((char )ch);
      }
      case_114: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 1084
      if (cur_cmd->a2) {
        {
#line 1085
        tmp___10 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1085
        bad_prog((char const   *)tmp___10);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1088
    cur_cmd->cmd = (char )ch;
    {
#line 1091
    if (ch == 35) {
#line 1091
      goto case_35;
    }
#line 1103
    if (ch == 118) {
#line 1103
      goto case_118___0;
    }
#line 1120
    if (ch == 123) {
#line 1120
      goto case_123;
    }
#line 1125
    if (ch == 125) {
#line 1125
      goto case_125;
    }
#line 1140
    if (ch == 101) {
#line 1140
      goto case_101___0;
    }
#line 1152
    if (ch == 99) {
#line 1152
      goto case_99;
    }
#line 1152
    if (ch == 105) {
#line 1152
      goto case_99;
    }
#line 1152
    if (ch == 97) {
#line 1152
      goto case_99;
    }
#line 1172
    if (ch == 58) {
#line 1172
      goto case_58;
    }
#line 1180
    if (ch == 116) {
#line 1180
      goto case_116;
    }
#line 1180
    if (ch == 98) {
#line 1180
      goto case_116;
    }
#line 1180
    if (ch == 84) {
#line 1180
      goto case_116;
    }
#line 1185
    if (ch == 113) {
#line 1185
      goto case_113;
    }
#line 1185
    if (ch == 81) {
#line 1185
      goto case_113;
    }
#line 1191
    if (ch == 108) {
#line 1191
      goto case_108___0;
    }
#line 1191
    if (ch == 76) {
#line 1191
      goto case_108___0;
    }
#line 1221
    if (ch == 120) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 122) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 80) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 112) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 78) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 110) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 72) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 104) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 71) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 103) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 70) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 68) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 100) {
#line 1221
      goto case_120;
    }
#line 1221
    if (ch == 61) {
#line 1221
      goto case_120;
    }
#line 1229
    if (ch == 114) {
#line 1229
      goto case_114___0;
    }
#line 1235
    if (ch == 82) {
#line 1235
      goto case_82___0;
    }
#line 1240
    if (ch == 119) {
#line 1240
      goto case_119;
    }
#line 1240
    if (ch == 87) {
#line 1240
      goto case_119;
    }
#line 1244
    if (ch == 115) {
#line 1244
      goto case_115;
    }
#line 1268
    if (ch == 121) {
#line 1268
      goto case_121;
    }
#line 1373
    if (ch == -1) {
#line 1373
      goto case_neg_1;
    }
#line 1377
    goto switch_default;
    case_35: /* CIL Label */ 
#line 1092
    if (cur_cmd->a1) {
      {
#line 1093
      tmp___11 = gettext(((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses"));
#line 1093
      bad_prog((char const   *)tmp___11);
      }
    }
    {
#line 1094
    ch = inchar();
    }
#line 1095
    if (ch == 110) {
#line 1095
      if (first_script) {
#line 1095
        if (cur_input.line < 2UL) {
#line 1096
          if (prog.base) {
#line 1096
            if ((unsigned long )prog.cur == (unsigned long )(prog.base + 2)) {
#line 1098
              no_default_output = (_Bool)1;
            } else {
#line 1096
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1096
          if (prog.file) {
#line 1096
            if (! prog.base) {
              {
#line 1096
              tmp___12 = ftell(prog.file);
              }
#line 1096
              if (2L == tmp___12) {
#line 1098
                no_default_output = (_Bool)1;
              }
            }
          }
        }
      }
    }
    {
#line 1099
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1099
      if (ch != -1) {
#line 1099
        if (! (ch != 10)) {
#line 1099
          goto while_break___1;
        }
      } else {
#line 1099
        goto while_break___1;
      }
      {
#line 1100
      ch = inchar();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1101
    goto __Cont;
    case_118___0: /* CIL Label */ 
    {
#line 1109
    tmp___13 = read_label();
#line 1109
    version = tmp___13;
    }
#line 1111
    if ((int )*version == 0) {
#line 1111
      compared_version = (char *)"4.0";
    } else {
#line 1111
      compared_version = version;
    }
    {
#line 1112
    tmp___15 = strverscmp((char const   *)compared_version, "4.2.2");
    }
#line 1112
    if (tmp___15 > 0) {
      {
#line 1113
      tmp___14 = gettext((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character"));
#line 1113
      bad_prog((char const   *)tmp___14);
      }
    }
    {
#line 1115
    free((void *)version);
#line 1116
    posixicity = (enum posixicity_types )0;
    }
#line 1118
    goto __Cont;
    case_123: /* CIL Label */ 
    {
#line 1121
    blocks = setup_label(blocks, vector->v_length, (char *)((void *)0), (struct error_info  const  *)(& cur_input));
#line 1122
    cur_cmd->addr_bang = (char )(! cur_cmd->addr_bang);
    }
#line 1123
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 1126
    if (! blocks) {
      {
#line 1127
      tmp___16 = gettext((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'"));
#line 1127
      bad_prog((char const   *)tmp___16);
      }
    }
#line 1128
    if (cur_cmd->a1) {
      {
#line 1129
      tmp___17 = gettext(((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'"));
#line 1129
      bad_prog((char const   *)tmp___17);
      }
    }
    {
#line 1130
    ch = in_nonblank();
    }
#line 1131
    if (ch == 125) {
      {
#line 1132
      savchar(ch);
      }
    } else
#line 1131
    if (ch == 35) {
      {
#line 1132
      savchar(ch);
      }
    } else
#line 1133
    if (ch != -1) {
#line 1133
      if (ch != 10) {
#line 1133
        if (ch != 59) {
          {
#line 1134
          tmp___18 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1134
          bad_prog((char const   *)tmp___18);
          }
        }
      }
    }
    {
#line 1136
    (vector->v + blocks->v_index)->x.jump_index = vector->v_length;
#line 1137
    blocks = release_label(blocks);
    }
#line 1138
    goto switch_break___0;
    case_101___0: /* CIL Label */ 
    {
#line 1141
    ch = in_nonblank();
    }
#line 1142
    if (ch == -1) {
#line 1144
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1145
      goto switch_break___0;
    } else
#line 1142
    if (ch == 10) {
#line 1144
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1145
      goto switch_break___0;
    } else {
#line 1148
      goto read_text_to_slash;
    }
    case_99: /* CIL Label */ 
    case_105___0: /* CIL Label */ 
    case_97___0: /* CIL Label */ 
    {
#line 1153
    ch = in_nonblank();
    }
    read_text_to_slash: 
#line 1156
    if (ch == -1) {
      {
#line 1157
      tmp___19 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1157
      bad_prog((char const   *)tmp___19);
      }
    }
#line 1159
    if (ch == 92) {
      {
#line 1160
      ch = inchar();
      }
    } else {
#line 1163
      if ((unsigned int )posixicity == 2U) {
        {
#line 1164
        tmp___20 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1164
        bad_prog((char const   *)tmp___20);
        }
      }
      {
#line 1165
      savchar(ch);
#line 1166
      ch = '\n';
      }
    }
    {
#line 1169
    read_text(& cur_cmd->x.cmd_txt, ch);
    }
#line 1170
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 1173
    if (cur_cmd->a1) {
      {
#line 1174
      tmp___21 = gettext((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses"));
#line 1174
      bad_prog((char const   *)tmp___21);
      }
    }
    {
#line 1175
    tmp___22 = read_label();
#line 1175
    labels = setup_label(labels, vector->v_length, tmp___22, (struct error_info  const  *)((void *)0));
    }
#line 1176
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 1181
    tmp___23 = read_label();
#line 1181
    jumps = setup_label(jumps, vector->v_length, tmp___23, (struct error_info  const  *)((void *)0));
    }
#line 1182
    goto switch_break___0;
    case_113: /* CIL Label */ 
    case_81___0: /* CIL Label */ 
#line 1186
    if (cur_cmd->a2) {
      {
#line 1187
      tmp___24 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1187
      bad_prog((char const   *)tmp___24);
      }
    }
    case_108___0: /* CIL Label */ 
    case_76___0: /* CIL Label */ 
    {
#line 1192
    ch = in_nonblank();
#line 1193
    tmp___26 = __ctype_b_loc();
    }
#line 1193
    if ((int const   )*(*tmp___26 + (int )((unsigned char )ch)) & 2048) {
#line 1193
      if ((unsigned int )posixicity != 2U) {
        {
#line 1195
        tmp___25 = in_integer(ch);
#line 1195
        cur_cmd->x.int_arg = (int )tmp___25;
#line 1196
        ch = in_nonblank();
        }
      } else {
#line 1199
        cur_cmd->x.int_arg = -1;
      }
    } else {
#line 1199
      cur_cmd->x.int_arg = -1;
    }
#line 1201
    if (ch == 125) {
      {
#line 1202
      savchar(ch);
      }
    } else
#line 1201
    if (ch == 35) {
      {
#line 1202
      savchar(ch);
      }
    } else
#line 1203
    if (ch != -1) {
#line 1203
      if (ch != 10) {
#line 1203
        if (ch != 59) {
          {
#line 1204
          tmp___27 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1204
          bad_prog((char const   *)tmp___27);
          }
        }
      }
    }
#line 1206
    goto switch_break___0;
    case_120: /* CIL Label */ 
    case_122___0: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_70___0: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    {
#line 1222
    ch = in_nonblank();
    }
#line 1223
    if (ch == 125) {
      {
#line 1224
      savchar(ch);
      }
    } else
#line 1223
    if (ch == 35) {
      {
#line 1224
      savchar(ch);
      }
    } else
#line 1225
    if (ch != -1) {
#line 1225
      if (ch != 10) {
#line 1225
        if (ch != 59) {
          {
#line 1226
          tmp___28 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1226
          bad_prog((char const   *)tmp___28);
          }
        }
      }
    }
#line 1227
    goto switch_break___0;
    case_114___0: /* CIL Label */ 
    {
#line 1230
    b___0 = read_filename();
#line 1231
    tmp___29 = get_buffer(b___0);
#line 1231
    cur_cmd->x.fname = ck_strdup((char const   *)tmp___29);
#line 1232
    free_buffer(b___0);
    }
#line 1233
    goto switch_break___0;
    case_82___0: /* CIL Label */ 
    {
#line 1236
    tmp___30 = get_openfile(& file_read, (char const   *)read_mode, 0);
#line 1236
    cur_cmd->x.fp = tmp___30->fp;
    }
#line 1237
    goto switch_break___0;
    case_119: /* CIL Label */ 
    case_87___0: /* CIL Label */ 
    {
#line 1241
    cur_cmd->x.outf = get_openfile(& file_write, (char const   *)write_mode, 1);
    }
#line 1242
    goto switch_break___0;
    case_115: /* CIL Label */ 
    {
#line 1250
    slash = inchar();
#line 1251
    b___0 = match_slash(slash, 1);
    }
#line 1251
    if (! b___0) {
      {
#line 1252
      tmp___31 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1252
      bad_prog((char const   *)tmp___31);
      }
    }
    {
#line 1253
    b2 = match_slash(slash, 0);
    }
#line 1253
    if (! b2) {
      {
#line 1254
      tmp___32 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1254
      bad_prog((char const   *)tmp___32);
      }
    }
#line 1256
    __h = & obs;
#line 1256
    __o = __h;
#line 1256
    __len = (int )sizeof(struct subst );
#line 1256
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 1256
      _obstack_newchunk(__o, __len);
      }
    }
#line 1256
    __o->next_free += __len;
#line 1256
    __o1 = __h;
#line 1256
    __value = (void *)__o1->object_base;
#line 1256
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1256
      __o1->maybe_empty_object = 1U;
    }
#line 1256
    if (sizeof(long ) < sizeof(void *)) {
#line 1256
      tmp___33 = __o1->object_base;
    } else {
#line 1256
      tmp___33 = (char *)0;
    }
#line 1256
    if (sizeof(long ) < sizeof(void *)) {
#line 1256
      tmp___34 = __o1->object_base;
    } else {
#line 1256
      tmp___34 = (char *)0;
    }
#line 1256
    __o1->next_free = tmp___33 + (((__o1->next_free - tmp___34) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1256
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1256
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 1256
    __o1->object_base = __o1->next_free;
#line 1256
    cur_cmd->x.cmd_subst = (struct subst *)__value;
#line 1257
    tmp___35 = size_buffer(b2);
#line 1257
    tmp___36 = get_buffer(b2);
#line 1257
    setup_replacement(cur_cmd->x.cmd_subst, (char const   *)tmp___36, tmp___35);
#line 1259
    free_buffer(b2);
#line 1261
    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
#line 1262
    (cur_cmd->x.cmd_subst)->regx = compile_regex(b___0, flags, (int )((cur_cmd->x.cmd_subst)->max_id + 1U));
#line 1264
    free_buffer(b___0);
    }
#line 1266
    goto switch_break___0;
    case_121: /* CIL Label */ 
    {
#line 1275
    slash___0 = inchar();
#line 1276
    b___0 = match_slash(slash___0, 0);
    }
#line 1276
    if (! b___0) {
      {
#line 1277
      tmp___37 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1277
      bad_prog((char const   *)tmp___37);
      }
    }
    {
#line 1278
    src_buf = get_buffer(b___0);
#line 1279
    tmp___38 = size_buffer(b___0);
#line 1279
    len = normalize_text(src_buf, tmp___38, (enum text_types )0);
#line 1281
    b2___0 = match_slash(slash___0, 0);
    }
#line 1281
    if (! b2___0) {
      {
#line 1282
      tmp___39 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1282
      bad_prog((char const   *)tmp___39);
      }
    }
    {
#line 1283
    dest_buf = get_buffer(b2___0);
#line 1284
    tmp___40 = size_buffer(b2___0);
#line 1284
    dest_len = normalize_text(dest_buf, tmp___40, (enum text_types )0);
    }
#line 1286
    if (mb_cur_max > 1) {
      {
#line 1289
      tmp___41 = ck_malloc(len * sizeof(size_t ));
#line 1289
      src_lens = (size_t *)tmp___41;
#line 1295
      memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
#line 1296
      i = 0;
#line 1296
      j = 0;
      }
      {
#line 1296
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1296
        if (! ((size_t )i < len)) {
#line 1296
          goto while_break___2;
        }
#line 1298
        if (mb_cur_max == 1) {
#line 1298
          mbclen = (size_t )1;
        } else {
          {
#line 1298
          tmp___42 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)(src_buf + i),
                             len - (size_t )i, (mbstate_t */* __restrict  */)(& cur_stat));
#line 1298
          mbclen = tmp___42;
          }
        }
#line 1301
        if (mbclen == 0xffffffffffffffffUL) {
#line 1303
          mbclen = (size_t )1;
        } else
#line 1301
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1303
          mbclen = (size_t )1;
        } else
#line 1301
        if (mbclen == 0UL) {
#line 1303
          mbclen = (size_t )1;
        }
#line 1304
        tmp___43 = j;
#line 1304
        j ++;
#line 1304
        *(src_lens + tmp___43) = mbclen;
#line 1305
        i = (int )((size_t )i + mbclen);
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1307
      src_char_num = j;
#line 1309
      memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
#line 1310
      idx = 0;
#line 1316
      tmp___44 = ck_malloc((unsigned long )(2 * src_char_num + 1) * sizeof(char *));
#line 1316
      trans_pairs = (char **)tmp___44;
#line 1317
      cur_cmd->x.translatemb = trans_pairs;
#line 1318
      i = 0;
      }
      {
#line 1318
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1318
        if (! (i < src_char_num)) {
#line 1318
          goto while_break___3;
        }
#line 1320
        if ((size_t )idx >= dest_len) {
          {
#line 1321
          tmp___45 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1321
          bad_prog((char const   *)tmp___45);
          }
        }
        {
#line 1324
        tmp___46 = ck_malloc((*(src_lens + i) + 1UL) * sizeof(char ));
#line 1324
        *(trans_pairs + 2 * i) = (char *)tmp___46;
#line 1325
        strncpy((char */* __restrict  */)*(trans_pairs + 2 * i), (char const   */* __restrict  */)src_buf,
                *(src_lens + i));
#line 1326
        *(*(trans_pairs + 2 * i) + *(src_lens + i)) = (char )'\000';
#line 1327
        src_buf += *(src_lens + i);
        }
#line 1330
        if (mb_cur_max == 1) {
#line 1330
          mbclen = (size_t )1;
        } else {
          {
#line 1330
          tmp___47 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)(dest_buf + idx),
                             dest_len - (size_t )idx, (mbstate_t */* __restrict  */)(& cur_stat));
#line 1330
          mbclen = tmp___47;
          }
        }
#line 1333
        if (mbclen == 0xffffffffffffffffUL) {
#line 1335
          mbclen = (size_t )1;
        } else
#line 1333
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1335
          mbclen = (size_t )1;
        } else
#line 1333
        if (mbclen == 0UL) {
#line 1335
          mbclen = (size_t )1;
        }
        {
#line 1338
        tmp___48 = ck_malloc((mbclen + 1UL) * sizeof(char ));
#line 1338
        *(trans_pairs + (2 * i + 1)) = (char *)tmp___48;
#line 1339
        strncpy((char */* __restrict  */)*(trans_pairs + (2 * i + 1)), (char const   */* __restrict  */)(dest_buf + idx),
                mbclen);
#line 1340
        *(*(trans_pairs + (2 * i + 1)) + mbclen) = (char )'\000';
#line 1341
        idx = (int )((size_t )idx + mbclen);
#line 1318
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1343
      *(trans_pairs + 2 * i) = (char *)((void *)0);
#line 1344
      if ((size_t )idx != dest_len) {
        {
#line 1345
        tmp___49 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1345
        bad_prog((char const   *)tmp___49);
        }
      }
    } else {
#line 1350
      __h___0 = & obs;
#line 1350
      __o___0 = __h___0;
#line 1350
      __len___0 = (int )(256UL * sizeof(unsigned char ));
#line 1350
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
#line 1350
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 1350
      __o___0->next_free += __len___0;
#line 1350
      __o1___0 = __h___0;
#line 1350
      __value___0 = (void *)__o1___0->object_base;
#line 1350
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 1350
        __o1___0->maybe_empty_object = 1U;
      }
#line 1350
      if (sizeof(long ) < sizeof(void *)) {
#line 1350
        tmp___50 = __o1___0->object_base;
      } else {
#line 1350
        tmp___50 = (char *)0;
      }
#line 1350
      if (sizeof(long ) < sizeof(void *)) {
#line 1350
        tmp___51 = __o1___0->object_base;
      } else {
#line 1350
        tmp___51 = (char *)0;
      }
#line 1350
      __o1___0->next_free = tmp___50 + (((__o1___0->next_free - tmp___51) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 1350
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 1350
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 1350
      __o1___0->object_base = __o1___0->next_free;
#line 1350
      translate = (unsigned char *)__value___0;
#line 1351
      ustring = (unsigned char *)src_buf;
#line 1353
      if (len != dest_len) {
        {
#line 1354
        tmp___52 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1354
        bad_prog((char const   *)tmp___52);
        }
      }
#line 1356
      len = (size_t )0;
      {
#line 1356
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1356
        if (! (len < 256UL)) {
#line 1356
          goto while_break___4;
        }
#line 1357
        *(translate + len) = (unsigned char )len;
#line 1356
        len ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1359
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1359
        tmp___55 = dest_len;
#line 1359
        dest_len --;
#line 1359
        if (! tmp___55) {
#line 1359
          goto while_break___5;
        }
#line 1360
        tmp___53 = ustring;
#line 1360
        ustring ++;
#line 1360
        tmp___54 = dest_buf;
#line 1360
        dest_buf ++;
#line 1360
        *(translate + *tmp___53) = (unsigned char )*tmp___54;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1362
      cur_cmd->x.translate = translate;
    }
    {
#line 1365
    ch = in_nonblank();
    }
#line 1365
    if (ch != -1) {
#line 1365
      if (ch != 10) {
#line 1365
        if (ch != 59) {
          {
#line 1366
          tmp___56 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1366
          bad_prog((char const   *)tmp___56);
          }
        }
      }
    }
    {
#line 1368
    free_buffer(b___0);
#line 1369
    free_buffer(b2___0);
    }
#line 1371
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1374
    tmp___57 = gettext((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses"));
#line 1374
    bad_prog((char const   *)tmp___57);
    }
    switch_default: /* CIL Label */ 
    {
#line 1378
    bad_command((char )ch);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1383
    (vector->v_length) ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1385
  if ((unsigned int )posixicity == 2U) {
#line 1385
    if (pending_text) {
      {
#line 1386
      tmp___58 = gettext(((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'"));
#line 1386
      bad_prog((char const   *)tmp___58);
      }
    }
  }
#line 1387
  return (vector);
}
}
#line 1392 "/home/khheo/project/benchmark/sed/sed/compile.c"
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) 
{ 
  char const   *bufend ;
  char *p ;
  char *q ;
  char ch ;
  int base ;
  int bracket_state ;
  int mbclen ;
  mbstate_t cur_stat ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 1398
  bufend = (char const   *)(buf + len);
#line 1399
  p = buf;
#line 1400
  q = buf;
#line 1410
  bracket_state = 0;
#line 1414
  memset((void *)(& cur_stat), 0, sizeof(mbstate_t ));
  }
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1416
    if (! ((unsigned long )p < (unsigned long )bufend)) {
#line 1416
      goto while_break;
    }
#line 1418
    if (mb_cur_max == 1) {
#line 1418
      mbclen = 1;
    } else {
      {
#line 1418
      tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)p,
                    (size_t )(bufend - (char const   *)p), (mbstate_t */* __restrict  */)(& cur_stat));
#line 1418
      mbclen = (int )tmp;
      }
    }
#line 1419
    if (mbclen != 1) {
#line 1423
      if ((size_t )mbclen == 0xffffffffffffffffUL) {
#line 1424
        mbclen = 1;
      } else
#line 1423
      if ((size_t )mbclen == 0xfffffffffffffffeUL) {
#line 1424
        mbclen = 1;
      } else
#line 1423
      if (mbclen == 0) {
#line 1424
        mbclen = 1;
      }
      {
#line 1426
      memmove((void *)q, (void const   *)p, (size_t )mbclen);
#line 1427
      q += mbclen;
#line 1428
      p += mbclen;
      }
#line 1429
      goto while_continue;
    }
#line 1432
    if ((int )*p == 92) {
#line 1432
      if ((unsigned long )(p + 1) < (unsigned long )bufend) {
#line 1432
        if (bracket_state == 0) {
#line 1433
          p ++;
          {
#line 1436
          if ((int )*p == 97) {
#line 1436
            goto case_97;
          }
#line 1441
          if ((int )*p == 102) {
#line 1441
            goto case_102;
          }
#line 1443
          if ((int )*p == 110) {
#line 1443
            goto case_110;
          }
#line 1443
          if ((int )*p == 10) {
#line 1443
            goto case_110;
          }
#line 1444
          if ((int )*p == 114) {
#line 1444
            goto case_114;
          }
#line 1445
          if ((int )*p == 116) {
#line 1445
            goto case_116;
          }
#line 1446
          if ((int )*p == 118) {
#line 1446
            goto case_118;
          }
#line 1448
          if ((int )*p == 100) {
#line 1448
            goto case_100;
          }
#line 1452
          if ((int )*p == 120) {
#line 1452
            goto case_120;
          }
#line 1490
          if ((int )*p == 111) {
#line 1490
            goto case_111;
          }
#line 1502
          if ((int )*p == 99) {
#line 1502
            goto case_99;
          }
#line 1517
          goto switch_default;
          case_97: /* CIL Label */ 
#line 1436
          tmp___0 = q;
#line 1436
          q ++;
#line 1436
          *tmp___0 = (char )'\a';
#line 1436
          p ++;
#line 1436
          goto while_continue;
          case_102: /* CIL Label */ 
#line 1441
          tmp___1 = q;
#line 1441
          q ++;
#line 1441
          *tmp___1 = (char )'\f';
#line 1441
          p ++;
#line 1441
          goto while_continue;
          case_110: /* CIL Label */ 
          case_10: /* CIL Label */ 
#line 1443
          tmp___2 = q;
#line 1443
          q ++;
#line 1443
          *tmp___2 = (char )'\n';
#line 1443
          p ++;
#line 1443
          goto while_continue;
          case_114: /* CIL Label */ 
#line 1444
          tmp___3 = q;
#line 1444
          q ++;
#line 1444
          *tmp___3 = (char )'\r';
#line 1444
          p ++;
#line 1444
          goto while_continue;
          case_116: /* CIL Label */ 
#line 1445
          tmp___4 = q;
#line 1445
          q ++;
#line 1445
          *tmp___4 = (char )'\t';
#line 1445
          p ++;
#line 1445
          goto while_continue;
          case_118: /* CIL Label */ 
#line 1446
          tmp___5 = q;
#line 1446
          q ++;
#line 1446
          *tmp___5 = (char )'\v';
#line 1446
          p ++;
#line 1446
          goto while_continue;
          case_100: /* CIL Label */ 
#line 1449
          base = 10;
#line 1450
          goto convert;
          case_120: /* CIL Label */ 
#line 1453
          base = 16;
#line 1454
          goto convert;
          case_111: /* CIL Label */ 
#line 1491
          base = 8;
          convert: 
          {
#line 1494
          p = convert_number(& ch, p, bufend, base);
          }
#line 1497
          if ((unsigned int )buftype == 1U) {
#line 1497
            if ((int )ch == 38) {
#line 1498
              tmp___6 = q;
#line 1498
              q ++;
#line 1498
              *tmp___6 = (char )'\\';
            }
          }
#line 1499
          tmp___7 = q;
#line 1499
          q ++;
#line 1499
          *tmp___7 = ch;
#line 1500
          goto while_continue;
          case_99: /* CIL Label */ 
#line 1503
          p ++;
#line 1503
          if ((unsigned long )p < (unsigned long )bufend) {
            {
#line 1505
            tmp___8 = q;
#line 1505
            q ++;
#line 1505
            tmp___9 = toupper((int )((unsigned char )*p));
#line 1505
            *tmp___8 = (char )(tmp___9 ^ 64);
#line 1506
            p ++;
            }
#line 1507
            goto while_continue;
          } else {
#line 1512
            if ((unsigned int )buftype != 0U) {
#line 1513
              tmp___10 = q;
#line 1513
              q ++;
#line 1513
              *tmp___10 = (char )'\\';
            }
#line 1514
            goto while_continue;
          }
          switch_default: /* CIL Label */ 
#line 1519
          if ((unsigned int )buftype != 0U) {
#line 1520
            tmp___11 = q;
#line 1520
            q ++;
#line 1520
            *tmp___11 = (char )'\\';
          }
#line 1521
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 1432
          goto _L___0;
        }
      } else {
#line 1432
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1523
    if ((unsigned int )buftype == 2U) {
#line 1523
      if ((unsigned int )posixicity != 0U) {
        {
#line 1526
        if ((int )*p == 91) {
#line 1526
          goto case_91;
        }
#line 1533
        if ((int )*p == 61) {
#line 1533
          goto case_61;
        }
#line 1533
        if ((int )*p == 46) {
#line 1533
          goto case_61;
        }
#line 1533
        if ((int )*p == 58) {
#line 1533
          goto case_61;
        }
#line 1538
        if ((int )*p == 93) {
#line 1538
          goto case_93;
        }
#line 1524
        goto switch_break___0;
        case_91: /* CIL Label */ 
#line 1527
        if (! bracket_state) {
#line 1528
          bracket_state = -1;
        }
#line 1529
        goto switch_break___0;
        case_61: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_58: /* CIL Label */ 
#line 1534
        if (bracket_state == -1) {
#line 1534
          if ((int )*(p + -1) == 91) {
#line 1535
            bracket_state = (int )*p;
          }
        }
#line 1536
        goto switch_break___0;
        case_93: /* CIL Label */ 
#line 1539
        if (! (bracket_state == 0)) {
#line 1541
          if (bracket_state == -1) {
#line 1542
            bracket_state = 0;
          } else
#line 1543
          if ((int )*(p + -2) != bracket_state) {
#line 1543
            if ((int )*(p + -1) == bracket_state) {
#line 1544
              bracket_state = -1;
            }
          }
        }
#line 1545
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1548
    tmp___12 = q;
#line 1548
    q ++;
#line 1548
    tmp___13 = p;
#line 1548
    p ++;
#line 1548
    *tmp___12 = *tmp___13;
  }
  while_break: /* CIL Label */ ;
  }
#line 1550
  return ((size_t )(q - buf));
}
}
#line 1562 "/home/khheo/project/benchmark/sed/sed/compile.c"
static countT string_expr_count  =    (countT )0;
#line 1556 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) 
{ 
  struct vector *ret ;

  {
  {
#line 1565
  prog.file = (FILE *)((void *)0);
#line 1566
  prog.base = (unsigned char const   *)((unsigned char *)str);
#line 1567
  prog.cur = prog.base;
#line 1568
  prog.end = prog.cur + len;
#line 1570
  cur_input.line = (countT )0;
#line 1571
  cur_input.name = (char const   *)((void *)0);
#line 1572
  string_expr_count ++;
#line 1572
  cur_input.string_expr_count = string_expr_count;
#line 1574
  ret = compile_program(cur_program);
#line 1575
  prog.base = (unsigned char const   *)((void *)0);
#line 1576
  prog.cur = (unsigned char const   *)((void *)0);
#line 1577
  prog.end = (unsigned char const   *)((void *)0);
#line 1579
  first_script = (_Bool)0;
  }
#line 1580
  return (ret);
}
}
#line 1586 "/home/khheo/project/benchmark/sed/sed/compile.c"
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) 
{ 
  struct vector *ret ;

  {
#line 1593
  prog.file = stdin;
#line 1594
  if ((int const   )*(cmdfile + 0) != 45) {
    {
#line 1597
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  } else
#line 1594
  if ((int const   )*(cmdfile + 1) != 0) {
    {
#line 1597
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  }
  {
#line 1603
  cur_input.line = (countT )1;
#line 1604
  cur_input.name = cmdfile;
#line 1605
  cur_input.string_expr_count = (countT )0;
#line 1607
  ret = compile_program(cur_program);
  }
#line 1608
  if ((unsigned long )prog.file != (unsigned long )stdin) {
    {
#line 1609
    ck_fclose(prog.file);
    }
  }
#line 1610
  prog.file = (FILE *)((void *)0);
#line 1612
  first_script = (_Bool)0;
#line 1613
  return (ret);
}
}
#line 1619 "/home/khheo/project/benchmark/sed/sed/compile.c"
void check_final_program(struct vector *program ) 
{ 
  struct sed_label *go ;
  struct sed_label *lbl ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  struct output *p ;

  {
#line 1627
  if (blocks) {
    {
#line 1630
    memcpy((void */* __restrict  */)(& cur_input), (void const   */* __restrict  */)(& blocks->err_info),
           sizeof(cur_input));
#line 1631
    tmp = gettext(((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address"));
#line 1631
    bad_prog((char const   *)tmp);
    }
  }
#line 1635
  if (pending_text) {
    {
#line 1637
    old_text_buf->text_length = size_buffer(pending_text);
    }
#line 1638
    if (old_text_buf->text_length) {
      {
#line 1639
      tmp___0 = get_buffer(pending_text);
#line 1639
      tmp___1 = ck_memdup((void const   *)((void *)tmp___0), old_text_buf->text_length * sizeof(char ));
#line 1639
      old_text_buf->text = (char *)tmp___1;
      }
    }
    {
#line 1641
    free_buffer(pending_text);
#line 1642
    pending_text = (struct buffer *)((void *)0);
    }
  }
#line 1645
  go = jumps;
  {
#line 1645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1645
    if (! go) {
#line 1645
      goto while_break;
    }
#line 1647
    lbl = labels;
    {
#line 1647
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1647
      if (! lbl) {
#line 1647
        goto while_break___0;
      }
      {
#line 1648
      tmp___2 = strcmp((char const   *)lbl->name, (char const   *)go->name);
      }
#line 1648
      if (tmp___2 == 0) {
#line 1649
        goto while_break___0;
      }
#line 1647
      lbl = lbl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1650
    if (lbl) {
#line 1652
      (program->v + go->v_index)->x.jump_index = lbl->v_index;
    } else {
#line 1656
      if (*(go->name)) {
        {
#line 1657
        tmp___3 = gettext("can\'t find label for jump to `%s\'");
#line 1657
        panic((char const   *)tmp___3, go->name);
        }
      }
#line 1658
      (program->v + go->v_index)->x.jump_index = program->v_length;
    }
    {
#line 1645
    go = release_label(go);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1661
  jumps = (struct sed_label *)((void *)0);
#line 1663
  lbl = labels;
  {
#line 1663
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1663
    if (! lbl) {
#line 1663
      goto while_break___1;
    }
    {
#line 1663
    lbl = release_label(lbl);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1665
  labels = (struct sed_label *)((void *)0);
#line 1671
  p = file_read;
  {
#line 1671
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1671
    if (! p) {
#line 1671
      goto while_break___2;
    }
#line 1672
    if (p->name) {
      {
#line 1674
      free((void *)p->name);
#line 1675
      p->name = (char *)((void *)0);
      }
    }
#line 1671
    p = p->link;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1678
  p = file_write;
  {
#line 1678
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1678
    if (! p) {
#line 1678
      goto while_break___3;
    }
#line 1679
    if (p->name) {
      {
#line 1681
      free((void *)p->name);
#line 1682
      p->name = (char *)((void *)0);
      }
    }
#line 1678
    p = p->link;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1685
  return;
}
}
#line 1688 "/home/khheo/project/benchmark/sed/sed/compile.c"
void rewind_read_files(void) 
{ 
  struct output *p ;

  {
#line 1693
  p = file_read;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! p) {
#line 1693
      goto while_break;
    }
#line 1694
    if (p->fp) {
      {
#line 1695
      rewind(p->fp);
      }
    }
#line 1693
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1696
  return;
}
}
#line 1699 "/home/khheo/project/benchmark/sed/sed/compile.c"
void finish_program(struct vector *program ) 
{ 
  struct output *p ;
  struct output *q ;

  {
#line 1707
  p = file_read;
  {
#line 1707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1707
    if (! p) {
#line 1707
      goto while_break;
    }
#line 1709
    if (p->fp) {
      {
#line 1710
      ck_fclose(p->fp);
      }
    }
#line 1711
    q = p->link;
#line 1707
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 1718
  p = file_write;
  {
#line 1718
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1718
    if (! p) {
#line 1718
      goto while_break___0;
    }
#line 1720
    if (p->fp) {
      {
#line 1721
      ck_fclose(p->fp);
      }
    }
#line 1722
    q = p->link;
#line 1718
    p = q;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1728
  file_write = (struct output *)((void *)0);
#line 1728
  file_read = file_write;
#line 1734
  return;
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 52 "../lib/stdio.h"
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 52
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1655
#pragma GCC diagnostic pop
#line 60 "../lib/wctype.h"
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 60
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 805
#pragma GCC diagnostic pop
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 202 "/home/khheo/project/benchmark/sed/sed/sed.h"
int main(int argc , char **argv ) ;
#line 225 "/home/khheo/project/benchmark/sed/sed/sed.h"
enum posixicity_types posixicity  ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 37 "/home/khheo/project/benchmark/sed/sed/sed.c"
char *program_name  ;
#line 39 "/home/khheo/project/benchmark/sed/sed/sed.c"
int extended_regexp_flags  =    0;
#line 42 "/home/khheo/project/benchmark/sed/sed/sed.c"
char buffer_delimiter  =    (char )'\n';
#line 45 "/home/khheo/project/benchmark/sed/sed/sed.c"
_Bool unbuffered  =    (_Bool)0;
#line 48 "/home/khheo/project/benchmark/sed/sed/sed.c"
_Bool no_default_output  =    (_Bool)0;
#line 51 "/home/khheo/project/benchmark/sed/sed/sed.c"
_Bool separate_files  =    (_Bool)0;
#line 54 "/home/khheo/project/benchmark/sed/sed/sed.c"
_Bool follow_symlinks  =    (_Bool)0;
#line 57 "/home/khheo/project/benchmark/sed/sed/sed.c"
char *in_place_extension  =    (char *)((void *)0);
#line 60 "/home/khheo/project/benchmark/sed/sed/sed.c"
char *read_mode  =    (char *)"r";
#line 61 "/home/khheo/project/benchmark/sed/sed/sed.c"
char *write_mode  =    (char *)"w";
#line 67 "/home/khheo/project/benchmark/sed/sed/sed.c"
countT lcmd_out_line_len  =    (countT )70;
#line 70 "/home/khheo/project/benchmark/sed/sed/sed.c"
static struct vector *the_program  =    (struct vector *)((void *)0);
#line 72
static void usage(int status ) ;
#line 73 "/home/khheo/project/benchmark/sed/sed/sed.c"
static void contact(int errmsg ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  if (errmsg) {
#line 77
    tmp = stderr;
  } else {
#line 77
    tmp = stdout;
  }
  {
#line 77
  out = tmp;
#line 79
  tmp___0 = gettext("GNU sed home page: <http://www.gnu.org/software/sed/>.\nGeneral help using GNU software: <http://www.gnu.org/gethelp/>.\n");
#line 79
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0);
  }
#line 85
  if (! errmsg) {
    {
#line 86
    tmp___1 = gettext("E-mail bug reports to: <%s>.\nBe sure to include the word ``%s\'\' somewhere in the ``Subject:\'\' field.\n");
#line 86
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
            "bug-sed@gnu.org", "sed");
    }
  }
#line 89
  return;
}
}
#line 92 "/home/khheo/project/benchmark/sed/sed/sed.c"
static void usage(int status ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 96
  if (status) {
#line 96
    tmp = stderr;
  } else {
#line 96
    tmp = stdout;
  }
  {
#line 96
  out = tmp;
#line 104
  tmp___0 = gettext("Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n");
#line 104
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
          myname);
#line 108
  tmp___1 = gettext("  -n, --quiet, --silent\n                 suppress automatic printing of pattern space\n");
#line 108
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1);
#line 110
  tmp___2 = gettext("  -e script, --expression=script\n                 add the script to the commands to be executed\n");
#line 110
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___2);
#line 112
  tmp___3 = gettext("  -f script-file, --file=script-file\n                 add the contents of script-file to the commands to be executed\n");
#line 112
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___3);
#line 115
  tmp___4 = gettext("  --follow-symlinks\n                 follow symlinks when processing in place\n");
#line 115
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___4);
#line 118
  tmp___5 = gettext("  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n");
#line 118
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___5);
#line 124
  tmp___6 = gettext("  -l N, --line-length=N\n                 specify the desired line-wrap length for the `l\' command\n");
#line 124
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___6);
#line 126
  tmp___7 = gettext("  --posix\n                 disable all GNU extensions.\n");
#line 126
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___7);
#line 128
  tmp___8 = gettext("  -r, --regexp-extended\n                 use extended regular expressions in the script.\n");
#line 128
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___8);
#line 133
  tmp___9 = gettext("  -s, --separate\n                 consider files as separate rather than as a single continuous\n                 long stream.\n");
#line 133
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___9);
#line 136
  tmp___10 = gettext("  -u, --unbuffered\n                 load minimal amounts of data from the input files and flush\n                 the output buffers more often\n");
#line 136
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___10);
#line 139
  tmp___11 = gettext("  -z, --null-data\n                 separate lines by NUL characters\n");
#line 139
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___11);
#line 141
  tmp___12 = gettext("      --help     display this help and exit\n");
#line 141
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___12);
#line 142
  tmp___13 = gettext("      --version  output version information and exit\n");
#line 142
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___13);
#line 143
  tmp___14 = gettext("\nIf no -e, --expression, -f, or --file option is given, then the first\nnon-option argument is taken as the sed script to interpret.  All\nremaining arguments are names of input files; if no input files are\nspecified, then the standard input is read.\n\n");
#line 143
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___14);
#line 149
  contact(status);
#line 151
  ck_fclose((FILE *)((void *)0));
#line 152
  exit(status);
  }
}
}
#line 166 "/home/khheo/project/benchmark/sed/sed/sed.c"
static struct option longopts[17]  = 
#line 166
  {      {"binary", 0, (int *)((void *)0), 'b'}, 
        {"regexp-extended", 0, (int *)((void *)0), 'r'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"in-place", 2, (int *)((void *)0), 'i'}, 
        {"line-length", 1, (int *)((void *)0), 'l'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"zero-terminated", 0, (int *)((void *)0), 'z'}, 
        {"quiet", 0, (int *)((void *)0), 'n'}, 
        {"posix", 0, (int *)((void *)0), 'p'}, 
        {"silent", 0, (int *)((void *)0), 'n'}, 
        {"separate", 0, (int *)((void *)0), 's'}, 
        {"unbuffered", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"follow-symlinks", 0, (int *)((void *)0), 'F'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 155 "/home/khheo/project/benchmark/sed/sed/sed.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int return_code ;
  char const   *cols ;
  char *tmp ;
  char *tmp___0 ;
  countT t ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *arg ;
  int tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 193
  tmp = getenv("COLS");
#line 193
  cols = (char const   *)tmp;
#line 195
  program_name = *(argv + 0);
#line 199
  setlocale(6, "");
#line 201
  initialize_mbcs();
#line 206
  bindtextdomain("sed", "/usr/local/share/locale");
#line 207
  textdomain("sed");
#line 210
  tmp___0 = getenv("POSIXLY_CORRECT");
  }
#line 210
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 211
    posixicity = (enum posixicity_types )1;
  } else {
#line 213
    posixicity = (enum posixicity_types )0;
  }
#line 219
  if (cols) {
    {
#line 221
    tmp___1 = atoi(cols);
#line 221
    t = (countT )tmp___1;
    }
#line 222
    if (t > 1UL) {
#line 223
      lcmd_out_line_len = t - 1UL;
    }
  }
#line 226
  myname = (char const   *)*argv;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    opt = getopt_long(argc, (char * const  *)argv, "bsnrzuEe:f:l:i::V:", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    }
#line 227
    if (! (opt != -1)) {
#line 227
      goto while_break;
    }
    {
#line 231
    if (opt == 110) {
#line 231
      goto case_110;
    }
#line 234
    if (opt == 101) {
#line 234
      goto case_101;
    }
#line 237
    if (opt == 102) {
#line 237
      goto case_102;
    }
#line 241
    if (opt == 122) {
#line 241
      goto case_122;
    }
#line 245
    if (opt == 70) {
#line 245
      goto case_70;
    }
#line 249
    if (opt == 105) {
#line 249
      goto case_105;
    }
#line 267
    if (opt == 108) {
#line 267
      goto case_108;
    }
#line 271
    if (opt == 112) {
#line 271
      goto case_112;
    }
#line 275
    if (opt == 98) {
#line 275
      goto case_98;
    }
#line 282
    if (opt == 114) {
#line 282
      goto case_114;
    }
#line 282
    if (opt == 69) {
#line 282
      goto case_114;
    }
#line 296
    if (opt == 115) {
#line 296
      goto case_115;
    }
#line 300
    if (opt == 117) {
#line 300
      goto case_117;
    }
#line 304
    if (opt == 118) {
#line 304
      goto case_118;
    }
#line 310
    if (opt == 104) {
#line 310
      goto case_104;
    }
#line 312
    goto switch_default;
    case_110: /* CIL Label */ 
#line 232
    no_default_output = (_Bool)1;
#line 233
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 235
    tmp___2 = strlen((char const   *)optarg);
#line 235
    the_program = compile_string(the_program, optarg, tmp___2);
    }
#line 236
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 238
    the_program = compile_file(the_program, (char const   *)optarg);
    }
#line 239
    goto switch_break;
    case_122: /* CIL Label */ 
#line 242
    buffer_delimiter = (char)0;
#line 243
    goto switch_break;
    case_70: /* CIL Label */ 
#line 246
    follow_symlinks = (_Bool)1;
#line 247
    goto switch_break;
    case_105: /* CIL Label */ 
#line 250
    separate_files = (_Bool)1;
#line 251
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 253
      in_place_extension = ck_strdup("*");
      }
    } else {
      {
#line 255
      tmp___5 = strchr((char const   *)optarg, '*');
      }
#line 255
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 256
        in_place_extension = ck_strdup((char const   *)optarg);
        }
      } else {
        {
#line 260
        tmp___3 = strlen((char const   *)optarg);
#line 260
        tmp___4 = ck_malloc((tmp___3 + 2UL) * sizeof(char ));
#line 260
        in_place_extension = (char *)tmp___4;
#line 261
        *(in_place_extension + 0) = (char )'*';
#line 262
        strcpy((char */* __restrict  */)(in_place_extension + 1), (char const   */* __restrict  */)optarg);
        }
      }
    }
#line 265
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 268
    tmp___6 = atoi((char const   *)optarg);
#line 268
    lcmd_out_line_len = (countT )tmp___6;
    }
#line 269
    goto switch_break;
    case_112: /* CIL Label */ 
#line 272
    posixicity = (enum posixicity_types )2;
#line 273
    goto switch_break;
    case_98: /* CIL Label */ 
#line 276
    read_mode = (char *)"rb";
#line 277
    write_mode = (char *)"wb";
#line 278
    goto switch_break;
    case_114: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 283
    if (extended_regexp_flags) {
      {
#line 284
      usage(4);
      }
    }
#line 285
    extended_regexp_flags = 1;
#line 286
    goto switch_break;
    case_115: /* CIL Label */ 
#line 297
    separate_files = (_Bool)1;
#line 298
    goto switch_break;
    case_117: /* CIL Label */ 
#line 301
    unbuffered = (_Bool)1;
#line 302
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 305
    tmp___7 = gettext("Paolo Bonzini");
#line 305
    tmp___8 = gettext("Ken Pizzini");
#line 305
    tmp___9 = gettext("Tom Lord");
#line 305
    tmp___10 = gettext("Jay Fenlason");
#line 305
    version_etc(stdout, (char const   *)program_name, "GNU sed", "4.2.2", tmp___10,
                tmp___9, tmp___8, tmp___7, (char *)((void *)0));
#line 307
    contact(0);
#line 308
    ck_fclose((FILE *)((void *)0));
#line 309
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 311
    usage(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 313
    usage(4);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if (! the_program) {
#line 319
    if (optind < argc) {
      {
#line 321
      tmp___11 = optind;
#line 321
      optind ++;
#line 321
      arg = *(argv + tmp___11);
#line 322
      tmp___12 = strlen((char const   *)arg);
#line 322
      the_program = compile_string(the_program, arg, tmp___12);
      }
    } else {
      {
#line 325
      usage(4);
      }
    }
  }
  {
#line 327
  check_final_program(the_program);
#line 329
  return_code = process_files(the_program, argv + optind);
#line 331
  finish_program(the_program);
#line 332
  ck_fclose((FILE *)((void *)0));
  }
#line 334
  return (return_code);
}
}
