/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_190925655 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_964515718 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_190925655 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_1064781011 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_964515718 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_558667438 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_1064781011 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_558667438 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 29 "../../include/bssignal.h"
struct signal ;
#line 29 "../../include/bssignal.h"
typedef struct signal signal_t;
#line 28 "../../include/bsbit.h"
struct bsbit ;
#line 28 "../../include/bsbit.h"
typedef struct bsbit bsbit_t;
#line 40 "../../include/bsbit.h"
struct bsbit {
   int bit ;
   char *name ;
   int type ;
   signal_t *signal ;
   int safe ;
   int control ;
   int control_value ;
   int control_state ;
};
#line 33 "../../include/bssignal.h"
struct signal {
   char *name ;
   char *pin ;
   signal_t *next ;
   bsbit_t *input ;
   bsbit_t *output ;
};
#line 41
struct salias ;
#line 41 "../../include/bssignal.h"
typedef struct salias salias_t;
#line 43 "../../include/bssignal.h"
struct salias {
   char *name ;
   salias_t *next ;
   signal_t *signal ;
};
#line 29 "../../include/register.h"
struct tap_register {
   char *data ;
   int len ;
   char *string ;
};
#line 29 "../../include/register.h"
typedef struct tap_register tap_register;
#line 32 "../../include/data_register.h"
struct data_register ;
#line 32 "../../include/data_register.h"
typedef struct data_register data_register;
#line 34 "../../include/data_register.h"
struct data_register {
   char name[11] ;
   tap_register *in ;
   tap_register *out ;
   data_register *next ;
};
#line 33 "../../include/instruction.h"
struct instruction ;
#line 33 "../../include/instruction.h"
typedef struct instruction instruction;
#line 35 "../../include/instruction.h"
struct instruction {
   char name[21] ;
   tap_register *value ;
   data_register *data_register ;
   instruction *next ;
};
#line 39 "../../include/part.h"
struct part ;
#line 39 "../../include/part.h"
typedef struct part part_t;
#line 41 "../../include/part.h"
struct part {
   tap_register *id ;
   char *alias ;
   char manufacturer[26] ;
   char part[21] ;
   char stepping[9] ;
   signal_t *signals ;
   salias_t *saliases ;
   int instruction_length ;
   instruction *instructions ;
   instruction *active_instruction ;
   data_register *data_registers ;
   int boundary_length ;
   bsbit_t **bsbits ;
};
#line 68
struct parts ;
#line 68 "../../include/part.h"
typedef struct parts parts_t;
#line 70 "../../include/part.h"
struct parts {
   int len ;
   part_t **parts ;
};
#line 30 "../../include/chain.h"
struct chain_t ;
#line 30 "../../include/chain.h"
typedef struct chain_t chain_t;
#line 31 "../../include/cable.h"
struct cable_t ;
#line 31 "../../include/cable.h"
typedef struct cable_t cable_t;
#line 31 "../../include/parport.h"
struct parport_t ;
#line 31 "../../include/parport.h"
typedef struct parport_t parport_t;
#line 35 "../../include/parport.h"
struct __anonstruct_parport_driver_t_422815707 {
   char const   *type ;
   parport_t *(*connect)(char const   ** , int  ) ;
   void (*parport_free)(parport_t * ) ;
   int (*open)(parport_t * ) ;
   int (*close)(parport_t * ) ;
   int (*set_data)(parport_t * , uint8_t  ) ;
   int (*get_data)(parport_t * ) ;
   int (*get_status)(parport_t * ) ;
   int (*set_control)(parport_t * , uint8_t  ) ;
};
#line 35 "../../include/parport.h"
typedef struct __anonstruct_parport_driver_t_422815707 parport_driver_t;
#line 47 "../../include/parport.h"
struct parport_t {
   parport_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 36 "../../include/cable.h"
struct cable_driver_t ;
#line 36 "../../include/cable.h"
typedef struct cable_driver_t cable_driver_t;
#line 38 "../../include/cable.h"
struct cable_driver_t {
   char const   *name ;
   char const   *description ;
   int (*connect)(char **params , cable_t *cable ) ;
   void (*disconnect)(cable_t *cable ) ;
   void (*cable_free)(cable_t *cable ) ;
   int (*init)(cable_t * ) ;
   void (*done)(cable_t * ) ;
   void (*clock)(cable_t * , int  , int  , int  ) ;
   int (*get_tdo)(cable_t * ) ;
   int (*transfer)(cable_t * , int  , char * , char * ) ;
   int (*set_trst)(cable_t * , int  ) ;
   int (*get_trst)(cable_t * ) ;
   void (*help)(char const   * ) ;
};
#line 54 "../../include/cable.h"
struct cable_t {
   cable_driver_t *driver ;
   parport_t *port ;
   void *params ;
   chain_t *chain ;
};
#line 38 "../../include/chain.h"
struct chain_t {
   int state ;
   parts_t *parts ;
   int active_part ;
   cable_t *cable ;
};
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
enum generic_irdr_coding {
    generic_ir = 0,
    generic_dr = 1
} ;
#line 46 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
struct ths_params {
   double number ;
   char *tdi ;
   char *tdo ;
   char *mask ;
   char *smask ;
};
#line 54 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
struct path_states {
   int states[64] ;
   int num_states ;
};
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
struct runtest {
   int run_state ;
   uint32_t run_count ;
   int run_clk ;
   double min_time ;
   double max_time ;
   int end_state ;
};
#line 68
struct YYLTYPE ;
#line 187 "svf_bison.h"
struct YYLTYPE {
   int first_line ;
   int first_column ;
   int last_line ;
   int last_column ;
};
#line 187 "svf_bison.h"
typedef struct YYLTYPE YYLTYPE;
#line 54 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
struct sxr {
   struct ths_params params ;
   int no_tdi ;
   int no_tdo ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 51 "svf_flex.c"
typedef short flex_int16_t;
#line 52 "svf_flex.c"
typedef int flex_int32_t;
#line 151
struct yy_buffer_state ;
#line 151 "svf_flex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 187 "svf_flex.c"
typedef unsigned int yy_size_t;
#line 192 "svf_flex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 338 "svf_flex.c"
typedef unsigned char YY_CHAR;
#line 342 "svf_flex.c"
typedef int yy_state_type;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
struct tdval {
   int token ;
   double dvalue ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
struct tcval {
   int token ;
   char *cvalue ;
   struct tcval *next ;
};
#line 166 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf_bison.h"
union YYSTYPE {
   int token ;
   double dvalue ;
   char *cvalue ;
   int ivalue ;
   struct tdval tdval ;
   struct tcval *tcval ;
};
#line 166 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf_bison.h"
typedef union YYSTYPE YYSTYPE;
#line 220 "svf_flex.l"
struct rwtable {
   char *rw_name ;
   int rw_yylex ;
};
#line 41 "svf_bison.y"
struct svf_parser_params {
   struct ths_params ths_params ;
   struct path_states path_states ;
   struct runtest runtest ;
};
#line 288 "svf_bison.c"
typedef unsigned char yytype_uint8;
#line 295 "svf_bison.c"
typedef signed char yytype_int8;
#line 309 "svf_bison.c"
typedef short yytype_int16;
#line 441 "svf_bison.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
   YYLTYPE yyls ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 40 "../../inclow/brux/bus.h"
struct __anonstruct_bus_area_t_36066931 {
   char const   *description ;
   uint32_t start ;
   uint64_t length ;
   unsigned int width ;
};
#line 40 "../../inclow/brux/bus.h"
typedef struct __anonstruct_bus_area_t_36066931 bus_area_t;
#line 47
struct bus ;
#line 47 "../../inclow/brux/bus.h"
typedef struct bus bus_t;
#line 49 "../../inclow/brux/bus.h"
struct bus_driver {
   char const   *name ;
   char const   *description ;
   bus_t *(*new_bus)(void) ;
   void (*free_bus)(bus_t *bus ) ;
   void (*printinfo)(bus_t *bus ) ;
   void (*prepare)(bus_t *bus ) ;
   int (*area)(bus_t *bus , uint32_t adr , bus_area_t *area ) ;
   void (*read_start)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_next)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_end)(bus_t *bus ) ;
   uint32_t (*read)(bus_t *bus , uint32_t adr ) ;
   void (*write)(bus_t *bus , uint32_t adr , uint32_t data ) ;
   int (*init)(bus_t *bus ) ;
};
#line 49 "../../inclow/brux/bus.h"
typedef struct bus_driver bus_driver_t;
#line 65 "../../inclow/brux/bus.h"
struct bus {
   void *params ;
   bus_driver_t const   *driver ;
};
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
typedef int ctype_t;
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
struct __anonstruct_component_t_641410113 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[25] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *nbyte ;
   signal_t *sts ;
   signal_t *nrp ;
   signal_t *si ;
   signal_t *so ;
   signal_t *sck ;
};
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
typedef struct __anonstruct_component_t_641410113 component_t;
#line 119 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
struct __anonstruct_bus_params_t_385495642 {
   chain_t *chain ;
   part_t *part ;
   component_t flash ;
   component_t ram0 ;
   component_t ram1 ;
   component_t eeprom ;
   component_t eeprom_status ;
};
#line 119 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
typedef struct __anonstruct_bus_params_t_385495642 bus_params_t;
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
struct __anonstruct_bus_params_t_940822640 {
   chain_t *chain ;
   part_t *part ;
   signal_t *oe ;
   signal_t *swe ;
   signal_t *romce[4] ;
   signal_t *sdcs[4] ;
   signal_t *addr[20] ;
   signal_t *data[16] ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
typedef struct __anonstruct_bus_params_t_940822640 bus_params_t___0;
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
struct __anonstruct_bus_params_t_904733789 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ad[20] ;
   signal_t *dq[16] ;
   signal_t *nsdce ;
   signal_t *sdclk ;
   signal_t *noe ;
   signal_t *nsrce ;
   signal_t *nflce ;
   signal_t *nflbyte ;
   signal_t *nflby ;
   signal_t *nwe ;
   signal_t *lcde ;
   signal_t *lcdrs ;
   signal_t *lcdrw ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
typedef struct __anonstruct_bus_params_t_904733789 bus_params_t___1;
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
struct __anonstruct_bus_params_t_496203297 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ma[19] ;
   signal_t *md[8] ;
   signal_t *bms ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
typedef struct __anonstruct_bus_params_t_496203297 bus_params_t___2;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
struct __anonstruct_bus_params_t_68471003 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[8] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *bs ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
typedef struct __anonstruct_bus_params_t_68471003 bus_params_t___3;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
struct __anonstruct_bus_params_t_562361935 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[64] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *rdwr2 ;
   signal_t *rd2 ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
typedef struct __anonstruct_bus_params_t_562361935 bus_params_t___4;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
struct __anonstruct_bus_params_t_562361935___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *md3 ;
   signal_t *md4 ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
typedef struct __anonstruct_bus_params_t_562361935___0 bus_params_t___5;
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
struct __anonstruct_bus_params_t_940822640___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *ncs[6] ;
   signal_t *rd_nwr ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
typedef struct __anonstruct_bus_params_t_940822640___0 bus_params_t___6;
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
struct __anonstruct_bus_params_t_587095632 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[22] ;
   signal_t *d[32] ;
   signal_t *nrcs[6] ;
   signal_t *necs[4] ;
   signal_t *nsdcs[4] ;
   signal_t *nwbe[4] ;
   signal_t *noe ;
   int dbuswidth ;
};
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
typedef struct __anonstruct_bus_params_t_587095632 bus_params_t___7;
#line 67 "../../inclow/arm/pxa2x0/mc.h"
struct MC_registers {
   uint32_t mdcnfg ;
   uint32_t mdrefr ;
   uint32_t msc0 ;
   uint32_t msc1 ;
   uint32_t msc2 ;
   uint32_t mecr ;
   uint32_t __reserved1 ;
   uint32_t sxcnfg ;
   uint32_t __reserved2 ;
   uint32_t sxmrs ;
   uint32_t mcmem0 ;
   uint32_t mcmem1 ;
   uint32_t mcatt0 ;
   uint32_t mcatt1 ;
   uint32_t mcio0 ;
   uint32_t mcio1 ;
   uint32_t mdmrs ;
   uint32_t boot_def ;
   uint32_t __reserved3[4] ;
   uint32_t mdmrslp ;
   uint32_t __reserved4[2] ;
   uint32_t sa1111cr ;
};
#line 67 "../../inclow/arm/pxa2x0/mc.h"
typedef struct MC_registers  volatile  MC_registers_t;
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
struct __anonstruct_ncs_map_entry_788335240 {
   char *sig_name ;
   int enabled ;
   int bus_width ;
   char label_buf[81] ;
};
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
typedef struct __anonstruct_ncs_map_entry_788335240 ncs_map_entry;
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
struct __anonstruct_bus_params_t_536293706 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ma[26] ;
   signal_t *md[32] ;
   signal_t *ncs[6] ;
   signal_t *dqm[4] ;
   signal_t *rdnwr ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *nsdcas ;
   MC_registers_t MC_registers ;
   int inited ;
   int proc ;
};
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
typedef struct __anonstruct_bus_params_t_536293706 bus_params_t___8;
#line 38 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
struct __anonstruct_bus_params_t_594364645 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[32] ;
   signal_t *d[8] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 38 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
typedef struct __anonstruct_bus_params_t_594364645 bus_params_t___9;
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
struct __anonstruct_bus_params_t_594364645___0 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[32] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
typedef struct __anonstruct_bus_params_t_594364645___0 bus_params_t___10;
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
struct __anonstruct_bus_params_t_413197238 {
   chain_t *chain ;
   part_t *part ;
   int boot_nfoe ;
   int boot_sdma1 ;
   uint32_t last_adr ;
   signal_t *ar[23] ;
   signal_t *nrcs0 ;
   signal_t *nwe ;
   signal_t *nfoe ;
   signal_t *d[8] ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
typedef struct __anonstruct_bus_params_t_413197238 bus_params_t___11;
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
struct __anonstruct_bus_params_t_496203297___0 {
   chain_t *chain ;
   part_t *part ;
   uint32_t last_adr ;
   signal_t *ad[24] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *d[8] ;
};
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
typedef struct __anonstruct_bus_params_t_496203297___0 bus_params_t___12;
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
struct __anonstruct_bus_params_t_940822640___1 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[24] ;
   signal_t *d[32] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *width[2] ;
};
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
typedef struct __anonstruct_bus_params_t_940822640___1 bus_params_t___13;
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
struct __anonstruct_component_t_604853148 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[19] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *ncs2 ;
   signal_t *nrdy ;
};
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
typedef struct __anonstruct_component_t_604853148 component_t___0;
#line 100 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
struct __anonstruct_bus_params_t_261477008 {
   chain_t *chain ;
   part_t *part ;
   component_t___0 rama ;
   component_t___0 ramb ;
   component_t___0 flash ;
   signal_t *ser_txd ;
   signal_t *ser_nrts ;
   signal_t *ser_rxd ;
   signal_t *ser_ncts ;
};
#line 100 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
typedef struct __anonstruct_bus_params_t_261477008 bus_params_t___14;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
struct __anonstruct_bus_params_t_594364645___1 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ex_cs[8] ;
   signal_t *ex_addr[24] ;
   signal_t *ex_data[16] ;
   signal_t *ex_wr ;
   signal_t *ex_rd ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
typedef struct __anonstruct_bus_params_t_594364645___1 bus_params_t___15;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
struct __anonstruct_bus_params_t_594364645___2 {
   chain_t *chain ;
   part_t *part ;
   signal_t *a[25] ;
   signal_t *d[32] ;
   signal_t *nRCS[4] ;
   signal_t *nRWE[4] ;
   signal_t *nROE ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
typedef struct __anonstruct_bus_params_t_594364645___2 bus_params_t___16;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
struct __anonstruct_bus_params_t_18421891 {
   chain_t *chain ;
   part_t *part ;
   int initialized ;
   uint32_t impcode ;
   uint16_t adr_hi ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
typedef struct __anonstruct_bus_params_t_18421891 bus_params_t___17;
#line 34 "../../include/bus.h"
struct __anonstruct_buses_t_1042349786 {
   int len ;
   bus_t **buses ;
};
#line 34 "../../include/bus.h"
typedef struct __anonstruct_buses_t_1042349786 buses_t;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
struct __anonstruct_bus_params_t_107014962 {
   chain_t *chain ;
   part_t *part ;
   signal_t *ams[4] ;
   signal_t *addr[19] ;
   signal_t *data[16] ;
   signal_t *pf[2] ;
   signal_t *awe ;
   signal_t *aoe ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms ;
   signal_t *swe ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
typedef struct __anonstruct_bus_params_t_107014962 bus_params_t___18;
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
struct __anonstruct_bus_params_t_594364645___3 {
   chain_t *chain ;
   part_t *part ;
   signal_t *io_ad[32] ;
   signal_t *io_cs_l[7] ;
   signal_t *io_rw ;
   signal_t *io_wr_l ;
   signal_t *io_oe_l ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
typedef struct __anonstruct_bus_params_t_594364645___3 bus_params_t___19;
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
struct __anonstruct_bus_params_t_594364645___4 {
   chain_t *chain ;
   part_t *part ;
   signal_t *rad[32] ;
   signal_t *nrcs[4] ;
   signal_t *nrwe ;
   signal_t *nroe ;
   signal_t *rd[32] ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
typedef struct __anonstruct_bus_params_t_594364645___4 bus_params_t___20;
#line 37 "./../inclow/brux/cmd.h"
struct __anonstruct_cmd_t_148900231 {
   char *name ;
   char *desc ;
   void (*help)(void) ;
   int (*run)(char **params ) ;
};
#line 37 "./../inclow/brux/cmd.h"
typedef struct __anonstruct_cmd_t_148900231 cmd_t;
#line 178 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 180 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 66 "./../inclow/device/flash/cfi.h"
struct cfi_query_identification_string {
   uint16_t pri_id_code ;
   void *pri_vendor_tbl ;
   uint16_t alt_id_code ;
   void *alt_vendor_tbl ;
};
#line 66 "./../inclow/device/flash/cfi.h"
typedef struct cfi_query_identification_string cfi_query_identification_string_t;
#line 101 "./../inclow/device/flash/cfi.h"
struct cfi_query_system_interface_information {
   uint16_t vcc_min_wev ;
   uint16_t vcc_max_wev ;
   uint16_t vpp_min_wev ;
   uint16_t vpp_max_wev ;
   uint32_t typ_single_write_timeout ;
   uint32_t typ_buffer_write_timeout ;
   uint32_t typ_block_erase_timeout ;
   uint32_t typ_chip_erase_timeout ;
   uint32_t max_single_write_timeout ;
   uint32_t max_buffer_write_timeout ;
   uint32_t max_block_erase_timeout ;
   uint32_t max_chip_erase_timeout ;
};
#line 101 "./../inclow/device/flash/cfi.h"
typedef struct cfi_query_system_interface_information cfi_query_system_interface_information_t;
#line 126
struct cfi_erase_block_region ;
#line 126 "./../inclow/device/flash/cfi.h"
typedef struct cfi_erase_block_region cfi_erase_block_region_t;
#line 128 "./../inclow/device/flash/cfi.h"
struct cfi_device_geometry {
   uint32_t device_size ;
   uint16_t device_interface ;
   uint32_t max_bytes_write ;
   uint8_t number_of_erase_regions ;
   cfi_erase_block_region_t *erase_block_regions ;
};
#line 128 "./../inclow/device/flash/cfi.h"
typedef struct cfi_device_geometry cfi_device_geometry_t;
#line 136 "./../inclow/device/flash/cfi.h"
struct cfi_erase_block_region {
   uint32_t erase_block_size ;
   uint32_t number_of_erase_blocks ;
};
#line 153 "./../inclow/device/flash/cfi.h"
struct cfi_query_structure {
   cfi_query_identification_string_t identification_string ;
   cfi_query_system_interface_information_t system_interface_info ;
   cfi_device_geometry_t device_geometry ;
};
#line 153 "./../inclow/device/flash/cfi.h"
typedef struct cfi_query_structure cfi_query_structure_t;
#line 42 "./../inclow/brux/cfi.h"
struct __anonstruct_cfi_chip_t_960872676 {
   int width ;
   cfi_query_structure_t cfi ;
};
#line 42 "./../inclow/brux/cfi.h"
typedef struct __anonstruct_cfi_chip_t_960872676 cfi_chip_t;
#line 47 "./../inclow/brux/cfi.h"
struct __anonstruct_cfi_array_t_656102674 {
   bus_t *bus ;
   uint32_t address ;
   int bus_width ;
   cfi_chip_t **cfi_chips ;
};
#line 47 "./../inclow/brux/cfi.h"
typedef struct __anonstruct_cfi_array_t_656102674 cfi_array_t;
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
struct mtd_erase_region_info {
   u_int32_t offset ;
   u_int32_t erasesize ;
   u_int32_t numblocks ;
};
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
struct amd_flash_info {
   int const   mfr_id ;
   int const   dev_id ;
   char const   *name ;
   long const   size ;
   u_int8_t const   interface_width ;
   int const   as_method ;
   int const   numeraseregions ;
   struct mtd_erase_region_info  const  regions[4] ;
};
#line 43 "./../inclow/brux/flash.h"
struct __anonstruct_flash_driver_t_660044769 {
   unsigned int bus_width ;
   char const   *name ;
   char const   *description ;
   int (*autodetect)(cfi_array_t *cfi_array ) ;
   void (*print_info)(cfi_array_t *cfi_array ) ;
   int (*erase_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*unlock_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*program)(cfi_array_t *cfi_array , uint32_t adr , uint32_t data ) ;
   void (*readarray)(cfi_array_t *cfi_array ) ;
};
#line 43 "./../inclow/brux/flash.h"
typedef struct __anonstruct_flash_driver_t_660044769 flash_driver_t;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 {
   unsigned long flash ;
   unsigned short algorithm ;
   unsigned short unlock_bypass ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 277 "/usr/include/usb.h"
struct usb_dev_handle ;
#line 278 "/usr/include/usb.h"
typedef struct usb_dev_handle usb_dev_handle;
#line 48 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
struct __anonstruct_xpcu_params_t_840885179 {
   char *serial ;
   unsigned int vendor_id ;
   unsigned int product_id ;
   usb_dev_handle *dev ;
};
#line 48 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
typedef struct __anonstruct_xpcu_params_t_840885179 xpcu_params_t;
#line 57
struct port_node_t ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
typedef struct port_node_t port_node_t;
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
struct port_node_t {
   parport_t *port ;
   port_node_t *next ;
};
#line 94 "/usr/include/usb.h"
struct usb_endpoint_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bEndpointAddress ;
   uint8_t bmAttributes ;
   uint16_t wMaxPacketSize ;
   uint8_t bInterval ;
   uint8_t bRefresh ;
   uint8_t bSynchAddress ;
   unsigned char *extra ;
   int extralen ;
};
#line 119 "/usr/include/usb.h"
struct usb_interface_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bInterfaceNumber ;
   uint8_t bAlternateSetting ;
   uint8_t bNumEndpoints ;
   uint8_t bInterfaceClass ;
   uint8_t bInterfaceSubClass ;
   uint8_t bInterfaceProtocol ;
   uint8_t iInterface ;
   struct usb_endpoint_descriptor *endpoint ;
   unsigned char *extra ;
   int extralen ;
};
#line 137 "/usr/include/usb.h"
struct usb_interface {
   struct usb_interface_descriptor *altsetting ;
   int num_altsetting ;
};
#line 145 "/usr/include/usb.h"
struct usb_config_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t wTotalLength ;
   uint8_t bNumInterfaces ;
   uint8_t bConfigurationValue ;
   uint8_t iConfiguration ;
   uint8_t bmAttributes ;
   uint8_t MaxPower ;
   struct usb_interface *interface ;
   unsigned char *extra ;
   int extralen ;
};
#line 162 "/usr/include/usb.h"
struct usb_device_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t bcdUSB ;
   uint8_t bDeviceClass ;
   uint8_t bDeviceSubClass ;
   uint8_t bDeviceProtocol ;
   uint8_t bMaxPacketSize0 ;
   uint16_t idVendor ;
   uint16_t idProduct ;
   uint16_t bcdDevice ;
   uint8_t iManufacturer ;
   uint8_t iProduct ;
   uint8_t iSerialNumber ;
   uint8_t bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 235
struct usb_device ;
#line 236
struct usb_bus ;
#line 248 "/usr/include/usb.h"
struct usb_device {
   struct usb_device *next ;
   struct usb_device *prev ;
   char filename[4097] ;
   struct usb_bus *bus ;
   struct usb_device_descriptor descriptor ;
   struct usb_config_descriptor *config ;
   void *dev ;
   uint8_t devnum ;
   unsigned char num_children ;
   struct usb_device **children ;
};
#line 266 "/usr/include/usb.h"
struct usb_bus {
   struct usb_bus *next ;
   struct usb_bus *prev ;
   char dirname[4097] ;
   struct usb_device *devices ;
   uint32_t location ;
   struct usb_device *root_dev ;
};
#line 31 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.h"
struct __anonstruct_generic_params_t_773697287 {
   int trst ;
   int sreset ;
};
#line 31 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.h"
typedef struct __anonstruct_generic_params_t_773697287 generic_params_t;
#line 56 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
struct __anonstruct_ppdev_params_t_951761807 {
   char *portname ;
   int fd ;
};
#line 56 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
typedef struct __anonstruct_ppdev_params_t_951761807 ppdev_params_t;
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
struct __anonstruct_direct_params_t_422959015 {
   unsigned int port ;
};
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
typedef struct __anonstruct_direct_params_t_422959015 direct_params_t;
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/detect.c"
struct id_record {
   char name[20] ;
   char fullname[100] ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 775
extern void perror(char const   *__s ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 159 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 165
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 455 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value ,
                                                                                      __useconds_t __interval ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 35 "../../include/register.h"
tap_register *register_alloc(int len ) ;
#line 37
void register_free(tap_register *tr ) ;
#line 39
char const   *register_get_string(tap_register const   *tr ) ;
#line 40
tap_register *register_init(tap_register *tr , char const   *value ) ;
#line 60 "../../include/part.h"
instruction *part_find_instruction(part_t *p , char const   *iname ) ;
#line 61
data_register *part_find_data_register(part_t *p , char const   *drname ) ;
#line 63
void part_set_instruction(part_t *p , char const   *iname ) ;
#line 66 "../../include/cable.h"
int cable_set_trst(cable_t *cable , int trst ) ;
#line 70
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 71
uint32_t cable_get_frequency(cable_t *cable ) ;
#line 48 "../../include/chain.h"
void chain_clock(chain_t *chain___0 , int tms , int tdi , int n ) ;
#line 52
void chain_shift_instructions_mode(chain_t *chain___0 , int capture , int exit___0 ) ;
#line 54
void chain_shift_data_registers_mode(chain_t *chain___0 , int capture_output , int capture ,
                                     int exit___0 ) ;
#line 37 "../../include/jtag.h"
chain_t *chain ;
#line 59 "../../include/state.h"
int tap_state(chain_t *chain___0 ) ;
#line 62
int tap_state_reset(chain_t *chain___0 ) ;
#line 46 "../../inclow/brux/cmd.h"
int cmd_run(char **params ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.h"
void svf_endxr(enum generic_irdr_coding ir_dr , int state ) ;
#line 71
void svf_frequency(double freq ) ;
#line 72
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 73
int svf_runtest(struct runtest *params ) ;
#line 74
int svf_state(struct path_states *path_states , int stable_state ) ;
#line 75
int svf_sxr(enum generic_irdr_coding ir_dr , struct ths_params *params , struct YYLTYPE *loc ) ;
#line 76
int svf_trst(int trst_mode ) ;
#line 77
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 51 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int yyparse(void) ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
FILE *yyin  =    (FILE *)0;
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
FILE *yyout  =    (FILE *)0;
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_stop_on_mismatch  ;
#line 65 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static part_t *part  ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static instruction *ir  ;
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static data_register *dr  ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static struct sxr sir_params  ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static struct sxr sdr_params  ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int endir  ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int enddr  ;
#line 76 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int runtest_run_state  ;
#line 76 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int runtest_end_state  ;
#line 79 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_trst_absent  ;
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_state_executed  ;
#line 83 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int issued_sir_tdo  ;
#line 84 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int issued_runtest_maxtime  ;
#line 92 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static void svf_force_reset_state(void) 
{ 


  {
  {
#line 95
  chain_clock(chain, 1, 0, 5);
#line 96
  tap_state_reset(chain);
  }
#line 97
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static void svf_goto_state(int new_state ) 
{ 
  int current_state ;

  {
  {
#line 117
  current_state = tap_state(chain);
  }
#line 120
  if (new_state == 1 << 7) {
#line 121
    new_state = (1 << 7) | (1 << 3);
  }
#line 124
  if (current_state == new_state) {
#line 125
    return;
  }
  {
#line 128
  if (current_state == ((1 << 7) | (1 << 3))) {
#line 128
    goto case_exp;
  }
#line 132
  if (current_state == 1 << 3) {
#line 132
    goto case_exp___0;
  }
#line 137
  if (current_state == 1 << 1) {
#line 137
    goto case_exp___1;
  }
#line 137
  if (current_state == 1) {
#line 137
    goto case_exp___1;
  }
#line 149
  if (current_state == ((1 | (1 << 2)) | (1 << 4))) {
#line 149
    goto case_exp___2;
  }
#line 158
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 158
    goto case_exp___3;
  }
#line 168
  if (current_state == ((1 << 1) | (1 << 2))) {
#line 168
    goto case_exp___4;
  }
#line 168
  if (current_state == (1 | (1 << 2))) {
#line 168
    goto case_exp___4;
  }
#line 173
  if (current_state == ((1 | (1 << 5)) | (1 << 6))) {
#line 173
    goto case_exp___6;
  }
#line 182
  if (current_state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 182
    goto case_exp___7;
  }
#line 192
  if (current_state == ((1 << 1) | (1 << 6))) {
#line 192
    goto case_exp___8;
  }
#line 192
  if (current_state == (1 | (1 << 6))) {
#line 192
    goto case_exp___8;
  }
#line 197
  if (current_state == ((1 | (1 << 2)) | (1 << 5))) {
#line 197
    goto case_exp___10;
  }
#line 206
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 206
    goto case_exp___11;
  }
#line 216
  if (current_state == ((1 << 1) | (1 << 3))) {
#line 216
    goto case_exp___12;
  }
#line 216
  if (current_state == (1 | (1 << 3))) {
#line 216
    goto case_exp___12;
  }
#line 225
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 129
  chain_clock(chain, 0, 0, 1);
  }
#line 130
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 133
  chain_clock(chain, 1, 0, 1);
  }
#line 134
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 138
  if (new_state == ((1 << 7) | (1 << 3))) {
    {
#line 143
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 138
  if (new_state == 1 << 3) {
    {
#line 143
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 138
  if (current_state & 1) {
#line 138
    if (new_state & (1 << 1)) {
      {
#line 143
      chain_clock(chain, 1, 0, 1);
      }
    } else {
#line 138
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 138
  if (current_state & (1 << 1)) {
#line 138
    if (new_state & 1) {
      {
#line 143
      chain_clock(chain, 1, 0, 1);
      }
    } else {
      {
#line 146
      chain_clock(chain, 0, 0, 1);
      }
    }
  } else {
    {
#line 146
    chain_clock(chain, 0, 0, 1);
    }
  }
#line 147
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 150
  if (new_state == (1 | (1 << 2))) {
    {
#line 152
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 155
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 156
  goto switch_break;
  case_exp___3: /* CIL Label */ 
#line 159
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 161
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 164
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 165
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  {
#line 170
  chain_clock(chain, 1, 0, 1);
  }
#line 171
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 174
  if (new_state == (1 | (1 << 6))) {
    {
#line 176
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 179
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 180
  goto switch_break;
  case_exp___7: /* CIL Label */ 
#line 183
  if (new_state == ((1 << 1) | (1 << 6))) {
    {
#line 185
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 188
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 189
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  {
#line 194
  chain_clock(chain, 1, 0, 1);
  }
#line 195
  goto switch_break;
  case_exp___10: /* CIL Label */ 
#line 198
  if (new_state == (1 | (1 << 2))) {
    {
#line 200
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 203
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 204
  goto switch_break;
  case_exp___11: /* CIL Label */ 
#line 207
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 209
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 212
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 213
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
#line 217
  if (new_state == 1 << 3) {
    {
#line 219
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 222
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 223
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 226
  svf_force_reset_state();
  }
#line 227
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 231
  svf_goto_state(new_state);
  }
#line 232
  return;
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_map_state(int state ) 
{ 
  int jtag_state ;

  {
  {
#line 253
  if (state == 268) {
#line 253
    goto case_268;
  }
#line 256
  if (state == 269) {
#line 256
    goto case_269;
  }
#line 259
  if (state == 311) {
#line 259
    goto case_311;
  }
#line 262
  if (state == 314) {
#line 262
    goto case_314;
  }
#line 265
  if (state == 309) {
#line 265
    goto case_309;
  }
#line 268
  if (state == 312) {
#line 268
    goto case_312;
  }
#line 271
  if (state == 308) {
#line 271
    goto case_308;
  }
#line 274
  if (state == 313) {
#line 274
    goto case_313;
  }
#line 277
  if (state == 310) {
#line 277
    goto case_310;
  }
#line 281
  if (state == 304) {
#line 281
    goto case_304;
  }
#line 284
  if (state == 307) {
#line 284
    goto case_307;
  }
#line 287
  if (state == 302) {
#line 287
    goto case_302;
  }
#line 290
  if (state == 305) {
#line 290
    goto case_305;
  }
#line 293
  if (state == 301) {
#line 293
    goto case_301;
  }
#line 296
  if (state == 306) {
#line 296
    goto case_306;
  }
#line 299
  if (state == 303) {
#line 299
    goto case_303;
  }
#line 303
  goto switch_default;
  case_268: /* CIL Label */ 
#line 254
  jtag_state = (1 << 7) | (1 << 3);
#line 255
  goto switch_break;
  case_269: /* CIL Label */ 
#line 257
  jtag_state = 1 << 3;
#line 258
  goto switch_break;
  case_311: /* CIL Label */ 
#line 260
  jtag_state = 1;
#line 261
  goto switch_break;
  case_314: /* CIL Label */ 
#line 263
  jtag_state = (1 | (1 << 2)) | (1 << 4);
#line 264
  goto switch_break;
  case_309: /* CIL Label */ 
#line 266
  jtag_state = 1 | (1 << 2);
#line 267
  goto switch_break;
  case_312: /* CIL Label */ 
#line 269
  jtag_state = (1 | (1 << 5)) | (1 << 6);
#line 270
  goto switch_break;
  case_308: /* CIL Label */ 
#line 272
  jtag_state = 1 | (1 << 6);
#line 273
  goto switch_break;
  case_313: /* CIL Label */ 
#line 275
  jtag_state = (1 | (1 << 2)) | (1 << 5);
#line 276
  goto switch_break;
  case_310: /* CIL Label */ 
#line 278
  jtag_state = 1 | (1 << 3);
#line 279
  goto switch_break;
  case_304: /* CIL Label */ 
#line 282
  jtag_state = 1 << 1;
#line 283
  goto switch_break;
  case_307: /* CIL Label */ 
#line 285
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 286
  goto switch_break;
  case_302: /* CIL Label */ 
#line 288
  jtag_state = (1 << 1) | (1 << 2);
#line 289
  goto switch_break;
  case_305: /* CIL Label */ 
#line 291
  jtag_state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 292
  goto switch_break;
  case_301: /* CIL Label */ 
#line 294
  jtag_state = (1 << 1) | (1 << 6);
#line 295
  goto switch_break;
  case_306: /* CIL Label */ 
#line 297
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 298
  goto switch_break;
  case_303: /* CIL Label */ 
#line 300
  jtag_state = (1 << 1) | (1 << 3);
#line 301
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 304
  jtag_state = 1 << 7;
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 308
  return (jtag_state);
}
}
#line 323 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_hex2dec(char nibble ) 
{ 
  int lower ;

  {
#line 328
  if ((int )nibble >= 48) {
#line 328
    if ((int )nibble <= 57) {
#line 329
      return ((int )nibble - 48);
    }
  }
  {
#line 331
  lower = tolower((int )nibble);
  }
#line 332
  if (lower >= 97) {
#line 332
    if (lower <= 102) {
#line 333
      return ((lower - 97) + 10);
    }
  }
#line 335
  return (0);
}
}
#line 364 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static char *svf_build_bit_string(char *hex_string , int len ) 
{ 
  char *bit_string ;
  char *bit_string_pos ;
  int nibble ;
  char *hex_string_pos ;
  int hex_string_idx ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 372
  tmp___0 = calloc((size_t )(len + 1), sizeof(char ));
#line 372
  bit_string = (char *)tmp___0;
  }
#line 372
  if (! bit_string) {
    {
#line 373
    tmp = gettext("out of memory");
#line 373
    printf((char const   */* __restrict  */)tmp);
    }
#line 374
    return ((char *)((void *)0));
  }
  {
#line 378
  tmp___1 = strlen((char const   *)hex_string);
#line 378
  hex_string_idx = (int )tmp___1;
#line 379
  hex_string_pos = hex_string + hex_string_idx;
#line 380
  nibble = 3;
#line 381
  bit_string_pos = bit_string + len;
  }
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    bit_string_pos --;
#line 384
    if (nibble == 3) {
#line 385
      nibble = 0;
#line 386
      hex_string_pos --;
#line 387
      hex_string_idx --;
    } else {
#line 389
      nibble ++;
    }
#line 391
    if (hex_string_idx >= 0) {
#line 391
      tmp___4 = (int )*hex_string_pos;
    } else {
#line 391
      tmp___4 = '0';
    }
    {
#line 391
    tmp___5 = svf_hex2dec((char )tmp___4);
    }
#line 391
    if (tmp___5 & (1 << nibble)) {
#line 391
      *bit_string_pos = (char )'1';
    } else {
#line 391
      *bit_string_pos = (char )'0';
    }
#line 382
    if (! ((unsigned long )bit_string_pos != (unsigned long )bit_string)) {
#line 382
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  *(bit_string + len) = (char )'\000';
#line 396
  return (bit_string);
}
}
#line 414 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_copy_hex_to_register(char *hex_string , tap_register *reg ) 
{ 
  char *bit_string ;

  {
  {
#line 419
  bit_string = svf_build_bit_string(hex_string, reg->len);
  }
#line 419
  if (! bit_string) {
#line 420
    return (0);
  }
  {
#line 422
  register_init(reg, (char const   *)bit_string);
#line 425
  free((void *)bit_string);
  }
#line 427
  return (1);
}
}
#line 449 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_compare_tdo(char *tdo , char *mask , tap_register *reg , YYLTYPE *loc ) 
{ 
  char *tdo_bit ;
  char *mask_bit ;
  int pos ;
  int mismatch ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 453
  result = 1;
#line 455
  tdo_bit = svf_build_bit_string(tdo, reg->len);
  }
#line 455
  if (! tdo_bit) {
#line 456
    return (0);
  }
  {
#line 457
  mask_bit = svf_build_bit_string(mask, reg->len);
  }
#line 457
  if (! mask_bit) {
    {
#line 458
    free((void *)tdo_bit);
    }
#line 459
    return (0);
  }
  {
#line 463
  register_get_string((tap_register const   *)reg);
#line 465
  mismatch = -1;
#line 466
  pos = 0;
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! (pos < reg->len)) {
#line 466
      goto while_break;
    }
    {
#line 467
    tmp = svf_hex2dec(*(tdo_bit + pos));
#line 467
    tmp___0 = svf_hex2dec(*(mask_bit + pos));
    }
#line 467
    if ((tmp ^ (int )*(reg->string + pos)) & tmp___0) {
#line 468
      mismatch = pos;
    }
#line 466
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  if (mismatch >= 0) {
    {
#line 471
    tmp___1 = gettext("Error %s: mismatch at position %d for TDO\n");
#line 471
    printf((char const   */* __restrict  */)tmp___1, "svf", mismatch);
    }
#line 472
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 473
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 479
    if (svf_stop_on_mismatch) {
#line 480
      result = 0;
    }
  }
  {
#line 483
  free((void *)mask_bit);
#line 484
  free((void *)tdo_bit);
  }
#line 486
  return (result);
}
}
#line 504 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static void svf_remember_param(char **rem , char *new ) 
{ 


  {
#line 507
  if (new) {
#line 508
    if (*rem) {
      {
#line 509
      free((void *)*rem);
      }
    }
#line 511
    *rem = new;
  }
#line 513
  return;
}
}
#line 531 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int svf_all_care(char **string , double number ) 
{ 
  char *ptr ;
  int num ;
  int result ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 537
  result = 1;
#line 539
  num = (int )number;
#line 540
  if (num % 4 == 0) {
#line 540
    num /= 4;
  } else {
#line 540
    num = num / 4 + 1;
  }
  {
#line 543
  tmp___0 = calloc((size_t )(num + 1), sizeof(char ));
#line 543
  ptr = (char *)tmp___0;
  }
#line 543
  if (! ptr) {
    {
#line 544
    tmp = gettext("out of memory");
#line 544
    printf((char const   */* __restrict  */)tmp);
    }
#line 545
    return (0);
  }
  {
#line 547
  memset((void *)ptr, 'F', (size_t )num);
#line 548
  *(ptr + num) = (char )'\000';
#line 550
  svf_remember_param(string, ptr);
  }
#line 554
  return (result);
}
}
#line 567 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
void svf_endxr(enum generic_irdr_coding ir_dr , int state ) 
{ 


  {
  {
#line 571
  if ((unsigned int )ir_dr == 0U) {
#line 571
    goto case_0;
  }
#line 574
  if ((unsigned int )ir_dr == 1U) {
#line 574
    goto case_1;
  }
#line 570
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 572
  endir = svf_map_state(state);
  }
#line 573
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 575
  enddr = svf_map_state(state);
  }
#line 576
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 589 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
void svf_frequency(double freq ) 
{ 


  {
  {
#line 592
  cable_set_frequency(chain->cable, (uint32_t )freq);
  }
#line 593
  return;
}
}
#line 612 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 615
  if (params->number != 0.0) {
#line 616
    if ((unsigned int )ir_dr == 0U) {
#line 616
      tmp = "HIR";
    } else {
#line 616
      tmp = "HDR";
    }
    {
#line 616
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 616
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 619
  return (1);
}
}
#line 623 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static int max_time_reached  ;
#line 624 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
static void sigalrm_handler(int signal___0 ) 
{ 


  {
#line 626
  max_time_reached = 1;
#line 627
  return;
}
}
#line 642 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_runtest(struct runtest *params ) 
{ 
  uint32_t run_count ;
  uint32_t frequency___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t min_time_run_count ;
  double tmp___3 ;
  struct sigaction sa ;
  unsigned int max_time ;
  int tmp___5 ;
  double tmp___6 ;
  uint32_t tmp___7 ;
  struct sigaction sa___0 ;
  int tmp___8 ;

  {
#line 648
  if (params->run_count > 0U) {
#line 648
    if (params->run_clk != 298) {
      {
#line 649
      tmp = gettext("Error %s: only TCK is supported for RUNTEST.\n");
#line 649
      printf((char const   */* __restrict  */)tmp, "svf");
      }
#line 650
      return (0);
    }
  }
#line 652
  if (params->max_time > 0.0) {
#line 652
    if (params->max_time < params->min_time) {
      {
#line 653
      tmp___0 = gettext("Error %s: maximum time must be larger or equal to minimum time.\n");
#line 653
      printf((char const   */* __restrict  */)tmp___0, "svf");
      }
#line 655
      return (0);
    }
  }
#line 657
  if (params->max_time > 0.0) {
#line 658
    if (! issued_runtest_maxtime) {
      {
#line 659
      tmp___1 = gettext("Warning %s: maximum time for RUNTEST not guaranteed.\n");
#line 659
      printf((char const   */* __restrict  */)tmp___1, "svf");
#line 660
      tmp___2 = gettext(" This message is only displayed once.\n");
#line 660
      printf((char const   */* __restrict  */)tmp___2);
#line 661
      issued_runtest_maxtime = 1;
      }
    }
  }
#line 665
  if (params->run_state != 0) {
    {
#line 666
    runtest_run_state = svf_map_state(params->run_state);
    }
#line 668
    if (params->end_state == 0) {
      {
#line 669
      runtest_end_state = svf_map_state(params->run_state);
      }
    }
  }
#line 671
  if (params->end_state != 0) {
    {
#line 672
    runtest_end_state = svf_map_state(params->end_state);
    }
  }
  {
#line 675
  run_count = params->run_count;
#line 676
  frequency___0 = cable_get_frequency(chain->cable);
  }
#line 677
  if (frequency___0 > 0U) {
    {
#line 678
    tmp___3 = ceil(params->min_time / (double )frequency___0);
#line 678
    min_time_run_count = (uint32_t )tmp___3;
    }
#line 679
    if (min_time_run_count > run_count) {
#line 680
      run_count = min_time_run_count;
    }
  }
#line 683
  if (! (run_count > 0U)) {
    {
#line 683
    __assert_fail("run_count > 0", "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c",
                  683U, "svf_runtest");
    }
  }
  {
#line 685
  svf_goto_state(runtest_run_state);
  }
#line 688
  if (params->max_time > 0.0) {
    {
#line 692
    sa.__sigaction_handler.sa_handler = & sigalrm_handler;
#line 693
    sa.sa_flags = (-0x7FFFFFFF-1);
#line 694
    sigemptyset(& sa.sa_mask);
#line 695
    tmp___5 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
    }
#line 695
    if (tmp___5 != 0) {
      {
#line 696
      perror("sigaction");
#line 697
      exit(1);
      }
    }
    {
#line 700
    tmp___6 = floor(params->max_time / (double )1000000);
#line 700
    max_time = (unsigned int )tmp___6;
    }
#line 701
    if (max_time == 0U) {
#line 702
      max_time = 1U;
    }
    {
#line 704
    ualarm(max_time, (__useconds_t )0);
    }
  }
#line 707
  if (params->max_time > 0.0) {
    {
#line 708
    while (1) {
      while_continue: /* CIL Label */ ;
#line 708
      tmp___7 = run_count;
#line 708
      run_count --;
#line 708
      if (tmp___7 > 0U) {
#line 708
        if (! (! max_time_reached)) {
#line 708
          goto while_break;
        }
      } else {
#line 708
        goto while_break;
      }
      {
#line 709
      chain_clock(chain, 0, 0, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 712
    chain_clock(chain, 0, 0, (int )run_count);
    }
  }
  {
#line 714
  svf_goto_state(runtest_end_state);
  }
#line 717
  if (params->max_time > 0.0) {
    {
#line 719
    sa___0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 720
    sa___0.sa_flags = 0;
#line 721
    sigemptyset(& sa___0.sa_mask);
#line 722
    tmp___8 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa___0),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 722
    if (tmp___8 != 0) {
      {
#line 723
      perror("sigaction");
#line 724
      exit(1);
      }
    }
  }
#line 728
  return (1);
}
}
#line 747 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_state(struct path_states *path_states , int stable_state ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 752
  svf_state_executed = 1;
#line 754
  i = 0;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (i < path_states->num_states)) {
#line 754
      goto while_break;
    }
    {
#line 755
    tmp = svf_map_state(path_states->states[i]);
#line 755
    svf_goto_state(tmp);
#line 754
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  if (stable_state) {
    {
#line 758
    tmp___0 = svf_map_state(stable_state);
#line 758
    svf_goto_state(tmp___0);
    }
  }
#line 760
  return (1);
}
}
#line 777 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_sxr(enum generic_irdr_coding ir_dr , struct ths_params *params , struct YYLTYPE *loc ) 
{ 
  struct sxr *sxr_params ;
  int len ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  tap_register *tmp___7 ;
  tap_register *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 781
  result = 1;
#line 783
  if ((unsigned int )ir_dr == 0U) {
#line 783
    sxr_params = & sir_params;
  } else {
#line 783
    sxr_params = & sdr_params;
  }
  {
#line 786
  svf_remember_param(& sxr_params->params.tdi, params->tdi);
#line 788
  sxr_params->params.tdo = params->tdo;
#line 790
  svf_remember_param(& sxr_params->params.mask, params->mask);
#line 792
  svf_remember_param(& sxr_params->params.smask, params->smask);
  }
#line 796
  if (sxr_params->params.number != params->number) {
#line 797
    sxr_params->no_tdi = 1;
#line 798
    sxr_params->no_tdo = 1;
#line 800
    if (! params->mask) {
      {
#line 801
      tmp = svf_all_care(& sxr_params->params.mask, params->number);
      }
#line 801
      if (! tmp) {
#line 802
        result = 0;
      }
    }
#line 803
    if (! params->smask) {
      {
#line 804
      tmp___0 = svf_all_care(& sxr_params->params.smask, params->number);
      }
#line 804
      if (! tmp___0) {
#line 805
        result = 0;
      }
    }
  }
#line 808
  sxr_params->params.number = params->number;
#line 811
  if (sxr_params->no_tdi) {
#line 812
    if (! params->tdi) {
#line 813
      if ((unsigned int )ir_dr == 0U) {
#line 813
        tmp___1 = "SIR";
      } else {
#line 813
        tmp___1 = "SDR";
      }
      {
#line 813
      tmp___2 = gettext("Error %s: first %s command after length change must have a TDI value.\n");
#line 813
      printf((char const   */* __restrict  */)tmp___2, "svf", tmp___1);
#line 815
      result = 0;
      }
    }
#line 817
    sxr_params->no_tdi = 0;
  }
#line 821
  if (! result) {
#line 822
    return (0);
  }
#line 825
  params->tdi = (char *)((void *)0);
#line 826
  params->mask = (char *)((void *)0);
#line 827
  params->smask = (char *)((void *)0);
#line 833
  len = (int )sxr_params->params.number;
  {
#line 835
  if ((unsigned int )ir_dr == 0U) {
#line 835
    goto case_0;
  }
#line 851
  if ((unsigned int )ir_dr == 1U) {
#line 851
    goto case_1;
  }
#line 834
  goto switch_break;
  case_0: /* CIL Label */ 
#line 837
  if ((ir->value)->len != len) {
    {
#line 838
    tmp___3 = gettext("Error %s: SIR command length inconsistent.\n");
#line 838
    printf((char const   */* __restrict  */)tmp___3, "svf");
    }
#line 840
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 841
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 847
    return (0);
  }
#line 849
  goto switch_break;
  case_1: /* CIL Label */ 
#line 853
  if ((dr->in)->len != len) {
    {
#line 855
    register_free(dr->in);
#line 856
    dr->in = (tap_register *)((void *)0);
#line 857
    register_free(dr->out);
#line 858
    dr->out = (tap_register *)((void *)0);
#line 860
    tmp___5 = register_alloc(len);
#line 860
    dr->in = tmp___5;
    }
#line 860
    if (! tmp___5) {
      {
#line 861
      tmp___4 = gettext("out of memory");
#line 861
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 862
      return (0);
    }
    {
#line 864
    tmp___7 = register_alloc(len);
#line 864
    dr->out = tmp___7;
    }
#line 864
    if (! tmp___7) {
      {
#line 865
      tmp___6 = gettext("out of memory");
#line 865
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 866
      return (0);
    }
  }
#line 869
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 874
  if ((unsigned int )ir_dr == 0U) {
#line 874
    tmp___8 = ir->value;
  } else {
#line 874
    tmp___8 = dr->in;
  }
  {
#line 874
  tmp___9 = svf_copy_hex_to_register(sxr_params->params.tdi, tmp___8);
  }
#line 874
  if (! tmp___9) {
#line 877
    return (0);
  }
  {
#line 882
  if ((unsigned int )ir_dr == 0U) {
#line 882
    goto case_0___0;
  }
#line 895
  if ((unsigned int )ir_dr == 1U) {
#line 895
    goto case_1___0;
  }
#line 881
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 883
  svf_goto_state((1 << 1) | (1 << 2));
#line 884
  chain_shift_instructions_mode(chain, 0, 2);
#line 885
  svf_goto_state(endir);
  }
#line 887
  if (sxr_params->params.tdo) {
#line 888
    if (! issued_sir_tdo) {
      {
#line 889
      tmp___10 = gettext("Warning %s: checking of TDO not supported for SIR.\n");
#line 889
      printf((char const   */* __restrict  */)tmp___10, "svf");
#line 890
      tmp___11 = gettext(" This message is only displayed once.\n");
#line 890
      printf((char const   */* __restrict  */)tmp___11);
#line 891
      issued_sir_tdo = 1;
      }
    }
  }
#line 893
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 896
  svf_goto_state(1 | (1 << 2));
#line 897
  chain_shift_data_registers_mode(chain, 1, 0, 2);
#line 898
  svf_goto_state(enddr);
  }
#line 900
  if (sxr_params->params.tdo) {
    {
#line 901
    result = svf_compare_tdo(sxr_params->params.tdo, sxr_params->params.mask, dr->out,
                             loc);
    }
  }
#line 902
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 905
  return (result);
}
}
#line 926 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_trst(int trst_mode ) 
{ 
  int trst_cable ;
  char *unimplemented_mode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 929
  trst_cable = -1;
#line 932
  if (svf_trst_absent) {
    {
#line 933
    tmp = gettext("Error %s: no further TRST command allowed after mode ABSENT\n");
#line 933
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 935
    return (0);
  }
  {
#line 939
  if (trst_mode == 275) {
#line 939
    goto case_275;
  }
#line 942
  if (trst_mode == 276) {
#line 942
    goto case_276;
  }
#line 945
  if (trst_mode == 277) {
#line 945
    goto case_277;
  }
#line 948
  if (trst_mode == 278) {
#line 948
    goto case_278;
  }
#line 963
  goto switch_default;
  case_275: /* CIL Label */ 
#line 940
  trst_cable = 0;
#line 941
  goto switch_break;
  case_276: /* CIL Label */ 
#line 943
  trst_cable = 1;
#line 944
  goto switch_break;
  case_277: /* CIL Label */ 
#line 946
  unimplemented_mode = (char *)"Z";
#line 947
  goto switch_break;
  case_278: /* CIL Label */ 
#line 949
  unimplemented_mode = (char *)"ABSENT";
#line 950
  svf_trst_absent = 1;
#line 952
  if (svf_state_executed) {
    {
#line 953
    tmp___0 = gettext("Error %s: TRST ABSENT must not be issued after a STATE command\n");
#line 953
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 955
    return (0);
  }
#line 957
  if (sir_params.params.number > 0.0) {
    {
#line 959
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 959
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  } else
#line 957
  if (sdr_params.params.number > 0.0) {
    {
#line 959
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 959
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  }
#line 962
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 964
  unimplemented_mode = (char *)"UNKNOWN";
#line 965
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 968
  if (trst_cable < 0) {
    {
#line 969
    tmp___2 = gettext("Warning %s: unimplemented mode \'%s\' for TRST\n");
#line 969
    printf((char const   */* __restrict  */)tmp___2, "svf", unimplemented_mode);
    }
  } else {
    {
#line 972
    cable_set_trst(chain->cable, trst_cable);
    }
  }
#line 974
  return (1);
}
}
#line 994 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 997
  if (params->number != 0.0) {
#line 998
    if ((unsigned int )ir_dr == 0U) {
#line 998
      tmp = "TIR";
    } else {
#line 998
      tmp = "TDR";
    }
    {
#line 998
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 998
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 1001
  return (1);
}
}
#line 1023 "/home/khheo/project/benchmark/urjtag-0.7/src/svf/svf.c"
void svf_run(FILE *SVF_FILE , int stop_on_mismatch ) 
{ 
  struct sxr sxr_default ;
  char *tmp ;
  char *tmp___0 ;
  char *register_cmd[4] ;
  int tmp___1 ;
  char *tmp___2 ;
  char *instruction_cmd[5] ;
  char *instruction_string ;
  int len ;
  int result ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1026
  sxr_default.params.number = 0.0;
#line 1026
  sxr_default.params.tdi = (char *)((void *)0);
#line 1026
  sxr_default.params.tdo = (char *)((void *)0);
#line 1026
  sxr_default.params.mask = (char *)((void *)0);
#line 1026
  sxr_default.params.smask = (char *)((void *)0);
#line 1026
  sxr_default.no_tdi = 1;
#line 1026
  sxr_default.no_tdo = 1;
#line 1033
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 1034
    tmp = gettext("Error %s: no JTAG chain available\n");
#line 1034
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 1035
    return;
  }
#line 1037
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 1038
    tmp___0 = gettext("Error %s: chain without any parts\n");
#line 1038
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 1039
    return;
  }
  {
#line 1041
  part = *((chain->parts)->parts + chain->active_part);
#line 1044
  dr = part_find_data_register(part, "SDR");
  }
#line 1044
  if (! dr) {
    {
#line 1045
    register_cmd[0] = (char *)"register";
#line 1045
    register_cmd[1] = (char *)"SDR";
#line 1045
    register_cmd[2] = (char *)"32";
#line 1045
    register_cmd[3] = (char *)((void *)0);
#line 1050
    tmp___1 = cmd_run(register_cmd);
    }
#line 1050
    if (tmp___1 < 1) {
#line 1051
      return;
    }
    {
#line 1053
    dr = part_find_data_register(part, "SDR");
    }
#line 1053
    if (! dr) {
      {
#line 1054
      tmp___2 = gettext("Error %s: could not establish SDR register\n");
#line 1054
      printf((char const   */* __restrict  */)tmp___2, "svf");
      }
#line 1055
      return;
    }
  }
  {
#line 1060
  ir = part_find_instruction(part, "SIR");
  }
#line 1060
  if (! ir) {
#line 1061
    instruction_cmd[0] = (char *)"instruction";
#line 1061
    instruction_cmd[1] = (char *)"SIR";
#line 1061
    instruction_cmd[2] = (char *)"";
#line 1061
    instruction_cmd[3] = (char *)"SDR";
#line 1061
    instruction_cmd[4] = (char *)((void *)0);
#line 1069
    len = part->instruction_length;
#line 1070
    if (len > 0) {
      {
#line 1071
      tmp___3 = calloc((size_t )(len + 1), sizeof(char ));
#line 1071
      instruction_string = (char *)tmp___3;
      }
#line 1071
      if ((unsigned long )instruction_string != (unsigned long )((void *)0)) {
        {
#line 1072
        memset((void *)instruction_string, '1', (size_t )len);
#line 1073
        *(instruction_string + len) = (char )'\000';
#line 1074
        instruction_cmd[2] = instruction_string;
#line 1076
        result = cmd_run(instruction_cmd);
#line 1078
        free((void *)instruction_string);
        }
#line 1080
        if (result < 1) {
#line 1081
          return;
        }
      }
    }
    {
#line 1085
    ir = part_find_instruction(part, "SIR");
    }
#line 1085
    if (! ir) {
      {
#line 1086
      tmp___4 = gettext("Error %s: could not establish SIR instruction\n");
#line 1086
      printf((char const   */* __restrict  */)tmp___4, "svf");
      }
#line 1087
      return;
    }
  }
  {
#line 1092
  svf_stop_on_mismatch = stop_on_mismatch;
#line 1094
  sdr_params = sxr_default;
#line 1094
  sir_params = sdr_params;
#line 1096
  enddr = 1 << 3;
#line 1096
  endir = enddr;
#line 1098
  runtest_end_state = 1 << 3;
#line 1098
  runtest_run_state = runtest_end_state;
#line 1100
  svf_trst_absent = 0;
#line 1101
  svf_state_executed = 0;
#line 1104
  issued_sir_tdo = 0;
#line 1105
  issued_runtest_maxtime = 0;
#line 1109
  part_set_instruction(part, "SIR");
#line 1111
  yyin = SVF_FILE;
#line 1112
  yyparse();
  }
#line 1116
  if (sir_params.params.tdi) {
    {
#line 1117
    free((void *)sir_params.params.tdi);
    }
  }
#line 1118
  if (sir_params.params.mask) {
    {
#line 1119
    free((void *)sir_params.params.mask);
    }
  }
#line 1120
  if (sir_params.params.smask) {
    {
#line 1121
    free((void *)sir_params.params.smask);
    }
  }
#line 1123
  if (sdr_params.params.tdi) {
    {
#line 1124
    free((void *)sdr_params.params.tdi);
    }
  }
#line 1125
  if (sdr_params.params.mask) {
    {
#line 1126
    free((void *)sdr_params.params.mask);
    }
  }
#line 1127
  if (sdr_params.params.smask) {
    {
#line 1128
    free((void *)sdr_params.params.smask);
    }
  }
#line 1129
  return;
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 137
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 757
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 117 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 539
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 154 "svf_flex.c"
int yyleng  ;
#line 256 "svf_flex.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 257 "svf_flex.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 258 "svf_flex.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 276 "svf_flex.c"
static char yy_hold_char  ;
#line 277 "svf_flex.c"
static int yy_n_chars  ;
#line 281 "svf_flex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 282 "svf_flex.c"
static int yy_init  =    0;
#line 283 "svf_flex.c"
static int yy_start  =    0;
#line 288 "svf_flex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 290
void yyrestart(FILE *input_file ) ;
#line 291
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 292
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 293
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 294
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 295
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 296
void yypop_buffer_state(void) ;
#line 298
static void yyensure_buffer_stack(void) ;
#line 299
static void yy_load_buffer_state(void) ;
#line 300
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 304
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 305
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 306
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 308
void *yyalloc(yy_size_t size ) ;
#line 309
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 310
void yyfree(void *ptr ) ;
#line 340 "svf_flex.c"
FILE *yyin  =    (FILE *)0;
#line 340 "svf_flex.c"
FILE *yyout  =    (FILE *)0;
#line 344
int yylineno ;
#line 346 "svf_flex.c"
int yylineno  =    1;
#line 348 "svf_flex.c"
char *yytext  ;
#line 351
static yy_state_type yy_get_previous_state(void) ;
#line 352
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 353
static int yy_get_next_buffer(void) ;
#line 354
static void yy_fatal_error(char const   *msg ) ;
#line 375 "svf_flex.c"
static flex_int16_t const   yy_accept[43]  = 
#line 375
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5, 
        (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )10,      (flex_int16_t const   )2,      (flex_int16_t const   )9,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )4, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0};
#line 384 "svf_flex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 384
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )17, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 416 "svf_flex.c"
static flex_int32_t const   yy_meta[18]  = 
#line 416
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )5,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )7};
#line 422 "svf_flex.c"
static flex_int16_t const   yy_base[49]  = 
#line 422
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )86,      (flex_int16_t const   )89,      (flex_int16_t const   )83, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )89, 
        (flex_int16_t const   )72,      (flex_int16_t const   )10,      (flex_int16_t const   )89,      (flex_int16_t const   )9, 
        (flex_int16_t const   )25,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )19, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )41,      (flex_int16_t const   )0, 
        (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )34, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )89, 
        (flex_int16_t const   )32,      (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )23, 
        (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )20, 
        (flex_int16_t const   )42,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )48, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )65,      (flex_int16_t const   )69, 
        (flex_int16_t const   )76};
#line 431 "svf_flex.c"
static flex_int16_t const   yy_def[49]  = 
#line 431
  {      (flex_int16_t const   )0,      (flex_int16_t const   )42,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )45, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )13, 
        (flex_int16_t const   )42,      (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )48,      (flex_int16_t const   )19,      (flex_int16_t const   )42, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )27,      (flex_int16_t const   )42,      (flex_int16_t const   )27, 
        (flex_int16_t const   )48,      (flex_int16_t const   )42,      (flex_int16_t const   )0,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42};
#line 440 "svf_flex.c"
static flex_int16_t const   yy_nxt[107]  = 
#line 440
  {      (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )15,      (flex_int16_t const   )6,      (flex_int16_t const   )22,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )25, 
        (flex_int16_t const   )24,      (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )25,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )32,      (flex_int16_t const   )20, 
        (flex_int16_t const   )37,      (flex_int16_t const   )20,      (flex_int16_t const   )28,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )29,      (flex_int16_t const   )40,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )24, 
        (flex_int16_t const   )41,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )34, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )17,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )21,      (flex_int16_t const   )29,      (flex_int16_t const   )19, 
        (flex_int16_t const   )29,      (flex_int16_t const   )17,      (flex_int16_t const   )42,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )5,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 456 "svf_flex.c"
static flex_int16_t const   yy_chk[107]  = 
#line 456
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )13,      (flex_int16_t const   )15, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )39,      (flex_int16_t const   )26, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )36, 
        (flex_int16_t const   )24,      (flex_int16_t const   )35,      (flex_int16_t const   )32,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )22, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )20, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )17,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )12,      (flex_int16_t const   )48,      (flex_int16_t const   )10, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 472 "svf_flex.c"
static yy_state_type yy_last_accepting_state  ;
#line 473 "svf_flex.c"
static char *yy_last_accepting_cpos  ;
#line 475
int yy_flex_debug ;
#line 476 "svf_flex.c"
int yy_flex_debug  =    0;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "svf_flex.l"
static int map_keyw_ident(YYSTYPE *yylval , char *str ) ;
#line 47
static void align_string(char *str ) ;
#line 61
static void fix_yylloc(YYLTYPE *yylloc , char *str ) ;
#line 62
static void fix_yylloc_nl(YYLTYPE *yylloc , char *str ) ;
#line 76 "svf_flex.l"
int yywrap(void) 
{ 


  {
#line 78
  return (1);
}
}
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 585 "svf_flex.c"
static int yy_init_globals(void) ;
#line 694
int yylex(YYSTYPE *yylval_param , YYLTYPE *yylloc_param ) ;
#line 718 "svf_flex.c"
int yylex(YYSTYPE *yylval_param , YYLTYPE *yylloc_param ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YYSTYPE *yylval ;
  YYLTYPE *yylloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;
  register YY_CHAR yy_c ;
  int keyw ;
  char *cstring ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *cstring___0 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 734
  yylval = yylval_param;
#line 736
  yylloc = yylloc_param;
#line 738
  if (! yy_init) {
#line 740
    yy_init = 1;
    {
#line 743
    while (1) {
      while_continue: /* CIL Label */ ;
#line 743
      tmp___1 = 0;
#line 743
      yylloc->last_column = tmp___1;
#line 743
      tmp___0 = tmp___1;
#line 743
      yylloc->first_column = tmp___0;
#line 743
      tmp = tmp___0;
#line 743
      yylloc->last_line = tmp;
#line 743
      yylloc->first_line = tmp;
#line 743
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 746
    if (! yy_start) {
#line 747
      yy_start = 1;
    }
#line 749
    if (! yyin) {
#line 750
      yyin = stdin;
    }
#line 752
    if (! yyout) {
#line 753
      yyout = stdout;
    }
#line 755
    if (yy_buffer_stack) {
#line 755
      tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 755
      tmp___2 = (YY_BUFFER_STATE )((void *)0);
    }
#line 755
    if (! tmp___2) {
      {
#line 756
      yyensure_buffer_stack();
#line 757
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 761
    yy_load_buffer_state();
    }
  }
  {
#line 764
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 766
    yy_cp = yy_c_buf_p;
#line 769
    *yy_cp = yy_hold_char;
#line 774
    yy_bp = yy_cp;
#line 776
    yy_current_state = yy_start;
    yy_match: 
    {
#line 778
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 780
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 781
      if (yy_accept[yy_current_state]) {
#line 783
        yy_last_accepting_state = yy_current_state;
#line 784
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 786
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 786
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 786
          goto while_break___2;
        }
#line 788
        yy_current_state = (int )yy_def[yy_current_state];
#line 789
        if (yy_current_state >= 43) {
#line 790
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 792
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 793
      yy_cp ++;
#line 778
      if (! ((int const   )yy_base[yy_current_state] != 89)) {
#line 778
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    yy_find_action: 
#line 798
    yy_act = (int )yy_accept[yy_current_state];
#line 799
    if (yy_act == 0) {
#line 801
      yy_cp = yy_last_accepting_cpos;
#line 802
      yy_current_state = yy_last_accepting_state;
#line 803
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 806
    yytext = yy_bp;
#line 806
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 806
    yy_hold_char = *yy_cp;
#line 806
    *yy_cp = (char )'\000';
#line 806
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 812
    if (yy_act == 0) {
#line 812
      goto case_0;
    }
#line 819
    if (yy_act == 1) {
#line 819
      goto case_1;
    }
#line 115
    if (yy_act == 2) {
#line 115 "svf_flex.l"
      goto case_2;
    }
#line 125
    if (yy_act == 3) {
#line 125
      goto case_3;
    }
#line 144
    if (yy_act == 4) {
#line 144
      goto case_4;
    }
#line 158
    if (yy_act == 5) {
#line 158
      goto case_5;
    }
#line 164
    if (yy_act == 6) {
#line 164
      goto case_6;
    }
#line 170
    if (yy_act == 7) {
#line 170
      goto case_7;
    }
#line 177
    if (yy_act == 8) {
#line 177
      goto case_8;
    }
#line 188
    if (yy_act == 9) {
#line 188
      goto case_9;
    }
#line 200
    if (yy_act == 14) {
#line 200
      goto case_14;
    }
#line 200
    if (yy_act == 13) {
#line 200
      goto case_14;
    }
#line 205
    if (yy_act == 10) {
#line 205
      goto case_10;
    }
#line 213
    if (yy_act == 11) {
#line 213
      goto case_11;
    }
#line 965
    if (yy_act == 12) {
#line 965 "svf_flex.c"
      goto case_12;
    }
#line 1087
    goto switch_default;
    case_0: /* CIL Label */ 
#line 814
    *yy_cp = yy_hold_char;
#line 815
    yy_cp = yy_last_accepting_cpos;
#line 816
    yy_current_state = yy_last_accepting_state;
#line 817
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 104 "svf_flex.l"
    fix_yylloc(yylloc, yytext);
#line 105
    keyw = map_keyw_ident(yylval, yytext);
    }
#line 108
    if (keyw == 285) {
#line 109
      yy_start = 3;
    }
#line 112
    return (keyw);
#line 114
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 119
    yylval->dvalue = strtod((char const   */* __restrict  */)yytext, (char **/* __restrict  */)((char **)((void *)0)));
#line 120
    fix_yylloc(yylloc, yytext);
    }
#line 122
    return (259);
#line 124
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 135
    fix_yylloc_nl(yylloc, yytext);
#line 136
    align_string(yytext);
#line 138
    tmp___3 = strlen((char const   *)yytext);
#line 138
    tmp___4 = calloc(tmp___3 + 1UL, sizeof(char ));
#line 138
    cstring = (char *)tmp___4;
#line 139
    strcpy((char */* __restrict  */)cstring, (char const   */* __restrict  */)yytext);
#line 140
    yylval->cvalue = cstring;
    }
#line 141
    return (261);
#line 143
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 149
    fix_yylloc_nl(yylloc, yytext);
#line 150
    align_string(yytext);
#line 152
    tmp___5 = strlen((char const   *)yytext);
#line 152
    tmp___6 = calloc(tmp___5 + 1UL, sizeof(char ));
#line 152
    cstring___0 = (char *)tmp___6;
#line 153
    strcpy((char */* __restrict  */)cstring___0, (char const   */* __restrict  */)yytext);
#line 154
    yylval->cvalue = cstring___0;
    }
#line 155
    return (260);
#line 157
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 161
    fix_yylloc(yylloc, yytext);
    }
#line 163
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 167
    fix_yylloc(yylloc, yytext);
    }
#line 169
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 173
    fix_yylloc(yylloc, yytext);
    }
#line 174
    return ((int )*(yytext + 0));
#line 176
    goto switch_break;
    case_8: /* CIL Label */ 
#line 181
    yylloc->first_line = yylloc->last_line;
#line 182
    yylloc->first_column = yylloc->last_column;
#line 183
    (yylloc->last_line) ++;
#line 184
    yylloc->last_column = 0;
#line 187
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 193
    yy_start = 1;
#line 195
    fix_yylloc(yylloc, yytext);
    }
#line 196
    return ((int )*(yytext + 0));
#line 198
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 202
    return (-1);
#line 204
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s\" is not a legal SVF language token\n",
            yytext);
    }
#line 212
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 213
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 214
    goto switch_break;
    case_12: /* CIL Label */ 
#line 968 "svf_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 971
    *yy_cp = yy_hold_char;
#line 974
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 985
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 986
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 987
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 997
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1001
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1003
      yy_current_state = yy_get_previous_state();
#line 1014
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1016
      yy_bp = yytext + 0;
      }
#line 1018
      if (yy_next_state) {
#line 1021
        yy_c_buf_p ++;
#line 1021
        yy_cp = yy_c_buf_p;
#line 1022
        yy_current_state = yy_next_state;
#line 1023
        goto yy_match;
      } else {
#line 1028
        yy_cp = yy_c_buf_p;
#line 1029
        goto yy_find_action;
      }
    } else {
      {
#line 1033
      tmp___7 = yy_get_next_buffer();
      }
      {
#line 1035
      if (tmp___7 == 1) {
#line 1035
        goto case_1___0;
      }
#line 1064
      if (tmp___7 == 0) {
#line 1064
        goto case_0___0;
      }
#line 1074
      if (tmp___7 == 2) {
#line 1074
        goto case_2___0;
      }
#line 1033
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1037
      yy_did_buffer_switch_on_eof = 0;
#line 1039
      tmp___8 = yywrap();
      }
#line 1039
      if (tmp___8) {
#line 1050
        yy_c_buf_p = yytext + 0;
#line 1052
        yy_act = (12 + (yy_start - 1) / 2) + 1;
#line 1053
        goto do_action;
      } else
#line 1058
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1059
        yyrestart(yyin);
        }
      }
#line 1061
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1065
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1068
      yy_current_state = yy_get_previous_state();
#line 1070
      yy_cp = yy_c_buf_p;
#line 1071
      yy_bp = yytext + 0;
      }
#line 1072
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1075
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1078
      yy_current_state = yy_get_previous_state();
#line 1080
      yy_cp = yy_c_buf_p;
#line 1081
      yy_bp = yytext + 0;
      }
#line 1082
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1084
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1088
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1101 "svf_flex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 1103
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1104
  source = yytext;
#line 1108
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1109
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1112
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1114
    if (yy_c_buf_p - yytext == 1L) {
#line 1119
      return (1);
    } else {
#line 1127
      return (2);
    }
  }
#line 1134
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1136
  i = 0;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i < number_to_move)) {
#line 1136
      goto while_break;
    }
#line 1137
    tmp = dest;
#line 1137
    dest ++;
#line 1137
    tmp___0 = source;
#line 1137
    source ++;
#line 1137
    *tmp = *tmp___0;
#line 1136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1143
    yy_n_chars = 0;
#line 1143
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1147
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1150
      if (! (num_to_read <= 0)) {
#line 1150
        goto while_break___0;
      }
#line 1154
      if (yy_buffer_stack) {
#line 1154
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1154
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1154
      b = tmp___1;
#line 1156
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1159
      if (b->yy_is_our_buffer) {
#line 1161
        new_size = (int )(b->yy_buf_size * 2U);
#line 1163
        if (new_size <= 0) {
#line 1164
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1166
          b->yy_buf_size *= 2U;
        }
        {
#line 1168
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1168
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1174
        b->yy_ch_buf = (char *)0;
      }
#line 1176
      if (! b->yy_ch_buf) {
        {
#line 1177
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1180
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1182
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1187
    if (num_to_read > 8192) {
#line 1188
      num_to_read = 8192;
    }
#line 1191
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1191
      c = '*';
#line 1191
      n = (size_t )0;
      {
#line 1191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1191
        if (n < (size_t )num_to_read) {
          {
#line 1191
          c = _IO_getc(yyin);
          }
#line 1191
          if (c != -1) {
#line 1191
            if (! (c != 10)) {
#line 1191
              goto while_break___1;
            }
          } else {
#line 1191
            goto while_break___1;
          }
        } else {
#line 1191
          goto while_break___1;
        }
#line 1191
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1191
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1191
      if (c == 10) {
#line 1191
        tmp___3 = n;
#line 1191
        n ++;
#line 1191
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1191
      if (c == -1) {
        {
#line 1191
        tmp___4 = ferror(yyin);
        }
#line 1191
        if (tmp___4) {
          {
#line 1191
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1191
      yy_n_chars = (int )n;
    } else {
      {
#line 1191
      tmp___5 = __errno_location();
#line 1191
      *tmp___5 = 0;
      }
      {
#line 1191
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1191
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1191
        yy_n_chars = (int )tmp___8;
        }
#line 1191
        if (yy_n_chars == 0) {
          {
#line 1191
          tmp___9 = ferror(yyin);
          }
#line 1191
          if (! tmp___9) {
#line 1191
            goto while_break___2;
          }
        } else {
#line 1191
          goto while_break___2;
        }
        {
#line 1191
        tmp___6 = __errno_location();
        }
#line 1191
        if (*tmp___6 != 4) {
          {
#line 1191
          yy_fatal_error("input in flex scanner failed");
          }
#line 1191
          goto while_break___2;
        }
        {
#line 1191
        tmp___7 = __errno_location();
#line 1191
        *tmp___7 = 0;
#line 1191
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1194
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1197
  if (yy_n_chars == 0) {
#line 1199
    if (number_to_move == 0) {
      {
#line 1201
      ret_val = 1;
#line 1202
      yyrestart(yyin);
      }
    } else {
#line 1207
      ret_val = 2;
#line 1208
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1214
    ret_val = 0;
  }
#line 1216
  yy_n_chars += number_to_move;
#line 1217
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1218
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1220
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1222
  return (ret_val);
}
}
#line 1227 "svf_flex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1232
  yy_current_state = yy_start;
#line 1234
  yy_cp = yytext + 0;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1234
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1234
      goto while_break;
    }
#line 1236
    if (*yy_cp) {
#line 1236
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1236
      tmp = (flex_int32_t const   )1;
    }
#line 1236
    yy_c = (YY_CHAR )tmp;
#line 1237
    if (yy_accept[yy_current_state]) {
#line 1239
      yy_last_accepting_state = yy_current_state;
#line 1240
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1242
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1242
        goto while_break___0;
      }
#line 1244
      yy_current_state = (int )yy_def[yy_current_state];
#line 1245
      if (yy_current_state >= 43) {
#line 1246
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1248
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1234
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1251
  return (yy_current_state);
}
}
#line 1259 "svf_flex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1262
  yy_cp = yy_c_buf_p;
#line 1264
  yy_c = (YY_CHAR )1;
#line 1265
  if (yy_accept[yy_current_state]) {
#line 1267
    yy_last_accepting_state = yy_current_state;
#line 1268
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1270
      goto while_break;
    }
#line 1272
    yy_current_state = (int )yy_def[yy_current_state];
#line 1273
    if (yy_current_state >= 43) {
#line 1274
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1276
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1277
  yy_is_jam = yy_current_state == 42;
#line 1279
  if (yy_is_jam) {
#line 1279
    tmp = 0;
  } else {
#line 1279
    tmp = yy_current_state;
  }
#line 1279
  return (tmp);
}
}
#line 1398 "svf_flex.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1401
  if (yy_buffer_stack) {
#line 1401
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1401
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1401
  if (! tmp) {
    {
#line 1402
    yyensure_buffer_stack();
#line 1403
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1407
  if (yy_buffer_stack) {
#line 1407
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1407
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1407
  yy_init_buffer(tmp___0, input_file);
#line 1408
  yy_load_buffer_state();
  }
#line 1409
  return;
}
}
#line 1415 "svf_flex.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1423
  yyensure_buffer_stack();
  }
#line 1424
  if (yy_buffer_stack) {
#line 1424
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1424
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1424
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1425
    return;
  }
#line 1427
  if (yy_buffer_stack) {
#line 1427
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1427
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1427
  if (tmp___0) {
#line 1430
    *yy_c_buf_p = yy_hold_char;
#line 1431
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1432
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1435
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1436
  yy_load_buffer_state();
#line 1443
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1444
  return;
}
}
#line 1446 "svf_flex.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1448
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1449
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1449
  yytext = yy_c_buf_p;
#line 1450
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1451
  yy_hold_char = *yy_c_buf_p;
#line 1452
  return;
}
}
#line 1460 "svf_flex.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1464
  tmp = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1464
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1465
  if (! b) {
    {
#line 1466
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1468
  b->yy_buf_size = (yy_size_t )size;
#line 1473
  tmp___0 = yyalloc(b->yy_buf_size + 2U);
#line 1473
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1474
  if (! b->yy_ch_buf) {
    {
#line 1475
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1477
  b->yy_is_our_buffer = 1;
#line 1479
  yy_init_buffer(b, file);
  }
#line 1481
  return (b);
}
}
#line 1488 "svf_flex.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1491
  if (! b) {
#line 1492
    return;
  }
#line 1494
  if (yy_buffer_stack) {
#line 1494
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1494
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1494
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1495
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1497
  if (b->yy_is_our_buffer) {
    {
#line 1498
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1500
  yyfree((void *)b);
  }
#line 1501
  return;
}
}
#line 1511 "svf_flex.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1514
  tmp = __errno_location();
#line 1514
  oerrno = *tmp;
#line 1516
  yy_flush_buffer(b);
#line 1518
  b->yy_input_file = file;
#line 1519
  b->yy_fill_buffer = 1;
  }
#line 1525
  if (yy_buffer_stack) {
#line 1525
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1525
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1525
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1526
    b->yy_bs_lineno = 1;
#line 1527
    b->yy_bs_column = 0;
  }
#line 1530
  if (file) {
    {
#line 1530
    tmp___1 = fileno(file);
#line 1530
    tmp___2 = isatty(tmp___1);
#line 1530
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1530
    b->yy_is_interactive = 0;
  }
  {
#line 1532
  tmp___3 = __errno_location();
#line 1532
  *tmp___3 = oerrno;
  }
#line 1533
  return;
}
}
#line 1539 "svf_flex.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1541
  if (! b) {
#line 1542
    return;
  }
#line 1544
  b->yy_n_chars = 0;
#line 1550
  *(b->yy_ch_buf + 0) = (char)0;
#line 1551
  *(b->yy_ch_buf + 1) = (char)0;
#line 1553
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1555
  b->yy_at_bol = 1;
#line 1556
  b->yy_buffer_status = 0;
#line 1558
  if (yy_buffer_stack) {
#line 1558
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1558
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1558
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1559
    yy_load_buffer_state();
    }
  }
#line 1560
  return;
}
}
#line 1568 "svf_flex.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1570
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1571
    return;
  }
  {
#line 1573
  yyensure_buffer_stack();
  }
#line 1576
  if (yy_buffer_stack) {
#line 1576
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1576
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1576
  if (tmp) {
#line 1579
    *yy_c_buf_p = yy_hold_char;
#line 1580
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1581
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1585
  if (yy_buffer_stack) {
#line 1585
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1585
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1585
  if (tmp___0) {
#line 1586
    yy_buffer_stack_top ++;
  }
  {
#line 1587
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1590
  yy_load_buffer_state();
#line 1591
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1592
  return;
}
}
#line 1598 "svf_flex.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1600
  if (yy_buffer_stack) {
#line 1600
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1600
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1600
  if (! tmp) {
#line 1601
    return;
  }
#line 1603
  if (yy_buffer_stack) {
#line 1603
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1603
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1603
  yy_delete_buffer(tmp___0);
#line 1604
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1605
  if (yy_buffer_stack_top > 0UL) {
#line 1606
    yy_buffer_stack_top --;
  }
#line 1608
  if (yy_buffer_stack) {
#line 1608
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1608
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1608
  if (tmp___1) {
    {
#line 1609
    yy_load_buffer_state();
#line 1610
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1612
  return;
}
}
#line 1617 "svf_flex.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1621
  if (! yy_buffer_stack) {
    {
#line 1627
    num_to_alloc = 1;
#line 1628
    tmp = yyalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1628
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
#line 1632
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1634
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1635
    yy_buffer_stack_top = (size_t )0;
    }
#line 1636
    return;
  }
#line 1639
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1642
    grow_size = 8;
#line 1644
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1645
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1645
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 1651
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1652
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1654
  return;
}
}
#line 1662 "svf_flex.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1666
  if (size < 2U) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  } else
#line 1666
  if ((int )*(base + (size - 2U)) != 0) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  } else
#line 1666
  if ((int )*(base + (size - 1U)) != 0) {
#line 1670
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1672
  tmp = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1672
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1673
  if (! b) {
    {
#line 1674
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1676
  b->yy_buf_size = size - 2U;
#line 1677
  tmp___0 = base;
#line 1677
  b->yy_ch_buf = tmp___0;
#line 1677
  b->yy_buf_pos = tmp___0;
#line 1678
  b->yy_is_our_buffer = 0;
#line 1679
  b->yy_input_file = (FILE *)0;
#line 1680
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1681
  b->yy_is_interactive = 0;
#line 1682
  b->yy_at_bol = 1;
#line 1683
  b->yy_fill_buffer = 0;
#line 1684
  b->yy_buffer_status = 0;
#line 1686
  yy_switch_to_buffer(b);
  }
#line 1688
  return (b);
}
}
#line 1699 "svf_flex.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1702
  tmp = strlen(yystr);
#line 1702
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 1702
  return (tmp___0);
}
}
#line 1712 "svf_flex.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1720
  n = (yy_size_t )(_yybytes_len + 2);
#line 1721
  tmp = yyalloc(n);
#line 1721
  buf = (char *)tmp;
  }
#line 1722
  if (! buf) {
    {
#line 1723
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1725
  i = 0;
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1725
    if (! (i < _yybytes_len)) {
#line 1725
      goto while_break;
    }
#line 1726
    *(buf + i) = (char )*(yybytes + i);
#line 1725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1728
  tmp___0 = (char)0;
#line 1728
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1728
  *(buf + _yybytes_len) = tmp___0;
#line 1730
  b = yy_scan_buffer(buf, n);
  }
#line 1731
  if (! b) {
    {
#line 1732
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1737
  b->yy_is_our_buffer = 1;
#line 1739
  return (b);
}
}
#line 1746 "svf_flex.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1748
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1749
  exit(2);
  }
}
}
#line 1774 "svf_flex.c"
int yyget_lineno(void) 
{ 


  {
#line 1777
  return (yylineno);
}
}
#line 1783 "svf_flex.c"
FILE *yyget_in(void) 
{ 


  {
#line 1785
  return (yyin);
}
}
#line 1791 "svf_flex.c"
FILE *yyget_out(void) 
{ 


  {
#line 1793
  return (yyout);
}
}
#line 1799 "svf_flex.c"
int yyget_leng(void) 
{ 


  {
#line 1801
  return (yyleng);
}
}
#line 1808 "svf_flex.c"
char *yyget_text(void) 
{ 


  {
#line 1810
  return (yytext);
}
}
#line 1817 "svf_flex.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 1820
  yylineno = line_number;
#line 1821
  return;
}
}
#line 1829 "svf_flex.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 1831
  yyin = in_str;
#line 1832
  return;
}
}
#line 1834 "svf_flex.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 1836
  yyout = out_str;
#line 1837
  return;
}
}
#line 1839 "svf_flex.c"
int yyget_debug(void) 
{ 


  {
#line 1841
  return (yy_flex_debug);
}
}
#line 1844 "svf_flex.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 1846
  yy_flex_debug = bdebug;
#line 1847
  return;
}
}
#line 1849 "svf_flex.c"
static int yy_init_globals(void) 
{ 


  {
#line 1855
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 1856
  yy_buffer_stack_top = (size_t )0;
#line 1857
  yy_buffer_stack_max = (size_t )0;
#line 1858
  yy_c_buf_p = (char *)0;
#line 1859
  yy_init = 0;
#line 1860
  yy_start = 0;
#line 1867
  yyin = (FILE *)0;
#line 1868
  yyout = (FILE *)0;
#line 1874
  return (0);
}
}
#line 1878 "svf_flex.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1882
    if (yy_buffer_stack) {
#line 1882
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1882
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1882
    if (! tmp___0) {
#line 1882
      goto while_break;
    }
#line 1883
    if (yy_buffer_stack) {
#line 1883
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1883
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1883
    yy_delete_buffer(tmp);
#line 1884
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 1885
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1889
  yyfree((void *)yy_buffer_stack);
#line 1890
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 1894
  yy_init_globals();
  }
#line 1896
  return (0);
}
}
#line 1923 "svf_flex.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1925
  tmp = malloc((size_t )size);
  }
#line 1925
  return (tmp);
}
}
#line 1928 "svf_flex.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1937
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 1937
  return (tmp);
}
}
#line 1940 "svf_flex.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 1942
  free((void *)((char *)ptr));
  }
#line 1943
  return;
}
}
#line 220 "svf_flex.l"
static struct rwtable rwtable[53]  = 
#line 220 "svf_flex.l"
  {      {(char *)"ABSENT", 278}, 
        {(char *)"D", 293}, 
        {(char *)"DRCAPTURE", 314}, 
        {(char *)"DREXIT1", 312}, 
        {(char *)"DREXIT2", 313}, 
        {(char *)"DRPAUSE", 308}, 
        {(char *)"DRSELECT", 311}, 
        {(char *)"DRSHIFT", 309}, 
        {(char *)"DRUPDATE", 310}, 
        {(char *)"EMPTY", 262}, 
        {(char *)"ENDDR", 263}, 
        {(char *)"ENDIR", 264}, 
        {(char *)"ENDSTATE", 300}, 
        {(char *)"FREQUENCY", 265}, 
        {(char *)"H", 290}, 
        {(char *)"HDR", 279}, 
        {(char *)"HIR", 280}, 
        {(char *)"HZ", 266}, 
        {(char *)"IDLE", 269}, 
        {(char *)"IN", 287}, 
        {(char *)"INOUT", 289}, 
        {(char *)"IRCAPTURE", 307}, 
        {(char *)"IREXIT1", 305}, 
        {(char *)"IREXIT2", 306}, 
        {(char *)"IRPAUSE", 301}, 
        {(char *)"IRSELECT", 304}, 
        {(char *)"IRSHIFT", 302}, 
        {(char *)"IRUPDATE", 303}, 
        {(char *)"L", 291}, 
        {(char *)"MASK", 272}, 
        {(char *)"MAXIMUM", 296}, 
        {(char *)"OFF", 276}, 
        {(char *)"ON", 275}, 
        {(char *)"OUT", 288}, 
        {(char *)"PIO", 285}, 
        {(char *)"PIOMAP", 286}, 
        {(char *)"RESET", 268}, 
        {(char *)"RUNTEST", 295}, 
        {(char *)"SCK", 299}, 
        {(char *)"SDR", 281}, 
        {(char *)"SEC", 297}, 
        {(char *)"SIR", 282}, 
        {(char *)"SMASK", 273}, 
        {(char *)"STATE", 267}, 
        {(char *)"TCK", 298}, 
        {(char *)"TDI", 270}, 
        {(char *)"TDO", 271}, 
        {(char *)"TDR", 283}, 
        {(char *)"TIR", 284}, 
        {(char *)"TRST", 274}, 
        {(char *)"U", 292}, 
        {(char *)"X", 294}, 
        {(char *)"Z", 277}};
#line 282 "svf_flex.l"
static int map_keyw_ident(YYSTYPE *yylval , char *str ) 
{ 
  int idx ;
  int rw ;
  int tmp ;

  {
#line 286
  rw = 258;
#line 288
  yylval->cvalue = str;
#line 290
  idx = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! ((unsigned long )idx <= sizeof(rwtable) / sizeof(rwtable[0]) - 1UL)) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = strcasecmp((char const   *)rwtable[idx].rw_name, (char const   *)str);
    }
#line 291
    if (tmp == 0) {
#line 293
      rw = rwtable[idx].rw_yylex;
#line 294
      yylval->token = rw;
    }
#line 290
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (rw);
}
}
#line 302 "svf_flex.l"
static void align_string(char *str ) 
{ 
  int src ;
  int dst ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 307
  dst = 0;
#line 308
  tmp = strlen((char const   *)str);
#line 308
  len = (int )tmp;
#line 310
  src = 0;
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (src < len)) {
#line 310
      goto while_break;
    }
    {
#line 311
    tmp___1 = __ctype_b_loc();
    }
#line 311
    if ((int const   )*(*tmp___1 + (int )*(str + src)) & 4096) {
#line 312
      tmp___0 = dst;
#line 312
      dst ++;
#line 312
      *(str + tmp___0) = *(str + src);
    }
#line 310
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  *(str + dst) = (char )'\000';
#line 315
  return;
}
}
#line 319 "svf_flex.l"
static void fix_yylloc(YYLTYPE *yylloc , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 322
  yylloc->first_line = yylloc->last_line;
#line 323
  yylloc->first_column = yylloc->last_column;
#line 324
  tmp = strlen((char const   *)str);
#line 324
  yylloc->last_column = (int )((size_t )yylloc->last_column + tmp);
  }
#line 325
  return;
}
}
#line 328 "svf_flex.l"
static void fix_yylloc_nl(YYLTYPE *yylloc , char *str ) 
{ 
  char *p ;

  {
#line 333
  yylloc->first_line = yylloc->last_line;
#line 334
  yylloc->first_column = yylloc->last_column;
#line 335
  p = str;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! *p) {
#line 335
      goto while_break;
    }
#line 336
    if ((int )*p == 10) {
#line 337
      yylloc->last_column = 0;
#line 338
      (yylloc->last_line) ++;
    } else {
#line 340
      (yylloc->last_column) ++;
    }
#line 335
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 48 "svf_bison.y"
static struct svf_parser_params parser_params  =    {{0.0, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, {0, (uint32_t )0.0, 0, (double )0,
                                                (double )0, 0}};
#line 54
void yyerror(char const   *error_string ) ;
#line 56
static void svf_free_ths_params(struct ths_params *params ) ;
#line 515 "svf_bison.c"
static yytype_uint8 const   yytranslate[315]  = 
#line 515 "svf_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59};
#line 606 "svf_bison.c"
static char const   * const  yytname[81]  = 
#line 606
  {      (char const   */* const  */)"SVF_EOF",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENTIFIER", 
        (char const   */* const  */)"NUMBER",      (char const   */* const  */)"HEXA_NUM",      (char const   */* const  */)"VECTOR_STRING",      (char const   */* const  */)"EMPTY", 
        (char const   */* const  */)"ENDDR",      (char const   */* const  */)"ENDIR",      (char const   */* const  */)"FREQUENCY",      (char const   */* const  */)"HZ", 
        (char const   */* const  */)"STATE",      (char const   */* const  */)"RESET",      (char const   */* const  */)"IDLE",      (char const   */* const  */)"TDI", 
        (char const   */* const  */)"TDO",      (char const   */* const  */)"MASK",      (char const   */* const  */)"SMASK",      (char const   */* const  */)"TRST", 
        (char const   */* const  */)"ON",      (char const   */* const  */)"OFF",      (char const   */* const  */)"Z",      (char const   */* const  */)"ABSENT", 
        (char const   */* const  */)"HDR",      (char const   */* const  */)"HIR",      (char const   */* const  */)"SDR",      (char const   */* const  */)"SIR", 
        (char const   */* const  */)"TDR",      (char const   */* const  */)"TIR",      (char const   */* const  */)"PIO",      (char const   */* const  */)"PIOMAP", 
        (char const   */* const  */)"IN",      (char const   */* const  */)"OUT",      (char const   */* const  */)"INOUT",      (char const   */* const  */)"H", 
        (char const   */* const  */)"L",      (char const   */* const  */)"U",      (char const   */* const  */)"D",      (char const   */* const  */)"X", 
        (char const   */* const  */)"RUNTEST",      (char const   */* const  */)"MAXIMUM",      (char const   */* const  */)"SEC",      (char const   */* const  */)"TCK", 
        (char const   */* const  */)"SCK",      (char const   */* const  */)"ENDSTATE",      (char const   */* const  */)"IRPAUSE",      (char const   */* const  */)"IRSHIFT", 
        (char const   */* const  */)"IRUPDATE",      (char const   */* const  */)"IRSELECT",      (char const   */* const  */)"IREXIT1",      (char const   */* const  */)"IREXIT2", 
        (char const   */* const  */)"IRCAPTURE",      (char const   */* const  */)"DRPAUSE",      (char const   */* const  */)"DRSHIFT",      (char const   */* const  */)"DRUPDATE", 
        (char const   */* const  */)"DRSELECT",      (char const   */* const  */)"DREXIT1",      (char const   */* const  */)"DREXIT2",      (char const   */* const  */)"DRCAPTURE", 
        (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"line",      (char const   */* const  */)"svf_statement",      (char const   */* const  */)"ths_param_list",      (char const   */* const  */)"ths_opt_param", 
        (char const   */* const  */)"stable_state",      (char const   */* const  */)"runtest_run_state_opt",      (char const   */* const  */)"runtest_clk_count",      (char const   */* const  */)"runtest_time_opt", 
        (char const   */* const  */)"runtest_time",      (char const   */* const  */)"runtest_max_time_opt",      (char const   */* const  */)"runtest_end_state_opt",      (char const   */* const  */)"all_states", 
        (char const   */* const  */)"path_states",      (char const   */* const  */)"piomap_rec",      (char const   */* const  */)"trst_mode",      (char const   */* const  */)"direction", 
        (char const   */* const  */)0};
#line 640 "svf_bison.c"
static yytype_uint8 const   yyr1[69]  = 
#line 640
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79};
#line 652 "svf_bison.c"
static yytype_uint8 const   yyr2[69]  = 
#line 652
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1};
#line 666 "svf_bison.c"
static yytype_uint8 const   yydefact[119]  = 
#line 666
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )50,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )60,      (yytype_uint8 const   )38,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )61,      (yytype_uint8 const   )39};
#line 683 "svf_bison.c"
static yytype_int8 const   yydefgoto[17]  = 
#line 683
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )19,      (yytype_int8 const   )66, 
        (yytype_int8 const   )87,      (yytype_int8 const   )24,      (yytype_int8 const   )43,      (yytype_int8 const   )78, 
        (yytype_int8 const   )98,      (yytype_int8 const   )79,      (yytype_int8 const   )108,      (yytype_int8 const   )101, 
        (yytype_int8 const   )64,      (yytype_int8 const   )28,      (yytype_int8 const   )106,      (yytype_int8 const   )33, 
        (yytype_int8 const   )76};
#line 692 "svf_bison.c"
static yytype_int16 const   yypact[119]  = 
#line 692
  {      (yytype_int16 const   )55,      (yytype_int16 const   )4,      (yytype_int16 const   )88,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )-3, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )31,      (yytype_int16 const   )17,      (yytype_int16 const   )45, 
        (yytype_int16 const   )57,      (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )73, 
        (yytype_int16 const   )67,      (yytype_int16 const   )26,      (yytype_int16 const   )46,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )18,      (yytype_int16 const   )29,      (yytype_int16 const   )79,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-11,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )33,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )44,      (yytype_int16 const   )-23,      (yytype_int16 const   )-24,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )65,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )66, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-10,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )2,      (yytype_int16 const   )8,      (yytype_int16 const   )12,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )102,      (yytype_int16 const   )27,      (yytype_int16 const   )123,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )93,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )94,      (yytype_int16 const   )61,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )46,      (yytype_int16 const   )75,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )78,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )80,      (yytype_int16 const   )136,      (yytype_int16 const   )99,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24};
#line 709 "svf_bison.c"
static yytype_int8 const   yypgoto[17]  = 
#line 709
  {      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )85, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-6,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )64,      (yytype_int8 const   )-24,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )37};
#line 720 "svf_bison.c"
static yytype_int8 const   yytable[146]  = 
#line 720
  {      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )3,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )42,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )34,      (yytype_int8 const   )63,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )49, 
        (yytype_int8 const   )50,      (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53, 
        (yytype_int8 const   )54,      (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57, 
        (yytype_int8 const   )58,      (yytype_int8 const   )59,      (yytype_int8 const   )60,      (yytype_int8 const   )61, 
        (yytype_int8 const   )62,      (yytype_int8 const   )35,      (yytype_int8 const   )86,      (yytype_int8 const   )29, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )1,      (yytype_int8 const   )27,      (yytype_int8 const   )88,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )36,      (yytype_int8 const   )89,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )37,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )90,      (yytype_int8 const   )94,      (yytype_int8 const   )95,      (yytype_int8 const   )96, 
        (yytype_int8 const   )91,      (yytype_int8 const   )40,      (yytype_int8 const   )-2,      (yytype_int8 const   )38, 
        (yytype_int8 const   )92,      (yytype_int8 const   )39,      (yytype_int8 const   )44,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )41, 
        (yytype_int8 const   )4,      (yytype_int8 const   )45,      (yytype_int8 const   )46,      (yytype_int8 const   )77, 
        (yytype_int8 const   )22,      (yytype_int8 const   )65,      (yytype_int8 const   )110,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )8,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )72,      (yytype_int8 const   )93,      (yytype_int8 const   )100,      (yytype_int8 const   )9, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-27,      (yytype_int8 const   )-28,      (yytype_int8 const   )-30, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-29,      (yytype_int8 const   )81,      (yytype_int8 const   )97, 
        (yytype_int8 const   )18,      (yytype_int8 const   )102,      (yytype_int8 const   )103,      (yytype_int8 const   )112, 
        (yytype_int8 const   )104,      (yytype_int8 const   )105,      (yytype_int8 const   )107,      (yytype_int8 const   )111, 
        (yytype_int8 const   )94,      (yytype_int8 const   )114,      (yytype_int8 const   )115,      (yytype_int8 const   )117, 
        (yytype_int8 const   )116,      (yytype_int8 const   )118,      (yytype_int8 const   )99,      (yytype_int8 const   )113, 
        (yytype_int8 const   )0,      (yytype_int8 const   )109};
#line 739 "svf_bison.c"
static yytype_int8 const   yycheck[146]  = 
#line 739
  {      (yytype_int8 const   )6,      (yytype_int8 const   )4,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )0,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )4,      (yytype_int8 const   )28,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )46, 
        (yytype_int8 const   )47,      (yytype_int8 const   )48,      (yytype_int8 const   )49,      (yytype_int8 const   )50, 
        (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53,      (yytype_int8 const   )54, 
        (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )58, 
        (yytype_int8 const   )59,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )0, 
        (yytype_int8 const   )1,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4,      (yytype_int8 const   )12, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )60,      (yytype_int8 const   )6,      (yytype_int8 const   )19,      (yytype_int8 const   )4, 
        (yytype_int8 const   )60,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )61, 
        (yytype_int8 const   )0,      (yytype_int8 const   )60,      (yytype_int8 const   )11,      (yytype_int8 const   )4, 
        (yytype_int8 const   )46,      (yytype_int8 const   )60,      (yytype_int8 const   )100,      (yytype_int8 const   )40, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )53, 
        (yytype_int8 const   )12,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )60,      (yytype_int8 const   )3,      (yytype_int8 const   )45,      (yytype_int8 const   )19, 
        (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60, 
        (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27, 
        (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31, 
        (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37,      (yytype_int8 const   )38, 
        (yytype_int8 const   )39,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )4, 
        (yytype_int8 const   )40,      (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )41,      (yytype_int8 const   )60, 
        (yytype_int8 const   )42,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )3, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )78,      (yytype_int8 const   )106, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )98};
#line 760 "svf_bison.c"
static yytype_uint8 const   yystos[119]  = 
#line 760
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )64,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )78,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )61,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )11,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )60,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )70,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )60,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )74,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )68,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42};
#line 1060 "svf_bison.c"
static unsigned long yystrlen(char const   *yystr ) 
{ 
  unsigned long yylen ;

  {
#line 1069
  yylen = 0UL;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! *(yystr + yylen)) {
#line 1069
      goto while_break;
    }
#line 1070
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1069
    yylen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1071
  return (yylen);
}
}
#line 1084 "svf_bison.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1093
  yyd = yydest;
#line 1094
  yys = yysrc;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    tmp = yyd;
#line 1096
    yyd ++;
#line 1096
    tmp___1 = yys;
#line 1096
    yys ++;
#line 1096
    tmp___0 = (char )*tmp___1;
#line 1096
    *tmp = tmp___0;
#line 1096
    if (! ((int )tmp___0 != 0)) {
#line 1096
      goto while_break;
    }
#line 1097
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  return (yyd - 1);
}
}
#line 1112 "svf_bison.c"
static unsigned long yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned long yyn ;
  char const   *yyp ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 1115
  if ((int const   )*yystr == 34) {
#line 1117
    yyn = 0UL;
#line 1118
    yyp = yystr;
    {
#line 1120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1121
      yyp ++;
      {
#line 1124
      if ((int const   )*yyp == 44) {
#line 1124
        goto case_44;
      }
#line 1124
      if ((int const   )*yyp == 39) {
#line 1124
        goto case_44;
      }
#line 1127
      if ((int const   )*yyp == 92) {
#line 1127
        goto case_92;
      }
#line 1137
      if ((int const   )*yyp == 34) {
#line 1137
        goto case_34;
      }
#line 1131
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1125
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1128
      yyp ++;
#line 1128
      if ((int const   )*yyp != 92) {
#line 1129
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1132
      if (yyres) {
#line 1133
        *(yyres + yyn) = (char )*yyp;
      }
#line 1134
      yyn ++;
#line 1135
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1138
      if (yyres) {
#line 1139
        *(yyres + yyn) = (char )'\000';
      }
#line 1140
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1145
  if (! yyres) {
    {
#line 1146
    tmp = yystrlen(yystr);
    }
#line 1146
    return (tmp);
  }
  {
#line 1148
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 1148
  return ((unsigned long )(tmp___0 - yyres));
}
}
#line 1188
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar ) ;
#line 1188 "svf_bison.c"
static char const   yyunexpected[28]  = 
#line 1188
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1189 "svf_bison.c"
static char const   yyexpecting[15]  = 
#line 1189
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1190 "svf_bison.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1159 "svf_bison.c"
static unsigned long yysyntax_error(char *yyresult , int yystate , int yychar ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned long yysize0 ;
  unsigned long tmp___0 ;
  unsigned long yysize ;
  unsigned long yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char tmp___8 ;

  {
#line 1162
  yyn = (int )yypact[yystate];
#line 1164
  if (-24 < yyn) {
#line 1164
    if (yyn <= 145) {
#line 1168
      if ((unsigned int )yychar <= 314U) {
#line 1168
        tmp = (int const   )yytranslate[yychar];
      } else {
#line 1168
        tmp = (int const   )2;
      }
      {
#line 1168
      yytype = (int )tmp;
#line 1169
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1169
      yysize0 = tmp___0;
#line 1170
      yysize = yysize0;
#line 1172
      yysize_overflow = 0;
#line 1195
      yyprefix = yyexpecting;
      }
#line 1199
      if (yyn < 0) {
#line 1199
        tmp___1 = - yyn;
      } else {
#line 1199
        tmp___1 = 0;
      }
#line 1199
      yyxbegin = tmp___1;
#line 1202
      yychecklim = (145 - yyn) + 1;
#line 1203
      if (yychecklim < 63) {
#line 1203
        tmp___2 = yychecklim;
      } else {
#line 1203
        tmp___2 = 63;
      }
      {
#line 1203
      yyxend = tmp___2;
#line 1204
      yycount = 1;
#line 1206
      yyarg[0] = (char const   *)yytname[yytype];
#line 1207
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1209
      yyx = yyxbegin;
      }
      {
#line 1209
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1209
        if (! (yyx < yyxend)) {
#line 1209
          goto while_break;
        }
#line 1210
        if ((int const   )yycheck[yyx + yyn] == (int const   )yyx) {
#line 1210
          if (yyx != 1) {
#line 1212
            if (yycount == 5) {
#line 1214
              yycount = 1;
#line 1215
              yysize = yysize0;
#line 1216
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1217
              goto while_break;
            }
            {
#line 1219
            tmp___3 = yycount;
#line 1219
            yycount ++;
#line 1219
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1220
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1220
            yysize1 = yysize + tmp___4;
#line 1221
            yysize_overflow |= yysize1 < yysize;
#line 1222
            yysize = yysize1;
#line 1223
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1224
            yyprefix = yyor;
            }
          }
        }
#line 1209
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1227
      yyf = (char const   *)(yyformat);
#line 1228
      tmp___5 = yystrlen(yyf);
#line 1228
      yysize1 = yysize + tmp___5;
#line 1229
      yysize_overflow |= yysize1 < yysize;
#line 1230
      yysize = yysize1;
      }
#line 1232
      if (yysize_overflow) {
#line 1233
        return (0xffffffffffffffffUL);
      }
#line 1235
      if (yyresult) {
#line 1240
        yyp = yyresult;
#line 1241
        yyi = 0;
        {
#line 1242
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1242
          tmp___8 = (char )*yyf;
#line 1242
          *yyp = tmp___8;
#line 1242
          if (! ((int )tmp___8 != 0)) {
#line 1242
            goto while_break___0;
          }
#line 1244
          if ((int )*yyp == 37) {
#line 1244
            if ((int const   )*(yyf + 1) == 115) {
#line 1244
              if (yyi < yycount) {
                {
#line 1246
                tmp___6 = yyi;
#line 1246
                yyi ++;
#line 1246
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1246
                yyp += tmp___7;
#line 1247
                yyf += 2;
                }
              } else {
#line 1251
                yyp ++;
#line 1252
                yyf ++;
              }
            } else {
#line 1251
              yyp ++;
#line 1252
              yyf ++;
            }
          } else {
#line 1251
            yyp ++;
#line 1252
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1256
      return (yysize);
    } else {
#line 1165
      return (0UL);
    }
  } else {
#line 1165
    return (0UL);
  }
}
}
#line 1269 "svf_bison.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , YYLTYPE *yylocationp ) 
{ 


  {
#line 1283
  if (! yymsg) {
#line 1284
    yymsg = "Deleting";
  }
  {
#line 1290
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1293
  return;
}
}
#line 1334 "svf_bison.c"
int yyparse(void) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  YYLTYPE yylloc ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned long yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  YYLTYPE yylsa[200] ;
  YYLTYPE *yyls ;
  YYLTYPE *yylsp ;
  YYLTYPE yyerror_range[2] ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  YYLTYPE yyloc ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  unsigned long yynewbytes___1 ;
  struct ths_params *p ;
  struct ths_params *p___0 ;
  struct runtest *rt ;
  int tmp___0 ;
  struct runtest *rt___0 ;
  int tmp___1 ;
  struct ths_params *p___1 ;
  int result ;
  struct ths_params *p___2 ;
  int result___0 ;
  int tmp___2 ;
  struct ths_params *p___3 ;
  int result___1 ;
  struct ths_params *p___4 ;
  int result___2 ;
  int tmp___3 ;
  struct path_states *ps ;
  unsigned long yysize___0 ;
  unsigned long tmp___4 ;
  unsigned long yyalloc___0 ;
  void *tmp___5 ;

  {
#line 1360
  yytoken = 0;
#line 1364
  yymsg = yymsgbuf;
#line 1365
  yymsg_alloc = sizeof(yymsgbuf);
#line 1378
  yyss = yyssa;
#line 1383
  yyvs = yyvsa;
#line 1388
  yyls = yylsa;
#line 1395
  yystacksize = 200UL;
#line 1404
  yylen = 0;
#line 1408
  yystate = 0;
#line 1409
  yyerrstatus = 0;
#line 1410
  yynerrs = 0;
#line 1411
  yychar = -2;
#line 1418
  yyssp = yyss;
#line 1419
  yyvsp = yyvs;
#line 1420
  yylsp = yyls;
#line 1423
  yylloc.last_line = 1;
#line 1423
  yylloc.first_line = yylloc.last_line;
#line 1424
  yylloc.last_column = 0;
#line 1424
  yylloc.first_column = yylloc.last_column;
#line 1427
  goto yysetstate;
  yynewstate: 
#line 1435
  yyssp ++;
  yysetstate: 
#line 1438
  *yyssp = (yytype_int16 )yystate;
#line 1440
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1443
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1472
    if (10000UL <= yystacksize) {
#line 1473
      goto yyexhaustedlab;
    }
#line 1474
    yystacksize *= 2UL;
#line 1475
    if (10000UL < yystacksize) {
#line 1476
      yystacksize = 10000UL;
    }
    {
#line 1479
    yyss1 = yyss;
#line 1480
    tmp = malloc(yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + sizeof(YYLTYPE )) + 2UL * (sizeof(union yyalloc ) - 1UL));
#line 1480
    yyptr = (union yyalloc *)tmp;
    }
#line 1482
    if (! yyptr) {
#line 1483
      goto yyexhaustedlab;
    }
    {
#line 1484
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1484
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1484
      yyss = & yyptr->yyss;
#line 1484
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1484
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1484
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1485
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1485
      yyvs = & yyptr->yyvs;
#line 1485
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1485
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1486
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1486
      __builtin_memcpy((void *)(& yyptr->yyls), (void const   *)yyls, yysize * sizeof(*yyls));
#line 1486
      yyls = & yyptr->yyls;
#line 1486
      yynewbytes___1 = yystacksize * sizeof(*yyls) + (sizeof(union yyalloc ) - 1UL);
#line 1486
      yyptr += yynewbytes___1 / sizeof(*yyptr);
      }
#line 1486
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1488
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1489
      free((void *)yyss1);
      }
    }
#line 1494
    yyssp = (yyss + yysize) - 1;
#line 1495
    yyvsp = (yyvs + yysize) - 1;
#line 1496
    yylsp = (yyls + yysize) - 1;
#line 1501
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1502
      goto yyabortlab;
    }
  }
#line 1507
  goto yybackup;
  yybackup: 
#line 1518
  yyn = (int )yypact[yystate];
#line 1519
  if (yyn == -24) {
#line 1520
    goto yydefault;
  }
#line 1525
  if (yychar == -2) {
    {
#line 1528
    yychar = yylex(& yylval, & yylloc);
    }
  }
#line 1531
  if (yychar <= 0) {
#line 1533
    yytoken = 0;
#line 1533
    yychar = yytoken;
  } else
#line 1538
  if ((unsigned int )yychar <= 314U) {
#line 1538
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1538
    yytoken = 2;
  }
#line 1544
  yyn += yytoken;
#line 1545
  if (yyn < 0) {
#line 1546
    goto yydefault;
  } else
#line 1545
  if (145 < yyn) {
#line 1546
    goto yydefault;
  } else
#line 1545
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1546
    goto yydefault;
  }
#line 1547
  yyn = (int )yytable[yyn];
#line 1548
  if (yyn <= 0) {
#line 1550
    if (yyn == 0) {
#line 1551
      goto yyerrlab;
    } else
#line 1550
    if (yyn == -31) {
#line 1551
      goto yyerrlab;
    }
#line 1552
    yyn = - yyn;
#line 1553
    goto yyreduce;
  }
#line 1556
  if (yyn == 4) {
#line 1557
    goto yyacceptlab;
  }
#line 1561
  if (yyerrstatus) {
#line 1562
    yyerrstatus --;
  }
#line 1568
  if (yychar != 0) {
#line 1569
    yychar = -2;
  }
#line 1571
  yystate = yyn;
#line 1572
  yyvsp ++;
#line 1572
  *yyvsp = yylval;
#line 1573
  yylsp ++;
#line 1573
  *yylsp = yylloc;
#line 1574
  goto yynewstate;
  yydefault: 
#line 1581
  yyn = (int )yydefact[yystate];
#line 1582
  if (yyn == 0) {
#line 1583
    goto yyerrlab;
  }
#line 1584
  goto yyreduce;
  yyreduce: 
#line 1592
  yylen = (int )yyr2[yyn];
#line 1602
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1605
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1605
    if (yylen) {
#line 1605
      yyloc.first_line = ((yylsp - yylen) + 1)->first_line;
#line 1605
      yyloc.first_column = ((yylsp - yylen) + 1)->first_column;
#line 1605
      yyloc.last_line = ((yylsp - yylen) + yylen)->last_line;
#line 1605
      yyloc.last_column = ((yylsp - yylen) + yylen)->last_column;
    } else {
#line 1605
      yyloc.last_line = ((yylsp - yylen) + 0)->last_line;
#line 1605
      yyloc.first_line = yyloc.last_line;
#line 1605
      yyloc.last_column = ((yylsp - yylen) + 0)->last_column;
#line 1605
      yyloc.first_column = yyloc.last_column;
    }
#line 1605
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1609
  if (yyn == 5) {
#line 1609
    goto case_5;
  }
#line 112
  if (yyn == 6) {
#line 112 "svf_bison.y"
    goto case_6;
  }
#line 117
  if (yyn == 7) {
#line 117
    goto case_7;
  }
#line 122
  if (yyn == 8) {
#line 122
    goto case_8;
  }
#line 127
  if (yyn == 9) {
#line 127
    goto case_9;
  }
#line 136
  if (yyn == 10) {
#line 136
    goto case_10;
  }
#line 145
  if (yyn == 11) {
#line 145
    goto case_11;
  }
#line 152
  if (yyn == 12) {
#line 152
    goto case_12;
  }
#line 160
  if (yyn == 13) {
#line 160
    goto case_13;
  }
#line 175
  if (yyn == 14) {
#line 175
    goto case_14;
  }
#line 190
  if (yyn == 15) {
#line 190
    goto case_15;
  }
#line 205
  if (yyn == 16) {
#line 205
    goto case_16;
  }
#line 220
  if (yyn == 17) {
#line 220
    goto case_17;
  }
#line 228
  if (yyn == 18) {
#line 228
    goto case_18;
  }
#line 243
  if (yyn == 19) {
#line 243
    goto case_19;
  }
#line 258
  if (yyn == 20) {
#line 258
    goto case_20;
  }
#line 266
  if (yyn == 23) {
#line 266
    goto case_23;
  }
#line 279
  if (yyn == 24) {
#line 279
    goto case_24;
  }
#line 284
  if (yyn == 25) {
#line 284
    goto case_25;
  }
#line 289
  if (yyn == 26) {
#line 289
    goto case_26;
  }
#line 294
  if (yyn == 31) {
#line 294
    goto case_31;
  }
#line 305
  if (yyn == 32) {
#line 305
    goto case_32;
  }
#line 309
  if (yyn == 33) {
#line 309
    goto case_33;
  }
#line 317
  if (yyn == 34) {
#line 317
    goto case_34;
  }
#line 323
  if (yyn == 35) {
#line 323
    goto case_35;
  }
#line 331
  if (yyn == 37) {
#line 331
    goto case_37;
  }
#line 340
  if (yyn == 39) {
#line 340
    goto case_39;
  }
#line 348
  if (yyn == 40) {
#line 348
    goto case_40;
  }
#line 352
  if (yyn == 41) {
#line 352
    goto case_41;
  }
#line 356
  if (yyn == 58) {
#line 356
    goto case_58;
  }
#line 382
  if (yyn == 59) {
#line 382
    goto case_59;
  }
#line 1914 "svf_bison.c"
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 108 "svf_bison.y"
  svf_endxr((enum generic_irdr_coding )0, (yyvsp + -1)->token);
  }
#line 110
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 113
  svf_endxr((enum generic_irdr_coding )1, (yyvsp + -1)->token);
  }
#line 115
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 118
  svf_frequency(0.0);
  }
#line 120
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 123
  svf_frequency((yyvsp + -2)->dvalue);
  }
#line 125
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 128
  p = & parser_params.ths_params;
#line 130
  p->number = (yyvsp + -2)->dvalue;
#line 131
  svf_hxr((enum generic_irdr_coding )1, p);
#line 132
  svf_free_ths_params(p);
  }
#line 134
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 137
  p___0 = & parser_params.ths_params;
#line 139
  p___0->number = (yyvsp + -2)->dvalue;
#line 140
  svf_hxr((enum generic_irdr_coding )0, p___0);
#line 141
  svf_free_ths_params(p___0);
  }
#line 143
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"PIOMAP not implemented\n");
#line 147
  yyerror("PIOMAP");
  }
#line 148
  goto yyerrorlab;
#line 150
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 153
  free((void *)(yyvsp + -1)->cvalue);
#line 154
  printf((char const   */* __restrict  */)"PIO not implemented\n");
#line 155
  yyerror("PIO");
  }
#line 156
  goto yyerrorlab;
#line 158
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 161
  rt = & parser_params.runtest;
#line 163
  rt->run_state = (yyvsp + -4)->token;
#line 164
  rt->run_count = (uint32_t )(yyvsp + -3)->tdval.dvalue;
#line 165
  rt->run_clk = (yyvsp + -3)->tdval.token;
#line 166
  rt->end_state = (yyvsp + -1)->token;
#line 168
  tmp___0 = svf_runtest(rt);
  }
#line 168
  if (! tmp___0) {
    {
#line 169
    yyerror("RUNTEST");
    }
#line 170
    goto yyerrorlab;
  }
#line 173
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 176
  rt___0 = & parser_params.runtest;
#line 178
  rt___0->run_state = (yyvsp + -3)->token;
#line 179
  rt___0->run_count = (uint32_t )0;
#line 180
  rt___0->run_clk = 0;
#line 181
  rt___0->end_state = (yyvsp + -1)->token;
#line 183
  tmp___1 = svf_runtest(rt___0);
  }
#line 183
  if (! tmp___1) {
    {
#line 184
    yyerror("RUNTEST");
    }
#line 185
    goto yyerrorlab;
  }
#line 188
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 191
  p___1 = & parser_params.ths_params;
#line 194
  p___1->number = (yyvsp + -2)->dvalue;
#line 195
  result = svf_sxr((enum generic_irdr_coding )1, p___1, & yyloc);
#line 196
  svf_free_ths_params(p___1);
  }
#line 198
  if (! result) {
    {
#line 199
    yyerror("SDR");
    }
#line 200
    goto yyerrorlab;
  }
#line 203
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 206
  p___2 = & parser_params.ths_params;
#line 209
  p___2->number = (yyvsp + -2)->dvalue;
#line 210
  result___0 = svf_sxr((enum generic_irdr_coding )0, p___2, & yyloc);
#line 211
  svf_free_ths_params(p___2);
  }
#line 213
  if (! result___0) {
    {
#line 214
    yyerror("SIR");
    }
#line 215
    goto yyerrorlab;
  }
#line 218
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 221
  tmp___2 = svf_state(& parser_params.path_states, (yyvsp + -1)->token);
  }
#line 221
  if (! tmp___2) {
    {
#line 222
    yyerror("STATE");
    }
#line 223
    goto yyerrorlab;
  }
#line 226
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 229
  p___3 = & parser_params.ths_params;
#line 232
  p___3->number = (yyvsp + -2)->dvalue;
#line 233
  result___1 = svf_txr((enum generic_irdr_coding )1, p___3);
#line 234
  svf_free_ths_params(p___3);
  }
#line 236
  if (! result___1) {
    {
#line 237
    yyerror("TDR");
    }
#line 238
    goto yyerrorlab;
  }
#line 241
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 244
  p___4 = & parser_params.ths_params;
#line 247
  p___4->number = (yyvsp + -2)->dvalue;
#line 248
  result___2 = svf_txr((enum generic_irdr_coding )0, p___4);
#line 249
  svf_free_ths_params(p___4);
  }
#line 251
  if (! result___2) {
    {
#line 252
    yyerror("TIR");
    }
#line 253
    goto yyerrorlab;
  }
#line 256
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 259
  tmp___3 = svf_trst((yyvsp + -1)->token);
  }
#line 259
  if (! tmp___3) {
    {
#line 260
    yyerror("TRST");
    }
#line 261
    goto yyerrorlab;
  }
#line 264
  goto switch_break;
  case_23: /* CIL Label */ 
#line 275
  parser_params.ths_params.tdi = (yyvsp + 0)->cvalue;
#line 277
  goto switch_break;
  case_24: /* CIL Label */ 
#line 280
  parser_params.ths_params.tdo = (yyvsp + 0)->cvalue;
#line 282
  goto switch_break;
  case_25: /* CIL Label */ 
#line 285
  parser_params.ths_params.mask = (yyvsp + 0)->cvalue;
#line 287
  goto switch_break;
  case_26: /* CIL Label */ 
#line 290
  parser_params.ths_params.smask = (yyvsp + 0)->cvalue;
#line 292
  goto switch_break;
  case_31: /* CIL Label */ 
#line 302
  yyval.token = 0;
#line 303
  goto switch_break;
  case_32: /* CIL Label */ 
#line 305
  yyval.token = (yyvsp + 0)->token;
#line 307
  goto switch_break;
  case_33: /* CIL Label */ 
#line 312
  yyval.tdval.token = (yyvsp + 0)->token;
#line 313
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 315
  goto switch_break;
  case_34: /* CIL Label */ 
#line 318
  yyval.tdval.token = (yyvsp + 0)->token;
#line 319
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 321
  goto switch_break;
  case_35: /* CIL Label */ 
#line 326
  parser_params.runtest.min_time = 0.0;
#line 327
  parser_params.runtest.max_time = 0.0;
#line 329
  goto switch_break;
  case_37: /* CIL Label */ 
#line 336
  parser_params.runtest.min_time = (yyvsp + -2)->dvalue;
#line 338
  goto switch_break;
  case_39: /* CIL Label */ 
#line 344
  parser_params.runtest.max_time = (yyvsp + -1)->dvalue;
#line 346
  goto switch_break;
  case_40: /* CIL Label */ 
#line 349
  yyval.token = 0;
#line 350
  goto switch_break;
  case_41: /* CIL Label */ 
#line 352
  yyval.token = (yyvsp + 0)->token;
#line 354
  goto switch_break;
  case_58: /* CIL Label */ 
#line 378
  parser_params.path_states.num_states = 0;
#line 380
  goto switch_break;
  case_59: /* CIL Label */ 
#line 383
  ps = & parser_params.path_states;
#line 385
  if (ps->num_states < 64) {
#line 386
    ps->states[ps->num_states] = (yyvsp + 0)->token;
#line 387
    (ps->num_states) ++;
  } else {
    {
#line 389
    printf((char const   */* __restrict  */)"Error %s: maximum number of %d path states reached.\n",
           "svf", 64);
    }
  }
#line 392
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1914 "svf_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1918
  yyvsp -= yylen;
#line 1918
  yyssp -= yylen;
#line 1918
  yylsp -= yylen;
#line 1919
  yylen = 0;
#line 1922
  yyvsp ++;
#line 1922
  *yyvsp = yyval;
#line 1923
  yylsp ++;
#line 1923
  *yylsp = yyloc;
#line 1929
  yyn = (int )yyr1[yyn];
#line 1931
  yystate = (int )((int const   )yypgoto[yyn - 63] + (int const   )*yyssp);
#line 1932
  if (0 <= yystate) {
#line 1932
    if (yystate <= 145) {
#line 1932
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1933
        yystate = (int )yytable[yystate];
      } else {
#line 1935
        yystate = (int )yydefgoto[yyn - 63];
      }
    } else {
#line 1935
      yystate = (int )yydefgoto[yyn - 63];
    }
  } else {
#line 1935
    yystate = (int )yydefgoto[yyn - 63];
  }
#line 1937
  goto yynewstate;
  yyerrlab: 
#line 1945
  if (! yyerrstatus) {
    {
#line 1947
    yynerrs ++;
#line 1952
    tmp___4 = yysyntax_error((char *)0, yystate, yychar);
#line 1952
    yysize___0 = tmp___4;
    }
#line 1953
    if (yymsg_alloc < yysize___0) {
#line 1953
      if (yymsg_alloc < 0xffffffffffffffffUL) {
#line 1955
        yyalloc___0 = 2UL * yysize___0;
#line 1956
        if (yysize___0 <= yyalloc___0) {
#line 1956
          if (! (yyalloc___0 <= 0xffffffffffffffffUL)) {
#line 1957
            yyalloc___0 = 0xffffffffffffffffUL;
          }
        } else {
#line 1957
          yyalloc___0 = 0xffffffffffffffffUL;
        }
#line 1958
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 1959
          free((void *)yymsg);
          }
        }
        {
#line 1960
        tmp___5 = malloc(yyalloc___0);
#line 1960
        yymsg = (char *)tmp___5;
        }
#line 1961
        if (yymsg) {
#line 1962
          yymsg_alloc = yyalloc___0;
        } else {
#line 1965
          yymsg = yymsgbuf;
#line 1966
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 1970
    if (0UL < yysize___0) {
#line 1970
      if (yysize___0 <= yymsg_alloc) {
        {
#line 1972
        yysyntax_error(yymsg, yystate, yychar);
#line 1973
        yyerror((char const   *)yymsg);
        }
      } else {
#line 1970
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1977
      yyerror("syntax error");
      }
#line 1978
      if (yysize___0 != 0UL) {
#line 1979
        goto yyexhaustedlab;
      }
    }
  }
#line 1985
  yyerror_range[0] = yylloc;
#line 1987
  if (yyerrstatus == 3) {
#line 1992
    if (yychar <= 0) {
#line 1995
      if (yychar == 0) {
#line 1996
        goto yyabortlab;
      }
    } else {
      {
#line 2000
      yydestruct("Error: discarding", yytoken, & yylval, & yylloc);
#line 2002
      yychar = -2;
      }
    }
  }
#line 2008
  goto yyerrlab1;
  yyerrorlab: 
#line 2022
  yyerror_range[0] = *(yylsp + (1 - yylen));
#line 2025
  yyvsp -= yylen;
#line 2025
  yyssp -= yylen;
#line 2025
  yylsp -= yylen;
#line 2026
  yylen = 0;
#line 2028
  yystate = (int )*yyssp;
#line 2029
  goto yyerrlab1;
  yyerrlab1: 
#line 2036
  yyerrstatus = 3;
  {
#line 2038
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2040
    yyn = (int )yypact[yystate];
#line 2041
    if (yyn != -24) {
#line 2043
      yyn ++;
#line 2044
      if (0 <= yyn) {
#line 2044
        if (yyn <= 145) {
#line 2044
          if ((int const   )yycheck[yyn] == 1) {
#line 2046
            yyn = (int )yytable[yyn];
#line 2047
            if (0 < yyn) {
#line 2048
              goto while_break___3;
            }
          }
        }
      }
    }
#line 2053
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2054
      goto yyabortlab;
    }
    {
#line 2056
    yyerror_range[0] = *yylsp;
#line 2057
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, yylsp);
#line 2059
    yyvsp --;
#line 2059
    yyssp --;
#line 2059
    yylsp --;
#line 2060
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2064
  if (yyn == 4) {
#line 2065
    goto yyacceptlab;
  }
#line 2067
  yyvsp ++;
#line 2067
  *yyvsp = yylval;
#line 2069
  yyerror_range[1] = yylloc;
  {
#line 2072
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2072
    yyloc.first_line = ((yyerror_range - 1) + 1)->first_line;
#line 2072
    yyloc.first_column = ((yyerror_range - 1) + 1)->first_column;
#line 2072
    yyloc.last_line = ((yyerror_range - 1) + 2)->last_line;
#line 2072
    yyloc.last_column = ((yyerror_range - 1) + 2)->last_column;
#line 2072
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2073
  yylsp ++;
#line 2073
  *yylsp = yyloc;
#line 2078
  yystate = yyn;
#line 2079
  goto yynewstate;
  yyacceptlab: 
#line 2086
  yyresult = 0;
#line 2087
  goto yyreturn;
  yyabortlab: 
#line 2093
  yyresult = 1;
#line 2094
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2101
  yyerror("memory exhausted");
#line 2102
  yyresult = 2;
  }
  yyreturn: 
#line 2107
  if (yychar != 0) {
#line 2107
    if (yychar != -2) {
      {
#line 2108
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, & yylloc);
      }
    }
  }
#line 2112
  yyvsp -= yylen;
#line 2112
  yyssp -= yylen;
#line 2112
  yylsp -= yylen;
  {
#line 2114
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2114
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2114
      goto while_break___5;
    }
    {
#line 2116
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, yylsp);
#line 2118
    yyvsp --;
#line 2118
    yyssp --;
#line 2118
    yylsp --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2121
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2122
    free((void *)yyss);
    }
  }
#line 2125
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2126
    free((void *)yymsg);
    }
  }
#line 2129
  return (yyresult);
}
}
#line 415 "svf_bison.y"
void yyerror(char const   *error_string ) 
{ 


  {
  {
#line 418
  printf((char const   */* __restrict  */)"Error occured for SVF command %s.\n", error_string);
  }
#line 419
  return;
}
}
#line 422 "svf_bison.y"
static void svf_free_ths_params(struct ths_params *params ) 
{ 


  {
#line 425
  params->number = 0.0;
#line 427
  if (params->tdi) {
    {
#line 428
    free((void *)params->tdi);
#line 429
    params->tdi = (char *)((void *)0);
    }
  }
#line 431
  if (params->tdo) {
    {
#line 432
    free((void *)params->tdo);
#line 433
    params->tdo = (char *)((void *)0);
    }
  }
#line 435
  if (params->mask) {
    {
#line 436
    free((void *)params->mask);
#line 437
    params->mask = (char *)((void *)0);
    }
  }
#line 439
  if (params->smask) {
    {
#line 440
    free((void *)params->smask);
#line 441
    params->smask = (char *)((void *)0);
    }
  }
#line 443
  return;
}
}
#line 62 "../../include/part.h"
signal_t *part_find_signal(part_t *p , char const   *signalname ) ;
#line 64
void part_set_signal(part_t *p , signal_t *s , int out , int val ) ;
#line 65
int part_get_signal(part_t *p , signal_t *s ) ;
#line 51 "../../include/chain.h"
void chain_shift_instructions(chain_t *chain___0 ) ;
#line 53
void chain_shift_data_registers(chain_t *chain___0 , int capture_output ) ;
#line 51 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  zefant_xs3_bus ;
#line 152 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static uint32_t last_address  =    (uint32_t )0;
#line 154 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void setup_address(bus_t *bus___0 , uint32_t a , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 158
  p = ((bus_params_t *)bus___0->params)->part;
#line 161
  last_address = a;
  {
#line 164
  if ((unsigned int )comp->ctype == 1U) {
#line 164
    goto case_1;
  }
#line 169
  if ((unsigned int )comp->ctype == 0U) {
#line 169
    goto case_0;
  }
#line 176
  if ((unsigned int )comp->ctype == 3U) {
#line 176
    goto case_3;
  }
#line 176
  if ((unsigned int )comp->ctype == 2U) {
#line 176
    goto case_3;
  }
#line 179
  goto switch_default;
  case_1: /* CIL Label */ 
#line 165
  addr_width = 25;
#line 168
  goto switch_break;
  case_0: /* CIL Label */ 
#line 170
  addr_width = 18;
#line 173
  a >>= 1;
#line 174
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 177
  addr_width = 16;
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 180
  addr_width = 0;
#line 181
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < addr_width)) {
#line 184
      goto while_break;
    }
    {
#line 185
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 184
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static int detect_data_width(component_t *comp ) 
{ 
  int width ;

  {
  {
#line 194
  if ((unsigned int )comp->ctype == 0U) {
#line 194
    goto case_0;
  }
#line 197
  if ((unsigned int )comp->ctype == 1U) {
#line 197
    goto case_1;
  }
#line 201
  if ((unsigned int )comp->ctype == 3U) {
#line 201
    goto case_3;
  }
#line 201
  if ((unsigned int )comp->ctype == 2U) {
#line 201
    goto case_3;
  }
#line 204
  goto switch_default;
  case_0: /* CIL Label */ 
#line 195
  width = 16;
#line 196
  goto switch_break;
  case_1: /* CIL Label */ 
#line 198
  width = 16;
#line 199
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 202
  width = 8;
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 205
  width = 0;
#line 206
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 209
  return (width);
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void set_data_in(bus_t *bus___0 , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 216
  p = ((bus_params_t *)bus___0->params)->part;
#line 219
  width = detect_data_width(comp);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < width)) {
#line 221
      goto while_break;
    }
    {
#line 222
    part_set_signal(p, comp->d[i], 0, 0);
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void setup_data(bus_t *bus___0 , uint32_t d , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 229
  p = ((bus_params_t *)bus___0->params)->part;
#line 232
  width = detect_data_width(comp);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < width)) {
#line 234
      goto while_break;
    }
    {
#line 235
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 238
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t **comp ) ;
#line 244 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 249
  i = 0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i < ((((bus_params_t *)bus___0->params)->chain)->parts)->len)) {
#line 249
      goto while_break;
    }
#line 250
    if ((unsigned long )((bus_params_t *)bus___0->params)->part == (unsigned long )*(((((bus_params_t *)bus___0->params)->chain)->parts)->parts + i)) {
#line 251
      goto while_break;
    }
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  tmp = gettext("Simple Solutions Zefant-XS3 Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 252
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 253
  return;
}
}
#line 259 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_prepare(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  component_t *comp ;

  {
  {
#line 262
  p = ((bus_params_t *)bus___0->params)->part;
#line 263
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 269
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 270
  chain_shift_instructions(chain___0);
#line 273
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 274
  setup_data(bus___0, (uint32_t )0, comp);
#line 275
  part_set_signal(p, comp->ncs, 1, 1);
#line 276
  part_set_signal(p, comp->nwe, 1, 1);
#line 277
  part_set_signal(p, comp->noe, 1, 1);
#line 278
  part_set_signal(p, comp->nrp, 1, 1);
#line 279
  part_set_signal(p, comp->nbyte, 1, 1);
#line 280
  part_set_signal(p, comp->sts, 0, 0);
#line 283
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 284
  setup_data(bus___0, (uint32_t )0, comp);
#line 285
  part_set_signal(p, comp->ncs, 1, 1);
#line 286
  part_set_signal(p, comp->nwe, 1, 1);
#line 287
  part_set_signal(p, comp->noe, 1, 1);
#line 288
  part_set_signal(p, comp->nlb, 1, 1);
#line 289
  part_set_signal(p, comp->nub, 1, 1);
#line 292
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 293
  setup_data(bus___0, (uint32_t )0, comp);
#line 294
  part_set_signal(p, comp->ncs, 1, 1);
#line 295
  part_set_signal(p, comp->nwe, 1, 1);
#line 296
  part_set_signal(p, comp->noe, 1, 1);
#line 297
  part_set_signal(p, comp->nlb, 1, 1);
#line 298
  part_set_signal(p, comp->nub, 1, 1);
#line 301
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 302
  part_set_signal(p, comp->si, 1, 0);
#line 303
  part_set_signal(p, comp->so, 0, 0);
#line 304
  part_set_signal(p, comp->sck, 1, 0);
#line 305
  part_set_signal(p, comp->ncs, 1, 1);
#line 308
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 309
  part_set_signal(p, comp->si, 1, 0);
#line 310
  part_set_signal(p, comp->so, 0, 0);
#line 311
  part_set_signal(p, comp->sck, 1, 0);
#line 312
  part_set_signal(p, comp->ncs, 1, 1);
#line 314
  chain_shift_data_registers(chain___0, 0);
#line 316
  part_set_instruction(p, "EXTEST");
#line 317
  chain_shift_instructions(chain___0);
  }
#line 318
  return;
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static uint8_t eeprom_shift_byte(chain_t *chain___0 , part_t *p , component_t *comp ,
                                 uint8_t byte ) 
{ 
  int pos ;
  uint8_t so_data ;
  int tmp ;

  {
#line 325
  so_data = (uint8_t )0;
#line 327
  pos = 7;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (pos >= 0)) {
#line 327
      goto while_break;
    }
    {
#line 329
    part_set_signal(p, comp->sck, 1, 0);
#line 331
    part_set_signal(p, comp->si, 1, ((int )byte >> pos) & 1);
#line 333
    chain_shift_data_registers(chain___0, 1);
#line 336
    part_set_signal(p, comp->sck, 1, 1);
#line 338
    chain_shift_data_registers(chain___0, 1);
#line 341
    tmp = part_get_signal(p, comp->so);
#line 341
    so_data = (uint8_t )((int )so_data | (int )((uint8_t )(tmp << pos)));
#line 327
    pos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (so_data);
}
}
#line 348 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void eeprom_disable_device(chain_t *chain___0 , part_t *p , component_t *comp ) 
{ 


  {
  {
#line 352
  part_set_signal(p, comp->sck, 1, 0);
#line 353
  chain_shift_data_registers(chain___0, 0);
#line 356
  part_set_signal(p, comp->ncs, 1, 1);
#line 357
  chain_shift_data_registers(chain___0, 0);
  }
#line 358
  return;
}
}
#line 364 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 367
  p = ((bus_params_t *)bus___0->params)->part;
#line 368
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 371
  cmd = (uint8_t )3;
#line 373
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 374
  if (! comp) {
    {
#line 375
    tmp = gettext("Address out of range\n");
#line 375
    printf((char const   */* __restrict  */)tmp);
#line 376
    last_address = adr;
    }
#line 377
    return;
  }
  {
#line 383
  if ((unsigned int )comp->ctype == 0U) {
#line 383
    goto case_0;
  }
#line 383
  if ((unsigned int )comp->ctype == 1U) {
#line 383
    goto case_0;
  }
#line 399
  if ((unsigned int )comp->ctype == 3U) {
#line 399
    goto case_3;
  }
#line 402
  if ((unsigned int )comp->ctype == 2U) {
#line 402
    goto case_2;
  }
#line 419
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 384
  part_set_signal(p, comp->ncs, 1, 0);
#line 385
  part_set_signal(p, comp->nwe, 1, 1);
#line 386
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 387
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 388
    part_set_signal(p, comp->nlb, 1, 0);
#line 389
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 392
  setup_address(bus___0, adr, comp);
#line 393
  set_data_in(bus___0, comp);
#line 395
  chain_shift_data_registers(chain___0, 0);
  }
#line 397
  goto switch_break;
  case_3: /* CIL Label */ 
#line 400
  cmd = (uint8_t )5;
  case_2: /* CIL Label */ 
  {
#line 404
  part_set_signal(p, comp->ncs, 1, 0);
#line 407
  eeprom_shift_byte(chain___0, p, comp, cmd);
  }
#line 409
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 411
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 413
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )(adr & 255U));
    }
  }
#line 416
  last_address = adr;
#line 417
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 420
  tmp___0 = gettext("Component type not supported\n");
#line 420
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 421
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 430 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 433
  p = ((bus_params_t *)bus___0->params)->part;
#line 434
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 436
  d = (uint32_t )0;
#line 440
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 441
  if (! comp) {
    {
#line 442
    tmp = gettext("Address out of range\n");
#line 442
    printf((char const   */* __restrict  */)tmp);
#line 443
    last_address = adr;
    }
#line 444
    return ((uint32_t )0);
  }
  {
#line 450
  if ((unsigned int )comp->ctype == 0U) {
#line 450
    goto case_0;
  }
#line 450
  if ((unsigned int )comp->ctype == 1U) {
#line 450
    goto case_0;
  }
#line 460
  if ((unsigned int )comp->ctype == 2U) {
#line 460
    goto case_2;
  }
#line 460
  if ((unsigned int )comp->ctype == 3U) {
#line 460
    goto case_2;
  }
#line 465
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 451
  setup_address(bus___0, adr, comp);
#line 452
  chain_shift_data_registers(chain___0, 1);
#line 454
  i = 0;
  }
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! ((unsigned int )i < area.width)) {
#line 454
      goto while_break;
    }
    {
#line 455
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 455
    d |= (uint32_t )(tmp___0 << i);
#line 454
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 462
  tmp___1 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
#line 462
  d = (uint32_t )tmp___1;
  }
#line 463
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 466
  tmp___2 = gettext("Component type not supported\n");
#line 466
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 467
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 470
  return (d);
}
}
#line 477 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 480
  p = ((bus_params_t *)bus___0->params)->part;
#line 481
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 483
  d = (uint32_t )0;
#line 488
  comp_bus_area(bus___0, last_address, & area, & comp);
  }
#line 489
  if (! comp) {
    {
#line 490
    tmp = gettext("Address out of range\n");
#line 490
    printf((char const   */* __restrict  */)tmp);
    }
#line 491
    return ((uint32_t )0);
  }
  {
#line 497
  if ((unsigned int )comp->ctype == 0U) {
#line 497
    goto case_0;
  }
#line 497
  if ((unsigned int )comp->ctype == 1U) {
#line 497
    goto case_0;
  }
#line 512
  if ((unsigned int )comp->ctype == 2U) {
#line 512
    goto case_2;
  }
#line 512
  if ((unsigned int )comp->ctype == 3U) {
#line 512
    goto case_2;
  }
#line 519
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 498
  part_set_signal(p, comp->ncs, 1, 1);
#line 499
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 500
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 501
    part_set_signal(p, comp->nlb, 1, 1);
#line 502
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 504
  chain_shift_data_registers(chain___0, 1);
#line 506
  i = 0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! ((unsigned int )i < area.width)) {
#line 506
      goto while_break;
    }
    {
#line 507
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 507
    d |= (uint32_t )(tmp___0 << i);
#line 506
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 514
  tmp___1 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
#line 514
  d = (uint32_t )tmp___1;
#line 515
  eeprom_disable_device(chain___0, p, comp);
  }
#line 517
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 520
  tmp___2 = gettext("Component type not supported\n");
#line 520
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 521
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 524
  return (d);
}
}
#line 531 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 534
  zefant_xs3_bus_read_start(bus___0, adr);
#line 535
  tmp = zefant_xs3_bus_read_end(bus___0);
  }
#line 535
  return (tmp);
}
}
#line 542 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  uint8_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 545
  p = ((bus_params_t *)bus___0->params)->part;
#line 546
  chain___0 = ((bus_params_t *)bus___0->params)->chain;
#line 549
  cmd = (uint8_t )2;
#line 551
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 552
  if (! comp) {
    {
#line 553
    tmp = gettext("Address out of range\n");
#line 553
    printf((char const   */* __restrict  */)tmp);
    }
#line 554
    return;
  }
  {
#line 559
  if ((unsigned int )comp->ctype == 0U) {
#line 559
    goto case_0;
  }
#line 559
  if ((unsigned int )comp->ctype == 1U) {
#line 559
    goto case_0;
  }
#line 585
  if ((unsigned int )comp->ctype == 3U) {
#line 585
    goto case_3;
  }
#line 588
  if ((unsigned int )comp->ctype == 2U) {
#line 588
    goto case_2;
  }
#line 639
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 560
  part_set_signal(p, comp->ncs, 1, 0);
#line 561
  part_set_signal(p, comp->nwe, 1, 1);
#line 562
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 563
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 564
    part_set_signal(p, comp->nlb, 1, 0);
#line 565
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 568
  setup_address(bus___0, adr, comp);
#line 569
  setup_data(bus___0, data, comp);
#line 571
  chain_shift_data_registers(chain___0, 0);
#line 573
  part_set_signal(p, comp->nwe, 1, 0);
#line 574
  chain_shift_data_registers(chain___0, 0);
#line 575
  part_set_signal(p, comp->nwe, 1, 1);
#line 576
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 577
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 578
    part_set_signal(p, comp->nlb, 1, 1);
#line 579
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 581
  chain_shift_data_registers(chain___0, 0);
  }
#line 583
  goto switch_break;
  case_3: /* CIL Label */ 
#line 586
  cmd = (uint8_t )1;
  case_2: /* CIL Label */ 
  {
#line 593
  part_set_signal(p, comp->ncs, 1, 0);
  }
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 597
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )5);
#line 596
    tmp___0 = eeprom_shift_byte(chain___0, p, comp, (uint8_t )0);
    }
#line 596
    if (! ((int )tmp___0 & 1)) {
#line 596
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 600
  eeprom_disable_device(chain___0, p, comp);
#line 607
  part_set_signal(p, comp->ncs, 1, 0);
#line 610
  eeprom_shift_byte(chain___0, p, comp, (uint8_t )6);
#line 612
  eeprom_disable_device(chain___0, p, comp);
#line 619
  part_set_signal(p, comp->ncs, 1, 0);
#line 623
  eeprom_shift_byte(chain___0, p, comp, cmd);
  }
#line 625
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 627
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 629
    eeprom_shift_byte(chain___0, p, comp, (uint8_t )(adr & 255U));
    }
  }
  {
#line 633
  eeprom_shift_byte(chain___0, p, comp, (uint8_t )(data & 255U));
#line 635
  eeprom_disable_device(chain___0, p, comp);
  }
#line 637
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 640
  tmp___1 = gettext("Component type not supported\n");
#line 640
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 641
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 643
  return;
}
}
#line 650 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t **comp ) 
{ 


  {
#line 653
  if (adr < (uint32_t )(1 << 25)) {
#line 654
    area->description = "FLASH Component";
#line 655
    area->start = (uint32_t )0;
#line 656
    area->length = (uint64_t )(1 << 25);
#line 657
    area->width = 16U;
#line 658
    *comp = & ((bus_params_t *)bus___0->params)->flash;
  } else
#line 659
  if (adr < (uint32_t )((1 << 25) + (1 << 19))) {
#line 660
    area->description = "SO-DIMM RAM0 Component";
#line 661
    area->start = (uint32_t )(1 << 25);
#line 662
    area->length = (uint64_t )(1 << 19);
#line 663
    area->width = 16U;
#line 664
    *comp = & ((bus_params_t *)bus___0->params)->ram0;
  } else
#line 665
  if (adr < (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19))) {
#line 666
    area->description = "SO-DIMM RAM1 Component";
#line 667
    area->start = (uint32_t )((1 << 25) + (1 << 19));
#line 668
    area->length = (uint64_t )(1 << 19);
#line 669
    area->width = 16U;
#line 670
    *comp = & ((bus_params_t *)bus___0->params)->ram1;
  } else
#line 671
  if (adr < (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16))) {
#line 672
    area->description = "EEPROM Component";
#line 673
    area->start = (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19));
#line 674
    area->length = (uint64_t )(1 << 16);
#line 675
    area->width = 8U;
#line 676
    *comp = & ((bus_params_t *)bus___0->params)->eeprom;
  } else
#line 677
  if (adr < (uint32_t )(((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16)) + 3)) {
#line 678
    area->description = "EEPROM Component Status";
#line 679
    area->start = (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16));
#line 680
    area->length = (uint64_t )(1 << 16);
#line 681
    area->width = 8U;
#line 682
    *comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
  } else {
#line 684
    area->description = "Dummy";
#line 685
    area->start = (uint32_t )(((1 << 25) + 2 * (1 << 19)) + 2 * (1 << 16));
#line 686
    area->length = 4294967296UL;
#line 687
    area->width = 0U;
#line 688
    *comp = (component_t *)((void *)0);
  }
#line 691
  return (0);
}
}
#line 695 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t *comp ;
  int tmp ;

  {
  {
#line 700
  tmp = comp_bus_area(bus___0, adr, area, & comp);
  }
#line 700
  return (tmp);
}
}
#line 704 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 707
  free(bus___0->params);
#line 708
  free((void *)bus___0);
  }
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static int attach_sig(bus_t *bus___0 , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;

  {
  {
#line 714
  failed = 0;
#line 716
  *sig = part_find_signal(((bus_params_t *)bus___0->params)->part, (char const   *)id);
  }
#line 717
  if (! *sig) {
    {
#line 718
    tmp = gettext("signal \'%s\' not found\n");
#line 718
    printf((char const   */* __restrict  */)tmp, id);
#line 719
    failed = 1;
    }
  }
#line 722
  return (failed);
}
}
#line 725 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
static bus_t *zefant_xs3_bus_new(void) 
{ 
  bus_t *bus___0 ;
  int failed ;
  component_t *comp ;
  int idx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;

  {
#line 729
  failed = 0;
#line 733
  if (! chain) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if (! chain->parts) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if ((chain->parts)->len <= chain->active_part) {
#line 734
    return ((bus_t *)((void *)0));
  } else
#line 733
  if (chain->active_part < 0) {
#line 734
    return ((bus_t *)((void *)0));
  }
  {
#line 736
  tmp = malloc(sizeof(bus_t ));
#line 736
  bus___0 = (bus_t *)tmp;
  }
#line 737
  if (! bus___0) {
#line 738
    return ((bus_t *)((void *)0));
  }
  {
#line 740
  bus___0->driver = & zefant_xs3_bus;
#line 741
  bus___0->params = malloc(sizeof(bus_params_t ));
  }
#line 742
  if (! bus___0->params) {
    {
#line 743
    free((void *)bus___0);
    }
#line 744
    return ((bus_t *)((void *)0));
  }
  {
#line 747
  ((bus_params_t *)bus___0->params)->chain = chain;
#line 748
  ((bus_params_t *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 753
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 754
  comp->ctype = (ctype_t )1;
#line 755
  comp->cname = (char *)"FLASH";
#line 757
  tmp___0 = attach_sig(bus___0, & comp->a[0], (char *)"IO_V9");
#line 757
  failed |= tmp___0;
#line 758
  tmp___1 = attach_sig(bus___0, & comp->a[1], (char *)"IO_U10");
#line 758
  failed |= tmp___1;
#line 759
  tmp___2 = attach_sig(bus___0, & comp->a[2], (char *)"IO_V10");
#line 759
  failed |= tmp___2;
#line 760
  tmp___3 = attach_sig(bus___0, & comp->a[3], (char *)"IO_W10");
#line 760
  failed |= tmp___3;
#line 761
  tmp___4 = attach_sig(bus___0, & comp->a[4], (char *)"IO_Y10");
#line 761
  failed |= tmp___4;
#line 762
  tmp___5 = attach_sig(bus___0, & comp->a[5], (char *)"IO_W8");
#line 762
  failed |= tmp___5;
#line 763
  tmp___6 = attach_sig(bus___0, & comp->a[6], (char *)"IO_W9");
#line 763
  failed |= tmp___6;
#line 764
  tmp___7 = attach_sig(bus___0, & comp->a[7], (char *)"IO_V8");
#line 764
  failed |= tmp___7;
#line 765
  tmp___8 = attach_sig(bus___0, & comp->a[8], (char *)"IO_V6");
#line 765
  failed |= tmp___8;
#line 766
  tmp___9 = attach_sig(bus___0, & comp->a[9], (char *)"IO_AA8");
#line 766
  failed |= tmp___9;
#line 767
  tmp___10 = attach_sig(bus___0, & comp->a[10], (char *)"IO_AB8");
#line 767
  failed |= tmp___10;
#line 768
  tmp___11 = attach_sig(bus___0, & comp->a[11], (char *)"IO_U7");
#line 768
  failed |= tmp___11;
#line 769
  tmp___12 = attach_sig(bus___0, & comp->a[12], (char *)"IO_V7");
#line 769
  failed |= tmp___12;
#line 770
  tmp___13 = attach_sig(bus___0, & comp->a[13], (char *)"IO_U6");
#line 770
  failed |= tmp___13;
#line 771
  tmp___14 = attach_sig(bus___0, & comp->a[14], (char *)"IO_Y6");
#line 771
  failed |= tmp___14;
#line 772
  tmp___15 = attach_sig(bus___0, & comp->a[15], (char *)"IO_AB11");
#line 772
  failed |= tmp___15;
#line 773
  tmp___16 = attach_sig(bus___0, & comp->a[16], (char *)"IO_AB10");
#line 773
  failed |= tmp___16;
#line 774
  tmp___17 = attach_sig(bus___0, & comp->a[17], (char *)"IO_AA10");
#line 774
  failed |= tmp___17;
#line 775
  tmp___18 = attach_sig(bus___0, & comp->a[18], (char *)"IO_W6");
#line 775
  failed |= tmp___18;
#line 776
  tmp___19 = attach_sig(bus___0, & comp->a[19], (char *)"IO_AA6");
#line 776
  failed |= tmp___19;
#line 777
  tmp___20 = attach_sig(bus___0, & comp->a[20], (char *)"IO_U11");
#line 777
  failed |= tmp___20;
#line 778
  tmp___21 = attach_sig(bus___0, & comp->a[21], (char *)"IO_Y13");
#line 778
  failed |= tmp___21;
#line 779
  tmp___22 = attach_sig(bus___0, & comp->a[22], (char *)"IO_AB13");
#line 779
  failed |= tmp___22;
#line 780
  tmp___23 = attach_sig(bus___0, & comp->a[23], (char *)"IO_U13");
#line 780
  failed |= tmp___23;
#line 781
  tmp___24 = attach_sig(bus___0, & comp->a[24], (char *)"IO_AA13");
#line 781
  failed |= tmp___24;
#line 783
  tmp___25 = attach_sig(bus___0, & comp->d[0], (char *)"IO_AA14");
#line 783
  failed |= tmp___25;
#line 784
  tmp___26 = attach_sig(bus___0, & comp->d[1], (char *)"IO_AB14");
#line 784
  failed |= tmp___26;
#line 785
  tmp___27 = attach_sig(bus___0, & comp->d[2], (char *)"IO_U12");
#line 785
  failed |= tmp___27;
#line 786
  tmp___28 = attach_sig(bus___0, & comp->d[3], (char *)"IO_V12");
#line 786
  failed |= tmp___28;
#line 787
  tmp___29 = attach_sig(bus___0, & comp->d[4], (char *)"IO_W11");
#line 787
  failed |= tmp___29;
#line 788
  tmp___30 = attach_sig(bus___0, & comp->d[5], (char *)"IO_V11");
#line 788
  failed |= tmp___30;
#line 789
  tmp___31 = attach_sig(bus___0, & comp->d[6], (char *)"IO_AB9");
#line 789
  failed |= tmp___31;
#line 790
  tmp___32 = attach_sig(bus___0, & comp->d[7], (char *)"IO_AA9");
#line 790
  failed |= tmp___32;
#line 791
  tmp___33 = attach_sig(bus___0, & comp->d[8], (char *)"IO_U16");
#line 791
  failed |= tmp___33;
#line 792
  tmp___34 = attach_sig(bus___0, & comp->d[9], (char *)"IO_AB15");
#line 792
  failed |= tmp___34;
#line 793
  tmp___35 = attach_sig(bus___0, & comp->d[10], (char *)"IO_AA15");
#line 793
  failed |= tmp___35;
#line 794
  tmp___36 = attach_sig(bus___0, & comp->d[11], (char *)"IO_W14");
#line 794
  failed |= tmp___36;
#line 795
  tmp___37 = attach_sig(bus___0, & comp->d[12], (char *)"IO_V14");
#line 795
  failed |= tmp___37;
#line 796
  tmp___38 = attach_sig(bus___0, & comp->d[13], (char *)"IO_U14");
#line 796
  failed |= tmp___38;
#line 797
  tmp___39 = attach_sig(bus___0, & comp->d[14], (char *)"IO_W13");
#line 797
  failed |= tmp___39;
#line 798
  tmp___40 = attach_sig(bus___0, & comp->d[15], (char *)"IO_V13");
#line 798
  failed |= tmp___40;
#line 800
  tmp___41 = attach_sig(bus___0, & comp->nwe, (char *)"IO_Y17");
#line 800
  failed |= tmp___41;
#line 801
  tmp___42 = attach_sig(bus___0, & comp->noe, (char *)"IO_AA17");
#line 801
  failed |= tmp___42;
#line 802
  tmp___43 = attach_sig(bus___0, & comp->ncs, (char *)"IO_U17");
#line 802
  failed |= tmp___43;
#line 803
  comp->nlb = (signal_t *)((void *)0);
#line 804
  comp->nub = (signal_t *)((void *)0);
#line 806
  tmp___44 = attach_sig(bus___0, & comp->nrp, (char *)"IO_V16");
#line 806
  failed |= tmp___44;
#line 807
  tmp___45 = attach_sig(bus___0, & comp->nbyte, (char *)"IO_Y16");
#line 807
  failed |= tmp___45;
#line 808
  tmp___46 = attach_sig(bus___0, & comp->sts, (char *)"IO_W16");
#line 808
  failed |= tmp___46;
#line 810
  comp->si = (signal_t *)((void *)0);
#line 811
  comp->so = (signal_t *)((void *)0);
#line 812
  comp->sck = (signal_t *)((void *)0);
#line 817
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 818
  comp->ctype = (ctype_t )0;
#line 819
  comp->cname = (char *)"RAM0";
#line 821
  tmp___47 = attach_sig(bus___0, & comp->a[0], (char *)"IO_AA4");
#line 821
  failed |= tmp___47;
#line 822
  tmp___48 = attach_sig(bus___0, & comp->a[1], (char *)"IO_AB4");
#line 822
  failed |= tmp___48;
#line 823
  tmp___49 = attach_sig(bus___0, & comp->a[2], (char *)"IO_W5");
#line 823
  failed |= tmp___49;
#line 824
  tmp___50 = attach_sig(bus___0, & comp->a[3], (char *)"IO_Y3");
#line 824
  failed |= tmp___50;
#line 825
  tmp___51 = attach_sig(bus___0, & comp->a[4], (char *)"IO_Y1");
#line 825
  failed |= tmp___51;
#line 826
  tmp___52 = attach_sig(bus___0, & comp->a[5], (char *)"IO_M1");
#line 826
  failed |= tmp___52;
#line 827
  tmp___53 = attach_sig(bus___0, & comp->a[6], (char *)"IO_N2");
#line 827
  failed |= tmp___53;
#line 828
  tmp___54 = attach_sig(bus___0, & comp->a[7], (char *)"IO_L2");
#line 828
  failed |= tmp___54;
#line 829
  tmp___55 = attach_sig(bus___0, & comp->a[8], (char *)"IO_L1");
#line 829
  failed |= tmp___55;
#line 830
  tmp___56 = attach_sig(bus___0, & comp->a[9], (char *)"IO_K1");
#line 830
  failed |= tmp___56;
#line 831
  tmp___57 = attach_sig(bus___0, & comp->a[10], (char *)"IO_K3");
#line 831
  failed |= tmp___57;
#line 832
  tmp___58 = attach_sig(bus___0, & comp->a[11], (char *)"IO_L6");
#line 832
  failed |= tmp___58;
#line 833
  tmp___59 = attach_sig(bus___0, & comp->a[12], (char *)"IO_L4");
#line 833
  failed |= tmp___59;
#line 834
  tmp___60 = attach_sig(bus___0, & comp->a[13], (char *)"IO_L3");
#line 834
  failed |= tmp___60;
#line 835
  tmp___61 = attach_sig(bus___0, & comp->a[14], (char *)"IO_K4");
#line 835
  failed |= tmp___61;
#line 836
  tmp___62 = attach_sig(bus___0, & comp->a[15], (char *)"IO_AB5");
#line 836
  failed |= tmp___62;
#line 837
  tmp___63 = attach_sig(bus___0, & comp->a[16], (char *)"IO_AA5");
#line 837
  failed |= tmp___63;
#line 838
  tmp___64 = attach_sig(bus___0, & comp->a[17], (char *)"IO_Y5");
#line 838
  failed |= tmp___64;
#line 839
  comp->a[18] = (signal_t *)((void *)0);
#line 840
  comp->a[19] = (signal_t *)((void *)0);
#line 841
  comp->a[20] = (signal_t *)((void *)0);
#line 842
  comp->a[21] = (signal_t *)((void *)0);
#line 843
  comp->a[22] = (signal_t *)((void *)0);
#line 844
  comp->a[23] = (signal_t *)((void *)0);
#line 845
  comp->a[24] = (signal_t *)((void *)0);
#line 847
  tmp___65 = attach_sig(bus___0, & comp->d[0], (char *)"IO_W1");
#line 847
  failed |= tmp___65;
#line 848
  tmp___66 = attach_sig(bus___0, & comp->d[1], (char *)"IO_V5");
#line 848
  failed |= tmp___66;
#line 849
  tmp___67 = attach_sig(bus___0, & comp->d[2], (char *)"IO_V3");
#line 849
  failed |= tmp___67;
#line 850
  tmp___68 = attach_sig(bus___0, & comp->d[3], (char *)"IO_V1");
#line 850
  failed |= tmp___68;
#line 851
  tmp___69 = attach_sig(bus___0, & comp->d[4], (char *)"IO_N1");
#line 851
  failed |= tmp___69;
#line 852
  tmp___70 = attach_sig(bus___0, & comp->d[5], (char *)"IO_N3");
#line 852
  failed |= tmp___70;
#line 853
  tmp___71 = attach_sig(bus___0, & comp->d[6], (char *)"IO_M2");
#line 853
  failed |= tmp___71;
#line 854
  tmp___72 = attach_sig(bus___0, & comp->d[7], (char *)"IO_M5");
#line 854
  failed |= tmp___72;
#line 855
  tmp___73 = attach_sig(bus___0, & comp->d[8], (char *)"IO_M4");
#line 855
  failed |= tmp___73;
#line 856
  tmp___74 = attach_sig(bus___0, & comp->d[9], (char *)"IO_M6");
#line 856
  failed |= tmp___74;
#line 857
  tmp___75 = attach_sig(bus___0, & comp->d[10], (char *)"IO_L5");
#line 857
  failed |= tmp___75;
#line 858
  tmp___76 = attach_sig(bus___0, & comp->d[11], (char *)"IO_N4");
#line 858
  failed |= tmp___76;
#line 859
  tmp___77 = attach_sig(bus___0, & comp->d[12], (char *)"IO_T6");
#line 859
  failed |= tmp___77;
#line 860
  tmp___78 = attach_sig(bus___0, & comp->d[13], (char *)"IO_V2");
#line 860
  failed |= tmp___78;
#line 861
  tmp___79 = attach_sig(bus___0, & comp->d[14], (char *)"IO_V4");
#line 861
  failed |= tmp___79;
#line 862
  tmp___80 = attach_sig(bus___0, & comp->d[15], (char *)"IO_U5");
#line 862
  failed |= tmp___80;
#line 864
  tmp___81 = attach_sig(bus___0, & comp->ncs, (char *)"IO_W3");
#line 864
  failed |= tmp___81;
#line 865
  tmp___82 = attach_sig(bus___0, & comp->noe, (char *)"IO_Y2");
#line 865
  failed |= tmp___82;
#line 866
  tmp___83 = attach_sig(bus___0, & comp->nwe, (char *)"IO_M3");
#line 866
  failed |= tmp___83;
#line 867
  tmp___84 = attach_sig(bus___0, & comp->nlb, (char *)"IO_W2");
#line 867
  failed |= tmp___84;
#line 868
  tmp___85 = attach_sig(bus___0, & comp->nub, (char *)"IO_W4");
#line 868
  failed |= tmp___85;
#line 869
  comp->nrp = (signal_t *)((void *)0);
#line 870
  comp->nbyte = (signal_t *)((void *)0);
#line 871
  comp->sts = (signal_t *)((void *)0);
#line 873
  comp->si = (signal_t *)((void *)0);
#line 874
  comp->so = (signal_t *)((void *)0);
#line 875
  comp->sck = (signal_t *)((void *)0);
#line 880
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 881
  comp->ctype = (ctype_t )0;
#line 882
  comp->cname = (char *)"RAM1";
#line 884
  tmp___86 = attach_sig(bus___0, & comp->a[0], (char *)"IO_H5");
#line 884
  failed |= tmp___86;
#line 885
  tmp___87 = attach_sig(bus___0, & comp->a[1], (char *)"IO_F5");
#line 885
  failed |= tmp___87;
#line 886
  tmp___88 = attach_sig(bus___0, & comp->a[2], (char *)"IO_F2");
#line 886
  failed |= tmp___88;
#line 887
  tmp___89 = attach_sig(bus___0, & comp->a[3], (char *)"IO_D1");
#line 887
  failed |= tmp___89;
#line 888
  tmp___90 = attach_sig(bus___0, & comp->a[4], (char *)"IO_E1");
#line 888
  failed |= tmp___90;
#line 889
  tmp___91 = attach_sig(bus___0, & comp->a[5], (char *)"IO_F10");
#line 889
  failed |= tmp___91;
#line 890
  tmp___92 = attach_sig(bus___0, & comp->a[6], (char *)"IO_C7");
#line 890
  failed |= tmp___92;
#line 891
  tmp___93 = attach_sig(bus___0, & comp->a[7], (char *)"IO_C10");
#line 891
  failed |= tmp___93;
#line 892
  tmp___94 = attach_sig(bus___0, & comp->a[8], (char *)"IO_A10");
#line 892
  failed |= tmp___94;
#line 893
  tmp___95 = attach_sig(bus___0, & comp->a[9], (char *)"IO_B10");
#line 893
  failed |= tmp___95;
#line 894
  tmp___96 = attach_sig(bus___0, & comp->a[10], (char *)"IO_F11");
#line 894
  failed |= tmp___96;
#line 895
  tmp___97 = attach_sig(bus___0, & comp->a[11], (char *)"IO_A9");
#line 895
  failed |= tmp___97;
#line 896
  tmp___98 = attach_sig(bus___0, & comp->a[12], (char *)"IO_B9");
#line 896
  failed |= tmp___98;
#line 897
  tmp___99 = attach_sig(bus___0, & comp->a[13], (char *)"IO_B8");
#line 897
  failed |= tmp___99;
#line 898
  tmp___100 = attach_sig(bus___0, & comp->a[14], (char *)"IO_F9");
#line 898
  failed |= tmp___100;
#line 899
  tmp___101 = attach_sig(bus___0, & comp->a[15], (char *)"IO_F4");
#line 899
  failed |= tmp___101;
#line 900
  tmp___102 = attach_sig(bus___0, & comp->a[16], (char *)"IO_G6");
#line 900
  failed |= tmp___102;
#line 901
  tmp___103 = attach_sig(bus___0, & comp->a[17], (char *)"IO_G5");
#line 901
  failed |= tmp___103;
#line 902
  comp->a[18] = (signal_t *)((void *)0);
#line 903
  comp->a[19] = (signal_t *)((void *)0);
#line 904
  comp->a[20] = (signal_t *)((void *)0);
#line 905
  comp->a[21] = (signal_t *)((void *)0);
#line 906
  comp->a[22] = (signal_t *)((void *)0);
#line 907
  comp->a[23] = (signal_t *)((void *)0);
#line 908
  comp->a[24] = (signal_t *)((void *)0);
#line 910
  tmp___104 = attach_sig(bus___0, & comp->d[0], (char *)"IO_C1");
#line 910
  failed |= tmp___104;
#line 911
  tmp___105 = attach_sig(bus___0, & comp->d[1], (char *)"IO_E2");
#line 911
  failed |= tmp___105;
#line 912
  tmp___106 = attach_sig(bus___0, & comp->d[2], (char *)"IO_C2");
#line 912
  failed |= tmp___106;
#line 913
  tmp___107 = attach_sig(bus___0, & comp->d[3], (char *)"IO_C3");
#line 913
  failed |= tmp___107;
#line 914
  tmp___108 = attach_sig(bus___0, & comp->d[4], (char *)"IO_B5");
#line 914
  failed |= tmp___108;
#line 915
  tmp___109 = attach_sig(bus___0, & comp->d[5], (char *)"IO_A5");
#line 915
  failed |= tmp___109;
#line 916
  tmp___110 = attach_sig(bus___0, & comp->d[6], (char *)"IO_B6");
#line 916
  failed |= tmp___110;
#line 917
  tmp___111 = attach_sig(bus___0, & comp->d[7], (char *)"IO_D7");
#line 917
  failed |= tmp___111;
#line 918
  tmp___112 = attach_sig(bus___0, & comp->d[8], (char *)"IO_D9");
#line 918
  failed |= tmp___112;
#line 919
  tmp___113 = attach_sig(bus___0, & comp->d[9], (char *)"IO_E9");
#line 919
  failed |= tmp___113;
#line 920
  tmp___114 = attach_sig(bus___0, & comp->d[10], (char *)"IO_F7");
#line 920
  failed |= tmp___114;
#line 921
  tmp___115 = attach_sig(bus___0, & comp->d[11], (char *)"IO_E7");
#line 921
  failed |= tmp___115;
#line 922
  tmp___116 = attach_sig(bus___0, & comp->d[12], (char *)"IO_D5");
#line 922
  failed |= tmp___116;
#line 923
  tmp___117 = attach_sig(bus___0, & comp->d[13], (char *)"IO_C4");
#line 923
  failed |= tmp___117;
#line 924
  tmp___118 = attach_sig(bus___0, & comp->d[14], (char *)"IO_D3");
#line 924
  failed |= tmp___118;
#line 925
  tmp___119 = attach_sig(bus___0, & comp->d[15], (char *)"IO_D4");
#line 925
  failed |= tmp___119;
#line 927
  tmp___120 = attach_sig(bus___0, & comp->ncs, (char *)"IO_D2");
#line 927
  failed |= tmp___120;
#line 928
  tmp___121 = attach_sig(bus___0, & comp->noe, (char *)"IO_F3");
#line 928
  failed |= tmp___121;
#line 929
  tmp___122 = attach_sig(bus___0, & comp->nwe, (char *)"IO_E10");
#line 929
  failed |= tmp___122;
#line 930
  tmp___123 = attach_sig(bus___0, & comp->nlb, (char *)"IO_E4");
#line 930
  failed |= tmp___123;
#line 931
  tmp___124 = attach_sig(bus___0, & comp->nub, (char *)"IO_E3");
#line 931
  failed |= tmp___124;
#line 932
  comp->nrp = (signal_t *)((void *)0);
#line 933
  comp->nbyte = (signal_t *)((void *)0);
#line 934
  comp->sts = (signal_t *)((void *)0);
#line 936
  comp->si = (signal_t *)((void *)0);
#line 937
  comp->so = (signal_t *)((void *)0);
#line 938
  comp->sck = (signal_t *)((void *)0);
#line 943
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 944
  comp->ctype = (ctype_t )2;
#line 945
  comp->cname = (char *)"EEPROM";
#line 947
  tmp___125 = attach_sig(bus___0, & comp->si, (char *)"IO_H19");
#line 947
  failed |= tmp___125;
#line 948
  tmp___126 = attach_sig(bus___0, & comp->so, (char *)"IO_J21");
#line 948
  failed |= tmp___126;
#line 949
  tmp___127 = attach_sig(bus___0, & comp->sck, (char *)"IO_H21");
#line 949
  failed |= tmp___127;
#line 950
  tmp___128 = attach_sig(bus___0, & comp->ncs, (char *)"IO_K22");
#line 950
  failed |= tmp___128;
#line 952
  idx = 0;
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (idx < 25)) {
#line 952
      goto while_break;
    }
#line 953
    comp->a[idx] = (signal_t *)((void *)0);
#line 952
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  idx = 0;
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    if (! (idx < 16)) {
#line 954
      goto while_break___0;
    }
#line 955
    comp->d[idx] = (signal_t *)((void *)0);
#line 954
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 956
  comp->noe = (signal_t *)((void *)0);
#line 957
  comp->nwe = (signal_t *)((void *)0);
#line 958
  comp->nlb = (signal_t *)((void *)0);
#line 959
  comp->nub = (signal_t *)((void *)0);
#line 960
  comp->nrp = (signal_t *)((void *)0);
#line 961
  comp->nbyte = (signal_t *)((void *)0);
#line 962
  comp->sts = (signal_t *)((void *)0);
#line 968
  ((bus_params_t *)bus___0->params)->eeprom_status = ((bus_params_t *)bus___0->params)->eeprom;
#line 969
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 970
  comp->ctype = (ctype_t )3;
#line 971
  comp->cname = (char *)"EEPROM Status";
#line 974
  if (failed) {
    {
#line 975
    free(bus___0->params);
#line 976
    free((void *)bus___0);
    }
#line 977
    return ((bus_t *)((void *)0));
  }
#line 980
  return (bus___0);
}
}
#line 983 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/zefant-xs3.c"
struct bus_driver  const  zefant_xs3_bus  = 
#line 983
     {"zefant-xs3", "Simple Solutions Zefant-XS3 Board compatible bus driver via BSR",
    & zefant_xs3_bus_new, & zefant_xs3_bus_free, & zefant_xs3_bus_printinfo, & zefant_xs3_bus_prepare,
    & zefant_xs3_bus_area, & zefant_xs3_bus_read_start, & zefant_xs3_bus_read_next,
    & zefant_xs3_bus_read_end, & zefant_xs3_bus_read, & zefant_xs3_bus_write, (int (*)(bus_t *bus ))0};
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 48 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  tx4925_bus ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void select_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 69
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 71
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 0);
#line 72
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 73
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 76
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void unselect_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 84
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 86
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 1);
#line 87
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 88
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 89
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 90
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 91
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 92
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 93
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 94
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void setup_address___0(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  int addr_shift ;

  {
#line 108
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 109
  addr_shift = 1;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 20)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->addr[i], 1, (int )((a >> (i + addr_shift)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void set_data_in___0(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void setup_data___0(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void tx4925_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < ((((bus_params_t___0 *)bus___0->params)->chain)->parts)->len)) {
#line 140
      goto while_break;
    }
#line 141
    if ((unsigned long )((bus_params_t___0 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___0 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 142
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp = gettext("Toshiba TX4925 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 143
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void tx4925_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 149
  part_set_instruction(((bus_params_t___0 *)bus___0->params)->part, "EXTEST");
#line 150
  chain_shift_instructions(((bus_params_t___0 *)bus___0->params)->chain);
  }
#line 151
  return;
}
}
#line 153 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void tx4925_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 156
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 157
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 159
  select_flash(bus___0);
#line 160
  setup_address___0(bus___0, adr);
#line 161
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 164
  set_data_in___0(bus___0);
#line 166
  chain_shift_data_registers(chain___0, 0);
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 172
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 173
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 175
  d = (uint32_t )0;
#line 177
  setup_address___0(bus___0, adr);
#line 178
  chain_shift_data_registers(chain___0, 1);
#line 180
  i = 0;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < 16)) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 181
    d |= (uint32_t )(tmp << i);
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return (d);
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 189
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 190
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 192
  d = (uint32_t )0;
#line 194
  unselect_flash(bus___0);
#line 195
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 198
  chain_shift_data_registers(chain___0, 1);
#line 200
  i = 0;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 16)) {
#line 200
      goto while_break;
    }
    {
#line 201
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 201
    d |= (uint32_t )(tmp << i);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (d);
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static uint32_t tx4925_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 209
  tx4925_bus_read_start(bus___0, adr);
#line 210
  tmp = tx4925_bus_read_end(bus___0);
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void tx4925_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 216
  p = ((bus_params_t___0 *)bus___0->params)->part;
#line 217
  chain___0 = ((bus_params_t___0 *)bus___0->params)->chain;
#line 219
  select_flash(bus___0);
#line 220
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 222
  setup_address___0(bus___0, adr);
#line 223
  setup_data___0(bus___0, data);
#line 225
  chain_shift_data_registers(chain___0, 0);
#line 227
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 0);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 230
  unselect_flash(bus___0);
#line 231
  chain_shift_data_registers(chain___0, 0);
  }
#line 232
  return;
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static int tx4925_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 237
  area->description = (char const   *)((void *)0);
#line 238
  area->start = 0U;
#line 239
  area->length = 4294967296UL;
#line 240
  area->width = 16U;
#line 242
  return (0);
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static void tx4925_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 248
  free(bus___0->params);
#line 249
  free((void *)bus___0);
  }
#line 250
  return;
}
}
#line 252
static bus_t *tx4925_bus_new(void) ;
#line 254 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
struct bus_driver  const  tx4925_bus  = 
#line 254
     {"tx4925", "Toshiba TX4925 compatible bus driver via BSR", & tx4925_bus_new, & tx4925_bus_free,
    & tx4925_bus_printinfo, & tx4925_bus_prepare, & tx4925_bus_area, & tx4925_bus_read_start,
    & tx4925_bus_read_next, & tx4925_bus_read_end, & tx4925_bus_read, & tx4925_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 271 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/tx4925.c"
static bus_t *tx4925_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 277
  failed = 0;
#line 279
  if (! chain) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if (! chain->parts) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if ((chain->parts)->len <= chain->active_part) {
#line 280
    return ((bus_t *)((void *)0));
  } else
#line 279
  if (chain->active_part < 0) {
#line 280
    return ((bus_t *)((void *)0));
  }
  {
#line 282
  tmp = malloc(sizeof(bus_t ));
#line 282
  bus___0 = (bus_t *)tmp;
  }
#line 283
  if (! bus___0) {
#line 284
    return ((bus_t *)((void *)0));
  }
  {
#line 286
  bus___0->driver = & tx4925_bus;
#line 287
  bus___0->params = malloc(sizeof(bus_params_t___0 ));
  }
#line 288
  if (! bus___0->params) {
    {
#line 289
    free((void *)bus___0);
    }
#line 290
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  ((bus_params_t___0 *)bus___0->params)->chain = chain;
#line 294
  ((bus_params_t___0 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 296
  ((bus_params_t___0 *)bus___0->params)->oe = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                               "OE");
  }
#line 297
  if (! ((bus_params_t___0 *)bus___0->params)->oe) {
    {
#line 298
    tmp___0 = gettext("signal \'%s\' not found\n");
#line 298
    printf((char const   */* __restrict  */)tmp___0, "OE");
#line 299
    failed = 1;
    }
  }
  {
#line 302
  ((bus_params_t___0 *)bus___0->params)->swe = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                "SWE");
  }
#line 303
  if (! ((bus_params_t___0 *)bus___0->params)->swe) {
    {
#line 304
    tmp___1 = gettext("signal \'%s\' not found\n");
#line 304
    printf((char const   */* __restrict  */)tmp___1, "SWE");
#line 305
    failed = 1;
    }
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 4)) {
#line 308
      goto while_break;
    }
    {
#line 309
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ROMCE_%d",
            i);
#line 310
    ((bus_params_t___0 *)bus___0->params)->romce[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 311
    if (! ((bus_params_t___0 *)bus___0->params)->romce[i]) {
      {
#line 312
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 312
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 313
      failed = 1;
      }
#line 314
      goto while_break;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! (i < 4)) {
#line 318
      goto while_break___0;
    }
    {
#line 319
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDCS_%d",
            i);
#line 320
    ((bus_params_t___0 *)bus___0->params)->sdcs[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 321
    if (! ((bus_params_t___0 *)bus___0->params)->sdcs[i]) {
      {
#line 322
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 322
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 323
      failed = 1;
      }
#line 324
      goto while_break___0;
    }
#line 318
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if (! (i < 20)) {
#line 328
      goto while_break___1;
    }
    {
#line 329
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR_%d",
            i);
#line 330
    ((bus_params_t___0 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 331
    if (! ((bus_params_t___0 *)bus___0->params)->addr[i]) {
      {
#line 332
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 332
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 333
      failed = 1;
      }
#line 334
      goto while_break___1;
    }
#line 328
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 338
  i = 0;
  {
#line 338
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 338
    if (! (i < 16)) {
#line 338
      goto while_break___2;
    }
    {
#line 339
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA_%d",
            i);
#line 340
    ((bus_params_t___0 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___0 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 341
    if (! ((bus_params_t___0 *)bus___0->params)->data[i]) {
      {
#line 342
      tmp___5 = gettext("signal \'%s\' not found\n");
#line 342
      printf((char const   */* __restrict  */)tmp___5, buff);
#line 343
      failed = 1;
      }
#line 344
      goto while_break___2;
    }
#line 338
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 348
  if (failed) {
    {
#line 349
    free(bus___0->params);
#line 350
    free((void *)bus___0);
    }
#line 351
    return ((bus_t *)((void *)0));
  }
#line 354
  return (bus___0);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  slsup3_bus ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
int databusio[16]  = 
#line 41 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
  {      94,      96,      98,      100, 
        102,      104,      106,      113, 
        95,      97,      99,      101, 
        103,      105,      107,      114};
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
int addrbusio[20]  = 
#line 42
  {      93,      88,      87,      86, 
        85,      84,      83,      63, 
        64,      65,      66,      67, 
        68,      74,      75,      76, 
        77,      82,      81,      78};
#line 90
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 92 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void setup_address___1(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 96
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 99
  slsup3_bus_area(bus___0, a, & area);
  }
#line 100
  if (area.width > 16U) {
#line 101
    return;
  }
  {
#line 103
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrs, 1, (int )(a & 1U));
  }
#line 106
  if (a >= 0U) {
#line 106
    if ((unsigned long )a < 2097152UL) {
#line 107
      i = 0;
      {
#line 107
      while (1) {
        while_continue: /* CIL Label */ ;
#line 107
        if (! (i < 20)) {
#line 107
          goto while_break;
        }
        {
#line 108
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (i + 1)) & 1U));
#line 107
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 109
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 0);
#line 110
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[15], 1, (int )(a & 1U));
      }
    } else {
      {
#line 112
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
      }
    }
  } else {
    {
#line 112
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
    }
  }
#line 115
  if (a >= 2097152U) {
#line 115
    if (a < 2228224U) {
      {
#line 116
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 0);
#line 117
      i = 0;
      }
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! (i < 20)) {
#line 117
          goto while_break___0;
        }
        {
#line 118
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (((unsigned int )i + area.width / 8U) - 1U)) & 1U));
#line 117
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 120
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
      }
    }
  } else {
    {
#line 120
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void set_data_in___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 129
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 132
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 133
  if (area.width > 16U) {
#line 134
    return;
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned int )i < area.width)) {
#line 136
      goto while_break;
    }
    {
#line 137
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 0, 0);
#line 136
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void setup_data___1(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 144
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 147
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 148
  if (area.width > 16U) {
#line 149
    return;
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned int )i < area.width)) {
#line 151
      goto while_break;
    }
    {
#line 152
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 1, (int )((d >> i) & 1U));
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 155 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static uint32_t get_data(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 160
  d = (uint32_t )0;
#line 161
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 163
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 164
  if (area.width > 16U) {
#line 165
    return ((uint32_t )0);
  }
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((unsigned int )i < area.width)) {
#line 167
      goto while_break;
    }
    {
#line 168
    tmp = part_get_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i]);
#line 168
    d |= (uint32_t )(tmp << i);
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (d);
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void slsup3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < ((((bus_params_t___1 *)bus___0->params)->chain)->parts)->len)) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )((bus_params_t___1 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___1 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 180
      goto while_break;
    }
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  tmp = gettext("SLS UP3 bus driver via BSR (JTAG part No. %d)\n");
#line 181
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 182
  return;
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void slsup3_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 187
  part_set_instruction(((bus_params_t___1 *)bus___0->params)->part, "EXTEST");
#line 188
  chain_shift_instructions(((bus_params_t___1 *)bus___0->params)->chain);
  }
#line 189
  return;
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void slsup3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 194
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 196
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
#line 198
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 0);
#line 200
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 205
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 206
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 1);
#line 208
  setup_address___1(bus___0, adr);
  }
#line 210
  if (adr >= 3145728U) {
#line 210
    if (adr < 4194304U) {
      {
#line 211
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 212
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 213
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 216
  set_data_in___1(bus___0, adr);
#line 218
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
  }
#line 220
  return;
}
}
#line 222 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  part_t *p ;

  {
  {
#line 227
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 229
  setup_address___1(bus___0, adr);
  }
#line 231
  if (adr >= 3145728U) {
#line 231
    if (adr < 4194304U) {
      {
#line 232
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 233
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 234
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 237
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 1);
#line 239
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
#line 241
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
  }
#line 243
  return (d);
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t d ;

  {
#line 249
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 252
  if (((bus_params_t___1 *)bus___0->params)->last_adr >= 3145728U) {
#line 252
    if (((bus_params_t___1 *)bus___0->params)->last_adr < 4194304U) {
      {
#line 253
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 254
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 255
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 258
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 260
  chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 1);
#line 262
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
  }
#line 264
  return (d);
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static uint32_t slsup3_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 272
  slsup3_bus_read_start(bus___0, adr);
#line 273
  d = slsup3_bus_read_end(bus___0);
  }
#line 274
  return (d);
}
}
#line 277 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void slsup3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 280
  p = ((bus_params_t___1 *)bus___0->params)->part;
#line 281
  chain___0 = ((bus_params_t___1 *)bus___0->params)->chain;
#line 283
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 284
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 287
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 288
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 290
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 291
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 0);
#line 293
  setup_address___1(bus___0, adr);
#line 294
  setup_data___1(bus___0, adr, data);
  }
#line 296
  if (adr >= 3145728U) {
#line 296
    if (adr < 4194304U) {
      {
#line 297
      chain_shift_data_registers(chain___0, 0);
#line 298
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 299
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
#line 300
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 301
      chain_shift_data_registers(((bus_params_t___1 *)bus___0->params)->chain, 0);
      }
    } else {
      {
#line 304
      chain_shift_data_registers(chain___0, 0);
#line 306
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 307
      chain_shift_data_registers(chain___0, 0);
#line 308
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 309
      chain_shift_data_registers(chain___0, 0);
      }
    }
  } else {
    {
#line 304
    chain_shift_data_registers(chain___0, 0);
#line 306
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 307
    chain_shift_data_registers(chain___0, 0);
#line 308
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 309
    chain_shift_data_registers(chain___0, 0);
    }
  }
#line 311
  return;
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 316
  if (adr >= 0U) {
#line 316
    if ((unsigned long )adr < 2097152UL) {
#line 317
      area->description = "Flash Memory (2 MByte) byte mode";
#line 318
      area->start = 0U;
#line 319
      area->length = 2097152UL;
#line 320
      area->width = 8U;
#line 322
      return (0);
    }
  }
#line 325
  if (adr >= 2097152U) {
#line 325
    if (adr < 2228224U) {
#line 326
      area->description = "SRAM 128KByte (64K x 16)";
#line 327
      area->start = (uint32_t )2097152;
#line 328
      area->length = (uint64_t )131072;
#line 329
      area->width = 16U;
#line 331
      return (0);
    }
  }
#line 334
  if (adr >= 3145728U) {
#line 334
    if (adr < 4194304U) {
#line 335
      area->description = "LCD Display (RS select by A0)";
#line 336
      area->start = (uint32_t )3145728;
#line 337
      area->length = (uint64_t )1048576;
#line 338
      area->width = 8U;
#line 340
      return (0);
    }
  }
#line 343
  area->description = (char const   *)((void *)0);
#line 344
  area->start = 4194304U;
#line 345
  area->length = 4290772992UL;
#line 346
  area->width = 0U;
#line 348
  return (0);
}
}
#line 351 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static void slsup3_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 354
  free(bus___0->params);
#line 355
  free((void *)bus___0);
  }
#line 356
  return;
}
}
#line 358 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
static bus_t *slsup3_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 364
  failed = 0;
#line 367
  if (! chain) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if (! chain->parts) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if ((chain->parts)->len <= chain->active_part) {
#line 368
    return ((bus_t *)((void *)0));
  } else
#line 367
  if (chain->active_part < 0) {
#line 368
    return ((bus_t *)((void *)0));
  }
  {
#line 370
  tmp = malloc(sizeof(bus_t ));
#line 370
  bus___0 = (bus_t *)tmp;
  }
#line 371
  if (! bus___0) {
#line 372
    return ((bus_t *)((void *)0));
  }
  {
#line 374
  bus___0->driver = & slsup3_bus;
#line 375
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___1 ));
  }
#line 376
  if (! bus___0->params) {
    {
#line 377
    free((void *)bus___0);
    }
#line 378
    return ((bus_t *)((void *)0));
  }
#line 381
  ((bus_params_t___1 *)bus___0->params)->chain = chain;
#line 382
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 382
  ((bus_params_t___1 *)bus___0->params)->part = part___0;
#line 384
  i = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (i < 20)) {
#line 384
      goto while_break;
    }
    {
#line 385
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            addrbusio[i]);
#line 386
    ((bus_params_t___1 *)bus___0->params)->ad[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 387
    if (! ((bus_params_t___1 *)bus___0->params)->ad[i]) {
      {
#line 388
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 388
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 389
      failed = 1;
      }
#line 390
      goto while_break;
    }
#line 384
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (i < 16)) {
#line 394
      goto while_break___0;
    }
    {
#line 395
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            databusio[i]);
#line 396
    ((bus_params_t___1 *)bus___0->params)->dq[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 397
    if (! ((bus_params_t___1 *)bus___0->params)->dq[i]) {
      {
#line 398
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 398
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 399
      failed = 1;
      }
#line 400
      goto while_break___0;
    }
#line 394
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 404
  ((bus_params_t___1 *)bus___0->params)->noe = part_find_signal(part___0, "IO118");
  }
#line 405
  if (! ((bus_params_t___1 *)bus___0->params)->noe) {
    {
#line 406
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 406
    printf((char const   */* __restrict  */)tmp___2, "nOE");
#line 407
    failed = 1;
    }
  }
  {
#line 410
  ((bus_params_t___1 *)bus___0->params)->nsrce = part_find_signal(part___0, "IO116");
  }
#line 411
  if (! ((bus_params_t___1 *)bus___0->params)->nsrce) {
    {
#line 412
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 412
    printf((char const   */* __restrict  */)tmp___3, "nSRce");
#line 413
    failed = 1;
    }
  }
  {
#line 416
  ((bus_params_t___1 *)bus___0->params)->nsdce = part_find_signal(part___0, "IO119");
  }
#line 417
  if (! ((bus_params_t___1 *)bus___0->params)->nsdce) {
    {
#line 418
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 418
    printf((char const   */* __restrict  */)tmp___4, "nSDce");
#line 419
    failed = 1;
    }
  }
  {
#line 422
  ((bus_params_t___1 *)bus___0->params)->nflce = part_find_signal(part___0, "IO117");
  }
#line 423
  if (! ((bus_params_t___1 *)bus___0->params)->nflce) {
    {
#line 424
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 424
    printf((char const   */* __restrict  */)tmp___5, "nFLce");
#line 425
    failed = 1;
    }
  }
  {
#line 428
  ((bus_params_t___1 *)bus___0->params)->nflbyte = part_find_signal(part___0, "IO115");
  }
#line 429
  if (! ((bus_params_t___1 *)bus___0->params)->nflbyte) {
    {
#line 430
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 430
    printf((char const   */* __restrict  */)tmp___6, "nFLbyte");
#line 431
    failed = 1;
    }
  }
  {
#line 434
  ((bus_params_t___1 *)bus___0->params)->nflby = part_find_signal(part___0, "IO80");
  }
#line 435
  if (! ((bus_params_t___1 *)bus___0->params)->nflby) {
    {
#line 436
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 436
    printf((char const   */* __restrict  */)tmp___7, "nFLby");
#line 437
    failed = 1;
    }
  }
  {
#line 440
  ((bus_params_t___1 *)bus___0->params)->nwe = part_find_signal(part___0, "IO79");
  }
#line 441
  if (! ((bus_params_t___1 *)bus___0->params)->nwe) {
    {
#line 442
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 442
    printf((char const   */* __restrict  */)tmp___8, "nWE");
#line 443
    failed = 1;
    }
  }
  {
#line 446
  ((bus_params_t___1 *)bus___0->params)->sdclk = part_find_signal(part___0, "IO11");
  }
#line 447
  if (! ((bus_params_t___1 *)bus___0->params)->sdclk) {
    {
#line 448
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 448
    printf((char const   */* __restrict  */)tmp___9, "SDclk");
#line 449
    failed = 1;
    }
  }
  {
#line 452
  ((bus_params_t___1 *)bus___0->params)->lcde = part_find_signal(part___0, "IO50");
  }
#line 453
  if (! ((bus_params_t___1 *)bus___0->params)->lcde) {
    {
#line 454
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 454
    printf((char const   */* __restrict  */)tmp___10, "LCDe");
#line 455
    failed = 1;
    }
  }
  {
#line 458
  ((bus_params_t___1 *)bus___0->params)->lcdrs = part_find_signal(part___0, "IO108");
  }
#line 459
  if (! ((bus_params_t___1 *)bus___0->params)->lcdrs) {
    {
#line 460
    tmp___11 = gettext("signal \'%s\' not found\n");
#line 460
    printf((char const   */* __restrict  */)tmp___11, "LCDrs");
#line 461
    failed = 1;
    }
  }
  {
#line 464
  ((bus_params_t___1 *)bus___0->params)->lcdrw = part_find_signal(part___0, "IO73");
  }
#line 465
  if (! ((bus_params_t___1 *)bus___0->params)->lcdrw) {
    {
#line 466
    tmp___12 = gettext("signal \'%s\' not found\n");
#line 466
    printf((char const   */* __restrict  */)tmp___12, "LCDrw");
#line 467
    failed = 1;
    }
  }
#line 470
  if (failed) {
    {
#line 471
    free(bus___0->params);
#line 472
    free((void *)bus___0);
    }
#line 473
    return ((bus_t *)((void *)0));
  }
#line 476
  return (bus___0);
}
}
#line 479 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/slsup3.c"
struct bus_driver  const  slsup3_bus  = 
#line 479
     {"slsup3", "SLS UP3 compatible bus driver via BSR", & slsup3_bus_new, & slsup3_bus_free,
    & slsup3_bus_printinfo, & slsup3_bus_prepare, & slsup3_bus_area, & slsup3_bus_read_start,
    & slsup3_bus_read_next, & slsup3_bus_read_end, & slsup3_bus_read, & slsup3_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 50 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  sharc_21065L_bus ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void setup_address___2(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 72
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < 19)) {
#line 74
      goto while_break;
    }
    {
#line 75
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 74
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 78
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 81 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void set_data_in___2(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 84
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 87
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 0, 0);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void setup_data___2(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 97
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 100
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 102
  i = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned int )i < area.width)) {
#line 102
      goto while_break;
    }
    {
#line 103
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 102
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void sharc_21065L_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < ((((bus_params_t___2 *)bus___0->params)->chain)->parts)->len)) {
#line 111
      goto while_break;
    }
#line 112
    if ((unsigned long )((bus_params_t___2 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___2 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 113
      goto while_break;
    }
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp = gettext("Analog Device\'s SHARC 21065L compatible bus driver via BSR (JTAG part No. %d)\n");
#line 114
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void sharc_21065L_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 119
  part_set_instruction(((bus_params_t___2 *)bus___0->params)->part, "EXTEST");
#line 120
  chain_shift_instructions(((bus_params_t___2 *)bus___0->params)->chain);
  }
#line 121
  return;
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void sharc_21065L_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;

  {
#line 126
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 127
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 129
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 130
  if (adr >= 524288U) {
#line 131
    return;
  }
  {
#line 134
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 135
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 136
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 0);
#line 138
  setup_address___2(bus___0, adr);
#line 139
  set_data_in___2(bus___0, adr);
#line 141
  chain_shift_data_registers(chain___0, 0);
  }
#line 142
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t d ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 147
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 148
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 152
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 154
  if (adr < 524288U) {
    {
#line 158
    sharc_21065L_bus_area(bus___0, adr, & area);
#line 161
    setup_address___2(bus___0, adr);
#line 162
    chain_shift_data_registers(chain___0, 1);
#line 164
    d = (uint32_t )0;
#line 165
    i = 0;
    }
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 165
      if (! ((unsigned int )i < area.width)) {
#line 165
        goto while_break;
      }
      {
#line 166
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 166
      d |= (uint32_t )(tmp << i);
#line 165
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 168
    return (d);
  }
#line 170
  return ((uint32_t )0);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 176
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 177
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 179
  if (((bus_params_t___2 *)bus___0->params)->last_adr < 524288U) {
    {
#line 181
    d = (uint32_t )0;
#line 184
    sharc_21065L_bus_area(bus___0, ((bus_params_t___2 *)bus___0->params)->last_adr,
                          & area);
#line 187
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 1);
#line 188
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 189
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 191
    chain_shift_data_registers(chain___0, 1);
#line 193
    i = 0;
    }
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 193
      if (! ((unsigned int )i < area.width)) {
#line 193
        goto while_break;
      }
      {
#line 194
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 194
      d |= (uint32_t )(tmp << i);
#line 193
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 196
    return (d);
  }
#line 199
  return ((uint32_t )0);
}
}
#line 202 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 204
  sharc_21065L_bus_read_start(bus___0, adr);
#line 205
  tmp = sharc_21065L_bus_read_end(bus___0);
  }
#line 205
  return (tmp);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void sharc_21065L_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
#line 212
  p = ((bus_params_t___2 *)bus___0->params)->part;
#line 213
  chain___0 = ((bus_params_t___2 *)bus___0->params)->chain;
#line 215
  if (adr >= 524288U) {
#line 216
    return;
  }
  {
#line 219
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 220
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 223
  setup_address___2(bus___0, adr);
#line 224
  setup_data___2(bus___0, adr, data);
#line 226
  chain_shift_data_registers(chain___0, 0);
#line 228
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 0);
#line 229
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 231
  chain_shift_data_registers(chain___0, 0);
  }
#line 232
  return;
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 238
  if (adr < 524288U) {
#line 239
    area->description = "Boot Memory Select";
#line 240
    area->start = 0U;
#line 241
    area->length = 524288UL;
#line 242
    area->width = 8U;
#line 244
    return (0);
  }
#line 247
  area->description = (char const   *)((void *)0);
#line 248
  area->start = 4294967295U;
#line 249
  area->length = 524288UL;
#line 250
  area->width = 0U;
#line 251
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static void sharc_21065L_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 257
  free(bus___0->params);
#line 258
  free((void *)bus___0);
  }
#line 259
  return;
}
}
#line 261
static bus_t *sharc_21065L_bus_new(void) ;
#line 263 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
struct bus_driver  const  sharc_21065L_bus  = 
#line 263
     {"SHARC_21065L", "SHARC_21065L compatible bus driver via BSR", & sharc_21065L_bus_new,
    & sharc_21065L_bus_free, & sharc_21065L_bus_printinfo, & sharc_21065L_bus_prepare,
    & sharc_21065L_bus_area, & sharc_21065L_bus_read_start, & sharc_21065L_bus_read_next,
    & sharc_21065L_bus_read_end, & sharc_21065L_bus_read, & sharc_21065L_bus_write,
    (int (*)(bus_t *bus ))0};
#line 279 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sharc21065l.c"
static bus_t *sharc_21065L_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 284
  failed = 0;
#line 286
  if (! chain) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (! chain->parts) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if ((chain->parts)->len <= chain->active_part) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (chain->active_part < 0) {
#line 287
    return ((bus_t *)((void *)0));
  }
  {
#line 289
  tmp = malloc(sizeof(bus_t ));
#line 289
  bus___0 = (bus_t *)tmp;
  }
#line 290
  if (! bus___0) {
#line 291
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  bus___0->driver = & sharc_21065L_bus;
#line 294
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___2 ));
  }
#line 295
  if (! bus___0->params) {
    {
#line 296
    free((void *)bus___0);
    }
#line 297
    return ((bus_t *)((void *)0));
  }
#line 300
  ((bus_params_t___2 *)bus___0->params)->chain = chain;
#line 301
  ((bus_params_t___2 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 19)) {
#line 303
      goto while_break;
    }
    {
#line 304
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 305
    ((bus_params_t___2 *)bus___0->params)->ma[i] = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 306
    if (! ((bus_params_t___2 *)bus___0->params)->ma[i]) {
      {
#line 307
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 307
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 308
      failed = 1;
      }
#line 309
      goto while_break;
    }
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < 8)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 314
    ((bus_params_t___2 *)bus___0->params)->md[i] = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 315
    if (! ((bus_params_t___2 *)bus___0->params)->md[i]) {
      {
#line 316
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 316
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 317
      failed = 1;
      }
#line 318
      goto while_break___0;
    }
#line 312
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 322
  ((bus_params_t___2 *)bus___0->params)->bms = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "BMS_B");
  }
#line 323
  if (! ((bus_params_t___2 *)bus___0->params)->bms) {
    {
#line 324
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 324
    printf((char const   */* __restrict  */)tmp___2, "BMS_B");
#line 325
    failed = 1;
    }
  }
  {
#line 327
  ((bus_params_t___2 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "WR_B");
  }
#line 328
  if (! ((bus_params_t___2 *)bus___0->params)->nwe) {
    {
#line 329
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 329
    printf((char const   */* __restrict  */)tmp___3, "WR_B");
#line 330
    failed = 1;
    }
  }
  {
#line 332
  ((bus_params_t___2 *)bus___0->params)->noe = part_find_signal(((bus_params_t___2 *)bus___0->params)->part,
                                                                "RD_B");
  }
#line 333
  if (! ((bus_params_t___2 *)bus___0->params)->noe) {
    {
#line 334
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___4, "RD_B");
#line 335
    failed = 1;
    }
  }
#line 339
  if (failed) {
    {
#line 340
    free(bus___0->params);
#line 341
    free((void *)bus___0);
    }
#line 342
    return ((bus_t *)((void *)0));
  }
#line 345
  return (bus___0);
}
}
#line 45 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  sh7751r_bus ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void setup_address___3(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 65
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < 26)) {
#line 67
      goto while_break;
    }
    {
#line 68
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 67
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void set_data_in___3(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 75
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 32)) {
#line 77
      goto while_break;
    }
    {
#line 78
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 0, 0);
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void setup_data___3(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 85
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 32)) {
#line 87
      goto while_break;
    }
    {
#line 88
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void sh7751r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < ((((bus_params_t___3 *)bus___0->params)->chain)->parts)->len)) {
#line 96
      goto while_break;
    }
#line 97
    if ((unsigned long )((bus_params_t___3 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___3 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 98
      goto while_break;
    }
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  tmp = gettext("Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 99
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 100
  return;
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void sh7751r_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 106
  part_set_instruction(((bus_params_t___3 *)bus___0->params)->part, "EXTEST");
#line 107
  chain_shift_instructions(((bus_params_t___3 *)bus___0->params)->chain);
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void sh7751r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 113
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 8)) {
#line 117
      goto while_break;
    }
#line 118
    cs[i] = 1;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  cs[(adr & 469762048U) >> 26] = 0;
#line 121
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 122
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 123
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 124
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 125
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 126
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 127
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 128
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 1);
#line 129
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 130
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 131
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 0);
#line 135
  setup_address___3(bus___0, adr);
#line 136
  set_data_in___3(bus___0);
#line 137
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 0);
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 143
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 145
  d = (uint32_t )0;
#line 147
  setup_address___3(bus___0, adr);
#line 148
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 1);
#line 150
  i = 0;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < 32)) {
#line 150
      goto while_break;
    }
    {
#line 151
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 151
    d |= (uint32_t )(tmp << i);
#line 150
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (d);
}
}
#line 156 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 159
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 162
  d = (uint32_t )0;
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < 8)) {
#line 164
      goto while_break;
    }
#line 165
    cs[i] = 1;
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 168
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 169
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 170
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 171
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 172
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 173
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 175
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 176
  chain_shift_data_registers(((bus_params_t___3 *)bus___0->params)->chain, 1);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < 32)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 179
    d |= (uint32_t )(tmp << i);
#line 178
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  return (d);
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 187
  sh7751r_bus_read_start(bus___0, adr);
#line 188
  tmp = sh7751r_bus_read_end(bus___0);
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void sh7751r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 194
  chain___0 = ((bus_params_t___3 *)bus___0->params)->chain;
#line 195
  p = ((bus_params_t___3 *)bus___0->params)->part;
#line 199
  i = 0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < 8)) {
#line 199
      goto while_break;
    }
#line 200
    cs[i] = 1;
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  cs[(adr & 469762048U) >> 26] = 0;
#line 203
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 204
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 205
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 206
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 207
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 208
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 209
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 211
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 0);
#line 212
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 213
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 216
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 218
  setup_address___3(bus___0, adr);
#line 219
  setup_data___3(bus___0, data);
#line 220
  chain_shift_data_registers(chain___0, 0);
#line 222
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 0);
#line 223
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 0);
#line 224
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 0);
#line 225
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 0);
#line 227
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 231
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static int sh7751r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static void sh7751r_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *sh7751r_bus_new(void) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
struct bus_driver  const  sh7751r_bus  = 
#line 257
     {"sh7751r", "Hitachi SH7751R compatible bus driver via BSR", & sh7751r_bus_new,
    & sh7751r_bus_free, & sh7751r_bus_printinfo, & sh7751r_bus_prepare, & sh7751r_bus_area,
    & sh7751r_bus_read_start, & sh7751r_bus_read_next, & sh7751r_bus_read_end, & sh7751r_bus_read,
    & sh7751r_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 273 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7751r.c"
static bus_t *sh7751r_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 279
  failed = 0;
#line 281
  if (! chain) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if (! chain->parts) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if ((chain->parts)->len <= chain->active_part) {
#line 282
    return ((bus_t *)((void *)0));
  } else
#line 281
  if (chain->active_part < 0) {
#line 282
    return ((bus_t *)((void *)0));
  }
  {
#line 284
  tmp = malloc(sizeof(bus_t ));
#line 284
  bus___0 = (bus_t *)tmp;
  }
#line 285
  if (! bus___0) {
#line 286
    return ((bus_t *)((void *)0));
  }
  {
#line 288
  bus___0->driver = & sh7751r_bus;
#line 289
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___3 ));
  }
#line 290
  if (! bus___0->params) {
    {
#line 291
    free((void *)bus___0);
    }
#line 292
    return ((bus_t *)((void *)0));
  }
#line 295
  ((bus_params_t___3 *)bus___0->params)->chain = chain;
#line 296
  ((bus_params_t___3 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 298
  i = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < 26)) {
#line 298
      goto while_break;
    }
    {
#line 299
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 300
    ((bus_params_t___3 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 301
    if (! ((bus_params_t___3 *)bus___0->params)->a[i]) {
      {
#line 302
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 302
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 303
      failed = 1;
      }
#line 304
      goto while_break;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 32)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 309
    ((bus_params_t___3 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___3 *)bus___0->params)->d[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 316
    if (! (i < 7)) {
#line 316
      goto while_break___1;
    }
    {
#line 317
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 318
    ((bus_params_t___3 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 319
    if (! ((bus_params_t___3 *)bus___0->params)->cs[i]) {
      {
#line 320
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 320
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 321
      failed = 1;
      }
#line 322
      goto while_break___1;
    }
#line 316
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 325
    if (! (i < 4)) {
#line 325
      goto while_break___2;
    }
    {
#line 326
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 327
    ((bus_params_t___3 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 328
    if (! ((bus_params_t___3 *)bus___0->params)->we[i]) {
      {
#line 329
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 329
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 330
      failed = 1;
      }
#line 331
      goto while_break___2;
    }
#line 325
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 334
  ((bus_params_t___3 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                                 "RD_WR");
  }
#line 335
  if (! ((bus_params_t___3 *)bus___0->params)->rdwr) {
    {
#line 336
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 336
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 337
    failed = 1;
    }
  }
  {
#line 339
  ((bus_params_t___3 *)bus___0->params)->rd = part_find_signal(((bus_params_t___3 *)bus___0->params)->part,
                                                               "RD_CASS_FRAME");
  }
#line 340
  if (! ((bus_params_t___3 *)bus___0->params)->rd) {
    {
#line 341
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 341
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 342
    failed = 1;
    }
  }
#line 345
  if (failed) {
    {
#line 346
    free(bus___0->params);
#line 347
    free((void *)bus___0);
    }
#line 348
    return ((bus_t *)((void *)0));
  }
#line 351
  return (bus___0);
}
}
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  sh7750r_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void setup_address___4(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 67
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < 26)) {
#line 69
      goto while_break;
    }
    {
#line 70
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 69
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void set_data_in___4(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 32)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 0, 0);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void setup_data___4(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 87
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 32)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void sh7750r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < ((((bus_params_t___4 *)bus___0->params)->chain)->parts)->len)) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )((bus_params_t___4 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___4 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 100
      goto while_break;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = gettext("Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 101
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void sh7750r_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 107
  part_set_instruction(((bus_params_t___4 *)bus___0->params)->part, "EXTEST");
#line 108
  chain_shift_instructions(((bus_params_t___4 *)bus___0->params)->chain);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void sh7750r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 114
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 8)) {
#line 118
      goto while_break;
    }
#line 119
    cs[i] = 1;
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  cs[(adr & 469762048U) >> 26] = 0;
#line 122
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 123
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 124
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 125
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 126
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 127
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 128
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 129
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 1);
#line 130
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 1);
#line 131
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 134
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 135
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 0);
#line 136
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 0);
#line 138
  setup_address___4(bus___0, adr);
#line 139
  set_data_in___4(bus___0);
#line 140
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 0);
  }
#line 141
  return;
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 146
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 148
  d = (uint32_t )0;
#line 150
  setup_address___4(bus___0, adr);
#line 151
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 1);
#line 153
  i = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < 32)) {
#line 153
      goto while_break;
    }
    {
#line 154
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 154
    d |= (uint32_t )(tmp << i);
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return (d);
}
}
#line 159 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 162
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 165
  d = (uint32_t )0;
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < 8)) {
#line 167
      goto while_break;
    }
#line 168
    cs[i] = 1;
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 171
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 172
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 173
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 174
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 175
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 176
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 178
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 180
  chain_shift_data_registers(((bus_params_t___4 *)bus___0->params)->chain, 1);
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (i < 32)) {
#line 182
      goto while_break___0;
    }
    {
#line 183
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 183
    d |= (uint32_t )(tmp << i);
#line 182
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  return (d);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  sh7750r_bus_read_start(bus___0, adr);
#line 192
  tmp = sh7750r_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void sh7750r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 198
  chain___0 = ((bus_params_t___4 *)bus___0->params)->chain;
#line 199
  p = ((bus_params_t___4 *)bus___0->params)->part;
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 8)) {
#line 203
      goto while_break;
    }
#line 204
    cs[i] = 1;
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  cs[(adr & 469762048U) >> 26] = 0;
#line 207
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 208
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 209
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 210
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 211
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 212
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 213
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 215
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 0);
#line 216
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 0);
#line 217
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 218
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 219
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 220
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 224
  setup_address___4(bus___0, adr);
#line 225
  setup_data___4(bus___0, data);
#line 227
  chain_shift_data_registers(chain___0, 0);
#line 229
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 0);
#line 230
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 0);
#line 231
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 0);
#line 232
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 0);
#line 234
  chain_shift_data_registers(chain___0, 0);
#line 236
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 237
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 238
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 239
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 241
  chain_shift_data_registers(chain___0, 0);
  }
#line 242
  return;
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static int sh7750r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 247
  area->description = (char const   *)((void *)0);
#line 248
  area->start = 0U;
#line 249
  area->length = 4294967296UL;
#line 250
  area->width = 32U;
#line 252
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static void sh7750r_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 258
  free(bus___0->params);
#line 259
  free((void *)bus___0);
  }
#line 260
  return;
}
}
#line 262
static bus_t *sh7750r_bus_new(void) ;
#line 264 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
struct bus_driver  const  sh7750r_bus  = 
#line 264
     {"sh7750r", "Hitachi SH7750R compatible bus driver via BSR", & sh7750r_bus_new,
    & sh7750r_bus_free, & sh7750r_bus_printinfo, & sh7750r_bus_prepare, & sh7750r_bus_area,
    & sh7750r_bus_read_start, & sh7750r_bus_read_next, & sh7750r_bus_read_end, & sh7750r_bus_read,
    & sh7750r_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 280 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7750r.c"
static bus_t *sh7750r_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 286
  failed = 0;
#line 288
  if (! chain) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (! chain->parts) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if ((chain->parts)->len <= chain->active_part) {
#line 289
    return ((bus_t *)((void *)0));
  } else
#line 288
  if (chain->active_part < 0) {
#line 289
    return ((bus_t *)((void *)0));
  }
  {
#line 291
  tmp = malloc(sizeof(bus_t ));
#line 291
  bus___0 = (bus_t *)tmp;
  }
#line 292
  if (! bus___0) {
#line 293
    return ((bus_t *)((void *)0));
  }
  {
#line 295
  bus___0->driver = & sh7750r_bus;
#line 296
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___4 ));
  }
#line 297
  if (! bus___0->params) {
    {
#line 298
    free((void *)bus___0);
    }
#line 299
    return ((bus_t *)((void *)0));
  }
#line 302
  ((bus_params_t___4 *)bus___0->params)->chain = chain;
#line 303
  ((bus_params_t___4 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 305
  i = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < 26)) {
#line 305
      goto while_break;
    }
    {
#line 306
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 307
    ((bus_params_t___4 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 308
    if (! ((bus_params_t___4 *)bus___0->params)->a[i]) {
      {
#line 309
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 309
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 310
      failed = 1;
      }
#line 311
      goto while_break;
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if (! (i < 32)) {
#line 314
      goto while_break___0;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 316
    ((bus_params_t___4 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___4 *)bus___0->params)->d[i]) {
      {
#line 318
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 318
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 319
      failed = 1;
      }
#line 320
      goto while_break___0;
    }
#line 314
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < 7)) {
#line 323
      goto while_break___1;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 325
    ((bus_params_t___4 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___4 *)bus___0->params)->cs[i]) {
      {
#line 327
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break___1;
    }
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 332
    if (! (i < 8)) {
#line 332
      goto while_break___2;
    }
    {
#line 333
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 334
    ((bus_params_t___4 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 335
    if (! ((bus_params_t___4 *)bus___0->params)->we[i]) {
      {
#line 336
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 336
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 337
      failed = 1;
      }
#line 338
      goto while_break___2;
    }
#line 332
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 341
  ((bus_params_t___4 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                 "RDWR");
  }
#line 342
  if (! ((bus_params_t___4 *)bus___0->params)->rdwr) {
    {
#line 343
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 343
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 344
    failed = 1;
    }
  }
  {
#line 346
  ((bus_params_t___4 *)bus___0->params)->rd = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                               "RD");
  }
#line 347
  if (! ((bus_params_t___4 *)bus___0->params)->rd) {
    {
#line 348
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 348
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 349
    failed = 1;
    }
  }
  {
#line 351
  ((bus_params_t___4 *)bus___0->params)->rdwr2 = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                  "RDWR2");
  }
#line 352
  if (! ((bus_params_t___4 *)bus___0->params)->rdwr2) {
    {
#line 353
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 353
    printf((char const   */* __restrict  */)tmp___6, "RDWR2");
#line 354
    failed = 1;
    }
  }
  {
#line 356
  ((bus_params_t___4 *)bus___0->params)->rd2 = part_find_signal(((bus_params_t___4 *)bus___0->params)->part,
                                                                "RD2");
  }
#line 357
  if (! ((bus_params_t___4 *)bus___0->params)->rd2) {
    {
#line 358
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 358
    printf((char const   */* __restrict  */)tmp___7, "RD2");
#line 359
    failed = 1;
    }
  }
#line 362
  if (failed) {
    {
#line 363
    free(bus___0->params);
#line 364
    free((void *)bus___0);
    }
#line 365
    return ((bus_t *)((void *)0));
  }
#line 368
  return (bus___0);
}
}
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  sh7727_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 65 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void setup_address___5(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 69
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < 26)) {
#line 71
      goto while_break;
    }
    {
#line 72
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 71
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void set_data_in___5(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 79
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 82
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((unsigned int )i < area.width)) {
#line 84
      goto while_break;
    }
    {
#line 85
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 0, 0);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void setup_data___5(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 92
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 95
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 97
  i = 0;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned int )i < area.width)) {
#line 97
      goto while_break;
    }
    {
#line 98
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 97
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void sh7727_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < ((((bus_params_t___5 *)bus___0->params)->chain)->parts)->len)) {
#line 106
      goto while_break;
    }
#line 107
    if ((unsigned long )((bus_params_t___5 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___5 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 108
      goto while_break;
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  tmp = gettext("Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 109
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void sh7727_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 115
  part_set_instruction(((bus_params_t___5 *)bus___0->params)->part, "EXTEST");
#line 116
  chain_shift_instructions(((bus_params_t___5 *)bus___0->params)->chain);
  }
#line 117
  return;
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void sh7727_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 122
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < 8)) {
#line 126
      goto while_break;
    }
#line 127
    cs[i] = 1;
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  cs[(adr & 469762048U) >> 26] = 0;
#line 130
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 131
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 132
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 133
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 134
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 135
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 136
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 1);
#line 137
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 138
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 139
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 140
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 141
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 0);
#line 143
  setup_address___5(bus___0, adr);
#line 144
  set_data_in___5(bus___0);
#line 146
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 0);
  }
#line 147
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 152
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 154
  d = (uint32_t )0;
#line 157
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 159
  setup_address___5(bus___0, adr);
#line 160
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 171
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 173
  d = (uint32_t )0;
#line 176
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 178
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 186
  chain_shift_data_registers(((bus_params_t___5 *)bus___0->params)->chain, 1);
#line 188
  i = 0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((unsigned int )i < area.width)) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 189
    d |= (uint32_t )(tmp << i);
#line 188
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (d);
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static uint32_t sh7727_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 197
  sh7727_bus_read_start(bus___0, adr);
#line 198
  tmp = sh7727_bus_read_end(bus___0);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void sh7727_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 204
  chain___0 = ((bus_params_t___5 *)bus___0->params)->chain;
#line 205
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < 8)) {
#line 209
      goto while_break;
    }
#line 210
    cs[i] = 1;
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  cs[(adr & 469762048U) >> 26] = 0;
#line 213
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 214
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 215
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 216
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 217
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 218
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 220
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 0);
#line 221
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 223
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 224
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 225
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 227
  setup_address___5(bus___0, adr);
#line 228
  setup_data___5(bus___0, data);
#line 230
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 0);
#line 233
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 0);
#line 234
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 0);
#line 235
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 0);
#line 237
  chain_shift_data_registers(chain___0, 0);
#line 239
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 240
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 241
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 242
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 244
  chain_shift_data_registers(chain___0, 0);
  }
#line 245
  return;
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 250
  p = ((bus_params_t___5 *)bus___0->params)->part;
#line 252
  area->description = (char const   *)((void *)0);
#line 253
  area->start = 0U;
#line 254
  area->length = 4294967296UL;
#line 256
  tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md4);
#line 256
  tmp___0 = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md3);
  }
  {
#line 257
  if (((tmp << 1) | tmp___0) == 1) {
#line 257
    goto case_1;
  }
#line 260
  if (((tmp << 1) | tmp___0) == 2) {
#line 260
    goto case_2;
  }
#line 263
  if (((tmp << 1) | tmp___0) == 3) {
#line 263
    goto case_3;
  }
#line 266
  goto switch_default;
  case_1: /* CIL Label */ 
#line 258
  area->width = 8U;
#line 259
  return (0);
  case_2: /* CIL Label */ 
#line 261
  area->width = 16U;
#line 262
  return (0);
  case_3: /* CIL Label */ 
#line 264
  area->width = 32U;
#line 265
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 267
  tmp___1 = gettext("Error: Invalid bus width (MD3 = MD4 = 0)!\n");
#line 267
  printf((char const   */* __restrict  */)tmp___1);
#line 268
  area->width = 0U;
  }
#line 269
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static void sh7727_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 276
  free(bus___0->params);
#line 277
  free((void *)bus___0);
  }
#line 278
  return;
}
}
#line 280
static bus_t *sh7727_bus_new(void) ;
#line 282 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
struct bus_driver  const  sh7727_bus  = 
#line 282
     {"sh7727", "Hitachi SH7727 compatible bus driver via BSR", & sh7727_bus_new, & sh7727_bus_free,
    & sh7727_bus_printinfo, & sh7727_bus_prepare, & sh7727_bus_area, & sh7727_bus_read_start,
    & sh7727_bus_read_next, & sh7727_bus_read_end, & sh7727_bus_read, & sh7727_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 298 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sh7727.c"
static bus_t *sh7727_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 304
  failed = 0;
#line 306
  if (! chain) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if (! chain->parts) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if ((chain->parts)->len <= chain->active_part) {
#line 307
    return ((bus_t *)((void *)0));
  } else
#line 306
  if (chain->active_part < 0) {
#line 307
    return ((bus_t *)((void *)0));
  }
  {
#line 309
  tmp = malloc(sizeof(bus_t ));
#line 309
  bus___0 = (bus_t *)tmp;
  }
#line 310
  if (! bus___0) {
#line 311
    return ((bus_t *)((void *)0));
  }
  {
#line 313
  bus___0->driver = & sh7727_bus;
#line 314
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___5 ));
  }
#line 315
  if (! bus___0->params) {
    {
#line 316
    free((void *)bus___0);
    }
#line 317
    return ((bus_t *)((void *)0));
  }
#line 320
  ((bus_params_t___5 *)bus___0->params)->chain = chain;
#line 321
  ((bus_params_t___5 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < 26)) {
#line 323
      goto while_break;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 325
    ((bus_params_t___5 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___5 *)bus___0->params)->a[i]) {
      {
#line 327
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break;
    }
#line 323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (i < 32)) {
#line 332
      goto while_break___0;
    }
    {
#line 333
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 334
    ((bus_params_t___5 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 335
    if (! ((bus_params_t___5 *)bus___0->params)->d[i]) {
      {
#line 336
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 336
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 337
      failed = 1;
      }
#line 338
      goto while_break___0;
    }
#line 332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 341
    if (! (i < 7)) {
#line 341
      goto while_break___1;
    }
#line 342
    if (i == 1) {
#line 343
      goto __Cont;
    }
    {
#line 344
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 345
    ((bus_params_t___5 *)bus___0->params)->cs[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 346
    if (! ((bus_params_t___5 *)bus___0->params)->cs[i]) {
      {
#line 347
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 347
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 348
      failed = 1;
      }
#line 349
      goto while_break___1;
    }
    __Cont: /* CIL Label */ 
#line 341
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 352
    if (! (i < 4)) {
#line 352
      goto while_break___2;
    }
    {
#line 353
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 354
    ((bus_params_t___5 *)bus___0->params)->we[i] = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 355
    if (! ((bus_params_t___5 *)bus___0->params)->we[i]) {
      {
#line 356
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 356
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 357
      failed = 1;
      }
#line 358
      goto while_break___2;
    }
#line 352
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 361
  ((bus_params_t___5 *)bus___0->params)->rdwr = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                 "RDWR");
  }
#line 362
  if (! ((bus_params_t___5 *)bus___0->params)->rdwr) {
    {
#line 363
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 363
    printf((char const   */* __restrict  */)tmp___4, "RDWR");
#line 364
    failed = 1;
    }
  }
  {
#line 366
  ((bus_params_t___5 *)bus___0->params)->rd = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                               "RD");
  }
#line 367
  if (! ((bus_params_t___5 *)bus___0->params)->rd) {
    {
#line 368
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 368
    printf((char const   */* __restrict  */)tmp___5, "RD");
#line 369
    failed = 1;
    }
  }
  {
#line 371
  ((bus_params_t___5 *)bus___0->params)->md3 = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                "MD3");
  }
#line 372
  if (! ((bus_params_t___5 *)bus___0->params)->md3) {
    {
#line 373
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 373
    printf((char const   */* __restrict  */)tmp___6, "MD3");
#line 374
    failed = 1;
    }
  }
  {
#line 376
  ((bus_params_t___5 *)bus___0->params)->md4 = part_find_signal(((bus_params_t___5 *)bus___0->params)->part,
                                                                "MD4");
  }
#line 377
  if (! ((bus_params_t___5 *)bus___0->params)->md4) {
    {
#line 378
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 378
    printf((char const   */* __restrict  */)tmp___7, "MD4");
#line 379
    failed = 1;
    }
  }
#line 382
  if (failed) {
    {
#line 383
    free(bus___0->params);
#line 384
    free((void *)bus___0);
    }
#line 385
    return ((bus_t *)((void *)0));
  }
#line 388
  return (bus___0);
}
}
#line 42 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  sa1110_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void setup_address___6(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 26)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void set_data_in___6(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 81
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned int )i < area.width)) {
#line 83
      goto while_break;
    }
    {
#line 84
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 0, 0);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void setup_data___6(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 91
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 94
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 96
  i = 0;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ((unsigned int )i < area.width)) {
#line 96
      goto while_break;
    }
    {
#line 97
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 96
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void sa1110_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < ((((bus_params_t___6 *)bus___0->params)->chain)->parts)->len)) {
#line 105
      goto while_break;
    }
#line 106
    if ((unsigned long )((bus_params_t___6 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___6 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 107
      goto while_break;
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp = gettext("Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 108
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void sa1110_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 114
  part_set_instruction(((bus_params_t___6 *)bus___0->params)->part, "EXTEST");
#line 115
  chain_shift_instructions(((bus_params_t___6 *)bus___0->params)->chain);
  }
#line 116
  return;
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void sa1110_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 122
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 123
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 125
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 126
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 127
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 128
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 129
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 130
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 131
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 1);
#line 132
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 133
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 0);
#line 135
  setup_address___6(bus___0, adr);
#line 136
  set_data_in___6(bus___0);
#line 138
  chain_shift_data_registers(chain___0, 0);
  }
#line 139
  return;
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 145
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 146
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 148
  d = (uint32_t )0;
#line 151
  sa1110_bus_area(bus___0, adr, & area);
#line 153
  setup_address___6(bus___0, adr);
#line 154
  chain_shift_data_registers(chain___0, 1);
#line 156
  i = 0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! ((unsigned int )i < area.width)) {
#line 156
      goto while_break;
    }
    {
#line 157
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 157
    d |= (uint32_t )(tmp << i);
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (d);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 166
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 167
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 169
  d = (uint32_t )0;
#line 172
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 174
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 181
  chain_shift_data_registers(chain___0, 1);
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((unsigned int )i < area.width)) {
#line 183
      goto while_break;
    }
    {
#line 184
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 184
    d |= (uint32_t )(tmp << i);
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (d);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static uint32_t sa1110_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 192
  sa1110_bus_read_start(bus___0, adr);
#line 193
  tmp = sa1110_bus_read_end(bus___0);
  }
#line 193
  return (tmp);
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void sa1110_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 200
  p = ((bus_params_t___6 *)bus___0->params)->part;
#line 201
  chain___0 = ((bus_params_t___6 *)bus___0->params)->chain;
#line 203
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 204
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 205
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 206
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 207
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 208
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 209
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 0);
#line 210
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 211
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 213
  setup_address___6(bus___0, adr);
#line 214
  setup_data___6(bus___0, data);
#line 216
  chain_shift_data_registers(chain___0, 0);
#line 218
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 0);
#line 219
  chain_shift_data_registers(chain___0, 0);
#line 220
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 221
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 222
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 223
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 224
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 225
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 226
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 227
  chain_shift_data_registers(chain___0, 0);
  }
#line 228
  return;
}
}
#line 230 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 233
  area->description = (char const   *)((void *)0);
#line 234
  area->start = 0U;
#line 235
  area->length = 4294967296UL;
#line 236
  tmp___1 = part_find_signal(((bus_params_t___6 *)bus___0->params)->part, "ROM_SEL");
#line 236
  tmp___2 = part_get_signal(((bus_params_t___6 *)bus___0->params)->part, tmp___1);
  }
#line 236
  if (tmp___2) {
#line 236
    area->width = 32U;
  } else {
#line 236
    area->width = 16U;
  }
#line 238
  return (0);
}
}
#line 241 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static void sa1110_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 244
  free(bus___0->params);
#line 245
  free((void *)bus___0);
  }
#line 246
  return;
}
}
#line 248
static bus_t *sa1110_bus_new(void) ;
#line 250 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
struct bus_driver  const  sa1110_bus  = 
#line 250
     {"sa1110", "Intel SA-1110 compatible bus driver via BSR", & sa1110_bus_new, & sa1110_bus_free,
    & sa1110_bus_printinfo, & sa1110_bus_prepare, & sa1110_bus_area, & sa1110_bus_read_start,
    & sa1110_bus_read_next, & sa1110_bus_read_end, & sa1110_bus_read, & sa1110_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 266 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/sa1110.c"
static bus_t *sa1110_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 272
  failed = 0;
#line 274
  if (! chain) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if (! chain->parts) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if ((chain->parts)->len <= chain->active_part) {
#line 275
    return ((bus_t *)((void *)0));
  } else
#line 274
  if (chain->active_part < 0) {
#line 275
    return ((bus_t *)((void *)0));
  }
  {
#line 277
  tmp = malloc(sizeof(bus_t ));
#line 277
  bus___0 = (bus_t *)tmp;
  }
#line 278
  if (! bus___0) {
#line 279
    return ((bus_t *)((void *)0));
  }
  {
#line 281
  bus___0->driver = & sa1110_bus;
#line 282
  bus___0->params = malloc(sizeof(bus_params_t___6 ));
  }
#line 283
  if (! bus___0->params) {
    {
#line 284
    free((void *)bus___0);
    }
#line 285
    return ((bus_t *)((void *)0));
  }
#line 288
  ((bus_params_t___6 *)bus___0->params)->chain = chain;
#line 289
  ((bus_params_t___6 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 291
  i = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (i < 26)) {
#line 291
      goto while_break;
    }
    {
#line 292
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 293
    ((bus_params_t___6 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 294
    if (! ((bus_params_t___6 *)bus___0->params)->a[i]) {
      {
#line 295
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 295
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 296
      failed = 1;
      }
#line 297
      goto while_break;
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (! (i < 32)) {
#line 300
      goto while_break___0;
    }
    {
#line 301
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 302
    ((bus_params_t___6 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 303
    if (! ((bus_params_t___6 *)bus___0->params)->d[i]) {
      {
#line 304
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 304
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 305
      failed = 1;
      }
#line 306
      goto while_break___0;
    }
#line 300
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 309
    if (! (i < 6)) {
#line 309
      goto while_break___1;
    }
    {
#line 310
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 311
    ((bus_params_t___6 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 312
    if (! ((bus_params_t___6 *)bus___0->params)->ncs[i]) {
      {
#line 313
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 313
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 314
      failed = 1;
      }
#line 315
      goto while_break___1;
    }
#line 309
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 318
  ((bus_params_t___6 *)bus___0->params)->rd_nwr = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                   "RD_nWR");
  }
#line 319
  if (! ((bus_params_t___6 *)bus___0->params)->rd_nwr) {
    {
#line 320
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 320
    printf((char const   */* __restrict  */)tmp___3, "RD_nWR");
#line 321
    failed = 1;
    }
  }
  {
#line 323
  ((bus_params_t___6 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                "nWE");
  }
#line 324
  if (! ((bus_params_t___6 *)bus___0->params)->nwe) {
    {
#line 325
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 325
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 326
    failed = 1;
    }
  }
  {
#line 328
  ((bus_params_t___6 *)bus___0->params)->noe = part_find_signal(((bus_params_t___6 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 329
  if (! ((bus_params_t___6 *)bus___0->params)->noe) {
    {
#line 330
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 330
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 331
    failed = 1;
    }
  }
#line 334
  if (failed) {
    {
#line 335
    free(bus___0->params);
#line 336
    free((void *)bus___0);
    }
#line 337
    return ((bus_t *)((void *)0));
  }
#line 340
  return (bus___0);
}
}
#line 41 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  s3c4510_bus ;
#line 102 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void setup_address___7(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 106
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < 22)) {
#line 108
      goto while_break;
    }
    {
#line 109
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void set_data_in___7(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 116
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 118
      goto while_break;
    }
    {
#line 119
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 0, 0);
#line 118
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void setup_data___7(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 126
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 128
      goto while_break;
    }
    {
#line 129
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 128
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  i = ((bus_params_t___7 *)bus___0->params)->dbuswidth;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (! (i < 32)) {
#line 131
      goto while_break___0;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, 0);
#line 131
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < ((((bus_params_t___7 *)bus___0->params)->chain)->parts)->len)) {
#line 140
      goto while_break;
    }
#line 141
    if ((unsigned long )((bus_params_t___7 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___7 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 142
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp = gettext("Samsung S3C4510B compatibile bus driver via BSR (JTAG part No. %d) RCS0=%ubit\n");
#line 143
  printf((char const   */* __restrict  */)tmp, i, ((bus_params_t___7 *)bus___0->params)->dbuswidth);
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 149
  part_set_instruction(((bus_params_t___7 *)bus___0->params)->part, "EXTEST");
#line 150
  chain_shift_instructions(((bus_params_t___7 *)bus___0->params)->chain);
  }
#line 151
  return;
}
}
#line 153 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_setup_ctrl(bus_t *bus___0 , int mode ) 
{ 
  int k ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 156
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 158
  k = 0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (k < 6)) {
#line 158
      goto while_break;
    }
#line 159
    if (mode & (1 << k)) {
#line 159
      tmp = 1;
    } else {
#line 159
      tmp = 0;
    }
    {
#line 159
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nrcs[k], 1, tmp);
#line 158
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  k = 0;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (k < 4)) {
#line 161
      goto while_break___0;
    }
    {
#line 162
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->necs[k], 1, 1);
#line 161
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 164
  k = 0;
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    if (! (k < 4)) {
#line 164
      goto while_break___1;
    }
    {
#line 165
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nsdcs[k], 1, 1);
#line 164
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 167
  k = 0;
  {
#line 167
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 167
    if (! (k < 4)) {
#line 167
      goto while_break___2;
    }
#line 168
    if (mode & (1 << (k + 8))) {
#line 168
      tmp___0 = 1;
    } else {
#line 168
      tmp___0 = 0;
    }
    {
#line 168
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nwbe[k], 1, tmp___0);
#line 167
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 170
  if (mode & (1 << 16)) {
#line 170
    tmp___1 = 1;
  } else {
#line 170
    tmp___1 = 0;
  }
  {
#line 170
  part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->noe, 1, tmp___1);
  }
#line 171
  return;
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;

  {
  {
#line 177
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 179
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 180
  setup_address___7(bus___0, adr);
#line 181
  set_data_in___7(bus___0);
#line 182
  chain_shift_data_registers(chain___0, 0);
  }
#line 183
  return;
}
}
#line 185 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 189
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 190
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 192
  d = (uint32_t )0;
#line 194
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 195
  setup_address___7(bus___0, adr);
#line 196
  set_data_in___7(bus___0);
#line 197
  chain_shift_data_registers(chain___0, 1);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 199
      goto while_break;
    }
    {
#line 200
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 200
    d |= (uint32_t )(tmp << i);
#line 199
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (d);
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 209
  p = ((bus_params_t___7 *)bus___0->params)->part;
#line 210
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 212
  d = (uint32_t )0;
#line 214
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 215
  chain_shift_data_registers(chain___0, 1);
#line 217
  i = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 218
    d |= (uint32_t )(tmp << i);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (d);
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 226
  s3c4510_bus_read_start(bus___0, adr);
#line 227
  tmp = s3c4510_bus_read_end(bus___0);
  }
#line 227
  return (tmp);
}
}
#line 236 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain___0 ;

  {
  {
#line 240
  chain___0 = ((bus_params_t___7 *)bus___0->params)->chain;
#line 242
  s3c4510_bus_setup_ctrl(bus___0, 131070);
#line 243
  setup_address___7(bus___0, adr);
#line 244
  setup_data___7(bus___0, data);
#line 246
  chain_shift_data_registers(chain___0, 0);
  }
  {
#line 254
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 254
    goto case_16;
  }
#line 258
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 258
    goto case_32;
  }
#line 250
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 252
  s3c4510_bus_setup_ctrl(bus___0, 130814);
  }
#line 253
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 255
  s3c4510_bus_setup_ctrl(bus___0, 130302);
  }
#line 256
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 259
  s3c4510_bus_setup_ctrl(bus___0, 127230);
  }
#line 260
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 263
  setup_address___7(bus___0, adr);
#line 264
  setup_data___7(bus___0, data);
#line 266
  chain_shift_data_registers(chain___0, 0);
#line 268
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 269
  chain_shift_data_registers(chain___0, 0);
  }
#line 272
  return;
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static int s3c4510_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  int b0size0 ;
  int b0size1 ;
  signal_t *tmp ;
  signal_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 280
  area->description = (char const   *)((void *)0);
#line 281
  area->start = 0U;
#line 282
  area->length = 4294967296UL;
#line 284
  tmp = part_find_signal(((bus_params_t___7 *)bus___0->params)->part, "B0SIZE0");
#line 284
  b0size0 = part_get_signal(((bus_params_t___7 *)bus___0->params)->part, tmp);
#line 285
  tmp___0 = part_find_signal(((bus_params_t___7 *)bus___0->params)->part, "B0SIZE1");
#line 285
  b0size1 = part_get_signal(((bus_params_t___7 *)bus___0->params)->part, tmp___0);
  }
  {
#line 288
  if (((b0size1 << 1) | b0size0) == 1) {
#line 288
    goto case_1;
  }
#line 291
  if (((b0size1 << 1) | b0size0) == 2) {
#line 291
    goto case_2;
  }
#line 294
  if (((b0size1 << 1) | b0size0) == 3) {
#line 294
    goto case_3;
  }
#line 297
  goto switch_default;
  case_1: /* CIL Label */ 
#line 289
  tmp___1 = 8;
#line 289
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___1;
#line 289
  area->width = (unsigned int )tmp___1;
#line 290
  return (0);
  case_2: /* CIL Label */ 
#line 292
  tmp___2 = 16;
#line 292
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___2;
#line 292
  area->width = (unsigned int )tmp___2;
#line 293
  return (0);
  case_3: /* CIL Label */ 
#line 295
  tmp___3 = 32;
#line 295
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___3;
#line 295
  area->width = (unsigned int )tmp___3;
#line 296
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 298
  printf((char const   */* __restrict  */)"B0SIZE[1:0]: Unknown\n");
#line 299
  area->width = 0U;
  }
#line 300
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static void s3c4510_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 307
  free(bus___0->params);
#line 308
  free((void *)bus___0);
  }
#line 309
  return;
}
}
#line 311
static bus_t *s3c4510_bus_new(void) ;
#line 313 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
struct bus_driver  const  s3c4510_bus  = 
#line 313
     {"s3c4510x", "Samsung S3C4510B compatible bus driver via BSR", & s3c4510_bus_new,
    & s3c4510_bus_free, & s3c4510_bus_printinfo, & s3c4510_bus_prepare, & s3c4510_bus_area,
    & s3c4510_bus_read_start, & s3c4510_bus_read_next, & s3c4510_bus_read_end, & s3c4510_bus_read,
    & s3c4510_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 329 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/s3c4510x.c"
static bus_t *s3c4510_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 335
  failed = 0;
#line 337
  if (! chain) {
#line 338
    return ((bus_t *)((void *)0));
  } else
#line 337
  if (! chain->parts) {
#line 338
    return ((bus_t *)((void *)0));
  } else
#line 337
  if ((chain->parts)->len <= chain->active_part) {
#line 338
    return ((bus_t *)((void *)0));
  } else
#line 337
  if (chain->active_part < 0) {
#line 338
    return ((bus_t *)((void *)0));
  }
  {
#line 340
  tmp = malloc(sizeof(bus_t ));
#line 340
  bus___0 = (bus_t *)tmp;
  }
#line 341
  if (! bus___0) {
#line 342
    return ((bus_t *)((void *)0));
  }
  {
#line 344
  bus___0->driver = & s3c4510_bus;
#line 345
  bus___0->params = malloc(sizeof(bus_params_t___7 ));
  }
#line 346
  if (! bus___0->params) {
    {
#line 347
    free((void *)bus___0);
    }
#line 348
    return ((bus_t *)((void *)0));
  }
#line 352
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = 16;
#line 353
  ((bus_params_t___7 *)bus___0->params)->chain = chain;
#line 354
  ((bus_params_t___7 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 356
  i = 0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (i < 22)) {
#line 356
      goto while_break;
    }
    {
#line 357
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 358
    ((bus_params_t___7 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 359
    if (! ((bus_params_t___7 *)bus___0->params)->a[i]) {
      {
#line 360
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 360
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 361
      failed = 1;
      }
#line 362
      goto while_break;
    }
#line 356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  i = 0;
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (i < 32)) {
#line 365
      goto while_break___0;
    }
    {
#line 366
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"XDATA%d",
            i);
#line 367
    ((bus_params_t___7 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 368
    if (! ((bus_params_t___7 *)bus___0->params)->d[i]) {
      {
#line 369
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 369
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 370
      failed = 1;
      }
#line 371
      goto while_break___0;
    }
#line 365
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  i = 0;
  {
#line 374
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 374
    if (! (i < 6)) {
#line 374
      goto while_break___1;
    }
    {
#line 375
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 376
    ((bus_params_t___7 *)bus___0->params)->nrcs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 377
    if (! ((bus_params_t___7 *)bus___0->params)->nrcs[i]) {
      {
#line 378
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 378
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 379
      failed = 1;
      }
#line 380
      goto while_break___1;
    }
#line 374
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 384
  i = 0;
  {
#line 384
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 384
    if (! (i < 4)) {
#line 384
      goto while_break___2;
    }
    {
#line 385
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nECS%d",
            i);
#line 386
    ((bus_params_t___7 *)bus___0->params)->necs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 387
    if (! ((bus_params_t___7 *)bus___0->params)->necs[i]) {
      {
#line 388
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 388
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 389
      failed = 1;
      }
#line 390
      goto while_break___2;
    }
#line 384
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 393
  i = 0;
  {
#line 393
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 393
    if (! (i < 4)) {
#line 393
      goto while_break___3;
    }
    {
#line 394
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRAS%d",
            i);
#line 395
    ((bus_params_t___7 *)bus___0->params)->nsdcs[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 396
    if (! ((bus_params_t___7 *)bus___0->params)->nsdcs[i]) {
      {
#line 397
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 397
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 398
      failed = 1;
      }
#line 399
      goto while_break___3;
    }
#line 393
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 402
  i = 0;
  {
#line 402
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 402
    if (! (i < 4)) {
#line 402
      goto while_break___4;
    }
    {
#line 403
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nWBE%d",
            i);
#line 404
    ((bus_params_t___7 *)bus___0->params)->nwbe[i] = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 405
    if (! ((bus_params_t___7 *)bus___0->params)->nwbe[i]) {
      {
#line 406
      tmp___5 = gettext("signal \'%s\' not found\n");
#line 406
      printf((char const   */* __restrict  */)tmp___5, buff);
#line 407
      failed = 1;
      }
#line 408
      goto while_break___4;
    }
#line 402
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 411
  ((bus_params_t___7 *)bus___0->params)->noe = part_find_signal(((bus_params_t___7 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 412
  if (! ((bus_params_t___7 *)bus___0->params)->noe) {
    {
#line 413
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 413
    printf((char const   */* __restrict  */)tmp___6, "nOE");
#line 414
    failed = 1;
    }
  }
#line 417
  if (failed) {
    {
#line 418
    free(bus___0->params);
#line 419
    free((void *)bus___0);
    }
#line 420
    return ((bus_t *)((void *)0));
  }
#line 423
  return (bus___0);
}
}
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  pxa2x0_bus ;
#line 40
struct bus_driver  const  pxa27x_bus ;
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static ncs_map_entry pxa25x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static ncs_map_entry pxa27x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[15]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[78]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[79]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[80]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[33]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 139 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void setup_address___8(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 143
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < 26)) {
#line 145
      goto while_break;
    }
    {
#line 146
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 145
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void set_data_in___8(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 153
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 156
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 158
  i = 0;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned int )i < area.width)) {
#line 158
      goto while_break;
    }
    {
#line 159
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 0, 0);
#line 158
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void setup_data___8(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 166
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 169
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 171
  i = 0;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned int )i < area.width)) {
#line 171
      goto while_break;
    }
    {
#line 172
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 171
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa2x0_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < ((((bus_params_t___8 *)bus___0->params)->chain)->parts)->len)) {
#line 180
      goto while_break;
    }
#line 181
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___8 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 182
      goto while_break;
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  tmp = gettext("Intel PXA2x0 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 183
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 184
  return;
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa27x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((((bus_params_t___8 *)bus___0->params)->chain)->parts)->len)) {
#line 191
      goto while_break;
    }
#line 192
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___8 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 193
      goto while_break;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  tmp = gettext("Intel PXA27x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 194
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 195
  return;
}
}
#line 197 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static int pxa2xx_bus_init(bus_t *bus___0 ) 
{ 
  chain_t *chain___0 ;
  part_t *p ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  signal_t *tmp___3 ;
  int tmp___4 ;
  signal_t *tmp___5 ;
  int tmp___6 ;

  {
#line 200
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 201
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 203
  if (((bus_params_t___8 *)bus___0->params)->inited == 1) {
#line 204
    return (0);
  }
  {
#line 206
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 207
  chain_shift_instructions(chain___0);
#line 208
  chain_shift_data_registers(chain___0, 1);
  }
#line 210
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
    {
#line 212
    tmp = part_find_signal(p, "BOOT_SEL[2]");
#line 212
    tmp___0 = part_get_signal(p, tmp);
#line 212
    tmp___1 = part_find_signal(p, "BOOT_SEL[1]");
#line 212
    tmp___2 = part_get_signal(p, tmp___1);
#line 212
    tmp___3 = part_find_signal(p, "BOOT_SEL[0]");
#line 212
    tmp___4 = part_get_signal(p, tmp___3);
#line 212
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | ((((tmp___0 << 2) | (tmp___2 << 1)) | tmp___4) & ((2 << 2) - 1)));
    }
  } else
#line 217
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
    {
#line 219
    tmp___5 = part_find_signal(p, "BOOT_SEL");
#line 219
    tmp___6 = part_get_signal(p, tmp___5);
#line 219
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | (tmp___6 & ((2 << 2) - 1)));
    }
  } else {
    {
#line 223
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
           "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c", 223);
    }
  }
  {
#line 225
  part_set_instruction(p, "BYPASS");
#line 226
  chain_shift_instructions(chain___0);
#line 228
  ((bus_params_t___8 *)bus___0->params)->inited = 1;
  }
#line 230
  return (0);
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa2xx_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 236
  pxa2xx_bus_init(bus___0);
#line 238
  part_set_instruction(((bus_params_t___8 *)bus___0->params)->part, "EXTEST");
#line 239
  chain_shift_instructions(((bus_params_t___8 *)bus___0->params)->chain);
  }
#line 240
  return;
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa2xx_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  int cs_index ;
  chain_t *chain___0 ;
  part_t *p ;

  {
#line 245
  cs_index = 0;
#line 247
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 248
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 250
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 251
  if (adr >= 402653184U) {
#line 252
    return;
  }
#line 254
  cs_index = (int )(adr >> 26);
#line 255
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 256
    return;
  }
  {
#line 259
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 260
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 261
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 262
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 263
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 264
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 1);
#line 265
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 266
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 0);
#line 267
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 269
  setup_address___8(bus___0, adr);
#line 270
  set_data_in___8(bus___0, adr);
#line 272
  chain_shift_data_registers(chain___0, 0);
  }
#line 273
  return;
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t d ;
  uint32_t old_last_adr ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 278
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 279
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 281
  old_last_adr = ((bus_params_t___8 *)bus___0->params)->last_adr;
#line 283
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 285
  if (adr < 402653184U) {
#line 289
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[adr >> 26] == (unsigned long )((void *)0)) {
#line 290
      return ((uint32_t )0);
    }
    {
#line 292
    (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 295
    setup_address___8(bus___0, adr);
#line 296
    chain_shift_data_registers(chain___0, 1);
#line 298
    d = (uint32_t )0;
#line 299
    i = 0;
    }
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! ((unsigned int )i < area.width)) {
#line 299
        goto while_break;
      }
      {
#line 300
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 300
      d |= (uint32_t )(tmp << i);
#line 299
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 302
    return (d);
  }
#line 306
  if (adr < 1207959552U) {
#line 307
    return ((uint32_t )0);
  }
#line 309
  if (adr < 1275068416U) {
#line 310
    if (old_last_adr == 1207959620U) {
#line 311
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 313
    return ((uint32_t )0);
  }
#line 316
  return ((uint32_t )0);
}
}
#line 319 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 322
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 323
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 325
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 402653184U) {
#line 327
    d = (uint32_t )0;
#line 330
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[((bus_params_t___8 *)bus___0->params)->last_adr >> 26] == (unsigned long )((void *)0)) {
#line 331
      return ((uint32_t )0);
    }
    {
#line 333
    (*((bus___0->driver)->area))(bus___0, ((bus_params_t___8 *)bus___0->params)->last_adr,
                                 & area);
#line 336
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[0], 1, 1);
#line 337
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 338
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 1);
#line 340
    chain_shift_data_registers(chain___0, 1);
#line 342
    i = 0;
    }
    {
#line 342
    while (1) {
      while_continue: /* CIL Label */ ;
#line 342
      if (! ((unsigned int )i < area.width)) {
#line 342
        goto while_break;
      }
      {
#line 343
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 343
      d |= (uint32_t )(tmp << i);
#line 342
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 345
    return (d);
  }
#line 349
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1207959552U) {
#line 350
    return ((uint32_t )0);
  }
#line 352
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1275068416U) {
#line 353
    if (((bus_params_t___8 *)bus___0->params)->last_adr == 1207959620U) {
#line 354
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 356
    return ((uint32_t )0);
  }
#line 359
  return ((uint32_t )0);
}
}
#line 362 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 365
  pxa2xx_bus_read_start(bus___0, adr);
#line 366
  tmp = pxa2xx_bus_read_end(bus___0);
  }
#line 366
  return (tmp);
}
}
#line 369 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa2xx_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  int cs_index ;
  part_t *p ;
  chain_t *chain___0 ;

  {
#line 372
  cs_index = 0;
#line 375
  p = ((bus_params_t___8 *)bus___0->params)->part;
#line 376
  chain___0 = ((bus_params_t___8 *)bus___0->params)->chain;
#line 378
  if (adr >= 402653184U) {
#line 379
    return;
  }
#line 381
  cs_index = (int )(adr >> 26);
#line 382
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 383
    return;
  }
  {
#line 385
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 386
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 387
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 388
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 389
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 390
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 0);
#line 391
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 392
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 393
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 395
  setup_address___8(bus___0, adr);
#line 396
  setup_data___8(bus___0, adr, data);
#line 398
  chain_shift_data_registers(chain___0, 0);
#line 400
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 0);
#line 401
  chain_shift_data_registers(chain___0, 0);
#line 402
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 403
  chain_shift_data_registers(chain___0, 0);
  }
#line 404
  return;
}
}
#line 406 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static int pxa2xx_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
  {
#line 411
  pxa2xx_bus_init(bus___0);
  }
#line 414
  if (adr < 67108864U) {
#line 415
    area->description = "Static Chip Select 0";
#line 416
    area->start = 0U;
#line 417
    area->length = 67108864UL;
#line 419
    if (pxa25x_ncs_map[0].bus_width > 0) {
#line 421
      area->width = (unsigned int )pxa25x_ncs_map[0].bus_width;
    } else {
      {
#line 427
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 427
        goto case_0;
      }
#line 430
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 430
        goto case_1;
      }
#line 434
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 434
        goto case_3;
      }
#line 434
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 434
        goto case_3;
      }
#line 440
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 440
        goto case_7;
      }
#line 440
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 440
        goto case_7;
      }
#line 440
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 440
        goto case_7;
      }
#line 440
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 440
        goto case_7;
      }
#line 443
      goto switch_default;
      case_0: /* CIL Label */ 
#line 428
      area->width = 32U;
#line 429
      goto switch_break;
      case_1: /* CIL Label */ 
#line 431
      area->width = 16U;
#line 432
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 435
      area->width = 0U;
#line 436
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 441
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 442
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 444
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c", 444);
      }
#line 445
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 448
    return (0);
  }
#line 452
  ncs_index = 1;
#line 452
  tmp_addr = (uint32_t )67108864;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (ncs_index <= 5)) {
#line 452
      goto while_break;
    }
#line 454
    if (adr >= tmp_addr) {
#line 454
      if (adr < tmp_addr + 67108864U) {
#line 455
        if (pxa25x_ncs_map[ncs_index].enabled) {
#line 455
          tmp = "";
        } else {
#line 455
          tmp = "(disabled)";
        }
        {
#line 455
        sprintf((char */* __restrict  */)(pxa25x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa25x_ncs_map[ncs_index].sig_name, tmp);
#line 458
        area->description = (char const   *)(pxa25x_ncs_map[ncs_index].label_buf);
#line 459
        area->start = tmp_addr;
#line 460
        area->length = 67108864UL;
#line 461
        area->width = (unsigned int )pxa25x_ncs_map[ncs_index].bus_width;
        }
#line 463
        return (0);
      }
    }
#line 452
    ncs_index ++;
#line 452
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  if (adr < 1207959552U) {
#line 468
    area->description = (char const   *)((void *)0);
#line 469
    area->start = 402653184U;
#line 470
    area->length = 805306368UL;
#line 471
    area->width = 0U;
#line 473
    return (0);
  }
#line 476
  if (adr < 1275068416U) {
#line 477
    area->description = "Memory Mapped registers (Memory Ctl)";
#line 478
    area->start = 1207959552U;
#line 479
    area->length = 67108864UL;
#line 480
    area->width = 32U;
#line 482
    return (0);
  }
#line 485
  area->description = (char const   *)((void *)0);
#line 486
  area->start = 1275068416U;
#line 487
  area->length = 3019898880UL;
#line 488
  area->width = 0U;
#line 490
  return (0);
}
}
#line 493 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static int pxa27x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
  {
#line 498
  pxa2xx_bus_init(bus___0);
  }
#line 501
  if (adr < 67108864U) {
#line 502
    area->description = "Static Chip Select 0";
#line 503
    area->start = 0U;
#line 504
    area->length = 67108864UL;
#line 506
    if (pxa27x_ncs_map[0].bus_width > 0) {
#line 508
      area->width = (unsigned int )pxa27x_ncs_map[0].bus_width;
    } else {
      {
#line 514
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 514
        goto case_0;
      }
#line 517
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 517
        goto case_1;
      }
#line 521
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 521
        goto case_3;
      }
#line 521
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 521
        goto case_3;
      }
#line 527
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 527
        goto case_7;
      }
#line 527
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 527
        goto case_7;
      }
#line 527
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 527
        goto case_7;
      }
#line 527
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 527
        goto case_7;
      }
#line 530
      goto switch_default;
      case_0: /* CIL Label */ 
#line 515
      area->width = 32U;
#line 516
      goto switch_break;
      case_1: /* CIL Label */ 
#line 518
      area->width = 16U;
#line 519
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 522
      area->width = 0U;
#line 523
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 528
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 529
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 531
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c", 531);
      }
#line 532
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 535
    return (0);
  }
#line 539
  ncs_index = 1;
#line 539
  tmp_addr = (uint32_t )67108864;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (ncs_index <= 5)) {
#line 539
      goto while_break;
    }
#line 542
    if (adr >= tmp_addr) {
#line 542
      if (adr < tmp_addr + 67108864U) {
#line 544
        if (pxa27x_ncs_map[ncs_index].enabled) {
#line 544
          tmp = "";
        } else {
#line 544
          tmp = "(disabled)";
        }
        {
#line 544
        sprintf((char */* __restrict  */)(pxa27x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa27x_ncs_map[ncs_index].sig_name, tmp);
#line 547
        area->description = (char const   *)(pxa27x_ncs_map[ncs_index].label_buf);
#line 548
        area->start = tmp_addr;
#line 549
        area->length = 67108864UL;
#line 550
        area->width = (unsigned int )pxa27x_ncs_map[ncs_index].bus_width;
        }
#line 552
        return (0);
      }
    }
#line 539
    ncs_index ++;
#line 539
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if (adr < 1073741824U) {
#line 558
    area->description = (char const   *)((void *)0);
#line 559
    area->start = 402653184U;
#line 560
    area->length = 671088640UL;
#line 561
    area->width = 0U;
#line 563
    return (0);
  }
#line 566
  if (adr < 1610612736U) {
#line 567
    area->description = "PXA270 internal address space (cfg, SRAM)";
#line 568
    area->start = 1073741824U;
#line 569
    area->length = 536870912UL;
#line 570
    area->width = 32U;
#line 572
    return (0);
  }
#line 575
  if (adr < 2684354560U) {
#line 576
    area->description = (char const   *)((void *)0);
#line 577
    area->start = 1610612736U;
#line 578
    area->length = 1073741824UL;
#line 579
    area->width = 0U;
#line 581
    return (0);
  }
#line 584
  if (adr < 2952790016U) {
#line 585
    area->description = "PXA270 SDRAM space (4x 64MB)";
#line 586
    area->start = 2684354560U;
#line 587
    area->length = 268435456UL;
#line 588
    area->width = 32U;
#line 590
    return (0);
  }
#line 593
  area->description = (char const   *)((void *)0);
#line 594
  area->start = 2952790016U;
#line 595
  area->length = 1342177280UL;
#line 596
  area->width = 0U;
#line 598
  return (0);
}
}
#line 601 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static void pxa2xx_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 605
  free(bus___0->params);
#line 606
  free((void *)bus___0);
  }
#line 607
  return;
}
}
#line 609
static bus_t *pxa2x0_bus_new(void) ;
#line 610
static bus_t *pxa27x_bus_new(void) ;
#line 612 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
struct bus_driver  const  pxa2x0_bus  = 
#line 612
     {"pxa2x0", "Intel PXA2x0 compatible bus driver via BSR", & pxa2x0_bus_new, & pxa2xx_bus_free,
    & pxa2x0_bus_printinfo, & pxa2xx_bus_prepare, & pxa2xx_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & pxa2xx_bus_read, & pxa2xx_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 628 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
struct bus_driver  const  pxa27x_bus  = 
#line 628
     {"pxa27x", "Intel PXA27x compatible bus driver via BSR", & pxa27x_bus_new, & pxa2xx_bus_free,
    & pxa27x_bus_printinfo, & pxa2xx_bus_prepare, & pxa27x_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & pxa2xx_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 646 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static int pxa2xx_bus_new_common(bus_t *bus___0 ) 
{ 
  int failed ;
  ncs_map_entry *ncs_map ;
  int i ;
  char buff[10] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 649
  failed = 0;
#line 650
  ncs_map = (ncs_map_entry *)((void *)0);
#line 676
  i = 0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < 26)) {
#line 676
      goto while_break;
    }
    {
#line 677
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MA[%d]",
            i);
#line 678
    ((bus_params_t___8 *)bus___0->params)->ma[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 679
    if (! ((bus_params_t___8 *)bus___0->params)->ma[i]) {
      {
#line 680
      tmp = gettext("signal \'%s\' not found\n");
#line 680
      printf((char const   */* __restrict  */)tmp, buff);
#line 681
      failed = 1;
      }
#line 682
      goto while_break;
    }
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  i = 0;
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (i < 32)) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MD[%d]",
            i);
#line 687
    ((bus_params_t___8 *)bus___0->params)->md[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 688
    if (! ((bus_params_t___8 *)bus___0->params)->md[i]) {
      {
#line 689
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 689
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 690
      failed = 1;
      }
#line 691
      goto while_break___0;
    }
#line 685
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 695
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
#line 696
    ncs_map = pxa25x_ncs_map;
  } else
#line 698
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
#line 699
    ncs_map = pxa27x_ncs_map;
  } else {
    {
#line 703
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d: unknown PROC\n",
           "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c", 703);
#line 704
    ncs_map = pxa25x_ncs_map;
    }
  }
#line 706
  i = 0;
  {
#line 706
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 706
    if (! (i < 6)) {
#line 706
      goto while_break___1;
    }
#line 707
    if ((ncs_map + i)->enabled > 0) {
      {
#line 709
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                       (char const   *)(ncs_map + i)->sig_name);
      }
#line 710
      if (! ((bus_params_t___8 *)bus___0->params)->ncs[i]) {
        {
#line 711
        tmp___1 = gettext("signal \'%s\' not found\n");
#line 711
        printf((char const   */* __restrict  */)tmp___1, buff);
#line 712
        failed = 1;
        }
#line 713
        goto while_break___1;
      }
    } else {
#line 718
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = (signal_t *)((void *)0);
    }
#line 706
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 722
  i = 0;
  {
#line 722
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 722
    if (! (i < 4)) {
#line 722
      goto while_break___2;
    }
    {
#line 723
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DQM[%d]",
            i);
#line 724
    ((bus_params_t___8 *)bus___0->params)->dqm[i] = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 725
    if (! ((bus_params_t___8 *)bus___0->params)->dqm[i]) {
      {
#line 726
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 726
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 727
      failed = 1;
      }
#line 728
      goto while_break___2;
    }
#line 722
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 731
  ((bus_params_t___8 *)bus___0->params)->rdnwr = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                  "RDnWR");
  }
#line 732
  if (! ((bus_params_t___8 *)bus___0->params)->rdnwr) {
    {
#line 733
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 733
    printf((char const   */* __restrict  */)tmp___3, "RDnWR");
#line 734
    failed = 1;
    }
  }
  {
#line 736
  ((bus_params_t___8 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                "nWE");
  }
#line 737
  if (! ((bus_params_t___8 *)bus___0->params)->nwe) {
    {
#line 738
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 738
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 739
    failed = 1;
    }
  }
  {
#line 741
  ((bus_params_t___8 *)bus___0->params)->noe = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                "nOE");
  }
#line 742
  if (! ((bus_params_t___8 *)bus___0->params)->noe) {
    {
#line 743
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 743
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 744
    failed = 1;
    }
  }
  {
#line 746
  ((bus_params_t___8 *)bus___0->params)->nsdcas = part_find_signal(((bus_params_t___8 *)bus___0->params)->part,
                                                                   "nSDCAS");
  }
#line 747
  if (! ((bus_params_t___8 *)bus___0->params)->nsdcas) {
    {
#line 748
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 748
    printf((char const   */* __restrict  */)tmp___6, "nSDCAS");
#line 749
    failed = 1;
    }
  }
#line 752
  return (failed);
}
}
#line 755 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static bus_t *pxa2x0_bus_new(void) 
{ 
  bus_t *bus___0 ;
  int failed ;
  void *tmp ;

  {
#line 759
  failed = 0;
#line 761
  if (! chain) {
#line 762
    return ((bus_t *)((void *)0));
  } else
#line 761
  if (! chain->parts) {
#line 762
    return ((bus_t *)((void *)0));
  } else
#line 761
  if ((chain->parts)->len <= chain->active_part) {
#line 762
    return ((bus_t *)((void *)0));
  } else
#line 761
  if (chain->active_part < 0) {
#line 762
    return ((bus_t *)((void *)0));
  }
  {
#line 764
  tmp = malloc(sizeof(bus_t ));
#line 764
  bus___0 = (bus_t *)tmp;
  }
#line 765
  if (! bus___0) {
#line 766
    return ((bus_t *)((void *)0));
  }
  {
#line 768
  bus___0->driver = & pxa2x0_bus;
#line 769
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___8 ));
  }
#line 770
  if (! bus___0->params) {
    {
#line 771
    free((void *)bus___0);
    }
#line 772
    return ((bus_t *)((void *)0));
  }
  {
#line 775
  ((bus_params_t___8 *)bus___0->params)->chain = chain;
#line 776
  ((bus_params_t___8 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 777
  ((bus_params_t___8 *)bus___0->params)->proc = 1;
#line 779
  failed = pxa2xx_bus_new_common(bus___0);
  }
#line 781
  if (failed) {
    {
#line 782
    free(bus___0->params);
#line 783
    free((void *)bus___0);
    }
#line 784
    return ((bus_t *)((void *)0));
  }
#line 787
  ((bus_params_t___8 *)bus___0->params)->inited = 0;
#line 789
  return (bus___0);
}
}
#line 792 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/pxa2x0.c"
static bus_t *pxa27x_bus_new(void) 
{ 
  bus_t *bus___0 ;
  int failed ;
  void *tmp ;

  {
#line 796
  failed = 0;
#line 798
  if (! chain) {
#line 799
    return ((bus_t *)((void *)0));
  } else
#line 798
  if (! chain->parts) {
#line 799
    return ((bus_t *)((void *)0));
  } else
#line 798
  if ((chain->parts)->len <= chain->active_part) {
#line 799
    return ((bus_t *)((void *)0));
  } else
#line 798
  if (chain->active_part < 0) {
#line 799
    return ((bus_t *)((void *)0));
  }
  {
#line 801
  tmp = malloc(sizeof(bus_t ));
#line 801
  bus___0 = (bus_t *)tmp;
  }
#line 802
  if (! bus___0) {
#line 803
    return ((bus_t *)((void *)0));
  }
  {
#line 805
  bus___0->driver = & pxa27x_bus;
#line 806
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___8 ));
  }
#line 807
  if (! bus___0->params) {
    {
#line 808
    free((void *)bus___0);
    }
#line 809
    return ((bus_t *)((void *)0));
  }
  {
#line 812
  ((bus_params_t___8 *)bus___0->params)->chain = chain;
#line 813
  ((bus_params_t___8 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 814
  ((bus_params_t___8 *)bus___0->params)->proc = 2;
#line 816
  failed = pxa2xx_bus_new_common(bus___0);
  }
#line 818
  if (failed) {
    {
#line 819
    free(bus___0->params);
#line 820
    free((void *)bus___0);
    }
#line 821
    return ((bus_t *)((void *)0));
  }
#line 824
  ((bus_params_t___8 *)bus___0->params)->inited = 0;
#line 826
  return (bus___0);
}
}
#line 37 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  ppc440gx_ebc8_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void setup_address___9(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 61
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 32)) {
#line 63
      goto while_break;
    }
    {
#line 64
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void set_data_in___9(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 73
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 76
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned int )i < area.width)) {
#line 78
      goto while_break;
    }
    {
#line 79
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[i], 0, 0);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void setup_data___9(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 86
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 89
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )i < area.width)) {
#line 91
      goto while_break;
    }
    {
#line 92
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[7 - i], 1, (int )((d >> i) & 1U));
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < ((((bus_params_t___9 *)bus___0->params)->chain)->parts)->len)) {
#line 100
      goto while_break;
    }
#line 101
    if ((unsigned long )((bus_params_t___9 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___9 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 102
      goto while_break;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  tmp = gettext("IBM PowerPC 440GX 8-bit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 103
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 109
  part_set_instruction(((bus_params_t___9 *)bus___0->params)->part, "EXTEST");
#line 110
  chain_shift_instructions(((bus_params_t___9 *)bus___0->params)->chain);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 116
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 117
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 119
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->ncs, 1, 0);
#line 120
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->nwe, 1, 1);
#line 121
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->noe, 1, 0);
#line 123
  setup_address___9(bus___0, adr);
#line 124
  set_data_in___9(bus___0);
#line 126
  chain_shift_data_registers(chain___0, 0);
  }
#line 127
  return;
}
}
#line 129 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 132
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 133
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 135
  d = (uint32_t )0;
#line 138
  ppc440gx_ebc8_bus_area(bus___0, adr, & area);
#line 140
  setup_address___9(bus___0, adr);
#line 141
  chain_shift_data_registers(chain___0, 1);
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned int )i < area.width)) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[7 - i]);
#line 144
    d |= (uint32_t )(tmp << i);
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (d);
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 152
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 153
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 155
  d = (uint32_t )0;
#line 158
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 160
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->ncs, 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->noe, 1, 1);
#line 162
  chain_shift_data_registers(chain___0, 1);
#line 164
  i = 0;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! ((unsigned int )i < area.width)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[7 - i]);
#line 165
    d |= (uint32_t )(tmp << i);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (d);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 173
  ppc440gx_ebc8_bus_read_start(bus___0, adr);
#line 174
  tmp = ppc440gx_ebc8_bus_read_end(bus___0);
  }
#line 174
  return (tmp);
}
}
#line 177 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 180
  p = ((bus_params_t___9 *)bus___0->params)->part;
#line 181
  chain___0 = ((bus_params_t___9 *)bus___0->params)->chain;
#line 183
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->ncs, 1, 0);
#line 184
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->nwe, 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->noe, 1, 1);
#line 187
  setup_address___9(bus___0, adr);
#line 188
  setup_data___9(bus___0, data);
#line 190
  chain_shift_data_registers(chain___0, 0);
#line 192
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->nwe, 1, 0);
#line 193
  chain_shift_data_registers(chain___0, 0);
#line 194
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->nwe, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->ncs, 1, 1);
#line 196
  chain_shift_data_registers(chain___0, 0);
  }
#line 197
  return;
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 202
  area->description = (char const   *)((void *)0);
#line 203
  area->start = 0U;
#line 204
  area->length = 4294967296UL;
#line 205
  area->width = 8U;
#line 207
  return (0);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 213
  free(bus___0->params);
#line 214
  free((void *)bus___0);
  }
#line 215
  return;
}
}
#line 217
static bus_t *ppc440gx_ebc8_bus_new(void) ;
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
struct bus_driver  const  ppc440gx_ebc8_bus  = 
#line 219
     {"ppc440gx_ebc8", "IBM PowerPC 440GX 8-bit EBC compatible bus driver via BSR",
    & ppc440gx_ebc8_bus_new, & ppc440gx_ebc8_bus_free, & ppc440gx_ebc8_bus_printinfo,
    & ppc440gx_ebc8_bus_prepare, & ppc440gx_ebc8_bus_area, & ppc440gx_ebc8_bus_read_start,
    & ppc440gx_ebc8_bus_read_next, & ppc440gx_ebc8_bus_read_end, & ppc440gx_ebc8_bus_read,
    & ppc440gx_ebc8_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 235 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc440gx_ebc8.c"
static bus_t *ppc440gx_ebc8_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 241
  failed = 0;
#line 243
  if (! chain) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if (! chain->parts) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if ((chain->parts)->len <= chain->active_part) {
#line 244
    return ((bus_t *)((void *)0));
  } else
#line 243
  if (chain->active_part < 0) {
#line 244
    return ((bus_t *)((void *)0));
  }
  {
#line 246
  tmp = malloc(sizeof(bus_t ));
#line 246
  bus___0 = (bus_t *)tmp;
  }
#line 247
  if (! bus___0) {
#line 248
    return ((bus_t *)((void *)0));
  }
  {
#line 250
  bus___0->driver = & ppc440gx_ebc8_bus;
#line 251
  bus___0->params = malloc(sizeof(bus_params_t___9 ));
  }
#line 252
  if (! bus___0->params) {
    {
#line 253
    free((void *)bus___0);
    }
#line 254
    return ((bus_t *)((void *)0));
  }
#line 257
  ((bus_params_t___9 *)bus___0->params)->chain = chain;
#line 258
  ((bus_params_t___9 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 32)) {
#line 260
      goto while_break;
    }
    {
#line 261
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCADR%d",
            i);
#line 262
    ((bus_params_t___9 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 263
    if (! ((bus_params_t___9 *)bus___0->params)->a[i]) {
      {
#line 264
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 264
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 265
      failed = 1;
      }
#line 266
      goto while_break;
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i < 8)) {
#line 269
      goto while_break___0;
    }
    {
#line 270
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCDATA%d",
            i);
#line 271
    ((bus_params_t___9 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                   (char const   *)(buff));
    }
#line 272
    if (! ((bus_params_t___9 *)bus___0->params)->d[i]) {
      {
#line 273
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 273
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 274
      failed = 1;
      }
#line 275
      goto while_break___0;
    }
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 278
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCCS0_N");
#line 279
  ((bus_params_t___9 *)bus___0->params)->ncs = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                (char const   *)(buff));
  }
#line 280
  if (! ((bus_params_t___9 *)bus___0->params)->ncs) {
    {
#line 281
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 281
    printf((char const   */* __restrict  */)tmp___2, buff);
#line 282
    failed = 1;
    }
  }
  {
#line 284
  ((bus_params_t___9 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                "EBCWE_N");
  }
#line 285
  if (! ((bus_params_t___9 *)bus___0->params)->nwe) {
    {
#line 286
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 286
    printf((char const   */* __restrict  */)tmp___3, "nWE");
#line 287
    failed = 1;
    }
  }
  {
#line 289
  ((bus_params_t___9 *)bus___0->params)->noe = part_find_signal(((bus_params_t___9 *)bus___0->params)->part,
                                                                "EBCOE_N");
  }
#line 290
  if (! ((bus_params_t___9 *)bus___0->params)->noe) {
    {
#line 291
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 291
    printf((char const   */* __restrict  */)tmp___4, "nOE");
#line 292
    failed = 1;
    }
  }
#line 295
  if (failed) {
    {
#line 296
    free(bus___0->params);
#line 297
    free((void *)bus___0);
    }
#line 298
    return ((bus_t *)((void *)0));
  }
#line 301
  return (bus___0);
}
}
#line 38 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  ppc405ep_bus ;
#line 55 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void setup_address___10(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 59
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 61
  i = 6;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 32)) {
#line 61
      goto while_break;
    }
    {
#line 62
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 61
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void set_data_in___10(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 71
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 74
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned int )i < area.width)) {
#line 76
      goto while_break;
    }
    {
#line 77
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[i], 0, 0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void setup_data___10(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 84
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 87
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 89
  i = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[15 - i], 1, (int )((d >> i) & 1U));
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void ppc405ep_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < ((((bus_params_t___10 *)bus___0->params)->chain)->parts)->len)) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )((bus_params_t___10 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___10 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 100
      goto while_break;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp = gettext("IBM PowerPC 405EP compatible bus driver via BSR (JTAG part No. %d)\n");
#line 101
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void ppc405ep_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 107
  part_set_instruction(((bus_params_t___10 *)bus___0->params)->part, "EXTEST");
#line 108
  chain_shift_instructions(((bus_params_t___10 *)bus___0->params)->chain);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void ppc405ep_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 114
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 115
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 117
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 118
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 119
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 121
  setup_address___10(bus___0, adr);
#line 122
  set_data_in___10(bus___0);
#line 124
  chain_shift_data_registers(chain___0, 0);
  }
#line 125
  return;
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 130
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 131
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 133
  d = (uint32_t )0;
#line 136
  ppc405ep_bus_area(bus___0, adr, & area);
#line 138
  setup_address___10(bus___0, adr);
#line 139
  chain_shift_data_registers(chain___0, 1);
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned int )i < area.width)) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[15 - i]);
#line 142
    d |= (uint32_t )(tmp << i);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (d);
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 150
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 151
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 153
  d = (uint32_t )0;
#line 156
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 158
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 159
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[15 - i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  int res ;
  uint32_t tmp ;

  {
  {
#line 173
  ppc405ep_bus_read_start(bus___0, adr);
#line 174
  tmp = ppc405ep_bus_read_end(bus___0);
#line 174
  res = (int )tmp;
  }
#line 176
  return ((uint32_t )res);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void ppc405ep_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 182
  p = ((bus_params_t___10 *)bus___0->params)->part;
#line 183
  chain___0 = ((bus_params_t___10 *)bus___0->params)->chain;
#line 185
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 186
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 189
  setup_address___10(bus___0, adr);
#line 190
  setup_data___10(bus___0, data);
#line 192
  chain_shift_data_registers(chain___0, 0);
#line 194
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 195
  chain_shift_data_registers(chain___0, 0);
#line 196
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 198
  chain_shift_data_registers(chain___0, 0);
  }
#line 199
  return;
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 204
  area->description = (char const   *)((void *)0);
#line 205
  area->start = 0U;
#line 206
  area->length = 4294967296UL;
#line 207
  area->width = 16U;
#line 209
  return (0);
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static void ppc405ep_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 215
  free(bus___0->params);
#line 216
  free((void *)bus___0);
  }
#line 217
  return;
}
}
#line 219
static bus_t *ppc405ep_bus_new(void) ;
#line 221 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
struct bus_driver  const  ppc405ep_bus  = 
#line 221
     {"ppc405ep", "IBM PowerPC 405EP compatible bus driver via BSR", & ppc405ep_bus_new,
    & ppc405ep_bus_free, & ppc405ep_bus_printinfo, & ppc405ep_bus_prepare, & ppc405ep_bus_area,
    & ppc405ep_bus_read_start, & ppc405ep_bus_read_next, & ppc405ep_bus_read_end,
    & ppc405ep_bus_read, & ppc405ep_bus_write, (int (*)(bus_t *bus ))0};
#line 236 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ppc405ep.c"
static bus_t *ppc405ep_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 242
  failed = 0;
#line 244
  if (! chain) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if (! chain->parts) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if ((chain->parts)->len <= chain->active_part) {
#line 245
    return ((bus_t *)((void *)0));
  } else
#line 244
  if (chain->active_part < 0) {
#line 245
    return ((bus_t *)((void *)0));
  }
  {
#line 247
  tmp = malloc(sizeof(bus_t ));
#line 247
  bus___0 = (bus_t *)tmp;
  }
#line 248
  if (! bus___0) {
#line 249
    return ((bus_t *)((void *)0));
  }
  {
#line 251
  bus___0->driver = & ppc405ep_bus;
#line 252
  bus___0->params = malloc(sizeof(bus_params_t___10 ));
  }
#line 253
  if (! bus___0->params) {
    {
#line 254
    free((void *)bus___0);
    }
#line 255
    return ((bus_t *)((void *)0));
  }
#line 258
  ((bus_params_t___10 *)bus___0->params)->chain = chain;
#line 259
  ((bus_params_t___10 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 261
  i = 6;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 32)) {
#line 261
      goto while_break;
    }
    {
#line 262
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerAddr%d",
            i);
#line 263
    ((bus_params_t___10 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 264
    if (! ((bus_params_t___10 *)bus___0->params)->a[i]) {
      {
#line 265
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 265
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 266
      failed = 1;
      }
#line 267
      goto while_break;
    }
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (i < 16)) {
#line 270
      goto while_break___0;
    }
    {
#line 271
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerData%d",
            i);
#line 272
    ((bus_params_t___10 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 273
    if (! ((bus_params_t___10 *)bus___0->params)->d[i]) {
      {
#line 274
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 274
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 275
      failed = 1;
      }
#line 276
      goto while_break___0;
    }
#line 270
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 279
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerCS0");
#line 280
  ((bus_params_t___10 *)bus___0->params)->ncs = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 (char const   *)(buff));
  }
#line 281
  if (! ((bus_params_t___10 *)bus___0->params)->ncs) {
    {
#line 282
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 282
    printf((char const   */* __restrict  */)tmp___2, "nCS0");
#line 283
    failed = 1;
    }
  }
  {
#line 285
  ((bus_params_t___10 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 "PerWBE1");
  }
#line 286
  if (! ((bus_params_t___10 *)bus___0->params)->nwe) {
    {
#line 287
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 287
    printf((char const   */* __restrict  */)tmp___3, "nWE");
#line 288
    failed = 1;
    }
  }
  {
#line 290
  ((bus_params_t___10 *)bus___0->params)->noe = part_find_signal(((bus_params_t___10 *)bus___0->params)->part,
                                                                 "PerOE");
  }
#line 291
  if (! ((bus_params_t___10 *)bus___0->params)->noe) {
    {
#line 292
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 292
    printf((char const   */* __restrict  */)tmp___4, "nOE");
#line 293
    failed = 1;
    }
  }
#line 296
  if (failed) {
    {
#line 297
    free(bus___0->params);
#line 298
    free((void *)bus___0);
    }
#line 299
    return ((bus_t *)((void *)0));
  }
#line 302
  return (bus___0);
}
}
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  mpc824x_bus ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void setup_address___11(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 70
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < 23)) {
#line 72
      goto while_break;
    }
    {
#line 73
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ar[i], 1, (int )((a >> i) & 1U));
#line 72
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void set_data_in___11(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 82
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 85
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 86
  if (area.width > 8U) {
#line 87
    return;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned int )i < area.width)) {
#line 89
      goto while_break;
    }
    {
#line 90
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i], 0, 0);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void setup_data___11(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 97
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 100
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 101
  if (area.width > 8U) {
#line 102
    return;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned int )i < area.width)) {
#line 104
      goto while_break;
    }
    {
#line 105
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 104
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static uint32_t get_data___0(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 113
  d = (uint32_t )0;
#line 114
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 116
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 117
  if (area.width > 8U) {
#line 118
    return ((uint32_t )0);
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned int )i < area.width)) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i]);
#line 121
    d |= (uint32_t )(tmp << i);
#line 120
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (d);
}
}
#line 126 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void mpc824x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < ((((bus_params_t___11 *)bus___0->params)->chain)->parts)->len)) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned long )((bus_params_t___11 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___11 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 133
      goto while_break;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp = gettext("Motorola MPC824x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 134
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void mpc824x_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 140
  part_set_instruction(((bus_params_t___11 *)bus___0->params)->part, "EXTEST");
#line 141
  chain_shift_instructions(((bus_params_t___11 *)bus___0->params)->chain);
  }
#line 142
  return;
}
}
#line 144 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void mpc824x_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 147
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 149
  ((bus_params_t___11 *)bus___0->params)->last_adr = adr;
#line 152
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nrcs0, 1, 0);
#line 153
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 154
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nfoe, 1, 0);
#line 156
  setup_address___11(bus___0, adr);
#line 157
  set_data_in___11(bus___0, adr);
#line 159
  chain_shift_data_registers(((bus_params_t___11 *)bus___0->params)->chain, 0);
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 167
  setup_address___11(bus___0, adr);
#line 168
  chain_shift_data_registers(((bus_params_t___11 *)bus___0->params)->chain, 1);
#line 170
  d = get_data___0(bus___0, ((bus_params_t___11 *)bus___0->params)->last_adr);
#line 171
  ((bus_params_t___11 *)bus___0->params)->last_adr = adr;
  }
#line 172
  return (d);
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 178
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 180
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nrcs0, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nfoe, 1, 1);
#line 183
  chain_shift_data_registers(((bus_params_t___11 *)bus___0->params)->chain, 1);
#line 185
  tmp = get_data___0(bus___0, ((bus_params_t___11 *)bus___0->params)->last_adr);
  }
#line 185
  return (tmp);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  mpc824x_bus_read_start(bus___0, adr);
#line 192
  tmp = mpc824x_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void mpc824x_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 199
  p = ((bus_params_t___11 *)bus___0->params)->part;
#line 200
  chain___0 = ((bus_params_t___11 *)bus___0->params)->chain;
#line 202
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nrcs0, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nfoe, 1, 1);
#line 206
  setup_address___11(bus___0, adr);
#line 207
  setup_data___11(bus___0, adr, data);
#line 209
  chain_shift_data_registers(chain___0, 0);
#line 211
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 0);
#line 212
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 214
  chain_shift_data_registers(chain___0, 0);
  }
#line 215
  return;
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 220
  if (adr < 4278190080U) {
#line 221
    area->description = (char const   *)((void *)0);
#line 222
    area->start = 0U;
#line 223
    area->length = 4278190080UL;
#line 224
    area->width = 0U;
#line 226
    return (0);
  }
#line 229
  if (adr < 4286578688U) {
#line 230
    area->description = "Base ROM Interface (Bank 1)";
#line 231
    area->start = 4278190080U;
#line 232
    area->length = 8388608UL;
#line 233
    area->width = 0U;
#line 235
    return (0);
  }
#line 238
  if (((bus_params_t___11 *)bus___0->params)->boot_sdma1 == 0) {
#line 239
    area->description = "Base ROM Interface (Bank 0)";
#line 240
    area->start = 4286578688U;
#line 241
    area->length = 8388608UL;
#line 242
    if (((bus_params_t___11 *)bus___0->params)->boot_nfoe != 0) {
#line 242
      area->width = 8U;
    } else {
#line 242
      area->width = 0U;
    }
#line 244
    return (0);
  }
#line 248
  if (adr < 4290772992U) {
#line 249
    area->description = (char const   *)((void *)0);
#line 250
    area->start = 4286578688U;
#line 251
    area->length = 4194304UL;
#line 252
    area->width = 0U;
#line 254
    return (0);
  }
#line 257
  area->description = "Base ROM Interface (Bank 0)";
#line 258
  area->start = 4290772992U;
#line 259
  area->length = 4194304UL;
#line 260
  if (((bus_params_t___11 *)bus___0->params)->boot_nfoe != 0) {
#line 260
    area->width = 8U;
  } else {
#line 260
    area->width = 0U;
  }
#line 262
  return (0);
}
}
#line 265 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static void mpc824x_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 268
  free(bus___0->params);
#line 269
  free((void *)bus___0);
  }
#line 270
  return;
}
}
#line 272 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
static bus_t *mpc824x_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  signal_t *s_nfoe ;
  signal_t *s_sdma1 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 278
  failed = 0;
#line 283
  if (! chain) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if (! chain->parts) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if ((chain->parts)->len <= chain->active_part) {
#line 284
    return ((bus_t *)((void *)0));
  } else
#line 283
  if (chain->active_part < 0) {
#line 284
    return ((bus_t *)((void *)0));
  }
  {
#line 286
  tmp = malloc(sizeof(bus_t ));
#line 286
  bus___0 = (bus_t *)tmp;
  }
#line 287
  if (! bus___0) {
#line 288
    return ((bus_t *)((void *)0));
  }
  {
#line 290
  bus___0->driver = & mpc824x_bus;
#line 291
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___11 ));
  }
#line 292
  if (! bus___0->params) {
    {
#line 293
    free((void *)bus___0);
    }
#line 294
    return ((bus_t *)((void *)0));
  }
  {
#line 297
  ((bus_params_t___11 *)bus___0->params)->chain = chain;
#line 298
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 298
  ((bus_params_t___11 *)bus___0->params)->part = part___0;
#line 300
  s_nfoe = part_find_signal(part___0, "nFOE");
#line 301
  s_sdma1 = part_find_signal(part___0, "SDMA1");
#line 302
  part_set_signal(part___0, s_nfoe, 0, 0);
#line 303
  part_set_signal(part___0, s_sdma1, 0, 0);
#line 305
  part_set_instruction(part___0, "SAMPLE/PRELOAD");
#line 306
  chain_shift_instructions(chain);
#line 307
  chain_shift_data_registers(chain, 0);
#line 308
  part_set_instruction(part___0, "EXTEST");
#line 309
  chain_shift_instructions(chain);
#line 310
  chain_shift_data_registers(chain, 1);
#line 312
  ((bus_params_t___11 *)bus___0->params)->boot_nfoe = part_get_signal(part___0, s_nfoe);
#line 313
  ((bus_params_t___11 *)bus___0->params)->boot_sdma1 = part_get_signal(part___0, s_sdma1);
#line 315
  i = 0;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i <= 10)) {
#line 315
      goto while_break;
    }
    {
#line 316
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDMA%d",
            i);
#line 317
    ((bus_params_t___11 *)bus___0->params)->ar[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 318
    if (! ((bus_params_t___11 *)bus___0->params)->ar[i]) {
      {
#line 319
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 319
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 320
      failed = 1;
      }
#line 321
      goto while_break;
    }
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  ((bus_params_t___11 *)bus___0->params)->ar[11] = part_find_signal(part___0, "SDBA0");
  }
#line 325
  if (! ((bus_params_t___11 *)bus___0->params)->ar[11]) {
    {
#line 326
    tmp___1 = gettext("signal \'%s\' not found\n");
#line 326
    printf((char const   */* __restrict  */)tmp___1, "SDBA0");
#line 327
    failed = 1;
    }
  }
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 329
    if (! (i < 8)) {
#line 329
      goto while_break___0;
    }
    {
#line 330
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PAR%d",
            i);
#line 331
    ((bus_params_t___11 *)bus___0->params)->ar[19 - i] = part_find_signal(part___0,
                                                                          (char const   *)(buff));
    }
#line 332
    if (! ((bus_params_t___11 *)bus___0->params)->ar[19 - i]) {
      {
#line 333
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 333
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 334
      failed = 1;
      }
#line 335
      goto while_break___0;
    }
#line 329
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  ((bus_params_t___11 *)bus___0->params)->ar[20] = part_find_signal(part___0, "SDBA1");
  }
#line 339
  if (! ((bus_params_t___11 *)bus___0->params)->ar[20]) {
    {
#line 340
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 340
    printf((char const   */* __restrict  */)tmp___3, "SDBA1");
#line 341
    failed = 1;
    }
  }
  {
#line 343
  ((bus_params_t___11 *)bus___0->params)->ar[21] = part_find_signal(part___0, "SDMA11");
  }
#line 344
  if (! ((bus_params_t___11 *)bus___0->params)->ar[21]) {
    {
#line 345
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 345
    printf((char const   */* __restrict  */)tmp___4, "SDMA11");
#line 346
    failed = 1;
    }
  }
  {
#line 348
  ((bus_params_t___11 *)bus___0->params)->ar[22] = part_find_signal(part___0, "SDMA12");
  }
#line 349
  if (! ((bus_params_t___11 *)bus___0->params)->ar[22]) {
    {
#line 350
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 350
    printf((char const   */* __restrict  */)tmp___5, "SDMA12");
#line 351
    failed = 1;
    }
  }
  {
#line 353
  ((bus_params_t___11 *)bus___0->params)->nrcs0 = part_find_signal(part___0, "nRCS0");
  }
#line 354
  if (! ((bus_params_t___11 *)bus___0->params)->nrcs0) {
    {
#line 355
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 355
    printf((char const   */* __restrict  */)tmp___6, "nRCS0");
#line 356
    failed = 1;
    }
  }
  {
#line 358
  ((bus_params_t___11 *)bus___0->params)->nwe = part_find_signal(part___0, "nWE");
  }
#line 359
  if (! ((bus_params_t___11 *)bus___0->params)->nwe) {
    {
#line 360
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 360
    printf((char const   */* __restrict  */)tmp___7, "nWE");
#line 361
    failed = 1;
    }
  }
  {
#line 363
  ((bus_params_t___11 *)bus___0->params)->nfoe = part_find_signal(part___0, "nFOE");
  }
#line 364
  if (! ((bus_params_t___11 *)bus___0->params)->nwe) {
    {
#line 365
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 365
    printf((char const   */* __restrict  */)tmp___8, "nFOE");
#line 366
    failed = 1;
    }
  }
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (i < 8)) {
#line 368
      goto while_break___1;
    }
    {
#line 369
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MDH%d",
            i);
#line 370
    ((bus_params_t___11 *)bus___0->params)->d[7 - i] = part_find_signal(part___0,
                                                                        (char const   *)(buff));
    }
#line 371
    if (! ((bus_params_t___11 *)bus___0->params)->d[7 - i]) {
      {
#line 372
      tmp___9 = gettext("signal \'%s\' not found\n");
#line 372
      printf((char const   */* __restrict  */)tmp___9, buff);
#line 373
      failed = 1;
      }
#line 374
      goto while_break___1;
    }
#line 368
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 378
  if (failed) {
    {
#line 379
    free(bus___0->params);
#line 380
    free((void *)bus___0);
    }
#line 381
    return ((bus_t *)((void *)0));
  }
#line 384
  return (bus___0);
}
}
#line 387 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc824x.c"
struct bus_driver  const  mpc824x_bus  = 
#line 387
     {"mpc824x", "Motorola MPC824x compatible bus driver via BSR", & mpc824x_bus_new,
    & mpc824x_bus_free, & mpc824x_bus_printinfo, & mpc824x_bus_prepare, & mpc824x_bus_area,
    & mpc824x_bus_read_start, & mpc824x_bus_read_next, & mpc824x_bus_read_end, & mpc824x_bus_read,
    & mpc824x_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  mpc5200_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void setup_address___12(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 24)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void set_data_in___12(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 81
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 82
  if (area.width > 8U) {
#line 83
    return;
  }
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned int )i < area.width)) {
#line 85
      goto while_break;
    }
    {
#line 86
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 0, 0);
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void setup_data___12(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 93
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 96
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 97
  if (area.width > 8U) {
#line 98
    return;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((unsigned int )i < area.width)) {
#line 100
      goto while_break;
    }
    {
#line 101
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static uint32_t get_data___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 109
  d = (uint32_t )0;
#line 110
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 112
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 113
  if (area.width > 8U) {
#line 114
    return ((uint32_t )0);
  }
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned int )i < area.width)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp = part_get_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i]);
#line 117
    d |= (uint32_t )(tmp << i);
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (d);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void mpc5200_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < ((((bus_params_t___12 *)bus___0->params)->chain)->parts)->len)) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )((bus_params_t___12 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___12 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 129
      goto while_break;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = gettext("Freescale MPC5200 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 130
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void mpc5200_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 136
  part_set_instruction(((bus_params_t___12 *)bus___0->params)->part, "EXTEST");
#line 137
  chain_shift_instructions(((bus_params_t___12 *)bus___0->params)->chain);
  }
#line 138
  return;
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void mpc5200_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 143
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 145
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 148
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[0], 1, 0);
#line 149
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[1], 1, 1);
#line 150
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[2], 1, 1);
#line 151
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[3], 1, 1);
#line 152
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 153
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->noe, 1, 0);
#line 155
  setup_address___12(bus___0, adr);
#line 156
  set_data_in___12(bus___0, adr);
#line 158
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 0);
  }
#line 159
  return;
}
}
#line 161 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 166
  setup_address___12(bus___0, adr);
#line 167
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 1);
#line 169
  d = get_data___1(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
#line 170
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
  }
#line 171
  return (d);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 177
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 179
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[0], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->noe, 1, 1);
#line 182
  chain_shift_data_registers(((bus_params_t___12 *)bus___0->params)->chain, 1);
#line 184
  tmp = get_data___1(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 190
  mpc5200_bus_read_start(bus___0, adr);
#line 191
  tmp = mpc5200_bus_read_end(bus___0);
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void mpc5200_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 198
  p = ((bus_params_t___12 *)bus___0->params)->part;
#line 199
  chain___0 = ((bus_params_t___12 *)bus___0->params)->chain;
#line 201
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[0], 1, 0);
#line 202
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[1], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[2], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ncs[3], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->noe, 1, 1);
#line 208
  setup_address___12(bus___0, adr);
#line 209
  setup_data___12(bus___0, adr, data);
#line 211
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 0);
#line 214
  chain_shift_data_registers(chain___0, 0);
#line 215
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 216
  chain_shift_data_registers(chain___0, 0);
  }
#line 217
  return;
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 222
  if (adr < 16777216U) {
#line 224
    area->description = "LocalPlus Bus";
#line 225
    area->start = 0U;
#line 226
    area->length = 16777216UL;
#line 227
    area->width = 8U;
#line 228
    return (0);
  }
#line 231
  area->description = (char const   *)((void *)0);
#line 232
  area->start = (uint32_t )16777216;
#line 233
  area->length = (uint64_t )4278190080U;
#line 234
  area->width = 0U;
#line 235
  return (0);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static void mpc5200_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 241
  free(bus___0->params);
#line 242
  free((void *)bus___0);
  }
#line 243
  return;
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
static bus_t *mpc5200_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  part_t *part___0 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 251
  failed = 0;
#line 254
  if (! chain) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if (! chain->parts) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if ((chain->parts)->len <= chain->active_part) {
#line 255
    return ((bus_t *)((void *)0));
  } else
#line 254
  if (chain->active_part < 0) {
#line 255
    return ((bus_t *)((void *)0));
  }
  {
#line 257
  tmp = malloc(sizeof(bus_t ));
#line 257
  bus___0 = (bus_t *)tmp;
  }
#line 258
  if (! bus___0) {
#line 259
    return ((bus_t *)((void *)0));
  }
  {
#line 261
  bus___0->driver = & mpc5200_bus;
#line 262
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___12 ));
  }
#line 263
  if (! bus___0->params) {
    {
#line 264
    free((void *)bus___0);
    }
#line 265
    return ((bus_t *)((void *)0));
  }
#line 268
  ((bus_params_t___12 *)bus___0->params)->chain = chain;
#line 269
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 269
  ((bus_params_t___12 *)bus___0->params)->part = part___0;
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < 24)) {
#line 272
      goto while_break;
    }
    {
#line 273
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i);
#line 274
    ((bus_params_t___12 *)bus___0->params)->ad[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 275
    if (! ((bus_params_t___12 *)bus___0->params)->ad[i]) {
      {
#line 276
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 276
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 277
      failed = 1;
      }
#line 278
      goto while_break;
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < 4)) {
#line 281
      goto while_break___0;
    }
    {
#line 282
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"LP_CS%d_B",
            i);
#line 283
    ((bus_params_t___12 *)bus___0->params)->ncs[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 284
    if (! ((bus_params_t___12 *)bus___0->params)->ncs[i]) {
      {
#line 285
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 285
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 286
      failed = 1;
      }
#line 287
      goto while_break___0;
    }
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 290
  ((bus_params_t___12 *)bus___0->params)->nwe = part_find_signal(part___0, "LP_RW");
  }
#line 291
  if (! ((bus_params_t___12 *)bus___0->params)->nwe) {
    {
#line 292
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 292
    printf((char const   */* __restrict  */)tmp___2, "LP_RW");
#line 293
    failed = 1;
    }
  }
  {
#line 295
  ((bus_params_t___12 *)bus___0->params)->noe = part_find_signal(part___0, "LP_OE");
  }
#line 296
  if (! ((bus_params_t___12 *)bus___0->params)->noe) {
    {
#line 297
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 297
    printf((char const   */* __restrict  */)tmp___3, "LP_OE");
#line 298
    failed = 1;
    }
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 300
    if (! (i < 8)) {
#line 300
      goto while_break___1;
    }
    {
#line 301
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i + 24);
#line 302
    ((bus_params_t___12 *)bus___0->params)->d[i] = part_find_signal(part___0, (char const   *)(buff));
    }
#line 303
    if (! ((bus_params_t___12 *)bus___0->params)->d[i]) {
      {
#line 304
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 304
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 305
      failed = 1;
      }
#line 306
      goto while_break___1;
    }
#line 300
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 310
  if (failed) {
    {
#line 311
    free(bus___0->params);
#line 312
    free((void *)bus___0);
    }
#line 313
    return ((bus_t *)((void *)0));
  }
#line 316
  return (bus___0);
}
}
#line 319 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/mpc5200.c"
struct bus_driver  const  mpc5200_bus  = 
#line 319
     {"mpc5200", "Freescale MPC5200 compatible bus driver via BSR", & mpc5200_bus_new,
    & mpc5200_bus_free, & mpc5200_bus_printinfo, & mpc5200_bus_prepare, & mpc5200_bus_area,
    & mpc5200_bus_read_start, & mpc5200_bus_read_next, & mpc5200_bus_read_end, & mpc5200_bus_read,
    & mpc5200_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  lh7a400_bus ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void setup_address___13(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 24)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void set_data_in___13(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 89
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 92
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 94
  i = 0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((unsigned int )i < area.width)) {
#line 94
      goto while_break;
    }
    {
#line 95
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 0, 0);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void setup_data___13(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 103
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 106
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 108
  i = 0;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned int )i < area.width)) {
#line 108
      goto while_break;
    }
    {
#line 109
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void lh7a400_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < ((((bus_params_t___13 *)bus___0->params)->chain)->parts)->len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )((bus_params_t___13 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___13 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 119
      goto while_break;
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp = gettext("Sharp LH7A400 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 120
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 121
  return;
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void lh7a400_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 126
  part_set_instruction(((bus_params_t___13 *)bus___0->params)->part, "EXTEST");
#line 127
  chain_shift_instructions(((bus_params_t___13 *)bus___0->params)->chain);
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void lh7a400_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 134
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 135
  chain___0 = ((bus_params_t___13 *)bus___0->params)->chain;
#line 137
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 138
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 139
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 0);
#line 141
  setup_address___13(bus___0, adr);
#line 142
  set_data_in___13(bus___0);
#line 144
  chain_shift_data_registers(chain___0, 0);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 151
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 152
  chain___0 = ((bus_params_t___13 *)bus___0->params)->chain;
#line 154
  d = (uint32_t )0;
#line 157
  lh7a400_bus_area(bus___0, adr, & area);
#line 159
  setup_address___13(bus___0, adr);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < area.width)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 172
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 173
  chain___0 = ((bus_params_t___13 *)bus___0->params)->chain;
#line 175
  d = (uint32_t )0;
#line 178
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 180
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 183
  chain_shift_data_registers(chain___0, 1);
#line 185
  i = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! ((unsigned int )i < area.width)) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp = part_get_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i]);
#line 186
    d |= (uint32_t )(tmp << i);
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (d);
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 194
  lh7a400_bus_read_start(bus___0, adr);
#line 195
  tmp = lh7a400_bus_read_end(bus___0);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void lh7a400_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 202
  p = ((bus_params_t___13 *)bus___0->params)->part;
#line 203
  chain___0 = ((bus_params_t___13 *)bus___0->params)->chain;
#line 205
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 206
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 209
  setup_address___13(bus___0, adr);
#line 210
  setup_data___13(bus___0, data);
#line 212
  chain_shift_data_registers(chain___0, 0);
#line 214
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 0);
#line 215
  chain_shift_data_registers(chain___0, 0);
#line 217
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 218
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 1);
#line 219
  chain_shift_data_registers(chain___0, 0);
  }
#line 220
  return;
}
}
#line 222 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  unsigned int width ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 227
  area->description = (char const   *)((void *)0);
#line 228
  area->start = 0U;
#line 229
  area->length = 268435456UL;
#line 232
  tmp = part_find_signal(((bus_params_t___13 *)bus___0->params)->part, "WIDTH0");
#line 232
  tmp___0 = part_get_signal(((bus_params_t___13 *)bus___0->params)->part, tmp);
#line 232
  width = (unsigned int )tmp___0;
#line 233
  tmp___1 = part_find_signal(((bus_params_t___13 *)bus___0->params)->part, "WIDTH1");
#line 233
  tmp___2 = part_get_signal(((bus_params_t___13 *)bus___0->params)->part, tmp___1);
#line 233
  width |= (unsigned int )(tmp___2 << 1);
  }
#line 235
  if (width < 0U) {
#line 236
    return (-1);
  }
  {
#line 239
  if (width == 0U) {
#line 239
    goto case_0;
  }
#line 242
  if (width == 1U) {
#line 242
    goto case_1;
  }
#line 246
  if (width == 3U) {
#line 246
    goto case_3;
  }
#line 246
  if (width == 2U) {
#line 246
    goto case_3;
  }
#line 238
  goto switch_break;
  case_0: /* CIL Label */ 
#line 240
  area->width = 8U;
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
#line 243
  area->width = 16U;
#line 244
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 247
  area->width = 32U;
  switch_break: /* CIL Label */ ;
  }
#line 250
  return (0);
}
}
#line 253 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static void lh7a400_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 256
  free(bus___0->params);
#line 257
  free((void *)bus___0);
  }
#line 258
  return;
}
}
#line 260
static bus_t *lh7a400_bus_new(void) ;
#line 262 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
struct bus_driver  const  lh7a400_bus  = 
#line 262
     {"lh7a400", "Sharp LH7A400 compatible bus driver via BSR (flash access only!)",
    & lh7a400_bus_new, & lh7a400_bus_free, & lh7a400_bus_printinfo, & lh7a400_bus_prepare,
    & lh7a400_bus_area, & lh7a400_bus_read_start, & lh7a400_bus_read_next, & lh7a400_bus_read_end,
    & lh7a400_bus_read, & lh7a400_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 278 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/lh7a400.c"
static bus_t *lh7a400_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 284
  failed = 0;
#line 286
  if (! chain) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (! chain->parts) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if ((chain->parts)->len <= chain->active_part) {
#line 287
    return ((bus_t *)((void *)0));
  } else
#line 286
  if (chain->active_part < 0) {
#line 287
    return ((bus_t *)((void *)0));
  }
  {
#line 289
  tmp = malloc(sizeof(bus_t ));
#line 289
  bus___0 = (bus_t *)tmp;
  }
#line 290
  if (! bus___0) {
#line 291
    return ((bus_t *)((void *)0));
  }
  {
#line 293
  bus___0->driver = & lh7a400_bus;
#line 294
  bus___0->params = malloc(sizeof(bus_params_t___13 ));
  }
#line 295
  if (! bus___0->params) {
    {
#line 296
    free((void *)bus___0);
    }
#line 297
    return ((bus_t *)((void *)0));
  }
#line 300
  ((bus_params_t___13 *)bus___0->params)->chain = chain;
#line 301
  ((bus_params_t___13 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 24)) {
#line 303
      goto while_break;
    }
    {
#line 304
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 305
    ((bus_params_t___13 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 306
    if (! ((bus_params_t___13 *)bus___0->params)->a[i]) {
      {
#line 307
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 307
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 308
      failed = 1;
      }
#line 309
      goto while_break;
    }
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < 32)) {
#line 312
      goto while_break___0;
    }
    {
#line 313
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 314
    ((bus_params_t___13 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 315
    if (! ((bus_params_t___13 *)bus___0->params)->d[i]) {
      {
#line 316
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 316
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 317
      failed = 1;
      }
#line 318
      goto while_break___0;
    }
#line 312
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 321
  i = 0;
  {
#line 321
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 321
    if (! (i < 4)) {
#line 321
      goto while_break___1;
    }
    {
#line 322
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 323
    ((bus_params_t___13 *)bus___0->params)->ncs[i] = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 324
    if (! ((bus_params_t___13 *)bus___0->params)->ncs[i]) {
      {
#line 325
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 325
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 326
      failed = 1;
      }
#line 327
      goto while_break___1;
    }
#line 321
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 330
    if (! (i < 2)) {
#line 330
      goto while_break___2;
    }
    {
#line 331
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WIDTH%d",
            i);
#line 332
    ((bus_params_t___13 *)bus___0->params)->width[i] = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 333
    if (! ((bus_params_t___13 *)bus___0->params)->width[i]) {
      {
#line 334
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 334
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 335
      failed = 1;
      }
#line 336
      goto while_break___2;
    }
#line 330
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 339
  ((bus_params_t___13 *)bus___0->params)->nwe = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                 "nWE0");
  }
#line 340
  if (! ((bus_params_t___13 *)bus___0->params)->nwe) {
    {
#line 341
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 341
    printf((char const   */* __restrict  */)tmp___4, "nWE");
#line 342
    failed = 1;
    }
  }
  {
#line 344
  ((bus_params_t___13 *)bus___0->params)->noe = part_find_signal(((bus_params_t___13 *)bus___0->params)->part,
                                                                 "nOE");
  }
#line 345
  if (! ((bus_params_t___13 *)bus___0->params)->noe) {
    {
#line 346
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 346
    printf((char const   */* __restrict  */)tmp___5, "nOE");
#line 347
    failed = 1;
    }
  }
#line 350
  if (failed) {
    {
#line 351
    free(bus___0->params);
#line 352
    free((void *)bus___0);
    }
#line 353
    return ((bus_t *)((void *)0));
  }
#line 356
  return (bus___0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  jopcyc_bus ;
#line 134 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static uint32_t last_address___0  =    (uint32_t )0;
#line 136 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void setup_address___14(bus_t *bus___0 , uint32_t a , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 140
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 143
  last_address___0 = a;
  {
#line 146
  if ((unsigned int )comp->ctype == 0U) {
#line 146
    goto case_0;
  }
#line 152
  if ((unsigned int )comp->ctype == 1U) {
#line 152
    goto case_1;
  }
#line 155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 147
  addr_width = 18;
#line 150
  a >>= 1;
#line 151
  goto switch_break;
  case_1: /* CIL Label */ 
#line 153
  addr_width = 19;
#line 154
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 156
  addr_width = 0;
#line 157
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < addr_width)) {
#line 160
      goto while_break;
    }
    {
#line 161
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static int detect_data_width___0(component_t___0 *comp ) 
{ 
  int width ;

  {
  {
#line 170
  if ((unsigned int )comp->ctype == 0U) {
#line 170
    goto case_0;
  }
#line 173
  if ((unsigned int )comp->ctype == 1U) {
#line 173
    goto case_1;
  }
#line 176
  goto switch_default;
  case_0: /* CIL Label */ 
#line 171
  width = 16;
#line 172
  goto switch_break;
  case_1: /* CIL Label */ 
#line 174
  width = 8;
#line 175
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 177
  width = 0;
#line 178
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 181
  return (width);
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void set_data_in___14(bus_t *bus___0 , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 188
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 191
  width = detect_data_width___0(comp);
#line 193
  i = 0;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (i < width)) {
#line 193
      goto while_break;
    }
    {
#line 194
    part_set_signal(p, comp->d[i], 0, 0);
#line 193
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return;
}
}
#line 197 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void setup_data___14(bus_t *bus___0 , uint32_t d , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 201
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 204
  width = detect_data_width___0(comp);
#line 206
  i = 0;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < width)) {
#line 206
      goto while_break;
    }
    {
#line 207
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t___0 **comp ) ;
#line 216 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void jopcyc_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 221
  i = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < ((((bus_params_t___14 *)bus___0->params)->chain)->parts)->len)) {
#line 221
      goto while_break;
    }
#line 222
    if ((unsigned long )((bus_params_t___14 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___14 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 223
      goto while_break;
    }
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  tmp = gettext("JOP.design Cyclone Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 224
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 225
  return;
}
}
#line 231 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void jopcyc_bus_prepare(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  component_t___0 *comp ;

  {
  {
#line 234
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 235
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 241
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 242
  chain_shift_instructions(chain___0);
#line 245
  comp = & ((bus_params_t___14 *)bus___0->params)->rama;
#line 246
  set_data_in___14(bus___0, comp);
#line 247
  part_set_signal(p, comp->ncs, 1, 1);
#line 248
  part_set_signal(p, comp->nwe, 1, 1);
#line 249
  part_set_signal(p, comp->noe, 1, 1);
#line 250
  part_set_signal(p, comp->nlb, 1, 1);
#line 251
  part_set_signal(p, comp->nub, 1, 1);
#line 254
  comp = & ((bus_params_t___14 *)bus___0->params)->ramb;
#line 255
  set_data_in___14(bus___0, comp);
#line 256
  part_set_signal(p, comp->ncs, 1, 1);
#line 257
  part_set_signal(p, comp->nwe, 1, 1);
#line 258
  part_set_signal(p, comp->noe, 1, 1);
#line 259
  part_set_signal(p, comp->nlb, 1, 1);
#line 260
  part_set_signal(p, comp->nub, 1, 1);
#line 263
  comp = & ((bus_params_t___14 *)bus___0->params)->flash;
#line 264
  set_data_in___14(bus___0, comp);
#line 265
  part_set_signal(p, comp->ncs, 1, 1);
#line 266
  part_set_signal(p, comp->nwe, 1, 1);
#line 267
  part_set_signal(p, comp->noe, 1, 1);
#line 268
  part_set_signal(p, comp->ncs2, 1, 1);
#line 269
  part_set_signal(p, comp->nrdy, 0, 0);
#line 272
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ser_rxd, 0, 0);
#line 273
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ser_nrts, 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ser_txd, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ser_ncts, 0, 0);
#line 277
  chain_shift_data_registers(chain___0, 0);
#line 279
  part_set_instruction(p, "EXTEST");
#line 280
  chain_shift_instructions(chain___0);
  }
#line 281
  return;
}
}
#line 287 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void jopcyc_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 290
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 291
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 295
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 296
  if (! comp) {
    {
#line 297
    tmp = gettext("Address out of range\n");
#line 297
    printf((char const   */* __restrict  */)tmp);
#line 298
    last_address___0 = adr;
    }
#line 299
    return;
  }
  {
#line 302
  part_set_signal(p, comp->ncs, 1, 0);
#line 303
  part_set_signal(p, comp->nwe, 1, 1);
#line 304
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 305
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 306
    part_set_signal(p, comp->nlb, 1, 0);
#line 307
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 310
  setup_address___14(bus___0, adr, comp);
#line 311
  set_data_in___14(bus___0, comp);
#line 313
  chain_shift_data_registers(chain___0, 0);
  }
#line 314
  return;
}
}
#line 320 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 323
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 324
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 326
  d = (uint32_t )0;
#line 330
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 331
  if (! comp) {
    {
#line 332
    tmp = gettext("Address out of range\n");
#line 332
    printf((char const   */* __restrict  */)tmp);
#line 333
    last_address___0 = adr;
    }
#line 334
    return ((uint32_t )0);
  }
  {
#line 337
  setup_address___14(bus___0, adr, comp);
#line 338
  chain_shift_data_registers(chain___0, 1);
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! ((unsigned int )i < area.width)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 341
    d |= (uint32_t )(tmp___0 << i);
#line 340
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (d);
}
}
#line 350 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 353
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 354
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 356
  d = (uint32_t )0;
#line 361
  comp_bus_area___0(bus___0, last_address___0, & area, & comp);
  }
#line 362
  if (! comp) {
    {
#line 363
    tmp = gettext("Address out of range\n");
#line 363
    printf((char const   */* __restrict  */)tmp);
    }
#line 364
    return ((uint32_t )0);
  }
  {
#line 367
  part_set_signal(p, comp->ncs, 1, 1);
#line 368
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 369
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 370
    part_set_signal(p, comp->nlb, 1, 1);
#line 371
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 373
  chain_shift_data_registers(chain___0, 1);
#line 375
  i = 0;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned int )i < area.width)) {
#line 375
      goto while_break;
    }
    {
#line 376
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 376
    d |= (uint32_t )(tmp___0 << i);
#line 375
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return (d);
}
}
#line 385 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 388
  jopcyc_bus_read_start(bus___0, adr);
#line 389
  tmp = jopcyc_bus_read_end(bus___0);
  }
#line 389
  return (tmp);
}
}
#line 396 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void jopcyc_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 399
  p = ((bus_params_t___14 *)bus___0->params)->part;
#line 400
  chain___0 = ((bus_params_t___14 *)bus___0->params)->chain;
#line 404
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 405
  if (! comp) {
    {
#line 406
    tmp = gettext("Address out of range\n");
#line 406
    printf((char const   */* __restrict  */)tmp);
    }
#line 407
    return;
  }
  {
#line 410
  part_set_signal(p, comp->ncs, 1, 0);
#line 411
  part_set_signal(p, comp->nwe, 1, 1);
#line 412
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 413
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 414
    part_set_signal(p, comp->nlb, 1, 0);
#line 415
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 418
  setup_address___14(bus___0, adr, comp);
#line 419
  setup_data___14(bus___0, data, comp);
#line 421
  chain_shift_data_registers(chain___0, 0);
#line 423
  part_set_signal(p, comp->nwe, 1, 0);
#line 424
  chain_shift_data_registers(chain___0, 0);
#line 425
  part_set_signal(p, comp->nwe, 1, 1);
#line 426
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 427
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 428
    part_set_signal(p, comp->nlb, 1, 1);
#line 429
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 431
  chain_shift_data_registers(chain___0, 0);
  }
#line 432
  return;
}
}
#line 439 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t___0 **comp ) 
{ 


  {
#line 442
  if (adr < (uint32_t )(1 << 19)) {
#line 443
    area->description = "RAMA Component";
#line 444
    area->start = (uint32_t )0;
#line 445
    area->length = (uint64_t )(1 << 19);
#line 446
    area->width = 16U;
#line 447
    *comp = & ((bus_params_t___14 *)bus___0->params)->rama;
  } else
#line 448
  if (adr < (uint32_t )(2 * (1 << 19))) {
#line 449
    area->description = "RAMB Component";
#line 450
    area->start = (uint32_t )(1 << 19);
#line 451
    area->length = (uint64_t )(1 << 19);
#line 452
    area->width = 16U;
#line 453
    *comp = & ((bus_params_t___14 *)bus___0->params)->ramb;
  } else
#line 454
  if (adr < (uint32_t )(2 * (1 << 19) + (1 << 19))) {
#line 455
    area->description = "FLASH Component";
#line 456
    area->start = (uint32_t )(2 * (1 << 19));
#line 457
    area->length = (uint64_t )(1 << 19);
#line 458
    area->width = 8U;
#line 459
    *comp = & ((bus_params_t___14 *)bus___0->params)->flash;
  } else {
#line 461
    area->description = "Dummy";
#line 462
    area->start = (uint32_t )(2 * (1 << 19) + (1 << 19));
#line 463
    area->length = 4294967296UL;
#line 464
    area->width = 0U;
#line 465
    *comp = (component_t___0 *)((void *)0);
  }
#line 468
  return (0);
}
}
#line 472 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static int jopcyc_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t___0 *comp ;
  int tmp ;

  {
  {
#line 477
  tmp = comp_bus_area___0(bus___0, adr, area, & comp);
  }
#line 477
  return (tmp);
}
}
#line 481 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static void jopcyc_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 484
  free(bus___0->params);
#line 485
  free((void *)bus___0);
  }
#line 486
  return;
}
}
#line 488 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static int attach_sig___0(bus_t *bus___0 , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;

  {
  {
#line 491
  failed = 0;
#line 493
  *sig = part_find_signal(((bus_params_t___14 *)bus___0->params)->part, (char const   *)id);
  }
#line 494
  if (! *sig) {
    {
#line 495
    tmp = gettext("signal \'%s\' not found\n");
#line 495
    printf((char const   */* __restrict  */)tmp, id);
#line 496
    failed = 1;
    }
  }
#line 499
  return (failed);
}
}
#line 502 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
static bus_t *jopcyc_bus_new(void) 
{ 
  bus_t *bus___0 ;
  int failed ;
  component_t___0 *comp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;

  {
#line 506
  failed = 0;
#line 509
  if (! chain) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if (! chain->parts) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if ((chain->parts)->len <= chain->active_part) {
#line 510
    return ((bus_t *)((void *)0));
  } else
#line 509
  if (chain->active_part < 0) {
#line 510
    return ((bus_t *)((void *)0));
  }
  {
#line 512
  tmp = malloc(sizeof(bus_t ));
#line 512
  bus___0 = (bus_t *)tmp;
  }
#line 513
  if (! bus___0) {
#line 514
    return ((bus_t *)((void *)0));
  }
  {
#line 516
  bus___0->driver = & jopcyc_bus;
#line 517
  bus___0->params = malloc(sizeof(bus_params_t___14 ));
  }
#line 518
  if (! bus___0->params) {
    {
#line 519
    free((void *)bus___0);
    }
#line 520
    return ((bus_t *)((void *)0));
  }
  {
#line 523
  ((bus_params_t___14 *)bus___0->params)->chain = chain;
#line 524
  ((bus_params_t___14 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 529
  comp = & ((bus_params_t___14 *)bus___0->params)->rama;
#line 530
  comp->ctype = (ctype_t )0;
#line 531
  comp->cname = (char *)"RAMA";
#line 533
  tmp___0 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO64");
#line 533
  failed |= tmp___0;
#line 534
  tmp___1 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO66");
#line 534
  failed |= tmp___1;
#line 535
  tmp___2 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO68");
#line 535
  failed |= tmp___2;
#line 536
  tmp___3 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO74");
#line 536
  failed |= tmp___3;
#line 537
  tmp___4 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO76");
#line 537
  failed |= tmp___4;
#line 538
  tmp___5 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO107");
#line 538
  failed |= tmp___5;
#line 539
  tmp___6 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO113");
#line 539
  failed |= tmp___6;
#line 540
  tmp___7 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO115");
#line 540
  failed |= tmp___7;
#line 541
  tmp___8 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO117");
#line 541
  failed |= tmp___8;
#line 542
  tmp___9 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO119");
#line 542
  failed |= tmp___9;
#line 543
  tmp___10 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO118");
#line 543
  failed |= tmp___10;
#line 544
  tmp___11 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO116");
#line 544
  failed |= tmp___11;
#line 545
  tmp___12 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO114");
#line 545
  failed |= tmp___12;
#line 546
  tmp___13 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO108");
#line 546
  failed |= tmp___13;
#line 547
  tmp___14 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO106");
#line 547
  failed |= tmp___14;
#line 548
  tmp___15 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO67");
#line 548
  failed |= tmp___15;
#line 549
  tmp___16 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO65");
#line 549
  failed |= tmp___16;
#line 550
  tmp___17 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO63");
#line 550
  failed |= tmp___17;
#line 551
  comp->a[18] = (signal_t *)((void *)0);
#line 553
  tmp___18 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO82");
#line 553
  failed |= tmp___18;
#line 554
  tmp___19 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO84");
#line 554
  failed |= tmp___19;
#line 555
  tmp___20 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO86");
#line 555
  failed |= tmp___20;
#line 556
  tmp___21 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO88");
#line 556
  failed |= tmp___21;
#line 557
  tmp___22 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO94");
#line 557
  failed |= tmp___22;
#line 558
  tmp___23 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO98");
#line 558
  failed |= tmp___23;
#line 559
  tmp___24 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO100");
#line 559
  failed |= tmp___24;
#line 560
  tmp___25 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO104");
#line 560
  failed |= tmp___25;
#line 561
  tmp___26 = attach_sig___0(bus___0, & comp->d[8], (char *)"IO101");
#line 561
  failed |= tmp___26;
#line 562
  tmp___27 = attach_sig___0(bus___0, & comp->d[9], (char *)"IO99");
#line 562
  failed |= tmp___27;
#line 563
  tmp___28 = attach_sig___0(bus___0, & comp->d[10], (char *)"IO95");
#line 563
  failed |= tmp___28;
#line 564
  tmp___29 = attach_sig___0(bus___0, & comp->d[11], (char *)"IO93");
#line 564
  failed |= tmp___29;
#line 565
  tmp___30 = attach_sig___0(bus___0, & comp->d[12], (char *)"IO87");
#line 565
  failed |= tmp___30;
#line 566
  tmp___31 = attach_sig___0(bus___0, & comp->d[13], (char *)"IO85");
#line 566
  failed |= tmp___31;
#line 567
  tmp___32 = attach_sig___0(bus___0, & comp->d[14], (char *)"IO83");
#line 567
  failed |= tmp___32;
#line 568
  tmp___33 = attach_sig___0(bus___0, & comp->d[15], (char *)"IO79");
#line 568
  failed |= tmp___33;
#line 570
  tmp___34 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO78");
#line 570
  failed |= tmp___34;
#line 571
  tmp___35 = attach_sig___0(bus___0, & comp->noe, (char *)"IO73");
#line 571
  failed |= tmp___35;
#line 572
  tmp___36 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO105");
#line 572
  failed |= tmp___36;
#line 573
  tmp___37 = attach_sig___0(bus___0, & comp->nlb, (char *)"IO77");
#line 573
  failed |= tmp___37;
#line 574
  tmp___38 = attach_sig___0(bus___0, & comp->nub, (char *)"IO75");
#line 574
  failed |= tmp___38;
#line 575
  comp->ncs2 = (signal_t *)((void *)0);
#line 576
  comp->nrdy = (signal_t *)((void *)0);
#line 581
  comp = & ((bus_params_t___14 *)bus___0->params)->ramb;
#line 582
  comp->ctype = (ctype_t )0;
#line 583
  comp->cname = (char *)"RAMB";
#line 585
  tmp___39 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO237");
#line 585
  failed |= tmp___39;
#line 586
  tmp___40 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO235");
#line 586
  failed |= tmp___40;
#line 587
  tmp___41 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO233");
#line 587
  failed |= tmp___41;
#line 588
  tmp___42 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO227");
#line 588
  failed |= tmp___42;
#line 589
  tmp___43 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO225");
#line 589
  failed |= tmp___43;
#line 590
  tmp___44 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO194");
#line 590
  failed |= tmp___44;
#line 591
  tmp___45 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO188");
#line 591
  failed |= tmp___45;
#line 592
  tmp___46 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO186");
#line 592
  failed |= tmp___46;
#line 593
  tmp___47 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO184");
#line 593
  failed |= tmp___47;
#line 594
  tmp___48 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO182");
#line 594
  failed |= tmp___48;
#line 595
  tmp___49 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO183");
#line 595
  failed |= tmp___49;
#line 596
  tmp___50 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO185");
#line 596
  failed |= tmp___50;
#line 597
  tmp___51 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO187");
#line 597
  failed |= tmp___51;
#line 598
  tmp___52 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO193");
#line 598
  failed |= tmp___52;
#line 599
  tmp___53 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO195");
#line 599
  failed |= tmp___53;
#line 600
  tmp___54 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO234");
#line 600
  failed |= tmp___54;
#line 601
  tmp___55 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO236");
#line 601
  failed |= tmp___55;
#line 602
  tmp___56 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO238");
#line 602
  failed |= tmp___56;
#line 603
  comp->a[18] = (signal_t *)((void *)0);
#line 605
  tmp___57 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO219");
#line 605
  failed |= tmp___57;
#line 606
  tmp___58 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO217");
#line 606
  failed |= tmp___58;
#line 607
  tmp___59 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO215");
#line 607
  failed |= tmp___59;
#line 608
  tmp___60 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO213");
#line 608
  failed |= tmp___60;
#line 609
  tmp___61 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO207");
#line 609
  failed |= tmp___61;
#line 610
  tmp___62 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO203");
#line 610
  failed |= tmp___62;
#line 611
  tmp___63 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO201");
#line 611
  failed |= tmp___63;
#line 612
  tmp___64 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO197");
#line 612
  failed |= tmp___64;
#line 613
  tmp___65 = attach_sig___0(bus___0, & comp->d[8], (char *)"IO200");
#line 613
  failed |= tmp___65;
#line 614
  tmp___66 = attach_sig___0(bus___0, & comp->d[9], (char *)"IO202");
#line 614
  failed |= tmp___66;
#line 615
  tmp___67 = attach_sig___0(bus___0, & comp->d[10], (char *)"IO206");
#line 615
  failed |= tmp___67;
#line 616
  tmp___68 = attach_sig___0(bus___0, & comp->d[11], (char *)"IO208");
#line 616
  failed |= tmp___68;
#line 617
  tmp___69 = attach_sig___0(bus___0, & comp->d[12], (char *)"IO214");
#line 617
  failed |= tmp___69;
#line 618
  tmp___70 = attach_sig___0(bus___0, & comp->d[13], (char *)"IO216");
#line 618
  failed |= tmp___70;
#line 619
  tmp___71 = attach_sig___0(bus___0, & comp->d[14], (char *)"IO218");
#line 619
  failed |= tmp___71;
#line 620
  tmp___72 = attach_sig___0(bus___0, & comp->d[15], (char *)"IO222");
#line 620
  failed |= tmp___72;
#line 622
  tmp___73 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO223");
#line 622
  failed |= tmp___73;
#line 623
  tmp___74 = attach_sig___0(bus___0, & comp->noe, (char *)"IO228");
#line 623
  failed |= tmp___74;
#line 624
  tmp___75 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO196");
#line 624
  failed |= tmp___75;
#line 625
  tmp___76 = attach_sig___0(bus___0, & comp->nlb, (char *)"IO224");
#line 625
  failed |= tmp___76;
#line 626
  tmp___77 = attach_sig___0(bus___0, & comp->nub, (char *)"IO226");
#line 626
  failed |= tmp___77;
#line 627
  comp->ncs2 = (signal_t *)((void *)0);
#line 628
  comp->nrdy = (signal_t *)((void *)0);
#line 633
  comp = & ((bus_params_t___14 *)bus___0->params)->flash;
#line 634
  comp->ctype = (ctype_t )1;
#line 635
  comp->cname = (char *)"FLASH";
#line 637
  tmp___78 = attach_sig___0(bus___0, & comp->a[0], (char *)"IO47");
#line 637
  failed |= tmp___78;
#line 638
  tmp___79 = attach_sig___0(bus___0, & comp->a[1], (char *)"IO48");
#line 638
  failed |= tmp___79;
#line 639
  tmp___80 = attach_sig___0(bus___0, & comp->a[2], (char *)"IO49");
#line 639
  failed |= tmp___80;
#line 640
  tmp___81 = attach_sig___0(bus___0, & comp->a[3], (char *)"IO50");
#line 640
  failed |= tmp___81;
#line 641
  tmp___82 = attach_sig___0(bus___0, & comp->a[4], (char *)"IO125");
#line 641
  failed |= tmp___82;
#line 642
  tmp___83 = attach_sig___0(bus___0, & comp->a[5], (char *)"IO127");
#line 642
  failed |= tmp___83;
#line 643
  tmp___84 = attach_sig___0(bus___0, & comp->a[6], (char *)"IO131");
#line 643
  failed |= tmp___84;
#line 644
  tmp___85 = attach_sig___0(bus___0, & comp->a[7], (char *)"IO133");
#line 644
  failed |= tmp___85;
#line 645
  tmp___86 = attach_sig___0(bus___0, & comp->a[8], (char *)"IO158");
#line 645
  failed |= tmp___86;
#line 646
  tmp___87 = attach_sig___0(bus___0, & comp->a[9], (char *)"IO16");
#line 646
  failed |= tmp___87;
#line 647
  tmp___88 = attach_sig___0(bus___0, & comp->a[10], (char *)"IO20");
#line 647
  failed |= tmp___88;
#line 648
  tmp___89 = attach_sig___0(bus___0, & comp->a[11], (char *)"IO14");
#line 648
  failed |= tmp___89;
#line 649
  tmp___90 = attach_sig___0(bus___0, & comp->a[12], (char *)"IO135");
#line 649
  failed |= tmp___90;
#line 650
  tmp___91 = attach_sig___0(bus___0, & comp->a[13], (char *)"IO156");
#line 650
  failed |= tmp___91;
#line 651
  tmp___92 = attach_sig___0(bus___0, & comp->a[14], (char *)"IO144");
#line 651
  failed |= tmp___92;
#line 652
  tmp___93 = attach_sig___0(bus___0, & comp->a[15], (char *)"IO137");
#line 652
  failed |= tmp___93;
#line 653
  tmp___94 = attach_sig___0(bus___0, & comp->a[16], (char *)"IO139");
#line 653
  failed |= tmp___94;
#line 654
  tmp___95 = attach_sig___0(bus___0, & comp->a[17], (char *)"IO143");
#line 654
  failed |= tmp___95;
#line 655
  tmp___96 = attach_sig___0(bus___0, & comp->a[18], (char *)"IO141");
#line 655
  failed |= tmp___96;
#line 657
  tmp___97 = attach_sig___0(bus___0, & comp->d[0], (char *)"IO46");
#line 657
  failed |= tmp___97;
#line 658
  tmp___98 = attach_sig___0(bus___0, & comp->d[1], (char *)"IO45");
#line 658
  failed |= tmp___98;
#line 659
  tmp___99 = attach_sig___0(bus___0, & comp->d[2], (char *)"IO44");
#line 659
  failed |= tmp___99;
#line 660
  tmp___100 = attach_sig___0(bus___0, & comp->d[3], (char *)"IO165");
#line 660
  failed |= tmp___100;
#line 661
  tmp___101 = attach_sig___0(bus___0, & comp->d[4], (char *)"IO164");
#line 661
  failed |= tmp___101;
#line 662
  tmp___102 = attach_sig___0(bus___0, & comp->d[5], (char *)"IO17");
#line 662
  failed |= tmp___102;
#line 663
  tmp___103 = attach_sig___0(bus___0, & comp->d[6], (char *)"IO18");
#line 663
  failed |= tmp___103;
#line 664
  tmp___104 = attach_sig___0(bus___0, & comp->d[7], (char *)"IO19");
#line 664
  failed |= tmp___104;
#line 665
  comp->d[8] = (signal_t *)((void *)0);
#line 666
  comp->d[9] = (signal_t *)((void *)0);
#line 667
  comp->d[10] = (signal_t *)((void *)0);
#line 668
  comp->d[11] = (signal_t *)((void *)0);
#line 669
  comp->d[12] = (signal_t *)((void *)0);
#line 670
  comp->d[13] = (signal_t *)((void *)0);
#line 671
  comp->d[14] = (signal_t *)((void *)0);
#line 672
  comp->d[15] = (signal_t *)((void *)0);
#line 674
  tmp___105 = attach_sig___0(bus___0, & comp->nwe, (char *)"IO15");
#line 674
  failed |= tmp___105;
#line 675
  tmp___106 = attach_sig___0(bus___0, & comp->noe, (char *)"IO24");
#line 675
  failed |= tmp___106;
#line 676
  tmp___107 = attach_sig___0(bus___0, & comp->ncs, (char *)"IO37");
#line 676
  failed |= tmp___107;
#line 677
  tmp___108 = attach_sig___0(bus___0, & comp->ncs2, (char *)"IO23");
#line 677
  failed |= tmp___108;
#line 682
  comp->nrdy = (signal_t *)((void *)0);
#line 684
  comp->nlb = (signal_t *)((void *)0);
#line 685
  comp->nub = (signal_t *)((void *)0);
#line 690
  tmp___109 = attach_sig___0(bus___0, & ((bus_params_t___14 *)bus___0->params)->ser_rxd,
                             (char *)"CLK2");
#line 690
  failed |= tmp___109;
#line 691
  tmp___110 = attach_sig___0(bus___0, & ((bus_params_t___14 *)bus___0->params)->ser_nrts,
                             (char *)"IO177");
#line 691
  failed |= tmp___110;
#line 692
  tmp___111 = attach_sig___0(bus___0, & ((bus_params_t___14 *)bus___0->params)->ser_txd,
                             (char *)"IO178");
#line 692
  failed |= tmp___111;
#line 693
  tmp___112 = attach_sig___0(bus___0, & ((bus_params_t___14 *)bus___0->params)->ser_ncts,
                             (char *)"CLK0");
#line 693
  failed |= tmp___112;
  }
#line 695
  if (failed) {
    {
#line 696
    free(bus___0->params);
#line 697
    free((void *)bus___0);
    }
#line 698
    return ((bus_t *)((void *)0));
  }
#line 701
  return (bus___0);
}
}
#line 704 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/jopcyc.c"
struct bus_driver  const  jopcyc_bus  = 
#line 704
     {"jopcyc", "JOP.design Cyclone Board compatible bus driver via BSR", & jopcyc_bus_new,
    & jopcyc_bus_free, & jopcyc_bus_printinfo, & jopcyc_bus_prepare, & jopcyc_bus_area,
    & jopcyc_bus_read_start, & jopcyc_bus_read_next, & jopcyc_bus_read_end, & jopcyc_bus_read,
    & jopcyc_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  ixp425_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void select_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 60
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 62
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[0], 1, 0);
#line 63
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[1], 1, 1);
#line 64
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[2], 1, 1);
#line 65
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[3], 1, 1);
#line 66
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[4], 1, 1);
#line 67
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[5], 1, 1);
#line 68
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[6], 1, 1);
#line 69
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 70
  return;
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void unselect_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 75
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 77
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[0], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[1], 1, 1);
#line 79
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[2], 1, 1);
#line 80
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[3], 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[4], 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[5], 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[6], 1, 1);
#line 84
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void setup_address___15(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 91
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 24)) {
#line 93
      goto while_break;
    }
    {
#line 94
    part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_addr[i], 1, (int )((a >> i) & 1U));
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void set_data_in___15(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 101
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 16)) {
#line 103
      goto while_break;
    }
    {
#line 104
    part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_data[i], 0, 0);
#line 103
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void setup_data___15(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 111
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < 16)) {
#line 113
      goto while_break;
    }
    {
#line 114
    part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_data[i], 1, (int )((d >> i) & 1U));
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void ixp425_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < ((((bus_params_t___15 *)bus___0->params)->chain)->parts)->len)) {
#line 122
      goto while_break;
    }
#line 123
    if ((unsigned long )((bus_params_t___15 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___15 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 124
      goto while_break;
    }
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp = gettext("Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 125
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 126
  return;
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void ixp425_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 131
  part_set_instruction(((bus_params_t___15 *)bus___0->params)->part, "EXTEST");
#line 132
  chain_shift_instructions(((bus_params_t___15 *)bus___0->params)->chain);
  }
#line 133
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void ixp425_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 138
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 139
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 141
  select_flash___0(bus___0);
#line 142
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_rd, 1, 0);
#line 143
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_wr, 1, 1);
#line 145
  setup_address___15(bus___0, adr);
#line 146
  set_data_in___15(bus___0);
#line 148
  chain_shift_data_registers(chain___0, 0);
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 154
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 155
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 157
  d = (uint32_t )0;
#line 159
  setup_address___15(bus___0, adr);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < 16)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = part_get_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_data[i]);
#line 163
    d |= (uint32_t )(tmp << i);
#line 162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (d);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 171
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 172
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 174
  d = (uint32_t )0;
#line 176
  unselect_flash___0(bus___0);
#line 177
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_rd, 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_wr, 1, 1);
#line 180
  chain_shift_data_registers(chain___0, 1);
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 16)) {
#line 182
      goto while_break;
    }
    {
#line 183
    tmp = part_get_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_data[i]);
#line 183
    d |= (uint32_t )(tmp << i);
#line 182
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (d);
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static uint32_t ixp425_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 191
  ixp425_bus_read_start(bus___0, adr);
#line 192
  tmp = ixp425_bus_read_end(bus___0);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void ixp425_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 198
  p = ((bus_params_t___15 *)bus___0->params)->part;
#line 199
  chain___0 = ((bus_params_t___15 *)bus___0->params)->chain;
#line 201
  select_flash___0(bus___0);
#line 202
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_rd, 1, 1);
#line 204
  setup_address___15(bus___0, adr);
#line 205
  setup_data___15(bus___0, data);
#line 207
  chain_shift_data_registers(chain___0, 0);
#line 209
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_wr, 1, 0);
#line 210
  chain_shift_data_registers(chain___0, 0);
#line 211
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ex_wr, 1, 1);
#line 212
  unselect_flash___0(bus___0);
#line 213
  chain_shift_data_registers(chain___0, 0);
  }
#line 214
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static int ixp425_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 219
  area->description = (char const   *)((void *)0);
#line 220
  area->start = 0U;
#line 221
  area->length = 4294967296UL;
#line 222
  area->width = 16U;
#line 224
  return (0);
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static void ixp425_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 230
  free(bus___0->params);
#line 231
  free((void *)bus___0);
  }
#line 232
  return;
}
}
#line 234
static bus_t *ixp425_bus_new(void) ;
#line 236 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
struct bus_driver  const  ixp425_bus  = 
#line 236
     {"ixp425", "Intel IXP425 compatible bus driver via BSR", & ixp425_bus_new, & ixp425_bus_free,
    & ixp425_bus_printinfo, & ixp425_bus_prepare, & ixp425_bus_area, & ixp425_bus_read_start,
    & ixp425_bus_read_next, & ixp425_bus_read_end, & ixp425_bus_read, & ixp425_bus_write,
    (int (*)(bus_t *bus ))((void *)0)};
#line 252 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ixp425.c"
static bus_t *ixp425_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 258
  failed = 0;
#line 260
  if (! chain) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if (! chain->parts) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if ((chain->parts)->len <= chain->active_part) {
#line 261
    return ((bus_t *)((void *)0));
  } else
#line 260
  if (chain->active_part < 0) {
#line 261
    return ((bus_t *)((void *)0));
  }
  {
#line 263
  tmp = malloc(sizeof(bus_t ));
#line 263
  bus___0 = (bus_t *)tmp;
  }
#line 264
  if (! bus___0) {
#line 265
    return ((bus_t *)((void *)0));
  }
  {
#line 267
  bus___0->driver = & ixp425_bus;
#line 268
  bus___0->params = malloc(sizeof(bus_params_t___15 ));
  }
#line 269
  if (! bus___0->params) {
    {
#line 270
    free((void *)bus___0);
    }
#line 271
    return ((bus_t *)((void *)0));
  }
#line 274
  ((bus_params_t___15 *)bus___0->params)->chain = chain;
#line 275
  ((bus_params_t___15 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < 8)) {
#line 277
      goto while_break;
    }
    {
#line 278
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_CS[%d]",
            i);
#line 279
    ((bus_params_t___15 *)bus___0->params)->ex_cs[i] = part_find_signal(((bus_params_t___15 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 280
    if (! ((bus_params_t___15 *)bus___0->params)->ex_cs[i]) {
      {
#line 281
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 281
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 282
      failed = 1;
      }
#line 283
      goto while_break;
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    if (! (i < 24)) {
#line 286
      goto while_break___0;
    }
    {
#line 287
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_ADDR[%d]",
            i);
#line 288
    ((bus_params_t___15 *)bus___0->params)->ex_addr[i] = part_find_signal(((bus_params_t___15 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 289
    if (! ((bus_params_t___15 *)bus___0->params)->ex_addr[i]) {
      {
#line 290
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 290
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 291
      failed = 1;
      }
#line 292
      goto while_break___0;
    }
#line 286
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 295
    if (! (i < 16)) {
#line 295
      goto while_break___1;
    }
    {
#line 296
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_DATA[%d]",
            i);
#line 297
    ((bus_params_t___15 *)bus___0->params)->ex_data[i] = part_find_signal(((bus_params_t___15 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 298
    if (! ((bus_params_t___15 *)bus___0->params)->ex_data[i]) {
      {
#line 299
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 299
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 300
      failed = 1;
      }
#line 301
      goto while_break___1;
    }
#line 295
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 304
  ((bus_params_t___15 *)bus___0->params)->ex_wr = part_find_signal(((bus_params_t___15 *)bus___0->params)->part,
                                                                   "EX_WR");
  }
#line 305
  if (! ((bus_params_t___15 *)bus___0->params)->ex_wr) {
    {
#line 306
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 306
    printf((char const   */* __restrict  */)tmp___3, "EX_WR");
#line 307
    failed = 1;
    }
  }
  {
#line 309
  ((bus_params_t___15 *)bus___0->params)->ex_rd = part_find_signal(((bus_params_t___15 *)bus___0->params)->part,
                                                                   "EX_RD");
  }
#line 310
  if (! ((bus_params_t___15 *)bus___0->params)->ex_rd) {
    {
#line 311
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 311
    printf((char const   */* __restrict  */)tmp___4, "EX_RD");
#line 312
    failed = 1;
    }
  }
#line 315
  if (failed) {
    {
#line 316
    free(bus___0->params);
#line 317
    free((void *)bus___0);
    }
#line 318
    return ((bus_t *)((void *)0));
  }
#line 321
  return (bus___0);
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  h7202_bus ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void setup_address___16(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 61
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 26)) {
#line 63
      goto while_break;
    }
    {
#line 64
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void set_data_in___16(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 73
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 76
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned int )i < area.width)) {
#line 78
      goto while_break;
    }
    {
#line 79
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->d[i], 0, 0);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void setup_data___16(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 86
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 89
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )i < area.width)) {
#line 91
      goto while_break;
    }
    {
#line 92
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void h7202_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < ((((bus_params_t___16 *)bus___0->params)->chain)->parts)->len)) {
#line 100
      goto while_break;
    }
#line 101
    if ((unsigned long )((bus_params_t___16 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___16 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 102
      goto while_break;
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  printf((char const   */* __restrict  */)"H7202 compatible bus driver via BSR (JTAG part No. %d)\n",
         i);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void h7202_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 109
  part_set_instruction(((bus_params_t___16 *)bus___0->params)->part, "EXTEST");
#line 110
  chain_shift_instructions(((bus_params_t___16 *)bus___0->params)->chain);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void h7202_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 117
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 118
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 120
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[0], 1, 0);
#line 121
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[1], 1, 1);
#line 122
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[2], 1, 1);
#line 123
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[3], 1, 1);
#line 124
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[0], 1, 1);
#line 125
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nROE, 1, 0);
#line 127
  setup_address___16(bus___0, adr);
#line 128
  set_data_in___16(bus___0);
#line 130
  chain_shift_data_registers(chain___0, 0);
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static uint32_t h7202_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 137
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 138
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 140
  d = (uint32_t )0;
#line 143
  h7202_bus_area(bus___0, adr, & area);
#line 145
  setup_address___16(bus___0, adr);
#line 146
  chain_shift_data_registers(chain___0, 1);
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned int )i < area.width)) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->d[i]);
#line 149
    d |= (uint32_t )(tmp << i);
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (d);
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static uint32_t h7202_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 158
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 159
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 161
  d = (uint32_t )0;
#line 164
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 166
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[0], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[1], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[2], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[3], 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nROE, 1, 1);
#line 171
  chain_shift_data_registers(chain___0, 1);
#line 173
  i = 0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! ((unsigned int )i < area.width)) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->d[i]);
#line 174
    d |= (uint32_t )(tmp << i);
#line 173
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (d);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static uint32_t h7202_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 182
  h7202_bus_read_start(bus___0, adr);
#line 183
  tmp = h7202_bus_read_end(bus___0);
  }
#line 183
  return (tmp);
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void h7202_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 190
  p = ((bus_params_t___16 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___16 *)bus___0->params)->chain;
#line 197
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[0], 1, 0);
#line 198
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[1], 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[2], 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[3], 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[0], 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[1], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[2], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[3], 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nROE, 1, 1);
#line 208
  setup_address___16(bus___0, adr);
#line 209
  setup_data___16(bus___0, data);
#line 211
  chain_shift_data_registers(chain___0, 0);
#line 213
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRWE[0], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[0], 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[1], 1, 1);
#line 216
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[2], 1, 1);
#line 217
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->nRCS[3], 1, 1);
#line 218
  chain_shift_data_registers(chain___0, 0);
  }
#line 219
  return;
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 224
  area->description = (char const   *)((void *)0);
#line 225
  area->start = 0U;
#line 226
  area->length = 4294967296UL;
#line 227
  area->width = 16U;
#line 229
  return (0);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static void h7202_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 235
  free(bus___0->params);
#line 236
  free((void *)bus___0);
  }
#line 237
  return;
}
}
#line 239
static bus_t *h7202_bus_new(void) ;
#line 241 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
struct bus_driver  const  h7202_bus  = 
#line 241
     {"h7202", "H7202 compatible bus driver via BSR", & h7202_bus_new, & h7202_bus_free,
    & h7202_bus_printinfo, & h7202_bus_prepare, & h7202_bus_area, & h7202_bus_read_start,
    & h7202_bus_read_next, & h7202_bus_read_end, & h7202_bus_read, & h7202_bus_write,
    (int (*)(bus_t *bus ))0};
#line 256 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/h7202.c"
static bus_t *h7202_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;

  {
#line 262
  failed = 0;
#line 264
  if (! chain) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if (! chain->parts) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if ((chain->parts)->len <= chain->active_part) {
#line 265
    return ((bus_t *)((void *)0));
  } else
#line 264
  if (chain->active_part < 0) {
#line 265
    return ((bus_t *)((void *)0));
  }
  {
#line 267
  tmp = malloc(sizeof(bus_t ));
#line 267
  bus___0 = (bus_t *)tmp;
  }
#line 268
  if (! bus___0) {
#line 269
    return ((bus_t *)((void *)0));
  }
  {
#line 271
  bus___0->driver = & h7202_bus;
#line 272
  bus___0->params = malloc(sizeof(bus_params_t___16 ));
  }
#line 273
  if (! bus___0->params) {
    {
#line 274
    free((void *)bus___0);
    }
#line 275
    return ((bus_t *)((void *)0));
  }
#line 278
  ((bus_params_t___16 *)bus___0->params)->chain = chain;
#line 279
  ((bus_params_t___16 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (i < 25)) {
#line 281
      goto while_break;
    }
    {
#line 282
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RA%d",
            i);
#line 283
    ((bus_params_t___16 *)bus___0->params)->a[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 284
    if (! ((bus_params_t___16 *)bus___0->params)->a[i]) {
      {
#line 285
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 286
      failed = 1;
      }
#line 287
      goto while_break;
    }
#line 281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (i < 32)) {
#line 290
      goto while_break___0;
    }
    {
#line 291
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 292
    ((bus_params_t___16 *)bus___0->params)->d[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                    (char const   *)(buff));
    }
#line 293
    if (! ((bus_params_t___16 *)bus___0->params)->d[i]) {
      {
#line 294
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 295
      failed = 1;
      }
#line 296
      goto while_break___0;
    }
#line 290
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 299
    if (! (i < 4)) {
#line 299
      goto while_break___1;
    }
    {
#line 300
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 301
    ((bus_params_t___16 *)bus___0->params)->nRCS[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 302
    if (! ((bus_params_t___16 *)bus___0->params)->nRCS[i]) {
      {
#line 303
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 304
      failed = 1;
      }
#line 305
      goto while_break___1;
    }
#line 299
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 308
  ((bus_params_t___16 *)bus___0->params)->nROE = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                  "nROE");
  }
#line 309
  if (! ((bus_params_t___16 *)bus___0->params)->nROE) {
    {
#line 310
    printf((char const   */* __restrict  */)"signal \'%s\' not found\n", "nROE");
#line 311
    failed = 1;
    }
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 314
    if (! (i < 4)) {
#line 314
      goto while_break___2;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRWE%d",
            i);
#line 316
    ((bus_params_t___16 *)bus___0->params)->nRWE[i] = part_find_signal(((bus_params_t___16 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___16 *)bus___0->params)->nRWE[i]) {
      {
#line 318
      printf((char const   */* __restrict  */)"signal \'%s\' not found\n", buff);
#line 319
      failed = 1;
      }
    }
#line 314
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 323
  if (failed) {
    {
#line 324
    free(bus___0->params);
#line 325
    free((void *)bus___0);
    }
#line 326
    return ((bus_t *)((void *)0));
  }
#line 329
  return (bus___0);
}
}
#line 38 "../../include/register.h"
tap_register *register_fill(tap_register *tr , int val ) ;
#line 70 "../../inclow/brux/bus.h"
bus_t *bus ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  ejtag_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < ((((bus_params_t___17 *)bus___0->params)->chain)->parts)->len)) {
#line 69
      goto while_break;
    }
#line 70
    if ((unsigned long )((bus_params_t___17 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___17 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 71
      goto while_break;
    }
#line 69
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  tmp = gettext("EJTAG compatible bus driver via PrAcc (JTAG part No. %d)\n");
#line 72
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 73
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t reg_value(tap_register *reg ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 91
  retval = (uint32_t )0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < reg->len)) {
#line 94
      goto while_break;
    }
#line 95
    if (*(reg->data + i)) {
#line 96
      retval |= (unsigned int )(1 << i);
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (retval);
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t ejtag_run_pracc(bus_t *bus___0 , uint32_t const   *code___0 , unsigned int len ) 
{ 
  data_register *ejaddr ;
  data_register *ejdata ;
  data_register *ejctrl ;
  int i ;
  int pass ;
  uint32_t addr ;
  uint32_t data ;
  uint32_t retval ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 108
  ejaddr = part_find_data_register(((bus_params_t___17 *)bus___0->params)->part, "EJADDRESS");
#line 109
  ejdata = part_find_data_register(((bus_params_t___17 *)bus___0->params)->part, "EJDATA");
#line 110
  ejctrl = part_find_data_register(((bus_params_t___17 *)bus___0->params)->part, "EJCONTROL");
  }
#line 111
  if (ejaddr) {
#line 111
    if (ejdata) {
#line 111
      if (! ejctrl) {
        {
#line 112
        tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
        printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
               113);
        }
#line 114
        return ((uint32_t )0);
      }
    } else {
      {
#line 112
      tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
             113);
      }
#line 114
      return ((uint32_t )0);
    }
  } else {
    {
#line 112
    tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 112
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
           113);
    }
#line 114
    return ((uint32_t )0);
  }
  {
#line 117
  part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 118
  chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 120
  pass = 0;
#line 121
  retval = (uint32_t )0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    *((ejctrl->in)->data + 18) = (char)1;
#line 125
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 126
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
    }
#line 130
    if (*((ejctrl->out)->data + 31)) {
      {
#line 131
      tmp___0 = register_get_string((tap_register const   *)ejctrl->out);
#line 131
      tmp___1 = gettext("%s(%d) Reset occurred, ctrl=%s\n");
#line 131
      printf((char const   */* __restrict  */)tmp___1, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
             132, tmp___0);
#line 134
      ((bus_params_t___17 *)bus___0->params)->initialized = 0;
      }
#line 135
      goto while_break;
    }
#line 137
    if (! *((ejctrl->out)->data + 18)) {
      {
#line 138
      tmp___2 = register_get_string((tap_register const   *)ejctrl->out);
#line 138
      tmp___3 = gettext("%s(%d) No processor access, ctrl=%s\n");
#line 138
      printf((char const   */* __restrict  */)tmp___3, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
             139, tmp___2);
#line 141
      ((bus_params_t___17 *)bus___0->params)->initialized = 0;
      }
#line 142
      goto while_break;
    }
    {
#line 145
    part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_ADDRESS");
#line 146
    chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 148
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
#line 149
    addr = reg_value(ejaddr->out);
    }
#line 150
    if (addr & 3U) {
      {
#line 151
      tmp___4 = gettext("%s(%d) PrAcc bad alignment: addr=0x%08x\n");
#line 151
      printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
             152, addr);
#line 153
      addr &= 4294967292U;
      }
    }
    {
#line 156
    part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_DATA");
#line 157
    chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 159
    register_fill(ejdata->in, 0);
    }
#line 161
    if (*((ejctrl->out)->data + 19)) {
      {
#line 162
      chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
#line 163
      data = reg_value(ejdata->out);
      }
#line 168
      if (addr == 4280287232U) {
#line 170
        retval = data;
      } else {
        {
#line 172
        tmp___5 = gettext("%s(%d) Unknown write addr=0x%08x data=0x%08x\n");
#line 172
        printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
               173, addr, data);
        }
      }
    } else {
#line 176
      if (addr == 4280287744U) {
#line 176
        tmp___6 = pass;
#line 176
        pass ++;
#line 176
        if (tmp___6) {
#line 177
          goto while_break;
        }
      }
#line 179
      data = (uint32_t )0;
#line 180
      if (addr >= 4280287744U) {
#line 180
        if (addr < 4280287744U + (len << 2)) {
#line 181
          data = (uint32_t )*(code___0 + ((addr - 4280287744U) >> 2));
#line 183
          i = 0;
          {
#line 183
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 183
            if (! (i < 32)) {
#line 183
              goto while_break___0;
            }
#line 184
            *((ejdata->in)->data + i) = (char )((data >> i) & 1U);
#line 183
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 190
      chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
      }
    }
    {
#line 193
    part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 194
    chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 196
    *((ejctrl->in)->data + 18) = (char)0;
#line 197
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (retval);
}
}
#line 202 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_init(bus_t *bus___0 ) 
{ 
  data_register *ejctrl ;
  data_register *ejimpl ;
  uint32_t code___0[4] ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 206
  code___0[0] = (uint32_t )1006960416;
#line 206
  code___0[1] = (uint32_t )882835968;
#line 206
  code___0[2] = (uint32_t )65011720;
#line 206
  code___0[3] = (uint32_t )1006829568;
#line 213
  ejctrl = part_find_data_register(((bus_params_t___17 *)bus___0->params)->part, "EJCONTROL");
#line 214
  ejimpl = part_find_data_register(((bus_params_t___17 *)bus___0->params)->part, "EJIMPCODE");
  }
#line 215
  if (ejctrl) {
#line 215
    if (! ejimpl) {
      {
#line 216
      tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 216
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
             217);
      }
#line 218
      return;
    }
  } else {
    {
#line 216
    tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 216
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
           217);
    }
#line 218
    return;
  }
  {
#line 221
  part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_IMPCODE");
#line 222
  chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 223
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 224
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
#line 225
  tmp___0 = register_get_string((tap_register const   *)ejimpl->out);
#line 225
  printf((char const   */* __restrict  */)"ImpCode=%s\n", tmp___0);
#line 226
  ((bus_params_t___17 *)bus___0->params)->impcode = reg_value(ejimpl->out);
  }
  {
#line 229
  if (((((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
#line 229
    goto case_0;
  }
#line 230
  if (((((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U) == 1U) {
#line 230
    goto case_1;
  }
#line 231
  if (((((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U) == 2U) {
#line 231
    goto case_2;
  }
#line 232
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 229
  printf((char const   */* __restrict  */)"EJTAG version: <= 2.0\n");
  }
#line 229
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 230
  printf((char const   */* __restrict  */)"EJTAG version: 2.5\n");
  }
#line 230
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 231
  printf((char const   */* __restrict  */)"EJTAG version: 2.6\n");
  }
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 233
  printf((char const   */* __restrict  */)"EJTAG version: unknown (%d)\n", (((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U);
  }
  switch_break: /* CIL Label */ ;
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & 1U) {
#line 235
    tmp___1 = " MIPS64";
  } else {
#line 235
    tmp___1 = " MIPS32";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
#line 235
    tmp___2 = " NoDMA";
  } else {
#line 235
    tmp___2 = "";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 16)) {
#line 235
    tmp___3 = " MIPS16";
  } else {
#line 235
    tmp___3 = "";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 21)) {
#line 235
    tmp___4 = " ASID_6";
  } else {
#line 235
    tmp___4 = "";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 22)) {
#line 235
    tmp___5 = " ASID_8";
  } else {
#line 235
    tmp___5 = "";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 24)) {
#line 235
    tmp___6 = " DINTsup";
  } else {
#line 235
    tmp___6 = "";
  }
#line 235
  if (((bus_params_t___17 *)bus___0->params)->impcode & (unsigned int )(1 << 28)) {
#line 235
    tmp___7 = " R3k";
  } else {
#line 235
    tmp___7 = " R4k";
  }
  {
#line 235
  printf((char const   */* __restrict  */)"EJTAG Implementation flags:%s%s%s%s%s%s%s\n",
         tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
  }
#line 244
  if (((((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
    {
#line 245
    part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAGBOOT");
#line 246
    chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
    }
  }
  {
#line 249
  part_set_instruction(((bus_params_t___17 *)bus___0->params)->part, "EJTAG_CONTROL");
#line 250
  chain_shift_instructions(((bus_params_t___17 *)bus___0->params)->chain);
#line 252
  register_fill(ejctrl->in, 0);
#line 254
  *((ejctrl->in)->data + 16) = (char)1;
#line 255
  *((ejctrl->in)->data + 20) = (char)1;
#line 256
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 258
  *((ejctrl->in)->data + 16) = (char)0;
#line 259
  *((ejctrl->in)->data + 20) = (char)0;
#line 260
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 262
  *((ejctrl->in)->data + 18) = (char)1;
#line 263
  *((ejctrl->in)->data + 15) = (char)1;
  }
#line 264
  if (((((bus_params_t___17 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
#line 265
    *((ejctrl->in)->data + 14) = (char)1;
#line 266
    *((ejctrl->in)->data + 31) = (char)1;
  }
  {
#line 268
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 270
  *((ejctrl->in)->data + 12) = (char)1;
#line 271
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 273
  *((ejctrl->in)->data + 12) = (char)0;
#line 274
  chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
  }
#line 276
  if (! *((ejctrl->out)->data + 3)) {
    {
#line 277
    tmp___8 = register_get_string((tap_register const   *)ejctrl->out);
#line 277
    tmp___9 = gettext("%s(%d) Failed to enter debug mode, ctrl=%s\n");
#line 277
    printf((char const   */* __restrict  */)tmp___9, "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c",
           278, tmp___8);
    }
#line 280
    return;
  }
#line 283
  if (*((ejctrl->out)->data + 31)) {
    {
#line 284
    *((ejctrl->in)->data + 31) = (char)0;
#line 285
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 0);
#line 286
    *((ejctrl->in)->data + 31) = (char)1;
#line 287
    chain_shift_data_registers(((bus_params_t___17 *)bus___0->params)->chain, 1);
    }
  }
  {
#line 290
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), 4U);
#line 291
  ((bus_params_t___17 *)bus___0->params)->adr_hi = (uint16_t )0;
#line 292
  ((bus_params_t___17 *)bus___0->params)->initialized = 1;
  }
#line 293
  return;
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 298
  if (((bus_params_t___17 *)bus___0->params)->initialized) {
#line 299
    return;
  }
  {
#line 301
  ejtag_bus_init(bus___0);
  }
#line 302
  return;
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static int ejtag_gen_read(uint32_t *code___0 , uint32_t adr ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 308
  p = code___0;
#line 311
  adr_lo = (uint16_t )(adr & 65535U);
#line 312
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 314
  if ((int )((bus_params_t___17 *)bus->params)->adr_hi != (int )adr_hi) {
#line 315
    ((bus_params_t___17 *)bus->params)->adr_hi = adr_hi;
#line 316
    tmp = p;
#line 316
    p ++;
#line 316
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 319
  if (adr >> 29 == 0U) {
#line 319
    goto case_0;
  }
#line 322
  if (adr >> 29 == 1U) {
#line 322
    goto case_1;
  }
#line 325
  if (adr >> 29 == 2U) {
#line 325
    goto case_2;
  }
#line 328
  goto switch_default;
  case_0: /* CIL Label */ 
#line 320
  tmp___0 = p;
#line 320
  p ++;
#line 320
  *tmp___0 = 2422341632U | (unsigned int )adr_lo;
#line 321
  goto switch_break;
  case_1: /* CIL Label */ 
#line 323
  tmp___1 = p;
#line 323
  p ++;
#line 323
  *tmp___1 = 2489450496U | (unsigned int )((int )adr_lo & -2);
#line 324
  goto switch_break;
  case_2: /* CIL Label */ 
#line 326
  tmp___2 = p;
#line 326
  p ++;
#line 326
  *tmp___2 = 2355232768U | (unsigned int )((int )adr_lo & -4);
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 329
  tmp___3 = p;
#line 329
  p ++;
#line 329
  *tmp___3 = (uint32_t )4133;
#line 330
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 332
  tmp___4 = p;
#line 332
  p ++;
#line 332
  *tmp___4 = (uint32_t )65011720;
#line 333
  return ((int )(p - code___0));
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t code___0[3] ;
  int tmp ;

  {
  {
#line 341
  tmp = ejtag_gen_read(code___0, adr);
#line 341
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )tmp);
  }
#line 343
  return;
}
}
#line 345 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  uint32_t code___0[4] ;
  uint32_t *p ;
  uint32_t *tmp ;
  int tmp___0 ;

  {
  {
#line 349
  p = code___0;
#line 351
  tmp = p;
#line 351
  p ++;
#line 351
  *tmp = 2894200832U;
#line 352
  tmp___0 = ejtag_gen_read(p, adr);
#line 352
  p += tmp___0;
#line 354
  d = ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 357
  return (d);
}
}
#line 364
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) ;
#line 364 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t const   code[2]  = {      (uint32_t const   )2894200832U,      (uint32_t const   )65011720};
#line 360 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t d ;

  {
  {
#line 369
  d = ejtag_run_pracc(bus___0, code, 2U);
  }
#line 372
  return (d);
}
}
#line 375 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static uint32_t ejtag_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 378
  ejtag_bus_read_start(bus___0, adr);
#line 379
  tmp = ejtag_bus_read_end(bus___0);
  }
#line 379
  return (tmp);
}
}
#line 382 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t code___0[5] ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;

  {
#line 386
  p = code___0;
#line 389
  adr_lo = (uint16_t )(adr & 65535U);
#line 390
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 392
  if ((int )((bus_params_t___17 *)bus___0->params)->adr_hi != (int )adr_hi) {
#line 393
    ((bus_params_t___17 *)bus___0->params)->adr_hi = adr_hi;
#line 394
    tmp = p;
#line 394
    p ++;
#line 394
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 397
  if (adr >> 29 == 0U) {
#line 397
    goto case_0;
  }
#line 401
  if (adr >> 29 == 1U) {
#line 401
    goto case_1;
  }
#line 405
  if (adr >> 29 == 2U) {
#line 405
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
#line 398
  tmp___0 = p;
#line 398
  p ++;
#line 398
  *tmp___0 = 872546304U | (data & 255U);
#line 399
  tmp___1 = p;
#line 399
  p ++;
#line 399
  *tmp___1 = 2690777088U | (unsigned int )adr_lo;
#line 400
  goto switch_break;
  case_1: /* CIL Label */ 
#line 402
  tmp___2 = p;
#line 402
  p ++;
#line 402
  *tmp___2 = 872546304U | (data & 65535U);
#line 403
  tmp___3 = p;
#line 403
  p ++;
#line 403
  *tmp___3 = 2757885952U | (unsigned int )((int )adr_lo & -2);
#line 404
  goto switch_break;
  case_2: /* CIL Label */ 
#line 406
  tmp___4 = p;
#line 406
  p ++;
#line 406
  *tmp___4 = 1006764032U | (data >> 16);
#line 407
  tmp___5 = p;
#line 407
  p ++;
#line 407
  *tmp___5 = 876740608U | (data & 65535U);
#line 408
  tmp___6 = p;
#line 408
  p ++;
#line 408
  *tmp___6 = 2892103680U | (unsigned int )((int )adr_lo & -4);
#line 409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 411
  tmp___7 = p;
#line 411
  p ++;
#line 411
  *tmp___7 = (uint32_t )65011720;
#line 413
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 416
  return;
}
}
#line 418 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 421
  if (adr < 536870912U) {
#line 422
    area->description = (char const   *)((void *)0);
#line 423
    area->start = 0U;
#line 424
    area->length = 536870912UL;
#line 425
    area->width = 8U;
  } else
#line 426
  if (adr < 1073741824U) {
#line 427
    area->description = (char const   *)((void *)0);
#line 428
    area->start = 536870912U;
#line 429
    area->length = 536870912UL;
#line 430
    area->width = 16U;
  } else
#line 431
  if (adr < 1610612736U) {
#line 432
    area->description = (char const   *)((void *)0);
#line 433
    area->start = 1073741824U;
#line 434
    area->length = 536870912UL;
#line 435
    area->width = 32U;
  } else {
#line 437
    area->description = (char const   *)((void *)0);
#line 438
    area->start = 1610612736U;
#line 439
    area->length = 2684354560UL;
#line 440
    area->width = 0U;
  }
#line 442
  return (0);
}
}
#line 445 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static void ejtag_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 448
  free(bus___0->params);
#line 449
  free((void *)bus___0);
  }
#line 450
  return;
}
}
#line 452
static bus_t *ejtag_bus_new(void) ;
#line 454 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
struct bus_driver  const  ejtag_bus  = 
#line 454
     {"ejtag", "EJTAG compatible bus driver via PrAcc", & ejtag_bus_new, & ejtag_bus_free,
    & ejtag_bus_printinfo, & ejtag_bus_prepare, & ejtag_bus_area, & ejtag_bus_read_start,
    & ejtag_bus_read_next, & ejtag_bus_read_end, & ejtag_bus_read, & ejtag_bus_write,
    (int (*)(bus_t *bus ))0};
#line 469 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/ejtag.c"
static bus_t *ejtag_bus_new(void) 
{ 
  bus_t *bus___0 ;
  void *tmp ;

  {
#line 474
  if (! chain) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if (! chain->parts) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if ((chain->parts)->len <= chain->active_part) {
#line 475
    return ((bus_t *)((void *)0));
  } else
#line 474
  if (chain->active_part < 0) {
#line 475
    return ((bus_t *)((void *)0));
  }
  {
#line 477
  tmp = malloc(sizeof(bus_t ));
#line 477
  bus___0 = (bus_t *)tmp;
  }
#line 478
  if (! bus___0) {
#line 479
    return ((bus_t *)((void *)0));
  }
  {
#line 481
  bus___0->driver = & ejtag_bus;
#line 482
  bus___0->params = malloc(sizeof(bus_params_t___17 ));
  }
#line 483
  if (! bus___0->params) {
    {
#line 484
    free((void *)bus___0);
    }
#line 485
    return ((bus_t *)((void *)0));
  }
#line 488
  ((bus_params_t___17 *)bus___0->params)->chain = chain;
#line 489
  ((bus_params_t___17 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 490
  ((bus_params_t___17 *)bus___0->params)->initialized = 0;
#line 492
  return (bus___0);
}
}
#line 39 "../../include/bus.h"
buses_t buses ;
#line 40
bus_driver_t const   *bus_drivers[25] ;
#line 42
void buses_free(void) ;
#line 43
void buses_add(bus_t *abus ) ;
#line 44
void buses_delete(bus_t *abus ) ;
#line 28 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.h"
struct bus_driver  const  au1500_bus ;
#line 29
struct bus_driver  const  bcm1250_bus ;
#line 31
struct bus_driver  const  bf533_stamp_bus ;
#line 32
struct bus_driver  const  bf533_ezkit_bus ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
bus_driver_t const   *bus_drivers[25]  = 
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
  {      & au1500_bus,      & bcm1250_bus,      & ejtag_bus,      & bf533_stamp_bus, 
        & bf533_ezkit_bus,      & ixp425_bus,      & lh7a400_bus,      & mpc824x_bus, 
        & mpc5200_bus,      & ppc440gx_ebc8_bus,      & ppc405ep_bus,      & pxa2x0_bus, 
        & pxa27x_bus,      & s3c4510_bus,      & sa1110_bus,      & sh7727_bus, 
        & sh7750r_bus,      & sh7751r_bus,      & h7202_bus,      & slsup3_bus, 
        & tx4925_bus,      & jopcyc_bus,      & sharc_21065L_bus,      & zefant_xs3_bus, 
        (bus_driver_t const   *)((void *)0)};
#line 60 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
bus_t *bus  =    (bus_t *)((void *)0);
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
buses_t buses  =    {0, (bus_t **)((void *)0)};
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
void buses_free(void) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < buses.len)) {
#line 67
      goto while_break;
    }
    {
#line 68
    (*(((*(buses.buses + i))->driver)->free_bus))(*(buses.buses + i));
#line 67
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  free((void *)buses.buses);
#line 71
  buses.len = 0;
#line 72
  buses.buses = (bus_t **)((void *)0);
#line 73
  bus = (bus_t *)((void *)0);
  }
#line 74
  return;
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
void buses_add(bus_t *abus ) 
{ 
  bus_t **b ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 80
  if ((unsigned long )abus == (unsigned long )((void *)0)) {
#line 81
    return;
  }
  {
#line 83
  tmp = realloc((void *)buses.buses, (unsigned long )(buses.len + 1) * sizeof(bus_t *));
#line 83
  b = (bus_t **)tmp;
  }
#line 84
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 85
    tmp___0 = gettext("Out of memory\n");
#line 85
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 86
    return;
  }
#line 88
  buses.buses = b;
#line 89
  tmp___1 = buses.len;
#line 89
  (buses.len) ++;
#line 89
  *(buses.buses + tmp___1) = abus;
#line 90
  if ((unsigned long )bus == (unsigned long )((void *)0)) {
#line 91
    bus = abus;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/buses.c"
void buses_delete(bus_t *abus ) 
{ 
  int i ;
  bus_t **b ;
  void *tmp ;

  {
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < buses.len)) {
#line 99
      goto while_break;
    }
#line 100
    if ((unsigned long )abus == (unsigned long )*(buses.buses + i)) {
#line 101
      goto while_break;
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (i >= buses.len) {
#line 103
    return;
  }
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (i + 1 < buses.len)) {
#line 105
      goto while_break___0;
    }
#line 106
    *(buses.buses + i) = *(buses.buses + (i + 1));
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 109
  (buses.len) --;
#line 110
  tmp = realloc((void *)buses.buses, (unsigned long )buses.len * sizeof(bus_t *));
#line 110
  b = (bus_t **)tmp;
  }
#line 111
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 112
    buses.buses = b;
  } else
#line 111
  if (buses.len == 0) {
#line 112
    buses.buses = b;
  }
#line 114
  if ((unsigned long )bus != (unsigned long )abus) {
#line 115
    return;
  }
#line 117
  if (buses.len > 0) {
#line 118
    bus = *(buses.buses + 0);
  }
#line 119
  return;
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void select_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[1], 1, 0);
#line 75
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[0], 1, 0);
#line 76
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[1], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[2], 1, 1);
#line 78
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[3], 1, 1);
#line 80
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sras, 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->scas, 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->swe, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sms, 1, 1);
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void unselect_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 89
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 91
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[0], 1, 0);
#line 92
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[1], 1, 0);
#line 94
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[0], 1, 1);
#line 95
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[1], 1, 1);
#line 96
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[2], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[3], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sras, 1, 1);
#line 100
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->scas, 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->swe, 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sms, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void setup_address___17(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 109
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 19)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void set_data_in___17(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void setup_data___17(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((((bus_params_t___18 *)bus___0->params)->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )((bus_params_t___18 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___18 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 150
  part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EXTEST");
#line 151
  chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 157
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 158
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 160
  select_flash___1(bus___0);
#line 161
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 164
  setup_address___17(bus___0, adr);
#line 165
  set_data_in___17(bus___0);
#line 167
  chain_shift_data_registers(chain___0, 0);
  }
#line 168
  return;
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 173
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 174
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 176
  d = (uint32_t )0;
#line 178
  setup_address___17(bus___0, adr);
#line 179
  chain_shift_data_registers(chain___0, 1);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 16)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 190
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 193
  d = (uint32_t )0;
#line 195
  unselect_flash___1(bus___0);
#line 196
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 199
  chain_shift_data_registers(chain___0, 1);
#line 201
  i = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < 16)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = part_get_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i]);
#line 202
    d |= (uint32_t )(tmp << i);
#line 201
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (d);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 210
  bf533_stamp_bus_read_start(bus___0, adr);
#line 211
  tmp = bf533_stamp_bus_read_end(bus___0);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 217
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 218
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 222
  select_flash___1(bus___0);
#line 223
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 1);
#line 225
  setup_address___17(bus___0, adr);
#line 226
  setup_data___17(bus___0, data);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 0);
#line 231
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 233
  unselect_flash___1(bus___0);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static int bf533_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *bf533_stamp_bus_new(void) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
struct bus_driver  const  bf533_stamp_bus  = 
#line 257
     {"bf533_stamp", "Blackfin BF533 Stamp board bus driver", & bf533_stamp_bus_new,
    & bf533_stamp_bus_free, & bf533_stamp_bus_printinfo, & bf533_stamp_bus_prepare,
    & bf533_stamp_bus_area, & bf533_stamp_bus_read_start, & bf533_stamp_bus_read_next,
    & bf533_stamp_bus_read_end, & bf533_stamp_bus_read, & bf533_stamp_bus_write, (int (*)(bus_t *bus ))0};
#line 272 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_stamp.c"
static bus_t *bf533_stamp_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 278
  failed = 0;
#line 280
  if (! chain) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (! chain->parts) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if ((chain->parts)->len <= chain->active_part) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (chain->active_part < 0) {
#line 281
    return ((bus_t *)((void *)0));
  }
  {
#line 283
  tmp = malloc(sizeof(bus_t ));
#line 283
  bus___0 = (bus_t *)tmp;
  }
#line 284
  if (! bus___0) {
#line 285
    return ((bus_t *)((void *)0));
  }
  {
#line 287
  bus___0->driver = & bf533_stamp_bus;
#line 288
  bus___0->params = malloc(sizeof(bus_params_t___18 ));
  }
#line 289
  if (! bus___0->params) {
    {
#line 290
    free((void *)bus___0);
    }
#line 291
    return ((bus_t *)((void *)0));
  }
#line 294
  ((bus_params_t___18 *)bus___0->params)->chain = chain;
#line 295
  ((bus_params_t___18 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 297
  i = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (i < 2)) {
#line 297
      goto while_break;
    }
    {
#line 298
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PF%d",
            i);
#line 299
    ((bus_params_t___18 *)bus___0->params)->pf[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 300
    if (! ((bus_params_t___18 *)bus___0->params)->pf[i]) {
      {
#line 301
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 301
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 302
      failed = 1;
      }
#line 303
      goto while_break;
    }
#line 297
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 4)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 309
    ((bus_params_t___18 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___18 *)bus___0->params)->ams[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! (i < 19)) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 319
    ((bus_params_t___18 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 320
    if (! ((bus_params_t___18 *)bus___0->params)->addr[i]) {
      {
#line 321
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 321
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 322
      failed = 1;
      }
#line 323
      goto while_break___1;
    }
#line 317
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 326
    if (! (i < 16)) {
#line 326
      goto while_break___2;
    }
    {
#line 327
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 328
    ((bus_params_t___18 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 329
    if (! ((bus_params_t___18 *)bus___0->params)->data[i]) {
      {
#line 330
      tmp___3 = gettext("signal \'%s\' not found\n");
#line 330
      printf((char const   */* __restrict  */)tmp___3, buff);
#line 331
      failed = 1;
      }
#line 332
      goto while_break___2;
    }
#line 326
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 336
  ((bus_params_t___18 *)bus___0->params)->awe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 337
  if (! ((bus_params_t___18 *)bus___0->params)->awe) {
    {
#line 338
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 338
    printf((char const   */* __restrict  */)tmp___4, "AWE_B");
#line 339
    failed = 1;
    }
  }
  {
#line 342
  ((bus_params_t___18 *)bus___0->params)->aoe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "AOE_B");
  }
#line 343
  if (! ((bus_params_t___18 *)bus___0->params)->aoe) {
    {
#line 344
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 344
    printf((char const   */* __restrict  */)tmp___5, "AOE_B");
#line 345
    failed = 1;
    }
  }
  {
#line 348
  ((bus_params_t___18 *)bus___0->params)->sras = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 349
  if (! ((bus_params_t___18 *)bus___0->params)->sras) {
    {
#line 350
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 350
    printf((char const   */* __restrict  */)tmp___6, "SRAS_B");
#line 351
    failed = 1;
    }
  }
  {
#line 354
  ((bus_params_t___18 *)bus___0->params)->scas = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 355
  if (! ((bus_params_t___18 *)bus___0->params)->scas) {
    {
#line 356
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 356
    printf((char const   */* __restrict  */)tmp___7, "SCAS_B");
#line 357
    failed = 1;
    }
  }
  {
#line 360
  ((bus_params_t___18 *)bus___0->params)->swe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 361
  if (! ((bus_params_t___18 *)bus___0->params)->swe) {
    {
#line 362
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 362
    printf((char const   */* __restrict  */)tmp___8, "SWE_B");
#line 363
    failed = 1;
    }
  }
  {
#line 366
  ((bus_params_t___18 *)bus___0->params)->sms = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "SMS_B");
  }
#line 367
  if (! ((bus_params_t___18 *)bus___0->params)->sms) {
    {
#line 368
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 368
    printf((char const   */* __restrict  */)tmp___9, "SMS_B");
#line 369
    failed = 1;
    }
  }
#line 372
  if (failed) {
    {
#line 373
    free(bus___0->params);
#line 374
    free((void *)bus___0);
    }
#line 375
    return ((bus_t *)((void *)0));
  }
#line 378
  return (bus___0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void select_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 70
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 72
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[0], 1, 0);
#line 73
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[1], 1, 1);
#line 74
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[2], 1, 1);
#line 75
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[3], 1, 1);
#line 77
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[0], 1, 0);
#line 78
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[1], 1, 0);
#line 80
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sras, 1, 1);
#line 81
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->scas, 1, 1);
#line 82
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->swe, 1, 1);
#line 83
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sms, 1, 1);
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void unselect_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 89
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 91
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[0], 1, 1);
#line 92
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[1], 1, 1);
#line 93
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[2], 1, 1);
#line 94
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->ams[3], 1, 1);
#line 96
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[0], 1, 1);
#line 97
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->pf[1], 1, 1);
#line 99
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sras, 1, 1);
#line 100
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->scas, 1, 1);
#line 101
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->swe, 1, 1);
#line 102
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->sms, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void setup_address___18(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 109
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 19)) {
#line 111
      goto while_break;
    }
    {
#line 112
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void set_data_in___18(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 119
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 16)) {
#line 121
      goto while_break;
    }
    {
#line 122
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i], 0, 0);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void setup_data___18(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 129
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 16)) {
#line 131
      goto while_break;
    }
    {
#line 132
    part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((((bus_params_t___18 *)bus___0->params)->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )((bus_params_t___18 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___18 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 EZKit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 150
  part_set_instruction(((bus_params_t___18 *)bus___0->params)->part, "EXTEST");
#line 151
  chain_shift_instructions(((bus_params_t___18 *)bus___0->params)->chain);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 157
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 158
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 160
  select_flash___2(bus___0);
#line 161
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 0);
#line 162
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 164
  setup_address___18(bus___0, adr);
#line 165
  set_data_in___18(bus___0);
#line 167
  chain_shift_data_registers(chain___0, 0);
  }
#line 168
  return;
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 173
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 174
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 176
  d = (uint32_t )0;
#line 178
  setup_address___18(bus___0, adr);
#line 179
  chain_shift_data_registers(chain___0, 1);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 16)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 190
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 191
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 193
  d = (uint32_t )0;
#line 195
  unselect_flash___2(bus___0);
#line 196
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 199
  chain_shift_data_registers(chain___0, 1);
#line 201
  i = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < 16)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = part_get_signal(p, ((bus_params_t___18 *)bus___0->params)->data[i]);
#line 202
    d |= (uint32_t )(tmp << i);
#line 201
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (d);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 210
  bf533_ezkit_bus_read_start(bus___0, adr);
#line 211
  tmp = bf533_ezkit_bus_read_end(bus___0);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 217
  p = ((bus_params_t___18 *)bus___0->params)->part;
#line 218
  chain___0 = ((bus_params_t___18 *)bus___0->params)->chain;
#line 222
  select_flash___2(bus___0);
#line 223
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->aoe, 1, 1);
#line 225
  setup_address___18(bus___0, adr);
#line 226
  setup_data___18(bus___0, data);
#line 228
  chain_shift_data_registers(chain___0, 0);
#line 230
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 0);
#line 231
  chain_shift_data_registers(chain___0, 0);
#line 232
  part_set_signal(p, ((bus_params_t___18 *)bus___0->params)->awe, 1, 1);
#line 233
  unselect_flash___2(bus___0);
#line 234
  chain_shift_data_registers(chain___0, 0);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static int bf533_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 240
  area->description = (char const   *)((void *)0);
#line 241
  area->start = 0U;
#line 242
  area->length = 4294967296UL;
#line 243
  area->width = 16U;
#line 245
  return (0);
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 251
  free(bus___0->params);
#line 252
  free((void *)bus___0);
  }
#line 253
  return;
}
}
#line 255
static bus_t *bf533_ezkit_bus_new(void) ;
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
struct bus_driver  const  bf533_ezkit_bus  = 
#line 257
     {"bf533_ezkit", "Blackfin BF533 EZKit board bus driver", & bf533_ezkit_bus_new,
    & bf533_ezkit_bus_free, & bf533_ezkit_bus_printinfo, & bf533_ezkit_bus_prepare,
    & bf533_ezkit_bus_area, & bf533_ezkit_bus_read_start, & bf533_ezkit_bus_read_next,
    & bf533_ezkit_bus_read_end, & bf533_ezkit_bus_read, & bf533_ezkit_bus_write, (int (*)(bus_t *bus ))0};
#line 272 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bf533_ezkit.c"
static bus_t *bf533_ezkit_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 278
  failed = 0;
#line 280
  if (! chain) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (! chain->parts) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if ((chain->parts)->len <= chain->active_part) {
#line 281
    return ((bus_t *)((void *)0));
  } else
#line 280
  if (chain->active_part < 0) {
#line 281
    return ((bus_t *)((void *)0));
  }
  {
#line 283
  tmp = malloc(sizeof(bus_t ));
#line 283
  bus___0 = (bus_t *)tmp;
  }
#line 284
  if (! bus___0) {
#line 285
    return ((bus_t *)((void *)0));
  }
  {
#line 287
  bus___0->driver = & bf533_ezkit_bus;
#line 288
  bus___0->params = malloc(sizeof(bus_params_t___18 ));
  }
#line 289
  if (! bus___0->params) {
    {
#line 290
    free((void *)bus___0);
    }
#line 291
    return ((bus_t *)((void *)0));
  }
#line 294
  ((bus_params_t___18 *)bus___0->params)->chain = chain;
#line 295
  ((bus_params_t___18 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 297
  i = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (i < 4)) {
#line 297
      goto while_break;
    }
    {
#line 298
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 299
    ((bus_params_t___18 *)bus___0->params)->ams[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 300
    if (! ((bus_params_t___18 *)bus___0->params)->ams[i]) {
      {
#line 301
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 301
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 302
      failed = 1;
      }
#line 303
      goto while_break;
    }
#line 297
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 19)) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 309
    ((bus_params_t___18 *)bus___0->params)->addr[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 310
    if (! ((bus_params_t___18 *)bus___0->params)->addr[i]) {
      {
#line 311
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 311
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 312
      failed = 1;
      }
#line 313
      goto while_break___0;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 316
    if (! (i < 16)) {
#line 316
      goto while_break___1;
    }
    {
#line 317
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 318
    ((bus_params_t___18 *)bus___0->params)->data[i] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 319
    if (! ((bus_params_t___18 *)bus___0->params)->data[i]) {
      {
#line 320
      tmp___2 = gettext("signal \'%s\' not found\n");
#line 320
      printf((char const   */* __restrict  */)tmp___2, buff);
#line 321
      failed = 1;
      }
#line 322
      goto while_break___1;
    }
#line 316
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 326
  ((bus_params_t___18 *)bus___0->params)->awe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "AWE_B");
  }
#line 327
  if (! ((bus_params_t___18 *)bus___0->params)->awe) {
    {
#line 328
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 328
    printf((char const   */* __restrict  */)tmp___3, "AWE_B");
#line 329
    failed = 1;
    }
  }
  {
#line 332
  ((bus_params_t___18 *)bus___0->params)->aoe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "AOE_B");
  }
#line 333
  if (! ((bus_params_t___18 *)bus___0->params)->aoe) {
    {
#line 334
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___4, "AOE_B");
#line 335
    failed = 1;
    }
  }
  {
#line 338
  ((bus_params_t___18 *)bus___0->params)->pf[0] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                   "ABE_B0");
  }
#line 339
  if (! ((bus_params_t___18 *)bus___0->params)->pf[0]) {
    {
#line 340
    tmp___5 = gettext("signal \'%s\' not found\n");
#line 340
    printf((char const   */* __restrict  */)tmp___5, "ABE_B0");
#line 341
    failed = 1;
    }
  }
  {
#line 344
  ((bus_params_t___18 *)bus___0->params)->pf[1] = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                   "ABE_B1");
  }
#line 345
  if (! ((bus_params_t___18 *)bus___0->params)->pf[1]) {
    {
#line 346
    tmp___6 = gettext("signal \'%s\' not found\n");
#line 346
    printf((char const   */* __restrict  */)tmp___6, "ABE_B1");
#line 347
    failed = 1;
    }
  }
  {
#line 350
  ((bus_params_t___18 *)bus___0->params)->sras = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                  "SRAS_B");
  }
#line 351
  if (! ((bus_params_t___18 *)bus___0->params)->sras) {
    {
#line 352
    tmp___7 = gettext("signal \'%s\' not found\n");
#line 352
    printf((char const   */* __restrict  */)tmp___7, "SRAS_B");
#line 353
    failed = 1;
    }
  }
  {
#line 356
  ((bus_params_t___18 *)bus___0->params)->scas = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                  "SCAS_B");
  }
#line 357
  if (! ((bus_params_t___18 *)bus___0->params)->scas) {
    {
#line 358
    tmp___8 = gettext("signal \'%s\' not found\n");
#line 358
    printf((char const   */* __restrict  */)tmp___8, "SCAS_B");
#line 359
    failed = 1;
    }
  }
  {
#line 362
  ((bus_params_t___18 *)bus___0->params)->swe = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "SWE_B");
  }
#line 363
  if (! ((bus_params_t___18 *)bus___0->params)->swe) {
    {
#line 364
    tmp___9 = gettext("signal \'%s\' not found\n");
#line 364
    printf((char const   */* __restrict  */)tmp___9, "SWE_B");
#line 365
    failed = 1;
    }
  }
  {
#line 368
  ((bus_params_t___18 *)bus___0->params)->sms = part_find_signal(((bus_params_t___18 *)bus___0->params)->part,
                                                                 "SMS_B");
  }
#line 369
  if (! ((bus_params_t___18 *)bus___0->params)->sms) {
    {
#line 370
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 370
    printf((char const   */* __restrict  */)tmp___10, "SMS_B");
#line 371
    failed = 1;
    }
  }
#line 374
  if (failed) {
    {
#line 375
    free(bus___0->params);
#line 376
    free((void *)bus___0);
    }
#line 377
    return ((bus_t *)((void *)0));
  }
#line 380
  return (bus___0);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void setup_address___19(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 24)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_ad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void set_data_in___19(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 77
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 8)) {
#line 79
      goto while_break;
    }
    {
#line 80
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_ad[i + 24], 0, 0);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void setup_data___19(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 88
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < 8)) {
#line 90
      goto while_break;
    }
    {
#line 91
    part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_ad[i + 24], 1, (int )((d >> i) & 1U));
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void bcm1250_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < ((((bus_params_t___19 *)bus___0->params)->chain)->parts)->len)) {
#line 101
      goto while_break;
    }
#line 102
    if ((unsigned long )((bus_params_t___19 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___19 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 103
      goto while_break;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp = gettext("Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 104
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
void bcm1250_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 110
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 111
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 113
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[0], 1, 0);
#line 114
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[1], 1, 1);
#line 115
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[2], 1, 1);
#line 116
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[3], 1, 1);
#line 117
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[4], 1, 1);
#line 118
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[5], 1, 1);
#line 119
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[6], 1, 1);
#line 120
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[7], 1, 1);
#line 121
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_rw, 1, 1);
#line 122
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_wr_l, 1, 1);
#line 123
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_oe_l, 1, 0);
#line 125
  setup_address___19(bus___0, adr);
#line 126
  set_data_in___19(bus___0);
#line 128
  chain_shift_data_registers(chain___0, 0);
  }
#line 129
  return;
}
}
#line 131 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 134
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 135
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 137
  setup_address___19(bus___0, adr);
#line 138
  chain_shift_data_registers(chain___0, 1);
#line 142
  d = (uint32_t )0;
#line 144
  i = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < 8)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp = part_get_signal(p, ((bus_params_t___19 *)bus___0->params)->io_ad[i + 24]);
#line 145
    d |= (uint32_t )(tmp << i);
#line 144
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (d);
}
}
#line 152 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 155
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 156
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 158
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[0], 1, 1);
#line 159
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_oe_l, 1, 1);
#line 160
  chain_shift_data_registers(chain___0, 1);
#line 164
  d = (uint32_t )0;
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < 8)) {
#line 166
      goto while_break;
    }
    {
#line 167
    tmp = part_get_signal(p, ((bus_params_t___19 *)bus___0->params)->io_ad[i + 24]);
#line 167
    d |= (uint32_t )(tmp << i);
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (d);
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
uint32_t bcm1250_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t i ;

  {
  {
#line 178
  bcm1250_bus_read_start(bus___0, adr);
#line 179
  i = bcm1250_bus_read_end(bus___0);
  }
#line 180
  return (i);
}
}
#line 183 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
void bcm1250_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 186
  p = ((bus_params_t___19 *)bus___0->params)->part;
#line 187
  chain___0 = ((bus_params_t___19 *)bus___0->params)->chain;
#line 189
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[0], 1, 0);
#line 190
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[3], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[4], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[5], 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[6], 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_cs_l[7], 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_rw, 1, 0);
#line 198
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_wr_l, 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_oe_l, 1, 1);
#line 201
  setup_address___19(bus___0, adr);
#line 202
  setup_data___19(bus___0, data);
#line 204
  chain_shift_data_registers(chain___0, 0);
#line 206
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_wr_l, 1, 0);
#line 207
  chain_shift_data_registers(chain___0, 0);
#line 209
  part_set_signal(p, ((bus_params_t___19 *)bus___0->params)->io_wr_l, 1, 1);
#line 210
  chain_shift_data_registers(chain___0, 0);
  }
#line 211
  return;
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static int bcm1250_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
#line 249
  area->description = (char const   *)((void *)0);
#line 250
  area->start = 0U;
#line 251
  area->length = 4294967296UL;
#line 252
  area->width = 8U;
#line 254
  return (0);
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void bcm1250_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 260
  part_set_instruction(((bus_params_t___19 *)bus___0->params)->part, "EXTEST");
#line 261
  chain_shift_instructions(((bus_params_t___19 *)bus___0->params)->chain);
  }
#line 262
  return;
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static void bcm1250_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 267
  free(bus___0->params);
#line 268
  free((void *)bus___0);
  }
#line 269
  return;
}
}
#line 271
static bus_t *bcm1250_bus_new(void) ;
#line 273 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
struct bus_driver  const  bcm1250_bus  = 
#line 273
     {"bcm1250", "Broadcom BCM1250 compatible bus driver via BSR", & bcm1250_bus_new,
    & bcm1250_bus_free, & bcm1250_bus_printinfo, & bcm1250_bus_prepare, & bcm1250_bus_area,
    & bcm1250_bus_read_start, & bcm1250_bus_read_next, & bcm1250_bus_read_end, & bcm1250_bus_read,
    & bcm1250_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 289 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/bcm1250.c"
static bus_t *bcm1250_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 295
  failed = 0;
#line 297
  if (! chain) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if (! chain->parts) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if ((chain->parts)->len <= chain->active_part) {
#line 298
    return ((bus_t *)((void *)0));
  } else
#line 297
  if (chain->active_part < 0) {
#line 298
    return ((bus_t *)((void *)0));
  }
  {
#line 300
  tmp = malloc(sizeof(bus_t ));
#line 300
  bus___0 = (bus_t *)tmp;
  }
#line 301
  if (! bus___0) {
#line 302
    return ((bus_t *)((void *)0));
  }
  {
#line 304
  bus___0->driver = & bcm1250_bus;
#line 305
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___19 ));
  }
#line 306
  if (! bus___0->params) {
    {
#line 307
    free((void *)bus___0);
    }
#line 308
    return ((bus_t *)((void *)0));
  }
#line 311
  ((bus_params_t___19 *)bus___0->params)->chain = chain;
#line 312
  ((bus_params_t___19 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < 32)) {
#line 314
      goto while_break;
    }
    {
#line 315
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_AD%d",
            i);
#line 316
    ((bus_params_t___19 *)bus___0->params)->io_ad[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                        (char const   *)(buff));
    }
#line 317
    if (! ((bus_params_t___19 *)bus___0->params)->io_ad[i]) {
      {
#line 318
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 318
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 319
      failed = 1;
      }
#line 320
      goto while_break;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! (i < 8)) {
#line 323
      goto while_break___0;
    }
    {
#line 324
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_CS_L%d",
            i);
#line 325
    ((bus_params_t___19 *)bus___0->params)->io_cs_l[i] = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                          (char const   *)(buff));
    }
#line 326
    if (! ((bus_params_t___19 *)bus___0->params)->io_cs_l[i]) {
      {
#line 327
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 327
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 328
      failed = 1;
      }
#line 329
      goto while_break___0;
    }
#line 323
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 332
  ((bus_params_t___19 *)bus___0->params)->io_rw = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                   "IO_RW");
  }
#line 333
  if (! ((bus_params_t___19 *)bus___0->params)->io_rw) {
    {
#line 334
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 334
    printf((char const   */* __restrict  */)tmp___2, "IO_RW");
#line 335
    failed = 1;
    }
  }
  {
#line 337
  ((bus_params_t___19 *)bus___0->params)->io_wr_l = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                     "IO_WR_L");
  }
#line 338
  if (! ((bus_params_t___19 *)bus___0->params)->io_wr_l) {
    {
#line 339
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 339
    printf((char const   */* __restrict  */)tmp___3, "IO_WR_L");
#line 340
    failed = 1;
    }
  }
  {
#line 342
  ((bus_params_t___19 *)bus___0->params)->io_oe_l = part_find_signal(((bus_params_t___19 *)bus___0->params)->part,
                                                                     "IO_OE_L");
  }
#line 343
  if (! ((bus_params_t___19 *)bus___0->params)->io_oe_l) {
    {
#line 344
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 344
    printf((char const   */* __restrict  */)tmp___4, "IO_OE_L");
#line 345
    failed = 1;
    }
  }
#line 348
  if (failed) {
    {
#line 349
    free(bus___0->params);
#line 350
    free((void *)bus___0);
    }
#line 351
    return ((bus_t *)((void *)0));
  }
#line 354
  return (bus___0);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void setup_address___20(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 66
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 32)) {
#line 68
      goto while_break;
    }
    {
#line 69
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->rad[i], 1, (int )((a >> i) & 1U));
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void set_data_in___20(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 78
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 81
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned int )i < area.width)) {
#line 83
      goto while_break;
    }
    {
#line 84
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->rd[i], 0, 0);
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static uint32_t get_data_out(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 92
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 94
  d = (uint32_t )0;
#line 96
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned int )i < area.width)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = part_get_signal(p, ((bus_params_t___20 *)bus___0->params)->rd[i]);
#line 99
    d |= (uint32_t )(tmp << i);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (d);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void setup_data___20(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 108
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 111
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 113
  i = 0;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned int )i < area.width)) {
#line 113
      goto while_break;
    }
    {
#line 114
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->rd[i], 1, (int )((d >> i) & 1U));
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static bus_t *au1500_bus_new(void) 
{ 
  bus_t *bus___0 ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 122
  failed = 0;
#line 125
  if (! chain) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if (! chain->parts) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if ((chain->parts)->len <= chain->active_part) {
#line 126
    return ((bus_t *)((void *)0));
  } else
#line 125
  if (chain->active_part < 0) {
#line 126
    return ((bus_t *)((void *)0));
  }
  {
#line 128
  tmp = malloc(sizeof(bus_t ));
#line 128
  bus___0 = (bus_t *)tmp;
  }
#line 129
  if (! bus___0) {
#line 130
    return ((bus_t *)((void *)0));
  }
  {
#line 132
  bus___0->driver = & au1500_bus;
#line 133
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___20 ));
  }
#line 134
  if (! bus___0->params) {
    {
#line 135
    free((void *)bus___0);
    }
#line 136
    return ((bus_t *)((void *)0));
  }
#line 139
  ((bus_params_t___20 *)bus___0->params)->chain = chain;
#line 140
  ((bus_params_t___20 *)bus___0->params)->part = *((chain->parts)->parts + chain->active_part);
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 32)) {
#line 142
      goto while_break;
    }
    {
#line 143
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RAD%d",
            i);
#line 144
    ((bus_params_t___20 *)bus___0->params)->rad[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                      (char const   *)(buff));
    }
#line 145
    if (! ((bus_params_t___20 *)bus___0->params)->rad[i]) {
      {
#line 146
      tmp___0 = gettext("signal \'%s\' not found\n");
#line 146
      printf((char const   */* __restrict  */)tmp___0, buff);
#line 147
      failed = 1;
      }
#line 148
      goto while_break;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! (i < 4)) {
#line 152
      goto while_break___0;
    }
    {
#line 153
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RCE_N%d",
            i);
#line 154
    ((bus_params_t___20 *)bus___0->params)->nrcs[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                       (char const   *)(buff));
    }
#line 155
    if (! ((bus_params_t___20 *)bus___0->params)->nrcs[i]) {
      {
#line 156
      tmp___1 = gettext("signal \'%s\' not found\n");
#line 156
      printf((char const   */* __restrict  */)tmp___1, buff);
#line 157
      failed = 1;
      }
#line 158
      goto while_break___0;
    }
#line 152
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 163
  ((bus_params_t___20 *)bus___0->params)->nrwe = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                  "RWE_N");
  }
#line 164
  if (! ((bus_params_t___20 *)bus___0->params)->nrwe) {
    {
#line 165
    tmp___2 = gettext("signal \'%s\' not found\n");
#line 165
    printf((char const   */* __restrict  */)tmp___2, "RWE_N");
#line 166
    failed = 1;
    }
  }
  {
#line 169
  ((bus_params_t___20 *)bus___0->params)->nroe = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                  "ROE_N");
  }
#line 170
  if (! ((bus_params_t___20 *)bus___0->params)->nroe) {
    {
#line 171
    tmp___3 = gettext("signal \'%s\' not found\n");
#line 171
    printf((char const   */* __restrict  */)tmp___3, "ROE_N");
#line 172
    failed = 1;
    }
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (i < 32)) {
#line 175
      goto while_break___1;
    }
    {
#line 176
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 177
    ((bus_params_t___20 *)bus___0->params)->rd[i] = part_find_signal(((bus_params_t___20 *)bus___0->params)->part,
                                                                     (char const   *)(buff));
    }
#line 178
    if (! ((bus_params_t___20 *)bus___0->params)->rd[i]) {
      {
#line 179
      tmp___4 = gettext("signal \'%s\' not found\n");
#line 179
      printf((char const   */* __restrict  */)tmp___4, buff);
#line 180
      failed = 1;
      }
#line 181
      goto while_break___1;
    }
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 185
  if (failed) {
    {
#line 186
    free(bus___0->params);
#line 187
    free((void *)bus___0);
    }
#line 188
    return ((bus_t *)((void *)0));
  }
#line 191
  return (bus___0);
}
}
#line 195 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 198
  area->description = (char const   *)((void *)0);
#line 199
  area->start = 0U;
#line 200
  area->length = 4294967296UL;
#line 202
  tmp___1 = part_find_signal(((bus_params_t___20 *)bus___0->params)->part, "ROMSIZ");
#line 202
  tmp___2 = part_get_signal(((bus_params_t___20 *)bus___0->params)->part, tmp___1);
  }
#line 202
  if (tmp___2) {
#line 202
    area->width = 16U;
  } else {
#line 202
    area->width = 32U;
  }
#line 205
  return (0);
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void au1500_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 212
  free(bus___0->params);
#line 213
  free((void *)bus___0);
  }
#line 214
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void au1500_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 221
  i = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < ((((bus_params_t___20 *)bus___0->params)->chain)->parts)->len)) {
#line 221
      goto while_break;
    }
#line 222
    if ((unsigned long )((bus_params_t___20 *)bus___0->params)->part == (unsigned long )*(((((bus_params_t___20 *)bus___0->params)->chain)->parts)->parts + i)) {
#line 223
      goto while_break;
    }
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  tmp = gettext("AU1500 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 224
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 225
  return;
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void au1500_bus_prepare(bus_t *bus___0 ) 
{ 


  {
  {
#line 230
  part_set_instruction(((bus_params_t___20 *)bus___0->params)->part, "EXTEST");
#line 231
  chain_shift_instructions(((bus_params_t___20 *)bus___0->params)->chain);
  }
#line 232
  return;
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void au1500_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 237
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 238
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 240
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[0], 1, 0);
#line 241
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[1], 1, 1);
#line 242
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[2], 1, 1);
#line 243
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[3], 1, 1);
#line 244
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrwe, 1, 1);
#line 245
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nroe, 1, 0);
#line 247
  setup_address___20(bus___0, adr);
#line 248
  set_data_in___20(bus___0);
#line 250
  chain_shift_data_registers(chain___0, 0);
  }
#line 251
  return;
}
}
#line 253 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static uint32_t au1500_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain___0 ;
  uint32_t tmp ;

  {
  {
#line 256
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 258
  setup_address___20(bus___0, adr);
#line 259
  chain_shift_data_registers(chain___0, 1);
#line 261
  tmp = get_data_out(bus___0);
  }
#line 261
  return (tmp);
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static uint32_t au1500_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;
  uint32_t tmp ;

  {
  {
#line 267
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 268
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 270
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[0], 1, 1);
#line 271
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[1], 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[2], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[3], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrwe, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nroe, 1, 1);
#line 277
  chain_shift_data_registers(chain___0, 1);
#line 279
  tmp = get_data_out(bus___0);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static uint32_t au1500_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 285
  au1500_bus_read_start(bus___0, adr);
#line 286
  tmp = au1500_bus_read_end(bus___0);
  }
#line 286
  return (tmp);
}
}
#line 289 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
static void au1500_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain___0 ;

  {
  {
#line 292
  p = ((bus_params_t___20 *)bus___0->params)->part;
#line 293
  chain___0 = ((bus_params_t___20 *)bus___0->params)->chain;
#line 295
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[0], 1, 0);
#line 296
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[1], 1, 1);
#line 297
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[2], 1, 1);
#line 298
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[3], 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrwe, 1, 1);
#line 300
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nroe, 1, 1);
#line 302
  setup_address___20(bus___0, adr);
#line 303
  setup_data___20(bus___0, data);
#line 305
  chain_shift_data_registers(chain___0, 0);
#line 307
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrwe, 1, 0);
#line 308
  chain_shift_data_registers(chain___0, 0);
#line 310
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrwe, 1, 1);
#line 311
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nroe, 1, 1);
#line 312
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[0], 1, 1);
#line 313
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[1], 1, 1);
#line 314
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[2], 1, 1);
#line 315
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->nrcs[3], 1, 1);
#line 317
  chain_shift_data_registers(chain___0, 0);
  }
#line 318
  return;
}
}
#line 320 "/home/khheo/project/benchmark/urjtag-0.7/src/bus/au1500.c"
struct bus_driver  const  au1500_bus  = 
#line 320
     {"au1500", "AU1500 BUS Driver via BSR", & au1500_bus_new, & au1500_bus_free, & au1500_bus_printinfo,
    & au1500_bus_prepare, & au1500_bus_area, & au1500_bus_read_start, & au1500_bus_read_next,
    & au1500_bus_read_end, & au1500_bus_read, & au1500_bus_write, (int (*)(bus_t *bus ))((void *)0)};
#line 31 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/quit.c"
static int cmd_quit_run(char **params ) 
{ 


  {
#line 34
  if (*(params + 1)) {
#line 35
    return (-1);
  }
#line 37
  return (0);
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/quit.c"
static void cmd_quit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 43
  tmp = gettext("Usage: %s\nExit from %s.\n");
#line 43
  printf((char const   */* __restrict  */)tmp, "quit", "libbrux");
  }
#line 47
  return;
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/quit.c"
cmd_t cmd_quit  =    {(char *)"quit", (char *)"exit and terminate this session", & cmd_quit_help, & cmd_quit_run};
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
static struct amd_flash_info  const  table[21]  = 
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )1, (int const   )8918, "AMD AM29F800BT", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )15}, {(u_int32_t )983040,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )1015808,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )1032192,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )4, (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384,
                                                                (u_int32_t )1}, {(u_int32_t )16384,
                                                                                 (u_int32_t )8192,
                                                                                 (u_int32_t )2},
                                                               {(u_int32_t )32768,
                                                                (u_int32_t )32768,
                                                                (u_int32_t )1}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )32, (int const   )8900, "ST M29W160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (u_int8_t const   )1,
      (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )48},
                                         {(u_int32_t )3145728, (u_int32_t )65536,
                                          (u_int32_t )15}, {(u_int32_t )4128768, (u_int32_t )8192,
                                                            (u_int32_t )8}}}, 
        {(int const   )1, (int const   )8830, "AMD AM29BDS643D", (long const   )8388608,
      (u_int8_t const   )1, (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )96}, {(u_int32_t )6291456,
                                                                                  (u_int32_t )65536,
                                                                                  (u_int32_t )31},
                                                               {(u_int32_t )8323072,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )8}}}, 
        {(int const   )31, (int const   )192, "Atmel AT49xV16x", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )8192,
                                                                (u_int32_t )8}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )8192, (u_int32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )7},
                                         {(u_int32_t )458752, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )491520, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )507904, (u_int32_t )16384, (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (u_int8_t const   )0,
      (int const   )1, (int const   )1, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )8}}}};
#line 369 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
int jedec_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int manid_as[2] ;
  int devid_as[2] ;
  int manid ;
  int devid ;
  int ba ;
  int bw ;
  int i ;
  int j ;
  cfi_query_structure_t *cfi ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 375
  manid = 0;
#line 375
  devid = 0;
#line 381
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 381
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 382
  if (! *cfi_array___0) {
#line 383
    return (-2);
  }
  {
#line 385
  (*cfi_array___0)->bus = bus___0;
#line 386
  (*cfi_array___0)->address = adr;
#line 387
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 387
  if (tmp___0 != 0) {
#line 388
    return (-8);
  }
#line 389
  bw = (int )area.width;
#line 390
  if (bw != 8) {
#line 390
    if (bw != 16) {
#line 390
      if (bw != 32) {
#line 391
        return (-3);
      }
    }
  }
  {
#line 392
  ba = bw / 8;
#line 392
  (*cfi_array___0)->bus_width = ba;
#line 394
  tmp___1 = calloc((size_t )1, sizeof(cfi_chip_t *));
#line 394
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 395
  if (! (*cfi_array___0)->cfi_chips) {
#line 396
    return (-2);
  }
  {
#line 398
  tmp___2 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 398
  *((*cfi_array___0)->cfi_chips + 0) = (cfi_chip_t *)tmp___2;
  }
#line 399
  if (! *((*cfi_array___0)->cfi_chips + 0)) {
#line 400
    return (-2);
  }
  {
#line 403
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 404
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )170);
#line 405
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )85);
#line 406
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )144);
#line 408
  tmp___3 = (*((bus___0->driver)->read))(bus___0, adr);
#line 408
  manid_as[0] = (int )tmp___3;
#line 409
  tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + 2U);
#line 409
  devid_as[0] = (int )tmp___4;
#line 410
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 413
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 414
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 415
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 416
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 418
  tmp___5 = (*((bus___0->driver)->read))(bus___0, adr);
#line 418
  manid_as[1] = (int )tmp___5;
#line 419
  tmp___6 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 419
  devid_as[1] = (int )tmp___6;
#line 420
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 422
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dev ID=%04x   man ID=%04x\n",
          devid, manid);
#line 424
  i = 0;
  }
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! ((unsigned long )i < sizeof(table) / sizeof(struct amd_flash_info ))) {
#line 424
      goto while_break;
    }
#line 427
    manid = manid_as[table[i].as_method];
#line 428
    devid = devid_as[table[i].as_method];
#line 429
    if (manid == (int )table[i].mfr_id) {
#line 429
      if (devid == (int )table[i].dev_id) {
#line 429
        goto while_break;
      }
    }
#line 424
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  if ((unsigned long )i == sizeof(table) / sizeof(struct amd_flash_info )) {
#line 433
    return (-4);
  }
#line 435
  cfi = & (*((*cfi_array___0)->cfi_chips + 0))->cfi;
#line 437
  cfi->identification_string.pri_id_code = (uint16_t )2;
#line 438
  cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 439
  cfi->identification_string.alt_id_code = (uint16_t )0;
#line 440
  cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 442
  cfi->device_geometry.device_size = (uint32_t )table[i].size;
#line 444
  cfi->device_geometry.device_interface = (uint16_t )table[i].interface_width;
  {
#line 446
  if ((int const   )table[i].interface_width == 0) {
#line 446
    goto case_0;
  }
#line 449
  if ((int const   )table[i].interface_width == 1) {
#line 449
    goto case_1;
  }
#line 452
  if ((int const   )table[i].interface_width == 2) {
#line 452
    goto case_2;
  }
#line 457
  if ((int const   )table[i].interface_width == 3) {
#line 457
    goto case_3;
  }
#line 460
  if ((int const   )table[i].interface_width == 4) {
#line 460
    goto case_4;
  }
#line 465
  goto switch_default;
  case_0: /* CIL Label */ 
#line 447
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 448
  goto switch_break;
  case_1: /* CIL Label */ 
#line 450
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 451
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 453
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X8_X16", "CFI_INTERFACE_X16");
#line 454
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 455
  cfi->device_geometry.device_interface = (uint16_t )1;
  }
#line 456
  goto switch_break;
  case_3: /* CIL Label */ 
#line 458
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 459
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 461
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X16_X32", "CFI_INTERFACE_X32");
#line 462
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 463
  cfi->device_geometry.device_interface = (uint16_t )3;
  }
#line 464
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 467
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unsupported interface geometry %d, bailing out\n",
          (int const   )table[i].interface_width);
#line 468
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 469
  cfi->device_geometry.device_interface = (uint16_t )0;
  }
#line 470
  return (-5);
#line 471
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 474
  cfi->device_geometry.number_of_erase_regions = (uint8_t )table[i].numeraseregions;
#line 476
  tmp___7 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 476
  cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___7;
  }
#line 478
  if (! cfi->device_geometry.erase_block_regions) {
#line 479
    return (-2);
  }
#line 481
  j = 0;
  {
#line 481
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 481
    if (! (j < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 481
      goto while_break___0;
    }
#line 482
    (cfi->device_geometry.erase_block_regions + j)->erase_block_size = (uint32_t )table[i].regions[j].erasesize;
#line 484
    (cfi->device_geometry.erase_block_regions + j)->number_of_erase_blocks = (uint32_t )table[i].regions[j].numblocks;
#line 481
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 488
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found %s flash,  size = %li bytes.\n",
          table[i].name, table[i].size);
  }
#line 490
  return (0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 52
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 54
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 62
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 62
  if (tmp != 0) {
#line 63
    return (0);
  }
#line 65
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 65
    goto _L;
  } else
#line 65
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 65
    if (area.width == 32U) {
#line 65
      tmp___0 = 1;
    } else {
#line 65
      tmp___0 = 0;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
#line 65
  return (tmp___0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 75
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 75
  if (tmp != 0) {
#line 76
    return (0);
  }
#line 78
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 78
    goto _L;
  } else
#line 78
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 78
    if (area.width == 16U) {
#line 78
      tmp___0 = 1;
    } else {
#line 78
      tmp___0 = 0;
    }
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  return (tmp___0);
}
}
#line 83 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 88
  if (tmp != 0) {
#line 89
    return (0);
  }
#line 91
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 91
    goto _L;
  } else
#line 91
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 91
    if (area.width == 8U) {
#line 91
      tmp___0 = 1;
    } else {
#line 91
      tmp___0 = 0;
    }
  } else {
#line 91
    tmp___0 = 0;
  }
#line 91
  return (tmp___0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void _intel_flash_print_info(cfi_array_t *cfi_array___0 , int o___1 ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 100
  bus___0 = cfi_array___0->bus;
#line 102
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 102
  mid = tmp & 255U;
  }
  {
#line 104
  if (mid == 137U) {
#line 104
    goto case_137;
  }
#line 107
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 105
  tmp___0 = gettext("Manufacturer: %s\n");
#line 105
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 106
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 108
  tmp___1 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 108
  printf((char const   */* __restrict  */)tmp___1, mid);
  }
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 112
  tmp___2 = gettext("Chip: ");
#line 112
  printf((char const   */* __restrict  */)tmp___2);
#line 113
  tmp___3 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o___1));
#line 113
  cid = tmp___3 & 65535U;
  }
  {
#line 115
  if (cid == 22U) {
#line 115
    goto case_22;
  }
#line 118
  if (cid == 23U) {
#line 118
    goto case_23;
  }
#line 121
  if (cid == 24U) {
#line 121
    goto case_24;
  }
#line 124
  if (cid == 29U) {
#line 124
    goto case_29;
  }
#line 127
  if (cid == 34817U) {
#line 127
    goto case_34817;
  }
#line 130
  if (cid == 34818U) {
#line 130
    goto case_34818;
  }
#line 133
  if (cid == 34819U) {
#line 133
    goto case_34819;
  }
#line 136
  if (cid == 34821U) {
#line 136
    goto case_34821;
  }
#line 139
  if (cid == 34822U) {
#line 139
    goto case_34822;
  }
#line 142
  if (cid == 34823U) {
#line 142
    goto case_34823;
  }
#line 145
  if (cid == 34827U) {
#line 145
    goto case_34827;
  }
#line 148
  if (cid == 34828U) {
#line 148
    goto case_34828;
  }
#line 151
  if (cid == 34829U) {
#line 151
    goto case_34829;
  }
#line 154
  if (cid == 34830U) {
#line 154
    goto case_34830;
  }
#line 157
  if (cid == 34831U) {
#line 157
    goto case_34831;
  }
#line 160
  if (cid == 34832U) {
#line 160
    goto case_34832;
  }
#line 163
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 116
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 117
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 119
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 120
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 122
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 123
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 125
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 126
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 128
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 129
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 131
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 132
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 134
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 135
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 137
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 138
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 140
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 141
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 143
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 144
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 147
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 149
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 150
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 152
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 153
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 155
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 156
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 158
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 159
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 161
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 162
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 164
  tmp___4 = gettext("Unknown (0x%02X)!\n");
#line 164
  printf((char const   */* __restrict  */)tmp___4, cid);
  }
#line 165
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 169
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 170
  return;
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int o___1 ;
  bus_t *bus___0 ;

  {
  {
#line 175
  o___1 = 1;
#line 176
  bus___0 = cfi_array___0->bus;
#line 182
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 185
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 187
  _intel_flash_print_info(cfi_array___0, o___1);
  }
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_print_info32(cfi_array_t *cfi_array___0 ) 
{ 
  int o___1 ;
  bus_t *bus___0 ;

  {
  {
#line 193
  o___1 = 2;
#line 194
  bus___0 = cfi_array___0->bus;
#line 199
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 202
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 204
  _intel_flash_print_info(cfi_array___0, o___1);
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 211
  bus___0 = cfi_array___0->bus;
#line 213
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 214
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 215
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 217
    sr = (uint16_t )(tmp & 254U);
    }
#line 217
    if ((int )sr & (1 << 7)) {
#line 217
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 220
    goto case_0;
  }
#line 222
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 222
    goto case_exp;
  }
#line 225
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 225
    goto case_exp___0;
  }
#line 228
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 228
    goto case_exp___1;
  }
#line 231
  goto switch_default;
  case_0: /* CIL Label */ 
#line 221
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 223
  tmp___0 = gettext("flash: invalid command seq\n");
#line 223
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 224
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 226
  tmp___1 = gettext("flash: low vpen\n");
#line 226
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 227
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 229
  tmp___2 = gettext("flash: block locked\n");
#line 229
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 230
  return (3);
  switch_default: /* CIL Label */ 
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 235
  return (99);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 242
  bus___0 = cfi_array___0->bus;
#line 244
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 245
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 246
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 248
    sr = (uint16_t )(tmp & 254U);
    }
#line 248
    if ((int )sr & (1 << 7)) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if ((int )sr != 1 << 7) {
    {
#line 251
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 251
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 252
    return (99);
  } else {
#line 254
    return (0);
  }
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 261
  bus___0 = cfi_array___0->bus;
#line 263
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 264
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 265
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 267
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 267
    sr = (uint16_t )(tmp & 254U);
    }
#line 267
    if ((int )sr & (1 << 7)) {
#line 267
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if ((int )sr != 1 << 7) {
    {
#line 270
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 270
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 271
    return (99);
  } else {
#line 273
    return (0);
  }
}
}
#line 276 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 280
  bus___0 = cfi_array___0->bus;
#line 282
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 283
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 284
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 286
    sr = tmp & 16646398U;
    }
#line 286
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 289
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 290
    return (99);
  } else {
#line 292
    return (0);
  }
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 299
  bus___0 = cfi_array___0->bus;
#line 301
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 302
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 303
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 305
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 305
    sr = tmp & 16646398U;
    }
#line 305
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 305
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 308
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 309
    return (99);
  } else {
#line 311
    return (0);
  }
}
}
#line 314 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 318
  bus___0 = cfi_array___0->bus;
#line 320
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 321
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 322
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 324
    sr = tmp & 16646398U;
    }
#line 324
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 324
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 327
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 328
    return (99);
  } else {
#line 330
    return (0);
  }
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_readarray32(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 337
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 338
  return;
}
}
#line 340 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_readarray(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 344
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 345
  return;
}
}
#line 347 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
flash_driver_t intel_32_flash_driver  = 
#line 347
     {4U, "Intel Standard Command Set", "supported: 28Fxxxx, 2 x 16 bit", & intel_flash_autodetect32,
    & intel_flash_print_info32, & intel_flash_erase_block32, & intel_flash_unlock_block32,
    & intel_flash_program32, & intel_flash_readarray32};
#line 359 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
flash_driver_t intel_16_flash_driver  = 
#line 359
     {2U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 16 bit", & intel_flash_autodetect,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 371 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
flash_driver_t intel_8_flash_driver  = 
#line 371
     {1U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 8 bit", & intel_flash_autodetect8,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 44 "./../inclow/brux/cmd.h"
cmd_t const   *cmds[35] ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/help.c"
static int cmd_help_run(char **params ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 38
  if (! *(params + 1)) {
    {
#line 39
    tmp = gettext("Command list:\n\n");
#line 39
    printf((char const   */* __restrict  */)tmp);
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! cmds[i]) {
#line 40
        goto while_break;
      }
#line 41
      if ((cmds[i])->desc) {
        {
#line 41
        tmp___0 = gettext((char const   *)(cmds[i])->desc);
#line 41
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 41
        tmp___1 = gettext("(no description available)");
#line 41
        tmp___2 = tmp___1;
        }
      }
      {
#line 41
      tmp___3 = gettext("%-13s %s\n");
#line 41
      printf((char const   */* __restrict  */)tmp___3, (cmds[i])->name, tmp___2);
#line 40
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    tmp___4 = gettext("\nType \"help COMMAND\" for details about a particular command.\n");
#line 42
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 43
    return (1);
  }
#line 46
  if (*(params + 2)) {
#line 47
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! cmds[i]) {
#line 50
      goto while_break___0;
    }
    {
#line 51
    tmp___5 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 1));
    }
#line 51
    if (tmp___5 == 0) {
#line 52
      if ((cmds[i])->help) {
        {
#line 53
        (*((cmds[i])->help))();
        }
      }
#line 54
      return (1);
    }
#line 50
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  tmp___6 = gettext("%s: unknown command\n");
#line 57
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 59
  return (1);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/help.c"
static void cmd_help_help(void) 
{ 
  char *tmp ;

  {
  {
#line 65
  tmp = gettext("Usage: %s [COMMAND]\nPrint short help for COMMAND, or list of available commands.\n");
#line 65
  printf((char const   */* __restrict  */)tmp, "help");
  }
#line 69
  return;
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/help.c"
cmd_t cmd_help  =    {(char *)"help", (char *)"display this help", & cmd_help_help, & cmd_help_run};
#line 54 "./../inclow/brux/cfi.h"
void cfi_array_free(cfi_array_t *cfi_array___0 ) ;
#line 55
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 61 "./../inclow/brux/flash.h"
void detectflash(bus_t *bus___0 , uint32_t adr ) ;
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/detectflash.c"
cfi_array_t *cfi_array  =    (cfi_array_t *)((void *)0);
#line 47
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/detectflash.c"
void detectflash(bus_t *bus___0 , uint32_t adr ) 
{ 
  cfi_query_structure_t *cfi ;
  char const   *s ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 55
  if (! bus___0) {
    {
#line 56
    tmp = gettext("Error: Missing bus driver!\n");
#line 56
    printf((char const   */* __restrict  */)tmp);
    }
#line 57
    return;
  }
  {
#line 60
  cfi_array_free(cfi_array);
#line 61
  cfi_array = (cfi_array_t *)((void *)0);
#line 63
  (*((bus___0->driver)->prepare))(bus___0);
#line 65
  tmp___3 = cfi_detect(bus___0, adr, & cfi_array);
  }
#line 65
  if (tmp___3) {
    {
#line 66
    cfi_array_free(cfi_array);
#line 67
    cfi_array = (cfi_array_t *)((void *)0);
#line 68
    tmp___2 = jedec_detect(bus___0, adr, & cfi_array);
    }
#line 68
    if (tmp___2 != 0) {
      {
#line 69
      cfi_array_free(cfi_array);
#line 70
      tmp___1 = amd_detect(bus___0, adr, & cfi_array);
      }
#line 70
      if (tmp___1 != 0) {
        {
#line 72
        cfi_array_free(cfi_array);
#line 73
        cfi_array->bus_width = 1;
#line 74
        cfi_array = (cfi_array_t *)((void *)0);
#line 75
        tmp___0 = gettext("Flash not found!\n");
#line 75
        printf((char const   */* __restrict  */)tmp___0);
        }
#line 76
        return;
      }
    }
  }
  {
#line 81
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 86
  tmp___4 = gettext("Query identification string:\n");
#line 86
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 89
  if ((int )cfi->identification_string.pri_id_code == 0) {
#line 89
    goto case_0;
  }
#line 92
  if ((int )cfi->identification_string.pri_id_code == 1) {
#line 92
    goto case_1;
  }
#line 95
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 95
    goto case_2;
  }
#line 98
  if ((int )cfi->identification_string.pri_id_code == 3) {
#line 98
    goto case_3;
  }
#line 101
  if ((int )cfi->identification_string.pri_id_code == 4) {
#line 101
    goto case_4;
  }
#line 104
  if ((int )cfi->identification_string.pri_id_code == 256) {
#line 104
    goto case_256;
  }
#line 107
  if ((int )cfi->identification_string.pri_id_code == 257) {
#line 107
    goto case_257;
  }
#line 110
  if ((int )cfi->identification_string.pri_id_code == 258) {
#line 110
    goto case_258;
  }
#line 113
  goto switch_default;
  case_0: /* CIL Label */ 
#line 90
  s = "null";
#line 91
  goto switch_break;
  case_1: /* CIL Label */ 
#line 93
  s = "Intel/Sharp Extended Command Set";
#line 94
  goto switch_break;
  case_2: /* CIL Label */ 
#line 96
  s = "AMD/Fujitsu Standard Command Set";
#line 97
  goto switch_break;
  case_3: /* CIL Label */ 
#line 99
  s = "Intel Standard Command Set";
#line 100
  goto switch_break;
  case_4: /* CIL Label */ 
#line 102
  s = "AMD/Fujitsu Extended Command Set";
#line 103
  goto switch_break;
  case_256: /* CIL Label */ 
#line 105
  s = "Mitsubishi Standard Command Set";
#line 106
  goto switch_break;
  case_257: /* CIL Label */ 
#line 108
  s = "Mitsubishi Extended Command Set";
#line 109
  goto switch_break;
  case_258: /* CIL Label */ 
#line 111
  s = "Page Write Command Set";
#line 112
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 114
  s = "unknown!!!";
#line 115
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 117
  tmp___5 = gettext(s);
#line 117
  tmp___6 = gettext("\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 117
  printf((char const   */* __restrict  */)tmp___6, (int )cfi->identification_string.pri_id_code,
         tmp___5);
  }
  {
#line 119
  if ((int )cfi->identification_string.alt_id_code == 0) {
#line 119
    goto case_0___0;
  }
#line 122
  if ((int )cfi->identification_string.alt_id_code == 1) {
#line 122
    goto case_1___0;
  }
#line 125
  if ((int )cfi->identification_string.alt_id_code == 2) {
#line 125
    goto case_2___0;
  }
#line 128
  if ((int )cfi->identification_string.alt_id_code == 3) {
#line 128
    goto case_3___0;
  }
#line 131
  if ((int )cfi->identification_string.alt_id_code == 4) {
#line 131
    goto case_4___0;
  }
#line 134
  if ((int )cfi->identification_string.alt_id_code == 256) {
#line 134
    goto case_256___0;
  }
#line 137
  if ((int )cfi->identification_string.alt_id_code == 257) {
#line 137
    goto case_257___0;
  }
#line 140
  if ((int )cfi->identification_string.alt_id_code == 258) {
#line 140
    goto case_258___0;
  }
#line 143
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 120
  s = "null";
#line 121
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 123
  s = "Intel/Sharp Extended Command Set";
#line 124
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 126
  s = "AMD/Fujitsu Standard Command Set";
#line 127
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 129
  s = "Intel Standard Command Set";
#line 130
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 132
  s = "AMD/Fujitsu Extended Command Set";
#line 133
  goto switch_break___0;
  case_256___0: /* CIL Label */ 
#line 135
  s = "Mitsubishi Standard Command Set";
#line 136
  goto switch_break___0;
  case_257___0: /* CIL Label */ 
#line 138
  s = "Mitsubishi Extended Command Set";
#line 139
  goto switch_break___0;
  case_258___0: /* CIL Label */ 
#line 141
  s = "Page Write Command Set";
#line 142
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 144
  s = "unknown!!!";
#line 145
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 147
  tmp___7 = gettext(s);
#line 147
  tmp___8 = gettext("\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 147
  printf((char const   */* __restrict  */)tmp___8, (int )cfi->identification_string.alt_id_code,
         tmp___7);
#line 150
  tmp___9 = gettext("Query system interface information:\n");
#line 150
  printf((char const   */* __restrict  */)tmp___9);
#line 151
  tmp___10 = gettext("\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n");
#line 151
  printf((char const   */* __restrict  */)tmp___10, (int )cfi->system_interface_info.vcc_min_wev);
#line 152
  tmp___11 = gettext("\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n");
#line 152
  printf((char const   */* __restrict  */)tmp___11, (int )cfi->system_interface_info.vcc_max_wev);
#line 153
  tmp___12 = gettext("\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n");
#line 153
  printf((char const   */* __restrict  */)tmp___12, (int )cfi->system_interface_info.vpp_min_wev);
#line 154
  tmp___13 = gettext("\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n");
#line 154
  printf((char const   */* __restrict  */)tmp___13, (int )cfi->system_interface_info.vpp_max_wev);
#line 155
  tmp___14 = gettext("\tTypical timeout per single byte/word program: %d us\n");
#line 155
  printf((char const   */* __restrict  */)tmp___14, cfi->system_interface_info.typ_single_write_timeout);
#line 156
  tmp___15 = gettext("\tTypical timeout for maximum-size multi-byte program: %d us\n");
#line 156
  printf((char const   */* __restrict  */)tmp___15, cfi->system_interface_info.typ_buffer_write_timeout);
#line 157
  tmp___16 = gettext("\tTypical timeout per individual block erase: %d ms\n");
#line 157
  printf((char const   */* __restrict  */)tmp___16, cfi->system_interface_info.typ_block_erase_timeout);
#line 158
  tmp___17 = gettext("\tTypical timeout for full chip erase: %d ms\n");
#line 158
  printf((char const   */* __restrict  */)tmp___17, cfi->system_interface_info.typ_chip_erase_timeout);
#line 159
  tmp___18 = gettext("\tMaximum timeout for byte/word program: %d us\n");
#line 159
  printf((char const   */* __restrict  */)tmp___18, cfi->system_interface_info.max_single_write_timeout);
#line 160
  tmp___19 = gettext("\tMaximum timeout for multi-byte program: %d us\n");
#line 160
  printf((char const   */* __restrict  */)tmp___19, cfi->system_interface_info.max_buffer_write_timeout);
#line 161
  tmp___20 = gettext("\tMaximum timeout per individual block erase: %d ms\n");
#line 161
  printf((char const   */* __restrict  */)tmp___20, cfi->system_interface_info.max_block_erase_timeout);
#line 162
  tmp___21 = gettext("\tMaximum timeout for chip erase: %d ms\n");
#line 162
  printf((char const   */* __restrict  */)tmp___21, cfi->system_interface_info.max_chip_erase_timeout);
#line 165
  tmp___22 = gettext("Device geometry definition:\n");
#line 165
  printf((char const   */* __restrict  */)tmp___22);
#line 166
  tmp___23 = gettext("\tDevice Size: %d B (%d KiB, %d MiB)\n");
#line 166
  printf((char const   */* __restrict  */)tmp___23, cfi->device_geometry.device_size,
         cfi->device_geometry.device_size / 1024U, cfi->device_geometry.device_size / 1048576U);
  }
  {
#line 172
  if ((int )cfi->device_geometry.device_interface == 0) {
#line 172
    goto case_0___1;
  }
#line 175
  if ((int )cfi->device_geometry.device_interface == 1) {
#line 175
    goto case_1___1;
  }
#line 178
  if ((int )cfi->device_geometry.device_interface == 2) {
#line 178
    goto case_2___1;
  }
#line 181
  if ((int )cfi->device_geometry.device_interface == 3) {
#line 181
    goto case_3___1;
  }
#line 184
  if ((int )cfi->device_geometry.device_interface == 4) {
#line 184
    goto case_4___1;
  }
#line 187
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 173
  s = "x8";
#line 174
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 176
  s = "x16";
#line 177
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 179
  s = "x8/x16";
#line 180
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 182
  s = "x32";
#line 183
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 185
  s = "x16/x32";
#line 186
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 188
  s = "unknown!!!";
#line 189
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 191
  tmp___24 = gettext(s);
#line 191
  tmp___25 = gettext("\tFlash Device Interface Code description: 0x%04X (%s)\n");
#line 191
  printf((char const   */* __restrict  */)tmp___25, (int )cfi->device_geometry.device_interface,
         tmp___24);
#line 192
  tmp___26 = gettext("\tMaximum number of bytes in multi-byte program: %d\n");
#line 192
  printf((char const   */* __restrict  */)tmp___26, cfi->device_geometry.max_bytes_write);
#line 193
  tmp___27 = gettext("\tNumber of Erase Block Regions within device: %d\n");
#line 193
  printf((char const   */* __restrict  */)tmp___27, (int )cfi->device_geometry.number_of_erase_regions);
#line 194
  tmp___28 = gettext("\tErase Block Region Information:\n");
#line 194
  printf((char const   */* __restrict  */)tmp___28);
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 198
      goto while_break;
    }
    {
#line 199
    tmp___29 = gettext("\t\tRegion %d:\n");
#line 199
    printf((char const   */* __restrict  */)tmp___29, i);
#line 200
    tmp___30 = gettext("\t\t\tErase Block Size: %d B (%d KiB)\n");
#line 200
    printf((char const   */* __restrict  */)tmp___30, (cfi->device_geometry.erase_block_regions + i)->erase_block_size,
           (cfi->device_geometry.erase_block_regions + i)->erase_block_size / 1024U);
#line 203
    tmp___31 = gettext("\t\t\tNumber of Erase Blocks: %d\n");
#line 203
    printf((char const   */* __restrict  */)tmp___31, (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 198
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 47 "./../inclow/brux/cmd.h"
int cmd_params(char **params ) ;
#line 48
int cmd_get_number(char *s , unsigned int *i ) ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd.c"
int cmd_run(char **params ) 
{ 
  int i ;
  int r ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 37
  if (! *(params + 0)) {
#line 38
    return (1);
  }
#line 40
  i = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! cmds[i]) {
#line 40
      goto while_break;
    }
    {
#line 41
    tmp___1 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0));
    }
#line 41
    if (tmp___1 == 0) {
      {
#line 42
      tmp = (*((cmds[i])->run))(params);
#line 42
      r = tmp;
      }
#line 43
      if (r < 0) {
        {
#line 44
        tmp___0 = gettext("%s: syntax error!\n");
#line 44
        printf((char const   */* __restrict  */)tmp___0, *(params + 0));
        }
      }
#line 45
      return (r);
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  tmp___2 = gettext("%s: unknown command\n");
#line 48
  printf((char const   */* __restrict  */)tmp___2, *(params + 0));
  }
#line 49
  return (1);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd.c"
int cmd_params(char **params ) 
{ 
  int i ;

  {
#line 55
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! *(params + i)) {
#line 57
      goto while_break;
    }
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (i);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd.c"
int cmd_get_number(char *s , unsigned int *i ) 
{ 
  int n ;
  int r ;
  size_t l ;

  {
#line 70
  if (! s) {
#line 71
    return (-1);
  } else
#line 70
  if (! i) {
#line 71
    return (-1);
  }
  {
#line 73
  l = strlen((char const   *)s);
#line 75
  n = -1;
#line 76
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"0x%x%n",
             i, & n);
  }
#line 77
  if (r == 1) {
#line 77
    if ((size_t )n == l) {
#line 78
      return (0);
    }
  }
  {
#line 80
  n = -1;
#line 81
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%u%n",
             i, & n);
  }
#line 82
  if (r == 1) {
#line 82
    if ((size_t )n == l) {
#line 83
      return (0);
    }
  }
#line 85
  return (-1);
}
}
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd_detectflash.c"
static int cmd_detectflash_run(char **params ) 
{ 
  uint32_t adr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp != 2) {
#line 38
    return (-1);
  }
#line 40
  if (! bus) {
    {
#line 41
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 41
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 42
    return (1);
  }
  {
#line 45
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 45
  if (tmp___1) {
#line 46
    return (-1);
  }
  {
#line 48
  detectflash(bus, adr);
  }
#line 50
  return (1);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd_detectflash.c"
static void cmd_detectflash_help(void) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("Usage: %s ADDRESS\nDetect flash memory type connected to a part.\n\nADDRESS    Base address for memory region\n");
#line 56
  printf((char const   */* __restrict  */)tmp, "detectflash");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd_detectflash.c"
cmd_t cmd_detectflash  =    {(char *)"detectflash", (char *)"detect parameters of flash chips attached to a part",
    & cmd_detectflash_help, & cmd_detectflash_run};
#line 40 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/cfi.c"
void cfi_array_free(cfi_array_t *cfi_array___0 ) 
{ 
  int i ;

  {
#line 43
  if (! cfi_array___0) {
#line 44
    return;
  }
#line 46
  if (cfi_array___0->cfi_chips) {
#line 49
    i = 0;
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      if (! (i < cfi_array___0->bus_width)) {
#line 49
        goto while_break;
      }
#line 50
      if (! *(cfi_array___0->cfi_chips + i)) {
#line 51
        goto __Cont;
      }
      {
#line 53
      free((void *)(*(cfi_array___0->cfi_chips + i))->cfi.device_geometry.erase_block_regions);
#line 54
      free((void *)*(cfi_array___0->cfi_chips + i));
      }
      __Cont: /* CIL Label */ 
#line 49
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 56
    free((void *)cfi_array___0->cfi_chips);
    }
  }
  {
#line 59
  free((void *)cfi_array___0);
  }
#line 60
  return;
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/cfi.c"
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  unsigned int bw ;
  unsigned int d ;
  int ba ;
  int ma ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  cfi_query_structure_t *cfi ;
  uint32_t tmp___2 ;
  int ret ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;
  uint32_t tmp___21 ;
  int tmp___22 ;
  uint32_t tmp___23 ;
  int tmp___24 ;
  uint32_t tmp___25 ;
  int tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint8_t tmp___32 ;
  uint32_t tmp___33 ;
  void *tmp___34 ;
  int a ;
  int i ;
  uint32_t y ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t z ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;

  {
#line 71
  if (! cfi_array___0) {
#line 72
    return (-1);
  } else
#line 71
  if (! bus___0) {
#line 72
    return (-1);
  }
  {
#line 74
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 74
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 75
  if (! *cfi_array___0) {
#line 76
    return (-2);
  }
  {
#line 78
  (*cfi_array___0)->bus = bus___0;
#line 79
  (*cfi_array___0)->address = adr;
#line 80
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 80
  if (tmp___0 != 0) {
#line 81
    return (-8);
  }
#line 82
  bw = area.width;
#line 83
  if (bw != 8U) {
#line 83
    if (bw != 16U) {
#line 83
      if (bw != 32U) {
#line 84
        return (-3);
      }
    }
  }
  {
#line 85
  ba = (int )(bw / 8U);
#line 85
  (*cfi_array___0)->bus_width = ba;
#line 86
  tmp___1 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 86
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 87
  if (! (*cfi_array___0)->cfi_chips) {
#line 88
    return (-2);
  }
#line 90
  d = 0U;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (d < bw)) {
#line 90
      goto while_break;
    }
#line 100
    ret = -4;
#line 103
    ma = 1;
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! (ma <= 4)) {
#line 103
        goto while_break___0;
      }
      {
#line 104
      (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )((85 * ba) * ma), (uint32_t )(152 << d));
#line 106
      tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((16 * ba) * ma));
      }
#line 106
      if (((tmp___4 >> d) & 255U) == 81U) {
        {
#line 107
        ret = -5;
#line 108
        tmp___3 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((17 * ba) * ma));
        }
#line 108
        if (((tmp___3 >> d) & 255U) == 82U) {
#line 109
          goto while_break___0;
        }
      }
      {
#line 112
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
#line 103
      ma *= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    if (ma > 4) {
#line 116
      return (ret);
    }
    {
#line 118
    tmp___5 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((18 * ba) * ma));
    }
#line 118
    if (((tmp___5 >> d) & 255U) != 89U) {
      {
#line 119
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 120
      return (-6);
    }
    {
#line 123
    tmp___6 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 123
    *((*cfi_array___0)->cfi_chips + d / 8U) = (cfi_chip_t *)tmp___6;
    }
#line 124
    if (! *((*cfi_array___0)->cfi_chips + d / 8U)) {
      {
#line 125
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 126
      return (-2);
    }
    {
#line 128
    cfi = & (*((*cfi_array___0)->cfi_chips + d / 8U))->cfi;
#line 131
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((19 * ba) * ma));
#line 131
    tmp___7 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((20 * ba) * ma));
#line 131
    tmp___8 = (*((bus___0->driver)->read_end))(bus___0);
#line 131
    cfi->identification_string.pri_id_code = (uint16_t )(((tmp___7 >> d) & 255U) | (((tmp___8 >> d) & 255U) << 8));
#line 132
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 133
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((23 * ba) * ma));
#line 133
    tmp___9 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((24 * ba) * ma));
#line 133
    tmp___10 = (*((bus___0->driver)->read_end))(bus___0);
#line 133
    cfi->identification_string.alt_id_code = (uint16_t )(((tmp___9 >> d) & 255U) | (((tmp___10 >> d) & 255U) << 8));
#line 134
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 137
    tmp___11 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((27 * ba) * ma));
#line 137
    tmp___2 = (tmp___11 >> d) & 255U;
#line 138
    cfi->system_interface_info.vcc_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 139
    tmp___12 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((28 * ba) * ma));
#line 139
    tmp___2 = (tmp___12 >> d) & 255U;
#line 140
    cfi->system_interface_info.vcc_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 141
    tmp___13 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((29 * ba) * ma));
#line 141
    tmp___2 = (tmp___13 >> d) & 255U;
#line 142
    cfi->system_interface_info.vpp_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 143
    tmp___14 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((30 * ba) * ma));
#line 143
    tmp___2 = (tmp___14 >> d) & 255U;
#line 144
    cfi->system_interface_info.vpp_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 147
    tmp___15 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((31 * ba) * ma));
#line 147
    tmp___2 = (tmp___15 >> d) & 255U;
    }
#line 148
    if (tmp___2) {
#line 148
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 148
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )0;
    }
    {
#line 150
    tmp___16 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((32 * ba) * ma));
#line 150
    tmp___2 = (tmp___16 >> d) & 255U;
    }
#line 151
    if (tmp___2) {
#line 151
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 151
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )0;
    }
    {
#line 153
    tmp___17 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((33 * ba) * ma));
#line 153
    tmp___2 = (tmp___17 >> d) & 255U;
    }
#line 154
    if (tmp___2) {
#line 154
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 154
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )0;
    }
    {
#line 156
    tmp___18 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((34 * ba) * ma));
#line 156
    tmp___2 = (tmp___18 >> d) & 255U;
    }
#line 157
    if (tmp___2) {
#line 157
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 157
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )0;
    }
    {
#line 159
    tmp___19 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((35 * ba) * ma));
#line 159
    tmp___2 = (tmp___19 >> d) & 255U;
    }
#line 160
    if (tmp___2) {
#line 160
      tmp___20 = 1 << tmp___2;
    } else {
#line 160
      tmp___20 = 0;
    }
    {
#line 160
    cfi->system_interface_info.max_single_write_timeout = (uint32_t )tmp___20 * cfi->system_interface_info.typ_single_write_timeout;
#line 163
    tmp___21 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((36 * ba) * ma));
#line 163
    tmp___2 = (tmp___21 >> d) & 255U;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___22 = 1 << tmp___2;
    } else {
#line 164
      tmp___22 = 0;
    }
    {
#line 164
    cfi->system_interface_info.max_buffer_write_timeout = (uint32_t )tmp___22 * cfi->system_interface_info.typ_buffer_write_timeout;
#line 167
    tmp___23 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((37 * ba) * ma));
#line 167
    tmp___2 = (tmp___23 >> d) & 255U;
    }
#line 168
    if (tmp___2) {
#line 168
      tmp___24 = 1 << tmp___2;
    } else {
#line 168
      tmp___24 = 0;
    }
    {
#line 168
    cfi->system_interface_info.max_block_erase_timeout = (uint32_t )tmp___24 * cfi->system_interface_info.typ_block_erase_timeout;
#line 171
    tmp___25 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((38 * ba) * ma));
#line 171
    tmp___2 = (tmp___25 >> d) & 255U;
    }
#line 172
    if (tmp___2) {
#line 172
      tmp___26 = 1 << tmp___2;
    } else {
#line 172
      tmp___26 = 0;
    }
    {
#line 172
    cfi->system_interface_info.max_chip_erase_timeout = (uint32_t )tmp___26 * cfi->system_interface_info.typ_chip_erase_timeout;
#line 177
    tmp___27 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((39 * ba) * ma));
#line 177
    cfi->device_geometry.device_size = (uint32_t )(1 << ((tmp___27 >> d) & 255U));
#line 179
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((40 * ba) * ma));
#line 179
    tmp___28 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((41 * ba) * ma));
#line 179
    tmp___29 = (*((bus___0->driver)->read_end))(bus___0);
#line 179
    cfi->device_geometry.device_interface = (uint16_t )(((tmp___28 >> d) & 255U) | (((tmp___29 >> d) & 255U) << 8));
#line 182
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((42 * ba) * ma));
#line 182
    tmp___30 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((43 * ba) * ma));
#line 182
    tmp___31 = (*((bus___0->driver)->read_end))(bus___0);
#line 182
    cfi->device_geometry.max_bytes_write = (uint32_t )(1 << (((tmp___30 >> d) & 255U) | (((tmp___31 >> d) & 255U) << 8)));
#line 184
    tmp___33 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((44 * ba) * ma));
#line 184
    tmp___32 = (uint8_t )((tmp___33 >> d) & 255U);
#line 184
    cfi->device_geometry.number_of_erase_regions = tmp___32;
#line 184
    tmp___2 = (uint32_t )tmp___32;
#line 186
    tmp___34 = malloc((unsigned long )tmp___2 * sizeof(cfi_erase_block_region_t ));
#line 186
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___34;
    }
#line 187
    if (! cfi->device_geometry.erase_block_regions) {
      {
#line 188
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 189
      return (-2);
    }
#line 196
    i = 0;
#line 196
    a = 45;
    {
#line 196
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 196
      if (! ((uint32_t )i < tmp___2)) {
#line 196
        goto while_break___1;
      }
      {
#line 197
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((a * ba) * ma));
#line 197
      tmp___35 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )(((a + 1) * ba) * ma));
#line 197
      tmp___36 = (*((bus___0->driver)->read_end))(bus___0);
#line 197
      y = ((tmp___35 >> d) & 255U) | (((tmp___36 >> d) & 255U) << 8);
#line 198
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )(((a + 2) * ba) * ma));
#line 198
      tmp___37 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((((a + 2) + 1) * ba) * ma));
#line 198
      tmp___38 = (*((bus___0->driver)->read_end))(bus___0);
#line 198
      z = (((tmp___37 >> d) & 255U) | (((tmp___38 >> d) & 255U) << 8)) << 8;
      }
#line 199
      if (z == 0U) {
#line 200
        z = (uint32_t )128;
      }
#line 201
      (cfi->device_geometry.erase_block_regions + i)->erase_block_size = z;
#line 202
      (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = y + 1U;
#line 196
      i ++;
#line 196
      a += 4;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 209
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
    }
    {
#line 219
    if ((int )cfi->device_geometry.device_interface == 0) {
#line 219
      goto case_0;
    }
#line 224
    if ((int )cfi->device_geometry.device_interface == 1) {
#line 224
      goto case_1;
    }
#line 230
    if ((int )cfi->device_geometry.device_interface == 2) {
#line 230
      goto case_2;
    }
#line 237
    if ((int )cfi->device_geometry.device_interface == 3) {
#line 237
      goto case_3;
    }
#line 243
    if ((int )cfi->device_geometry.device_interface == 4) {
#line 243
      goto case_4;
    }
#line 252
    goto switch_default;
    case_0: /* CIL Label */ 
#line 220
    if (ma != 1) {
#line 221
      return (-7);
    }
#line 222
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 1;
#line 223
    goto switch_break;
    case_1: /* CIL Label */ 
#line 225
    if (ma != 1) {
#line 226
      return (-7);
    }
#line 227
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2;
#line 228
    d += 8U;
#line 229
    goto switch_break;
    case_2: /* CIL Label */ 
#line 231
    if (ma != 1) {
#line 231
      if (ma != 2) {
#line 232
        return (-7);
      }
    }
#line 233
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2 / ma;
#line 234
    if (ma == 1) {
#line 235
      d += 8U;
    }
#line 236
    goto switch_break;
    case_3: /* CIL Label */ 
#line 238
    if (ma != 1) {
#line 239
      return (-7);
    }
#line 240
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4;
#line 241
    d += 24U;
#line 242
    goto switch_break;
    case_4: /* CIL Label */ 
#line 244
    if (ma != 1) {
#line 244
      if (ma != 2) {
#line 245
        return (-7);
      }
    }
#line 246
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4 / ma;
#line 247
    if (ma == 1) {
#line 248
      d += 24U;
    } else {
#line 250
      d += 8U;
    }
#line 251
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 253
    return (-7);
    switch_break: /* CIL Label */ ;
    }
#line 90
    d += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (0);
}
}
#line 463 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int dbg  =    0;
#line 49
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 52
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int o  ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 60
  if (cfi_array___0->bus_width != 4) {
#line 60
    return (0);
  }
#line 61
  o = 2;
#line 62
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect16(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 68
  if (cfi_array___0->bus_width != 2) {
#line 68
    return (0);
  }
#line 69
  o = 1;
#line 70
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 76
  if (cfi_array___0->bus_width != 1) {
#line 76
    return (0);
  }
#line 77
  o = 0;
#line 78
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amdstatus(bus_t *bus___0 , uint32_t adr , int data ) 
{ 
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;

  {
#line 128
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 131
  timeout = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (timeout < 100)) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 132
    data1 = tmp;
#line 133
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 133
    data2 = tmp___0;
    }
#line 137
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 138
      return (1);
    }
#line 142
    if (dbg) {
      {
#line 143
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    } else {
      {
#line 145
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 146
    usleep((__useconds_t )100);
#line 131
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (0);
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static void amd_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 223
  bus___0 = cfi_array___0->bus;
#line 225
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 226
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 227
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 228
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 228
  mid = (int )(tmp & 65535U);
#line 229
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 229
  cid = (int )(tmp___0 & 65535U);
#line 230
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 230
  prot = (int )(tmp___1 & 255U);
#line 231
  amd_flash_read_array(cfi_array___0);
#line 232
  tmp___2 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 232
  printf((char const   */* __restrict  */)tmp___2);
  }
  {
#line 234
  if (mid == 1) {
#line 234
    goto case_1;
  }
#line 237
  if (mid == 32) {
#line 237
    goto case_32;
  }
#line 240
  if (mid == 44) {
#line 240
    goto case_44;
  }
#line 243
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 235
  tmp___3 = gettext("AMD");
#line 235
  printf((char const   */* __restrict  */)tmp___3);
  }
#line 236
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 238
  tmp___4 = gettext("ST/Samsung");
#line 238
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 239
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 241
  tmp___5 = gettext("Macronix");
#line 241
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 242
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 244
  tmp___6 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 244
  printf((char const   */* __restrict  */)tmp___6, mid);
  }
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 247
  tmp___7 = gettext("\n\tChip: ");
#line 247
  printf((char const   */* __restrict  */)tmp___7);
  }
  {
#line 249
  if (cid == 79) {
#line 249
    goto case_79;
  }
#line 252
  if (cid == 8919) {
#line 252
    goto case_8919;
  }
#line 255
  if (cid == 8795) {
#line 255
    goto case_8795;
  }
#line 258
  if (cid == 8777) {
#line 258
    goto case_8777;
  }
#line 261
  if (cid == 73) {
#line 261
    goto case_73;
  }
#line 264
  if (cid == 147) {
#line 264
    goto case_147;
  }
#line 267
  if (cid == 202) {
#line 267
    goto case_202;
  }
#line 270
  if (cid == 203) {
#line 270
    goto case_203;
  }
#line 273
  goto switch_default___0;
  case_79: /* CIL Label */ 
  {
#line 250
  tmp___8 = gettext("Am29LV040B");
#line 250
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 251
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 253
  tmp___9 = gettext("Am29LV640D/Am29LV641D/Am29LV642D");
#line 253
  printf((char const   */* __restrict  */)tmp___9);
  }
#line 254
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 256
  tmp___10 = gettext("Am29LV800B");
#line 256
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 257
  goto switch_break___0;
  case_8777: /* CIL Label */ 
  {
#line 259
  tmp___11 = gettext("MX29LV160B");
#line 259
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 260
  goto switch_break___0;
  case_73: /* CIL Label */ 
  {
#line 262
  tmp___12 = gettext("AM29LV160DB");
#line 262
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 263
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 265
  tmp___13 = gettext("Am29LV065D");
#line 265
  printf((char const   */* __restrict  */)tmp___13);
  }
#line 266
  goto switch_break___0;
  case_202: /* CIL Label */ 
  {
#line 268
  tmp___14 = gettext("M29W320DT");
#line 268
  printf((char const   */* __restrict  */)tmp___14);
  }
#line 269
  goto switch_break___0;
  case_203: /* CIL Label */ 
  {
#line 271
  tmp___15 = gettext("M29W320DB");
#line 271
  printf((char const   */* __restrict  */)tmp___15);
  }
#line 272
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 274
  tmp___16 = gettext("Unknown (ID 0x%04x)");
#line 274
  printf((char const   */* __restrict  */)tmp___16, cid);
  }
#line 275
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 277
  tmp___17 = gettext("\n\tProtected: %04x\n");
#line 277
  printf((char const   */* __restrict  */)tmp___17, prot);
#line 280
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 281
  return;
}
}
#line 283 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 286
  bus___0 = cfi_array___0->bus;
#line 288
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 292
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 293
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 294
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 295
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 296
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 297
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 299
  tmp = amdstatus(bus___0, adr, 65535);
  }
#line 299
  if (tmp) {
    {
#line 300
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 301
    amd_flash_read_array(cfi_array___0);
    }
#line 302
    return (0);
  }
  {
#line 304
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 306
  amd_flash_read_array(cfi_array___0);
  }
#line 308
  return (99);
}
}
#line 311 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 314
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 315
  return (0);
}
}
#line 318 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 322
  bus___0 = cfi_array___0->bus;
#line 324
  if (dbg) {
    {
#line 325
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 327
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 329
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 331
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 332
  status = amdstatus(bus___0, adr, (int )data);
  }
#line 335
  return (! status);
}
}
#line 338 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 342
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 343
  return;
}
}
#line 345 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
flash_driver_t amd_32_flash_driver  = 
#line 345
     {4U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit",
    & amd_flash_autodetect32, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 357 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
flash_driver_t amd_16_flash_driver  = 
#line 357
     {2U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV800B; 1x16 Bit", & amd_flash_autodetect16,
    & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block, & amd_flash_program,
    & amd_flash_read_array};
#line 369 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
flash_driver_t amd_8_flash_driver  = 
#line 369
     {1U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV160, AMD 29LV065D, AMD 29LV040B; 1x8 Bit",
    & amd_flash_autodetect8, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 var_forced_detection  ;
#line 78
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) ;
#line 79
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 80
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) ;
#line 81
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) ;
#line 82
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 83
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 84
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  bus_area_t area ;
  cfi_query_structure_t *cfi ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  unsigned int bw ;
  int ba ;
  int i ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 93
  if (! cfi_array___0) {
#line 94
    return (-1);
  } else
#line 93
  if (! bus___0) {
#line 94
    return (-1);
  }
  {
#line 96
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 96
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 97
  if (! *cfi_array___0) {
#line 98
    return (-2);
  }
  {
#line 100
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 101
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 102
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 103
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 104
  tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 104
  mid = (int )tmp___0;
#line 105
  tmp___1 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 105
  did = (int )tmp___1;
#line 106
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 108
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_detect", mid,
         did);
  }
#line 109
  if (mid != 1) {
#line 110
    return (-1);
  }
  {
#line 114
  if (did == 164) {
#line 114
    goto case_164;
  }
#line 117
  if (did == 79) {
#line 117
    goto case_79;
  }
#line 121
  goto switch_default;
  case_164: /* CIL Label */ 
#line 115
  var_forced_detection.flash = 1UL;
#line 116
  goto switch_break;
  case_79: /* CIL Label */ 
#line 118
  var_forced_detection.flash = 1UL;
#line 119
  var_forced_detection.algorithm = (unsigned short)1;
#line 120
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 125
  (*cfi_array___0)->bus = bus___0;
#line 126
  (*cfi_array___0)->address = (uint32_t )0;
#line 127
  tmp___2 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 127
  if (tmp___2 != 0) {
#line 128
    return (-8);
  }
#line 129
  bw = area.width;
#line 131
  if (bw != 8U) {
#line 131
    if (bw != 16U) {
#line 131
      if (bw != 32U) {
#line 132
        return (-3);
      }
    }
  }
  {
#line 133
  ba = (int )(bw / 8U);
#line 133
  (*cfi_array___0)->bus_width = ba;
#line 134
  tmp___3 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 134
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___3;
  }
#line 135
  if (! (*cfi_array___0)->cfi_chips) {
#line 136
    return (-2);
  }
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < ba)) {
#line 137
      goto while_break;
    }
    {
#line 139
    tmp___4 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 139
    *((*cfi_array___0)->cfi_chips + i) = (cfi_chip_t *)tmp___4;
    }
#line 140
    if (! *((*cfi_array___0)->cfi_chips + i)) {
#line 141
      return (-2);
    }
    {
#line 142
    (*((*cfi_array___0)->cfi_chips + i))->width = 1;
#line 143
    cfi = & (*((*cfi_array___0)->cfi_chips + i))->cfi;
#line 145
    cfi->identification_string.pri_id_code = (uint16_t )0;
#line 146
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 147
    cfi->identification_string.alt_id_code = (uint16_t )0;
#line 148
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 150
    cfi->device_geometry.device_size = (uint32_t )524288;
#line 151
    cfi->device_geometry.device_interface = (uint16_t )0;
#line 152
    cfi->device_geometry.max_bytes_write = (uint32_t )32;
#line 153
    cfi->device_geometry.number_of_erase_regions = (uint8_t )1;
#line 154
    tmp___5 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 154
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___5;
    }
#line 156
    if (! cfi->device_geometry.erase_block_regions) {
#line 157
      return (-2);
    }
#line 159
    (cfi->device_geometry.erase_block_regions + i)->erase_block_size = (uint32_t )65536;
#line 160
    (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = (uint32_t )8;
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (0);
}
}
#line 167 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 169
  return (var_forced_detection.flash == 1UL);
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 178
  dq7mask = (unsigned short )(1 << 7);
#line 179
  dq5mask = (unsigned short )(1 << 5);
#line 180
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 182
  timeout = (short)0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((int )timeout < 1000)) {
#line 182
      goto while_break;
    }
    {
#line 184
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 184
    data1 = (unsigned short )(tmp & 255U);
    }
#line 185
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 186
      return (1);
    }
#line 188
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 190
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 190
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 191
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 193
        return (1);
      } else {
#line 197
        return (0);
      }
    }
    {
#line 200
    usleep((__useconds_t )50);
#line 182
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (0);
}
}
#line 208 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 211
  bus___0 = cfi_array___0->bus;
#line 214
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 217
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 218
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 218
  mid = (int )tmp;
#line 219
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 219
  did = (int )tmp___0;
#line 220
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 220
  prot = (int )tmp___1;
#line 221
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 223
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 228
  if (mid == 1) {
#line 228
    goto case_1;
  }
#line 231
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 229
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 229
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 230
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 232
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 232
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp___4 = gettext("\n\tChip: ");
#line 235
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 237
  if (did == 164) {
#line 237
    goto case_164;
  }
#line 241
  if (did == 79) {
#line 241
    goto case_79;
  }
#line 245
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 238
  tmp___5 = gettext("Am29C040B\t-\t");
#line 238
  printf((char const   */* __restrict  */)tmp___5);
#line 239
  tmp___6 = gettext("5V Flash\n");
#line 239
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 240
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 242
  tmp___7 = gettext("Am29LV040B\t-\t");
#line 242
  printf((char const   */* __restrict  */)tmp___7);
#line 243
  tmp___8 = gettext("3V Flash\n");
#line 243
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 244
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 246
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 246
  printf((char const   */* __restrict  */)tmp___9, did);
  }
#line 247
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 249
  tmp___10 = gettext("\n\tProtected: %04x\n");
#line 249
  printf((char const   */* __restrict  */)tmp___10, prot);
  }
#line 250
  return;
}
}
#line 252 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 255
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 257
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 258
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 259
    usleep((__useconds_t )100);
#line 260
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 262
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 263
  return;
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 271
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 275
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 277
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 278
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 279
    usleep((__useconds_t )100);
#line 280
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 283
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 288
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 290
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 293
  tmp = amd_29xx040_status(bus___0, adr, (unsigned short)255);
  }
#line 293
  if (tmp) {
    {
#line 294
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 295
    amd_29xx040_read_array(cfi_array___0);
    }
#line 296
    return (1);
  }
  {
#line 298
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 300
  amd_29xx040_read_array(cfi_array___0);
  }
#line 302
  return (-5);
}
}
#line 305 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 308
  bus___0 = cfi_array___0->bus;
#line 312
  if ((int )var_forced_detection.algorithm == 1) {
#line 314
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 316
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 318
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 319
      usleep((__useconds_t )1000);
#line 320
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 325
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 326
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 329
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 330
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 331
  status = amd_29xx040_status(bus___0, adr, (unsigned short )data);
  }
#line 334
  return (! status);
}
}
#line 337 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 339
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 340
  return (0);
}
}
#line 344 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
flash_driver_t amd_29xx040_flash_driver  = 
#line 344
     {1U, "AMD Standard Command Set", "supported: AMD 29LV040B, 29C040B, 1x8 Bit", & amd_29xx040_autodetect,
    & amd_29xx040_print_info, & amd_29xx040_erase_block, & amd_29xx040_unlock_block,
    & amd_29xx040_program, & amd_29xx040_read_array};
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 49 "../../include/jtag.h"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/writemem.c"
static int cmd_writemem_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 4) {
#line 40
    return (-1);
  }
#line 42
  if (! bus) {
    {
#line 43
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 43
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 47
  if (tmp___1) {
#line 48
    return (-1);
  } else {
    {
#line 47
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 47
    if (tmp___2) {
#line 48
      return (-1);
    }
  }
  {
#line 50
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"r");
  }
#line 51
  if (! f) {
    {
#line 52
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 52
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 53
    return (1);
  }
  {
#line 55
  writemem(bus, f, adr, len);
#line 56
  fclose(f);
  }
#line 58
  return (1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/writemem.c"
static void cmd_writemem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nWrite to device memory starting at ADDR the FILENAME file.\n\nADDR       start address of the written memory area\nLEN        written memory length\nFILENAME   name of the input file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\nNOTE: This is NOT useful for FLASH programming!\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "writemem");
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/writemem.c"
cmd_t cmd_writemem  =    {(char *)"writemem", (char *)"write content of file to the memory", & cmd_writemem_help,
    & cmd_writemem_run};
#line 30 "../../include/cmd.h"
int cmd_test_cable(void) ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/test.c"
static int cmd_test_run(char **params ) 
{ 
  int data ;
  unsigned int i ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 44
  tmp = cmd_params(params);
  }
#line 44
  if (tmp != 4) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 47
  if (tmp___0 != 0) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___1 = cmd_test_cable();
  }
#line 50
  if (! tmp___1) {
#line 51
    return (1);
  }
#line 53
  if (! chain->parts) {
    {
#line 54
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 55
    return (1);
  }
#line 58
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 59
    tmp___3 = gettext("%s: no active part\n");
#line 59
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 60
    return (1);
  }
  {
#line 63
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 64
  if (! s) {
    {
#line 65
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 66
    return (1);
  }
  {
#line 72
  tmp___5 = cmd_get_number(*(params + 3), & i);
  }
#line 72
  if (tmp___5) {
#line 73
    return (1);
  }
  {
#line 75
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 76
  if (data != -1) {
#line 77
    if ((unsigned int )data != i) {
      {
#line 78
      tmp___6 = gettext("<FAIL>%s = %d\n");
#line 78
      printf((char const   */* __restrict  */)tmp___6, *(params + 2), data);
      }
#line 79
      return (-99);
    }
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/test.c"
static void cmd_test_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL 0/1\nTest signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/test.c"
cmd_t cmd_test  =    {(char *)"test", (char *)"test external signal value", & cmd_test_help, & cmd_test_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/svf.c"
static int cmd_svf_run(char **params ) 
{ 
  FILE *SVF_FILE ;
  int num_params ;
  int result ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 38
  result = -1;
#line 40
  num_params = cmd_params(params);
  }
#line 41
  if (num_params == 2) {
#line 41
    goto _L;
  } else
#line 41
  if (num_params == 3) {
    _L: /* CIL Label */ 
    {
#line 42
    SVF_FILE = fopen((char const   */* __restrict  */)*(params + 1), (char const   */* __restrict  */)"r");
    }
#line 42
    if ((unsigned long )SVF_FILE != (unsigned long )((void *)0)) {
#line 44
      if (num_params == 3) {
        {
#line 45
        tmp = strcasecmp((char const   *)*(params + 2), "stop");
        }
#line 45
        if (tmp == 0) {
          {
#line 46
          svf_run(SVF_FILE, 1);
#line 47
          result = 1;
          }
        }
      } else {
        {
#line 50
        svf_run(SVF_FILE, 0);
#line 51
        result = 1;
        }
      }
      {
#line 54
      fclose(SVF_FILE);
      }
    } else {
      {
#line 56
      tmp___0 = gettext("%s: cannot open file \'%s\' for reading\n");
#line 56
      printf((char const   */* __restrict  */)tmp___0, "svf", *(params + 1));
      }
    }
  }
#line 61
  return (result);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/svf.c"
static void cmd_svf_help(void) 
{ 
  char *tmp ;

  {
  {
#line 68
  tmp = gettext("Usage: %s FILE\nUsage: %s FILE stop\nExecute svf commands from FILE.\nCommand execution stops upon TDO mismatch when \'stop\' is specified.\n\nFILE file containing SVF commans\n");
#line 68
  printf((char const   */* __restrict  */)tmp, "svf", "svf");
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/svf.c"
cmd_t cmd_svf  =    {(char *)"svf", (char *)"execute svf commands from file", & cmd_svf_help, & cmd_svf_run};
#line 49 "../../include/bssignal.h"
signal_t *signal_alloc(char const   *name ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/signal.c"
static int cmd_signal_run(char **params ) 
{ 
  part_t *part___0 ;
  signal_t *s ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 42
  i = cmd_params(params);
  }
#line 42
  if (i < 2) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable();
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "signal");
    }
#line 56
    return (1);
  }
  {
#line 59
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 60
  s = part_find_signal(part___0, (char const   *)*(params + 1));
  }
#line 60
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 61
    if (i == 3) {
      {
#line 62
      printf((char const   */* __restrict  */)"Defining pin for signal %s\n", s->name);
      }
#line 64
      if (s->pin) {
        {
#line 64
        free((void *)s->pin);
        }
      }
      {
#line 67
      tmp___2 = strlen((char const   *)*(params + 2));
#line 67
      tmp___3 = malloc(tmp___2 + 1UL);
#line 67
      s->pin = (char *)tmp___3;
#line 68
      strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
      }
#line 70
      return (1);
    } else {
      {
#line 73
      tmp___4 = gettext("Signal \'%s\' already defined\n");
#line 73
      printf((char const   */* __restrict  */)tmp___4, *(params + 1));
      }
#line 74
      return (1);
    }
  }
  {
#line 78
  s = signal_alloc((char const   *)*(params + 1));
  }
#line 80
  if (i == 3) {
    {
#line 82
    tmp___5 = strlen((char const   *)*(params + 2));
#line 82
    tmp___6 = malloc(tmp___5 + 1UL);
#line 82
    s->pin = (char *)tmp___6;
#line 83
    strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
    }
  }
#line 87
  if (! s) {
    {
#line 88
    tmp___7 = gettext("out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 89
    return (1);
  }
#line 92
  s->next = part___0->signals;
#line 93
  part___0->signals = s;
#line 95
  return (1);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/signal.c"
static void cmd_signal_help(void) 
{ 
  char *tmp ;

  {
  {
#line 101
  tmp = gettext("Usage: %s SIGNAL [PIN#]\nDefine new signal with name SIGNAL for a part.\n\nSIGNAL\t\tNew signal name\nPIN#   \tList of pin # for a signal\n");
#line 101
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/signal.c"
cmd_t cmd_signal  =    {(char *)"signal", (char *)"define new signal for a part", & cmd_signal_help, & cmd_signal_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shift.c"
static int cmd_shift_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp != 2) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable();
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tmp___1 = strcasecmp((char const   *)*(params + 1), "ir");
  }
#line 44
  if (tmp___1 == 0) {
    {
#line 45
    chain_shift_instructions(chain);
    }
#line 46
    return (1);
  }
  {
#line 48
  tmp___2 = strcasecmp((char const   *)*(params + 1), "dr");
  }
#line 48
  if (tmp___2 == 0) {
    {
#line 49
    chain_shift_data_registers(chain, 1);
    }
#line 50
    return (1);
  }
#line 53
  return (-1);
}
}
#line 56 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shift.c"
static void cmd_shift_help(void) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = gettext("Usage: %s\nUsage: %s\nShift instruction or data register through JTAG chain.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "shift ir", "shift dr");
  }
#line 64
  return;
}
}
#line 66 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shift.c"
cmd_t cmd_shift  =    {(char *)"shift", (char *)"shift data/instruction registers through JTAG chain",
    & cmd_shift_help, & cmd_shift_run};
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 781 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shell.c"
static int cmd_shell_run(char **params ) 
{ 
  int i ;
  int len ;
  int n ;
  int tmp ;
  char *shell_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 42
  tmp = cmd_params(params);
#line 42
  n = tmp;
#line 45
  n = cmd_params(params);
  }
#line 45
  if (n == 1) {
#line 46
    return (-1);
  }
#line 57
  i = 1;
#line 57
  len = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < n)) {
#line 57
      goto while_break;
    }
    {
#line 57
    tmp___0 = strlen((char const   *)*(params + i));
#line 57
    len = (int )((size_t )len + (1UL + tmp___0));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___1 = malloc((size_t )len);
#line 59
  shell_cmd = (char *)tmp___1;
  }
#line 60
  if ((unsigned long )shell_cmd == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___2 = gettext("Out of memory\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return (-1);
  }
  {
#line 66
  strcpy((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + 1));
#line 67
  i = 2;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < n)) {
#line 67
      goto while_break___0;
    }
    {
#line 69
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)" ");
#line 70
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + i));
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  printf((char const   */* __restrict  */)"Executing \'%s\'\n", shell_cmd);
#line 74
  system((char const   *)shell_cmd);
#line 75
  free((void *)shell_cmd);
  }
#line 77
  return (1);
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shell.c"
static void cmd_shell_help(void) 
{ 
  char *tmp ;

  {
  {
#line 83
  tmp = gettext("Usage: %s cmmd\nShell out to os for a command.\n\nCMMD OS Shell Command\n");
#line 83
  printf((char const   */* __restrict  */)tmp, "shell cmmd");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/shell.c"
cmd_t cmd_shell  =    {(char *)"shell", (char *)"shell cmmd", & cmd_shell_help, & cmd_shell_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/set.c"
static int cmd_set_run(char **params ) 
{ 
  int dir ;
  unsigned int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 40
  data = 0U;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 4) {
#line 44
    return (-1);
  } else {
    {
#line 43
    tmp___0 = cmd_params(params);
    }
#line 43
    if (tmp___0 > 5) {
#line 44
      return (-1);
    }
  }
  {
#line 46
  tmp___1 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 46
  if (tmp___1 != 0) {
#line 47
    return (-1);
  }
  {
#line 49
  tmp___2 = cmd_test_cable();
  }
#line 49
  if (! tmp___2) {
#line 50
    return (1);
  }
#line 52
  if (! chain->parts) {
    {
#line 53
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 54
    return (1);
  }
#line 57
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 58
    tmp___4 = gettext("%s: no active part\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "set");
    }
#line 59
    return (1);
  }
  {
#line 63
  tmp___5 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 63
  if (tmp___5 != 0) {
    {
#line 63
    tmp___6 = strcasecmp((char const   *)*(params + 3), "out");
    }
#line 63
    if (tmp___6 != 0) {
#line 64
      return (-1);
    }
  }
  {
#line 66
  tmp___8 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 66
  if (tmp___8 == 0) {
#line 66
    dir = 0;
  } else {
#line 66
    dir = 1;
  }
#line 68
  if (dir) {
    {
#line 69
    tmp___9 = cmd_get_number(*(params + 4), & data);
    }
#line 69
    if (tmp___9) {
#line 70
      return (-1);
    }
#line 71
    if (data > 1U) {
#line 72
      return (-1);
    }
  }
  {
#line 75
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 76
  if (! s) {
    {
#line 77
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 77
    printf((char const   */* __restrict  */)tmp___10, *(params + 2));
    }
#line 78
    return (1);
  }
  {
#line 80
  part_set_signal(*((chain->parts)->parts + chain->active_part), s, dir, (int )data);
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/set.c"
static void cmd_set_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL DIR [DATA]\nSet signal state in input BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\nDIR           requested signal direction; possible values: \'in\' or \'out\'\nDATA          desired output signal value (\'0\' or \'1\'); used only if DIR\n                is \'out\'\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "set signal");
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/set.c"
cmd_t cmd_set  =    {(char *)"set", (char *)"set external signal value", & cmd_set_help, & cmd_set_run};
#line 40 "../../include/jtag.h"
int debug_mode ;
#line 42
int jtag_parse_file(char const   *filename ) ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/script.c"
static int cmd_script_run(char **params ) 
{ 
  int i ;
  int j ;
  int go ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  go = 0;
#line 38
  i = 0;
#line 38
  j = 1;
#line 39
  tmp___0 = cmd_params(params);
  }
#line 39
  if (tmp___0 == 3) {
    {
#line 40
    sscanf((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"%d",
           & j);
    }
  } else {
    {
#line 42
    tmp = cmd_params(params);
    }
#line 42
    if (tmp != 2) {
#line 43
      return (-1);
    }
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < j)) {
#line 45
      goto while_break;
    }
    {
#line 46
    go = jtag_parse_file((char const   *)*(params + 1));
    }
#line 48
    if (go < 0) {
#line 49
      if (go != -99) {
        {
#line 50
        tmp___1 = gettext("Unable to open file `%s go=%d\'!\n");
#line 50
        printf((char const   */* __restrict  */)tmp___1, *(params + 1), go);
        }
      }
#line 51
      goto while_break;
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (debug_mode & 1) {
    {
#line 54
    printf((char const   */* __restrict  */)"Return at cmd_script_run\n");
    }
  }
#line 55
  if (go) {
#line 55
    tmp___2 = 1;
  } else {
#line 55
    tmp___2 = 0;
  }
#line 55
  return (tmp___2);
}
}
#line 58 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/script.c"
static void cmd_script_help(void) 
{ 
  char *tmp ;

  {
  {
#line 61
  tmp = gettext("Usage: %s FILENAME [n] \nRun command sequence n times from external FILENAME.\n\nFILENAME      Name of the file with commands\n");
#line 61
  printf((char const   */* __restrict  */)tmp, "script");
  }
#line 67
  return;
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/script.c"
cmd_t cmd_script  =    {(char *)"script", (char *)"run command sequence from external file", & cmd_script_help,
    & cmd_script_run};
#line 52 "../../include/bssignal.h"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/salias.c"
static int cmd_salias_run(char **params ) 
{ 
  part_t *part___0 ;
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  signal_t *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable();
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
#line 48
  if (! chain->parts) {
    {
#line 49
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 50
    return (1);
  }
#line 53
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 54
    tmp___2 = gettext("%s: no active part\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2, "signal");
    }
#line 55
    return (1);
  }
  {
#line 58
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 59
  tmp___4 = part_find_signal(part___0, (char const   *)*(params + 1));
  }
#line 59
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___3 = gettext("Signal \'%s\' already defined\n");
#line 60
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 61
    return (1);
  }
  {
#line 64
  s = part_find_signal(part___0, (char const   *)*(params + 2));
  }
#line 65
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 66
    tmp___5 = gettext("Signal \'%s\' not found\n");
#line 66
    printf((char const   */* __restrict  */)tmp___5, *(params + 2));
    }
#line 67
    return (1);
  }
  {
#line 70
  sa = salias_alloc((char const   *)*(params + 1), (signal_t const   *)s);
  }
#line 71
  if (! sa) {
    {
#line 72
    tmp___6 = gettext("out of memory\n");
#line 72
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 73
    return (1);
  }
#line 76
  sa->next = part___0->saliases;
#line 77
  part___0->saliases = sa;
#line 79
  return (1);
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/salias.c"
static void cmd_salias_help(void) 
{ 
  char *tmp ;

  {
  {
#line 85
  tmp = gettext("Usage: %s ALIAS SIGNAL\nDefine new signal ALIAS as alias for existing SIGNAL.\n\nALIAS         New signal alias name\nSIGNAL        Existing signal name\n");
#line 85
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/salias.c"
struct __anonstruct_cmd_t_148900231  const  cmd_salias  =    {(char *)"salias", (char *)"define an alias for a signal", & cmd_salias_help, & cmd_salias_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/reset.c"
void jtag_reset(chain_t *chain___0 ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/reset.c"
static int cmd_reset_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp > 1) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
  {
#line 45
  jtag_reset(chain);
  }
#line 47
  return (1);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/reset.c"
static void cmd_reset_help(void) 
{ 
  char *tmp ;

  {
  {
#line 53
  tmp = gettext("Usage: %s\nReset current JTAG chain.\n");
#line 53
  printf((char const   */* __restrict  */)tmp, "reset");
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/reset.c"
cmd_t cmd_reset  =    {(char *)"reset", (char *)"reset JTAG chain", & cmd_reset_help, & cmd_reset_run};
#line 41 "../../include/data_register.h"
data_register *data_register_alloc(char const   *name , int len ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/register.c"
static int cmd_register_run(char **params ) 
{ 
  part_t *part___0 ;
  unsigned int len ;
  data_register *dr___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  data_register *tmp___5 ;
  char *tmp___6 ;
  int i ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp___0 = cmd_test_cable();
  }
#line 46
  if (! tmp___0) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___2 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___2, "register");
    }
#line 56
    return (1);
  }
  {
#line 59
  tmp___3 = cmd_get_number(*(params + 2), & len);
  }
#line 59
  if (tmp___3) {
#line 60
    return (-1);
  }
  {
#line 62
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 64
  tmp___5 = part_find_data_register(part___0, (char const   *)*(params + 1));
  }
#line 64
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
    {
#line 65
    tmp___4 = gettext("Data register \'%s\' already defined\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 1));
    }
#line 66
    return (1);
  }
  {
#line 69
  dr___0 = data_register_alloc((char const   *)*(params + 1), (int )len);
  }
#line 70
  if (! dr___0) {
    {
#line 71
    tmp___6 = gettext("out of memory\n");
#line 71
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 72
    return (1);
  }
  {
#line 75
  dr___0->next = part___0->data_registers;
#line 76
  part___0->data_registers = dr___0;
#line 79
  tmp___9 = strcasecmp((char const   *)(dr___0->name), "BSR");
  }
#line 79
  if (tmp___9 == 0) {
    {
#line 82
    part___0->boundary_length = (int )len;
#line 83
    tmp___7 = malloc((unsigned long )part___0->boundary_length * sizeof(*(part___0->bsbits)));
#line 83
    part___0->bsbits = (bsbit_t **)tmp___7;
    }
#line 84
    if (! part___0->bsbits) {
      {
#line 85
      tmp___8 = gettext("out of memory\n");
#line 85
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 86
      return (1);
    }
#line 88
    i = 0;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (i < part___0->boundary_length)) {
#line 88
        goto while_break;
      }
#line 89
      *(part___0->bsbits + i) = (bsbit_t *)((void *)0);
#line 88
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 93
  tmp___11 = strcasecmp((char const   *)(dr___0->name), "DIR");
  }
#line 93
  if (tmp___11 == 0) {
    {
#line 94
    tmp___10 = register_get_string((tap_register const   *)part___0->id);
#line 94
    register_init(dr___0->out, tmp___10);
    }
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/register.c"
static void cmd_register_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s NAME LENGTH\nDefine new data register with specified NAME and LENGTH.\n\nNAME          Data register name\nLENGTH        Data register length\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "register");
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/register.c"
cmd_t cmd_register  =    {(char *)"register", (char *)"define new data register for a part", & cmd_register_help,
    & cmd_register_run};
#line 48 "../../include/jtag.h"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/readmem.c"
static int cmd_readmem_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp != 4) {
#line 42
    return (-1);
  }
#line 44
  if (! bus) {
    {
#line 45
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 45
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 46
    return (1);
  }
  {
#line 49
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 49
  if (tmp___1) {
#line 50
    return (-1);
  } else {
    {
#line 49
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 49
    if (tmp___2) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"w");
  }
#line 53
  if (! f) {
    {
#line 54
    tmp___3 = gettext("Unable to create file `%s\'!\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 55
    return (1);
  }
  {
#line 57
  readmem(bus, f, adr, len);
#line 58
  fclose(f);
  }
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/readmem.c"
static void cmd_readmem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nCopy device memory content starting with ADDR to FILENAME file.\n\nADDR       start address of the copied memory area\nLEN        copied memory length\nFILENAME   name of the output file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "readmem");
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/readmem.c"
cmd_t cmd_readmem  =    {(char *)"readmem", (char *)"read content of the memory and write it to file",
    & cmd_readmem_help, & cmd_readmem_run};
#line 930 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcstombs)(char * __restrict  __s ,
                                                                                  wchar_t const   * __restrict  __pwcs ,
                                                                                  size_t __n ) ;
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 524
extern int putchar(int __c ) ;
#line 222 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 590
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) swprintf)(wchar_t * __restrict  __s ,
                                                                               size_t __n ,
                                                                               wchar_t const   * __restrict  __format 
                                                                               , ...) ;
#line 66 "../../include/part.h"
void part_print(part_t *p ) ;
#line 79
void parts_print(parts_t *ps ) ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/print.c"
static int cmd_print_run(char **params ) 
{ 
  char format[100] ;
  wchar_t wformat[100] ;
  wchar_t wheader[100] ;
  char header[100] ;
  int i ;
  int noheader ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  part_t *part___0 ;
  signal_t *s ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int i___0 ;
  uint64_t a ;
  bus_area_t area ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 47
  noheader = 0;
#line 49
  tmp = cmd_params(params);
  }
#line 49
  if (tmp > 2) {
#line 50
    return (-1);
  }
  {
#line 52
  tmp___0 = cmd_test_cable();
  }
#line 52
  if (! tmp___0) {
#line 53
    return (1);
  }
#line 55
  if (! chain->parts) {
    {
#line 56
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 56
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 57
    return (1);
  }
  {
#line 60
  tmp___4 = cmd_params(params);
  }
#line 60
  if (tmp___4 == 2) {
    {
#line 61
    tmp___2 = strcasecmp((char const   *)*(params + 1), "bus");
    }
#line 61
    if (tmp___2 == 0) {
#line 62
      noheader = 1;
    }
    {
#line 64
    tmp___3 = strcasecmp((char const   *)*(params + 1), "signals");
    }
#line 64
    if (tmp___3 == 0) {
      {
#line 66
      printf((char const   */* __restrict  */)"Signals:\n");
#line 69
      part___0 = *((chain->parts)->parts + chain->active_part);
#line 70
      s = part___0->signals;
      }
      {
#line 70
      while (1) {
        while_continue: /* CIL Label */ ;
#line 70
        if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 70
          goto while_break;
        }
#line 71
        if (s->pin) {
          {
#line 71
          printf((char const   */* __restrict  */)"%s %s", s->name, s->pin);
          }
        } else {
          {
#line 72
          printf((char const   */* __restrict  */)"%s", s->name);
          }
        }
#line 73
        if (s->input) {
          {
#line 73
          printf((char const   */* __restrict  */)"\tinput=%s", (s->input)->name);
          }
        }
#line 74
        if (s->output) {
          {
#line 74
          printf((char const   */* __restrict  */)"\toutput=%s", (s->output)->name);
          }
        }
        {
#line 75
        printf((char const   */* __restrict  */)"\n");
#line 70
        s = s->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 77
      return (1);
    }
  }
#line 81
  if (noheader == 0) {
    {
#line 82
    tmp___5 = gettext(" No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 82
    snprintf((char */* __restrict  */)(format), (size_t )100, (char const   */* __restrict  */)tmp___5,
             25, 20, 8, 20, 10);
#line 85
    tmp___7 = mbstowcs((wchar_t */* __restrict  */)(wformat), (char const   */* __restrict  */)(format),
                       (size_t )100);
    }
#line 85
    if (tmp___7 == 0xffffffffffffffffUL) {
      {
#line 86
      tmp___6 = gettext("(%d) String conversion failed!\n");
#line 86
      printf((char const   */* __restrict  */)tmp___6, 86);
      }
    }
    {
#line 87
    tmp___8 = gettext("Register");
#line 87
    tmp___9 = gettext("Instruction");
#line 87
    tmp___10 = gettext("Stepping");
#line 87
    tmp___11 = gettext("Part");
#line 87
    tmp___12 = gettext("Manufacturer");
#line 87
    swprintf((wchar_t */* __restrict  */)(wheader), (size_t )100, (wchar_t const   */* __restrict  */)(wformat),
             tmp___12, tmp___11, tmp___10, tmp___9, tmp___8);
#line 88
    tmp___14 = wcstombs((char */* __restrict  */)(header), (wchar_t const   */* __restrict  */)(wheader),
                        (size_t )100);
    }
#line 88
    if (tmp___14 == 0xffffffffffffffffUL) {
      {
#line 89
      tmp___13 = gettext("(%d) String conversion failed!\n");
#line 89
      printf((char const   */* __restrict  */)tmp___13, 89);
      }
    }
    {
#line 95
    printf((char const   */* __restrict  */)(header));
#line 97
    i = 0;
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 97
      tmp___15 = wcslen((wchar_t const   *)(wheader));
      }
#line 97
      if (! ((size_t )i < tmp___15)) {
#line 97
        goto while_break___0;
      }
      {
#line 98
      putchar('-');
#line 97
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 99
    putchar('\n');
    }
  }
  {
#line 102
  tmp___24 = cmd_params(params);
  }
#line 102
  if (tmp___24 == 1) {
#line 103
    if ((chain->parts)->len > chain->active_part) {
#line 104
      if ((*((chain->parts)->parts + chain->active_part))->alias) {
        {
#line 105
        tmp___16 = gettext(" %3d %s ");
#line 105
        printf((char const   */* __restrict  */)tmp___16, chain->active_part, (*((chain->parts)->parts + chain->active_part))->alias);
        }
      } else {
        {
#line 107
        tmp___17 = gettext(" %3d ");
#line 107
        printf((char const   */* __restrict  */)tmp___17, chain->active_part);
        }
      }
      {
#line 109
      part_print(*((chain->parts)->parts + chain->active_part));
      }
    }
#line 111
    if ((unsigned long )bus != (unsigned long )((void *)0)) {
#line 116
      i___0 = 0;
      {
#line 116
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 116
        if (! (i___0 < buses.len)) {
#line 116
          goto while_break___1;
        }
#line 117
        if ((unsigned long )*(buses.buses + i___0) == (unsigned long )bus) {
#line 118
          goto while_break___1;
        }
#line 116
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 119
      tmp___18 = gettext("\nActive bus:\n*%d: ");
#line 119
      printf((char const   */* __restrict  */)tmp___18, i___0);
#line 120
      (*((bus->driver)->printinfo))(bus);
#line 122
      a = (uint64_t )0;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if (! (a < 4294967296UL)) {
#line 122
          goto while_break___2;
        }
        {
#line 123
        tmp___20 = (*((bus->driver)->area))(bus, (uint32_t )a, & area);
        }
#line 123
        if (tmp___20 != 0) {
          {
#line 124
          tmp___19 = gettext("Error in bus area discovery at 0x%08llX\n");
#line 124
          printf((char const   */* __restrict  */)tmp___19, (unsigned long long )a);
          }
#line 125
          goto while_break___2;
        }
#line 127
        if (area.width != 0U) {
#line 128
          if ((unsigned long )area.description != (unsigned long )((void *)0)) {
            {
#line 129
            tmp___21 = gettext(area.description);
#line 129
            tmp___22 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit, (%s)\n");
#line 129
            printf((char const   */* __restrict  */)tmp___22, area.start, (unsigned long long )area.length,
                   area.width, tmp___21);
            }
          } else {
            {
#line 131
            tmp___23 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit\n");
#line 131
            printf((char const   */* __restrict  */)tmp___23, area.start, (unsigned long long )area.length,
                   area.width);
            }
          }
        }
#line 122
        a = (uint64_t )area.start + area.length;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 136
    return (1);
  }
  {
#line 139
  tmp___25 = strcasecmp((char const   *)*(params + 1), "chain");
  }
#line 139
  if (tmp___25 == 0) {
    {
#line 140
    parts_print(chain->parts);
    }
#line 141
    return (1);
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 144
    if (! (i < buses.len)) {
#line 144
      goto while_break___3;
    }
#line 145
    if ((unsigned long )*(buses.buses + i) == (unsigned long )bus) {
      {
#line 146
      tmp___26 = gettext("*%d: ");
#line 146
      printf((char const   */* __restrict  */)tmp___26, i);
      }
    } else {
      {
#line 148
      tmp___27 = gettext("%d: ");
#line 148
      printf((char const   */* __restrict  */)tmp___27, i);
      }
    }
    {
#line 149
    (*(((*(buses.buses + i))->driver)->printinfo))(*(buses.buses + i));
#line 144
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 152
  return (1);
}
}
#line 155 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/print.c"
static void cmd_print_help(void) 
{ 
  char *tmp ;

  {
  {
#line 158
  tmp = gettext("Usage: %s [chain|bus|signals]\nDisplay JTAG chain status.\n\nDisplay list of the parts connected to the JTAG chain including\npart number and current (active) instruction and data register.\n");
#line 158
  printf((char const   */* __restrict  */)tmp, "print");
  }
#line 165
  return;
}
}
#line 167 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/print.c"
cmd_t cmd_print  =    {(char *)"print", (char *)"display JTAG chain list/status", & cmd_print_help, & cmd_print_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
static int cmd_peek_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  int pars ;
  int j ;
  bus_area_t area ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 38
  j = 1;
#line 43
  pars = cmd_params(params);
  }
#line 43
  if (pars < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp);
    }
#line 48
    return (1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___0 = cmd_get_number(*(params + j), & adr);
    }
#line 51
    if (tmp___0) {
#line 52
      return (-1);
    }
    {
#line 54
    (*((bus->driver)->prepare))(bus);
#line 55
    (*((bus->driver)->area))(bus, adr, & area);
#line 56
    val = (*((bus->driver)->read))(bus, adr);
    }
    {
#line 60
    if (area.width == 8U) {
#line 60
      goto case_8;
    }
#line 64
    if (area.width == 16U) {
#line 64
      goto case_16;
    }
#line 68
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 61
    val &= 255U;
#line 62
    tmp___1 = gettext("bus_read(0x%08x) = 0x%02X (%i)\n");
#line 62
    printf((char const   */* __restrict  */)tmp___1, adr, val, val);
    }
#line 63
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 65
    val &= 65535U;
#line 66
    tmp___2 = gettext("bus_read(0x%08x) = 0x%04X (%i)\n");
#line 66
    printf((char const   */* __restrict  */)tmp___2, adr, val, val);
    }
#line 67
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 69
    tmp___3 = gettext("bus_read(0x%08x) = 0x%08X (%i)\n");
#line 69
    printf((char const   */* __restrict  */)tmp___3, adr, val, val);
    }
    switch_break: /* CIL Label */ ;
    }
#line 50
    j ++;
#line 50
    if (! (j != pars)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (1);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
static void cmd_peek_help(void) 
{ 
  char *tmp ;

  {
  {
#line 79
  tmp = gettext("Usage: %s ADDR\nRead a single word (bus width size).\n\nADDR       address to read from\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 79
  printf((char const   */* __restrict  */)tmp, "peek");
  }
#line 88
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
cmd_t cmd_peek  =    {(char *)"peek", (char *)"read a single word", & cmd_peek_help, & cmd_peek_run};
#line 97 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
static int cmd_poke_run(char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  bus_area_t area ;
  int k ;
  int pars ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 103
  k = 1;
#line 103
  tmp = cmd_params(params);
#line 103
  pars = tmp;
  }
#line 105
  if (pars < 3) {
#line 106
    return (-1);
  } else
#line 105
  if (! (pars & 1)) {
#line 106
    return (-1);
  }
#line 108
  if (! bus) {
    {
#line 109
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 109
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 110
    return (1);
  }
  {
#line 114
  (*((bus->driver)->prepare))(bus);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (k < pars)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___1 = cmd_get_number(*(params + k), & adr);
    }
#line 117
    if (tmp___1) {
#line 118
      return (-1);
    } else {
      {
#line 117
      tmp___2 = cmd_get_number(*(params + (k + 1)), & val);
      }
#line 117
      if (tmp___2) {
#line 118
        return (-1);
      }
    }
    {
#line 119
    (*((bus->driver)->area))(bus, adr, & area);
#line 120
    (*((bus->driver)->write))(bus, adr, val);
#line 121
    k += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (1);
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
static void cmd_poke_help(void) 
{ 
  char *tmp ;

  {
  {
#line 130
  tmp = gettext("Usage: %s ADDR VAL [ADDR VAL] ... \nWrite a single word (bus width size).\n\nADDR       address to write\nVAL        value to write\n\nADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 130
  printf((char const   */* __restrict  */)tmp, "poke");
  }
#line 140
  return;
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/peekpoke.c"
cmd_t cmd_poke  =    {(char *)"poke", (char *)"write a single word", & cmd_poke_help, & cmd_poke_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/part.c"
static int cmd_part_run(char **params ) 
{ 
  unsigned int n ;
  part_t *part___0 ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int i ;
  char *a ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 41
  tmp___2 = cmd_params(params);
  }
#line 41
  if (tmp___2 == 3) {
    {
#line 42
    tmp___1 = strcasecmp((char const   *)*(params + 1), "alias");
    }
#line 42
    if (tmp___1 == 0) {
      {
#line 44
      part___0 = *((chain->parts)->parts + chain->active_part);
#line 45
      tmp = strlen((char const   *)*(params + 2));
#line 45
      tmp___0 = malloc(tmp + 1UL);
#line 45
      part___0->alias = (char *)tmp___0;
#line 46
      strcpy((char */* __restrict  */)part___0->alias, (char const   */* __restrict  */)*(params + 2));
      }
#line 47
      return (1);
    }
  }
  {
#line 52
  tmp___3 = cmd_params(params);
  }
#line 52
  if (tmp___3 != 2) {
#line 53
    return (-1);
  }
  {
#line 55
  tmp___4 = cmd_test_cable();
  }
#line 55
  if (! tmp___4) {
#line 56
    return (1);
  }
#line 58
  if (! chain->parts) {
    {
#line 59
    tmp___5 = gettext("Run \"detect\" first.\n");
#line 59
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 60
    return (1);
  }
  {
#line 64
  tmp___7 = cmd_get_number(*(params + 1), & n);
  }
#line 64
  if (tmp___7) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < (chain->parts)->len)) {
#line 70
        goto while_break;
      }
#line 71
      a = (*((chain->parts)->parts + i))->alias;
#line 72
      if (a) {
        {
#line 72
        tmp___6 = strcasecmp((char const   *)a, (char const   *)*(params + 1));
        }
#line 72
        if (tmp___6 == 0) {
#line 72
          goto while_break;
        }
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (i < (chain->parts)->len) {
#line 74
      n = (unsigned int )i;
    } else {
#line 77
      return (-1);
    }
  }
#line 80
  if (n >= (unsigned int )(chain->parts)->len) {
    {
#line 81
    tmp___8 = gettext("%s: invalid part number\n");
#line 81
    printf((char const   */* __restrict  */)tmp___8, "part");
    }
#line 82
    return (1);
  }
#line 85
  chain->active_part = (int )n;
#line 87
  return (1);
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/part.c"
static void cmd_part_help(void) 
{ 
  char *tmp ;

  {
  {
#line 93
  tmp = gettext("Usage: %s PART\nChange active part for current JTAG chain.\n\nPART          part number | alias\n");
#line 93
  printf((char const   */* __restrict  */)tmp, "part");
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/part.c"
cmd_t cmd_part  =    {(char *)"part", (char *)"change active part for current JTAG chain", & cmd_part_help,
    & cmd_part_run};
#line 42 "../../include/instruction.h"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/instruction.c"
static int cmd_instruction_run(char **params ) 
{ 
  part_t *part___0 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned int len ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  instruction *i ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  instruction *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 40
  tmp = cmd_test_cable();
  }
#line 40
  if (! tmp) {
#line 41
    return (1);
  }
#line 43
  if (! chain->parts) {
    {
#line 44
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 44
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 45
    return (1);
  }
#line 48
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 49
    tmp___1 = gettext("%s: no active part\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1, "instruction");
    }
#line 50
    return (1);
  }
  {
#line 53
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 55
  tmp___3 = cmd_params(params);
  }
#line 55
  if (tmp___3 == 2) {
    {
#line 56
    part_set_instruction(part___0, (char const   *)*(params + 1));
    }
#line 57
    if ((unsigned long )part___0->active_instruction == (unsigned long )((void *)0)) {
      {
#line 58
      tmp___2 = gettext("%s: unknown instruction \'%s\'\n");
#line 58
      printf((char const   */* __restrict  */)tmp___2, "instruction", *(params + 1));
      }
    }
#line 59
    return (1);
  }
  {
#line 62
  tmp___7 = cmd_params(params);
  }
#line 62
  if (tmp___7 == 3) {
    {
#line 65
    tmp___4 = strcasecmp((char const   *)*(params + 1), "length");
    }
#line 65
    if (tmp___4 != 0) {
#line 66
      return (-1);
    }
#line 68
    if ((unsigned long )part___0->instructions != (unsigned long )((void *)0)) {
      {
#line 69
      tmp___5 = gettext("instruction length is already set and used\n");
#line 69
      printf((char const   */* __restrict  */)tmp___5);
      }
#line 70
      return (1);
    }
    {
#line 73
    tmp___6 = cmd_get_number(*(params + 2), & len);
    }
#line 73
    if (tmp___6) {
#line 74
      return (-1);
    }
#line 76
    part___0->instruction_length = (int )len;
#line 77
    return (1);
  }
  {
#line 80
  tmp___14 = cmd_params(params);
  }
#line 80
  if (tmp___14 == 4) {
    {
#line 83
    tmp___9 = strlen((char const   *)*(params + 2));
    }
#line 83
    if (tmp___9 != (size_t )part___0->instruction_length) {
      {
#line 84
      tmp___8 = gettext("invalid instruction length\n");
#line 84
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 85
      return (1);
    }
    {
#line 88
    tmp___11 = part_find_instruction(part___0, (char const   *)*(params + 1));
    }
#line 88
    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
      {
#line 89
      tmp___10 = gettext("Instruction \'%s\' already defined\n");
#line 89
      printf((char const   */* __restrict  */)tmp___10, *(params + 1));
      }
#line 90
      return (1);
    }
    {
#line 93
    i = instruction_alloc((char const   *)*(params + 1), part___0->instruction_length,
                          (char const   *)*(params + 2));
    }
#line 94
    if (! i) {
      {
#line 95
      tmp___12 = gettext("out of memory\n");
#line 95
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 96
      return (1);
    }
    {
#line 99
    i->next = part___0->instructions;
#line 100
    part___0->instructions = i;
#line 102
    i->data_register = part_find_data_register(part___0, (char const   *)*(params + 3));
    }
#line 103
    if ((unsigned long )i->data_register == (unsigned long )((void *)0)) {
      {
#line 104
      tmp___13 = gettext("unknown data register \'%s\'\n");
#line 104
      printf((char const   */* __restrict  */)tmp___13, *(params + 3));
      }
#line 105
      return (1);
    }
#line 108
    return (1);
  }
#line 111
  return (-1);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/instruction.c"
static void cmd_instruction_help(void) 
{ 
  char *tmp ;

  {
  {
#line 117
  tmp = gettext("Usage: %s INSTRUCTION\nUsage: %s length LENGTH\nUsage: %s INSTRUCTION CODE REGISTER\nChange active INSTRUCTION for a part or declare new instruction.\n\nINSTRUCTION   instruction name (e.g. BYPASS)\nLENGTH        common instruction length\nCODE          instruction code (e.g. 11111)\nREGISTER      default data register for instruction (e.g. BR)\n");
#line 117
  printf((char const   */* __restrict  */)tmp, "instruction", "instruction", "instruction");
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/instruction.c"
cmd_t cmd_instruction  =    {(char *)"instruction", (char *)"change active instruction for a part or declare new instruction",
    & cmd_instruction_help, & cmd_instruction_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/initbus.c"
static int cmd_initbus_run(char **params ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bus_t *bus___0 ;
  bus_t *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
#line 50
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___5 = strcasecmp((char const   *)(bus_drivers[i])->name, (char const   *)*(params + 1));
    }
#line 56
    if (tmp___5 == 0) {
      {
#line 57
      tmp___3 = (*((bus_drivers[i])->new_bus))();
#line 57
      bus___0 = tmp___3;
      }
#line 58
      if ((unsigned long )bus___0 == (unsigned long )((void *)0)) {
        {
#line 59
        tmp___4 = gettext("bus initialization failed!\n");
#line 59
        printf((char const   */* __restrict  */)tmp___4);
        }
#line 60
        return (1);
      }
      {
#line 62
      buses_add(bus___0);
      }
#line 63
      return (1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp___6 = gettext("Unknown bus: %s\n");
#line 67
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 69
  return (1);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/initbus.c"
static void cmd_initbus_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 77
  tmp = gettext("Usage: %s BUSNAME\nInitialize new bus driver for active part.\n\nBUSNAME       Name of the bus\n\nList of available buses:\n");
#line 77
  printf((char const   */* __restrict  */)tmp, "initbus");
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 86
      goto while_break;
    }
    {
#line 87
    tmp___0 = gettext("%-10s %s\n");
#line 87
    printf((char const   */* __restrict  */)tmp___0, (bus_drivers[i])->name, (bus_drivers[i])->description);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/initbus.c"
struct __anonstruct_cmd_t_148900231  const  cmd_initbus  =    {(char *)"initbus", (char *)"initialize bus driver for active part", & cmd_initbus_help,
    & cmd_initbus_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/include.c"
static int cmd_include_run(char **params ) 
{ 
  int go ;
  char *path ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = strlen("/usr/local/share/urjtag");
#line 45
  tmp___1 = strlen((char const   *)*(params + 1));
#line 45
  len = (int )((tmp___0 + tmp___1) + 2UL);
#line 45
  tmp___2 = malloc((size_t )len);
#line 45
  path = (char *)tmp___2;
  }
#line 46
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___3 = gettext("Out of memory\n");
#line 47
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 48
    return (1);
  }
  {
#line 50
  snprintf((char */* __restrict  */)path, (size_t )len, (char const   */* __restrict  */)"%s/%s",
           "/usr/local/share/urjtag", *(params + 1));
#line 52
  go = jtag_parse_file((char const   *)path);
  }
#line 53
  if (go < 0) {
    {
#line 54
    tmp___4 = gettext("Unable to open file `%s\'!\n");
#line 54
    printf((char const   */* __restrict  */)tmp___4, *(params + 1));
    }
  }
  {
#line 56
  free((void *)path);
  }
#line 58
  if (go) {
#line 58
    tmp___5 = 1;
  } else {
#line 58
    tmp___5 = 0;
  }
#line 58
  return (tmp___5);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/include.c"
static void cmd_include_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s FILENAME\nRun command sequence from external FILENAME from the repository.\n\nFILENAME      Name of the file with commands\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "include");
  }
#line 70
  return;
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/include.c"
cmd_t cmd_include  =    {(char *)"include", (char *)"include command sequence from external repository",
    & cmd_include_help, & cmd_include_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/get.c"
static int cmd_get_run(char **params ) 
{ 
  int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 45
  if (tmp___0 != 0) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp___1 = cmd_test_cable();
  }
#line 48
  if (! tmp___1) {
#line 49
    return (1);
  }
#line 51
  if (! chain->parts) {
    {
#line 52
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 52
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 53
    return (1);
  }
#line 56
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 57
    tmp___3 = gettext("%s: no active part\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 58
    return (1);
  }
  {
#line 61
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 62
  if (! s) {
    {
#line 63
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 63
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 64
    return (1);
  }
  {
#line 66
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 67
  if (data != -1) {
    {
#line 68
    tmp___5 = gettext("%s = %d\n");
#line 68
    printf((char const   */* __restrict  */)tmp___5, *(params + 2), data);
    }
  }
#line 70
  return (1);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/get.c"
static void cmd_get_help(void) 
{ 
  char *tmp ;

  {
  {
#line 76
  tmp = gettext("Usage: %s SIGNAL\nGet signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 76
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 82
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/get.c"
cmd_t cmd_get  =    {(char *)"get", (char *)"get external signal value", & cmd_get_help, & cmd_get_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/frequency.c"
static int cmd_frequency_run(char **params ) 
{ 
  unsigned int freq ;
  uint32_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 39
  tmp___1 = cmd_params(params);
  }
#line 39
  if (tmp___1 == 1) {
    {
#line 40
    tmp = cable_get_frequency(chain->cable);
#line 40
    tmp___0 = gettext("Current TCK frequency is %u Hz\n");
#line 40
    printf((char const   */* __restrict  */)tmp___0, tmp);
    }
#line 41
    return (1);
  }
  {
#line 44
  tmp___2 = cmd_params(params);
  }
#line 44
  if (tmp___2 != 2) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___3 = cmd_get_number(*(params + 1), & freq);
  }
#line 47
  if (tmp___3) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___4 = gettext("Setting TCK frequency to %u Hz\n");
#line 50
  printf((char const   */* __restrict  */)tmp___4, freq);
#line 51
  cable_set_frequency(chain->cable, freq);
  }
#line 53
  return (1);
}
}
#line 56 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/frequency.c"
static void cmd_frequency_help(void) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = gettext("Usage: %s [FREQ]\nChange TCK frequency to FREQ or print current TCK frequency.\n\nFREQ is in hertz. It\'s a maximum TCK frequency for JTAG interface.\nIn some cases the TCK frequency is less than FREQ, but the frequency\nis never more than FREQ. Maximum supported frequency depends on JTAG\nadapter.\n\nFREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\nUse 0 for FREQ to disable frequency limit.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "frequency");
  }
#line 71
  return;
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/frequency.c"
cmd_t cmd_frequency  =    {(char *)"frequency", (char *)"setup JTAG frequency", & cmd_frequency_help, & cmd_frequency_run};
#line 63 "../../inclow/brux/flash.h"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) ;
#line 64
void flashmsbin(bus_t *bus___0 , FILE *f ) ;
#line 31 "../../include/flash.h"
flash_driver_t *flash_drivers[8] ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/flashmem.c"
static int cmd_flashmem_run(char **params ) 
{ 
  int msbin ;
  uint32_t adr ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 40
  adr = (uint32_t )0;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp != 3) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 48
    return (1);
  }
  {
#line 51
  tmp___1 = strcasecmp("msbin", (char const   *)*(params + 1));
#line 51
  msbin = tmp___1 == 0;
  }
#line 52
  if (! msbin) {
    {
#line 52
    tmp___2 = cmd_get_number(*(params + 1), & adr);
    }
#line 52
    if (tmp___2) {
#line 53
      return (-1);
    }
  }
  {
#line 55
  f = fopen((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"rb");
  }
#line 56
  if (! f) {
    {
#line 57
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, *(params + 2));
    }
#line 58
    return (1);
  }
#line 60
  if (msbin) {
    {
#line 61
    flashmsbin(bus, f);
    }
  } else {
    {
#line 63
    flashmem(bus, f, adr);
    }
  }
  {
#line 64
  fclose(f);
  }
#line 66
  return (1);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/flashmem.c"
static void cmd_flashmem_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 74
  tmp = gettext("Usage: %s ADDR FILENAME\nUsage: %s FILENAME\nProgram FILENAME content to flash memory.\n\nADDR       target address for raw binary image\nFILENAME   name of the input file\n%-10s FILENAME is in MS .bin format (for WinCE)\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 74
  printf((char const   */* __restrict  */)tmp, "flashmem", "flashmem msbin", "msbin");
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! flash_drivers[i]) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___0 = gettext((flash_drivers[i])->description);
#line 89
    tmp___1 = gettext((flash_drivers[i])->name);
#line 89
    tmp___2 = gettext("%s\n     %s\n");
#line 89
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/flashmem.c"
cmd_t cmd_flashmem  =    {(char *)"flashmem", (char *)"burn flash memory with data from a file", & cmd_flashmem_help,
    & cmd_flashmem_run};
#line 51 "../../include/jtag.h"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/eraseflash.c"
static int cmd_eraseflash_run(char **params ) 
{ 
  uint32_t adr ;
  unsigned int number ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 39
  adr = (uint32_t )0;
#line 40
  number = 0U;
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 44
  tmp___0 = cmd_test_cable();
  }
#line 44
  if (! tmp___0) {
#line 45
    return (1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___1 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 48
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & adr);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
  {
#line 52
  tmp___3 = cmd_get_number(*(params + 2), & number);
  }
#line 52
  if (tmp___3) {
#line 53
    return (-1);
  }
  {
#line 54
  flasherase(bus, adr, (int )number);
  }
#line 56
  return (1);
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/eraseflash.c"
static void cmd_eraseflash_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR BLOCKS\nErase flash memory from ADDR.\n\nADDR       target addres for erasing block\nBLOCKS     number of blocks to erase\n\nADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "eraseflash");
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! flash_drivers[i]) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = gettext((flash_drivers[i])->description);
#line 77
    tmp___1 = gettext((flash_drivers[i])->name);
#line 77
    tmp___2 = gettext("%s\n     %s\n");
#line 77
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/eraseflash.c"
cmd_t cmd_eraseflash  =    {(char *)"eraseflash", (char *)"erase flash memory by number of blocks", & cmd_eraseflash_help,
    & cmd_eraseflash_run};
#line 39 "../../include/jtag.h"
int big_endian ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/endian.c"
static int cmd_endian_run(char **params ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp > 2) {
#line 38
    return (-1);
  }
#line 40
  if (! *(params + 1)) {
#line 41
    if (big_endian) {
      {
#line 42
      tmp___0 = gettext("Endianess for external files: big\n");
#line 42
      printf((char const   */* __restrict  */)tmp___0);
      }
    } else {
      {
#line 44
      tmp___1 = gettext("Endianess for external files: little\n");
#line 44
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 45
    return (1);
  }
  {
#line 49
  tmp___2 = strcasecmp((char const   *)*(params + 1), "little");
  }
#line 49
  if (tmp___2 == 0) {
#line 50
    big_endian = 0;
#line 51
    return (1);
  }
  {
#line 53
  tmp___3 = strcasecmp((char const   *)*(params + 1), "big");
  }
#line 53
  if (tmp___3 == 0) {
#line 54
    big_endian = 1;
#line 55
    return (1);
  }
#line 58
  return (-1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/endian.c"
static void cmd_endian_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s\nSet or print endianess for external files.\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "endian [little|big]");
  }
#line 68
  return;
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/endian.c"
cmd_t cmd_endian  =    {(char *)"endian", (char *)"set/print endianess", & cmd_endian_help, & cmd_endian_run};
#line 276 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/dr.c"
static int cmd_dr_run(char **params ) 
{ 
  int dir ;
  tap_register *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned int bit ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 38
  dir = 1;
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp < 1) {
#line 42
    return (-1);
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    }
  }
  {
#line 44
  tmp___1 = cmd_test_cable();
  }
#line 44
  if (! tmp___1) {
#line 45
    return (1);
  }
#line 47
  if (! chain->parts) {
    {
#line 48
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 48
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 49
    return (1);
  }
#line 52
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 53
    tmp___3 = gettext("%s: no active part\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3, "dr");
    }
#line 54
    return (1);
  }
#line 57
  if ((unsigned long )(*((chain->parts)->parts + chain->active_part))->active_instruction == (unsigned long )((void *)0)) {
    {
#line 58
    tmp___4 = gettext("%s: part without active instruction\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "dr");
    }
#line 59
    return (1);
  }
#line 61
  if ((unsigned long )((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___5 = gettext("%s: part without active data register\n");
#line 62
    printf((char const   */* __restrict  */)tmp___5, "dr");
    }
#line 63
    return (1);
  }
#line 66
  if (*(params + 1)) {
    {
#line 67
    tmp___11 = strcasecmp((char const   *)*(params + 1), "in");
    }
#line 67
    if (tmp___11 == 0) {
#line 68
      dir = 0;
    } else {
      {
#line 69
      tmp___10 = strcasecmp((char const   *)*(params + 1), "out");
      }
#line 69
      if (tmp___10 == 0) {
#line 70
        dir = 1;
      } else {
        {
#line 73
        tmp___6 = strspn((char const   *)*(params + 1), "01");
#line 73
        tmp___7 = strlen((char const   *)*(params + 1));
        }
#line 73
        if (tmp___6 != tmp___7) {
#line 74
          return (-1);
        }
        {
#line 77
        r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
#line 78
        tmp___9 = strlen((char const   *)*(params + 1));
        }
#line 78
        if ((size_t )r->len != tmp___9) {
          {
#line 79
          tmp___8 = gettext("%s: register length mismatch\n");
#line 79
          printf((char const   */* __restrict  */)tmp___8, "dr");
          }
#line 80
          return (1);
        }
#line 82
        bit = 0U;
        {
#line 82
        while (1) {
          while_continue: /* CIL Label */ ;
#line 82
          if (! *(*(params + 1) + bit)) {
#line 82
            goto while_break;
          }
#line 83
          *(r->data + ((unsigned int )(r->len - 1) - bit)) = (char )((int )*(*(params + 1) + bit) == 49);
#line 82
          bit ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 86
        dir = 0;
      }
    }
  }
#line 90
  if (dir) {
#line 91
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->out;
  } else {
#line 93
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
  }
  {
#line 94
  tmp___12 = register_get_string((tap_register const   *)r);
#line 94
  tmp___13 = gettext("%s\n");
#line 94
  printf((char const   */* __restrict  */)tmp___13, tmp___12);
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/dr.c"
static void cmd_dr_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s [DIR]\nDisplay input or output data register content.\n\nDIR           requested data register; possible values: \'in\' for\n                input and \'out\' for output; default is \'out\'\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "dr");
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/dr.c"
cmd_t cmd_dr  =    {(char *)"dr", (char *)"display active data register for a part", & cmd_dr_help,
    & cmd_dr_run};
#line 46 "../../include/jtag.h"
void discovery(chain_t *chain___0 ) ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/discovery.c"
static int cmd_discovery_run(char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = cmd_params(params);
  }
#line 36
  if (tmp != 1) {
#line 37
    return (-1);
  }
  {
#line 39
  tmp___0 = cmd_test_cable();
  }
#line 39
  if (! tmp___0) {
#line 40
    return (1);
  }
  {
#line 42
  discovery(chain);
  }
#line 44
  return (1);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/discovery.c"
static void cmd_discovery_help(void) 
{ 
  char *tmp ;

  {
  {
#line 50
  tmp = gettext("Usage: %s\nDiscovery of unknown parts in the JTAG chain.\n\n\'%s\' attempts to detect these parameters of an unknown JTAG\nchain:\n 1. IR (instruction register) length\n 2. DR (data register) length for all possible instructions\n\nWarning: This may be dangerous for some parts (especially if the\npart doesn\'t have TRST signal).\n");
#line 50
  printf((char const   */* __restrict  */)tmp, "discovery", "discovery");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/discovery.c"
cmd_t cmd_discovery  =    {(char *)"discovery", (char *)"discovery of unknown parts in the JTAG chain", & cmd_discovery_help,
    & cmd_discovery_run};
#line 76 "../../include/part.h"
void parts_free(parts_t *ps ) ;
#line 78
void parts_set_instruction(parts_t *ps , char const   *iname ) ;
#line 44 "../../include/jtag.h"
int detect_parts(chain_t *chain___0 , char *db_path ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/detect.c"
static int cmd_detect_run(char **params ) 
{ 
  int i ;
  bus_t *abus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 1) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable();
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
  {
#line 48
  buses_free();
#line 49
  parts_free(chain->parts);
#line 50
  chain->parts = (parts_t *)((void *)0);
#line 51
  detect_parts(chain, (char *)"/usr/local/share/urjtag");
  }
#line 52
  if (! chain->parts) {
#line 53
    return (1);
  }
#line 54
  if (! (chain->parts)->len) {
    {
#line 55
    parts_free(chain->parts);
#line 56
    chain->parts = (parts_t *)((void *)0);
    }
#line 57
    return (1);
  }
  {
#line 59
  parts_set_instruction(chain->parts, "SAMPLE/PRELOAD");
#line 60
  chain_shift_instructions(chain);
#line 61
  chain_shift_data_registers(chain, 1);
#line 62
  parts_set_instruction(chain->parts, "BYPASS");
#line 63
  chain_shift_instructions(chain);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < buses.len)) {
#line 66
      goto while_break;
    }
#line 68
    abus = *(buses.buses + i);
#line 69
    if ((abus->driver)->init) {
      {
#line 71
      tmp___1 = (*((abus->driver)->init))(abus);
      }
#line 71
      if (! tmp___1) {
#line 72
        return (-1);
      }
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/detect.c"
static void cmd_detect_help(void) 
{ 
  char *tmp ;

  {
  {
#line 82
  tmp = gettext("Usage: %s\nDetect parts on the JTAG chain.\n\nOutput from this command is a list of the detected parts.\nIf no parts are detected other commands may not work properly.\n");
#line 82
  printf((char const   */* __restrict  */)tmp, "detect");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/detect.c"
cmd_t cmd_detect  =    {(char *)"detect", (char *)"detect parts on the JTAG chain", & cmd_detect_help,
    & cmd_detect_run};
#line 37 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/debug.c"
static int cmd_debug_run(char **params ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_get_number(*(params + 1), & i);
  }
#line 45
  if (tmp___0) {
#line 46
    return (1);
  }
#line 48
  debug_mode = (int )i;
#line 49
  return (1);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/debug.c"
static void cmd_debug_help(void) 
{ 
  char *tmp ;

  {
  {
#line 55
  tmp = gettext("Usage: %s  n\nEnabled debugging.\n\nn =1 fileio, 2=tap commands, 4 =?\n");
#line 55
  printf((char const   */* __restrict  */)tmp, "debug n");
  }
#line 61
  return;
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/debug.c"
cmd_t cmd_debug  =    {(char *)"debug", (char *)"debug jtag program", & cmd_debug_help, & cmd_debug_run};
#line 37 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cmd.c"
cmd_t cmd_cable ;
#line 43
cmd_t cmd_bit ;
#line 48
cmd_t cmd_bus ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cmd.c"
cmd_t const   *cmds[35]  = 
#line 69
  {      (cmd_t const   *)(& cmd_quit),      (cmd_t const   *)(& cmd_help),      (cmd_t const   *)(& cmd_frequency),      (cmd_t const   *)(& cmd_cable), 
        (cmd_t const   *)(& cmd_reset),      (cmd_t const   *)(& cmd_discovery),      (cmd_t const   *)(& cmd_detect),      (cmd_t const   *)(& cmd_signal), 
        & cmd_salias,      (cmd_t const   *)(& cmd_bit),      (cmd_t const   *)(& cmd_register),      & cmd_initbus, 
        (cmd_t const   *)(& cmd_print),      (cmd_t const   *)(& cmd_part),      (cmd_t const   *)(& cmd_bus),      (cmd_t const   *)(& cmd_instruction), 
        (cmd_t const   *)(& cmd_shift),      (cmd_t const   *)(& cmd_dr),      (cmd_t const   *)(& cmd_get),      (cmd_t const   *)(& cmd_test), 
        (cmd_t const   *)(& cmd_shell),      (cmd_t const   *)(& cmd_set),      (cmd_t const   *)(& cmd_endian),      (cmd_t const   *)(& cmd_peek), 
        (cmd_t const   *)(& cmd_poke),      (cmd_t const   *)(& cmd_readmem),      (cmd_t const   *)(& cmd_writemem),      (cmd_t const   *)(& cmd_detectflash), 
        (cmd_t const   *)(& cmd_flashmem),      (cmd_t const   *)(& cmd_eraseflash),      (cmd_t const   *)(& cmd_script),      (cmd_t const   *)(& cmd_include), 
        (cmd_t const   *)(& cmd_svf),      (cmd_t const   *)(& cmd_debug),      (cmd_t const   *)((void *)0)};
#line 107 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cmd.c"
int cmd_test_cable(void) 
{ 
  char *tmp ;

  {
#line 110
  if (chain->cable) {
#line 111
    return (1);
  }
  {
#line 113
  tmp = gettext("Error: Cable not configured. Please use \'%s\' command first!\n");
#line 113
  printf((char const   */* __restrict  */)tmp, "cable");
  }
#line 114
  return (0);
}
}
#line 47 "../../include/chain.h"
void chain_disconnect(chain_t *chain___0 ) ;
#line 49
int chain_set_trst(chain_t *chain___0 , int trst ) ;
#line 62 "../../include/cable.h"
int cable_init(cable_t *cable ) ;
#line 74
cable_driver_t *cable_drivers[15] ;
#line 60 "../../include/parport.h"
parport_driver_t *parport_drivers[4] ;
#line 31 "../../include/tap.h"
void tap_reset(chain_t *chain___0 ) ;
#line 40 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cable.c"
static int cmd_cable_run(char **params ) 
{ 
  cable_t *cable ;
  int i ;
  int paramc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmparam ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 45
  tmp = cmd_params(params);
#line 45
  paramc = tmp;
  }
#line 48
  if (paramc < 2) {
#line 48
    return (-1);
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! parport_drivers[i]) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp___0 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 52
    if (tmp___0 == 0) {
#line 53
      goto while_break;
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if ((unsigned long )parport_drivers[i] != (unsigned long )((parport_driver_t *)0)) {
    {
#line 58
    tmp___1 = gettext("Note: the \'cable\' command syntax changed, please read the help text\n");
#line 58
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 59
    if (paramc >= 4) {
#line 62
      tmparam = *(params + 3);
#line 63
      *(params + 3) = *(params + 2);
#line 64
      *(params + 2) = *(params + 1);
#line 65
      *(params + 1) = tmparam;
    } else {
#line 68
      return (-1);
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! cable_drivers[i]) {
#line 72
      goto while_break___0;
    }
    {
#line 73
    tmp___2 = strcasecmp((char const   *)*(params + 1), (cable_drivers[i])->name);
    }
#line 73
    if (tmp___2 == 0) {
#line 74
      goto while_break___0;
    }
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  if (! cable_drivers[i]) {
    {
#line 76
    tmp___3 = gettext("Unknown cable type: %s\n");
#line 76
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 77
    return (1);
  }
#line 80
  if (paramc >= 3) {
    {
#line 82
    tmp___4 = strcasecmp((char const   *)*(params + 2), "help");
    }
#line 82
    if (tmp___4 == 0) {
      {
#line 84
      (*((cable_drivers[i])->help))((cable_drivers[i])->name);
      }
#line 85
      return (1);
    }
  }
#line 89
  if (bus) {
    {
#line 90
    (*((bus->driver)->free_bus))(bus);
#line 91
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 94
  chain_disconnect(chain);
#line 96
  tmp___5 = malloc(sizeof(cable_t ));
#line 96
  cable = (cable_t *)tmp___5;
  }
#line 98
  if (! cable) {
    {
#line 99
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 99
    printf((char const   */* __restrict  */)tmp___6, "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cable.c",
           99);
    }
#line 100
    return (1);
  }
  {
#line 103
  cable->driver = cable_drivers[i];
#line 105
  params ++;
#line 105
  tmp___8 = (*((cable->driver)->connect))(params, cable);
  }
#line 105
  if (tmp___8) {
    {
#line 106
    tmp___7 = gettext("Error: Cable connection failed!\n");
#line 106
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 107
    return (1);
  }
  {
#line 110
  chain->cable = cable;
#line 112
  tmp___10 = cable_init(chain->cable);
  }
#line 112
  if (tmp___10) {
    {
#line 113
    tmp___9 = gettext("Error: Cable initialization failed!\n");
#line 113
    printf((char const   */* __restrict  */)tmp___9);
#line 114
    chain_disconnect(chain);
    }
#line 115
    return (1);
  }
  {
#line 117
  chain_set_trst(chain, 0);
#line 118
  chain_set_trst(chain, 1);
#line 119
  tap_reset(chain);
  }
#line 121
  return (1);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cable.c"
static void cmd_cable_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 129
  tmp = gettext("Usage: %s DRIVER [DRIVER_OPTS]\nSelect JTAG cable type.\n\nDRIVER      name of cable\nDRIVER_OPTS options for the selected cable\n\nType \"cable DRIVER help\" for info about options for cable DRIVER.\n\nList of supported cables:\n");
#line 129
  printf((char const   */* __restrict  */)tmp, "cable");
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! cable_drivers[i]) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp___0 = gettext((cable_drivers[i])->description);
#line 142
    tmp___1 = gettext("%-13s %s\n");
#line 142
    printf((char const   */* __restrict  */)tmp___1, (cable_drivers[i])->name, tmp___0);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/cable.c"
cmd_t cmd_cable  =    {(char *)"cable", (char *)"select JTAG cable", & cmd_cable_help, & cmd_cable_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bus.c"
static int cmd_bus_run(char **params ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable();
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & n);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
#line 53
  if (n >= (unsigned int )buses.len) {
    {
#line 54
    tmp___3 = gettext("%s: invalid bus number\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, "bus");
    }
#line 55
    return (1);
  }
#line 58
  bus = *(buses.buses + n);
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bus.c"
static void cmd_bus_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s BUS\nChange active bus.\n\nBUS           bus number\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "bus");
  }
#line 72
  return;
}
}
#line 74 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bus.c"
cmd_t cmd_bus  =    {(char *)"bus", (char *)"change active bus", & cmd_bus_help, & cmd_bus_run};
#line 51 "../../include/bsbit.h"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bit.c"
static void cmd_bit_print_params(char **params , unsigned int parameters , char *command ) 
{ 
  unsigned int i ;

  {
  {
#line 39
  strcpy((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + 0));
#line 40
  i = 1U;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < parameters)) {
#line 40
      goto while_break;
    }
    {
#line 41
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)" ");
#line 42
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + i));
#line 40
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bit.c"
static int cmd_bit_run(char **params ) 
{ 
  part_t *part___0 ;
  data_register *bsr ;
  unsigned int bit ;
  int type ;
  int safe ;
  unsigned int control ;
  unsigned int parameters ;
  int tmp ;
  char command[1024] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  signal_t *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 55
  tmp = cmd_params(params);
#line 55
  parameters = (unsigned int )tmp;
#line 58
  cmd_bit_print_params(params, parameters, command);
  }
#line 60
  if (parameters != 5U) {
#line 60
    if (parameters != 8U) {
      {
#line 61
      tmp___0 = gettext("%s: invalid number of parameters (%d) for command \'%s\'\n");
#line 61
      printf((char const   */* __restrict  */)tmp___0, "bit", parameters, command);
      }
#line 62
      return (-1);
    }
  }
  {
#line 65
  tmp___2 = cmd_test_cable();
  }
#line 65
  if (! tmp___2) {
    {
#line 66
    tmp___1 = gettext("%s: cable test failed for command \'%s\'\n");
#line 66
    printf((char const   */* __restrict  */)tmp___1, "bit", command);
    }
#line 67
    return (1);
  }
#line 70
  if (! chain->parts) {
    {
#line 71
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 71
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 72
    return (1);
  }
#line 75
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 76
    tmp___4 = gettext("%s: no active part\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4, "bit");
    }
#line 77
    return (1);
  }
  {
#line 80
  part___0 = *((chain->parts)->parts + chain->active_part);
#line 81
  bsr = part_find_data_register(part___0, "BSR");
  }
#line 82
  if ((unsigned long )bsr == (unsigned long )((void *)0)) {
    {
#line 83
    tmp___5 = gettext("%s: missing Boundary Scan Register (BSR) for command \'%s\'\n");
#line 83
    printf((char const   */* __restrict  */)tmp___5, "bit", command);
    }
#line 84
    return (1);
  }
  {
#line 88
  tmp___7 = cmd_get_number(*(params + 1), & bit);
  }
#line 88
  if (tmp___7) {
    {
#line 89
    tmp___6 = gettext("%s: unable to get boundary bit number for command \'%s\'\n");
#line 89
    printf((char const   */* __restrict  */)tmp___6, "bit", command);
    }
#line 90
    return (-1);
  }
#line 93
  if (bit >= (unsigned int )(bsr->in)->len) {
    {
#line 94
    tmp___8 = gettext("%s: invalid boundary bit number for command \'%s\'\n");
#line 94
    printf((char const   */* __restrict  */)tmp___8, "bit", command);
    }
#line 95
    return (1);
  }
#line 97
  if ((unsigned long )*(part___0->bsbits + bit) != (unsigned long )((void *)0)) {
    {
#line 98
    tmp___9 = gettext("%s: duplicate bit declaration for command \'%s\'\n");
#line 98
    printf((char const   */* __restrict  */)tmp___9, "bit", command);
    }
#line 99
    return (1);
  }
  {
#line 103
  tmp___11 = strlen((char const   *)*(params + 2));
  }
#line 103
  if (tmp___11 != 1UL) {
    {
#line 104
    tmp___10 = gettext("%s: invalid bit type length for command \'%s\'\n");
#line 104
    printf((char const   */* __restrict  */)tmp___10, "bit", command);
    }
#line 105
    return (-1);
  }
  {
#line 109
  if ((int )*(*(params + 2) + 0) == 105) {
#line 109
    goto case_105;
  }
#line 109
  if ((int )*(*(params + 2) + 0) == 73) {
#line 109
    goto case_105;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 111) {
#line 113
    goto case_111;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 79) {
#line 113
    goto case_111;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 98) {
#line 117
    goto case_98;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 66) {
#line 117
    goto case_98;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 99) {
#line 121
    goto case_99;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 67) {
#line 121
    goto case_99;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 120) {
#line 125
    goto case_120;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 88) {
#line 125
    goto case_120;
  }
#line 128
  goto switch_default;
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 110
  type = 1;
#line 111
  goto switch_break;
  case_111: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 114
  type = 2;
#line 115
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 118
  type = 5;
#line 119
  goto switch_break;
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 122
  type = 3;
#line 123
  goto switch_break;
  case_120: /* CIL Label */ 
  case_88: /* CIL Label */ 
#line 126
  type = 4;
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 129
  tmp___12 = gettext("%s: invalid bit type for command \'%s\'\n");
#line 129
  printf((char const   */* __restrict  */)tmp___12, "bit", command);
  }
#line 130
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___14 = strlen((char const   *)*(params + 3));
  }
#line 134
  if (tmp___14 != 1UL) {
    {
#line 135
    tmp___13 = gettext("%s: invalid default value length for command \'%s\'\n");
#line 135
    printf((char const   */* __restrict  */)tmp___13, "bit", command);
    }
#line 136
    return (-1);
  }
#line 139
  if ((int )*(*(params + 3) + 0) == 49) {
#line 139
    safe = 1;
  } else {
#line 139
    safe = 0;
  }
  {
#line 140
  *((bsr->in)->data + bit) = (char )safe;
#line 143
  tmp___15 = part_find_signal(part___0, (char const   *)*(params + 4));
#line 143
  *(part___0->bsbits + bit) = bsbit_alloc((int )bit, (char const   *)*(params + 4),
                                          type, tmp___15, safe);
  }
#line 144
  if ((unsigned long )*(part___0->bsbits + bit) == (unsigned long )((void *)0)) {
    {
#line 145
    tmp___16 = gettext("%s: out of memory for command \'%s\'\n");
#line 145
    printf((char const   */* __restrict  */)tmp___16, "bit", command);
    }
#line 146
    return (1);
  }
  {
#line 150
  tmp___17 = cmd_params(params);
  }
#line 150
  if (tmp___17 == 5) {
#line 151
    return (1);
  }
  {
#line 154
  tmp___19 = cmd_get_number(*(params + 5), & control);
  }
#line 154
  if (tmp___19) {
    {
#line 155
    tmp___18 = gettext("%s: unable to get control bit number for command \'%s\'\n");
#line 155
    printf((char const   */* __restrict  */)tmp___18, "bit", command);
    }
#line 156
    return (-1);
  }
#line 158
  if (control >= (unsigned int )(bsr->in)->len) {
    {
#line 159
    tmp___20 = gettext("%s: invalid control bit number for command \'%s\'\n");
#line 159
    printf((char const   */* __restrict  */)tmp___20, "bit", command);
    }
#line 160
    return (1);
  }
  {
#line 162
  (*(part___0->bsbits + bit))->control = (int )control;
#line 165
  tmp___22 = strlen((char const   *)*(params + 6));
  }
#line 165
  if (tmp___22 != 1UL) {
    {
#line 166
    tmp___21 = gettext("%s: invalid control value length for command \'%s\'\n");
#line 166
    printf((char const   */* __restrict  */)tmp___21, "bit", command);
    }
#line 167
    return (-1);
  }
#line 169
  if ((int )*(*(params + 6) + 0) == 49) {
#line 169
    (*(part___0->bsbits + bit))->control_value = 1;
  } else {
#line 169
    (*(part___0->bsbits + bit))->control_value = 0;
  }
  {
#line 172
  tmp___23 = strcasecmp((char const   *)*(params + 7), "Z");
  }
#line 172
  if (tmp___23) {
#line 173
    return (-1);
  }
#line 175
  (*(part___0->bsbits + bit))->control_state = -1;
#line 177
  return (1);
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bit.c"
static void cmd_bit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 183
  tmp = gettext("Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\nDefine new BSR (Boundary Scan Register) bit for SIGNAL, with\nDEFAULT value.\n\nNUMBER        Bit number in the BSR\nTYPE          Bit type, valid values are I, O, B, C, and X\nDEFAULT       Default (safe) bit value, valid values are 1, 0, ?\nSIGNAL        Associated signal name\nCBIT          Control bit number\nCVAL          Control value\nCSTATE        Control state, valid state is only Z\n");
#line 183
  printf((char const   */* __restrict  */)tmp, "bit");
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.7/src/cmd/bit.c"
cmd_t cmd_bit  =    {(char *)"bit", (char *)"define new BSR bit", & cmd_bit_help, & cmd_bit_run};
#line 31 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/quit.c"
static int cmd_quit_run___0(char **params ) 
{ 


  {
#line 34
  if (*(params + 1)) {
#line 35
    return (-1);
  }
#line 37
  return (0);
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/quit.c"
static void cmd_quit_help___0(void) 
{ 
  char *tmp ;

  {
  {
#line 43
  tmp = gettext("Usage: %s\nExit from %s.\n");
#line 43
  printf((char const   */* __restrict  */)tmp, "quit", "libbrux");
  }
#line 47
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
static struct amd_flash_info  const  table___0[21]  = 
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )32768,
                                          (u_int32_t )1}, {(u_int32_t )2064384, (u_int32_t )8192,
                                                           (u_int32_t )2}, {(u_int32_t )2080768,
                                                                            (u_int32_t )16384,
                                                                            (u_int32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )1, (int const   )8918, "AMD AM29F800BT", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )15}, {(u_int32_t )983040,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )1015808,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )1032192,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )4, (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384,
                                                                (u_int32_t )1}, {(u_int32_t )16384,
                                                                                 (u_int32_t )8192,
                                                                                 (u_int32_t )2},
                                                               {(u_int32_t )32768,
                                                                (u_int32_t )32768,
                                                                (u_int32_t )1}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )15},
                                         {(u_int32_t )983040, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )1015808, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )1032192, (u_int32_t )16384,
                                          (u_int32_t )1}}}, 
        {(int const   )32, (int const   )8900, "ST M29W160DT", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )31}, {(u_int32_t )2031616,
                                                                                  (u_int32_t )32768,
                                                                                  (u_int32_t )1},
                                                               {(u_int32_t )2064384,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )2}, {(u_int32_t )2080768,
                                                                                 (u_int32_t )16384,
                                                                                 (u_int32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )16384, (u_int32_t )1},
                                         {(u_int32_t )16384, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )32768, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )65536, (u_int32_t )65536, (u_int32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (u_int8_t const   )1,
      (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )48},
                                         {(u_int32_t )3145728, (u_int32_t )65536,
                                          (u_int32_t )15}, {(u_int32_t )4128768, (u_int32_t )8192,
                                                            (u_int32_t )8}}}, 
        {(int const   )1, (int const   )8830, "AMD AM29BDS643D", (long const   )8388608,
      (u_int8_t const   )1, (int const   )0, (int const   )3, {{(u_int32_t )0, (u_int32_t )65536,
                                                                (u_int32_t )96}, {(u_int32_t )6291456,
                                                                                  (u_int32_t )65536,
                                                                                  (u_int32_t )31},
                                                               {(u_int32_t )8323072,
                                                                (u_int32_t )8192,
                                                                (u_int32_t )8}}}, 
        {(int const   )31, (int const   )192, "Atmel AT49xV16x", (long const   )2097152,
      (u_int8_t const   )1, (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )8192,
                                                                (u_int32_t )8}, {(u_int32_t )65536,
                                                                                 (u_int32_t )65536,
                                                                                 (u_int32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (u_int8_t const   )1,
      (int const   )0, (int const   )2, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )31},
                                         {(u_int32_t )2031616, (u_int32_t )8192, (u_int32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (u_int8_t const   )1,
      (int const   )0, (int const   )4, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )7},
                                         {(u_int32_t )458752, (u_int32_t )32768, (u_int32_t )1},
                                         {(u_int32_t )491520, (u_int32_t )8192, (u_int32_t )2},
                                         {(u_int32_t )507904, (u_int32_t )16384, (u_int32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (u_int8_t const   )0,
      (int const   )1, (int const   )1, {{(u_int32_t )0, (u_int32_t )65536, (u_int32_t )8}}}};
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 52
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 54
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 62
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 62
  if (tmp != 0) {
#line 63
    return (0);
  }
#line 65
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 65
    goto _L;
  } else
#line 65
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 65
    if (area.width == 32U) {
#line 65
      tmp___0 = 1;
    } else {
#line 65
      tmp___0 = 0;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
#line 65
  return (tmp___0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 75
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 75
  if (tmp != 0) {
#line 76
    return (0);
  }
#line 78
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 78
    goto _L;
  } else
#line 78
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 78
    if (area.width == 16U) {
#line 78
      tmp___0 = 1;
    } else {
#line 78
      tmp___0 = 0;
    }
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  return (tmp___0);
}
}
#line 83 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 88
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 88
  if (tmp != 0) {
#line 89
    return (0);
  }
#line 91
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 91
    goto _L;
  } else
#line 91
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 91
    if (area.width == 8U) {
#line 91
      tmp___0 = 1;
    } else {
#line 91
      tmp___0 = 0;
    }
  } else {
#line 91
    tmp___0 = 0;
  }
#line 91
  return (tmp___0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void _intel_flash_print_info___0(cfi_array_t *cfi_array___0 , int o___1 ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 100
  bus___0 = cfi_array___0->bus;
#line 102
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 102
  mid = tmp & 255U;
  }
  {
#line 104
  if (mid == 137U) {
#line 104
    goto case_137;
  }
#line 107
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 105
  tmp___0 = gettext("Manufacturer: %s\n");
#line 105
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 106
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 108
  tmp___1 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 108
  printf((char const   */* __restrict  */)tmp___1, mid);
  }
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 112
  tmp___2 = gettext("Chip: ");
#line 112
  printf((char const   */* __restrict  */)tmp___2);
#line 113
  tmp___3 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o___1));
#line 113
  cid = tmp___3 & 65535U;
  }
  {
#line 115
  if (cid == 22U) {
#line 115
    goto case_22;
  }
#line 118
  if (cid == 23U) {
#line 118
    goto case_23;
  }
#line 121
  if (cid == 24U) {
#line 121
    goto case_24;
  }
#line 124
  if (cid == 29U) {
#line 124
    goto case_29;
  }
#line 127
  if (cid == 34817U) {
#line 127
    goto case_34817;
  }
#line 130
  if (cid == 34818U) {
#line 130
    goto case_34818;
  }
#line 133
  if (cid == 34819U) {
#line 133
    goto case_34819;
  }
#line 136
  if (cid == 34821U) {
#line 136
    goto case_34821;
  }
#line 139
  if (cid == 34822U) {
#line 139
    goto case_34822;
  }
#line 142
  if (cid == 34823U) {
#line 142
    goto case_34823;
  }
#line 145
  if (cid == 34827U) {
#line 145
    goto case_34827;
  }
#line 148
  if (cid == 34828U) {
#line 148
    goto case_34828;
  }
#line 151
  if (cid == 34829U) {
#line 151
    goto case_34829;
  }
#line 154
  if (cid == 34830U) {
#line 154
    goto case_34830;
  }
#line 157
  if (cid == 34831U) {
#line 157
    goto case_34831;
  }
#line 160
  if (cid == 34832U) {
#line 160
    goto case_34832;
  }
#line 163
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 116
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 117
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 119
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 120
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 122
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 123
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 125
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 126
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 128
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 129
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 131
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 132
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 134
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 135
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 137
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 138
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 140
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 141
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 143
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 144
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 147
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 149
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 150
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 152
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 153
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 155
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 156
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 158
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 159
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 161
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 162
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 164
  tmp___4 = gettext("Unknown (0x%02X)!\n");
#line 164
  printf((char const   */* __restrict  */)tmp___4, cid);
  }
#line 165
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 169
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 170
  return;
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o___1 ;
  bus_t *bus___0 ;

  {
  {
#line 175
  o___1 = 1;
#line 176
  bus___0 = cfi_array___0->bus;
#line 182
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 185
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 187
  _intel_flash_print_info___0(cfi_array___0, o___1);
  }
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_print_info32___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o___1 ;
  bus_t *bus___0 ;

  {
  {
#line 193
  o___1 = 2;
#line 194
  bus___0 = cfi_array___0->bus;
#line 199
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 202
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 204
  _intel_flash_print_info___0(cfi_array___0, o___1);
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 211
  bus___0 = cfi_array___0->bus;
#line 213
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 214
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 215
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 217
    sr = (uint16_t )(tmp & 254U);
    }
#line 217
    if ((int )sr & (1 << 7)) {
#line 217
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 220
    goto case_0;
  }
#line 222
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 222
    goto case_exp;
  }
#line 225
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 225
    goto case_exp___0;
  }
#line 228
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 228
    goto case_exp___1;
  }
#line 231
  goto switch_default;
  case_0: /* CIL Label */ 
#line 221
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 223
  tmp___0 = gettext("flash: invalid command seq\n");
#line 223
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 224
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 226
  tmp___1 = gettext("flash: low vpen\n");
#line 226
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 227
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 229
  tmp___2 = gettext("flash: block locked\n");
#line 229
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 230
  return (3);
  switch_default: /* CIL Label */ 
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 235
  return (99);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 242
  bus___0 = cfi_array___0->bus;
#line 244
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 245
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 246
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 248
    sr = (uint16_t )(tmp & 254U);
    }
#line 248
    if ((int )sr & (1 << 7)) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if ((int )sr != 1 << 7) {
    {
#line 251
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 251
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 252
    return (99);
  } else {
#line 254
    return (0);
  }
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 261
  bus___0 = cfi_array___0->bus;
#line 263
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 264
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 265
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 267
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 267
    sr = (uint16_t )(tmp & 254U);
    }
#line 267
    if ((int )sr & (1 << 7)) {
#line 267
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if ((int )sr != 1 << 7) {
    {
#line 270
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 270
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 271
    return (99);
  } else {
#line 273
    return (0);
  }
}
}
#line 276 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 280
  bus___0 = cfi_array___0->bus;
#line 282
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 283
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 284
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 286
    sr = tmp & 16646398U;
    }
#line 286
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 289
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 290
    return (99);
  } else {
#line 292
    return (0);
  }
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 299
  bus___0 = cfi_array___0->bus;
#line 301
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 302
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 303
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 305
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 305
    sr = tmp & 16646398U;
    }
#line 305
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 305
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 308
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 309
    return (99);
  } else {
#line 311
    return (0);
  }
}
}
#line 314 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 318
  bus___0 = cfi_array___0->bus;
#line 320
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 321
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 322
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 324
    sr = tmp & 16646398U;
    }
#line 324
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 324
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 327
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 328
    return (99);
  } else {
#line 330
    return (0);
  }
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_readarray32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 337
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 338
  return;
}
}
#line 340 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/intel.c"
static void intel_flash_readarray___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 344
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 345
  return;
}
}
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/help.c"
static int cmd_help_run___0(char **params ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 38
  if (! *(params + 1)) {
    {
#line 39
    tmp = gettext("Command list:\n\n");
#line 39
    printf((char const   */* __restrict  */)tmp);
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! cmds[i]) {
#line 40
        goto while_break;
      }
#line 41
      if ((cmds[i])->desc) {
        {
#line 41
        tmp___0 = gettext((char const   *)(cmds[i])->desc);
#line 41
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 41
        tmp___1 = gettext("(no description available)");
#line 41
        tmp___2 = tmp___1;
        }
      }
      {
#line 41
      tmp___3 = gettext("%-13s %s\n");
#line 41
      printf((char const   */* __restrict  */)tmp___3, (cmds[i])->name, tmp___2);
#line 40
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    tmp___4 = gettext("\nType \"help COMMAND\" for details about a particular command.\n");
#line 42
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 43
    return (1);
  }
#line 46
  if (*(params + 2)) {
#line 47
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! cmds[i]) {
#line 50
      goto while_break___0;
    }
    {
#line 51
    tmp___5 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 1));
    }
#line 51
    if (tmp___5 == 0) {
#line 52
      if ((cmds[i])->help) {
        {
#line 53
        (*((cmds[i])->help))();
        }
      }
#line 54
      return (1);
    }
#line 50
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  tmp___6 = gettext("%s: unknown command\n");
#line 57
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 59
  return (1);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/help.c"
static void cmd_help_help___0(void) 
{ 
  char *tmp ;

  {
  {
#line 65
  tmp = gettext("Usage: %s [COMMAND]\nPrint short help for COMMAND, or list of available commands.\n");
#line 65
  printf((char const   */* __restrict  */)tmp, "help");
  }
#line 69
  return;
}
}
#line 32 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd_detectflash.c"
static int cmd_detectflash_run___0(char **params ) 
{ 
  uint32_t adr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp != 2) {
#line 38
    return (-1);
  }
#line 40
  if (! bus) {
    {
#line 41
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 41
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 42
    return (1);
  }
  {
#line 45
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 45
  if (tmp___1) {
#line 46
    return (-1);
  }
  {
#line 48
  detectflash(bus, adr);
  }
#line 50
  return (1);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/cmd/cmd_detectflash.c"
static void cmd_detectflash_help___0(void) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("Usage: %s ADDRESS\nDetect flash memory type connected to a part.\n\nADDRESS    Base address for memory region\n");
#line 56
  printf((char const   */* __restrict  */)tmp, "detectflash");
  }
#line 62
  return;
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int dbg___0  =    0;
#line 49
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 52
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int o___0  ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 60
  if (cfi_array___0->bus_width != 4) {
#line 60
    return (0);
  }
#line 61
  o___0 = 2;
#line 62
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect16___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 68
  if (cfi_array___0->bus_width != 2) {
#line 68
    return (0);
  }
#line 69
  o___0 = 1;
#line 70
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 76
  if (cfi_array___0->bus_width != 1) {
#line 76
    return (0);
  }
#line 77
  o___0 = 0;
#line 78
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amdstatus___0(bus_t *bus___0 , uint32_t adr , int data ) 
{ 
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;

  {
#line 128
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 131
  timeout = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (timeout < 100)) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 132
    data1 = tmp;
#line 133
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 133
    data2 = tmp___0;
    }
#line 137
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 138
      return (1);
    }
#line 142
    if (dbg___0) {
      {
#line 143
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    } else {
      {
#line 145
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 146
    usleep((__useconds_t )100);
#line 131
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (0);
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static void amd_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 223
  bus___0 = cfi_array___0->bus;
#line 225
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )11141290);
#line 226
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o___0),
                                (uint32_t )5570645);
#line 227
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )9437328);
#line 228
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 228
  mid = (int )(tmp & 65535U);
#line 229
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o___0));
#line 229
  cid = (int )(tmp___0 & 65535U);
#line 230
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o___0));
#line 230
  prot = (int )(tmp___1 & 255U);
#line 231
  amd_flash_read_array___0(cfi_array___0);
#line 232
  tmp___2 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 232
  printf((char const   */* __restrict  */)tmp___2);
  }
  {
#line 234
  if (mid == 1) {
#line 234
    goto case_1;
  }
#line 237
  if (mid == 32) {
#line 237
    goto case_32;
  }
#line 240
  if (mid == 44) {
#line 240
    goto case_44;
  }
#line 243
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 235
  tmp___3 = gettext("AMD");
#line 235
  printf((char const   */* __restrict  */)tmp___3);
  }
#line 236
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 238
  tmp___4 = gettext("ST/Samsung");
#line 238
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 239
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 241
  tmp___5 = gettext("Macronix");
#line 241
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 242
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 244
  tmp___6 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 244
  printf((char const   */* __restrict  */)tmp___6, mid);
  }
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 247
  tmp___7 = gettext("\n\tChip: ");
#line 247
  printf((char const   */* __restrict  */)tmp___7);
  }
  {
#line 249
  if (cid == 79) {
#line 249
    goto case_79;
  }
#line 252
  if (cid == 8919) {
#line 252
    goto case_8919;
  }
#line 255
  if (cid == 8795) {
#line 255
    goto case_8795;
  }
#line 258
  if (cid == 8777) {
#line 258
    goto case_8777;
  }
#line 261
  if (cid == 73) {
#line 261
    goto case_73;
  }
#line 264
  if (cid == 147) {
#line 264
    goto case_147;
  }
#line 267
  if (cid == 202) {
#line 267
    goto case_202;
  }
#line 270
  if (cid == 203) {
#line 270
    goto case_203;
  }
#line 273
  goto switch_default___0;
  case_79: /* CIL Label */ 
  {
#line 250
  tmp___8 = gettext("Am29LV040B");
#line 250
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 251
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 253
  tmp___9 = gettext("Am29LV640D/Am29LV641D/Am29LV642D");
#line 253
  printf((char const   */* __restrict  */)tmp___9);
  }
#line 254
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 256
  tmp___10 = gettext("Am29LV800B");
#line 256
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 257
  goto switch_break___0;
  case_8777: /* CIL Label */ 
  {
#line 259
  tmp___11 = gettext("MX29LV160B");
#line 259
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 260
  goto switch_break___0;
  case_73: /* CIL Label */ 
  {
#line 262
  tmp___12 = gettext("AM29LV160DB");
#line 262
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 263
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 265
  tmp___13 = gettext("Am29LV065D");
#line 265
  printf((char const   */* __restrict  */)tmp___13);
  }
#line 266
  goto switch_break___0;
  case_202: /* CIL Label */ 
  {
#line 268
  tmp___14 = gettext("M29W320DT");
#line 268
  printf((char const   */* __restrict  */)tmp___14);
  }
#line 269
  goto switch_break___0;
  case_203: /* CIL Label */ 
  {
#line 271
  tmp___15 = gettext("M29W320DB");
#line 271
  printf((char const   */* __restrict  */)tmp___15);
  }
#line 272
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 274
  tmp___16 = gettext("Unknown (ID 0x%04x)");
#line 274
  printf((char const   */* __restrict  */)tmp___16, cid);
  }
#line 275
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 277
  tmp___17 = gettext("\n\tProtected: %04x\n");
#line 277
  printf((char const   */* __restrict  */)tmp___17, prot);
#line 280
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 281
  return;
}
}
#line 283 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 286
  bus___0 = cfi_array___0->bus;
#line 288
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 292
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )11141290);
#line 293
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o___0),
                                (uint32_t )5570645);
#line 294
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )8388736);
#line 295
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )11141290);
#line 296
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o___0),
                                (uint32_t )5570645);
#line 297
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 299
  tmp = amdstatus___0(bus___0, adr, 65535);
  }
#line 299
  if (tmp) {
    {
#line 300
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 301
    amd_flash_read_array___0(cfi_array___0);
    }
#line 302
    return (0);
  }
  {
#line 304
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 306
  amd_flash_read_array___0(cfi_array___0);
  }
#line 308
  return (99);
}
}
#line 311 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 314
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 315
  return (0);
}
}
#line 318 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 322
  bus___0 = cfi_array___0->bus;
#line 324
  if (dbg___0) {
    {
#line 325
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 327
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )11141290);
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o___0),
                                (uint32_t )5570645);
#line 329
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o___0),
                                (uint32_t )10485920);
#line 331
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 332
  status = amdstatus___0(bus___0, adr, (int )data);
  }
#line 335
  return (! status);
}
}
#line 338 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd.c"
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 342
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 343
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) ;
#line 79
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 80
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) ;
#line 81
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 82
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 83
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 84
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 167 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 169
  return (var_forced_detection.flash == 1UL);
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 178
  dq7mask = (unsigned short )(1 << 7);
#line 179
  dq5mask = (unsigned short )(1 << 5);
#line 180
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 182
  timeout = (short)0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((int )timeout < 1000)) {
#line 182
      goto while_break;
    }
    {
#line 184
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 184
    data1 = (unsigned short )(tmp & 255U);
    }
#line 185
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 186
      return (1);
    }
#line 188
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 190
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 190
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 191
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 193
        return (1);
      } else {
#line 197
        return (0);
      }
    }
    {
#line 200
    usleep((__useconds_t )50);
#line 182
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (0);
}
}
#line 208 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 211
  bus___0 = cfi_array___0->bus;
#line 214
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 217
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 218
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 218
  mid = (int )tmp;
#line 219
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 219
  did = (int )tmp___0;
#line 220
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 220
  prot = (int )tmp___1;
#line 221
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 223
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 228
  if (mid == 1) {
#line 228
    goto case_1;
  }
#line 231
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 229
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 229
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 230
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 232
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 232
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp___4 = gettext("\n\tChip: ");
#line 235
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 237
  if (did == 164) {
#line 237
    goto case_164;
  }
#line 241
  if (did == 79) {
#line 241
    goto case_79;
  }
#line 245
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 238
  tmp___5 = gettext("Am29C040B\t-\t");
#line 238
  printf((char const   */* __restrict  */)tmp___5);
#line 239
  tmp___6 = gettext("5V Flash\n");
#line 239
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 240
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 242
  tmp___7 = gettext("Am29LV040B\t-\t");
#line 242
  printf((char const   */* __restrict  */)tmp___7);
#line 243
  tmp___8 = gettext("3V Flash\n");
#line 243
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 244
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 246
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 246
  printf((char const   */* __restrict  */)tmp___9, did);
  }
#line 247
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 249
  tmp___10 = gettext("\n\tProtected: %04x\n");
#line 249
  printf((char const   */* __restrict  */)tmp___10, prot);
  }
#line 250
  return;
}
}
#line 252 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 255
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 257
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 258
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 259
    usleep((__useconds_t )100);
#line 260
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 262
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 263
  return;
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 271
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 275
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 277
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 278
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 279
    usleep((__useconds_t )100);
#line 280
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 283
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 288
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 290
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 293
  tmp = amd_29xx040_status___0(bus___0, adr, (unsigned short)255);
  }
#line 293
  if (tmp) {
    {
#line 294
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 295
    amd_29xx040_read_array___0(cfi_array___0);
    }
#line 296
    return (1);
  }
  {
#line 298
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 300
  amd_29xx040_read_array___0(cfi_array___0);
  }
#line 302
  return (-5);
}
}
#line 305 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 308
  bus___0 = cfi_array___0->bus;
#line 312
  if ((int )var_forced_detection.algorithm == 1) {
#line 314
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 316
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 318
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 319
      usleep((__useconds_t )1000);
#line 320
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 325
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 326
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 329
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 330
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 331
  status = amd_29xx040_status___0(bus___0, adr, (unsigned short )data);
  }
#line 334
  return (! status);
}
}
#line 337 "/home/khheo/project/benchmark/urjtag-0.7/libbrux/flash/amd_flash.c"
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 339
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 340
  return (0);
}
}
#line 40 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern long __sysconf(int  ) ;
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/lib/fclock.c"
extern int ( /* missing proto */  __builtin_isnormal)() ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/src/lib/fclock.c"
long double frealtime(void) 
{ 
  long double result ;
  struct timespec t ;
  int tmp ;
  int tmp___3 ;

  {
  {
#line 55
  tmp = clock_gettime(0, & t);
  }
#line 55
  if (tmp == -1) {
    {
#line 56
    perror("frealtime (clock_gettime)");
#line 57
    exit(1);
    }
  }
  {
#line 59
  result = (long double )t.tv_sec + (long double )t.tv_nsec * (long double )1e-9;
#line 69
  tmp___3 = __builtin_isnormal(result);
  }
#line 69
  if (! tmp___3) {
    {
#line 69
    __assert_fail("isnormal(result)", "/home/khheo/project/benchmark/urjtag-0.7/src/lib/fclock.c",
                  69U, "frealtime");
    }
  }
#line 70
  if (! (result > (long double )0)) {
    {
#line 70
    __assert_fail("result > 0", "/home/khheo/project/benchmark/urjtag-0.7/src/lib/fclock.c",
                  70U, "frealtime");
    }
  }
#line 71
  return (result);
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.7/src/lib/fclock.c"
long double fcputime(void) 
{ 
  struct tms t ;
  clock_t c ;
  clock_t tmp ;
  long tmp___0 ;

  {
  {
#line 79
  tmp = times(& t);
#line 79
  c = tmp;
  }
#line 80
  if (c == -1L) {
    {
#line 81
    perror("fcputime (times)");
#line 82
    exit(1);
    }
  }
  {
#line 84
  tmp___0 = __sysconf(2);
  }
#line 84
  return (((long double )t.tms_utime + (long double )t.tms_stime) / (long double )tmp___0);
}
}
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 50 "../../include/bssignal.h"
void signal_free(signal_t *s ) ;
#line 53
void salias_free(salias_t *salias ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.7/src/part/signal.c"
signal_t *signal_alloc(char const   *name ) 
{ 
  signal_t *s ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*s));
#line 33
  s = (signal_t *)tmp;
  }
#line 34
  if (! s) {
#line 35
    return ((signal_t *)((void *)0));
  }
  {
#line 37
  s->name = strdup(name);
  }
#line 38
  if (! s->name) {
    {
#line 39
    free((void *)s);
    }
#line 40
    return ((signal_t *)((void *)0));
  }
#line 42
  s->pin = (char *)((void *)0);
#line 43
  s->next = (signal_t *)((void *)0);
#line 44
  s->input = (bsbit_t *)((void *)0);
#line 45
  s->output = (bsbit_t *)((void *)0);
#line 47
  return (s);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.7/src/part/signal.c"
void signal_free(signal_t *s ) 
{ 


  {
#line 53
  if (! s) {
#line 54
    return;
  }
  {
#line 55
  free((void *)s->name);
#line 56
  free((void *)s);
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/part/signal.c"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) 
{ 
  salias_t *sa ;
  void *tmp ;

  {
  {
#line 62
  tmp = malloc(sizeof(*sa));
#line 62
  sa = (salias_t *)tmp;
  }
#line 63
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 64
    return ((salias_t *)((void *)0));
  }
  {
#line 66
  sa->name = strdup(name);
  }
#line 67
  if ((unsigned long )sa->name == (unsigned long )((void *)0)) {
    {
#line 68
    free((void *)sa);
    }
#line 69
    return ((salias_t *)((void *)0));
  }
#line 71
  sa->next = (salias_t *)((void *)0);
#line 72
  sa->signal = (signal_t *)signal;
#line 74
  return (sa);
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.7/src/part/signal.c"
void salias_free(salias_t *salias ) 
{ 


  {
#line 79
  if ((unsigned long )salias == (unsigned long )((void *)0)) {
#line 80
    return;
  }
  {
#line 81
  free((void *)salias->name);
#line 82
  free((void *)salias);
  }
#line 83
  return;
}
}
#line 52 "../../include/bsbit.h"
void bsbit_free(bsbit_t *b ) ;
#line 36 "../../include/register.h"
tap_register *register_duplicate(tap_register const   *tr ) ;
#line 42 "../../include/data_register.h"
void data_register_free(data_register *dr___0 ) ;
#line 43 "../../include/instruction.h"
void instruction_free(instruction *i ) ;
#line 57 "../../include/part.h"
part_t *part_alloc(tap_register const   *id ) ;
#line 58
void part_free(part_t *p ) ;
#line 75
parts_t *parts_alloc(void) ;
#line 77
int parts_add_part(parts_t *ps , part_t *p ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
part_t *part_alloc(tap_register const   *id ) 
{ 
  part_t *p ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc(sizeof(*p));
#line 37
  p = (part_t *)tmp;
  }
#line 38
  if (! p) {
#line 39
    return ((part_t *)((void *)0));
  }
  {
#line 40
  p->alias = (char *)((void *)0);
#line 41
  p->id = register_duplicate(id);
#line 42
  p->manufacturer[0] = (char )'\000';
#line 43
  p->part[0] = (char )'\000';
#line 44
  p->stepping[0] = (char )'\000';
#line 45
  p->signals = (signal_t *)((void *)0);
#line 46
  p->saliases = (salias_t *)((void *)0);
#line 47
  p->instruction_length = 0;
#line 48
  p->instructions = (instruction *)((void *)0);
#line 49
  p->active_instruction = (instruction *)((void *)0);
#line 50
  p->data_registers = (data_register *)((void *)0);
#line 51
  p->boundary_length = 0;
#line 52
  p->bsbits = (bsbit_t **)((void *)0);
  }
#line 54
  return (p);
}
}
#line 57 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void part_free(part_t *p ) 
{ 
  int i ;
  signal_t *s ;
  salias_t *sa ;
  instruction *i___0 ;
  data_register *dr___0 ;

  {
#line 62
  if (! p) {
#line 63
    return;
  }
  {
#line 66
  free((void *)p->id);
  }
#line 68
  if (p->alias) {
    {
#line 68
    free((void *)p->alias);
    }
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! p->signals) {
#line 71
      goto while_break;
    }
    {
#line 72
    s = p->signals;
#line 73
    p->signals = s->next;
#line 74
    signal_free(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! p->saliases) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    sa = p->saliases;
#line 80
    p->saliases = sa->next;
#line 81
    salias_free(sa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! p->instructions) {
#line 85
      goto while_break___1;
    }
    {
#line 86
    i___0 = p->instructions;
#line 87
    p->instructions = i___0->next;
#line 88
    instruction_free(i___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 92
    if (! p->data_registers) {
#line 92
      goto while_break___2;
    }
    {
#line 93
    dr___0 = p->data_registers;
#line 94
    p->data_registers = dr___0->next;
#line 95
    data_register_free(dr___0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 99
    if (! (i < p->boundary_length)) {
#line 99
      goto while_break___3;
    }
    {
#line 100
    bsbit_free(*(p->bsbits + i));
#line 99
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)p->bsbits);
#line 103
  free((void *)p);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
instruction *part_find_instruction(part_t *p , char const   *iname ) 
{ 
  instruction *i ;
  int tmp ;

  {
#line 111
  if (! p) {
#line 112
    return ((instruction *)((void *)0));
  } else
#line 111
  if (! iname) {
#line 112
    return ((instruction *)((void *)0));
  }
#line 114
  i = p->instructions;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break;
    }
    {
#line 116
    tmp = strcasecmp(iname, (char const   *)(i->name));
    }
#line 116
    if (tmp == 0) {
#line 117
      goto while_break;
    }
#line 118
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (i);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
data_register *part_find_data_register(part_t *p , char const   *drname ) 
{ 
  data_register *dr___0 ;
  int tmp ;

  {
#line 129
  if (! p) {
#line 130
    return ((data_register *)((void *)0));
  } else
#line 129
  if (! drname) {
#line 130
    return ((data_register *)((void *)0));
  }
#line 132
  dr___0 = p->data_registers;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! dr___0) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp = strcasecmp(drname, (char const   *)(dr___0->name));
    }
#line 134
    if (tmp == 0) {
#line 135
      goto while_break;
    }
#line 136
    dr___0 = dr___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (dr___0);
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
signal_t *part_find_signal(part_t *p , char const   *signalname ) 
{ 
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;

  {
#line 148
  if (! p) {
#line 149
    return ((signal_t *)((void *)0));
  } else
#line 148
  if (! signalname) {
#line 149
    return ((signal_t *)((void *)0));
  }
#line 151
  s = p->signals;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! s) {
#line 152
      goto while_break;
    }
    {
#line 153
    tmp = strcasecmp(signalname, (char const   *)s->name);
    }
#line 153
    if (tmp == 0) {
#line 154
      return (s);
    }
#line 155
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  sa = p->saliases;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! sa) {
#line 159
      goto while_break___0;
    }
    {
#line 160
    tmp___0 = strcasecmp(signalname, (char const   *)sa->name);
    }
#line 160
    if (tmp___0 == 0) {
#line 161
      return (sa->signal);
    }
#line 162
    sa = sa->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return ((signal_t *)((void *)0));
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void part_set_instruction(part_t *p , char const   *iname ) 
{ 


  {
#line 171
  if (p) {
    {
#line 172
    p->active_instruction = part_find_instruction(p, iname);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) 
{ 
  data_register *bsr ;
  char *tmp ;
  int control ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 180
  if (! p) {
#line 181
    return;
  } else
#line 180
  if (! s) {
#line 181
    return;
  }
  {
#line 184
  bsr = part_find_data_register(p, "BSR");
  }
#line 185
  if (! bsr) {
    {
#line 186
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 186
    printf((char const   */* __restrict  */)tmp, "part_set_signal", "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c",
           186);
    }
#line 187
    return;
  }
#line 191
  if (out) {
#line 193
    if (! s->output) {
      {
#line 194
      tmp___0 = gettext("signal \'%s\' cannot be set as output\n");
#line 194
      printf((char const   */* __restrict  */)tmp___0, s->name);
      }
#line 195
      return;
    }
#line 197
    *((bsr->in)->data + (s->output)->bit) = (char )(val & 1);
#line 199
    control = (*(p->bsbits + (s->output)->bit))->control;
#line 200
    if (control >= 0) {
#line 201
      *((bsr->in)->data + control) = (char )((*(p->bsbits + (s->output)->bit))->control_value ^ 1);
    }
  } else {
#line 203
    if (! s->input) {
      {
#line 204
      tmp___1 = gettext("signal \'%s\' cannot be set as input\n");
#line 204
      printf((char const   */* __restrict  */)tmp___1, s->name);
      }
#line 205
      return;
    }
#line 207
    if (s->output) {
#line 208
      *((bsr->in)->data + (s->output)->control) = (char )(*(p->bsbits + (s->output)->bit))->control_value;
    }
  }
#line 210
  return;
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
int part_get_signal(part_t *p , signal_t *s ) 
{ 
  data_register *bsr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 217
  if (! p) {
#line 218
    return (-1);
  } else
#line 217
  if (! s) {
#line 218
    return (-1);
  }
  {
#line 221
  bsr = part_find_data_register(p, "BSR");
  }
#line 222
  if (! bsr) {
    {
#line 223
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 223
    printf((char const   */* __restrict  */)tmp, "part_get_signal", "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c",
           223);
    }
#line 224
    return (-1);
  }
#line 227
  if (! s->input) {
    {
#line 228
    tmp___0 = gettext("signal \'%s\' is not input signal\n");
#line 228
    printf((char const   */* __restrict  */)tmp___0, s->name);
    }
#line 229
    return (-1);
  }
#line 232
  return ((int )*((bsr->out)->data + (s->input)->bit));
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void part_print(part_t *p ) 
{ 
  char *instruction___0 ;
  char *dr___0 ;
  char format[100] ;
  char *tmp ;

  {
#line 238
  instruction___0 = (char *)((void *)0);
#line 239
  dr___0 = (char *)((void *)0);
#line 242
  if (! p) {
#line 243
    return;
  }
  {
#line 245
  tmp = gettext("%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 245
  snprintf((char */* __restrict  */)(format), (size_t )100, (char const   */* __restrict  */)tmp,
           25, 20, 8, 20, 10);
  }
#line 248
  if (p->active_instruction) {
#line 249
    instruction___0 = (p->active_instruction)->name;
#line 250
    if ((unsigned long )(p->active_instruction)->data_register != (unsigned long )((void *)0)) {
#line 251
      dr___0 = ((p->active_instruction)->data_register)->name;
    }
  }
#line 253
  if ((unsigned long )instruction___0 == (unsigned long )((void *)0)) {
    {
#line 254
    instruction___0 = gettext("(none)");
    }
  }
#line 255
  if ((unsigned long )dr___0 == (unsigned long )((void *)0)) {
    {
#line 256
    dr___0 = gettext("(none)");
    }
  }
  {
#line 257
  printf((char const   */* __restrict  */)(format), p->manufacturer, p->part, p->stepping,
         instruction___0, dr___0);
  }
#line 258
  return;
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
parts_t *parts_alloc(void) 
{ 
  parts_t *ps ;
  void *tmp ;

  {
  {
#line 265
  tmp = malloc(sizeof(*ps));
#line 265
  ps = (parts_t *)tmp;
  }
#line 266
  if (! ps) {
#line 267
    return ((parts_t *)((void *)0));
  }
#line 269
  ps->len = 0;
#line 270
  ps->parts = (part_t **)((void *)0);
#line 272
  return (ps);
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void parts_free(parts_t *ps ) 
{ 
  int i ;

  {
#line 280
  if (! ps) {
#line 281
    return;
  }
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < ps->len)) {
#line 283
      goto while_break;
    }
    {
#line 284
    part_free(*(ps->parts + i));
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  free((void *)ps->parts);
#line 287
  free((void *)ps);
  }
#line 288
  return;
}
}
#line 290 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
int parts_add_part(parts_t *ps , part_t *p ) 
{ 
  part_t **np ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = realloc((void *)ps->parts, (unsigned long )(ps->len + 1) * sizeof(*(ps->parts)));
#line 293
  np = (part_t **)tmp;
  }
#line 295
  if (! np) {
#line 296
    return (0);
  }
#line 298
  ps->parts = np;
#line 299
  tmp___0 = ps->len;
#line 299
  (ps->len) ++;
#line 299
  *(ps->parts + tmp___0) = p;
#line 301
  return (1);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void parts_set_instruction(parts_t *ps , char const   *iname ) 
{ 
  int i ;

  {
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < ps->len)) {
#line 309
      goto while_break;
    }
    {
#line 310
    (*(ps->parts + i))->active_instruction = part_find_instruction(*(ps->parts + i),
                                                                   iname);
#line 309
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.7/src/part/part.c"
void parts_print(parts_t *ps ) 
{ 
  int i ;
  part_t *p ;
  char *tmp ;

  {
#line 318
  if (! ps) {
#line 319
    return;
  }
#line 321
  i = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i < ps->len)) {
#line 321
      goto while_break;
    }
#line 322
    p = *(ps->parts + i);
#line 324
    if (! p) {
#line 325
      goto __Cont;
    }
    {
#line 327
    tmp = gettext(" %3d ");
#line 327
    printf((char const   */* __restrict  */)tmp, i);
#line 328
    part_print(p);
    }
    __Cont: /* CIL Label */ 
#line 321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return;
}
}
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/part/instruction.c"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) 
{ 
  instruction *i ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((instruction *)((void *)0));
  } else
#line 38
  if (! val) {
#line 39
    return ((instruction *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*i));
#line 41
  i = (instruction *)tmp;
  }
#line 42
  if (! i) {
#line 43
    return ((instruction *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 20UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Instruction name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name,
          (size_t )20);
#line 48
  i->name[20] = (char )'\000';
#line 50
  i->value = register_alloc(len);
  }
#line 51
  if (! i->value) {
    {
#line 52
    free((void *)(i->name));
#line 53
    free((void *)i);
    }
#line 54
    return ((instruction *)((void *)0));
  }
  {
#line 57
  register_init(i->value, val);
#line 58
  i->data_register = (data_register *)((void *)0);
#line 59
  i->next = (instruction *)((void *)0);
  }
#line 61
  return (i);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/src/part/instruction.c"
void instruction_free(instruction *i ) 
{ 


  {
#line 67
  if (! i) {
#line 68
    return;
  }
  {
#line 70
  register_free(i->value);
#line 71
  free((void *)i);
  }
#line 72
  return;
}
}
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/part/data_register.c"
data_register *data_register_alloc(char const   *name , int len ) 
{ 
  data_register *dr___0 ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((data_register *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*dr___0));
#line 41
  dr___0 = (data_register *)tmp;
  }
#line 42
  if (! dr___0) {
#line 43
    return ((data_register *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 10UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Data register name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(dr___0->name), (char const   */* __restrict  */)name,
          (size_t )10);
#line 48
  dr___0->name[10] = (char )'\000';
  }
#line 50
  if (len > 0) {
    {
#line 52
    dr___0->in = register_alloc(len);
#line 53
    dr___0->out = register_alloc(len);
    }
  } else {
    {
#line 57
    dr___0->in = register_alloc(1);
#line 58
    dr___0->out = register_alloc(1);
    }
  }
#line 60
  if (! dr___0->in) {
    {
#line 61
    free((void *)dr___0->in);
#line 62
    free((void *)dr___0->out);
#line 63
    free((void *)(dr___0->name));
#line 64
    free((void *)dr___0);
    }
#line 65
    return ((data_register *)((void *)0));
  } else
#line 60
  if (! dr___0->out) {
    {
#line 61
    free((void *)dr___0->in);
#line 62
    free((void *)dr___0->out);
#line 63
    free((void *)(dr___0->name));
#line 64
    free((void *)dr___0);
    }
#line 65
    return ((data_register *)((void *)0));
  }
#line 68
  dr___0->next = (data_register *)((void *)0);
#line 70
  return (dr___0);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.7/src/part/data_register.c"
void data_register_free(data_register *dr___0 ) 
{ 


  {
#line 76
  if (! dr___0) {
#line 77
    return;
  }
  {
#line 79
  register_free(dr___0->in);
#line 80
  register_free(dr___0->out);
#line 81
  free((void *)dr___0);
  }
#line 82
  return;
}
}
#line 30 "/home/khheo/project/benchmark/urjtag-0.7/src/part/bsbit.c"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) 
{ 
  bsbit_t *b ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*b));
#line 33
  b = (bsbit_t *)tmp;
  }
#line 34
  if (! b) {
#line 35
    return ((bsbit_t *)((void *)0));
  }
  {
#line 37
  b->name = strdup(name);
  }
#line 38
  if (! b->name) {
    {
#line 39
    free((void *)b);
    }
#line 40
    return ((bsbit_t *)((void *)0));
  }
#line 43
  b->bit = bit;
#line 44
  b->type = type;
#line 45
  b->signal = (signal_t *)((void *)0);
#line 46
  b->safe = safe;
#line 47
  b->control = -1;
#line 49
  if ((unsigned long )signal != (unsigned long )((void *)0)) {
#line 50
    b->signal = signal;
    {
#line 52
    if (type == 1) {
#line 52
      goto case_1;
    }
#line 55
    if (type == 2) {
#line 55
      goto case_2;
    }
#line 58
    if (type == 5) {
#line 58
      goto case_5;
    }
#line 51
    goto switch_break;
    case_1: /* CIL Label */ 
#line 53
    signal->input = b;
#line 54
    goto switch_break;
    case_2: /* CIL Label */ 
#line 56
    signal->output = b;
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
#line 59
    signal->input = b;
#line 60
    signal->output = b;
#line 61
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 65
  return (b);
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.7/src/part/bsbit.c"
void bsbit_free(bsbit_t *b ) 
{ 


  {
#line 71
  if (! b) {
#line 72
    return;
  }
  {
#line 74
  free((void *)b->name);
#line 75
  free((void *)b);
  }
#line 76
  return;
}
}
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 332 "/usr/include/usb.h"
extern void usb_init(void) ;
#line 334
extern int usb_find_busses(void) ;
#line 11 "../../include/xpcu.h"
int xpcu_init(void) ;
#line 12
int xpcu_close(struct usb_dev_handle *xpcu ) ;
#line 14
int xpcu_raise_ioa5(struct usb_dev_handle *xpcu ) ;
#line 15
int xpcu_write_gpio(struct usb_dev_handle *xpcu , uint8_t bits ) ;
#line 16
int xpcu_read_gpio(struct usb_dev_handle *xpcu , uint8_t *bits ) ;
#line 18
int xpcu_select_gpio(struct usb_dev_handle *xpcu , int chain___0 ) ;
#line 19
int xpcu_open(struct usb_dev_handle **xpcu ) ;
#line 55 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
parport_driver_t xpcu_pp_driver ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static port_node_t *ports  =    (port_node_t *)((void *)0);
#line 68 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static parport_t *xpcu_pp_alloc(char const   *vidpid ) 
{ 
  xpcu_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;
  char *f ;
  char *tmp___2 ;
  char *l ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 71
  tmp = malloc(sizeof(*params));
#line 71
  params = (xpcu_params_t *)tmp;
#line 72
  tmp___0 = malloc(sizeof(*parport));
#line 72
  parport = (parport_t *)tmp___0;
#line 73
  tmp___1 = malloc(sizeof(*node));
#line 73
  node = (port_node_t *)tmp___1;
  }
#line 75
  if (! node) {
    {
#line 76
    free((void *)node);
#line 77
    free((void *)parport);
#line 78
    free((void *)params);
    }
#line 79
    return ((parport_t *)((void *)0));
  } else
#line 75
  if (! parport) {
    {
#line 76
    free((void *)node);
#line 77
    free((void *)parport);
#line 78
    free((void *)params);
    }
#line 79
    return ((parport_t *)((void *)0));
  } else
#line 75
  if (! params) {
    {
#line 76
    free((void *)node);
#line 77
    free((void *)parport);
#line 78
    free((void *)params);
    }
#line 79
    return ((parport_t *)((void *)0));
  }
  {
#line 82
  params->product_id = 0U;
#line 83
  params->vendor_id = 0U;
#line 84
  params->serial = (char *)((void *)0);
#line 85
  params->dev = (usb_dev_handle *)((void *)0);
#line 88
  tmp___2 = strchr(vidpid, ':');
#line 88
  f = tmp___2;
#line 89
  tmp___3 = strrchr(vidpid, ':');
#line 89
  l = tmp___3;
  }
#line 90
  if (f) {
    {
#line 92
    tmp___4 = strtoul((char const   */* __restrict  */)vidpid, (char **/* __restrict  */)((void *)0),
                      16);
#line 92
    params->vendor_id = (unsigned int )tmp___4;
#line 93
    tmp___5 = strtoul((char const   */* __restrict  */)(f + 1), (char **/* __restrict  */)((void *)0),
                      16);
#line 93
    params->product_id = (unsigned int )tmp___5;
    }
#line 94
    if ((unsigned long )l != (unsigned long )f) {
      {
#line 94
      params->serial = strdup((char const   *)(l + 1));
      }
    }
  }
#line 98
  parport->params = (void *)params;
#line 99
  parport->driver = & xpcu_pp_driver;
#line 100
  parport->cable = (cable_t *)((void *)0);
#line 102
  node->port = parport;
#line 103
  node->next = ports;
#line 105
  ports = node;
#line 107
  return (parport);
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static void xpcu_pp_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 117
  prev = & ports;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! *prev) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 119
      goto while_break;
    }
#line 117
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (*prev) {
    {
#line 122
    pn = *prev;
#line 123
    *prev = pn->next;
#line 124
    free((void *)pn);
    }
  }
  {
#line 127
  free((void *)((xpcu_params_t *)port->params)->serial);
#line 128
  free(port->params);
#line 129
  free((void *)port);
  }
#line 130
  return;
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
parport_t *xpcu_pp_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 141
  if (parnum != 1) {
    {
#line 142
    tmp = gettext("Syntax error!\n");
#line 142
    printf((char const   */* __restrict  */)tmp);
    }
#line 143
    return ((parport_t *)((void *)0));
  }
#line 146
  pn = ports;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! pn) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 147
    if (tmp___2 == 0) {
      {
#line 148
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 148
      tmp___1 = gettext("Disconnecting %s, device %s\n");
#line 148
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 149
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 150
      goto while_break;
    }
#line 146
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  tmp___3 = gettext("Initializing device %s\n");
#line 156
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 159
  parport = xpcu_pp_alloc(*(par + 0));
  }
#line 160
  if (! parport) {
    {
#line 161
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 161
    printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c",
           161);
    }
#line 162
    return ((parport_t *)((void *)0));
  }
#line 165
  return (parport);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_open(parport_t *parport ) 
{ 
  xpcu_params_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 173
  p = (xpcu_params_t *)parport->params;
#line 175
  usb_init();
#line 177
  tmp = usb_find_busses();
  }
#line 177
  if (tmp < 0) {
    {
#line 179
    perror("usb_find_busses failed");
    }
#line 180
    return (-1);
  }
  {
#line 183
  tmp___0 = xpcu_init();
  }
#line 183
  if (tmp___0 < 0) {
    {
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t initialize XPCU\n");
    }
#line 186
    return (-1);
  }
  {
#line 189
  tmp___1 = xpcu_open(& p->dev);
  }
#line 189
  if (tmp___1 < 0) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open XPCU\n");
    }
#line 192
    return (-1);
  }
  {
#line 195
  tmp___2 = xpcu_raise_ioa5(p->dev);
  }
#line 195
  if (tmp___2 < 0) {
#line 195
    return (-1);
  }
  {
#line 198
  tmp___3 = xpcu_select_gpio(p->dev, 0);
  }
#line 198
  if (tmp___3 < 0) {
#line 198
    return (-1);
  }
#line 200
  return (0);
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_close(parport_t *parport ) 
{ 
  xpcu_params_t *p ;

  {
  {
#line 208
  p = (xpcu_params_t *)parport->params;
#line 209
  xpcu_close(p->dev);
  }
#line 210
  return (0);
}
}
#line 215 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_set_data(parport_t *parport , uint8_t data ) 
{ 
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 218
  p = (xpcu_params_t *)parport->params;
#line 220
  tmp = xpcu_write_gpio(p->dev, data);
  }
#line 220
  if (tmp < 0) {
#line 220
    return (-1);
  }
#line 221
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 230
  p = (xpcu_params_t *)parport->params;
#line 232
  tmp = xpcu_read_gpio(p->dev, & d);
  }
#line 232
  if (tmp < 0) {
#line 232
    return (0);
  }
#line 233
  return ((int )d);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_get_status(parport_t *parport ) 
{ 


  {
#line 241
  return (0);
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
static int xpcu_pp_set_control(parport_t *parport , uint8_t data ) 
{ 
  xpcu_params_t *p ;
  int tmp ;

  {
  {
#line 249
  p = (xpcu_params_t *)parport->params;
#line 251
  tmp = xpcu_select_gpio(p->dev, (int )data);
  }
#line 251
  if (tmp < 0) {
#line 251
    return (-1);
  }
#line 252
  return (0);
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_pp.c"
parport_driver_t xpcu_pp_driver  = 
#line 257
     {"xpcu", & xpcu_pp_connect, & xpcu_pp_free, & xpcu_pp_open, & xpcu_pp_close, & xpcu_pp_set_data,
    & xpcu_pp_get_data, & xpcu_pp_get_status, & xpcu_pp_set_control};
#line 281 "/usr/include/usb.h"
extern struct usb_bus *usb_busses ;
#line 290
extern usb_dev_handle *usb_open(struct usb_device *dev ) ;
#line 291
extern int usb_close(usb_dev_handle *dev ) ;
#line 312
extern int usb_control_msg(usb_dev_handle *dev , int requesttype , int request , int value ,
                           int index , char *bytes , int size , int timeout ) ;
#line 315
extern int usb_claim_interface(usb_dev_handle *dev , int interface ) ;
#line 316
extern int usb_release_interface(usb_dev_handle *dev , int interface ) ;
#line 320
extern int usb_reset(usb_dev_handle *dev ) ;
#line 335
extern int usb_find_devices(void) ;
#line 45 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
struct usb_device *find_xpcu(void) 
{ 
  struct usb_device *xpcu_dev ;
  struct usb_bus *bus___0 ;
  struct usb_device *dev ;
  int tmp ;

  {
  {
#line 47
  xpcu_dev = (struct usb_device *)((void *)0);
#line 49
  tmp = usb_find_devices();
  }
#line 49
  if (tmp < 0) {
    {
#line 51
    perror("find_xpcu: usb_find_devices failed");
    }
  } else {
#line 57
    bus___0 = usb_busses;
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
#line 57
      if (bus___0) {
#line 57
        if (! (! xpcu_dev)) {
#line 57
          goto while_break;
        }
      } else {
#line 57
        goto while_break;
      }
#line 61
      dev = bus___0->devices;
      {
#line 61
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 61
        if (dev) {
#line 61
          if (! (! xpcu_dev)) {
#line 61
            goto while_break___0;
          }
        } else {
#line 61
          goto while_break___0;
        }
#line 63
        if ((int )dev->descriptor.idVendor == 1021) {
#line 65
          if ((int )dev->descriptor.idProduct == 8) {
#line 67
            xpcu_dev = dev;
          } else {
            {
#line 71
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found Xilinx device with unknown PID %04X. No firmware loaded?\n",
                    (int )dev->descriptor.idProduct);
            }
          }
        }
#line 61
        dev = dev->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 57
      bus___0 = bus___0->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 80
  return (xpcu_dev);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_init(void) 
{ 
  struct usb_device *xpcu_dev ;
  struct usb_device *tmp ;
  struct usb_dev_handle *xpcu ;
  int tmp___0 ;

  {
  {
#line 87
  tmp = find_xpcu();
#line 87
  xpcu_dev = tmp;
  }
#line 90
  if ((unsigned long )xpcu_dev == (unsigned long )((void *)0)) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xpcu_reset: no device found\n");
    }
#line 93
    return (-1);
  }
  {
#line 96
  xpcu = usb_open(xpcu_dev);
  }
#line 97
  if ((unsigned long )xpcu == (unsigned long )((void *)0)) {
    {
#line 99
    perror("xpcu_reset: usb_open() failed");
    }
#line 100
    return (-1);
  }
  {
#line 103
  tmp___0 = usb_reset(xpcu);
  }
#line 103
  if (tmp___0 < 0) {
    {
#line 105
    perror("xpcu_reset: usb_reset() failed");
    }
#line 106
    return (-1);
  }
#line 109
  return (0);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_close(struct usb_dev_handle *xpcu ) 
{ 


  {
  {
#line 116
  usb_release_interface(xpcu, 0);
#line 117
  usb_close(xpcu);
  }
#line 119
  return (0);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_request_28(struct usb_dev_handle *xpcu , int value ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = usb_control_msg(xpcu, 64, 176, 40, value, (char *)((void *)0), 0, 1000);
  }
#line 128
  if (tmp < 0) {
    {
#line 130
    perror("usb_control_msg(0x28.x)");
    }
#line 131
    return (-1);
  }
#line 134
  return (0);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_write_gpio(struct usb_dev_handle *xpcu , uint8_t bits ) 
{ 
  int tmp ;

  {
  {
#line 141
  tmp = usb_control_msg(xpcu, 64, 176, 48, (int )bits, (char *)((void *)0), 0, 1000);
  }
#line 141
  if (tmp < 0) {
    {
#line 143
    perror("usb_control_msg(0x30.0x00) (write port E)");
    }
#line 144
    return (-1);
  }
#line 147
  return (0);
}
}
#line 152 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_read_gpio(struct usb_dev_handle *xpcu , uint8_t *bits ) 
{ 
  int tmp ;

  {
  {
#line 154
  tmp = usb_control_msg(xpcu, 192, 176, 56, 0, (char *)bits, 1, 1000);
  }
#line 154
  if (tmp < 0) {
    {
#line 156
    perror("usb_control_msg(0x38.0x00) (read port E)");
    }
#line 157
    return (-1);
  }
#line 160
  return (0);
}
}
#line 166 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_read_firmware_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 168
  tmp = usb_control_msg(xpcu, 192, 176, 80, 0, (char *)buf, 2, 1000);
  }
#line 168
  if (tmp < 0) {
    {
#line 170
    perror("usb_control_msg(0x50.0) (read_firmware_version)");
    }
#line 171
    return (-1);
  }
#line 173
  return (0);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_read_cpld_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = usb_control_msg(xpcu, 192, 176, 80, 1, (char *)buf, 2, 1000);
  }
#line 181
  if (tmp < 0) {
    {
#line 183
    perror("usb_control_msg(0x50.1) (read_cpld_version)");
    }
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 192 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_raise_ioa5(struct usb_dev_handle *xpcu ) 
{ 
  int tmp ;

  {
  {
#line 194
  tmp = usb_control_msg(xpcu, 64, 176, 24, 0, (char *)((void *)0), 0, 1000);
  }
#line 194
  if (tmp < 0) {
    {
#line 196
    perror("usb_control_msg(0x18.0x00) (raise IOA.5");
    }
#line 197
    return (-1);
  }
#line 200
  return (0);
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_select_gpio(struct usb_dev_handle *xpcu , int chain___0 ) 
{ 
  int tmp ;

  {
  {
#line 208
  tmp = usb_control_msg(xpcu, 64, 176, 82, chain___0, (char *)((void *)0), 0, 1000);
  }
#line 208
  if (tmp < 0) {
    {
#line 210
    perror("usb_control_msg(0x52.x) (select gpio)");
    }
#line 211
    return (-1);
  }
#line 214
  return (0);
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/xpcu_common.c"
int xpcu_open(struct usb_dev_handle **xpcu ) 
{ 
  uint16_t buf ;
  struct usb_device *xpcu_dev ;
  struct usb_device *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 222
  tmp = find_xpcu();
#line 222
  xpcu_dev = tmp;
  }
#line 224
  if ((unsigned long )xpcu_dev == (unsigned long )((void *)0)) {
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xpcu_open: no device found\n");
    }
#line 227
    return (-1);
  }
  {
#line 230
  *xpcu = usb_open(xpcu_dev);
  }
#line 231
  if ((unsigned long )*xpcu == (unsigned long )((void *)0)) {
    {
#line 233
    perror("xpcu_open: usb_open() failed");
    }
#line 234
    return (-1);
  }
  {
#line 237
  tmp___0 = usb_claim_interface(*xpcu, 0);
  }
#line 237
  if (tmp___0 != 0) {
    {
#line 239
    perror("xpcu_open: usb_claim_interface failed");
#line 240
    usb_close(*xpcu);
    }
#line 241
    return (-1);
  }
  {
#line 245
  tmp___1 = xpcu_request_28(*xpcu, 17);
  }
#line 245
  if (tmp___1 < 0) {
    {
#line 247
    usb_close(*xpcu);
    }
#line 248
    return (-1);
  }
  {
#line 251
  tmp___2 = xpcu_write_gpio(*xpcu, (uint8_t )8);
  }
#line 251
  if (tmp___2 < 0) {
    {
#line 253
    usb_close(*xpcu);
    }
#line 254
    return (-1);
  }
  {
#line 259
  tmp___3 = xpcu_read_firmware_version(*xpcu, & buf);
  }
#line 259
  if (tmp___3 < 0) {
    {
#line 261
    usb_close(*xpcu);
    }
#line 262
    return (-1);
  } else {
    {
#line 266
    printf((char const   */* __restrict  */)"firmware version = 0x%04X (%u)\n", (int )buf,
           (int )buf);
    }
  }
  {
#line 271
  tmp___4 = xpcu_read_cpld_version(*xpcu, & buf);
  }
#line 271
  if (tmp___4 < 0) {
    {
#line 273
    usb_close(*xpcu);
    }
#line 274
    return (-1);
  } else {
    {
#line 278
    printf((char const   */* __restrict  */)"cable CPLD version = 0x%04X (%u)\n",
           (int )buf, (int )buf);
    }
#line 279
    if ((int )buf == 0) {
      {
#line 281
      printf((char const   */* __restrict  */)"Warning: version \'0\' can\'t be correct. Please try resetting the cable\n");
      }
    }
  }
#line 285
  return (0);
}
}
#line 53 "../../include/parport.h"
int parport_open(parport_t *port ) ;
#line 55
int parport_set_data(parport_t *port , uint8_t data ) ;
#line 56
int parport_get_data(parport_t *port ) ;
#line 58
int parport_set_control(parport_t *port , uint8_t data ) ;
#line 72 "../../include/cable.h"
void cable_wait(void) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.h"
int generic_connect(char **params , cable_t *cable ) ;
#line 40
void generic_disconnect(cable_t *cable ) ;
#line 41
void generic_cable_free(cable_t *cable ) ;
#line 42
void generic_done(cable_t *cable ) ;
#line 43
int generic_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 44
int generic_get_trst(cable_t *cable ) ;
#line 38 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
static int xpc_int_init(cable_t *cable ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 41
  tmp = parport_open(cable->port);
  }
#line 41
  if (tmp) {
#line 41
    return (-1);
  }
  {
#line 42
  tmp___0 = parport_set_control(cable->port, (uint8_t )1);
  }
#line 42
  if (tmp___0 < 0) {
#line 42
    return (-1);
  }
#line 44
  ((generic_params_t *)cable->params)->trst = 1;
#line 46
  return (0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
static int xpc_ext_init(cable_t *cable ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 52
  tmp = parport_open(cable->port);
  }
#line 52
  if (tmp) {
#line 52
    return (-1);
  }
  {
#line 53
  tmp___0 = parport_set_control(cable->port, (uint8_t )0);
  }
#line 53
  if (tmp___0 < 0) {
#line 53
    return (-1);
  }
#line 55
  ((generic_params_t *)cable->params)->trst = 1;
#line 57
  return (0);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
static void xpc_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 72
  if (tms) {
#line 72
    tms = 1;
  } else {
#line 72
    tms = 0;
  }
#line 73
  if (tdi) {
#line 73
    tdi = 1;
  } else {
#line 73
    tdi = 0;
  }
  {
#line 75
  parport_set_data(cable->port, (uint8_t )(((1 << 3) | (tms << 1)) | tdi));
#line 76
  cable_wait();
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )((((1 << 3) | (1 << 2)) | (tms << 1)) | tdi));
#line 79
    cable_wait();
#line 80
    parport_set_data(cable->port, (uint8_t )(((1 << 3) | (tms << 1)) | tdi));
#line 81
    cable_wait();
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
static int xpc_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  tmp = parport_get_data(cable->port);
  }
#line 88
  return (tmp & 1);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
static int xpc_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 94
  return (1);
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
void xpcu_usbcable_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 100
  tmp = gettext("Usage: cable %s xpcu VID:PID\n\nVID        vendor ID (hex, e.g. 9FB, or empty)\nPID        product ID (hex, e.g. 6001, or empty)\n\n");
#line 100
  printf((char const   */* __restrict  */)tmp, cablename);
  }
#line 107
  return;
}
}
#line 109 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
cable_driver_t xpc_int_cable_driver  = 
#line 109
     {"xpc_int", "Xilinx Platform Cable USB internal chain", & generic_connect, & generic_disconnect,
    & generic_cable_free, & xpc_int_init, & generic_done, & xpc_clock, & xpc_get_tdo,
    & generic_transfer, & xpc_set_trst, & generic_get_trst, & xpcu_usbcable_help};
#line 125 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/xpc.c"
cable_driver_t xpc_ext_cable_driver  = 
#line 125
     {"xpc_ext", "Xilinx Platform Cable USB external chain", & generic_connect, & generic_disconnect,
    & generic_cable_free, & xpc_ext_init, & generic_done, & xpc_clock, & xpc_get_tdo,
    & generic_transfer, & xpc_set_trst, & generic_get_trst, & xpcu_usbcable_help};
#line 57 "../../include/parport.h"
int parport_get_status(parport_t *port ) ;
#line 45 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.h"
void generic_lptcable_help(char const   *cablename ) ;
#line 60 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
static int wiggler_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 65
  tmp = parport_open(cable->port);
  }
#line 65
  if (tmp) {
#line 66
    return (-1);
  }
  {
#line 68
  data = parport_get_data(cable->port);
  }
#line 68
  if (data < 0) {
    {
#line 69
    tmp___0 = parport_set_data(cable->port, (uint8_t )((1 << 4) | (~ (((((1 << 4) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1) & 255)));
    }
#line 69
    if (tmp___0) {
#line 70
      return (-1);
    }
#line 71
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 73
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 75
  return (0);
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
static void wiggler_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 4) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1) & 255)));
#line 88
    cable_wait();
#line 89
    parport_set_data(cable->port, (uint8_t )(((((224 | (((generic_params_t *)cable->params)->trst << 4)) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 4) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1) & 255)));
#line 90
    cable_wait();
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
static int wiggler_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 97
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 4) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1) & 255)));
#line 98
  cable_wait();
#line 99
  tmp = parport_get_status(cable->port);
  }
#line 99
  return ((tmp >> 7) & 1);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
static int wiggler_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 105
  if (trst) {
#line 105
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 105
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 107
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 4) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1) & 255)));
  }
#line 108
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
cable_driver_t wiggler_cable_driver  = 
#line 111
     {"WIGGLER", "Macraigor Wiggler JTAG Cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & wiggler_init, & generic_done, & wiggler_clock, & wiggler_get_tdo,
    & generic_transfer, & wiggler_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 127 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler.c"
cable_driver_t igloo_cable_driver  = 
#line 127
     {"IGLOO", "Excelpoint IGLOO JTAG Cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & wiggler_init, & generic_done, & wiggler_clock, & wiggler_get_tdo,
    & generic_transfer, & wiggler_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 67 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler2.c"
static int wiggler2_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 72
  tmp = parport_open(cable->port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
  {
#line 75
  data = parport_get_data(cable->port);
  }
#line 75
  if (data < 0) {
    {
#line 76
    tmp___0 = parport_set_data(cable->port, (uint8_t )(~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255));
    }
#line 76
    if (tmp___0) {
#line 77
      return (-1);
    }
#line 78
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 80
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 82
  return (0);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler2.c"
static void wiggler2_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 90
  if (tms) {
#line 90
    tms = 1;
  } else {
#line 90
    tms = 0;
  }
#line 91
  if (tdi) {
#line 91
    tdi = 1;
  } else {
#line 91
    tdi = 0;
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < n)) {
#line 93
      goto while_break;
    }
    {
#line 94
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 95
    cable_wait();
#line 96
    parport_set_data(cable->port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 97
    cable_wait();
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 104
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 105
  cable_wait();
#line 106
  tmp = parport_get_status(cable->port);
  }
#line 106
  return ((tmp >> 7) & 1);
}
}
#line 109 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler2.c"
static int wiggler2_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 112
  if (trst) {
#line 112
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 112
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 114
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
  }
#line 115
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/wiggler2.c"
cable_driver_t wiggler2_cable_driver  = 
#line 118
     {"WIGGLER2", "Modified (with CPU Reset) WIGGLER JTAG Cable", & generic_connect,
    & generic_disconnect, & generic_cable_free, & wiggler2_init, & generic_done, & wiggler2_clock,
    & wiggler2_get_tdo, & generic_transfer, & wiggler2_set_trst, & generic_get_trst,
    & generic_lptcable_help};
#line 68 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/triton.c"
static int triton_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 71
  tmp = parport_open(cable->port);
  }
#line 71
  if (tmp) {
#line 72
    return (-1);
  }
#line 74
  ((generic_params_t *)cable->params)->trst = 1;
#line 75
  ((generic_params_t *)cable->params)->sreset = 1;
#line 77
  return (0);
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/triton.c"
static void triton_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 85
  if (tms) {
#line 85
    tms = 1;
  } else {
#line 85
    tms = 0;
  }
#line 86
  if (tdi) {
#line 86
    tdi = 1;
  } else {
#line 86
    tdi = 0;
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < n)) {
#line 88
      goto while_break;
    }
    {
#line 89
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 90
    cable_wait();
#line 91
    parport_set_data(cable->port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 92
    cable_wait();
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/triton.c"
static int triton_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 99
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
#line 100
  cable_wait();
#line 101
  tmp = parport_get_status(cable->port);
  }
#line 101
  return ((tmp >> 7) & 1);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/triton.c"
static int triton_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 107
  if (trst) {
#line 107
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 107
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 109
  parport_set_data(cable->port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
  }
#line 110
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/triton.c"
cable_driver_t triton_cable_driver  = 
#line 113
     {"TRITON", "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable", & generic_connect,
    & generic_disconnect, & generic_cable_free, & triton_init, & generic_done, & triton_clock,
    & triton_get_tdo, & generic_transfer, & triton_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 65 "../../include/cable.h"
int cable_get_tdo(cable_t *cable ) ;
#line 68
int cable_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 32 "../../include/tap.h"
void tap_capture_dr(chain_t *chain___0 ) ;
#line 33
void tap_capture_ir(chain_t *chain___0 ) ;
#line 34
void tap_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                        int exit___0 ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/tap.c"
void tap_reset(chain_t *chain___0 ) 
{ 


  {
  {
#line 37
  tap_state_reset(chain___0);
#line 39
  chain_clock(chain___0, 1, 0, 5);
#line 41
  chain_clock(chain___0, 0, 0, 1);
  }
#line 42
  return;
}
}
#line 44 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/tap.c"
void tap_shift_register(chain_t *chain___0 , tap_register const   *in , tap_register *out ,
                        int exit___0 ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 49
  tmp___1 = tap_state(chain___0);
  }
#line 49
  if (! (tmp___1 & (1 << 2))) {
    {
#line 50
    tmp = tap_state(chain___0);
#line 50
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0, "tap_shift_register", tmp);
    }
  }
  {
#line 53
  tmp___2 = tap_state(chain___0);
  }
#line 53
  if (tmp___2 & (1 << 4)) {
    {
#line 54
    chain_clock(chain___0, 0, 0, 1);
    }
  }
#line 56
  i = (int )in->len;
#line 57
  if (exit___0) {
#line 57
    i --;
  }
#line 58
  if (out) {
#line 58
    if (out->len < i) {
#line 58
      i = out->len;
    }
  }
#line 60
  if (out) {
    {
#line 61
    cable_transfer(chain___0->cable, i, (char *)in->data, out->data);
    }
  } else {
    {
#line 63
    cable_transfer(chain___0->cable, i, (char *)in->data, (char *)((void *)0));
    }
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < (int )in->len)) {
#line 65
      goto while_break;
    }
#line 66
    if (out) {
#line 66
      if (i < out->len) {
        {
#line 67
        tmp___3 = cable_get_tdo(chain___0->cable);
#line 67
        *(out->data + i) = (char )tmp___3;
        }
      }
    }
#line 68
    if (exit___0 != 0) {
#line 68
      if (i + 1 == (int )in->len) {
#line 68
        tmp___4 = 1;
      } else {
#line 68
        tmp___4 = 0;
      }
    } else {
#line 68
      tmp___4 = 0;
    }
    {
#line 68
    chain_clock(chain___0, tmp___4, (int )*(in->data + i), 1);
#line 65
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (exit___0 == 1) {
    {
#line 72
    chain_clock(chain___0, 1, 0, 1);
#line 73
    chain_clock(chain___0, 0, 0, 1);
    }
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/tap.c"
void tap_capture_dr(chain_t *chain___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 80
  tmp___1 = tap_state(chain___0);
  }
#line 80
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 81
    tmp = tap_state(chain___0);
#line 81
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 81
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_dr", tmp);
    }
  }
  {
#line 84
  chain_clock(chain___0, 1, 0, 1);
#line 85
  chain_clock(chain___0, 0, 0, 1);
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/tap.c"
void tap_capture_ir(chain_t *chain___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 91
  tmp___1 = tap_state(chain___0);
  }
#line 91
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 92
    tmp = tap_state(chain___0);
#line 92
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 92
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_ir", tmp);
    }
  }
  {
#line 95
  chain_clock(chain___0, 1, 0, 2);
#line 96
  chain_clock(chain___0, 0, 0, 1);
  }
#line 97
  return;
}
}
#line 60 "../../include/state.h"
int tap_state_init(chain_t *chain___0 ) ;
#line 61
int tap_state_done(chain_t *chain___0 ) ;
#line 63
int tap_state_set_trst(chain_t *chain___0 , int old_trst , int new_trst ) ;
#line 64
int tap_state_clock(chain_t *chain___0 , int tms ) ;
#line 29 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state(chain_t *chain___0 ) 
{ 


  {
#line 32
  return (chain___0->state);
}
}
#line 35 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state_init(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 38
  tmp = 1 << 7;
#line 38
  chain___0->state = tmp;
#line 38
  return (tmp);
}
}
#line 41 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state_done(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 44
  tmp = 1 << 7;
#line 44
  chain___0->state = tmp;
#line 44
  return (tmp);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state_reset(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
#line 50
  tmp = (1 << 7) | (1 << 3);
#line 50
  chain___0->state = tmp;
#line 50
  return (tmp);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state_set_trst(chain_t *chain___0 , int old_trst , int new_trst ) 
{ 


  {
#line 56
  if (old_trst) {
#line 56
    old_trst = 1;
  } else {
#line 56
    old_trst = 0;
  }
#line 57
  if (new_trst) {
#line 57
    new_trst = 1;
  } else {
#line 57
    new_trst = 0;
  }
#line 59
  if (old_trst != new_trst) {
#line 60
    if (new_trst) {
#line 61
      chain___0->state = (1 << 7) | (1 << 3);
    } else {
#line 63
      chain___0->state = 1 << 7;
    }
  }
#line 66
  return (chain___0->state);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/state.c"
int tap_state_clock(chain_t *chain___0 , int tms ) 
{ 


  {
#line 72
  if (tms) {
    {
#line 74
    if (chain___0->state == ((1 << 7) | (1 << 3))) {
#line 74
      goto case_exp;
    }
#line 78
    if (chain___0->state == ((1 << 1) | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain___0->state == (1 | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain___0->state == 1 << 3) {
#line 78
      goto case_exp___0;
    }
#line 81
    if (chain___0->state == 1) {
#line 81
      goto case_1;
    }
#line 85
    if (chain___0->state == (1 | (1 << 2))) {
#line 85
      goto case_exp___3;
    }
#line 85
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 85
      goto case_exp___3;
    }
#line 89
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 89
      goto case_exp___5;
    }
#line 89
    if (chain___0->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 89
      goto case_exp___5;
    }
#line 92
    if (chain___0->state == (1 | (1 << 6))) {
#line 92
      goto case_exp___7;
    }
#line 95
    if (chain___0->state == 1 << 1) {
#line 95
      goto case_exp___8;
    }
#line 99
    if (chain___0->state == ((1 << 1) | (1 << 2))) {
#line 99
      goto case_exp___9;
    }
#line 99
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 99
      goto case_exp___9;
    }
#line 103
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 103
      goto case_exp___11;
    }
#line 103
    if (chain___0->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 103
      goto case_exp___11;
    }
#line 106
    if (chain___0->state == ((1 << 1) | (1 << 6))) {
#line 106
      goto case_exp___13;
    }
#line 109
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 75
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
#line 79
    chain___0->state = 1;
#line 80
    goto switch_break;
    case_1: /* CIL Label */ 
#line 82
    chain___0->state = 1 << 1;
#line 83
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
#line 86
    chain___0->state = (1 | (1 << 5)) | (1 << 6);
#line 87
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
#line 90
    chain___0->state = 1 | (1 << 3);
#line 91
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 93
    chain___0->state = (1 | (1 << 2)) | (1 << 5);
#line 94
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 96
    chain___0->state = (1 << 7) | (1 << 3);
#line 97
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
#line 100
    chain___0->state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 101
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    case_exp___12: /* CIL Label */ 
#line 104
    chain___0->state = (1 << 1) | (1 << 3);
#line 105
    goto switch_break;
    case_exp___13: /* CIL Label */ 
#line 107
    chain___0->state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 110
    chain___0->state = 1 << 7;
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 118
    if (chain___0->state == ((1 << 1) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == (1 | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == 1 << 3) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain___0->state == ((1 << 7) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 121
    if (chain___0->state == 1) {
#line 121
      goto case_1___0;
    }
#line 126
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain___0->state == (1 | (1 << 2))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain___0->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 126
      goto case_exp___18;
    }
#line 130
    if (chain___0->state == (1 | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 130
    if (chain___0->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 133
    if (chain___0->state == 1 << 1) {
#line 133
      goto case_exp___23;
    }
#line 138
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain___0->state == ((1 << 1) | (1 << 2))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain___0->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 138
      goto case_exp___24;
    }
#line 142
    if (chain___0->state == ((1 << 1) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 142
    if (chain___0->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 145
    goto switch_default___0;
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
#line 119
    chain___0->state = 1 << 3;
#line 120
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 122
    chain___0->state = (1 | (1 << 2)) | (1 << 4);
#line 123
    goto switch_break___0;
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    case_exp___20: /* CIL Label */ 
#line 127
    chain___0->state = 1 | (1 << 2);
#line 128
    goto switch_break___0;
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
#line 131
    chain___0->state = 1 | (1 << 6);
#line 132
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
#line 134
    chain___0->state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 135
    goto switch_break___0;
    case_exp___24: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
#line 139
    chain___0->state = (1 << 1) | (1 << 2);
#line 140
    goto switch_break___0;
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
#line 143
    chain___0->state = (1 << 1) | (1 << 6);
#line 144
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 146
    chain___0->state = 1 << 7;
#line 147
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 151
  return (chain___0->state);
}
}
#line 41 "../../include/register.h"
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) ;
#line 42
int register_match(tap_register const   *tr , char const   *expr ) ;
#line 43
tap_register *register_inc(tap_register *tr ) ;
#line 44
tap_register *register_dec(tap_register *tr ) ;
#line 45
tap_register *register_shift_right(tap_register *tr , int shift ) ;
#line 46
tap_register *register_shift_left(tap_register *tr , int shift ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_alloc(int len ) 
{ 
  tap_register *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 35
  if (len < 1) {
#line 36
    return ((tap_register *)((void *)0));
  }
  {
#line 38
  tmp = malloc(sizeof(tap_register ));
#line 38
  tr = (tap_register *)tmp;
  }
#line 39
  if (! tr) {
#line 40
    return ((tap_register *)((void *)0));
  }
  {
#line 42
  tmp___0 = malloc((size_t )len);
#line 42
  tr->data = (char *)tmp___0;
  }
#line 43
  if (! tr->data) {
    {
#line 44
    free((void *)tr);
    }
#line 45
    return ((tap_register *)((void *)0));
  }
  {
#line 48
  memset((void *)tr->data, 0, (size_t )len);
#line 50
  tmp___1 = malloc((size_t )(len + 1));
#line 50
  tr->string = (char *)tmp___1;
  }
#line 51
  if (! tr->string) {
    {
#line 52
    free((void *)tr->data);
#line 53
    free((void *)tr);
    }
#line 54
    return ((tap_register *)((void *)0));
  }
#line 57
  tr->len = len;
#line 58
  *(tr->string + len) = (char )'\000';
#line 60
  return (tr);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_duplicate(tap_register const   *tr ) 
{ 
  char const   *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;

  {
#line 66
  if (! tr) {
#line 67
    return ((tap_register *)((void *)0));
  }
  {
#line 69
  tmp = register_get_string(tr);
#line 69
  tmp___0 = register_alloc((int )tr->len);
#line 69
  tmp___1 = register_init(tmp___0, tmp);
  }
#line 69
  return (tmp___1);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
void register_free(tap_register *tr ) 
{ 


  {
#line 75
  if (tr) {
    {
#line 76
    free((void *)tr->data);
#line 77
    free((void *)tr->string);
    }
  }
  {
#line 79
  free((void *)tr);
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_fill(tap_register *tr , int val ) 
{ 


  {
#line 85
  if (tr) {
    {
#line 86
    memset((void *)tr->data, val & 1, (size_t )tr->len);
    }
  }
#line 88
  return (tr);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
char const   *register_get_string(tap_register const   *tr ) 
{ 
  int i ;

  {
#line 96
  if (! tr) {
#line 97
    return ((char const   *)((void *)0));
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < (int )tr->len)) {
#line 99
      goto while_break;
    }
#line 100
    if ((int )*(tr->data + i) & 1) {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'1';
    } else {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'0';
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((char const   *)tr->string);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_init(tap_register *tr , char const   *value ) 
{ 
  int i ;
  char const   *p ;
  char *tmp ;

  {
#line 112
  if (! value) {
#line 113
    return (tr);
  } else
#line 112
  if (! tr) {
#line 113
    return (tr);
  }
  {
#line 115
  tmp = strchr(value, '\000');
#line 115
  p = (char const   *)tmp;
#line 117
  i = 0;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < tr->len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )p == (unsigned long )value) {
#line 119
      *(tr->data + i) = (char)0;
    } else {
#line 121
      p --;
#line 122
      if ((int const   )*p == 48) {
#line 122
        *(tr->data + i) = (char)0;
      } else {
#line 122
        *(tr->data + i) = (char)1;
      }
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (tr);
}
}
#line 129 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) 
{ 
  int i ;

  {
#line 134
  if (! tr) {
#line 134
    if (! tr2) {
#line 135
      return (0);
    }
  }
#line 137
  if (! tr) {
#line 138
    return (1);
  } else
#line 137
  if (! tr2) {
#line 138
    return (1);
  }
#line 140
  if (tr->len != tr2->len) {
#line 141
    return (1);
  }
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < (int )tr->len)) {
#line 143
      goto while_break;
    }
#line 144
    if ((int )*(tr->data + i) != (int )*(tr2->data + i)) {
#line 145
      return (1);
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
int register_match(tap_register const   *tr , char const   *expr ) 
{ 
  int i ;
  char const   *s ;
  size_t tmp ;

  {
#line 156
  if (! tr) {
#line 157
    return (0);
  } else
#line 156
  if (! expr) {
#line 157
    return (0);
  } else {
    {
#line 156
    tmp = strlen(expr);
    }
#line 156
    if ((size_t )tr->len != tmp) {
#line 157
      return (0);
    }
  }
  {
#line 159
  s = register_get_string(tr);
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < (int )tr->len)) {
#line 161
      goto while_break;
    }
#line 162
    if ((int const   )*(expr + i) != 63) {
#line 162
      if ((int const   )*(expr + i) != (int const   )*(s + i)) {
#line 163
        return (0);
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (1);
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_inc(tap_register *tr ) 
{ 
  int i ;

  {
#line 173
  if (! tr) {
#line 174
    return ((tap_register *)((void *)0));
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < tr->len)) {
#line 176
      goto while_break;
    }
#line 177
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 179
    if ((int )*(tr->data + i) == 1) {
#line 180
      goto while_break;
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return (tr);
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_dec(tap_register *tr ) 
{ 
  int i ;

  {
#line 191
  if (! tr) {
#line 192
    return ((tap_register *)((void *)0));
  }
#line 194
  i = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < tr->len)) {
#line 194
      goto while_break;
    }
#line 195
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 197
    if ((int )*(tr->data + i) == 0) {
#line 198
      goto while_break;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return (tr);
}
}
#line 204 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_shift_right(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 209
  if (! tr) {
#line 210
    return ((tap_register *)((void *)0));
  }
#line 212
  if (shift < 1) {
#line 213
    return (tr);
  }
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < tr->len)) {
#line 215
      goto while_break;
    }
#line 216
    if (i + shift < tr->len) {
#line 217
      *(tr->data + i) = *(tr->data + (i + shift));
    } else {
#line 219
      *(tr->data + i) = (char)0;
    }
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (tr);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/register.c"
tap_register *register_shift_left(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 230
  if (! tr) {
#line 231
    return ((tap_register *)((void *)0));
  }
#line 233
  if (shift < 1) {
#line 234
    return (tr);
  }
#line 236
  i = tr->len - 1;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i >= 0)) {
#line 236
      goto while_break;
    }
#line 237
    if (i - shift >= 0) {
#line 238
      *(tr->data + i) = *(tr->data + (i - shift));
    } else {
#line 240
      *(tr->data + i) = (char)0;
    }
#line 236
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return (tr);
}
}
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 67 "/usr/include/stropts.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 45 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static port_node_t *ports___0  =    (port_node_t *)((void *)0);
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc(sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc(sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc(sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports___0;
#line 87
  ports___0 = node;
#line 89
  return (parport);
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static void ppdev_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports___0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
parport_t *ppdev_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 118
  if (parnum != 1) {
    {
#line 119
    tmp = gettext("Syntax error!\n");
#line 119
    printf((char const   */* __restrict  */)tmp);
    }
#line 120
    return ((parport_t *)((void *)0));
  }
#line 123
  pn = ports___0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! pn) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 124
    if (tmp___2 == 0) {
      {
#line 125
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 125
      tmp___1 = gettext("Disconnecting %s from ppdev port %s\n");
#line 125
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 126
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 127
      goto while_break;
    }
#line 123
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp___3 = gettext("Initializing ppdev port %s\n");
#line 130
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 132
  parport = ppdev_parport_alloc(*(par + 0));
  }
#line 133
  if (! parport) {
    {
#line 134
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c",
           134);
    }
#line 135
    return ((parport_t *)((void *)0));
  }
#line 138
  return (parport);
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_open(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_close(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_set_data(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_get_status(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
static int ppdev_set_control(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver  = 
#line 226
     {"ppdev", & ppdev_connect, & ppdev_parport_free, & ppdev_open, & ppdev_close, & ppdev_set_data,
    & ppdev_get_data, & ppdev_get_status, & ppdev_set_control};
#line 54 "../../include/parport.h"
int parport_close(parport_t *port ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
parport_driver_t direct_parport_driver ;
#line 50 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
parport_driver_t *parport_drivers[4]  = {      & direct_parport_driver,      & ppdev_parport_driver,      & xpcu_pp_driver,      (parport_driver_t *)((void *)0)};
#line 75 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_open(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 78
  tmp = (*((port->driver)->open))(port);
  }
#line 78
  return (tmp);
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_close(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = (*((port->driver)->close))(port);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_set_data(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = (*((port->driver)->set_data))(port, data);
  }
#line 90
  return (tmp);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_get_data(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 96
  tmp = (*((port->driver)->get_data))(port);
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_get_status(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = (*((port->driver)->get_status))(port);
  }
#line 102
  return (tmp);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport.c"
int parport_set_control(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 108
  tmp = (*((port->driver)->set_control))(port, data);
  }
#line 108
  return (tmp);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/mpcbdm.c"
static int mpcbdm_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = parport_open(cable->port);
  }
#line 66
  if (tmp) {
#line 67
    return (-1);
  }
  {
#line 69
  parport_set_control(cable->port, (uint8_t )0);
#line 70
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 72
  return (0);
}
}
#line 75 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 80
  if (tms) {
#line 80
    tms = 1;
  } else {
#line 80
    tms = 0;
  }
#line 81
  if (tdi) {
#line 81
    tdi = 1;
  } else {
#line 81
    tdi = 0;
  }
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < n)) {
#line 83
      goto while_break;
    }
    {
#line 84
    parport_set_data(cable->port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 85
    cable_wait();
#line 86
    parport_set_data(cable->port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 87
    cable_wait();
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 94
  parport_set_data(cable->port, (uint8_t )0);
#line 95
  cable_wait();
#line 96
  tmp = parport_get_status(cable->port);
  }
#line 96
  return ((tmp >> 5) & 1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 102
  if (trst) {
#line 102
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 102
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 104
  parport_set_control(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst ^ 1));
  }
#line 105
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/mpcbdm.c"
cable_driver_t mpcbdm_cable_driver  = 
#line 108
     {"MPCBDM", "Mpcbdm JTAG cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & mpcbdm_init, & generic_done, & mpcbdm_clock, & mpcbdm_get_tdo, & generic_transfer,
    & mpcbdm_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/lattice.c"
static int lattice_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
#line 59
  ((generic_params_t *)cable->params)->trst = 1;
#line 61
  return (0);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/lattice.c"
static void lattice_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 69
  if (tms) {
#line 69
    tms = 1;
  } else {
#line 69
    tms = 0;
  }
#line 70
  if (tdi) {
#line 70
    tdi = 1;
  } else {
#line 70
    tdi = 0;
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < n)) {
#line 72
      goto while_break;
    }
    {
#line 73
    parport_set_data(cable->port, (uint8_t )(((tms << 2) | tdi) | (1 << 4)));
#line 74
    cable_wait();
#line 75
    parport_set_data(cable->port, (uint8_t )((((1 << 1) | (tms << 2)) | tdi) | (1 << 4)));
#line 76
    cable_wait();
#line 72
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/lattice.c"
static int lattice_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 83
  parport_set_data(cable->port, (uint8_t )(1 << 4));
#line 84
  cable_wait();
#line 85
  tmp = parport_get_status(cable->port);
  }
#line 85
  return ((tmp >> 6) & 1);
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/lattice.c"
static int lattice_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 91
  tmp = parport_set_data(cable->port, (uint8_t )(trst << 4));
  }
#line 91
  return (tmp);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/lattice.c"
cable_driver_t lattice_cable_driver  = 
#line 94
     {"Lattice", "Lattice Parallel Port JTAG Cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & lattice_init, & generic_done, & lattice_clock, & lattice_get_tdo,
    & generic_transfer, & lattice_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 66 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/keithkoep.c"
static int keithkoep_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 75
  return (0);
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/keithkoep.c"
static void keithkoep_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait();
#line 89
    parport_set_data(cable->port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait();
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 97
  parport_set_data(cable->port, (uint8_t )0);
#line 98
  cable_wait();
#line 99
  tmp = parport_get_status(cable->port);
  }
#line 99
  return ((tmp >> 5) & 1);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/keithkoep.c"
static int keithkoep_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 105
  if (trst) {
#line 105
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 105
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 107
  parport_set_control(cable->port, (uint8_t )((generic_params_t *)cable->params)->trst);
  }
#line 108
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/keithkoep.c"
cable_driver_t keithkoep_cable_driver  = 
#line 111
     {"KeithKoep", "Keith & Koep JTAG cable", & generic_connect, & generic_disconnect,
    & generic_cable_free, & keithkoep_init, & generic_done, & keithkoep_clock, & keithkoep_get_tdo,
    & generic_transfer, & keithkoep_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 63 "../../include/cable.h"
void cable_done(cable_t *cable ) ;
#line 64
void cable_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
int generic_connect(char **params , cable_t *cable ) 
{ 
  generic_params_t *cable_params ;
  void *tmp ;
  parport_t *port ;
  int i ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 42
  tmp = malloc(sizeof(*cable_params));
#line 42
  cable_params = (generic_params_t *)tmp;
#line 46
  tmp___1 = cmd_params(params);
  }
#line 46
  if (tmp___1 < 3) {
    {
#line 47
    tmp___0 = gettext("not enough arguments!\n");
#line 47
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 48
    return (1);
  }
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! parport_drivers[i]) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp___2 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 53
    if (tmp___2 == 0) {
#line 54
      goto while_break;
    }
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (! parport_drivers[i]) {
    {
#line 56
    tmp___3 = gettext("Unknown port driver: %s\n");
#line 56
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 57
    return (2);
  }
  {
#line 61
  tmp___4 = cmd_params(params);
#line 61
  port = (*((parport_drivers[i])->connect))((char const   **)(params + 2), tmp___4 - 2);
  }
#line 64
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 65
    tmp___5 = gettext("Error: Cable connection failed!\n");
#line 65
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 66
    return (3);
  }
#line 69
  if (! cable_params) {
    {
#line 70
    free((void *)cable_params);
#line 71
    free((void *)cable);
    }
#line 72
    return (4);
  }
#line 75
  cable->port = port;
#line 76
  cable->params = (void *)cable_params;
#line 77
  cable->chain = (chain_t *)((void *)0);
#line 79
  return (0);
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
void generic_disconnect(cable_t *cable ) 
{ 


  {
  {
#line 85
  cable_done(cable);
#line 86
  chain_disconnect(cable->chain);
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
void generic_cable_free(cable_t *cable ) 
{ 


  {
  {
#line 92
  (*(((cable->port)->driver)->parport_free))(cable->port);
#line 93
  free(cable->params);
#line 94
  free((void *)cable);
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
void generic_done(cable_t *cable ) 
{ 


  {
  {
#line 100
  parport_close(cable->port);
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
int generic_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int tmp ;

  {
#line 108
  if (out) {
#line 109
    i = 0;
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! (i < len)) {
#line 109
        goto while_break;
      }
      {
#line 110
      tmp = cable_get_tdo(cable);
#line 110
      *(out + i) = (char )tmp;
#line 111
      cable_clock(cable, 0, (int )*(in + i), 1);
#line 109
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 114
    i = 0;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (! (i < len)) {
#line 114
        goto while_break___0;
      }
      {
#line 115
      cable_clock(cable, 0, (int )*(in + i), 1);
#line 114
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 118
  return (i);
}
}
#line 121 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
int generic_get_trst(cable_t *cable ) 
{ 


  {
#line 124
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/generic.c"
void generic_lptcable_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 130
  tmp = gettext("Usage: cable %s parallel PORTADDR\n   or: cable %s ppdev PPDEV\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEF      ppdev device (e.g. /dev/parport0)\n\n");
#line 130
  printf((char const   */* __restrict  */)tmp, cablename, cablename);
  }
#line 156
  return;
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ei012.c"
static int ei012_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 58
  tmp = parport_open(cable->port);
  }
#line 58
  if (tmp) {
#line 59
    return (-1);
  }
  {
#line 61
  data = parport_get_data(cable->port);
  }
#line 61
  if (data < 0) {
    {
#line 62
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 4));
    }
#line 62
    if (tmp___0) {
#line 63
      return (-1);
    }
#line 64
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 66
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 68
  return (0);
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ei012.c"
static void ei012_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait();
#line 82
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait();
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ei012.c"
static int ei012_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 90
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 91
  cable_wait();
#line 92
  tmp = parport_get_status(cable->port);
  }
#line 92
  return ((tmp >> 7) & 1);
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ei012.c"
static int ei012_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 98
  if (trst) {
#line 98
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 98
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 100
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 101
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ei012.c"
cable_driver_t ei012_cable_driver  = 
#line 104
     {"EI012", "ETC EI012 JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & ei012_init, & generic_done, & ei012_clock, & ei012_get_tdo, & generic_transfer,
    & ei012_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 51 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ea253.c"
static int ea253_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
  {
#line 59
  data = parport_get_data(cable->port);
  }
#line 59
  if (data < 0) {
    {
#line 60
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 4));
    }
#line 60
    if (tmp___0) {
#line 61
      return (-1);
    }
#line 62
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 64
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ea253.c"
static void ea253_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | tdi));
#line 79
    cable_wait();
#line 80
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 81
    cable_wait();
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ea253.c"
static int ea253_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 89
  cable_wait();
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 4) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ea253.c"
static int ea253_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  if (trst) {
#line 96
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 96
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 98
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 99
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/ea253.c"
cable_driver_t ea253_cable_driver  = 
#line 102
     {"EA253", "ETC EA253 JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & ea253_init, & generic_done, & ea253_clock, & ea253_get_tdo, & generic_transfer,
    & ea253_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 58 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/dlc5.c"
static int dlc5_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = parport_open(cable->port);
  }
#line 61
  if (tmp) {
#line 62
    return (-1);
  }
#line 64
  ((generic_params_t *)cable->params)->trst = 1;
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/dlc5.c"
static void dlc5_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 79
    cable_wait();
#line 80
    parport_set_data(cable->port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 81
    cable_wait();
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/dlc5.c"
static int dlc5_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(1 << 4));
#line 89
  cable_wait();
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 4) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/dlc5.c"
static int dlc5_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/dlc5.c"
cable_driver_t dlc5_cable_driver  = 
#line 99
     {"DLC5", "Xilinx DLC5 JTAG Parallel Cable III", & generic_connect, & generic_disconnect,
    & generic_cable_free, & dlc5_init, & generic_done, & dlc5_clock, & dlc5_get_tdo,
    & generic_transfer, & dlc5_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 837
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioperm)(unsigned long __from ,
                                                                             unsigned long __num ,
                                                                             int __turn_on ) ;
#line 38
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static port_node_t *ports___1  =    (port_node_t *)((void *)0);
#line 111 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 114
  tmp = malloc(sizeof(*params));
#line 114
  params = (direct_params_t *)tmp;
#line 115
  tmp___0 = malloc(sizeof(*parport));
#line 115
  parport = (parport_t *)tmp___0;
#line 116
  tmp___1 = malloc(sizeof(*node));
#line 116
  node = (port_node_t *)tmp___1;
  }
#line 118
  if (! node) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! parport) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! params) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  }
#line 125
  params->port = port;
#line 127
  parport->params = (void *)params;
#line 128
  parport->driver = & direct_parport_driver;
#line 129
  parport->cable = (cable_t *)((void *)0);
#line 131
  node->port = parport;
#line 132
  node->next = ports___1;
#line 134
  ports___1 = node;
#line 136
  return (parport);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static void direct_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 144
  prev = & ports___1;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! *prev) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 146
      goto while_break;
    }
#line 144
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (*prev) {
    {
#line 149
    pn = *prev;
#line 150
    *prev = pn->next;
#line 151
    free((void *)pn);
    }
  }
  {
#line 154
  free(port->params);
#line 155
  free((void *)port);
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
parport_t *direct_connect(char const   **par , int parnum ) 
{ 
  long port_scan_val ;
  unsigned int port ;
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int aport ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 163
  pn = ports___1;
#line 166
  if (parnum != 1) {
    {
#line 167
    tmp = gettext("Syntax error!\n");
#line 167
    printf((char const   */* __restrict  */)tmp);
    }
#line 168
    return ((parport_t *)((void *)0));
  }
  {
#line 171
  port_scan_val = strtol((char const   */* __restrict  */)*(par + 0), (char **/* __restrict  */)((void *)0),
                         0);
  }
#line 173
  if (port_scan_val < 0L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  } else
#line 173
  if (port_scan_val + 3L > 65535L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  }
#line 178
  port = (unsigned int )port_scan_val;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! pn) {
#line 180
      goto while_break;
    }
#line 181
    pn = ports___1;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! pn) {
#line 181
        goto while_break___0;
      }
      {
#line 184
      aport = ((direct_params_t *)(pn->port)->params)->port;
#line 185
      tmp___3 = abs((int )(aport - port));
      }
#line 185
      if (tmp___3 < 3) {
        {
#line 186
        tmp___1 = gettext((((pn->port)->cable)->driver)->description);
#line 186
        tmp___2 = gettext("Disconnecting %s from parallel port at 0x%x\n");
#line 186
        printf((char const   */* __restrict  */)tmp___2, tmp___1, aport);
#line 187
        (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
        }
#line 188
        goto while_break___0;
      }
#line 181
      pn = pn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___4 = gettext("Initializing parallel port at 0x%x\n");
#line 192
  printf((char const   */* __restrict  */)tmp___4, port);
#line 194
  parport = direct_parport_alloc(port);
  }
#line 195
  if (! parport) {
    {
#line 196
    tmp___5 = gettext("%s(%d) Out of memory.\n");
#line 196
    printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c",
           196);
    }
#line 197
    return ((parport_t *)((void *)0));
  }
#line 200
  return (parport);
}
}
#line 203 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_open(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  port = ((direct_params_t *)parport->params)->port;
#line 207
  if (port + 3U <= 1024U) {
    {
#line 207
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 207
    if (tmp) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 207
  if (port + 3U > 1024U) {
    {
#line 207
    tmp___0 = iopl(3);
    }
#line 207
    if (tmp___0) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      tmp___1 = 0;
    }
  } else {
#line 207
    tmp___1 = 0;
  }
#line 207
  return (tmp___1);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_close(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 213
  port = ((direct_params_t *)parport->params)->port;
#line 214
  if (port + 3U <= 1024U) {
    {
#line 214
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 214
    tmp___1 = tmp;
    }
  } else {
    {
#line 214
    tmp___0 = iopl(0);
#line 214
    tmp___1 = tmp___0;
    }
  }
#line 214
  return (tmp___1);
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_set_data(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 220
  port = ((direct_params_t *)parport->params)->port;
#line 221
  outb(data, (unsigned short )port);
  }
#line 222
  return (0);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_get_data(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 228
  port = ((direct_params_t *)parport->params)->port;
#line 229
  tmp = inb((unsigned short )port);
  }
#line 229
  return ((int )tmp);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_get_status(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 235
  port = ((direct_params_t *)parport->params)->port;
#line 236
  tmp = inb((unsigned short )(port + 1U));
  }
#line 236
  return ((int )tmp ^ 128);
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
static int direct_set_control(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 242
  port = ((direct_params_t *)parport->params)->port;
#line 243
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 244
  return (0);
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/parport/direct.c"
parport_driver_t direct_parport_driver  = 
#line 247
     {"parallel", & direct_connect, & direct_parport_free, & direct_open, & direct_close,
    & direct_set_data, & direct_get_data, & direct_get_status, & direct_set_control};
#line 61 "../../include/cable.h"
void cable_free(cable_t *cable ) ;
#line 67
int cable_get_trst(cable_t *cable ) ;
#line 45 "../../include/chain.h"
chain_t *chain_alloc(void) ;
#line 46
void chain_free(chain_t *chain___0 ) ;
#line 50
int chain_get_trst(chain_t *chain___0 ) ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
chain_t *chain_alloc(void) 
{ 
  chain_t *chain___0 ;
  void *tmp ;

  {
  {
#line 36
  tmp = malloc(sizeof(chain_t ));
#line 36
  chain___0 = (chain_t *)tmp;
  }
#line 37
  if (! chain___0) {
#line 38
    return ((chain_t *)((void *)0));
  }
  {
#line 40
  chain___0->cable = (cable_t *)((void *)0);
#line 41
  chain___0->parts = (parts_t *)((void *)0);
#line 42
  chain___0->active_part = 0;
#line 43
  tap_state_init(chain___0);
  }
#line 45
  return (chain___0);
}
}
#line 48 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_free(chain_t *chain___0 ) 
{ 


  {
#line 51
  if (! chain___0) {
#line 52
    return;
  }
  {
#line 54
  chain_disconnect(chain___0);
#line 56
  parts_free(chain___0->parts);
#line 57
  free((void *)chain___0);
  }
#line 58
  return;
}
}
#line 60 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_disconnect(chain_t *chain___0 ) 
{ 


  {
#line 63
  if (! chain___0->cable) {
#line 64
    return;
  }
  {
#line 66
  tap_state_done(chain___0);
#line 67
  cable_done(chain___0->cable);
#line 68
  cable_free(chain___0->cable);
#line 69
  chain___0->cable = (cable_t *)((void *)0);
  }
#line 70
  return;
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_clock(chain_t *chain___0 , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 77
  if (! chain___0) {
#line 78
    return;
  } else
#line 77
  if (! chain___0->cable) {
#line 78
    return;
  }
  {
#line 80
  cable_clock(chain___0->cable, tms, tdi, n);
#line 82
  i = 0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < n)) {
#line 82
      goto while_break;
    }
    {
#line 83
    tap_state_clock(chain___0, tms);
#line 82
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
int chain_set_trst(chain_t *chain___0 , int trst ) 
{ 
  int old_trst ;
  int tmp ;

  {
  {
#line 89
  tmp = cable_get_trst(chain___0->cable);
#line 89
  old_trst = tmp;
#line 90
  trst = cable_set_trst(chain___0->cable, trst);
#line 91
  tap_state_set_trst(chain___0, old_trst, trst);
  }
#line 92
  return (trst);
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
int chain_get_trst(chain_t *chain___0 ) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = cable_get_trst(chain___0->cable);
  }
#line 98
  return (tmp);
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_shift_instructions_mode(chain_t *chain___0 , int capture , int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  int tmp___0 ;

  {
#line 107
  if (! chain___0) {
#line 108
    return;
  } else
#line 107
  if (! chain___0->parts) {
#line 108
    return;
  }
#line 110
  ps = chain___0->parts;
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < ps->len)) {
#line 112
      goto while_break;
    }
#line 113
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 114
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 114
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c",
             114, i);
      }
#line 115
      return;
    }
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (capture) {
    {
#line 120
    tap_capture_ir(chain___0);
    }
  }
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (i < ps->len)) {
#line 121
      goto while_break___0;
    }
#line 122
    if (i + 1 == ps->len) {
#line 122
      tmp___0 = exit___0;
    } else {
#line 122
      tmp___0 = 0;
    }
    {
#line 122
    tap_shift_register(chain___0, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                       (tap_register *)((void *)0), tmp___0);
#line 121
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 126 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_shift_instructions(chain_t *chain___0 ) 
{ 


  {
  {
#line 129
  chain_shift_instructions_mode(chain___0, 1, 1);
  }
#line 130
  return;
}
}
#line 132 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_shift_data_registers_mode(chain_t *chain___0 , int capture_output , int capture ,
                                     int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  tap_register *tmp___2 ;

  {
#line 138
  if (! chain___0) {
#line 139
    return;
  } else
#line 138
  if (! chain___0->parts) {
#line 139
    return;
  }
#line 141
  ps = chain___0->parts;
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < ps->len)) {
#line 143
      goto while_break;
    }
#line 144
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 145
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 145
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c",
             145, i);
      }
#line 146
      return;
    }
#line 148
    if ((unsigned long )((*(ps->parts + i))->active_instruction)->data_register == (unsigned long )((void *)0)) {
      {
#line 149
      tmp___0 = gettext("%s(%d) Part %d without data register\n");
#line 149
      printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c",
             149, i);
      }
#line 150
      return;
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (capture) {
    {
#line 155
    tap_capture_dr(chain___0);
    }
  }
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if (! (i < ps->len)) {
#line 156
      goto while_break___0;
    }
#line 157
    if (i + 1 == ps->len) {
#line 157
      tmp___1 = exit___0;
    } else {
#line 157
      tmp___1 = 0;
    }
#line 157
    if (capture_output) {
#line 157
      tmp___2 = (((*(ps->parts + i))->active_instruction)->data_register)->out;
    } else {
#line 157
      tmp___2 = (tap_register *)((void *)0);
    }
    {
#line 157
    tap_shift_register(chain___0, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                       tmp___2, tmp___1);
#line 156
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/chain.c"
void chain_shift_data_registers(chain_t *chain___0 , int capture_output ) 
{ 


  {
  {
#line 165
  chain_shift_data_registers_mode(chain___0, capture_output, 1, 1);
  }
#line 166
  return;
}
}
#line 329 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fmax)(double __x ,
                                                                              double __y )  __attribute__((__const__)) ;
#line 38 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
cable_driver_t arcom_cable_driver ;
#line 39
cable_driver_t byteblaster_cable_driver ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
cable_driver_t *cable_drivers[15]  = 
#line 61
  {      & arcom_cable_driver,      & byteblaster_cable_driver,      & dlc5_cable_driver,      & ea253_cable_driver, 
        & ei012_cable_driver,      & igloo_cable_driver,      & keithkoep_cable_driver,      & lattice_cable_driver, 
        & mpcbdm_cable_driver,      & triton_cable_driver,      & wiggler_cable_driver,      & wiggler2_cable_driver, 
        & xpc_int_cable_driver,      & xpc_ext_cable_driver,      (cable_driver_t *)((void *)0)};
#line 86 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
void cable_free(cable_t *cable ) 
{ 


  {
  {
#line 89
  (*((cable->driver)->cable_free))(cable);
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
int cable_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 95
  tmp = (*((cable->driver)->init))(cable);
  }
#line 95
  return (tmp);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
void cable_done(cable_t *cable ) 
{ 


  {
  {
#line 101
  (*((cable->driver)->done))(cable);
  }
#line 101
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
void cable_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 


  {
  {
#line 107
  (*((cable->driver)->clock))(cable, tms, tdi, n);
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
int cable_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 113
  tmp = (*((cable->driver)->get_tdo))(cable);
  }
#line 113
  return (tmp);
}
}
#line 116 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
int cable_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 119
  tmp = (*((cable->driver)->set_trst))(cable, trst);
  }
#line 119
  return (tmp);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
int cable_get_trst(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 125
  tmp = (*((cable->driver)->get_trst))(cable);
  }
#line 125
  return (tmp);
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
static uint32_t delay  =    (uint32_t )0;
#line 129 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
static uint32_t frequency  =    (uint32_t )0;
#line 131 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 
  double tolerance ;
  uint32_t loops ;
  uint32_t i ;
  uint32_t new_delay ;
  long double start ;
  long double end ;
  long double real_frequency ;
  double tmp___0 ;

  {
#line 134
  if (new_frequency == 0U) {
#line 135
    delay = (uint32_t )0;
#line 136
    frequency = (uint32_t )0;
  } else {
    {
#line 138
    tolerance = 0.1;
#line 141
    printf((char const   */* __restrict  */)"requested frequency %u, now calibrating delay loop\n",
           new_frequency);
    }
#line 143
    if (delay == 0U) {
#line 144
      delay = (uint32_t )1000;
#line 145
      loops = (uint32_t )10000;
    } else {
#line 147
      loops = 3U * frequency;
    }
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 154
      start = frealtime();
#line 155
      i = (uint32_t )0;
      }
      {
#line 155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 155
        if (! (i < loops)) {
#line 155
          goto while_break___0;
        }
        {
#line 156
        chain_clock(chain, 0, 0, 1);
#line 155
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 158
      end = frealtime();
      }
#line 160
      if (! (end > start)) {
        {
#line 160
        __assert_fail("end > start", "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c",
                      160U, "cable_set_frequency");
        }
      }
      {
#line 161
      real_frequency = (long double )loops / (end - start);
#line 162
      printf((char const   */* __restrict  */)"new real frequency %Lg, delay %u\n",
             real_frequency, delay);
#line 165
      tmp___0 = fmax((double )real_frequency, (double )new_frequency);
#line 165
      loops = (uint32_t )((double )3 * tmp___0);
#line 166
      new_delay = (uint32_t )(((long double )delay * real_frequency) / (long double )new_frequency);
      }
#line 168
      if (real_frequency >= (long double )((1.0 - tolerance) * (double )new_frequency)) {
#line 169
        if (real_frequency <= (long double )((1.0 + tolerance) * (double )new_frequency)) {
#line 170
          goto while_break;
        }
#line 172
        if (new_delay > delay) {
#line 173
          delay = new_delay;
        } else {
#line 175
          delay ++;
        }
      } else {
#line 178
        if (new_delay < delay) {
#line 179
          delay = new_delay;
        } else {
#line 181
          delay --;
        }
#line 183
        if (delay == 0U) {
          {
#line 184
          printf((char const   */* __restrict  */)"operating without delay\n");
          }
#line 185
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 190
    frequency = new_frequency;
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
uint32_t cable_get_frequency(cable_t *cable ) 
{ 


  {
#line 197
  return (frequency);
}
}
#line 200 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
int cable_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int r ;

  {
  {
#line 204
  r = (*((cable->driver)->transfer))(cable, len, in, out);
  }
#line 205
  return (r);
}
}
#line 208 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable.c"
void cable_wait(void) 
{ 
  int i ;
  int volatile   j ;

  {
#line 214
  if (delay == 0U) {
#line 215
    return;
  }
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((uint32_t )i < delay)) {
#line 217
      goto while_break;
    }
#line 218
    j = (int volatile   )i;
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/byteblaster.c"
static int byteblaster_init(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 72
  BB_II = 0;
#line 74
  tmp = parport_open(cable->port);
  }
#line 74
  if (tmp) {
#line 75
    return (-1);
  }
  {
#line 77
  ((generic_params_t *)cable->params)->trst = 1;
#line 80
  parport_set_data(cable->port, (uint8_t )(1 << 5));
#line 81
  tmp___0 = parport_get_status(cable->port);
  }
#line 81
  if (! ((tmp___0 >> 6) & 1)) {
#line 82
    BB_II = 1;
  }
  {
#line 83
  parport_set_data(cable->port, (uint8_t )0);
#line 84
  tmp___1 = parport_get_status(cable->port);
  }
#line 84
  if ((tmp___1 >> 6) & 1) {
#line 85
    BB_II = 1;
  }
#line 89
  if (BB_II) {
    {
#line 89
    tmp___2 = parport_get_status(cable->port);
    }
#line 89
    if ((tmp___2 >> 3) & 1) {
#line 90
      return (-1);
    }
  }
  {
#line 93
  parport_set_control(cable->port, (uint8_t )12);
  }
#line 95
  return (0);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/byteblaster.c"
static void byteblaster_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 103
  if (tms) {
#line 103
    tms = 1;
  } else {
#line 103
    tms = 0;
  }
#line 104
  if (tdi) {
#line 104
    tdi = 1;
  } else {
#line 104
    tdi = 0;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < n)) {
#line 106
      goto while_break;
    }
    {
#line 107
    parport_set_data(cable->port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 108
    cable_wait();
#line 109
    parport_set_data(cable->port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 110
    cable_wait();
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 117
  parport_set_data(cable->port, (uint8_t )0);
#line 118
  cable_wait();
#line 119
  tmp = parport_get_status(cable->port);
  }
#line 119
  return ((tmp >> 7) & 1);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/byteblaster.c"
static int byteblaster_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 125
  return (1);
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/byteblaster.c"
cable_driver_t byteblaster_cable_driver  = 
#line 128
     {"ByteBlaster", "Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable",
    & generic_connect, & generic_disconnect, & generic_cable_free, & byteblaster_init,
    & generic_done, & byteblaster_clock, & byteblaster_get_tdo, & generic_transfer,
    & byteblaster_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 51 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/arcom.c"
static int arcom_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 56
  tmp = parport_open(cable->port);
  }
#line 56
  if (tmp) {
#line 57
    return (-1);
  }
  {
#line 59
  data = parport_get_data(cable->port);
  }
#line 59
  if (data < 0) {
    {
#line 60
    tmp___0 = parport_set_data(cable->port, (uint8_t )(1 << 3));
    }
#line 60
    if (tmp___0) {
#line 61
      return (-1);
    }
#line 62
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 64
    ((generic_params_t *)cable->params)->trst = (data >> 3) & 1;
  }
#line 66
  return (0);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/arcom.c"
static void arcom_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 74
  if (tms) {
#line 74
    tms = 1;
  } else {
#line 74
    tms = 0;
  }
#line 75
  if (tdi) {
#line 75
    tdi = 1;
  } else {
#line 75
    tdi = 0;
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < n)) {
#line 77
      goto while_break;
    }
    {
#line 78
    parport_set_data(cable->port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 3) | (tms << 2)) | (tdi << 1)));
#line 79
    cable_wait();
#line 80
    parport_set_data(cable->port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait();
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/arcom.c"
static int arcom_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 88
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
#line 89
  cable_wait();
#line 90
  tmp = parport_get_status(cable->port);
  }
#line 90
  return ((tmp >> 7) & 1);
}
}
#line 93 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/arcom.c"
static int arcom_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 96
  if (trst) {
#line 96
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 96
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 98
  parport_set_data(cable->port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
  }
#line 99
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.7/src/tap/cable/arcom.c"
cable_driver_t arcom_cable_driver  = 
#line 102
     {"ARCOM", "Arcom JTAG Cable", & generic_connect, & generic_disconnect, & generic_cable_free,
    & arcom_init, & generic_done, & arcom_clock, & arcom_get_tdo, & generic_transfer,
    & arcom_set_trst, & generic_get_trst, & generic_lptcable_help};
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
flash_driver_t *flash_drivers[8]  = 
#line 58 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
  {      & amd_32_flash_driver,      & amd_16_flash_driver,      & amd_8_flash_driver,      & intel_32_flash_driver, 
        & intel_16_flash_driver,      & intel_8_flash_driver,      & amd_29xx040_flash_driver,      (flash_driver_t *)((void *)0)};
#line 70 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
static flash_driver_t *flash_driver  =    (flash_driver_t *)((void *)0);
#line 72 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
static void set_flash_driver(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 78
  flash_driver = (flash_driver_t *)((void *)0);
#line 79
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 80
    return;
  }
#line 81
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 84
    if (tmp) {
      {
#line 85
      flash_driver = flash_drivers[i];
#line 86
      (*(flash_driver->print_info))(cfi_array);
      }
#line 87
      return;
    }
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 90
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 94
  tmp___1 = gettext("Flash not supported!\n");
#line 94
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
void flashmsbin(bus_t *bus___0 , FILE *f ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  char *tmp ;
  char sync[8] ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t start ;
  uint32_t len ;
  int first ;
  int last ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  uint32_t a ;
  uint32_t l ;
  uint32_t c ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint32_t data ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  uint32_t a___0 ;
  uint32_t l___0 ;
  uint32_t c___0 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  uint32_t data___0 ;
  uint32_t readed ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 103
  set_flash_driver();
  }
#line 104
  if (! cfi_array) {
    {
#line 105
    tmp = gettext("no flash driver found\n");
#line 105
    printf((char const   */* __restrict  */)tmp);
    }
#line 106
    return;
  } else
#line 104
  if (! flash_driver) {
    {
#line 105
    tmp = gettext("no flash driver found\n");
#line 105
    printf((char const   */* __restrict  */)tmp);
    }
#line 106
    return;
  }
  {
#line 108
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 113
  fread((void */* __restrict  */)(& sync), sizeof(char ), (size_t )7, (FILE */* __restrict  */)f);
#line 114
  sync[7] = (char )'\000';
#line 115
  tmp___1 = strcmp("B000FF\n", (char const   *)(sync));
  }
#line 115
  if (tmp___1 != 0) {
    {
#line 116
    tmp___0 = gettext("Invalid sync sequence!\n");
#line 116
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 117
    return;
  }
  {
#line 127
  fread((void */* __restrict  */)(& start), sizeof(start), (size_t )1, (FILE */* __restrict  */)f);
#line 128
  fread((void */* __restrict  */)(& len), sizeof(len), (size_t )1, (FILE */* __restrict  */)f);
#line 129
  first = (int )(start / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
#line 130
  last = (int )(((start + len) - 1U) / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (first <= last)) {
#line 131
      goto while_break;
    }
    {
#line 132
    adr = ((uint32_t )first * (cfi->device_geometry.erase_block_regions + 0)->erase_block_size) * 2U;
#line 133
    (*(flash_driver->unlock_block))(cfi_array, adr);
#line 134
    tmp___2 = gettext("block %d unlocked\n");
#line 134
    printf((char const   */* __restrict  */)tmp___2, first);
#line 135
    tmp___3 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 135
    tmp___4 = gettext("erasing block %d: %d\n");
#line 135
    printf((char const   */* __restrict  */)tmp___4, first, tmp___3);
#line 131
    first ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp___5 = gettext("program:\n");
#line 139
  printf((char const   */* __restrict  */)tmp___5);
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 143
    fread((void */* __restrict  */)(& a), sizeof(a), (size_t )1, (FILE */* __restrict  */)f);
#line 144
    fread((void */* __restrict  */)(& l), sizeof(l), (size_t )1, (FILE */* __restrict  */)f);
#line 145
    fread((void */* __restrict  */)(& c), sizeof(c), (size_t )1, (FILE */* __restrict  */)f);
#line 146
    tmp___7 = feof(f);
    }
#line 146
    if (tmp___7) {
      {
#line 147
      tmp___6 = gettext("Error: premature end of file\n");
#line 147
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 148
      return;
    }
    {
#line 150
    tmp___8 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 150
    printf((char const   */* __restrict  */)tmp___8, a, l, c);
    }
#line 151
    if (a == 0U) {
#line 151
      if (c == 0U) {
#line 152
        goto while_break___0;
      }
    }
#line 153
    if (l & 3U) {
      {
#line 154
      tmp___9 = gettext("Error: Invalid record length!\n");
#line 154
      printf((char const   */* __restrict  */)tmp___9);
      }
#line 155
      return;
    }
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 158
      if (! l) {
#line 158
        goto while_break___1;
      }
      {
#line 161
      tmp___10 = gettext("addr: 0x%08X");
#line 161
      printf((char const   */* __restrict  */)tmp___10, a);
#line 162
      printf((char const   */* __restrict  */)"\r");
#line 163
      fflush(stdout);
#line 164
      fread((void */* __restrict  */)(& data), sizeof(data), (size_t )1, (FILE */* __restrict  */)f);
#line 165
      tmp___12 = (*(flash_driver->program))(cfi_array, a, data);
      }
#line 165
      if (tmp___12) {
        {
#line 166
        tmp___11 = gettext("\nflash error\n");
#line 166
        printf((char const   */* __restrict  */)tmp___11);
        }
#line 167
        return;
      }
#line 169
      a += 4U;
#line 170
      l -= 4U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  printf((char const   */* __restrict  */)"\n");
#line 175
  (*(flash_driver->readarray))(cfi_array);
#line 177
  fseek(f, 15L, 0);
#line 178
  tmp___13 = gettext("verify:\n");
#line 178
  printf((char const   */* __restrict  */)tmp___13);
  }
  {
#line 180
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 183
    fread((void */* __restrict  */)(& a___0), sizeof(a___0), (size_t )1, (FILE */* __restrict  */)f);
#line 184
    fread((void */* __restrict  */)(& l___0), sizeof(l___0), (size_t )1, (FILE */* __restrict  */)f);
#line 185
    fread((void */* __restrict  */)(& c___0), sizeof(c___0), (size_t )1, (FILE */* __restrict  */)f);
#line 186
    tmp___15 = feof(f);
    }
#line 186
    if (tmp___15) {
      {
#line 187
      tmp___14 = gettext("Error: premature end of file\n");
#line 187
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 188
      return;
    }
    {
#line 190
    tmp___16 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 190
    printf((char const   */* __restrict  */)tmp___16, a___0, l___0, c___0);
    }
#line 191
    if (a___0 == 0U) {
#line 191
      if (c___0 == 0U) {
#line 192
        goto while_break___2;
      }
    }
#line 193
    if (l___0 & 3U) {
      {
#line 194
      tmp___17 = gettext("Error: Invalid record length!\n");
#line 194
      printf((char const   */* __restrict  */)tmp___17);
      }
#line 195
      return;
    }
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 198
      if (! l___0) {
#line 198
        goto while_break___3;
      }
      {
#line 201
      tmp___18 = gettext("addr: 0x%08X");
#line 201
      printf((char const   */* __restrict  */)tmp___18, a___0);
#line 202
      printf((char const   */* __restrict  */)"\r");
#line 203
      fflush(stdout);
#line 204
      fread((void */* __restrict  */)(& data___0), sizeof(data___0), (size_t )1, (FILE */* __restrict  */)f);
#line 205
      readed = (*((bus___0->driver)->read))(bus___0, a___0);
      }
#line 206
      if (data___0 != readed) {
        {
#line 207
        tmp___19 = gettext("\nverify error: 0x%08X vs. 0x%08X at addr %08X\n");
#line 207
        printf((char const   */* __restrict  */)tmp___19, readed, data___0, a___0);
        }
#line 209
        return;
      }
#line 211
      a___0 += 4U;
#line 212
      l___0 -= 4U;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 216
  tmp___20 = gettext("\nDone.\n");
#line 216
  printf((char const   */* __restrict  */)tmp___20);
  }
#line 217
  return;
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
static int find_block(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;

  {
#line 223
  b = 0;
#line 224
  bb = 0;
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 226
      goto while_break;
    }
#line 227
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 228
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 229
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 230
    region_size = region_blocks * region_block_size;
#line 232
    if (adr < bb + region_size) {
#line 233
      return (b + (adr - bb) / region_block_size);
    }
#line 234
    b += region_blocks;
#line 235
    bb += region_size;
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (-1);
}
}
#line 240 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  int *erased ;
  int i ;
  int neb ;
  int bus_width ;
  int chip_width ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t data ;
  uint8_t b[4096] ;
  int bc ;
  int bn ;
  int block_no ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int j ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  uint8_t buf[16] ;
  uint32_t data___0 ;
  uint32_t readed ;
  int j___0 ;
  int tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 251
  set_flash_driver();
  }
#line 252
  if (! cfi_array) {
    {
#line 253
    tmp = gettext("no flash driver found\n");
#line 253
    printf((char const   */* __restrict  */)tmp);
    }
#line 254
    return;
  } else
#line 252
  if (! flash_driver) {
    {
#line 253
    tmp = gettext("no flash driver found\n");
#line 253
    printf((char const   */* __restrict  */)tmp);
    }
#line 254
    return;
  }
#line 256
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 258
  bus_width = cfi_array->bus_width;
#line 259
  chip_width = (*(cfi_array->cfi_chips + 0))->width;
#line 261
  i = 0;
#line 261
  neb = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 261
      goto while_break;
    }
#line 262
    neb = (int )((uint32_t )neb + (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  tmp___0 = malloc((unsigned long )neb * sizeof(*erased));
#line 264
  erased = (int *)tmp___0;
  }
#line 265
  if (! erased) {
    {
#line 266
    tmp___1 = gettext("Out of memory!\n");
#line 266
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 267
    return;
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i < neb)) {
#line 269
      goto while_break___0;
    }
#line 270
    *(erased + i) = 0;
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 272
  tmp___2 = gettext("program:\n");
#line 272
  printf((char const   */* __restrict  */)tmp___2);
#line 273
  adr = addr;
  }
  {
#line 274
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 274
    tmp___11 = feof(f);
    }
#line 274
    if (tmp___11) {
#line 274
      goto while_break___1;
    }
    {
#line 278
    bc = 0;
#line 278
    bn = 0;
#line 280
    tmp___3 = find_block(cfi, (int )(adr - cfi_array->address), bus_width, chip_width);
#line 280
    block_no = tmp___3;
    }
#line 281
    if (! *(erased + block_no)) {
      {
#line 282
      (*(flash_driver->unlock_block))(cfi_array, adr);
#line 283
      tmp___4 = gettext("\nblock %d unlocked\n");
#line 283
      printf((char const   */* __restrict  */)tmp___4, block_no);
#line 284
      tmp___5 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 284
      tmp___6 = gettext("erasing block %d: %d\n");
#line 284
      printf((char const   */* __restrict  */)tmp___6, block_no, tmp___5);
#line 285
      *(erased + block_no) = 1;
      }
    }
    {
#line 288
    tmp___7 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )4096, (FILE */* __restrict  */)f);
#line 288
    bn = (int )tmp___7;
#line 289
    bc = 0;
    }
    {
#line 289
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 289
      if (! (bc < bn)) {
#line 289
        goto while_break___2;
      }
#line 291
      if ((adr & 255U) == 0U) {
        {
#line 292
        tmp___8 = gettext("addr: 0x%08X\r");
#line 292
        printf((char const   */* __restrict  */)tmp___8, adr);
#line 293
        fflush(stdout);
        }
      }
#line 296
      data = (uint32_t )0;
#line 297
      j = 0;
      {
#line 297
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 297
        if (! ((unsigned int )j < flash_driver->bus_width)) {
#line 297
          goto while_break___3;
        }
#line 298
        if (big_endian) {
#line 299
          data = (data << 8) | (unsigned int )b[bc + j];
        } else {
#line 301
          data |= (unsigned int )((int )b[bc + j] << j * 8);
        }
#line 297
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 303
      tmp___10 = (*(flash_driver->program))(cfi_array, adr, data);
      }
#line 303
      if (tmp___10) {
        {
#line 304
        tmp___9 = gettext("\nflash error\n");
#line 304
        printf((char const   */* __restrict  */)tmp___9);
        }
#line 305
        return;
      }
#line 307
      adr += flash_driver->bus_width;
#line 289
      bc = (int )((unsigned int )bc + flash_driver->bus_width);
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 310
  printf((char const   */* __restrict  */)"\n");
#line 312
  (*(flash_driver->readarray))(cfi_array);
#line 314
  fseek(f, 0L, 0);
#line 315
  tmp___12 = gettext("verify:\n");
#line 315
  printf((char const   */* __restrict  */)tmp___12);
#line 316
  fflush(stdout);
#line 317
  adr = addr;
  }
  {
#line 318
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 318
    tmp___19 = feof(f);
    }
#line 318
    if (tmp___19) {
#line 318
      goto while_break___4;
    }
    {
#line 324
    tmp___15 = fread((void */* __restrict  */)(buf), (size_t )flash_driver->bus_width,
                     (size_t )1, (FILE */* __restrict  */)f);
    }
#line 324
    if (tmp___15 != 1UL) {
      {
#line 325
      tmp___13 = feof(f);
      }
#line 325
      if (tmp___13) {
#line 326
        goto while_break___4;
      }
      {
#line 327
      tmp___14 = gettext("Error during file read.\n");
#line 327
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 328
      return;
    }
#line 331
    data___0 = (uint32_t )0;
#line 332
    j___0 = 0;
    {
#line 332
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 332
      if (! ((unsigned int )j___0 < flash_driver->bus_width)) {
#line 332
        goto while_break___5;
      }
#line 333
      if (big_endian) {
#line 334
        data___0 = (data___0 << 8) | (unsigned int )buf[j___0];
      } else {
#line 336
        data___0 |= (unsigned int )((int )buf[j___0] << j___0 * 8);
      }
#line 332
      j___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 338
    if (addr) {
#line 338
      tmp___17 = 1;
    } else {
#line 338
      tmp___17 = 0;
    }
#line 338
    if (tmp___17 == 0) {
      {
#line 339
      tmp___16 = gettext("addr: 0x%08X\r");
#line 339
      printf((char const   */* __restrict  */)tmp___16, adr);
#line 340
      fflush(stdout);
      }
    }
    {
#line 342
    readed = (*((bus___0->driver)->read))(bus___0, adr);
    }
#line 343
    if (data___0 != readed) {
      {
#line 344
      tmp___18 = gettext("\nverify error:\nreaded: 0x%08X\nexpected: 0x%08X\n");
#line 344
      printf((char const   */* __restrict  */)tmp___18, readed, data___0);
      }
#line 345
      return;
    }
#line 347
    adr += flash_driver->bus_width;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 349
  tmp___20 = gettext("\nDone.\n");
#line 349
  printf((char const   */* __restrict  */)tmp___20);
#line 351
  free((void *)erased);
  }
#line 352
  return;
}
}
#line 354 "/home/khheo/project/benchmark/urjtag-0.7/src/flash.c"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) 
{ 
  cfi_query_structure_t *cfi ;
  int i ;
  int status ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int addr_block ;
  int block_no ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 359
  status = 0;
#line 361
  set_flash_driver();
  }
#line 362
  if (! cfi_array) {
    {
#line 363
    tmp = gettext("no flash driver found\n");
#line 363
    printf((char const   */* __restrict  */)tmp);
    }
#line 364
    return;
  } else
#line 362
  if (! flash_driver) {
    {
#line 363
    tmp = gettext("no flash driver found\n");
#line 363
    printf((char const   */* __restrict  */)tmp);
    }
#line 364
    return;
  }
#line 366
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 368
  if (number > 1) {
#line 368
    tmp___0 = "s";
  } else {
#line 368
    tmp___0 = "";
  }
  {
#line 368
  tmp___1 = gettext("\nErasing %d Flash block%s from address 0x%x\n");
#line 368
  printf((char const   */* __restrict  */)tmp___1, number, tmp___0, addr);
#line 370
  i = 1;
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i <= number)) {
#line 370
      goto while_break;
    }
    {
#line 371
    addr_block = (int )(((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * flash_driver->bus_width) / 2U);
#line 372
    block_no = (int )(addr / (uint32_t )addr_block);
#line 373
    tmp___2 = gettext("(%d%% Completed) FLASH Block %d : Unlocking ... ");
#line 373
    printf((char const   */* __restrict  */)tmp___2, (i * 100) / number, block_no);
#line 374
    fflush(stdout);
#line 375
    (*(flash_driver->unlock_block))(cfi_array, addr);
#line 376
    tmp___3 = gettext("Erasing ... ");
#line 376
    printf((char const   */* __restrict  */)tmp___3);
#line 377
    fflush(stdout);
#line 378
    status = (*(flash_driver->erase_block))(cfi_array, addr);
    }
#line 379
    if (status == 0) {
#line 380
      if (i == number) {
        {
#line 381
        tmp___4 = gettext("\r(100%% Completed) FLASH Block %d : Unlocking ... Erasing ... Ok.\n");
#line 381
        printf((char const   */* __restrict  */)tmp___4, block_no);
        }
      } else {
        {
#line 383
        tmp___5 = gettext("Ok.\r%78s\r");
#line 383
        printf((char const   */* __restrict  */)tmp___5, "");
        }
      }
    } else {
      {
#line 386
      tmp___6 = gettext("ERROR.\n");
#line 386
      printf((char const   */* __restrict  */)tmp___6);
      }
    }
#line 387
    addr |= (unsigned int )(addr_block - 1);
#line 388
    addr ++;
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  if (status == 0) {
    {
#line 392
    tmp___7 = gettext("\nErasing Completed.\n");
#line 392
    printf((char const   */* __restrict  */)tmp___7);
    }
  } else {
    {
#line 394
    tmp___8 = gettext("\nErasing Failed.\n");
#line 394
    printf((char const   */* __restrict  */)tmp___8);
    }
  }
#line 399
  return;
}
}
#line 36 "/home/khheo/project/benchmark/urjtag-0.7/src/writemem.c"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  int bidx ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 41
  bc = 0;
#line 42
  bidx = 0;
#line 48
  if (! bus___0) {
    {
#line 49
    tmp = gettext("Error: Missing bus driver!\n");
#line 49
    printf((char const   */* __restrict  */)tmp);
    }
#line 50
    return;
  }
  {
#line 53
  (*((bus___0->driver)->prepare))(bus___0);
#line 55
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 55
  if (tmp___1 != 0) {
    {
#line 56
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 56
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 57
    return;
  }
#line 59
  step = area.width / 8U;
#line 61
  if (step == 0U) {
    {
#line 62
    tmp___2 = gettext("Unknown bus width!\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return;
  }
  {
#line 66
  addr &= ~ (step - 1U);
#line 67
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 69
  tmp___3 = gettext("address: 0x%08X\n");
#line 69
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 70
  tmp___4 = gettext("length:  0x%08X\n");
#line 70
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 72
  if (len == 0U) {
    {
#line 73
    tmp___5 = gettext("length is 0.\n");
#line 73
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 74
    return;
  }
  {
#line 77
  a = addr;
#line 78
  end = (uint64_t )(a + len);
#line 79
  tmp___6 = gettext("writing:\n");
#line 79
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((uint64_t )a < end)) {
#line 81
      goto while_break;
    }
#line 86
    if ((uint32_t )bc < step) {
      {
#line 87
      tmp___7 = gettext("addr: 0x%08X");
#line 87
      printf((char const   */* __restrict  */)tmp___7, a);
#line 88
      printf((char const   */* __restrict  */)"\r");
#line 89
      fflush(stdout);
      }
#line 90
      if (bc != 0) {
        {
#line 91
        tmp___8 = gettext("Data not on word boundary, NOT SUPPORTED!");
#line 91
        printf((char const   */* __restrict  */)tmp___8);
        }
      }
      {
#line 92
      tmp___11 = feof(f);
      }
#line 92
      if (tmp___11) {
        {
#line 93
        tmp___9 = gettext("Unexpected end of file!\n");
#line 93
        printf((char const   */* __restrict  */)tmp___9);
#line 94
        tmp___10 = gettext("Addr: 0x%08X\n");
#line 94
        printf((char const   */* __restrict  */)tmp___10, a);
        }
#line 95
        goto while_break;
      }
      {
#line 97
      tmp___12 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )4096, (FILE */* __restrict  */)f);
#line 97
      bc = (int )tmp___12;
      }
#line 98
      if (! bc) {
        {
#line 99
        tmp___13 = gettext("Short read: bc=0x%X\n");
#line 99
        printf((char const   */* __restrict  */)tmp___13, bc);
        }
      }
#line 101
      bidx = 0;
    }
#line 106
    data = (uint32_t )0;
#line 107
    j = (int )step;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (j > 0)) {
#line 107
        goto while_break___0;
      }
#line 108
      if (big_endian) {
#line 109
        tmp___14 = bidx;
#line 109
        bidx ++;
#line 109
        data |= (unsigned int )b[tmp___14];
#line 110
        data <<= 8;
#line 111
        bc --;
      } else {
#line 113
        tmp___15 = bidx;
#line 113
        bidx ++;
#line 113
        data |= (unsigned int )((int )b[tmp___15] << (step - (uint32_t )j) * 8U);
#line 114
        bc --;
      }
#line 107
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 118
    (*((bus___0->driver)->write))(bus___0, a, data);
#line 81
    a += step;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp___16 = gettext("\nDone.\n");
#line 122
  printf((char const   */* __restrict  */)tmp___16);
  }
#line 123
  return;
}
}
#line 43 "/home/khheo/project/benchmark/urjtag-0.7/src/readmem.c"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 48
  bc = 0;
#line 54
  if (! bus___0) {
    {
#line 55
    tmp = gettext("Error: Missing bus driver!\n");
#line 55
    printf((char const   */* __restrict  */)tmp);
    }
#line 56
    return;
  }
  {
#line 59
  (*((bus___0->driver)->prepare))(bus___0);
#line 61
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 61
  if (tmp___1 != 0) {
    {
#line 62
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 62
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 63
    return;
  }
#line 65
  step = area.width / 8U;
#line 67
  if (step == 0U) {
    {
#line 68
    tmp___2 = gettext("Unknown bus width!\n");
#line 68
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 69
    return;
  }
  {
#line 72
  addr &= ~ (step - 1U);
#line 73
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 75
  tmp___3 = gettext("address: 0x%08X\n");
#line 75
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 76
  tmp___4 = gettext("length:  0x%08X\n");
#line 76
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 78
  if (len == 0U) {
    {
#line 79
    tmp___5 = gettext("length is 0.\n");
#line 79
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 80
    return;
  }
  {
#line 83
  a = addr;
#line 84
  end = (uint64_t )(a + len);
#line 85
  tmp___6 = gettext("reading:\n");
#line 85
  printf((char const   */* __restrict  */)tmp___6);
#line 86
  (*((bus___0->driver)->read_start))(bus___0, addr);
#line 87
  a += step;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((uint64_t )a <= end)) {
#line 87
      goto while_break;
    }
#line 91
    if (a < addr + len) {
      {
#line 92
      data = (*((bus___0->driver)->read_next))(bus___0, a);
      }
    } else {
      {
#line 94
      data = (*((bus___0->driver)->read_end))(bus___0);
      }
    }
#line 96
    j = (int )step;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (j > 0)) {
#line 96
        goto while_break___0;
      }
#line 97
      if (big_endian) {
#line 98
        tmp___7 = bc;
#line 98
        bc ++;
#line 98
        b[tmp___7] = (uint8_t )((data >> (j - 1) * 8) & 255U);
      } else {
#line 100
        tmp___8 = bc;
#line 100
        bc ++;
#line 100
        b[tmp___8] = (uint8_t )(data & 255U);
#line 101
        data >>= 8;
      }
#line 96
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    if (bc >= 4096) {
#line 104
      goto _L;
    } else
#line 104
    if ((uint64_t )a >= end) {
      _L: /* CIL Label */ 
      {
#line 105
      tmp___9 = gettext("addr: 0x%08X");
#line 105
      printf((char const   */* __restrict  */)tmp___9, a);
#line 106
      printf((char const   */* __restrict  */)"\r");
#line 107
      fflush(stdout);
#line 108
      fwrite((void const   */* __restrict  */)(b), (size_t )bc, (size_t )1, (FILE */* __restrict  */)f);
#line 109
      bc = 0;
      }
    }
#line 87
    a += step;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp___10 = gettext("\nDone.\n");
#line 113
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 114
  return;
}
}
#line 45 "../include/jtag.h"
int detect_register_size(chain_t *chain___0 ) ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.7/src/discovery.c"
int detect_register_size(chain_t *chain___0 ) 
{ 
  int len ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rpat ;
  int p ;
  int ok ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;
  int i ;
  char const   *s ;
  int tmp___2 ;

  {
#line 49
  len = 1;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (len <= 1024)) {
#line 49
      goto while_break;
    }
    {
#line 51
    ok = 0;
#line 53
    tmp = register_alloc(len);
#line 53
    rz = register_fill(tmp, 0);
#line 54
    rout = register_alloc(8 + len);
#line 55
    tmp___0 = register_alloc(8 + len);
#line 55
    tmp___1 = register_fill(tmp___0, 0);
#line 55
    rpat = register_inc(tmp___1);
#line 57
    p = 1;
    }
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! (p < 1 << 8)) {
#line 57
        goto while_break___0;
      }
      {
#line 60
      ok = 0;
#line 62
      s = register_get_string((tap_register const   *)rpat);
      }
      {
#line 63
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 63
        if (! *s) {
#line 63
          goto while_break___1;
        }
#line 64
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 66
      i = 0;
      {
#line 66
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 66
        if (! (i < 1)) {
#line 66
          goto while_break___2;
        }
        {
#line 67
        tap_shift_register(chain___0, (tap_register const   *)rz, (tap_register *)((void *)0),
                           0);
#line 68
        tap_shift_register(chain___0, (tap_register const   *)rpat, rout, 0);
#line 70
        register_shift_right(rout, len);
#line 72
        tmp___2 = register_compare((tap_register const   *)rpat, (tap_register const   *)rout);
        }
#line 72
        if (tmp___2 == 0) {
#line 73
          ok ++;
        }
#line 66
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 75
      if (100 * ok < 100) {
#line 76
        ok = 0;
#line 77
        goto while_break___0;
      }
      {
#line 80
      register_inc(rpat);
#line 57
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 83
    register_free(rz);
#line 84
    register_free(rout);
#line 85
    register_free(rpat);
    }
#line 87
    if (ok) {
#line 88
      return (len);
    }
#line 49
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return (-1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.7/src/discovery.c"
void jtag_reset(chain_t *chain___0 ) 
{ 


  {
  {
#line 97
  chain_set_trst(chain___0, 0);
#line 98
  chain_set_trst(chain___0, 1);
#line 100
  tap_reset(chain___0);
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.7/src/discovery.c"
void discovery(chain_t *chain___0 ) 
{ 
  int irlen ;
  tap_register *ir___0 ;
  tap_register *irz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;
  char *tmp___3 ;
  int rs ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 111
  jtag_reset(chain___0);
#line 113
  tmp = gettext("Detecting IR length ... ");
#line 113
  printf((char const   */* __restrict  */)tmp);
#line 114
  fflush(stdout);
#line 116
  tap_capture_ir(chain___0);
#line 117
  irlen = detect_register_size(chain___0);
#line 119
  tmp___0 = gettext("%d\n");
#line 119
  printf((char const   */* __restrict  */)tmp___0, irlen);
  }
#line 121
  if (irlen < 1) {
    {
#line 122
    tmp___1 = gettext("Error: Invalid IR length!\n");
#line 122
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 123
    return;
  }
  {
#line 127
  tmp___2 = register_alloc(irlen);
#line 127
  ir___0 = register_fill(tmp___2, 1);
#line 128
  irz = register_duplicate((tap_register const   *)ir___0);
  }
#line 130
  if (! ir___0) {
    {
#line 131
    register_free(ir___0);
#line 132
    register_free(irz);
#line 133
    tmp___3 = gettext("Error: Out of memory!\n");
#line 133
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 134
    return;
  } else
#line 130
  if (! irz) {
    {
#line 131
    register_free(ir___0);
#line 132
    register_free(irz);
#line 133
    tmp___3 = gettext("Error: Out of memory!\n");
#line 133
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 134
    return;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    jtag_reset(chain___0);
#line 142
    tap_capture_ir(chain___0);
#line 143
    tap_shift_register(chain___0, (tap_register const   *)ir___0, (tap_register *)((void *)0),
                       1);
#line 145
    tmp___4 = register_get_string((tap_register const   *)ir___0);
#line 145
    tmp___5 = gettext("Detecting DR length for IR %s ... ");
#line 145
    printf((char const   */* __restrict  */)tmp___5, tmp___4);
#line 146
    fflush(stdout);
#line 148
    tap_capture_dr(chain___0);
#line 149
    rs = detect_register_size(chain___0);
#line 151
    tmp___6 = gettext("%d\n");
#line 151
    printf((char const   */* __restrict  */)tmp___6, rs);
#line 153
    register_inc(ir___0);
#line 154
    tmp___7 = register_compare((tap_register const   *)ir___0, (tap_register const   *)irz);
    }
#line 154
    if (tmp___7 == 0) {
#line 155
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  register_free(ir___0);
#line 158
  register_free(irz);
  }
#line 159
  return;
}
}
#line 564 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 47 "/home/khheo/project/benchmark/urjtag-0.7/src/detect.c"
static int find_record(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 52
  r = 0;
#line 54
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 55
  if (! file) {
    {
#line 56
    tmp = gettext("Cannot open %s\n");
#line 56
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 57
    return (0);
  }
  {
#line 60
  tr = register_alloc(key->len);
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 67
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
      goto while_break;
    }
    {
#line 71
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 72
    if (p) {
#line 73
      *p = (char )'\000';
    }
#line 75
    p = line;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (*p) {
        {
#line 78
        tmp___1 = __ctype_b_loc();
        }
#line 78
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 78
          goto while_break___0;
        }
      } else {
#line 78
        goto while_break___0;
      }
#line 79
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 82
    s = strchr((char const   *)p, '\000');
    }
    {
#line 83
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 83
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 83
        goto while_break___1;
      }
      {
#line 84
      tmp___2 = __ctype_b_loc();
#line 84
      s --;
      }
#line 84
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 85
        goto while_break___1;
      }
#line 86
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 90
    if (! *p) {
#line 91
      goto __Cont;
    }
#line 94
    s = p;
    {
#line 95
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 95
      if (*s) {
        {
#line 95
        tmp___3 = __ctype_b_loc();
        }
#line 95
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 95
          goto while_break___2;
        }
      } else {
#line 95
        goto while_break___2;
      }
#line 96
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 97
    if (*s) {
#line 98
      tmp___4 = s;
#line 98
      s ++;
#line 98
      *tmp___4 = (char )'\000';
    }
    {
#line 101
    tmp___5 = strlen((char const   *)p);
    }
#line 101
    if (tmp___5 != (size_t )key->len) {
#line 102
      goto __Cont;
    }
    {
#line 105
    register_init(tr, (char const   *)p);
#line 106
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 106
    if (tmp___6) {
#line 107
      goto __Cont;
    }
#line 110
    p = s;
    {
#line 113
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 113
      if (*p) {
        {
#line 113
        tmp___7 = __ctype_b_loc();
        }
#line 113
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 113
          goto while_break___3;
        }
      } else {
#line 113
        goto while_break___3;
      }
#line 114
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 117
    if (! *p) {
#line 118
      goto __Cont;
    }
#line 121
    s = p;
    {
#line 122
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 122
      if (*s) {
        {
#line 122
        tmp___8 = __ctype_b_loc();
        }
#line 122
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 122
          goto while_break___4;
        }
      } else {
#line 122
        goto while_break___4;
      }
#line 123
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 124
    if (*s) {
#line 125
      tmp___9 = s;
#line 125
      s ++;
#line 125
      *tmp___9 = (char )'\000';
    }
    {
#line 128
    tmp___10 = strlen((char const   *)p);
    }
#line 128
    if (tmp___10 >= sizeof(idr->name)) {
#line 129
      goto __Cont;
    }
    {
#line 132
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 135
    p = s;
    }
    {
#line 138
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 138
      if (*p) {
        {
#line 138
        tmp___11 = __ctype_b_loc();
        }
#line 138
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 138
          goto while_break___5;
        }
      } else {
#line 138
        goto while_break___5;
      }
#line 139
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 142
    if (! *p) {
#line 143
      goto __Cont;
    }
    {
#line 146
    tmp___12 = strlen((char const   *)p);
    }
#line 146
    if (tmp___12 >= sizeof(idr->fullname)) {
#line 147
      goto __Cont;
    }
    {
#line 150
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 152
    r = 1;
    }
#line 153
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  fclose(file);
#line 158
  register_free(tr);
  }
#line 160
  return (r);
}
}
#line 163 "/home/khheo/project/benchmark/urjtag-0.7/src/detect.c"
uint64_t bits_to_uint64(tap_register *t ) 
{ 
  int i ;
  uint64_t l ;
  uint64_t b ;

  {
#line 168
  l = (uint64_t )0;
#line 168
  b = (uint64_t )1;
#line 169
  i = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < t->len)) {
#line 169
      goto while_break;
    }
#line 170
    if ((int )*(t->data + i) & 1) {
#line 170
      l |= b;
    }
#line 171
    b <<= 1;
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (l);
}
}
#line 177 "/home/khheo/project/benchmark/urjtag-0.7/src/detect.c"
int detect_parts(chain_t *chain___0 , char *db_path ) 
{ 
  int irlen ;
  tap_register *ir___0 ;
  int chlen ;
  tap_register *one ;
  tap_register *ones ;
  tap_register *br ;
  tap_register *id ;
  parts_t *ps ;
  int i ;
  char data_path[1024] ;
  char *cmd[3] ;
  char manufacturer[26] ;
  char partname[21] ;
  char stepping[9] ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  tap_register *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  part_t *part___0 ;
  tap_register *did ;
  tap_register *key ;
  struct id_record idr ;
  char *p ;
  int tmp___7 ;
  uint64_t tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;

  {
  {
#line 191
  cmd[0] = (char *)"script";
#line 191
  cmd[1] = data_path;
#line 191
  cmd[2] = (char *)((void *)0);
#line 197
  tap_reset(chain___0);
#line 198
  tap_capture_ir(chain___0);
#line 199
  irlen = detect_register_size(chain___0);
  }
#line 200
  if (irlen < 1) {
#line 201
    return (0);
  }
  {
#line 203
  tmp = gettext("IR length: %d\n");
#line 203
  printf((char const   */* __restrict  */)tmp, irlen);
#line 206
  tmp___0 = register_alloc(irlen);
#line 206
  ir___0 = register_fill(tmp___0, 1);
  }
#line 207
  if ((unsigned long )ir___0 == (unsigned long )((void *)0)) {
    {
#line 208
    tmp___1 = gettext("out of memory\n");
#line 208
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 209
    return (0);
  }
  {
#line 212
  tap_shift_register(chain___0, (tap_register const   *)ir___0, (tap_register *)((void *)0),
                     1);
#line 213
  register_free(ir___0);
#line 216
  tap_capture_dr(chain___0);
#line 217
  chlen = detect_register_size(chain___0);
  }
#line 218
  if (chlen < 1) {
    {
#line 219
    tmp___2 = gettext("Unable to detect JTAG chain length\n");
#line 219
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 220
    return (0);
  }
  {
#line 222
  tmp___3 = gettext("Chain length: %d\n");
#line 222
  printf((char const   */* __restrict  */)tmp___3, chlen);
#line 225
  tmp___4 = register_alloc(1);
#line 225
  one = register_fill(tmp___4, 1);
#line 226
  tmp___5 = register_alloc(31);
#line 226
  ones = register_fill(tmp___5, 1);
#line 227
  br = register_alloc(1);
#line 228
  id = register_alloc(32);
#line 229
  ps = parts_alloc();
  }
#line 230
  if (! one) {
#line 230
    goto _L;
  } else
#line 230
  if (! ones) {
#line 230
    goto _L;
  } else
#line 230
  if (! br) {
#line 230
    goto _L;
  } else
#line 230
  if (! id) {
#line 230
    goto _L;
  } else
#line 230
  if (! ps) {
    _L: /* CIL Label */ 
    {
#line 231
    tmp___6 = gettext("out of memory\n");
#line 231
    printf((char const   */* __restrict  */)tmp___6);
#line 233
    register_free(one);
#line 234
    register_free(ones);
#line 235
    register_free(br);
#line 236
    register_free(id);
#line 237
    parts_free(ps);
    }
#line 238
    return (0);
  }
  {
#line 240
  chain___0->parts = ps;
#line 241
  chain___0->active_part = 0;
#line 244
  tap_reset(chain___0);
#line 245
  tap_capture_dr(chain___0);
#line 247
  i = 0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < chlen)) {
#line 247
      goto while_break;
    }
    {
#line 249
    did = br;
#line 254
    tap_shift_register(chain___0, (tap_register const   *)one, br, 0);
#line 255
    tmp___7 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 255
    if (tmp___7 == 0) {
      {
#line 257
      tap_shift_register(chain___0, (tap_register const   *)ones, id, 0);
#line 258
      register_shift_left(id, 1);
#line 259
      *(id->data + 0) = (char)1;
#line 260
      did = id;
      }
    }
    {
#line 263
    tmp___8 = bits_to_uint64(did);
#line 263
    tmp___9 = register_get_string((tap_register const   *)did);
#line 263
    tmp___10 = gettext("Device Id: %s (0x%016lX)\n");
#line 263
    printf((char const   */* __restrict  */)tmp___10, tmp___9, tmp___8);
#line 265
    part___0 = part_alloc((tap_register const   *)did);
    }
#line 266
    if ((unsigned long )part___0 == (unsigned long )((void *)0)) {
      {
#line 267
      tmp___11 = gettext("Out of memory\n");
#line 267
      printf((char const   */* __restrict  */)tmp___11);
      }
#line 268
      goto while_break;
    }
    {
#line 270
    parts_add_part(ps, part___0);
    }
#line 272
    if ((unsigned long )did == (unsigned long )br) {
#line 273
      goto __Cont;
    }
    {
#line 277
    strcpy((char */* __restrict  */)(data_path), (char const   */* __restrict  */)db_path);
#line 280
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/MANUFACTURERS");
#line 282
    key = register_alloc(11);
#line 283
    memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 1),
           (size_t )key->len);
#line 284
    tmp___13 = find_record(data_path, key, & idr);
    }
#line 284
    if (! tmp___13) {
      {
#line 285
      tmp___12 = gettext("  Unknown manufacturer!\n");
#line 285
      printf((char const   */* __restrict  */)tmp___12);
#line 286
      register_free(key);
      }
#line 287
      goto __Cont;
    }
    {
#line 289
    register_free(key);
#line 291
    tmp___14 = gettext("  Manufacturer: %s\n");
#line 291
    printf((char const   */* __restrict  */)tmp___14, idr.fullname);
#line 292
    tmp___16 = strlen((char const   *)(idr.fullname));
    }
#line 292
    if (tmp___16 > 25UL) {
      {
#line 293
      tmp___15 = gettext("Warning: Manufacturer too long\n");
#line 293
      printf((char const   */* __restrict  */)tmp___15);
      }
    }
    {
#line 294
    strncpy((char */* __restrict  */)(manufacturer), (char const   */* __restrict  */)(idr.fullname),
            (size_t )25);
#line 295
    manufacturer[25] = (char )'\000';
#line 298
    p = strrchr((char const   *)(data_path), '/');
    }
#line 299
    if (p) {
#line 300
      *(p + 1) = (char )'\000';
    } else {
#line 302
      data_path[0] = (char )'\000';
    }
    {
#line 303
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 304
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/PARTS");
#line 306
    key = register_alloc(16);
#line 307
    memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 12),
           (size_t )key->len);
#line 308
    tmp___18 = find_record(data_path, key, & idr);
    }
#line 308
    if (! tmp___18) {
      {
#line 309
      tmp___17 = gettext("  Unknown part!\n");
#line 309
      printf((char const   */* __restrict  */)tmp___17);
#line 310
      register_free(key);
      }
#line 311
      goto __Cont;
    }
    {
#line 313
    register_free(key);
#line 315
    tmp___19 = gettext("  Part(%d):         %s\n");
#line 315
    printf((char const   */* __restrict  */)tmp___19, chain___0->active_part, idr.fullname);
#line 316
    tmp___21 = strlen((char const   *)(idr.fullname));
    }
#line 316
    if (tmp___21 > 20UL) {
      {
#line 317
      tmp___20 = gettext("Warning: Part too long\n");
#line 317
      printf((char const   */* __restrict  */)tmp___20);
      }
    }
    {
#line 318
    strncpy((char */* __restrict  */)(partname), (char const   */* __restrict  */)(idr.fullname),
            (size_t )20);
#line 319
    partname[20] = (char )'\000';
#line 322
    p = strrchr((char const   *)(data_path), '/');
    }
#line 323
    if (p) {
#line 324
      *(p + 1) = (char )'\000';
    } else {
#line 326
      data_path[0] = (char )'\000';
    }
    {
#line 327
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 328
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/STEPPINGS");
#line 330
    key = register_alloc(4);
#line 331
    memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 28),
           (size_t )key->len);
#line 332
    tmp___23 = find_record(data_path, key, & idr);
    }
#line 332
    if (! tmp___23) {
      {
#line 333
      tmp___22 = gettext("  Unknown stepping!\n");
#line 333
      printf((char const   */* __restrict  */)tmp___22);
#line 334
      register_free(key);
      }
#line 335
      goto __Cont;
    }
    {
#line 337
    register_free(key);
#line 339
    tmp___24 = gettext("  Stepping:     %s\n");
#line 339
    printf((char const   */* __restrict  */)tmp___24, idr.fullname);
#line 340
    tmp___26 = strlen((char const   *)(idr.fullname));
    }
#line 340
    if (tmp___26 > 8UL) {
      {
#line 341
      tmp___25 = gettext("Warning: Stepping too long\n");
#line 341
      printf((char const   */* __restrict  */)tmp___25);
      }
    }
    {
#line 342
    strncpy((char */* __restrict  */)(stepping), (char const   */* __restrict  */)(idr.fullname),
            (size_t )8);
#line 343
    stepping[8] = (char )'\000';
#line 346
    p = strrchr((char const   *)(data_path), '/');
    }
#line 347
    if (p) {
#line 348
      *(p + 1) = (char )'\000';
    } else {
#line 350
      data_path[0] = (char )'\000';
    }
    {
#line 351
    strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 353
    tmp___27 = gettext("  Filename:     %s\n");
#line 353
    printf((char const   */* __restrict  */)tmp___27, data_path);
#line 356
    chain___0->active_part = ps->len - 1;
#line 357
    strcpy((char */* __restrict  */)(part___0->manufacturer), (char const   */* __restrict  */)(manufacturer));
#line 358
    strcpy((char */* __restrict  */)(part___0->part), (char const   */* __restrict  */)(partname));
#line 359
    strcpy((char */* __restrict  */)(part___0->stepping), (char const   */* __restrict  */)(stepping));
#line 360
    cmd_run(cmd);
    }
#line 361
    if ((unsigned long )part___0->active_instruction == (unsigned long )((void *)0)) {
      {
#line 362
      part___0->active_instruction = part_find_instruction(part___0, "IDCODE");
      }
    }
    __Cont: /* CIL Label */ 
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  i = 0;
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (i < 32)) {
#line 365
      goto while_break___0;
    }
    {
#line 366
    tap_shift_register(chain___0, (tap_register const   *)one, br, 0);
#line 367
    tmp___29 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 367
    if (tmp___29 != 0) {
      {
#line 368
      tmp___28 = gettext("Error: Unable to detect JTAG chain end!\n");
#line 368
      printf((char const   */* __restrict  */)tmp___28);
      }
#line 369
      goto while_break___0;
    }
#line 365
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 372
  tap_shift_register(chain___0, (tap_register const   *)one, (tap_register *)((void *)0),
                     1);
#line 374
  register_free(one);
#line 375
  register_free(ones);
#line 376
  register_free(br);
#line 377
  register_free(id);
  }
#line 379
  return (ps->len);
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 616 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 335
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
chain_t *chain  =    (chain_t *)((void *)0);
#line 59 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
int debug_mode  =    0;
#line 60 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
int big_endian  =    0;
#line 63 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static char *get_token(char *buf ) 
{ 
  char *t ;
  char *tmp ;

  {
  {
#line 66
  tmp = strtok((char */* __restrict  */)buf, (char const   */* __restrict  */)" \f\n\r\t\v");
#line 66
  t = tmp;
  }
#line 67
  if (t) {
#line 67
    if ((int )*t == 35) {
#line 68
      return ((char *)((void *)0));
    }
  }
#line 69
  return (t);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static void jtag_create_jtagdir(void) 
{ 
  char *home ;
  char *tmp ;
  char *jdir ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 79
  tmp = getenv("HOME");
#line 79
  home = tmp;
  }
#line 82
  if (! home) {
#line 83
    return;
  }
  {
#line 85
  tmp___0 = strlen((char const   *)home);
#line 85
  tmp___1 = strlen(".jtag");
#line 85
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 85
  jdir = (char *)tmp___2;
  }
#line 86
  if (! jdir) {
#line 87
    return;
  }
  {
#line 89
  strcpy((char */* __restrict  */)jdir, (char const   */* __restrict  */)home);
#line 90
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)"/");
#line 91
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)".jtag");
#line 94
  mkdir((char const   *)jdir, (__mode_t )((((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 96
  free((void *)jdir);
  }
#line 97
  return;
}
}
#line 155 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static int jtag_parse_line(char *line ) 
{ 
  char *t ;
  int l ;
  int n ;
  char **a ;
  int r ;
  size_t tmp ;
  char **newa ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 164
  if (! line) {
#line 165
    return (1);
  } else {
    {
#line 164
    tmp = strlen((char const   *)line);
    }
#line 164
    if (! (tmp > 0UL)) {
#line 165
      return (1);
    }
  }
  {
#line 167
  t = get_token(line);
  }
#line 168
  if (! t) {
#line 169
    return (1);
  }
#line 171
  n = 0;
#line 172
  l = 0;
#line 173
  a = (char **)((void *)0);
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! t) {
#line 174
      goto while_break;
    }
#line 175
    if (n + 2 > l) {
#line 177
      if (l < 16) {
#line 177
        l = 16;
      } else {
#line 177
        l *= 2;
      }
      {
#line 178
      tmp___0 = realloc((void *)a, (unsigned long )l * sizeof(char *));
#line 178
      newa = (char **)tmp___0;
      }
#line 179
      if (! newa) {
        {
#line 180
        free((void *)a);
#line 181
        tmp___1 = gettext("Out of memory\n");
#line 181
        printf((char const   */* __restrict  */)tmp___1);
        }
#line 182
        return (1);
      }
#line 184
      a = newa;
    }
    {
#line 186
    tmp___2 = n;
#line 186
    n ++;
#line 186
    *(a + tmp___2) = t;
#line 187
    *(a + n) = (char *)((void *)0);
#line 189
    t = get_token((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  r = cmd_run(a);
  }
#line 193
  if (debug_mode & 1) {
    {
#line 193
    printf((char const   */* __restrict  */)"Return in jtag_parse_line r=%d\n", r);
    }
  }
  {
#line 194
  free((void *)a);
  }
#line 195
  return (r);
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static int jtag_readline_multiple_commands_support(char *line ) 
{ 
  int r ;
  char *nextcmd ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 202
  nextcmd = line;
#line 204
  if (! line) {
#line 205
    return (1);
  } else {
    {
#line 204
    tmp = strlen((char const   *)line);
    }
#line 204
    if (! (tmp > 0UL)) {
#line 205
      return (1);
    }
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 208
    line = nextcmd;
#line 210
    nextcmd = strstr((char const   *)nextcmd, "::");
    }
#line 212
    if (nextcmd) {
#line 213
      tmp___0 = nextcmd;
#line 213
      nextcmd ++;
#line 213
      *tmp___0 = (char)0;
#line 214
      nextcmd ++;
      {
#line 215
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 215
        if (! ((int )*line == 58)) {
#line 215
          goto while_break___0;
        }
#line 215
        line ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 218
    r = jtag_parse_line(line);
    }
#line 207
    if (nextcmd) {
#line 207
      if (! r) {
#line 207
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (r);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static void jtag_readline_loop(char const   *prompt ) 
{ 
  char line[1024] ;
  char *tmp ;

  {
#line 247
  line[0] = (char)0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 250
    printf((char const   */* __restrict  */)"%s", prompt);
#line 251
    fflush(stdout);
#line 252
    jtag_readline_multiple_commands_support(line);
#line 248
    tmp = fgets((char */* __restrict  */)(line), 1023, (FILE */* __restrict  */)stdin);
    }
#line 248
    if (! tmp) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 258 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static int jtag_parse_stream(FILE *f ) 
{ 
  int go ;
  char *line ;
  size_t n ;
  size_t tmp ;
  __ssize_t tmp___0 ;

  {
#line 261
  go = 1;
#line 262
  line = (char *)((void *)0);
#line 263
  n = (size_t )0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (go) {
      {
#line 265
      tmp___0 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& n),
                        (FILE */* __restrict  */)f);
      }
#line 265
      if (! (tmp___0 != -1L)) {
#line 265
        goto while_break;
      }
    } else {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp = strlen((char const   *)line);
    }
#line 266
    if (tmp > 0UL) {
#line 266
      if ((int )*(line + 0) != 35) {
        {
#line 267
        go = jtag_parse_line(line);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  free((void *)line);
  }
#line 271
  return (go);
}
}
#line 274 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
int jtag_parse_file(char const   *filename ) 
{ 
  FILE *f ;
  int go ;

  {
  {
#line 280
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 281
  if (! f) {
#line 282
    return (-1);
  }
  {
#line 284
  go = jtag_parse_stream(f);
#line 286
  fclose(f);
  }
#line 287
  if (debug_mode & 1) {
    {
#line 287
    printf((char const   */* __restrict  */)"File Closed gp=%d\n", go);
    }
  }
#line 288
  return (go);
}
}
#line 291 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static int jtag_parse_rc(void) 
{ 
  char *home ;
  char *tmp ;
  char *file ;
  int go ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 294
  tmp = getenv("HOME");
#line 294
  home = tmp;
  }
#line 298
  if (! home) {
#line 299
    return (1);
  }
  {
#line 301
  tmp___0 = strlen((char const   *)home);
#line 301
  tmp___1 = strlen(".jtag");
#line 301
  tmp___2 = strlen("rc");
#line 301
  tmp___3 = malloc(((tmp___0 + tmp___1) + tmp___2) + 3UL);
#line 301
  file = (char *)tmp___3;
  }
#line 302
  if (! file) {
#line 303
    return (1);
  }
  {
#line 305
  strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)home);
#line 306
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 307
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)".jtag");
#line 308
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 309
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"rc");
#line 311
  go = jtag_parse_file((char const   *)file);
#line 313
  free((void *)file);
  }
#line 315
  return (go);
}
}
#line 318 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static void cleanup(void) 
{ 


  {
  {
#line 321
  cfi_array_free(cfi_array);
#line 322
  cfi_array = (cfi_array_t *)((void *)0);
  }
#line 324
  if (bus) {
    {
#line 325
    (*((bus->driver)->free_bus))(bus);
#line 326
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 328
  chain_free(chain);
#line 329
  chain = (chain_t *)((void *)0);
  }
#line 330
  return;
}
}
#line 357
int main(int argc , char * const  *argv ) ;
#line 357 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
static struct option long_options[4]  = {      {"version", 0, (int *)0, 'v'}, 
        {"norc", 0, (int *)0, 'n'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 332 "/home/khheo/project/benchmark/urjtag-0.7/src/jtag.c"
int main(int argc , char * const  *argv ) 
{ 
  int go ;
  int i ;
  int c ;
  int norc ;
  int help ;
  int version ;
  char *tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int option_index ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 335
  go = 0;
#line 338
  norc = 0;
#line 339
  help = 0;
#line 340
  version = 0;
#line 342
  tmp___0 = geteuid();
  }
#line 342
  if (tmp___0 == 0U) {
    {
#line 342
    tmp___1 = getuid();
    }
#line 342
    if (tmp___1 != 0U) {
      {
#line 344
      tmp = gettext("\'%s\' must not be run suid root!\n");
#line 344
      printf((char const   */* __restrict  */)tmp, "jtag");
      }
#line 345
      return (-1);
    }
  }
  {
#line 350
  setlocale(6, "");
#line 351
  bindtextdomain("urjtag", "/usr/local/share/locale");
#line 352
  textdomain("urjtag");
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 366
    option_index = 0;
#line 368
    c = getopt_long(argc, argv, "vnh", (struct option  const  *)(long_options), & option_index);
    }
#line 372
    if (c == -1) {
#line 373
      goto while_break;
    }
    {
#line 377
    if (c == 118) {
#line 377
      goto case_118;
    }
#line 381
    if (c == 110) {
#line 381
      goto case_110;
    }
#line 386
    goto switch_default;
    case_118: /* CIL Label */ 
#line 378
    version = 1;
#line 379
    goto switch_break;
    case_110: /* CIL Label */ 
#line 382
    norc = 1;
#line 383
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 387
    help = 1;
#line 388
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  if (help) {
    {
#line 395
    tmp___2 = gettext("%s #%s\n");
#line 395
    printf((char const   */* __restrict  */)tmp___2, "UrJTAG 0.7", "886");
#line 396
    printf((char const   */* __restrict  */)"\n");
#line 398
    tmp___3 = gettext("Usage: %s [OPTION] [FILE]\n");
#line 398
    printf((char const   */* __restrict  */)tmp___3, "jtag");
#line 399
    printf((char const   */* __restrict  */)"\n");
#line 401
    tmp___4 = gettext("  -h, --help          display this help and exit\n");
#line 401
    printf((char const   */* __restrict  */)tmp___4);
#line 402
    tmp___5 = gettext("  -v, --version       display version information and exit\n");
#line 402
    printf((char const   */* __restrict  */)tmp___5);
#line 403
    printf((char const   */* __restrict  */)"\n");
#line 405
    tmp___6 = gettext("  -n, --norc          disable reading ~/.jtag/rc on startup\n");
#line 405
    printf((char const   */* __restrict  */)tmp___6);
#line 406
    printf((char const   */* __restrict  */)"\n");
#line 408
    tmp___7 = gettext("  [FILE]              file containing commands to execute\n");
#line 408
    printf((char const   */* __restrict  */)tmp___7);
#line 409
    printf((char const   */* __restrict  */)"\n");
#line 411
    tmp___8 = gettext("  Please report bugs at http://www.urjtag.org\n");
#line 411
    printf((char const   */* __restrict  */)tmp___8);
#line 413
    exit(0);
    }
  }
#line 416
  if (version) {
    {
#line 418
    tmp___9 = gettext("\n%s #%s\n\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n");
#line 418
    printf((char const   */* __restrict  */)tmp___9, "UrJTAG 0.7", "886");
#line 423
    tmp___10 = gettext("\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n");
#line 423
    printf((char const   */* __restrict  */)tmp___10);
#line 438
    exit(0);
    }
  }
#line 443
  if (argc > optind) {
#line 444
    i = optind;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (i < argc)) {
#line 444
        goto while_break___0;
      }
      {
#line 445
      chain = chain_alloc();
      }
#line 446
      if (! chain) {
        {
#line 447
        tmp___11 = gettext("Out of memory\n");
#line 447
        printf((char const   */* __restrict  */)tmp___11);
        }
#line 448
        return (-1);
      }
      {
#line 451
      go = jtag_parse_file((char const   *)*(argv + i));
#line 452
      cleanup();
      }
#line 453
      if (go < 0) {
        {
#line 454
        tmp___12 = gettext("Unable to open file `%s\'!\n");
#line 454
        printf((char const   */* __restrict  */)tmp___12, *(argv + i));
        }
#line 455
        goto while_break___0;
      }
#line 444
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    return (0);
  }
  {
#line 462
  tmp___14 = isatty(0);
  }
#line 462
  if (! tmp___14) {
    {
#line 463
    chain = chain_alloc();
    }
#line 464
    if (! chain) {
      {
#line 465
      tmp___13 = gettext("Out of memory\n");
#line 465
      printf((char const   */* __restrict  */)tmp___13);
      }
#line 466
      return (-1);
    }
    {
#line 469
    jtag_parse_stream(stdin);
#line 471
    cleanup();
    }
#line 473
    return (0);
  }
  {
#line 477
  tmp___15 = gettext("\n%s #%s\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n\n%s is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nThere is absolutely no warranty for %s.\n\n");
#line 477
  printf((char const   */* __restrict  */)tmp___15, "UrJTAG 0.7", "886", "UrJTAG",
         "UrJTAG");
#line 487
  chain = chain_alloc();
  }
#line 488
  if (! chain) {
    {
#line 489
    tmp___16 = gettext("Out of memory\n");
#line 489
    printf((char const   */* __restrict  */)tmp___16);
    }
#line 490
    return (-1);
  }
  {
#line 493
  tmp___17 = gettext("WARNING: %s may damage your hardware!\n");
#line 493
  printf((char const   */* __restrict  */)tmp___17, "UrJTAG");
#line 494
  tmp___18 = gettext("Type \"quit\" to exit, \"help\" for help.\n\n");
#line 494
  printf((char const   */* __restrict  */)tmp___18);
#line 497
  jtag_create_jtagdir();
  }
#line 500
  if (! norc) {
    {
#line 500
    go = jtag_parse_rc();
    }
  }
#line 502
  if (go) {
    {
#line 510
    jtag_readline_loop("jtag> ");
    }
  }
  {
#line 518
  cleanup();
  }
#line 520
  return (0);
}
}
