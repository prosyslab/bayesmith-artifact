/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_538434829 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_538434829 __mbstate_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 161 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 173 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 109 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.h"
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/isnan.c"
union __anonunion_memory_double_618071262 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/isnan.c"
typedef union __anonunion_memory_double_618071262 memory_double;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
union __anonunion_id_984444735 {
   uid_t u ;
   gid_t g ;
};
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
struct userid {
   union __anonunion_id_984444735 id ;
   struct userid *next ;
   char name[] ;
};
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.h"
typedef struct I_ring I_ring;
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 26 "./xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "./xstrtol.h"
typedef enum strtol_error strtol_error;
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.h"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 54
struct hash_table ;
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.h"
typedef struct hash_table Hash_table;
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 9 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.h"
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 223 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 246 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/xtime.h"
typedef long long xtime_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 120 "getdate.y"
struct __anonstruct_textint_824309684 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 120 "getdate.y"
typedef struct __anonstruct_textint_824309684 textint;
#line 128 "getdate.y"
struct __anonstruct_table_528220008 {
   char const   *name ;
   int type ;
   int value ;
};
#line 128 "getdate.y"
typedef struct __anonstruct_table_528220008 table;
#line 141 "getdate.y"
struct __anonstruct_relative_time_124712104 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long seconds ;
   long ns ;
};
#line 141 "getdate.y"
typedef struct __anonstruct_relative_time_124712104 relative_time;
#line 160 "getdate.y"
struct __anonstruct_parser_control_427311395 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 160 "getdate.y"
typedef struct __anonstruct_parser_control_427311395 parser_control;
#line 205
union YYSTYPE ;
#line 423 "getdate.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 423 "getdate.c"
typedef union YYSTYPE YYSTYPE;
#line 458 "getdate.c"
typedef unsigned char yytype_uint8;
#line 465 "getdate.c"
typedef signed char yytype_int8;
#line 479 "getdate.c"
typedef short yytype_int16;
#line 610 "getdate.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
struct _ftsent ;
#line 68
struct cycle_check_state ;
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
struct __anonstruct_FTS_453244812 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
typedef struct __anonstruct_FTS_453244812 FTS;
#line 185 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 185 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 7 "/home/khheo/project/benchmark/coreutils-7.1/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 725 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/fsusage.h"
struct fs_usage {
   uintmax_t fsu_blocksize ;
   uintmax_t fsu_blocks ;
   uintmax_t fsu_bfree ;
   uintmax_t fsu_bavail ;
   _Bool fsu_bavail_top_bit_set ;
   uintmax_t fsu_files ;
   uintmax_t fsu_ffree ;
};
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.h"
struct exclude ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
struct exclude {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.h"
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.h"
typedef enum canonicalize_mode_t canonicalize_mode_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.h"
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 153 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.h"
struct argv_iterator ;
#line 21
enum argv_iter_err ;
#line 30
enum argv_iter_err {
    AI_ERR_OK = 1,
    AI_ERR_EOF = 2,
    AI_ERR_MEM = 3,
    AI_ERR_READ = 4
} ;
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
struct argv_iterator {
   FILE *fp ;
   size_t item_idx ;
   char *tok ;
   size_t buf_len ;
   char **arg_list ;
   char **p ;
};
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7
} ;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 24 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
enum __anonenum_arg_type_817662448 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
typedef enum __anonenum_arg_type_817662448 arg_type;
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
union __anonunion_a_145370145 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
struct __anonstruct_argument_11373919 {
   arg_type type ;
   union __anonunion_a_145370145 a ;
};
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
typedef struct __anonstruct_argument_11373919 argument;
#line 138 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
struct __anonstruct_arguments_777806161 {
   size_t count ;
   argument *arg ;
};
#line 138 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
typedef struct __anonstruct_arguments_777806161 arguments;
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.h"
struct __anonstruct_char_directive_658480644 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.h"
typedef struct __anonstruct_char_directive_658480644 char_directive;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.h"
struct __anonstruct_char_directives_143329776 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.h"
typedef struct __anonstruct_char_directives_143329776 char_directives;
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/fpucw.h"
typedef unsigned short fpucw_t;
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 100 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 195 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.h"
typedef uintmax_t randint;
#line 33
struct randint_source ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
struct numname {
   int num ;
   char const   name[8] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/u64.h"
typedef uint64_t u64;
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.h"
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
#line 371 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
struct __anonstruct_972123420 {
   char c ;
   u64 x ;
};
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.h"
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t total[2] ;
   size_t buflen ;
   uint32_t buffer[32] ;
};
#line 363 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
struct __anonstruct_833865290 {
   char c ;
   uint32_t x ;
};
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.h"
struct sha1_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t E ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 239 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
struct __anonstruct_833865290___0 {
   char c ;
   uint32_t x ;
};
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.h"
enum __anonenum_state_467303978 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.h"
union __anonunion_val_408517849 {
   int fd ;
   int errnum ;
   pid_t child ;
};
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.h"
struct savewd {
   enum __anonenum_state_467303978 state ;
   union __anonunion_val_408517849 val ;
};
#line 56 "./regex.h"
typedef ssize_t regoff_t;
#line 61 "./regex.h"
typedef size_t __re_idx_t;
#line 64 "./regex.h"
typedef size_t __re_size_t;
#line 68 "./regex.h"
typedef size_t __re_long_size_t;
#line 94 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 372
enum __anonenum_reg_errcode_t_721730718 {
    _REG_ENOSYS = -1,
    _REG_NOERROR = 0,
    _REG_NOMATCH = 1,
    _REG_BADPAT = 2,
    _REG_ECOLLATE = 3,
    _REG_ECTYPE = 4,
    _REG_EESCAPE = 5,
    _REG_ESUBREG = 6,
    _REG_EBRACK = 7,
    _REG_EPAREN = 8,
    _REG_EBRACE = 9,
    _REG_BADBR = 10,
    _REG_ERANGE = 11,
    _REG_ESPACE = 12,
    _REG_BADRPT = 13,
    _REG_EEND = 14,
    _REG_ESIZE = 15,
    _REG_ERPAREN = 16
} ;
#line 372 "./regex.h"
typedef enum __anonenum_reg_errcode_t_721730718 reg_errcode_t;
#line 450 "./regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 518 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 522 "./regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 541 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 541 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
typedef unsigned long wctype_t;
#line 130 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef __re_idx_t Idx;
#line 153 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef __re_size_t re_hashval_t;
#line 157 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef unsigned long bitset_word_t;
#line 194 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef bitset_word_t bitset_t[4];
#line 195 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef bitset_word_t *re_bitset_ptr_t;
#line 196 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef bitset_word_t const   *re_const_bitset_ptr_t;
#line 209
enum __anonenum_re_context_type_961346151 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
#line 209 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef enum __anonenum_re_context_type_961346151 re_context_type;
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_node_set_397540522 {
   Idx alloc ;
   Idx nelem ;
   Idx *elems ;
};
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_node_set_397540522 re_node_set;
#line 230
enum __anonenum_re_token_type_t_412351811 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    COMPLEX_BRACKET = 6,
    OP_UTF8_PERIOD = 7,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
#line 230 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef enum __anonenum_re_token_type_t_412351811 re_token_type_t;
#line 282 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_charset_t_533161772 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   Idx nmbchars ;
   Idx ncoll_syms ;
   Idx nequiv_classes ;
   Idx nranges ;
   Idx nchar_classes ;
};
#line 282 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_charset_t_533161772 re_charset_t;
#line 329 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
union __anonunion_opr_701081363 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   Idx idx ;
   re_context_type ctx_type ;
};
#line 329 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_token_t_822067178 {
   union __anonunion_opr_701081363 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int mb_partial : 1 ;
   unsigned int word_char : 1 ;
};
#line 329 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_token_t_822067178 re_token_t;
#line 360 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   wint_t *wcs ;
   Idx *offsets ;
   mbstate_t cur_state ;
   Idx raw_mbs_idx ;
   Idx valid_len ;
   Idx valid_raw_len ;
   Idx bufs_len ;
   Idx cur_idx ;
   Idx raw_len ;
   Idx len ;
   Idx raw_stop ;
   Idx stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
#line 415 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct re_string_t re_string_t;
#line 418
struct re_dfa_t ;
#line 419 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 482 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   Idx node_idx ;
};
#line 496 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 501 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024UL - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
#line 506 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct bin_tree_storage_t bin_tree_storage_t;
#line 536 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_dfastate_t {
   re_hashval_t hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 554 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 556 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_state_table_entry {
   Idx num ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 565 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_state_array_t_793059239 {
   Idx next_idx ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 565 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_state_array_t_793059239 state_array_t;
#line 574 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_sub_match_last_t_590766955 {
   Idx node ;
   Idx str_idx ;
   state_array_t path ;
};
#line 574 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_590766955 re_sub_match_last_t;
#line 585 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_sub_match_top_t_1066558227 {
   Idx str_idx ;
   Idx node ;
   state_array_t *path ;
   Idx alasts ;
   Idx nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 585 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_1066558227 re_sub_match_top_t;
#line 595 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_backref_cache_entry {
   Idx node ;
   Idx str_idx ;
   Idx subexp_from ;
   Idx subexp_to ;
   char more ;
   char unused ;
   unsigned short eps_reachable_subexps_map ;
};
#line 606 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_match_context_t_201234058 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   Idx match_last ;
   Idx last_node ;
   re_dfastate_t **state_log ;
   Idx state_log_top ;
   Idx nbkref_ents ;
   Idx abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   Idx nsub_tops ;
   Idx asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 606 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_match_context_t_201234058 re_match_context_t;
#line 633 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_re_sift_context_t_945197081 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   Idx last_node ;
   Idx last_str_idx ;
   re_node_set limits ;
};
#line 633 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_945197081 re_sift_context_t;
#line 642 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_fail_stack_ent_t {
   Idx idx ;
   Idx node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 650 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_fail_stack_t {
   Idx num ;
   Idx alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 657 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   Idx *nexts ;
   Idx *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   re_hashval_t state_hash_mask ;
   Idx init_node ;
   Idx nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   Idx *subexp_map ;
};
#line 713
enum __anonenum_bracket_elem_type_1002392186 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 713 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef enum __anonenum_bracket_elem_type_1002392186 bracket_elem_type;
#line 722 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
union __anonunion_opr_675232149 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 722 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
struct __anonstruct_bracket_elem_t_90807258 {
   bracket_elem_type type ;
   union __anonunion_opr_675232149 opr ;
};
#line 722 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_90807258 bracket_elem_t;
#line 3365 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_415302911 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_415302911 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 144 "/home/khheo/project/benchmark/coreutils-7.1/lib/readutmp.h"
typedef struct utmpx STRUCT_UTMP;
#line 823 "/usr/include/stdio.h"
struct obstack ;
#line 142 "/home/khheo/project/benchmark/coreutils-7.1/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/home/khheo/project/benchmark/coreutils-7.1/lib/obstack.h"
union __anonunion_temp_267926141 {
   long tempint ;
   void *tempptr ;
};
#line 149 "/home/khheo/project/benchmark/coreutils-7.1/lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_267926141 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.h"
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.h"
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.h"
typedef struct tokenbuffer token_buffer;
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.h"
struct randread_source ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.h"
struct isaac_state {
   uint32_t mm[1 << 8] ;
   uint32_t iv[8] ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
};
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
union __anonunion_data_453857088 {
   uint32_t w[1 << 8] ;
   unsigned char b[(unsigned long )(1 << 8) * sizeof(uint32_t )] ;
};
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_453857088 data ;
};
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
union __anonunion_buf_444358637 {
   char c[2UL * ((unsigned long )(1 << 8) * sizeof(uint32_t ))] ;
   struct isaac isaac ;
};
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
struct randread_source {
   FILE *source ;
   void (*handler)(void const   * ) ;
   void const   *handler_arg ;
   union __anonunion_buf_444358637 buf ;
};
#line 249 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
struct __anonstruct_833865290___1 {
   char c ;
   uint32_t x ;
};
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
#line 192 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
struct quoting_options ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
};
#line 625 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/mountlist.h"
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
#line 51 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.h"
struct mode_change ;
#line 98 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/memchr2.c"
typedef unsigned long longword;
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 252 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
struct __anonstruct_833865290___2 {
   char c ;
   uint32_t x ;
};
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.c"
union __anonunion_tmp_771759453___0 {
   unsigned int align ;
   char buf[4096] ;
};
#line 371 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
struct __anonstruct_972123420___0 {
   char c ;
   u64 x ;
};
#line 363 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
struct __anonstruct_833865290___3 {
   char c ;
   uint32_t x ;
};
#line 239 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
struct __anonstruct_833865290___4 {
   char c ;
   uint32_t x ;
};
#line 249 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
struct __anonstruct_833865290___5 {
   char c ;
   uint32_t x ;
};
#line 252 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
struct __anonstruct_833865290___6 {
   char c ;
   uint32_t x ;
};
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.h"
enum argv_iter_err ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_997013311 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_869131175 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_997013311 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_604693741 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_869131175 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_941642424 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_604693741 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_941642424 siginfo_t;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 133 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
enum blanktype {
    bl_start = 0,
    bl_end = 1,
    bl_both = 2
} ;
#line 139 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct line {
   char *text ;
   size_t length ;
   char *keybeg ;
   char *keylim ;
};
#line 148 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct buffer {
   char *buf ;
   size_t used ;
   size_t nlines ;
   size_t alloc ;
   size_t left ;
   size_t line_bytes ;
   _Bool eof ;
};
#line 163 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct keyfield {
   size_t sword ;
   size_t schar ;
   size_t eword ;
   size_t echar ;
   _Bool const   *ignore ;
   char const   *translate ;
   _Bool skipsblanks ;
   _Bool skipeblanks ;
   _Bool numeric ;
   _Bool random ;
   _Bool general_numeric ;
   _Bool month ;
   _Bool reverse ;
   _Bool version ;
   struct keyfield *next ;
};
#line 185 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct month {
   char const   *name ;
   int val ;
};
#line 505 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct cs_status {
   _Bool valid ;
   sigset_t sigs ;
};
#line 532 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct tempnode {
   struct tempnode * volatile  next ;
   pid_t pid ;
   char name[1] ;
};
#line 541 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct sortfile {
   char const   *name ;
   pid_t pid ;
};
#line 555
enum procstate {
    ALIVE = 0,
    ZOMBIE = 1
} ;
#line 561 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
struct procnode {
   pid_t pid ;
   enum procstate state ;
   size_t count ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 63
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 390
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 440 "./string.h"
size_t mbslen(char const   *string ) ;
#line 472
char *mbsstr(char const   *haystack , char const   *needle ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 588
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 68
void freea(void *p ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 259 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbchar.h"
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 262
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 264
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 265
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 268
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 269
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 270
  tmp = (_Bool )old_mbc->wc_valid;
#line 270
  new_mbc->wc_valid = tmp;
#line 270
  if (tmp) {
#line 271
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 272
  return;
}
}
#line 305
unsigned int const   is_basic_table[8] ;
#line 307 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 


  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 123 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___8) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp___2) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h",
                    142U, "mbuiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    tmp___3 = __ctype_get_mb_cur_max();
#line 145
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 145
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___4, (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 148
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 151
      iter->cur.bytes = (size_t )1;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 166
      if (iter->cur.bytes == 0UL) {
#line 169
        iter->cur.bytes = (size_t )1;
#line 170
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 170
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h",
                        170U, "mbuiter_multi_next");
          }
        }
#line 171
        if (! (iter->cur.wc == 0)) {
          {
#line 171
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbuiter.h",
                        171U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 177
      if (tmp___7) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/str-kmp.h"
static _Bool knuth_morris_pratt_unibyte(char const   *haystack , char const   *needle ,
                                        char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  size_t *table ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  char const   *rhaystack ;
  char const   *phaystack ;

  {
  {
#line 35
  tmp = strlen(needle);
#line 35
  m = tmp;
  }
#line 38
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 38
    tmp___5 = -1;
  } else {
#line 38
    tmp___5 = -2;
  }
#line 38
  if (m > (size_t )tmp___5 / sizeof(size_t )) {
#line 38
    tmp___4 = (void *)0;
  } else {
#line 38
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 38
      tmp___1 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 38
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 38
      tmp___2 = mmalloca(m * sizeof(size_t ));
#line 38
      tmp___3 = tmp___2;
      }
    }
#line 38
    tmp___4 = tmp___3;
  }
#line 38
  table = (size_t *)tmp___4;
#line 39
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 40
    return ((_Bool)0);
  }
#line 60
  *(table + 1) = (size_t )1;
#line 61
  j = (size_t )0;
#line 63
  i = (size_t )2;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < m)) {
#line 63
      goto while_break;
    }
#line 69
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if ((int )b == (int )((unsigned char )*(needle + j))) {
#line 79
        j ++;
#line 79
        *(table + i) = i - j;
#line 80
        goto while_break___0;
      }
#line 85
      if (j == 0UL) {
#line 88
        *(table + i) = i;
#line 89
        goto while_break___0;
      }
#line 102
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  *resultp = (char const   *)((void *)0);
#line 115
  j___0 = (size_t )0;
#line 116
  rhaystack = haystack;
#line 117
  phaystack = haystack;
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    if (! ((int const   )*phaystack != 0)) {
#line 119
      goto while_break___1;
    }
#line 120
    if ((int )((unsigned char )*(needle + j___0)) == (int )((unsigned char )*phaystack)) {
#line 123
      j___0 ++;
#line 124
      phaystack ++;
#line 125
      if (j___0 == m) {
#line 128
        *resultp = rhaystack;
#line 129
        goto while_break___1;
      }
    } else
#line 132
    if (j___0 > 0UL) {
#line 135
      rhaystack += *(table + j___0);
#line 136
      j___0 -= *(table + j___0);
    } else {
#line 141
      rhaystack ++;
#line 142
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 146
  freea((void *)table);
  }
#line 147
  return ((_Bool)1);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 42
  tmp = mbslen(needle);
#line 42
  m = tmp;
  }
#line 47
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 47
    tmp___5 = -1;
  } else {
#line 47
    tmp___5 = -2;
  }
#line 47
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 47
    tmp___4 = (void *)0;
  } else {
#line 47
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 47
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 47
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 47
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 47
      tmp___3 = tmp___2;
      }
    }
#line 47
    tmp___4 = tmp___3;
  }
#line 47
  memory = (char *)tmp___4;
#line 48
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 49
    return ((_Bool)0);
  }
  {
#line 50
  needle_mbchars = (mbchar_t *)memory;
#line 51
  table = (size_t *)(memory + m * sizeof(mbchar_t ));
#line 58
  j = (size_t )0;
#line 59
  iter.cur.ptr = needle;
#line 59
  iter.in_shift = (_Bool)0;
#line 59
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 59
  iter.next_done = (_Bool)0;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    mbuiter_multi_next(& iter);
    }
#line 59
    if (iter.cur.wc_valid) {
#line 59
      if (iter.cur.wc == 0) {
#line 59
        tmp___6 = 0;
      } else {
#line 59
        tmp___6 = 1;
      }
    } else {
#line 59
      tmp___6 = 1;
    }
#line 59
    if (! tmp___6) {
#line 59
      goto while_break;
    }
    {
#line 60
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 59
    iter.cur.ptr += iter.cur.bytes;
#line 59
    iter.next_done = (_Bool)0;
#line 59
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  *(table + 1) = (size_t )1;
#line 83
  j___0 = (size_t )0;
#line 85
  i = (size_t )2;
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (i < m)) {
#line 85
      goto while_break___0;
    }
#line 91
    b = needle_mbchars + (i - 1UL);
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 98
      if (b->wc_valid) {
#line 98
        if ((needle_mbchars + j___0)->wc_valid) {
#line 98
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 98
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 98
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 98
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 98
          if (tmp___7 == 0) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            tmp___8 = 0;
          }
        } else {
#line 98
          tmp___8 = 0;
        }
#line 98
        tmp___9 = tmp___8;
      }
#line 98
      if (tmp___9) {
#line 101
        j___0 ++;
#line 101
        *(table + i) = i - j___0;
#line 102
        goto while_break___1;
      }
#line 107
      if (j___0 == 0UL) {
#line 110
        *(table + i) = i;
#line 111
        goto while_break___1;
      }
#line 124
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 85
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  *resultp = (char const   *)((void *)0);
#line 137
  j___1 = (size_t )0;
#line 138
  rhaystack.cur.ptr = haystack;
#line 138
  rhaystack.in_shift = (_Bool)0;
#line 138
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 138
  rhaystack.next_done = (_Bool)0;
#line 139
  phaystack.cur.ptr = haystack;
#line 139
  phaystack.in_shift = (_Bool)0;
#line 139
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 139
  phaystack.next_done = (_Bool)0;
  }
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 141
    mbuiter_multi_next(& phaystack);
    }
#line 141
    if (phaystack.cur.wc_valid) {
#line 141
      if (phaystack.cur.wc == 0) {
#line 141
        tmp___15 = 0;
      } else {
#line 141
        tmp___15 = 1;
      }
    } else {
#line 141
      tmp___15 = 1;
    }
#line 141
    if (! tmp___15) {
#line 141
      goto while_break___2;
    }
#line 142
    if ((needle_mbchars + j___1)->wc_valid) {
#line 142
      if (phaystack.cur.wc_valid) {
#line 142
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 142
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 142
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 142
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 142
        if (tmp___12 == 0) {
#line 142
          tmp___13 = 1;
        } else {
#line 142
          tmp___13 = 0;
        }
      } else {
#line 142
        tmp___13 = 0;
      }
#line 142
      tmp___14 = tmp___13;
    }
#line 142
    if (tmp___14) {
#line 144
      j___1 ++;
#line 145
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 145
      phaystack.next_done = (_Bool)0;
#line 146
      if (j___1 == m) {
#line 149
        *resultp = rhaystack.cur.ptr;
#line 150
        goto while_break___2;
      }
    } else
#line 153
    if (j___1 > 0UL) {
#line 156
      count = *(table + j___1);
#line 157
      j___1 -= count;
      {
#line 158
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 158
        if (! (count > 0UL)) {
#line 158
          goto while_break___3;
        }
        {
#line 160
        mbuiter_multi_next(& rhaystack);
        }
#line 160
        if (rhaystack.cur.wc_valid) {
#line 160
          if (rhaystack.cur.wc == 0) {
#line 160
            tmp___10 = 0;
          } else {
#line 160
            tmp___10 = 1;
          }
        } else {
#line 160
          tmp___10 = 1;
        }
#line 160
        if (! tmp___10) {
          {
#line 161
          abort();
          }
        }
#line 162
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 162
        rhaystack.next_done = (_Bool)0;
#line 158
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 168
      mbuiter_multi_next(& rhaystack);
      }
#line 168
      if (rhaystack.cur.wc_valid) {
#line 168
        if (rhaystack.cur.wc == 0) {
#line 168
          tmp___11 = 0;
        } else {
#line 168
          tmp___11 = 1;
        }
      } else {
#line 168
        tmp___11 = 1;
      }
#line 168
      if (! tmp___11) {
        {
#line 169
        abort();
        }
      }
#line 170
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 170
      rhaystack.next_done = (_Bool)0;
#line 171
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 171
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 175
  freea((void *)memory);
  }
#line 176
  return ((_Bool)1);
}
}
#line 181 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbsstr.c"
char *mbsstr(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  char const   *result___0 ;
  _Bool success___0 ;
  _Bool tmp___15 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___16 ;

  {
  {
#line 189
  tmp___16 = __ctype_get_mb_cur_max();
  }
#line 189
  if (tmp___16 > 1UL) {
    {
#line 193
    iter_needle.cur.ptr = needle;
#line 193
    iter_needle.in_shift = (_Bool)0;
#line 193
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 193
    iter_needle.next_done = (_Bool)0;
#line 194
    mbuiter_multi_next(& iter_needle);
    }
#line 194
    if (iter_needle.cur.wc_valid) {
#line 194
      if (iter_needle.cur.wc == 0) {
#line 194
        tmp___12 = 0;
      } else {
#line 194
        tmp___12 = 1;
      }
    } else {
#line 194
      tmp___12 = 1;
    }
#line 194
    if (tmp___12) {
      {
#line 210
      try_kmp = (_Bool)1;
#line 211
      outer_loop_count = (size_t )0;
#line 212
      comparison_count = (size_t )0;
#line 213
      last_ccount = (size_t )0;
#line 218
      iter_needle_last_ccount.cur.ptr = needle;
#line 218
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 218
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 218
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 219
      iter_haystack.cur.ptr = haystack;
#line 219
      iter_haystack.in_shift = (_Bool)0;
#line 219
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 219
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 220
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 222
        mbuiter_multi_next(& iter_haystack);
        }
#line 222
        if (iter_haystack.cur.wc_valid) {
#line 222
          if (iter_haystack.cur.wc == 0) {
#line 222
            tmp = 0;
          } else {
#line 222
            tmp = 1;
          }
        } else {
#line 222
          tmp = 1;
        }
#line 222
        if (! tmp) {
#line 224
          return ((char *)((void *)0));
        }
#line 228
        if (try_kmp) {
#line 228
          if (outer_loop_count >= 10UL) {
#line 228
            if (comparison_count >= 5UL * outer_loop_count) {
#line 234
              count = comparison_count - last_ccount;
              {
#line 235
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 235
                if (count > 0UL) {
                  {
#line 235
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 235
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 235
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 235
                      tmp___0 = 0;
                    } else {
#line 235
                      tmp___0 = 1;
                    }
                  } else {
#line 235
                    tmp___0 = 1;
                  }
#line 235
                  if (! tmp___0) {
#line 235
                    goto while_break___0;
                  }
                } else {
#line 235
                  goto while_break___0;
                }
#line 238
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 238
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 235
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 239
              last_ccount = comparison_count;
#line 240
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 240
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 240
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 240
                  tmp___2 = 0;
                } else {
#line 240
                  tmp___2 = 1;
                }
              } else {
#line 240
                tmp___2 = 1;
              }
#line 240
              if (! tmp___2) {
                {
#line 244
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 244
                success = tmp___1;
                }
#line 247
                if (success) {
#line 248
                  return ((char *)result);
                }
#line 249
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 253
        outer_loop_count ++;
#line 254
        comparison_count ++;
#line 255
        if (iter_haystack.cur.wc_valid) {
#line 255
          if (iter_needle.cur.wc_valid) {
#line 255
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 255
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 255
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 255
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 255
            if (tmp___9 == 0) {
#line 255
              tmp___10 = 1;
            } else {
#line 255
              tmp___10 = 0;
            }
          } else {
#line 255
            tmp___10 = 0;
          }
#line 255
          tmp___11 = tmp___10;
        }
#line 255
        if (tmp___11) {
          {
#line 261
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 262
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 262
          rhaystack.next_done = (_Bool)0;
#line 264
          rneedle.cur.ptr = needle;
#line 264
          rneedle.in_shift = (_Bool)0;
#line 264
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 264
          rneedle.next_done = (_Bool)0;
#line 265
          mbuiter_multi_next(& rneedle);
          }
#line 265
          if (rneedle.cur.wc_valid) {
#line 265
            if (rneedle.cur.wc == 0) {
#line 265
              tmp___3 = 0;
            } else {
#line 265
              tmp___3 = 1;
            }
          } else {
#line 265
            tmp___3 = 1;
          }
#line 265
          if (! tmp___3) {
            {
#line 266
            abort();
            }
          }
#line 267
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 267
          rneedle.next_done = (_Bool)0;
          {
#line 269
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 271
            mbuiter_multi_next(& rneedle);
            }
#line 271
            if (rneedle.cur.wc_valid) {
#line 271
              if (rneedle.cur.wc == 0) {
#line 271
                tmp___4 = 0;
              } else {
#line 271
                tmp___4 = 1;
              }
            } else {
#line 271
              tmp___4 = 1;
            }
#line 271
            if (! tmp___4) {
#line 273
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 274
            mbuiter_multi_next(& rhaystack);
            }
#line 274
            if (rhaystack.cur.wc_valid) {
#line 274
              if (rhaystack.cur.wc == 0) {
#line 274
                tmp___5 = 0;
              } else {
#line 274
                tmp___5 = 1;
              }
            } else {
#line 274
              tmp___5 = 1;
            }
#line 274
            if (! tmp___5) {
#line 276
              return ((char *)((void *)0));
            }
#line 277
            comparison_count ++;
#line 278
            if (rhaystack.cur.wc_valid) {
#line 278
              if (rneedle.cur.wc_valid) {
#line 278
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 278
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 278
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 278
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 278
                if (tmp___6 == 0) {
#line 278
                  tmp___7 = 1;
                } else {
#line 278
                  tmp___7 = 0;
                }
              } else {
#line 278
                tmp___7 = 0;
              }
#line 278
              tmp___8 = tmp___7;
            }
#line 278
            if (! tmp___8) {
#line 280
              goto while_break___1;
            }
#line 269
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 269
            rhaystack.next_done = (_Bool)0;
#line 269
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 269
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 220
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 220
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 286
      return ((char *)haystack);
    }
  } else
#line 290
  if ((int const   )*needle != 0) {
#line 306
    try_kmp___0 = (_Bool)1;
#line 307
    outer_loop_count___0 = (size_t )0;
#line 308
    comparison_count___0 = (size_t )0;
#line 309
    last_ccount___0 = (size_t )0;
#line 310
    needle_last_ccount = needle;
#line 314
    tmp___13 = needle;
#line 314
    needle ++;
#line 314
    b = (char )*tmp___13;
    {
#line 316
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 318
      if ((int const   )*haystack == 0) {
#line 320
        return ((char *)((void *)0));
      }
#line 324
      if (try_kmp___0) {
#line 324
        if (outer_loop_count___0 >= 10UL) {
#line 324
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 330
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 332
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 332
              needle_last_ccount += tmp___14;
              }
#line 335
              if ((int const   )*needle_last_ccount == 0) {
#line 336
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 337
              last_ccount___0 = comparison_count___0;
            }
#line 339
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 343
              tmp___15 = knuth_morris_pratt_unibyte(haystack, needle - 1, & result___0);
#line 343
              success___0 = tmp___15;
              }
#line 346
              if (success___0) {
#line 347
                return ((char *)result___0);
              }
#line 348
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 352
      outer_loop_count___0 ++;
#line 353
      comparison_count___0 ++;
#line 354
      if ((int const   )*haystack == (int const   )b) {
#line 357
        rhaystack___0 = haystack + 1;
#line 358
        rneedle___0 = needle;
        {
#line 360
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 362
          if ((int const   )*rneedle___0 == 0) {
#line 364
            return ((char *)haystack);
          }
#line 365
          if ((int const   )*rhaystack___0 == 0) {
#line 367
            return ((char *)((void *)0));
          }
#line 368
          comparison_count___0 ++;
#line 369
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 371
            goto while_break___3;
          }
#line 360
          rhaystack___0 ++;
#line 360
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 316
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 377
    return ((char *)haystack);
  }
}
}
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbslen.c"
size_t mbslen(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 482 "./string.h"
int mbscasecmp(char const   *s1 , char const   *s2 ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 122
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbscasecmp.c"
int mbscasecmp(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 70
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 72
  if (nplus >= n) {
    {
#line 74
    tmp = malloc(nplus);
#line 74
    p = (char *)tmp;
    }
#line 76
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 80
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 83
      *((int *)p + -1) = 336984906;
#line 86
      slot = (unsigned long )p % 257UL;
#line 87
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 88
      mmalloca_results[slot] = (void *)p;
#line 90
      return ((void *)p);
    }
  }
#line 94
  return ((void *)0);
}
}
#line 105 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 109
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 115
    if (*((int *)p + -1) == 336984906) {
#line 119
      slot = (unsigned long )p % 257UL;
#line 120
      chain = & mmalloca_results[slot];
      {
#line 121
      while (1) {
        while_continue: /* CIL Label */ ;
#line 121
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 121
          goto while_break;
        }
#line 123
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 126
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 127
          *chain = ((struct header *)p_begin)->next;
#line 128
          free((void *)p_begin);
          }
#line 129
          return;
        }
#line 131
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 136
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 19 "/home/khheo/project/benchmark/coreutils-7.1/lib/long-options.h"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) ;
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 55
extern int opterr ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc.h"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/long-options.c"
static struct option  const  long_options[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/long-options.c"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) 
{ 
  int c ;
  int saved_opterr ;
  va_list authors ;

  {
#line 55
  saved_opterr = opterr;
#line 58
  opterr = 0;
#line 60
  if (argc == 2) {
    {
#line 60
    c = getopt_long(argc, (char * const  *)argv, "+", long_options, (int *)((void *)0));
    }
#line 60
    if (c != -1) {
      {
#line 65
      if (c == 104) {
#line 65
        goto case_104;
      }
#line 68
      if (c == 118) {
#line 68
        goto case_118;
      }
#line 76
      goto switch_default;
      case_104: /* CIL Label */ 
      {
#line 66
      (*usage_func)(0);
      }
      case_118: /* CIL Label */ 
      {
#line 71
      __builtin_va_start(authors, usage_func);
#line 72
      version_etc_va(stdout, command_name, package, version, authors);
#line 73
      exit(0);
      }
      switch_default: /* CIL Label */ 
#line 78
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 83
  opterr = saved_opterr;
#line 87
  optind = 0;
#line 88
  return;
}
}
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 631
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___3 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 116
  cp = (char const   *)charset_aliases;
#line 117
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 122
    base = "charset.alias";
#line 127
    tmp = getenv("CHARSETALIASDIR");
#line 127
    dir = (char const   *)tmp;
    }
#line 128
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 129
      dir = "/usr/local/lib";
    } else
#line 128
    if ((int const   )*(dir + 0) == 0) {
#line 129
      dir = "/usr/local/lib";
    }
    {
#line 133
    tmp___0 = strlen(dir);
#line 133
    dir_len___0 = tmp___0;
#line 134
    tmp___1 = strlen(base);
#line 134
    base_len___0 = tmp___1;
    }
#line 135
    if (dir_len___0 > 0UL) {
#line 135
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 135
        tmp___2 = 1;
      } else {
#line 135
        tmp___2 = 0;
      }
    } else {
#line 135
      tmp___2 = 0;
    }
    {
#line 135
    add_slash = tmp___2;
#line 136
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 136
    file_name___3 = (char *)tmp___3;
    }
#line 137
    if ((unsigned long )file_name___3 != (unsigned long )((void *)0)) {
      {
#line 139
      memcpy((void */* __restrict  */)file_name___3, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 140
      if (add_slash) {
#line 141
        *(file_name___3 + dir_len___0) = (char )'/';
      }
      {
#line 142
      memcpy((void */* __restrict  */)((file_name___3 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 146
    if ((unsigned long )file_name___3 == (unsigned long )((void *)0)) {
#line 148
      cp = "";
    } else {
      {
#line 146
      fp = fopen((char const   */* __restrict  */)file_name___3, (char const   */* __restrict  */)"r");
      }
#line 146
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 148
        cp = "";
      } else {
#line 152
        res_ptr = (char *)((void *)0);
#line 153
        res_size = (size_t )0;
        {
#line 155
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 163
          c = getc_unlocked(fp);
          }
#line 164
          if (c == -1) {
#line 165
            goto while_break;
          }
#line 166
          if (c == 10) {
#line 167
            goto __Cont;
          } else
#line 166
          if (c == 32) {
#line 167
            goto __Cont;
          } else
#line 166
          if (c == 9) {
#line 167
            goto __Cont;
          }
#line 168
          if (c == 35) {
            {
#line 171
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 172
              c = getc_unlocked(fp);
              }
#line 171
              if (c == -1) {
#line 171
                goto while_break___0;
              } else
#line 171
              if (c == 10) {
#line 171
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 174
            if (c == -1) {
#line 175
              goto while_break;
            }
#line 176
            goto __Cont;
          }
          {
#line 178
          ungetc(c, fp);
#line 179
          tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                           buf1, buf2);
          }
#line 179
          if (tmp___4 < 2) {
#line 180
            goto while_break;
          }
          {
#line 181
          l1 = strlen((char const   *)(buf1));
#line 182
          l2 = strlen((char const   *)(buf2));
#line 183
          old_res_ptr = res_ptr;
          }
#line 184
          if (res_size == 0UL) {
            {
#line 186
            res_size = ((l1 + 1UL) + l2) + 1UL;
#line 187
            tmp___5 = malloc(res_size + 1UL);
#line 187
            res_ptr = (char *)tmp___5;
            }
          } else {
            {
#line 191
            res_size += ((l1 + 1UL) + l2) + 1UL;
#line 192
            tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 192
            res_ptr = (char *)tmp___6;
            }
          }
#line 194
          if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 197
            res_size = (size_t )0;
#line 198
            if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
              {
#line 199
              free((void *)old_res_ptr);
              }
            }
#line 200
            goto while_break;
          }
          {
#line 202
          strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                 (char const   */* __restrict  */)(buf1));
#line 203
          strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
          }
          __Cont: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 205
        fclose(fp);
        }
#line 206
        if (res_size == 0UL) {
#line 207
          cp = "";
        } else {
#line 210
          *(res_ptr + res_size) = (char )'\000';
#line 211
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 215
    if ((unsigned long )file_name___3 != (unsigned long )((void *)0)) {
      {
#line 216
      free((void *)file_name___3);
      }
    }
#line 309
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 312
  return (cp);
}
}
#line 324 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 335
  tmp = nl_langinfo(14);
#line 335
  codeset = (char const   *)tmp;
  }
#line 477
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 479
    codeset = "";
  }
  {
#line 482
  aliases = get_charset_aliases();
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! ((int const   )*aliases != 0)) {
#line 482
      goto while_break;
    }
    {
#line 485
    tmp___3 = strcmp(codeset, aliases);
    }
#line 485
    if (tmp___3 == 0) {
      {
#line 488
      tmp___2 = strlen(aliases);
#line 488
      codeset = (aliases + tmp___2) + 1;
      }
#line 489
      goto while_break;
    } else
#line 485
    if ((int const   )*(aliases + 0) == 42) {
#line 485
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 488
        tmp___2 = strlen(aliases);
#line 488
        codeset = (aliases + tmp___2) + 1;
        }
#line 489
        goto while_break;
      }
    }
    {
#line 482
    tmp___0 = strlen(aliases);
#line 482
    aliases += tmp___0 + 1UL;
#line 482
    tmp___1 = strlen(aliases);
#line 482
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  if ((int const   )*(codeset + 0) == 0) {
#line 496
    codeset = "ASCII";
  }
#line 498
  return (codeset);
}
}
#line 766 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.h"
void initbuffer(struct linebuffer *linebuffer ) ;
#line 41
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
#line 48
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
#line 51
void freebuffer(struct linebuffer *linebuffer ) ;
#line 59 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
void *x2realloc(void *p , size_t *pn ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.c"
void initbuffer(struct linebuffer *linebuffer ) 
{ 


  {
  {
#line 39
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
  }
#line 40
  return;
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.c"
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) 
{ 
  struct linebuffer *tmp ;

  {
  {
#line 45
  tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
  }
#line 45
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.c"
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) 
{ 
  int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  size_t oldsize ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 63
  buffer = linebuffer->buffer;
#line 64
  p = linebuffer->buffer;
#line 65
  end = buffer + linebuffer->size;
#line 67
  tmp = feof_unlocked(stream);
  }
#line 67
  if (tmp) {
#line 68
    return ((struct linebuffer *)((void *)0));
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    c = getc_unlocked(stream);
    }
#line 73
    if (c == -1) {
#line 75
      if ((unsigned long )p == (unsigned long )buffer) {
#line 76
        return ((struct linebuffer *)((void *)0));
      } else {
        {
#line 75
        tmp___0 = ferror_unlocked(stream);
        }
#line 75
        if (tmp___0) {
#line 76
          return ((struct linebuffer *)((void *)0));
        }
      }
#line 77
      if ((int )*(p + -1) == (int )delimiter) {
#line 78
        goto while_break;
      }
#line 79
      c = (int )delimiter;
    }
#line 81
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 83
      oldsize = linebuffer->size;
#line 84
      tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
#line 84
      buffer = (char *)tmp___1;
#line 85
      p = buffer + oldsize;
#line 86
      linebuffer->buffer = buffer;
#line 87
      end = buffer + linebuffer->size;
      }
    }
#line 89
    tmp___2 = p;
#line 89
    p ++;
#line 89
    *tmp___2 = (char )c;
#line 70
    if (! (c != (int )delimiter)) {
#line 70
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  linebuffer->length = (size_t )(p - buffer);
#line 94
  return (linebuffer);
}
}
#line 99 "/home/khheo/project/benchmark/coreutils-7.1/lib/linebuffer.c"
void freebuffer(struct linebuffer *linebuffer ) 
{ 


  {
  {
#line 102
  free((void *)linebuffer->buffer);
  }
#line 103
  return;
}
}
#line 70 "/home/khheo/project/benchmark/coreutils-7.1/lib/isnan.c"
int rpl_isnanl(long double x ) 
{ 
  memory_double m1 ;
  memory_double m2 ;
  long double tmp ;
  int tmp___0 ;

  {
#line 142
  if (x == x) {
    {
#line 149
    memset((void *)(& m1.value), 0, (size_t )10);
#line 150
    memset((void *)(& m2.value), 0, (size_t )10);
#line 151
    m1.value = x;
    }
#line 152
    if (x) {
#line 152
      tmp = 0.0L;
    } else {
#line 152
      tmp = - 0.0L;
    }
    {
#line 152
    m2.value = x + tmp;
#line 153
    tmp___0 = memcmp((void const   *)(& m1.value), (void const   *)(& m2.value), (size_t )10);
    }
#line 153
    if (tmp___0 != 0) {
#line 154
      return (1);
    }
#line 156
    return (0);
  } else {
#line 159
    return (1);
  }
}
}
#line 6 "/home/khheo/project/benchmark/coreutils-7.1/lib/isapipe.h"
int isapipe(int fd ) ;
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/isapipe.c"
int isapipe(int fd ) 
{ 
  nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int tmp ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 71
  pipe_link_count_max = (nlink_t )1;
#line 72
  check_for_fifo = (_Bool)1;
#line 74
  tmp = fstat(fd, & st);
#line 74
  fstat_result = tmp;
  }
#line 76
  if (fstat_result != 0) {
#line 77
    return (fstat_result);
  }
#line 114
  if (st.st_nlink <= pipe_link_count_max) {
#line 114
    if (check_for_fifo) {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 4096U;
    } else {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 49152U;
    }
#line 114
    if (tmp___4) {
#line 114
      tmp___5 = 1;
    } else {
#line 114
      tmp___5 = 0;
    }
  } else {
#line 114
    tmp___5 = 0;
  }
#line 114
  return (tmp___5);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___1 + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 6 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.h"
char *getuser(uid_t uid ) ;
#line 7
char *getgroup(gid_t gid ) ;
#line 8
uid_t *getuidbyname(char const   *user ) ;
#line 9
gid_t *getgidbyname(char const   *group ) ;
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 115
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 101 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 107
extern struct group *getgrnam(char const   *__name ) ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *user_alist  ;
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *nouser_alist  ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *group_alist  ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *nogroup_alist  ;
#line 67 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
char *getuser(uid_t uid ) 
{ 
  struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 71
  match = (struct userid *)((void *)0);
#line 73
  tail = user_alist;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! tail) {
#line 73
      goto while_break;
    }
#line 75
    if (tail->id.u == uid) {
#line 77
      match = tail;
#line 78
      goto while_break;
    }
#line 73
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    {
#line 84
    tmp = getpwuid(uid);
#line 84
    pwent = tmp;
    }
#line 85
    if (pwent) {
#line 85
      tmp___0 = (char const   *)pwent->pw_name;
    } else {
#line 85
      tmp___0 = "";
    }
    {
#line 85
    name = tmp___0;
#line 86
    tmp___1 = strlen(name);
#line 86
    tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 86
    match = (struct userid *)tmp___2;
#line 87
    match->id.u = uid;
#line 88
    strcpy((char */* __restrict  */)(match->name), (char const   */* __restrict  */)name);
#line 91
    match->next = user_alist;
#line 92
    user_alist = match;
    }
  }
#line 95
  if (match->name[0]) {
#line 95
    tmp___3 = match->name;
  } else {
#line 95
    tmp___3 = (char *)((void *)0);
  }
#line 95
  return (tmp___3);
}
}
#line 103 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
uid_t *getuidbyname(char const   *user ) 
{ 
  struct userid *tail ;
  struct passwd *pwent ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 109
  tail = user_alist;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! tail) {
#line 109
      goto while_break;
    }
#line 111
    if ((int )tail->name[0] == (int )*user) {
      {
#line 111
      tmp = strcmp((char const   *)(tail->name), user);
      }
#line 111
      if (! tmp) {
#line 112
        return (& tail->id.u);
      }
    }
#line 109
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  tail = nouser_alist;
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! tail) {
#line 114
      goto while_break___0;
    }
#line 116
    if ((int )tail->name[0] == (int )*user) {
      {
#line 116
      tmp___0 = strcmp((char const   *)(tail->name), user);
      }
#line 116
      if (! tmp___0) {
#line 117
        return ((uid_t *)((void *)0));
      }
    }
#line 114
    tail = tail->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  pwent = getpwnam(user);
#line 130
  tmp___1 = strlen(user);
#line 130
  tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 130
  tail = (struct userid *)tmp___2;
#line 131
  strcpy((char */* __restrict  */)(tail->name), (char const   */* __restrict  */)user);
  }
#line 134
  if (pwent) {
#line 136
    tail->id.u = pwent->pw_uid;
#line 137
    tail->next = user_alist;
#line 138
    user_alist = tail;
#line 139
    return (& tail->id.u);
  }
#line 142
  tail->next = nouser_alist;
#line 143
  nouser_alist = tail;
#line 144
  return ((uid_t *)((void *)0));
}
}
#line 149 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
char *getgroup(gid_t gid ) 
{ 
  struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 153
  match = (struct userid *)((void *)0);
#line 155
  tail = group_alist;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! tail) {
#line 155
      goto while_break;
    }
#line 157
    if (tail->id.g == gid) {
#line 159
      match = tail;
#line 160
      goto while_break;
    }
#line 155
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    {
#line 166
    tmp = getgrgid(gid);
#line 166
    grent = tmp;
    }
#line 167
    if (grent) {
#line 167
      tmp___0 = (char const   *)grent->gr_name;
    } else {
#line 167
      tmp___0 = "";
    }
    {
#line 167
    name = tmp___0;
#line 168
    tmp___1 = strlen(name);
#line 168
    tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 168
    match = (struct userid *)tmp___2;
#line 169
    match->id.g = gid;
#line 170
    strcpy((char */* __restrict  */)(match->name), (char const   */* __restrict  */)name);
#line 173
    match->next = group_alist;
#line 174
    group_alist = match;
    }
  }
#line 177
  if (match->name[0]) {
#line 177
    tmp___3 = match->name;
  } else {
#line 177
    tmp___3 = (char *)((void *)0);
  }
#line 177
  return (tmp___3);
}
}
#line 185 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
gid_t *getgidbyname(char const   *group ) 
{ 
  struct userid *tail ;
  struct group *grent ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 191
  tail = group_alist;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! tail) {
#line 191
      goto while_break;
    }
#line 193
    if ((int )tail->name[0] == (int )*group) {
      {
#line 193
      tmp = strcmp((char const   *)(tail->name), group);
      }
#line 193
      if (! tmp) {
#line 194
        return (& tail->id.g);
      }
    }
#line 191
    tail = tail->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  tail = nogroup_alist;
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if (! tail) {
#line 196
      goto while_break___0;
    }
#line 198
    if ((int )tail->name[0] == (int )*group) {
      {
#line 198
      tmp___0 = strcmp((char const   *)(tail->name), group);
      }
#line 198
      if (! tmp___0) {
#line 199
        return ((gid_t *)((void *)0));
      }
    }
#line 196
    tail = tail->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 201
  grent = getgrnam(group);
#line 212
  tmp___1 = strlen(group);
#line 212
  tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 212
  tail = (struct userid *)tmp___2;
#line 213
  strcpy((char */* __restrict  */)(tail->name), (char const   */* __restrict  */)group);
  }
#line 216
  if (grent) {
#line 218
    tail->id.g = grent->gr_gid;
#line 219
    tail->next = group_alist;
#line 220
    group_alist = tail;
#line 221
    return (& tail->id.g);
  }
#line 224
  tail->next = nogroup_alist;
#line 225
  nogroup_alist = tail;
#line 226
  return ((gid_t *)((void *)0));
}
}
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir ) ;
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ 
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 4)) {
#line 31
      goto while_break;
    }
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ 
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ 
  int top_val ;
  _Bool tmp ;

  {
  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
  }
#line 59
  if (tmp) {
    {
#line 60
    abort();
    }
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 47 "./xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 80 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.h"
char *human_readable(uintmax_t n , char *buf___1 , int opts___0 , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
#line 82
enum strtol_error human_options(char const   *spec , int *opts___0 , uintmax_t *block_size ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *( __attribute__((__leaf__)) localeconv)(void) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 42 "./argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char const   power_letter[9]  = 
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static long double adjust_value(int inexact_style , long double value ) 
{ 
  uintmax_t u ;
  int tmp ;

  {
#line 61
  if (inexact_style != 1) {
#line 61
    if (value < (long double )0xffffffffffffffffUL) {
#line 63
      u = (uintmax_t )value;
#line 64
      if (inexact_style == 0) {
#line 64
        if ((long double )u != value) {
#line 64
          tmp = 1;
        } else {
#line 64
          tmp = 0;
        }
      } else {
#line 64
        tmp = 0;
      }
#line 64
      value = (long double )(u + (uintmax_t )tmp);
    }
  }
#line 67
  return (value);
}
}
#line 79 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep___0 ) 
{ 
  register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___1[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  unsigned char g ;

  {
  {
#line 84
  grouplen = 0xffffffffffffffffUL;
#line 85
  tmp = strlen(thousands_sep___0);
#line 85
  thousands_seplen = tmp;
#line 86
  i = numberlen;
#line 92
  memcpy((void */* __restrict  */)(buf___1), (void const   */* __restrict  */)number,
         numberlen);
#line 93
  d = number + numberlen;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    g = (unsigned char )*grouping;
#line 99
    if (g) {
#line 101
      if ((int )g < 127) {
#line 101
        grouplen = (size_t )g;
      } else {
#line 101
        grouplen = i;
      }
#line 102
      grouping ++;
    }
#line 105
    if (i < grouplen) {
#line 106
      grouplen = i;
    }
    {
#line 108
    d -= grouplen;
#line 109
    i -= grouplen;
#line 110
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)(buf___1 + i),
           grouplen);
    }
#line 111
    if (i == 0UL) {
#line 112
      return (d);
    }
    {
#line 114
    d -= thousands_seplen;
#line 115
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)thousands_sep___0,
           thousands_seplen);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 153 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
char *human_readable(uintmax_t n , char *buf___1 , int opts___0 , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) 
{ 
  int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point___0 ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep___0 ;
  struct lconv  const  *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 157
  inexact_style = opts___0 & 3;
#line 159
  if (opts___0 & 32) {
#line 159
    tmp = 1024;
  } else {
#line 159
    tmp = 1000;
  }
  {
#line 159
  base = (unsigned int )tmp;
#line 162
  exponent = -1;
#line 163
  exponent_max = (int )(sizeof(power_letter) - 1UL);
#line 174
  decimal_point___0 = ".";
#line 175
  decimal_pointlen = (size_t )1;
#line 176
  grouping = "";
#line 177
  thousands_sep___0 = "";
#line 178
  tmp___0 = localeconv();
#line 178
  l = (struct lconv  const  *)tmp___0;
#line 179
  tmp___1 = strlen((char const   *)l->decimal_point);
#line 179
  pointlen = tmp___1;
  }
#line 180
  if (0UL < pointlen) {
#line 180
    if (pointlen <= 16UL) {
#line 182
      decimal_point___0 = (char const   *)l->decimal_point;
#line 183
      decimal_pointlen = pointlen;
    }
  }
  {
#line 185
  grouping = (char const   *)l->grouping;
#line 186
  tmp___2 = strlen((char const   *)l->thousands_sep);
  }
#line 186
  if (tmp___2 <= 16UL) {
#line 187
    thousands_sep___0 = (char const   *)l->thousands_sep;
  }
#line 189
  psuffix = (buf___1 + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
#line 190
  p = psuffix;
#line 195
  if (to_block_size <= from_block_size) {
#line 197
    if (from_block_size % to_block_size == 0UL) {
#line 199
      multiplier = from_block_size / to_block_size;
#line 200
      amt = n * multiplier;
#line 201
      if (amt / multiplier == n) {
#line 203
        tenths = 0;
#line 204
        rounding = 0;
#line 205
        goto use_integer_arithmetic;
      }
    }
  } else
#line 209
  if (from_block_size != 0UL) {
#line 209
    if (to_block_size % from_block_size == 0UL) {
#line 211
      divisor = to_block_size / from_block_size;
#line 212
      r10 = (n % divisor) * 10UL;
#line 213
      r2 = (r10 % divisor) * 2UL;
#line 214
      amt = n / divisor;
#line 215
      tenths = (int )(r10 / divisor);
#line 216
      if (r2 < divisor) {
#line 216
        rounding = 0UL < r2;
      } else {
#line 216
        rounding = 2 + (divisor < r2);
      }
#line 217
      goto use_integer_arithmetic;
    }
  }
#line 225
  dto_block_size = (long double )to_block_size;
#line 226
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
#line 230
  if (! (opts___0 & 16)) {
    {
#line 232
    tmp___3 = adjust_value(inexact_style, damt);
#line 232
    sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%.0Lf",
            tmp___3);
#line 233
    buflen = strlen((char const   *)buf___1);
#line 234
    nonintegerlen = (size_t )0;
    }
  } else {
#line 238
    e = (long double )1;
#line 239
    exponent = 0;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      e *= (long double )base;
#line 244
      exponent ++;
#line 241
      if (e * (long double )base <= damt) {
#line 241
        if (! (exponent < exponent_max)) {
#line 241
          goto while_break;
        }
      } else {
#line 241
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 248
    damt /= e;
#line 250
    tmp___4 = adjust_value(inexact_style, damt);
#line 250
    sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%.1Lf",
            tmp___4);
#line 251
    buflen = strlen((char const   *)buf___1);
#line 252
    nonintegerlen = decimal_pointlen + 1UL;
    }
#line 254
    if ((1UL + nonintegerlen) + (size_t )(! (opts___0 & 32)) < buflen) {
      {
#line 258
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 258
      sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%.0Lf",
              tmp___5 / (long double )10);
#line 260
      buflen = strlen((char const   *)buf___1);
#line 261
      nonintegerlen = (size_t )0;
      }
    } else
#line 254
    if (opts___0 & 8) {
#line 254
      if ((int )*(buf___1 + (buflen - 1UL)) == 48) {
        {
#line 258
        tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 258
        sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%.0Lf",
                tmp___5 / (long double )10);
#line 260
        buflen = strlen((char const   *)buf___1);
#line 261
        nonintegerlen = (size_t )0;
        }
      }
    }
  }
  {
#line 265
  p = psuffix - buflen;
#line 266
  memmove((void *)p, (void const   *)buf___1, buflen);
#line 267
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
  }
#line 269
  goto do_grouping;
  use_integer_arithmetic: 
#line 278
  if (opts___0 & 16) {
#line 280
    exponent = 0;
#line 282
    if ((uintmax_t )base <= amt) {
      {
#line 284
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 286
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
#line 287
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
#line 288
        amt /= (uintmax_t )base;
#line 289
        tenths = (int )(r10___0 / base);
#line 290
        if (r2___0 < base) {
#line 290
          rounding = r2___0 + (unsigned int )rounding != 0U;
        } else {
#line 290
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
        }
#line 293
        exponent ++;
#line 284
        if ((uintmax_t )base <= amt) {
#line 284
          if (! (exponent < exponent_max)) {
#line 284
            goto while_break___0;
          }
        } else {
#line 284
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 297
      if (amt < 10UL) {
#line 299
        if (inexact_style == 1) {
#line 299
          tmp___7 = 2 < rounding + (tenths & 1);
        } else {
#line 299
          if (inexact_style == 0) {
#line 299
            if (0 < rounding) {
#line 299
              tmp___6 = 1;
            } else {
#line 299
              tmp___6 = 0;
            }
          } else {
#line 299
            tmp___6 = 0;
          }
#line 299
          tmp___7 = tmp___6;
        }
#line 299
        if (tmp___7) {
#line 303
          tenths ++;
#line 304
          rounding = 0;
#line 306
          if (tenths == 10) {
#line 308
            amt ++;
#line 309
            tenths = 0;
          }
        }
#line 313
        if (amt < 10UL) {
#line 313
          if (tenths) {
#line 313
            goto _L;
          } else
#line 313
          if (! (opts___0 & 8)) {
            _L: /* CIL Label */ 
            {
#line 316
            p --;
#line 316
            *p = (char )(48 + tenths);
#line 317
            p -= decimal_pointlen;
#line 318
            memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)decimal_point___0,
                   decimal_pointlen);
#line 319
            rounding = 0;
#line 319
            tenths = rounding;
            }
          }
        }
      }
    }
  }
#line 325
  if (inexact_style == 1) {
#line 325
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
  } else {
#line 325
    if (inexact_style == 0) {
#line 325
      if (0 < tenths + rounding) {
#line 325
        tmp___8 = 1;
      } else {
#line 325
        tmp___8 = 0;
      }
    } else {
#line 325
      tmp___8 = 0;
    }
#line 325
    tmp___9 = tmp___8;
  }
#line 325
  if (tmp___9) {
#line 329
    amt ++;
#line 331
    if (opts___0 & 16) {
#line 331
      if (amt == (uintmax_t )base) {
#line 331
        if (exponent < exponent_max) {
#line 334
          exponent ++;
#line 335
          if (! (opts___0 & 8)) {
            {
#line 337
            p --;
#line 337
            *p = (char )'0';
#line 338
            p -= decimal_pointlen;
#line 339
            memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)decimal_point___0,
                   decimal_pointlen);
            }
          }
#line 341
          amt = (uintmax_t )1;
        }
      }
    }
  }
#line 345
  integerlim = (char const   *)p;
  {
#line 347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 349
    digit = (int )(amt % 10UL);
#line 350
    p --;
#line 350
    *p = (char )(digit + 48);
#line 347
    amt /= 10UL;
#line 347
    if (! (amt != 0UL)) {
#line 347
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  do_grouping: 
#line 356
  if (opts___0 & 4) {
    {
#line 357
    p = group_number(p, (size_t )(integerlim - (char const   *)p), grouping, thousands_sep___0);
    }
  }
#line 359
  if (opts___0 & 128) {
#line 361
    if (exponent < 0) {
#line 364
      exponent = 0;
#line 365
      power = (uintmax_t )1;
      {
#line 365
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 365
        if (! (power < to_block_size)) {
#line 365
          goto while_break___2;
        }
#line 366
        exponent ++;
#line 366
        if (exponent == exponent_max) {
#line 367
          goto while_break___2;
        }
#line 365
        power *= (uintmax_t )base;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 370
    if (exponent | (opts___0 & 256)) {
#line 370
      if (opts___0 & 64) {
#line 371
        tmp___10 = psuffix;
#line 371
        psuffix ++;
#line 371
        *tmp___10 = (char )' ';
      }
    }
#line 373
    if (exponent) {
#line 374
      tmp___11 = psuffix;
#line 374
      psuffix ++;
#line 374
      if (! (opts___0 & 32)) {
#line 374
        if (exponent == 1) {
#line 374
          *tmp___11 = (char )'k';
        } else {
#line 374
          *tmp___11 = (char )power_letter[exponent];
        }
      } else {
#line 374
        *tmp___11 = (char )power_letter[exponent];
      }
    }
#line 378
    if (opts___0 & 256) {
#line 380
      if (opts___0 & 32) {
#line 380
        if (exponent) {
#line 381
          tmp___12 = psuffix;
#line 381
          psuffix ++;
#line 381
          *tmp___12 = (char )'i';
        }
      }
#line 382
      tmp___13 = psuffix;
#line 382
      psuffix ++;
#line 382
      *tmp___13 = (char )'B';
    }
  }
#line 386
  *psuffix = (char )'\000';
#line 388
  return (p);
}
}
#line 398 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char const   * const  block_size_args[3]  = {      (char const   */* const  */)"human-readable",      (char const   */* const  */)"si",      (char const   */* const  */)0};
#line 399 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
#line 405 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static uintmax_t default_block_size(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 408
  tmp___1 = getenv("POSIXLY_CORRECT");
  }
#line 408
  if (tmp___1) {
#line 408
    tmp___0 = 512;
  } else {
#line 408
    tmp___0 = 1024;
  }
#line 408
  return ((uintmax_t )tmp___0);
}
}
#line 411 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static strtol_error humblock(char const   *spec , uintmax_t *block_size , int *options ) 
{ 
  int i ;
  int opts___0 ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 415
  opts___0 = 0;
#line 417
  if (! spec) {
    {
#line 417
    tmp___1 = getenv("BLOCK_SIZE");
#line 417
    spec = (char const   *)tmp___1;
    }
#line 417
    if (spec) {
#line 417
      goto _L___0;
    } else {
      {
#line 417
      tmp___2 = getenv("BLOCKSIZE");
#line 417
      spec = (char const   *)tmp___2;
      }
#line 417
      if (spec) {
#line 417
        goto _L___0;
      } else {
        {
#line 420
        *block_size = default_block_size();
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 423
    if ((int const   )*spec == 39) {
#line 425
      opts___0 |= 4;
#line 426
      spec ++;
    }
    {
#line 429
    tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts), sizeof(block_size_opts[0]));
#line 429
    i = (int )tmp___0;
    }
#line 429
    if (0 <= i) {
#line 431
      opts___0 |= (int )block_size_opts[i];
#line 432
      *block_size = (uintmax_t )1;
    } else {
      {
#line 437
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 437
      e = tmp;
      }
#line 439
      if ((unsigned int )e != 0U) {
#line 441
        *options = 0;
#line 442
        return (e);
      }
      {
#line 444
      while (1) {
        while_continue: /* CIL Label */ ;
#line 444
        if (48 <= (int )*spec) {
#line 444
          if ((int const   )*spec <= 57) {
#line 444
            goto while_break;
          }
        }
#line 445
        if ((unsigned long )spec == (unsigned long )ptr) {
#line 447
          opts___0 |= 128;
#line 448
          if ((int )*(ptr + -1) == 66) {
#line 449
            opts___0 |= 256;
          }
#line 450
          if ((int )*(ptr + -1) != 66) {
#line 451
            opts___0 |= 32;
          } else
#line 450
          if ((int )*(ptr + -2) == 105) {
#line 451
            opts___0 |= 32;
          }
#line 452
          goto while_break;
        }
#line 444
        spec ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 457
  *options = opts___0;
#line 458
  return ((strtol_error )0);
}
}
#line 461 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
enum strtol_error human_options(char const   *spec , int *opts___0 , uintmax_t *block_size ) 
{ 
  strtol_error e ;
  strtol_error tmp ;

  {
  {
#line 464
  tmp = humblock(spec, block_size, opts___0);
#line 464
  e = tmp;
  }
#line 465
  if (*block_size == 0UL) {
    {
#line 467
    *block_size = default_block_size();
#line 468
    e = (strtol_error )4;
    }
  }
#line 470
  return (e);
}
}
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 59 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 60
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 61
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 62
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 63
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 64
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 65
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 68
void *hash_get_first(Hash_table const   *table ) ;
#line 69
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 70
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 71
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 74
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 75
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 76
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) ;
#line 79
void hash_clear(Hash_table *table ) ;
#line 80
void hash_free(Hash_table *table ) ;
#line 83
_Bool hash_rehash(Hash_table *table , size_t candidate ) ;
#line 84
void *hash_insert(Hash_table *table , void const   *entry ) ;
#line 85
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 127 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 146 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 149
  return ((size_t )table->n_buckets);
}
}
#line 154 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 157
  return ((size_t )table->n_buckets_used);
}
}
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 165
  return ((size_t )table->n_entries);
}
}
#line 170 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 174
  max_bucket_length = (size_t )0;
#line 176
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 176
      goto while_break;
    }
#line 178
    if (bucket->data) {
#line 180
      cursor = bucket;
#line 181
      bucket_length = (size_t )1;
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        cursor = (struct hash_entry  const  *)cursor->next;
#line 183
        if (! cursor) {
#line 183
          goto while_break___0;
        }
#line 184
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 186
      if (bucket_length > max_bucket_length) {
#line 187
        max_bucket_length = bucket_length;
      }
    }
#line 176
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (max_bucket_length);
}
}
#line 197 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 201
  n_buckets_used = (size_t )0;
#line 202
  n_entries = (size_t )0;
#line 204
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 204
      goto while_break;
    }
#line 206
    if (bucket->data) {
#line 208
      cursor = bucket;
#line 211
      n_buckets_used ++;
#line 212
      n_entries ++;
      {
#line 215
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 215
        cursor = (struct hash_entry  const  *)cursor->next;
#line 215
        if (! cursor) {
#line 215
          goto while_break___0;
        }
#line 216
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 204
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 220
    if (n_entries == (size_t )table->n_entries) {
#line 221
      return ((_Bool)1);
    }
  }
#line 223
  return ((_Bool)0);
}
}
#line 226 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 229
  tmp = hash_get_n_entries(table);
#line 229
  n_entries = tmp;
#line 230
  tmp___0 = hash_get_n_buckets(table);
#line 230
  n_buckets = tmp___0;
#line 231
  tmp___1 = hash_get_n_buckets_used(table);
#line 231
  n_buckets_used = tmp___1;
#line 232
  tmp___2 = hash_get_max_bucket_length(table);
#line 232
  max_bucket_length = tmp___2;
#line 234
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 235
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 236
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 241
  return;
}
}
#line 246 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 249
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 249
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 253
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 254
    abort();
    }
  }
#line 256
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 257
    return ((void *)0);
  }
#line 259
  cursor = bucket;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! cursor) {
#line 259
      goto while_break;
    }
    {
#line 260
    tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
    }
#line 260
    if (tmp___0) {
#line 261
      return ((void *)cursor->data);
    }
#line 259
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return ((void *)0);
}
}
#line 275 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 280
  if (table->n_entries == 0UL) {
#line 281
    return ((void *)0);
  }
#line 283
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 285
      abort();
      }
    } else
#line 286
    if (bucket->data) {
#line 287
      return ((void *)bucket->data);
    }
#line 283
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 294 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 297
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 297
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 301
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 302
    abort();
    }
  }
#line 305
  cursor = bucket;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! cursor) {
#line 305
      goto while_break;
    }
#line 306
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 306
      if (cursor->next) {
#line 307
        return ((cursor->next)->data);
      }
    }
#line 305
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 310
    bucket ++;
#line 310
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 310
      goto while_break___0;
    }
#line 311
    if (bucket->data) {
#line 312
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  return ((void *)0);
}
}
#line 322 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 326
  counter = (size_t )0;
#line 330
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 330
      goto while_break;
    }
#line 332
    if (bucket->data) {
#line 334
      cursor = bucket;
      {
#line 334
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 334
        if (! cursor) {
#line 334
          goto while_break___0;
        }
#line 336
        if (counter >= buffer_size) {
#line 337
          return (counter);
        }
#line 338
        tmp = counter;
#line 338
        counter ++;
#line 338
        *(buffer + tmp) = (void *)cursor->data;
#line 334
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 330
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (counter);
}
}
#line 354 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 358
  counter = (size_t )0;
#line 362
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 362
      goto while_break;
    }
#line 364
    if (bucket->data) {
#line 366
      cursor = bucket;
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if (! cursor) {
#line 366
          goto while_break___0;
        }
        {
#line 368
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 368
        if (! tmp) {
#line 369
          return (counter);
        }
#line 370
        counter ++;
#line 366
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 362
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (counter);
}
}
#line 417 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 420
  value = (size_t )0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    ch = (unsigned char )*string;
#line 423
    if (! ch) {
#line 423
      goto while_break;
    }
#line 424
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 423
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return (value);
}
}
#line 433 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 436
  divisor = (size_t )3;
#line 437
  square = divisor * divisor;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (square < candidate) {
#line 439
      if (! (candidate % divisor)) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
#line 441
    divisor ++;
#line 442
    square += 4UL * divisor;
#line 443
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  if (candidate % divisor) {
#line 446
    tmp = 1;
  } else {
#line 446
    tmp = 0;
  }
#line 446
  return ((_Bool )tmp);
}
}
#line 452 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 456
  if (candidate < 10UL) {
#line 457
    candidate = (size_t )10;
  }
#line 460
  candidate |= 1UL;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 462
    tmp = is_prime(candidate);
    }
#line 462
    if (tmp) {
#line 462
      goto while_break;
    }
#line 463
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (candidate);
}
}
#line 468 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 471
  *tuning = (Hash_tuning )default_tuning;
#line 472
  return;
}
}
#line 480 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 483
  tuning = table->tuning;
#line 490
  epsilon = 0.1f;
#line 492
  if (epsilon < (float )tuning->growth_threshold) {
#line 492
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 492
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 492
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 492
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 492
            if (tuning->shrink_factor <= (float const   )1) {
#line 492
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 499
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 501
  table->tuning = & default_tuning;
#line 502
  return ((_Bool)0);
}
}
#line 536 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  float new_candidate ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 543
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 544
    return ((Hash_table *)((void *)0));
  } else
#line 543
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 544
    return ((Hash_table *)((void *)0));
  }
  {
#line 546
  tmp = malloc(sizeof(*table));
#line 546
  table = (Hash_table *)tmp;
  }
#line 547
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 548
    return ((Hash_table *)((void *)0));
  }
#line 550
  if (! tuning) {
#line 551
    tuning = & default_tuning;
  }
  {
#line 552
  table->tuning = tuning;
#line 553
  tmp___0 = check_tuning(table);
  }
#line 553
  if (! tmp___0) {
#line 560
    goto fail;
  }
#line 563
  if (! tuning->is_n_buckets) {
#line 565
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 566
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 567
      goto fail;
    }
#line 568
    candidate = (size_t )new_candidate;
  }
#line 571
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 571
    tmp___1 = -1;
  } else {
#line 571
    tmp___1 = -2;
  }
#line 571
  if ((size_t )tmp___1 / sizeof(*(table->bucket)) < candidate) {
#line 572
    goto fail;
  }
  {
#line 573
  table->n_buckets = next_prime(candidate);
  }
#line 574
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 574
    tmp___2 = -1;
  } else {
#line 574
    tmp___2 = -2;
  }
#line 574
  if ((size_t )tmp___2 / sizeof(*(table->bucket)) < table->n_buckets) {
#line 575
    goto fail;
  }
  {
#line 577
  tmp___3 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 577
  table->bucket = (struct hash_entry *)tmp___3;
  }
#line 578
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 579
    goto fail;
  }
#line 580
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 581
  table->n_buckets_used = (size_t )0;
#line 582
  table->n_entries = (size_t )0;
#line 584
  table->hasher = hasher;
#line 585
  table->comparator = comparator;
#line 586
  table->data_freer = data_freer;
#line 588
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 592
  return (table);
  fail: 
  {
#line 595
  free((void *)table);
  }
#line 596
  return ((Hash_table *)((void *)0));
}
}
#line 603 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 608
  bucket = table->bucket;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 608
      goto while_break;
    }
#line 610
    if (bucket->data) {
#line 616
      cursor = bucket->next;
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 616
        if (! cursor) {
#line 616
          goto while_break___0;
        }
#line 618
        if (table->data_freer) {
          {
#line 619
          (*(table->data_freer))(cursor->data);
          }
        }
#line 620
        cursor->data = (void *)0;
#line 622
        next = cursor->next;
#line 625
        cursor->next = table->free_entry_list;
#line 626
        table->free_entry_list = cursor;
#line 616
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 630
      if (table->data_freer) {
        {
#line 631
        (*(table->data_freer))(bucket->data);
        }
      }
#line 632
      bucket->data = (void *)0;
#line 633
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 608
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  table->n_buckets_used = (size_t )0;
#line 638
  table->n_entries = (size_t )0;
#line 639
  return;
}
}
#line 646 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 654
  if (table->data_freer) {
#line 654
    if (table->n_entries) {
#line 656
      bucket = table->bucket;
      {
#line 656
      while (1) {
        while_continue: /* CIL Label */ ;
#line 656
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 656
          goto while_break;
        }
#line 658
        if (bucket->data) {
#line 660
          cursor = bucket;
          {
#line 660
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 660
            if (! cursor) {
#line 660
              goto while_break___0;
            }
            {
#line 662
            (*(table->data_freer))(cursor->data);
#line 660
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 656
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 675
  bucket = table->bucket;
  {
#line 675
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 675
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 675
      goto while_break___1;
    }
#line 677
    cursor = bucket->next;
    {
#line 677
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 677
      if (! cursor) {
#line 677
        goto while_break___2;
      }
      {
#line 679
      next = cursor->next;
#line 680
      free((void *)cursor);
#line 677
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 675
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 685
  cursor = table->free_entry_list;
  {
#line 685
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 685
    if (! cursor) {
#line 685
      goto while_break___3;
    }
    {
#line 687
    next = cursor->next;
#line 688
    free((void *)cursor);
#line 685
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 694
  free((void *)table->bucket);
#line 695
  free((void *)table);
  }
#line 696
  return;
}
}
#line 703 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 708
  if (table->free_entry_list) {
#line 710
    new = table->free_entry_list;
#line 711
    table->free_entry_list = new->next;
  } else {
    {
#line 718
    tmp = malloc(sizeof(*new));
#line 718
    new = (struct hash_entry *)tmp;
    }
  }
#line 722
  return (new);
}
}
#line 728 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 731
  entry->data = (void *)0;
#line 732
  entry->next = table->free_entry_list;
#line 733
  table->free_entry_list = entry;
#line 734
  return;
}
}
#line 742 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 746
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 746
  bucket = table->bucket + tmp;
  }
#line 750
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 751
    abort();
    }
  }
#line 753
  *bucket_head = bucket;
#line 756
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 757
    return ((void *)0);
  }
  {
#line 760
  tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
  }
#line 760
  if (tmp___0) {
#line 762
    data = bucket->data;
#line 764
    if (delete) {
#line 766
      if (bucket->next) {
        {
#line 768
        next = bucket->next;
#line 772
        *bucket = *next;
#line 773
        free_entry(table, next);
        }
      } else {
#line 777
        bucket->data = (void *)0;
      }
    }
#line 781
    return (data);
  }
#line 785
  cursor = bucket;
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! cursor->next) {
#line 785
      goto while_break;
    }
    {
#line 787
    tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
    }
#line 787
    if (tmp___1) {
#line 789
      data___0 = (cursor->next)->data;
#line 791
      if (delete) {
        {
#line 793
        next___0 = cursor->next;
#line 797
        cursor->next = next___0->next;
#line 798
        free_entry(table, next___0);
        }
      }
#line 801
      return (data___0);
    }
#line 785
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  return ((void *)0);
}
}
#line 817 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
_Bool hash_rehash(Hash_table *table , size_t candidate ) 
{ 
  Hash_table *new_table ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___0 ;

  {
  {
#line 825
  new_table = hash_initialize(candidate, table->tuning, table->hasher, table->comparator,
                              table->data_freer);
  }
#line 827
  if ((unsigned long )new_table == (unsigned long )((void *)0)) {
#line 828
    return ((_Bool)0);
  }
#line 835
  new_table->free_entry_list = table->free_entry_list;
#line 837
  bucket = table->bucket;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 837
      goto while_break;
    }
#line 838
    if (bucket->data) {
#line 839
      cursor = bucket;
      {
#line 839
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 839
        if (! cursor) {
#line 839
          goto while_break___0;
        }
        {
#line 841
        data = cursor->data;
#line 842
        tmp = (*(new_table->hasher))((void const   *)data, new_table->n_buckets);
#line 842
        new_bucket = new_table->bucket + tmp;
        }
#line 846
        if (! ((unsigned long )new_bucket < (unsigned long )new_table->bucket_limit)) {
          {
#line 847
          abort();
          }
        }
#line 849
        next = cursor->next;
#line 851
        if (new_bucket->data) {
#line 853
          if ((unsigned long )cursor == (unsigned long )bucket) {
            {
#line 857
            tmp___0 = allocate_entry(new_table);
#line 857
            new_entry = tmp___0;
            }
#line 859
            if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 860
              return ((_Bool)0);
            }
#line 862
            new_entry->data = data;
#line 863
            new_entry->next = new_bucket->next;
#line 864
            new_bucket->next = new_entry;
          } else {
#line 870
            cursor->next = new_bucket->next;
#line 871
            new_bucket->next = cursor;
          }
        } else {
#line 880
          new_bucket->data = data;
#line 881
          (new_table->n_buckets_used) ++;
#line 882
          if ((unsigned long )cursor != (unsigned long )bucket) {
            {
#line 883
            free_entry(new_table, cursor);
            }
          }
        }
#line 839
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 837
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 887
  free((void *)table->bucket);
#line 888
  table->bucket = new_table->bucket;
#line 889
  table->bucket_limit = new_table->bucket_limit;
#line 890
  table->n_buckets = new_table->n_buckets;
#line 891
  table->n_buckets_used = new_table->n_buckets_used;
#line 892
  table->free_entry_list = new_table->free_entry_list;
#line 897
  free((void *)new_table);
  }
#line 899
  return ((_Bool)1);
}
}
#line 906 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void *hash_insert(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp___0 ;
  _Bool tmp___1 ;

  {
#line 913
  if (! entry) {
    {
#line 914
    abort();
    }
  }
  {
#line 917
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 917
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 918
    return (data);
  }
#line 922
  if (bucket->data) {
    {
#line 924
    tmp = allocate_entry(table);
#line 924
    new_entry = tmp;
    }
#line 926
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 927
      return ((void *)0);
    }
#line 931
    new_entry->data = (void *)entry;
#line 932
    new_entry->next = bucket->next;
#line 933
    bucket->next = new_entry;
#line 934
    (table->n_entries) ++;
#line 935
    return ((void *)entry);
  }
#line 940
  bucket->data = (void *)entry;
#line 941
  (table->n_entries) ++;
#line 942
  (table->n_buckets_used) ++;
#line 949
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 954
    check_tuning(table);
    }
#line 955
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 958
      tuning = table->tuning;
#line 959
      if (tuning->is_n_buckets) {
#line 959
        tmp___0 = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 959
        tmp___0 = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 959
      candidate = (float )tmp___0;
#line 965
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 966
        return ((void *)0);
      }
      {
#line 969
      tmp___1 = hash_rehash(table, (size_t )candidate);
      }
#line 969
      if (! tmp___1) {
#line 970
        entry = (void const   *)((void *)0);
      }
    }
  }
#line 974
  return ((void *)entry);
}
}
#line 981 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;

  {
  {
#line 987
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 988
  if (! data) {
#line 989
    return ((void *)0);
  }
#line 991
  (table->n_entries) --;
#line 992
  if (! bucket->data) {
#line 994
    (table->n_buckets_used) --;
#line 999
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1004
      check_tuning(table);
      }
#line 1005
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1008
        tuning = table->tuning;
#line 1009
        if (tuning->is_n_buckets) {
#line 1009
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1009
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1009
        candidate = (size_t )tmp;
#line 1015
        hash_rehash(table, candidate);
        }
      }
    }
  }
#line 1020
  return (data);
}
}
#line 16 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.h"
size_t triple_hash(void const   *x , size_t table_size ) ;
#line 17
size_t triple_hash_no_name(void const   *x , size_t table_size ) ;
#line 18
_Bool triple_compare(void const   *x , void const   *y ) ;
#line 19
_Bool triple_compare_ino_str(void const   *x , void const   *y ) ;
#line 20
void triple_free(void *x ) ;
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-pjw.h"
size_t hash_pjw(void const   *x , size_t tablesize ) ;
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/same.h"
_Bool same_name(char const   *source , char const   *dest ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.c"
size_t triple_hash(void const   *x , size_t table_size ) 
{ 
  struct F_triple  const  *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 36
  p = (struct F_triple  const  *)x;
#line 37
  tmp___0 = hash_pjw((void const   *)p->name, table_size);
#line 37
  tmp = tmp___0;
  }
#line 40
  return ((tmp ^ (unsigned long )p->st_ino) % table_size);
}
}
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.c"
size_t triple_hash_no_name(void const   *x , size_t table_size ) 
{ 
  struct F_triple  const  *p ;

  {
#line 47
  p = (struct F_triple  const  *)x;
#line 50
  return ((size_t )(p->st_ino % (unsigned long const   )table_size));
}
}
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.c"
_Bool triple_compare(void const   *x , void const   *y ) 
{ 
  struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 57
  a = (struct F_triple  const  *)x;
#line 58
  b = (struct F_triple  const  *)y;
#line 59
  if (a->st_ino == b->st_ino) {
#line 59
    if (a->st_dev == b->st_dev) {
      {
#line 59
      tmp___1 = same_name((char const   *)a->name, (char const   *)b->name);
      }
#line 59
      if (tmp___1) {
#line 59
        tmp___0 = 1;
      } else {
#line 59
        tmp___0 = 0;
      }
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((_Bool )tmp___0);
}
}
#line 62 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.c"
_Bool triple_compare_ino_str(void const   *x , void const   *y ) 
{ 
  struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 65
  a = (struct F_triple  const  *)x;
#line 66
  b = (struct F_triple  const  *)y;
#line 67
  if (a->st_ino == b->st_ino) {
#line 67
    if (a->st_dev == b->st_dev) {
      {
#line 67
      tmp___1 = strcmp((char const   *)a->name, (char const   *)b->name);
      }
#line 67
      if (tmp___1 == 0) {
#line 67
        tmp___0 = 1;
      } else {
#line 67
        tmp___0 = 0;
      }
    } else {
#line 67
      tmp___0 = 0;
    }
  } else {
#line 67
    tmp___0 = 0;
  }
#line 67
  return ((_Bool )tmp___0);
}
}
#line 71 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-triple.c"
void triple_free(void *x ) 
{ 
  struct F_triple *a ;

  {
  {
#line 74
  a = (struct F_triple *)x;
#line 75
  free((void *)a->name);
#line 76
  free((void *)a);
  }
#line 77
  return;
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash-pjw.c"
size_t hash_pjw(void const   *x , size_t tablesize ) 
{ 
  char const   *s ;
  size_t h ;

  {
#line 34
  h = (size_t )0;
#line 36
  s = (char const   *)x;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! *s) {
#line 36
      goto while_break;
    }
#line 37
    h = (unsigned long )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8UL - 9UL)));
#line 36
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  return (h % tablesize);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 38
  hard = (_Bool)1;
#line 39
  tmp = setlocale(category, (char const   *)((void *)0));
#line 39
  p = (char const   *)tmp;
  }
#line 41
  if (p) {
#line 43
    if (1) {
      {
#line 45
      tmp___0 = strcmp(p, "C");
      }
#line 45
      if (tmp___0 == 0) {
#line 46
        hard = (_Bool)0;
      } else {
        {
#line 45
        tmp___1 = strcmp(p, "POSIX");
        }
#line 45
        if (tmp___1 == 0) {
#line 46
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 50
      tmp___2 = strdup(p);
#line 50
      locale = tmp___2;
      }
#line 51
      if (locale) {
        {
#line 56
        tmp___3 = setlocale(category, "C");
#line 56
        p = (char const   *)tmp___3;
        }
#line 56
        if (p) {
          {
#line 56
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 56
          if (tmp___4 == 0) {
#line 60
            hard = (_Bool)0;
          } else {
#line 56
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 56
          tmp___5 = setlocale(category, "POSIX");
#line 56
          p = (char const   *)tmp___5;
          }
#line 56
          if (p) {
            {
#line 56
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 56
            if (tmp___6 == 0) {
#line 60
              hard = (_Bool)0;
            }
          }
        }
        {
#line 63
        setlocale(category, (char const   *)locale);
#line 64
        free((void *)locale);
        }
      }
    }
  }
#line 69
  return (hard);
}
}
#line 18 "/home/khheo/project/benchmark/coreutils-7.1/lib/getugroups.h"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) ;
#line 61 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 67
extern void endgrent(void) ;
#line 73
extern struct group *getgrent(void) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/getugroups.c"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) 
{ 
  int count ;
  char **cp ;
  struct group *grp ;
  int *tmp ;
  int n ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 52
  count = 0;
#line 54
  if (gid != 4294967295U) {
#line 56
    if (maxcount != 0) {
#line 57
      *(grouplist + count) = gid;
    }
#line 58
    count ++;
  }
  {
#line 61
  setgrent();
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp = __errno_location();
#line 67
    *tmp = 0;
#line 68
    grp = getgrent();
    }
#line 69
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 70
      goto while_break;
    }
#line 72
    cp = grp->gr_mem;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! *cp) {
#line 72
        goto while_break___0;
      }
      {
#line 76
      tmp___0 = strcmp(username, (char const   *)*cp);
      }
#line 76
      if (! (tmp___0 == 0)) {
#line 77
        goto __Cont;
      }
#line 80
      n = 0;
      {
#line 80
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 80
        if (! (n < count)) {
#line 80
          goto while_break___1;
        }
#line 81
        if (grouplist) {
#line 81
          if (*(grouplist + n) == grp->gr_gid) {
#line 82
            goto while_break___1;
          }
        }
#line 80
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 85
      if (n == count) {
#line 87
        if (maxcount != 0) {
#line 89
          if (count >= maxcount) {
#line 90
            goto done;
          }
#line 91
          *(grouplist + count) = grp->gr_gid;
        }
#line 93
        if (count == 2147483647) {
          {
#line 95
          tmp___1 = __errno_location();
#line 95
          *tmp___1 = 75;
          }
#line 96
          goto done;
        }
#line 98
        count ++;
      }
      __Cont: /* CIL Label */ 
#line 72
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  tmp___2 = __errno_location();
  }
#line 103
  if (*tmp___2 != 0) {
#line 104
    count = -1;
  }
  done: 
  {
#line 108
  tmp___3 = __errno_location();
#line 108
  saved_errno = *tmp___3;
#line 109
  endgrent();
#line 110
  tmp___4 = __errno_location();
#line 110
  *tmp___4 = saved_errno;
  }
#line 113
  return (count);
}
}
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/timespec.h"
void gettime(struct timespec *ts ) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;

  {
  {
#line 36
  tmp = clock_gettime(0, ts);
  }
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
  {
#line 42
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
#line 48
  return;
}
}
#line 949 "/usr/include/unistd.h"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 137
extern struct _IO_FILE *stderr ;
#line 213
extern int fflush_unlocked(FILE *__stream ) ;
#line 545
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 349 "./stdio.h"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) ;
#line 82 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fsetlocking)(FILE *__fp ,
                                                                                    int __type ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 78 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static void call_fclose(void *arg ) 
{ 


  {
#line 81
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 82
    fclose((FILE *)arg);
    }
  }
#line 83
  return;
}
}
#line 92 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static char *buf  ;
#line 93 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static size_t bufsize  ;
#line 85 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) 
{ 
  FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 91
  tty_changed = (_Bool)0;
#line 99
  tty = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w+");
  }
#line 100
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 102
    in = stdin;
#line 103
    out = stderr;
  } else {
    {
#line 108
    __fsetlocking(tty, 2);
#line 110
    in = tty;
#line 110
    out = in;
    }
  }
  {
#line 117
  tmp___1 = fileno(in);
#line 117
  tmp___2 = tcgetattr(tmp___1, & t);
  }
#line 117
  if (tmp___2 == 0) {
    {
#line 120
    s = t;
#line 122
    t.c_lflag &= 4294967286U;
#line 123
    tmp = fileno(in);
#line 123
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
#line 123
    tty_changed = (_Bool )(tmp___0 == 0);
    }
  }
  {
#line 128
  fputs_unlocked((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)out);
#line 129
  fflush_unlocked(out);
#line 132
  nread = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                  (FILE */* __restrict  */)in);
#line 143
  rpl_fseeko(out, (off_t )0, 1);
  }
#line 145
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 147
    if (nread < 0L) {
#line 148
      *(buf + 0) = (char )'\000';
    } else
#line 149
    if ((int )*(buf + (nread - 1L)) == 10) {
#line 152
      *(buf + (nread - 1L)) = (char )'\000';
#line 153
      if (tty_changed) {
        {
#line 156
        putc_unlocked('\n', out);
        }
      }
    }
  }
#line 163
  if (tty_changed) {
    {
#line 164
    tmp___3 = fileno(in);
#line 164
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
    }
  }
  {
#line 169
  call_fclose((void *)tty);
  }
#line 171
  return (buf);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/getndelim2.h"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadptr.h"
char const   *freadptr(FILE *fp , size_t *sizep ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadseek.h"
int freadseek(FILE *fp , size_t offset ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) ;
#line 70 "/home/khheo/project/benchmark/coreutils-7.1/lib/getndelim2.c"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) 
{ 
  size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  _Bool found_delimiter ;
  void *tmp ;
  int c ;
  char const   *buffer ;
  size_t buffer_len ;
  char const   *end ;
  void *tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  char *newptr ;
  size_t newsizemax ;
  void *tmp___2 ;
  size_t copy_len ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 76
  bytes_stored = (ssize_t )-1;
#line 77
  ptr = *lineptr;
#line 78
  size = *linesize;
#line 81
  if (! ptr) {
#line 83
    if (nmax < 64UL) {
#line 83
      size = nmax;
    } else {
#line 83
      size = (size_t )64;
    }
    {
#line 84
    tmp = malloc(size);
#line 84
    ptr = (char *)tmp;
    }
#line 85
    if (! ptr) {
#line 86
      return ((ssize_t )-1);
    }
  }
#line 89
  if (size < offset) {
#line 90
    goto done;
  }
#line 92
  nbytes_avail = size - offset;
#line 93
  read_pos = ptr + offset;
#line 95
  if (nbytes_avail == 0UL) {
#line 95
    if (nmax <= size) {
#line 96
      goto done;
    }
  }
#line 99
  if (delim1 == -1) {
#line 100
    delim1 = delim2;
  } else
#line 101
  if (delim2 == -1) {
#line 102
    delim2 = delim1;
  }
#line 106
  found_delimiter = (_Bool)0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    buffer = freadptr(stream, & buffer_len);
    }
#line 117
    if (buffer) {
#line 119
      if (delim1 != -1) {
        {
#line 121
        tmp___0 = memchr2((void const   *)buffer, delim1, delim2, buffer_len);
#line 121
        end = (char const   *)tmp___0;
        }
#line 122
        if (end) {
#line 124
          buffer_len = (size_t )((end - buffer) + 1L);
#line 125
          found_delimiter = (_Bool)1;
        }
      }
    } else {
      {
#line 131
      c = getc_unlocked(stream);
      }
#line 132
      if (c == -1) {
#line 135
        if ((unsigned long )read_pos == (unsigned long )ptr) {
#line 136
          goto unlock_done;
        } else {
#line 138
          goto while_break;
        }
      }
#line 140
      if (c == delim1) {
#line 141
        found_delimiter = (_Bool)1;
      } else
#line 140
      if (c == delim2) {
#line 141
        found_delimiter = (_Bool)1;
      }
#line 142
      buffer_len = (size_t )1;
    }
#line 149
    if (nbytes_avail < buffer_len + 1UL) {
#line 149
      if (size < nmax) {
#line 153
        if (size < 64UL) {
#line 153
          tmp___1 = size + 64UL;
        } else {
#line 153
          tmp___1 = 2UL * size;
        }
#line 153
        newsize = tmp___1;
#line 158
        if (newsize - (size_t )(read_pos - ptr) < buffer_len + 1UL) {
#line 159
          newsize = ((size_t )(read_pos - ptr) + buffer_len) + 1UL;
        }
#line 161
        if (size < newsize) {
#line 161
          if (! (newsize <= nmax)) {
#line 162
            newsize = nmax;
          }
        } else {
#line 162
          newsize = nmax;
        }
#line 164
        if (9223372036854775807UL < newsize - offset) {
#line 166
          newsizemax = (offset + 9223372036854775807UL) + 1UL;
#line 167
          if (size == newsizemax) {
#line 168
            goto unlock_done;
          }
#line 169
          newsize = newsizemax;
        }
        {
#line 172
        nbytes_avail = newsize - (size_t )(read_pos - ptr);
#line 173
        tmp___2 = realloc((void *)ptr, newsize);
#line 173
        newptr = (char *)tmp___2;
        }
#line 174
        if (! newptr) {
#line 175
          goto unlock_done;
        }
#line 176
        ptr = newptr;
#line 177
        size = newsize;
#line 178
        read_pos = ptr + (size - nbytes_avail);
      }
    }
#line 184
    if (1UL < nbytes_avail) {
#line 186
      copy_len = nbytes_avail - 1UL;
#line 187
      if (buffer_len < copy_len) {
#line 188
        copy_len = buffer_len;
      }
#line 189
      if (buffer) {
        {
#line 190
        memcpy((void */* __restrict  */)read_pos, (void const   */* __restrict  */)buffer,
               copy_len);
        }
      } else {
#line 192
        *read_pos = (char )c;
      }
#line 193
      read_pos += copy_len;
#line 194
      nbytes_avail -= copy_len;
    }
#line 199
    if (buffer) {
      {
#line 199
      tmp___3 = freadseek(stream, buffer_len);
      }
#line 199
      if (tmp___3) {
#line 200
        goto unlock_done;
      }
    }
#line 107
    if (! (! found_delimiter)) {
#line 107
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  *read_pos = (char )'\000';
#line 208
  bytes_stored = read_pos - (ptr + offset);
  unlock_done: ;
  done: 
#line 214
  *lineptr = ptr;
#line 215
  *linesize = size;
#line 216
  if (bytes_stored) {
#line 216
    tmp___4 = bytes_stored;
  } else {
#line 216
    tmp___4 = (ssize_t )-1;
  }
#line 216
  return (tmp___4);
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/xtime.h"
__inline static xtime_t xtime_make(xtime_t s , long ns ) 
{ 


  {
#line 48
  return (1000000000LL * s + (xtime_t )ns);
}
}
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/gethrxtime.h"
xtime_t gethrxtime(void) ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/gethrxtime.c"
xtime_t gethrxtime(void) 
{ 
  struct timespec ts ;
  xtime_t tmp ;
  int tmp___0 ;
  struct timespec ts___0 ;
  xtime_t tmp___1 ;

  {
  {
#line 46
  tmp___0 = clock_gettime(1, & ts);
  }
#line 46
  if (tmp___0 == 0) {
    {
#line 47
    tmp = xtime_make((xtime_t )ts.tv_sec, ts.tv_nsec);
    }
#line 47
    return (tmp);
  }
  {
#line 63
  gettime(& ts___0);
#line 64
  tmp___1 = xtime_make((xtime_t )ts___0.tv_sec, ts___0.tv_nsec);
  }
#line 64
  return (tmp___1);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 82 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/getdate.h"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 124 "./c-ctype.h"
_Bool c_isalpha(int c ) ;
#line 132
_Bool c_isspace(int c ) ;
#line 137
int c_toupper(int c ) ;
#line 650 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 654
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 837
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 206 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 207
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 208
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 213 "getdate.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 216
  if (pc->dates_seen) {
#line 216
    if (! pc->year.digits) {
#line 216
      if (! pc->rels_seen) {
#line 216
        if (pc->times_seen) {
#line 218
          pc->year = text_int;
        } else
#line 216
        if (2UL < text_int.digits) {
#line 218
          pc->year = text_int;
        } else {
#line 216
          goto _L___1;
        }
      } else {
#line 216
        goto _L___1;
      }
    } else {
#line 216
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 221
  if (4UL < text_int.digits) {
#line 223
    (pc->dates_seen) ++;
#line 224
    pc->day = text_int.value % 100L;
#line 225
    pc->month = (text_int.value / 100L) % 100L;
#line 226
    pc->year.value = text_int.value / 10000L;
#line 227
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 231
    (pc->times_seen) ++;
#line 232
    if (text_int.digits <= 2UL) {
#line 234
      pc->hour = text_int.value;
#line 235
      pc->minutes = 0L;
    } else {
#line 239
      pc->hour = text_int.value / 100L;
#line 240
      pc->minutes = text_int.value % 100L;
    }
#line 242
    pc->seconds.tv_sec = (__time_t )0;
#line 243
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 244
    pc->meridian = 2;
  }
#line 247
  return;
}
}
#line 250 "getdate.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 253
  pc->rel.ns += (long )factor * rel.ns;
#line 254
  pc->rel.seconds += (long )factor * rel.seconds;
#line 255
  pc->rel.minutes += (long )factor * rel.minutes;
#line 256
  pc->rel.hour += (long )factor * rel.hour;
#line 257
  pc->rel.day += (long )factor * rel.day;
#line 258
  pc->rel.month += (long )factor * rel.month;
#line 259
  pc->rel.year += (long )factor * rel.year;
#line 260
  pc->rels_seen = (_Bool)1;
#line 261
  return;
}
}
#line 264 "getdate.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 268
  pc->hour = hour;
#line 269
  pc->minutes = minutes;
#line 270
  pc->seconds.tv_sec = sec;
#line 271
  pc->seconds.tv_nsec = nsec;
#line 272
  return;
}
}
#line 683 "getdate.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 683 "getdate.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 804 "getdate.c"
static yytype_uint8 const   yyr1[83]  = 
#line 804
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47};
#line 818 "getdate.c"
static yytype_uint8 const   yyr2[83]  = 
#line 818
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 834 "getdate.c"
static yytype_uint8 const   yydefact[100]  = 
#line 834
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )74,      (yytype_uint8 const   )76,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )45,      (yytype_uint8 const   )48,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )62,      (yytype_uint8 const   )51,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )41,      (yytype_uint8 const   )63,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )28,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )43,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )26,      (yytype_uint8 const   )79,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )66,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )34,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )79,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19};
#line 849 "getdate.c"
static yytype_int8 const   yydefgoto[21]  = 
#line 849
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33, 
        (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37, 
        (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )40,      (yytype_int8 const   )41,      (yytype_int8 const   )81, 
        (yytype_int8 const   )92};
#line 859 "getdate.c"
static yytype_int8 const   yypact[100]  = 
#line 859
  {      (yytype_int8 const   )-17,      (yytype_int8 const   )56,      (yytype_int8 const   )15,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )26,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-82,      (yytype_int8 const   )68,      (yytype_int8 const   )10, 
        (yytype_int8 const   )50,      (yytype_int8 const   )9,      (yytype_int8 const   )59,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )72,      (yytype_int8 const   )73,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )80,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )65,      (yytype_int8 const   )61,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )17,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )60,      (yytype_int8 const   )44, 
        (yytype_int8 const   )67,      (yytype_int8 const   )69,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-7,      (yytype_int8 const   )62,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )75,      (yytype_int8 const   )-82,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82};
#line 874 "getdate.c"
static yytype_int8 const   yypgoto[21]  = 
#line 874
  {      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-6,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-81, 
        (yytype_int8 const   )-3};
#line 886 "getdate.c"
static yytype_uint8 const   yytable[99]  = 
#line 886
  {      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )1,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )94,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )91,      (yytype_uint8 const   )6,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )73,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )42,      (yytype_uint8 const   )52,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )89,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )74,      (yytype_uint8 const   )97,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )95,      (yytype_uint8 const   )79,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )80};
#line 900 "getdate.c"
static yytype_int8 const   yycheck[99]  = 
#line 900
  {      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )23,      (yytype_int8 const   )12, 
        (yytype_int8 const   )15,      (yytype_int8 const   )90,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )19,      (yytype_int8 const   )4,      (yytype_int8 const   )19,      (yytype_int8 const   )0, 
        (yytype_int8 const   )97,      (yytype_int8 const   )24,      (yytype_int8 const   )20,      (yytype_int8 const   )24, 
        (yytype_int8 const   )22,      (yytype_int8 const   )26,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )24,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )12,      (yytype_int8 const   )19, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )15,      (yytype_int8 const   )25, 
        (yytype_int8 const   )4,      (yytype_int8 const   )27,      (yytype_int8 const   )19,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )3, 
        (yytype_int8 const   )19,      (yytype_int8 const   )91,      (yytype_int8 const   )25,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )20, 
        (yytype_int8 const   )95,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )24};
#line 916 "getdate.c"
static yytype_uint8 const   yystos[100]  = 
#line 916
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )25,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )39,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )46,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )26,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )19,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46};
#line 1424 "getdate.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 


  {
#line 1438
  if (! yymsg) {
#line 1439
    yymsg = "Deleting";
  }
  {
#line 1445
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1446
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 1459
int yyparse(parser_control *pc ) ;
#line 1486 "getdate.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;

  {
#line 1546
  yylen = 0;
#line 1548
  yytoken = 0;
#line 1549
  yyss = yyssa;
#line 1550
  yyvs = yyvsa;
#line 1551
  yystacksize = 20UL;
#line 1555
  yystate = 0;
#line 1556
  yyerrstatus = 0;
#line 1557
  yynerrs = 0;
#line 1558
  yychar = -2;
#line 1564
  yyssp = yyss;
#line 1565
  yyvsp = yyvs;
#line 1567
  goto yysetstate;
  yynewstate: 
#line 1575
  yyssp ++;
  yysetstate: 
#line 1578
  *yyssp = (yytype_int16 )yystate;
#line 1580
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1583
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1610
    if (20UL <= yystacksize) {
#line 1611
      goto yyexhaustedlab;
    }
#line 1612
    yystacksize *= 2UL;
#line 1613
    if (20UL < yystacksize) {
#line 1614
      yystacksize = 20UL;
    }
    {
#line 1617
    yyss1 = yyss;
#line 1618
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1618
    yyptr = (union yyalloc *)tmp;
    }
#line 1620
    if (! yyptr) {
#line 1621
      goto yyexhaustedlab;
    }
    {
#line 1622
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1622
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1622
      yyss = & yyptr->yyss_alloc;
#line 1622
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1622
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1622
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1623
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1623
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1623
      yyvs = & yyptr->yyvs_alloc;
#line 1623
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1623
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1623
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1625
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1626
      free((void *)yyss1);
      }
    }
#line 1631
    yyssp = (yyss + yysize) - 1;
#line 1632
    yyvsp = (yyvs + yysize) - 1;
#line 1637
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1638
      goto yyabortlab;
    }
  }
#line 1643
  if (yystate == 12) {
#line 1644
    goto yyacceptlab;
  }
#line 1646
  goto yybackup;
  yybackup: 
#line 1657
  yyn = (int )yypact[yystate];
#line 1658
  if (yyn == -82) {
#line 1659
    goto yydefault;
  }
#line 1664
  if (yychar == -2) {
    {
#line 1667
    yychar = yylex(& yylval, pc);
    }
  }
#line 1670
  if (yychar <= 0) {
#line 1672
    yytoken = 0;
#line 1672
    yychar = yytoken;
  } else
#line 1677
  if ((unsigned int )yychar <= 277U) {
#line 1677
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1677
    yytoken = 2;
  }
#line 1683
  yyn += yytoken;
#line 1684
  if (yyn < 0) {
#line 1685
    goto yydefault;
  } else
#line 1684
  if (98 < yyn) {
#line 1685
    goto yydefault;
  } else
#line 1684
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1685
    goto yydefault;
  }
#line 1686
  yyn = (int )yytable[yyn];
#line 1687
  if (yyn <= 0) {
#line 1689
    if (yyn == 0) {
#line 1690
      goto yyerrlab;
    } else
#line 1689
    if (yyn == -1) {
#line 1690
      goto yyerrlab;
    }
#line 1691
    yyn = - yyn;
#line 1692
    goto yyreduce;
  }
#line 1697
  if (yyerrstatus) {
#line 1698
    yyerrstatus --;
  }
#line 1704
  yychar = -2;
#line 1706
  yystate = yyn;
#line 1707
  yyvsp ++;
#line 1707
  *yyvsp = yylval;
#line 1709
  goto yynewstate;
  yydefault: 
#line 1716
  yyn = (int )yydefact[yystate];
#line 1717
  if (yyn == 0) {
#line 1718
    goto yyerrlab;
  }
#line 1719
  goto yyreduce;
  yyreduce: 
#line 1727
  yylen = (int )yyr2[yyn];
#line 1737
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1743
  if (yyn == 4) {
#line 1743
    goto case_4;
  }
#line 324
  if (yyn == 7) {
#line 324 "getdate.y"
    goto case_7;
  }
#line 334
  if (yyn == 8) {
#line 334
    goto case_8;
  }
#line 336
  if (yyn == 9) {
#line 336
    goto case_9;
  }
#line 338
  if (yyn == 10) {
#line 338
    goto case_10;
  }
#line 340
  if (yyn == 11) {
#line 340
    goto case_11;
  }
#line 342
  if (yyn == 15) {
#line 342
    goto case_15;
  }
#line 353
  if (yyn == 16) {
#line 353
    goto case_16;
  }
#line 358
  if (yyn == 17) {
#line 358
    goto case_17;
  }
#line 365
  if (yyn == 18) {
#line 365
    goto case_18;
  }
#line 370
  if (yyn == 19) {
#line 370
    goto case_19;
  }
#line 377
  if (yyn == 20) {
#line 377
    goto case_20;
  }
#line 385
  if (yyn == 21) {
#line 385
    goto case_21;
  }
#line 390
  if (yyn == 22) {
#line 390
    goto case_22;
  }
#line 395
  if (yyn == 23) {
#line 395
    goto case_23;
  }
#line 398
  if (yyn == 24) {
#line 398
    goto case_24;
  }
#line 400
  if (yyn == 25) {
#line 400
    goto case_25;
  }
#line 402
  if (yyn == 26) {
#line 402
    goto case_26;
  }
#line 404
  if (yyn == 27) {
#line 404
    goto case_27;
  }
#line 412
  if (yyn == 28) {
#line 412
    goto case_28;
  }
#line 417
  if (yyn == 29) {
#line 417
    goto case_29;
  }
#line 422
  if (yyn == 30) {
#line 422
    goto case_30;
  }
#line 427
  if (yyn == 31) {
#line 427
    goto case_31;
  }
#line 435
  if (yyn == 32) {
#line 435
    goto case_32;
  }
#line 455
  if (yyn == 33) {
#line 455
    goto case_33;
  }
#line 462
  if (yyn == 34) {
#line 462
    goto case_34;
  }
#line 470
  if (yyn == 35) {
#line 470
    goto case_35;
  }
#line 478
  if (yyn == 36) {
#line 478
    goto case_36;
  }
#line 483
  if (yyn == 37) {
#line 483
    goto case_37;
  }
#line 489
  if (yyn == 38) {
#line 489
    goto case_38;
  }
#line 494
  if (yyn == 39) {
#line 494
    goto case_39;
  }
#line 500
  if (yyn == 40) {
#line 500
    goto case_40;
  }
#line 505
  if (yyn == 41) {
#line 505
    goto case_41;
  }
#line 507
  if (yyn == 42) {
#line 507
    goto case_42;
  }
#line 509
  if (yyn == 43) {
#line 509
    goto case_43;
  }
#line 514
  if (yyn == 44) {
#line 514
    goto case_44;
  }
#line 516
  if (yyn == 45) {
#line 516
    goto case_45;
  }
#line 518
  if (yyn == 46) {
#line 518
    goto case_46;
  }
#line 520
  if (yyn == 47) {
#line 520
    goto case_47;
  }
#line 522
  if (yyn == 48) {
#line 522
    goto case_48;
  }
#line 524
  if (yyn == 49) {
#line 524
    goto case_49;
  }
#line 526
  if (yyn == 50) {
#line 526
    goto case_50;
  }
#line 528
  if (yyn == 51) {
#line 528
    goto case_51;
  }
#line 530
  if (yyn == 52) {
#line 530
    goto case_52;
  }
#line 532
  if (yyn == 53) {
#line 532
    goto case_53;
  }
#line 534
  if (yyn == 54) {
#line 534
    goto case_54;
  }
#line 536
  if (yyn == 55) {
#line 536
    goto case_55;
  }
#line 538
  if (yyn == 56) {
#line 538
    goto case_56;
  }
#line 540
  if (yyn == 57) {
#line 540
    goto case_57;
  }
#line 542
  if (yyn == 58) {
#line 542
    goto case_58;
  }
#line 544
  if (yyn == 59) {
#line 544
    goto case_59;
  }
#line 546
  if (yyn == 60) {
#line 546
    goto case_60;
  }
#line 548
  if (yyn == 61) {
#line 548
    goto case_61;
  }
#line 550
  if (yyn == 62) {
#line 550
    goto case_62;
  }
#line 552
  if (yyn == 64) {
#line 552
    goto case_64;
  }
#line 558
  if (yyn == 65) {
#line 558
    goto case_65;
  }
#line 560
  if (yyn == 66) {
#line 560
    goto case_66;
  }
#line 562
  if (yyn == 67) {
#line 562
    goto case_67;
  }
#line 564
  if (yyn == 68) {
#line 564
    goto case_68;
  }
#line 566
  if (yyn == 69) {
#line 566
    goto case_69;
  }
#line 568
  if (yyn == 70) {
#line 568
    goto case_70;
  }
#line 573
  if (yyn == 74) {
#line 573
    goto case_74;
  }
#line 581
  if (yyn == 76) {
#line 581
    goto case_76;
  }
#line 587
  if (yyn == 77) {
#line 587
    goto case_77;
  }
#line 592
  if (yyn == 78) {
#line 592
    goto case_78;
  }
#line 602
  if (yyn == 79) {
#line 602
    goto case_79;
  }
#line 607
  if (yyn == 80) {
#line 607
    goto case_80;
  }
#line 609
  if (yyn == 81) {
#line 609
    goto case_81;
  }
#line 614
  if (yyn == 82) {
#line 614
    goto case_82;
  }
#line 2328 "getdate.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 319 "getdate.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 320
  pc->timespec_seen = (_Bool)1;
#line 322
  goto switch_break;
  case_7: /* CIL Label */ 
#line 331
  (pc->times_seen) ++;
#line 332
  goto switch_break;
  case_8: /* CIL Label */ 
#line 333
  (pc->local_zones_seen) ++;
#line 334
  goto switch_break;
  case_9: /* CIL Label */ 
#line 335
  (pc->zones_seen) ++;
#line 336
  goto switch_break;
  case_10: /* CIL Label */ 
#line 337
  (pc->dates_seen) ++;
#line 338
  goto switch_break;
  case_11: /* CIL Label */ 
#line 339
  (pc->days_seen) ++;
#line 340
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 348
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 349
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 351
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 353
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 354
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 356
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 358
  set_hhmmss(pc, (yyvsp + -4)->textintval.value, (yyvsp + -2)->textintval.value, (time_t )0,
             0L);
#line 359
  pc->meridian = 2;
#line 360
  (pc->zones_seen) ++;
#line 361
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 363
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 365
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 366
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 368
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 370
  set_hhmmss(pc, (yyvsp + -6)->textintval.value, (yyvsp + -4)->textintval.value, (yyvsp + -2)->timespec.tv_sec,
             (yyvsp + -2)->timespec.tv_nsec);
#line 371
  pc->meridian = 2;
#line 372
  (pc->zones_seen) ++;
#line 373
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 375
  goto switch_break;
  case_20: /* CIL Label */ 
#line 380
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 381
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 383
  goto switch_break;
  case_21: /* CIL Label */ 
#line 385
  pc->local_isdst = 1;
#line 386
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 388
  goto switch_break;
  case_22: /* CIL Label */ 
#line 392
  pc->time_zone = (yyvsp + 0)->intval;
#line 393
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 394
  pc->time_zone = (yyvsp + -1)->intval;
#line 395
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 396
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 397
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 397
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  }
#line 398
  goto switch_break;
  case_25: /* CIL Label */ 
#line 399
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 400
  goto switch_break;
  case_26: /* CIL Label */ 
#line 401
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 402
  goto switch_break;
  case_27: /* CIL Label */ 
#line 407
  pc->day_ordinal = 1L;
#line 408
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 410
  goto switch_break;
  case_28: /* CIL Label */ 
#line 412
  pc->day_ordinal = 1L;
#line 413
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 415
  goto switch_break;
  case_29: /* CIL Label */ 
#line 417
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 418
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 420
  goto switch_break;
  case_30: /* CIL Label */ 
#line 422
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 423
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 425
  goto switch_break;
  case_31: /* CIL Label */ 
#line 430
  pc->month = (yyvsp + -2)->textintval.value;
#line 431
  pc->day = (yyvsp + 0)->textintval.value;
#line 433
  goto switch_break;
  case_32: /* CIL Label */ 
#line 440
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 442
    pc->year = (yyvsp + -4)->textintval;
#line 443
    pc->month = (yyvsp + -2)->textintval.value;
#line 444
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 448
    pc->month = (yyvsp + -4)->textintval.value;
#line 449
    pc->day = (yyvsp + -2)->textintval.value;
#line 450
    pc->year = (yyvsp + 0)->textintval;
  }
#line 453
  goto switch_break;
  case_33: /* CIL Label */ 
#line 456
  pc->year = (yyvsp + -2)->textintval;
#line 457
  pc->month = - (yyvsp + -1)->textintval.value;
#line 458
  pc->day = - (yyvsp + 0)->textintval.value;
#line 460
  goto switch_break;
  case_34: /* CIL Label */ 
#line 463
  pc->day = (yyvsp + -2)->textintval.value;
#line 464
  pc->month = (yyvsp + -1)->intval;
#line 465
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 466
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 468
  goto switch_break;
  case_35: /* CIL Label */ 
#line 471
  pc->month = (yyvsp + -2)->intval;
#line 472
  pc->day = - (yyvsp + -1)->textintval.value;
#line 473
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 474
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 476
  goto switch_break;
  case_36: /* CIL Label */ 
#line 478
  pc->month = (yyvsp + -1)->intval;
#line 479
  pc->day = (yyvsp + 0)->textintval.value;
#line 481
  goto switch_break;
  case_37: /* CIL Label */ 
#line 483
  pc->month = (yyvsp + -3)->intval;
#line 484
  pc->day = (yyvsp + -2)->textintval.value;
#line 485
  pc->year = (yyvsp + 0)->textintval;
#line 487
  goto switch_break;
  case_38: /* CIL Label */ 
#line 489
  pc->day = (yyvsp + -1)->textintval.value;
#line 490
  pc->month = (yyvsp + 0)->intval;
#line 492
  goto switch_break;
  case_39: /* CIL Label */ 
#line 494
  pc->day = (yyvsp + -2)->textintval.value;
#line 495
  pc->month = (yyvsp + -1)->intval;
#line 496
  pc->year = (yyvsp + 0)->textintval;
#line 498
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 502
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
  }
#line 503
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 504
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 505
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 506
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 507
  goto switch_break;
  case_43: /* CIL Label */ 
#line 511
  __constr_expr_0.year = 0L;
#line 511
  __constr_expr_0.month = 0L;
#line 511
  __constr_expr_0.day = 0L;
#line 511
  __constr_expr_0.hour = 0L;
#line 511
  __constr_expr_0.minutes = 0L;
#line 511
  __constr_expr_0.seconds = 0L;
#line 511
  __constr_expr_0.ns = 0L;
#line 511
  yyval.rel = __constr_expr_0;
#line 511
  yyval.rel.year = (yyvsp + -1)->intval;
#line 512
  goto switch_break;
  case_44: /* CIL Label */ 
#line 513
  __constr_expr_1.year = 0L;
#line 513
  __constr_expr_1.month = 0L;
#line 513
  __constr_expr_1.day = 0L;
#line 513
  __constr_expr_1.hour = 0L;
#line 513
  __constr_expr_1.minutes = 0L;
#line 513
  __constr_expr_1.seconds = 0L;
#line 513
  __constr_expr_1.ns = 0L;
#line 513
  yyval.rel = __constr_expr_1;
#line 513
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 514
  goto switch_break;
  case_45: /* CIL Label */ 
#line 515
  __constr_expr_2.year = 0L;
#line 515
  __constr_expr_2.month = 0L;
#line 515
  __constr_expr_2.day = 0L;
#line 515
  __constr_expr_2.hour = 0L;
#line 515
  __constr_expr_2.minutes = 0L;
#line 515
  __constr_expr_2.seconds = 0L;
#line 515
  __constr_expr_2.ns = 0L;
#line 515
  yyval.rel = __constr_expr_2;
#line 515
  yyval.rel.year = 1L;
#line 516
  goto switch_break;
  case_46: /* CIL Label */ 
#line 517
  __constr_expr_3.year = 0L;
#line 517
  __constr_expr_3.month = 0L;
#line 517
  __constr_expr_3.day = 0L;
#line 517
  __constr_expr_3.hour = 0L;
#line 517
  __constr_expr_3.minutes = 0L;
#line 517
  __constr_expr_3.seconds = 0L;
#line 517
  __constr_expr_3.ns = 0L;
#line 517
  yyval.rel = __constr_expr_3;
#line 517
  yyval.rel.month = (yyvsp + -1)->intval;
#line 518
  goto switch_break;
  case_47: /* CIL Label */ 
#line 519
  __constr_expr_4.year = 0L;
#line 519
  __constr_expr_4.month = 0L;
#line 519
  __constr_expr_4.day = 0L;
#line 519
  __constr_expr_4.hour = 0L;
#line 519
  __constr_expr_4.minutes = 0L;
#line 519
  __constr_expr_4.seconds = 0L;
#line 519
  __constr_expr_4.ns = 0L;
#line 519
  yyval.rel = __constr_expr_4;
#line 519
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 520
  goto switch_break;
  case_48: /* CIL Label */ 
#line 521
  __constr_expr_5.year = 0L;
#line 521
  __constr_expr_5.month = 0L;
#line 521
  __constr_expr_5.day = 0L;
#line 521
  __constr_expr_5.hour = 0L;
#line 521
  __constr_expr_5.minutes = 0L;
#line 521
  __constr_expr_5.seconds = 0L;
#line 521
  __constr_expr_5.ns = 0L;
#line 521
  yyval.rel = __constr_expr_5;
#line 521
  yyval.rel.month = 1L;
#line 522
  goto switch_break;
  case_49: /* CIL Label */ 
#line 523
  __constr_expr_6.year = 0L;
#line 523
  __constr_expr_6.month = 0L;
#line 523
  __constr_expr_6.day = 0L;
#line 523
  __constr_expr_6.hour = 0L;
#line 523
  __constr_expr_6.minutes = 0L;
#line 523
  __constr_expr_6.seconds = 0L;
#line 523
  __constr_expr_6.ns = 0L;
#line 523
  yyval.rel = __constr_expr_6;
#line 523
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 524
  goto switch_break;
  case_50: /* CIL Label */ 
#line 525
  __constr_expr_7.year = 0L;
#line 525
  __constr_expr_7.month = 0L;
#line 525
  __constr_expr_7.day = 0L;
#line 525
  __constr_expr_7.hour = 0L;
#line 525
  __constr_expr_7.minutes = 0L;
#line 525
  __constr_expr_7.seconds = 0L;
#line 525
  __constr_expr_7.ns = 0L;
#line 525
  yyval.rel = __constr_expr_7;
#line 525
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 526
  goto switch_break;
  case_51: /* CIL Label */ 
#line 527
  __constr_expr_8.year = 0L;
#line 527
  __constr_expr_8.month = 0L;
#line 527
  __constr_expr_8.day = 0L;
#line 527
  __constr_expr_8.hour = 0L;
#line 527
  __constr_expr_8.minutes = 0L;
#line 527
  __constr_expr_8.seconds = 0L;
#line 527
  __constr_expr_8.ns = 0L;
#line 527
  yyval.rel = __constr_expr_8;
#line 527
  yyval.rel.day = (yyvsp + 0)->intval;
#line 528
  goto switch_break;
  case_52: /* CIL Label */ 
#line 529
  __constr_expr_9.year = 0L;
#line 529
  __constr_expr_9.month = 0L;
#line 529
  __constr_expr_9.day = 0L;
#line 529
  __constr_expr_9.hour = 0L;
#line 529
  __constr_expr_9.minutes = 0L;
#line 529
  __constr_expr_9.seconds = 0L;
#line 529
  __constr_expr_9.ns = 0L;
#line 529
  yyval.rel = __constr_expr_9;
#line 529
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 530
  goto switch_break;
  case_53: /* CIL Label */ 
#line 531
  __constr_expr_10.year = 0L;
#line 531
  __constr_expr_10.month = 0L;
#line 531
  __constr_expr_10.day = 0L;
#line 531
  __constr_expr_10.hour = 0L;
#line 531
  __constr_expr_10.minutes = 0L;
#line 531
  __constr_expr_10.seconds = 0L;
#line 531
  __constr_expr_10.ns = 0L;
#line 531
  yyval.rel = __constr_expr_10;
#line 531
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 532
  goto switch_break;
  case_54: /* CIL Label */ 
#line 533
  __constr_expr_11.year = 0L;
#line 533
  __constr_expr_11.month = 0L;
#line 533
  __constr_expr_11.day = 0L;
#line 533
  __constr_expr_11.hour = 0L;
#line 533
  __constr_expr_11.minutes = 0L;
#line 533
  __constr_expr_11.seconds = 0L;
#line 533
  __constr_expr_11.ns = 0L;
#line 533
  yyval.rel = __constr_expr_11;
#line 533
  yyval.rel.hour = 1L;
#line 534
  goto switch_break;
  case_55: /* CIL Label */ 
#line 535
  __constr_expr_12.year = 0L;
#line 535
  __constr_expr_12.month = 0L;
#line 535
  __constr_expr_12.day = 0L;
#line 535
  __constr_expr_12.hour = 0L;
#line 535
  __constr_expr_12.minutes = 0L;
#line 535
  __constr_expr_12.seconds = 0L;
#line 535
  __constr_expr_12.ns = 0L;
#line 535
  yyval.rel = __constr_expr_12;
#line 535
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 536
  goto switch_break;
  case_56: /* CIL Label */ 
#line 537
  __constr_expr_13.year = 0L;
#line 537
  __constr_expr_13.month = 0L;
#line 537
  __constr_expr_13.day = 0L;
#line 537
  __constr_expr_13.hour = 0L;
#line 537
  __constr_expr_13.minutes = 0L;
#line 537
  __constr_expr_13.seconds = 0L;
#line 537
  __constr_expr_13.ns = 0L;
#line 537
  yyval.rel = __constr_expr_13;
#line 537
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 538
  goto switch_break;
  case_57: /* CIL Label */ 
#line 539
  __constr_expr_14.year = 0L;
#line 539
  __constr_expr_14.month = 0L;
#line 539
  __constr_expr_14.day = 0L;
#line 539
  __constr_expr_14.hour = 0L;
#line 539
  __constr_expr_14.minutes = 0L;
#line 539
  __constr_expr_14.seconds = 0L;
#line 539
  __constr_expr_14.ns = 0L;
#line 539
  yyval.rel = __constr_expr_14;
#line 539
  yyval.rel.minutes = 1L;
#line 540
  goto switch_break;
  case_58: /* CIL Label */ 
#line 541
  __constr_expr_15.year = 0L;
#line 541
  __constr_expr_15.month = 0L;
#line 541
  __constr_expr_15.day = 0L;
#line 541
  __constr_expr_15.hour = 0L;
#line 541
  __constr_expr_15.minutes = 0L;
#line 541
  __constr_expr_15.seconds = 0L;
#line 541
  __constr_expr_15.ns = 0L;
#line 541
  yyval.rel = __constr_expr_15;
#line 541
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 542
  goto switch_break;
  case_59: /* CIL Label */ 
#line 543
  __constr_expr_16.year = 0L;
#line 543
  __constr_expr_16.month = 0L;
#line 543
  __constr_expr_16.day = 0L;
#line 543
  __constr_expr_16.hour = 0L;
#line 543
  __constr_expr_16.minutes = 0L;
#line 543
  __constr_expr_16.seconds = 0L;
#line 543
  __constr_expr_16.ns = 0L;
#line 543
  yyval.rel = __constr_expr_16;
#line 543
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 544
  goto switch_break;
  case_60: /* CIL Label */ 
#line 545
  __constr_expr_17.year = 0L;
#line 545
  __constr_expr_17.month = 0L;
#line 545
  __constr_expr_17.day = 0L;
#line 545
  __constr_expr_17.hour = 0L;
#line 545
  __constr_expr_17.minutes = 0L;
#line 545
  __constr_expr_17.seconds = 0L;
#line 545
  __constr_expr_17.ns = 0L;
#line 545
  yyval.rel = __constr_expr_17;
#line 545
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 545
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 546
  goto switch_break;
  case_61: /* CIL Label */ 
#line 547
  __constr_expr_18.year = 0L;
#line 547
  __constr_expr_18.month = 0L;
#line 547
  __constr_expr_18.day = 0L;
#line 547
  __constr_expr_18.hour = 0L;
#line 547
  __constr_expr_18.minutes = 0L;
#line 547
  __constr_expr_18.seconds = 0L;
#line 547
  __constr_expr_18.ns = 0L;
#line 547
  yyval.rel = __constr_expr_18;
#line 547
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 547
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 548
  goto switch_break;
  case_62: /* CIL Label */ 
#line 549
  __constr_expr_19.year = 0L;
#line 549
  __constr_expr_19.month = 0L;
#line 549
  __constr_expr_19.day = 0L;
#line 549
  __constr_expr_19.hour = 0L;
#line 549
  __constr_expr_19.minutes = 0L;
#line 549
  __constr_expr_19.seconds = 0L;
#line 549
  __constr_expr_19.ns = 0L;
#line 549
  yyval.rel = __constr_expr_19;
#line 549
  yyval.rel.seconds = 1L;
#line 550
  goto switch_break;
  case_64: /* CIL Label */ 
#line 555
  __constr_expr_20.year = 0L;
#line 555
  __constr_expr_20.month = 0L;
#line 555
  __constr_expr_20.day = 0L;
#line 555
  __constr_expr_20.hour = 0L;
#line 555
  __constr_expr_20.minutes = 0L;
#line 555
  __constr_expr_20.seconds = 0L;
#line 555
  __constr_expr_20.ns = 0L;
#line 555
  yyval.rel = __constr_expr_20;
#line 555
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 556
  goto switch_break;
  case_65: /* CIL Label */ 
#line 557
  __constr_expr_21.year = 0L;
#line 557
  __constr_expr_21.month = 0L;
#line 557
  __constr_expr_21.day = 0L;
#line 557
  __constr_expr_21.hour = 0L;
#line 557
  __constr_expr_21.minutes = 0L;
#line 557
  __constr_expr_21.seconds = 0L;
#line 557
  __constr_expr_21.ns = 0L;
#line 557
  yyval.rel = __constr_expr_21;
#line 557
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 558
  goto switch_break;
  case_66: /* CIL Label */ 
#line 559
  __constr_expr_22.year = 0L;
#line 559
  __constr_expr_22.month = 0L;
#line 559
  __constr_expr_22.day = 0L;
#line 559
  __constr_expr_22.hour = 0L;
#line 559
  __constr_expr_22.minutes = 0L;
#line 559
  __constr_expr_22.seconds = 0L;
#line 559
  __constr_expr_22.ns = 0L;
#line 559
  yyval.rel = __constr_expr_22;
#line 559
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 560
  goto switch_break;
  case_67: /* CIL Label */ 
#line 561
  __constr_expr_23.year = 0L;
#line 561
  __constr_expr_23.month = 0L;
#line 561
  __constr_expr_23.day = 0L;
#line 561
  __constr_expr_23.hour = 0L;
#line 561
  __constr_expr_23.minutes = 0L;
#line 561
  __constr_expr_23.seconds = 0L;
#line 561
  __constr_expr_23.ns = 0L;
#line 561
  yyval.rel = __constr_expr_23;
#line 561
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 562
  goto switch_break;
  case_68: /* CIL Label */ 
#line 563
  __constr_expr_24.year = 0L;
#line 563
  __constr_expr_24.month = 0L;
#line 563
  __constr_expr_24.day = 0L;
#line 563
  __constr_expr_24.hour = 0L;
#line 563
  __constr_expr_24.minutes = 0L;
#line 563
  __constr_expr_24.seconds = 0L;
#line 563
  __constr_expr_24.ns = 0L;
#line 563
  yyval.rel = __constr_expr_24;
#line 563
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 564
  goto switch_break;
  case_69: /* CIL Label */ 
#line 565
  __constr_expr_25.year = 0L;
#line 565
  __constr_expr_25.month = 0L;
#line 565
  __constr_expr_25.day = 0L;
#line 565
  __constr_expr_25.hour = 0L;
#line 565
  __constr_expr_25.minutes = 0L;
#line 565
  __constr_expr_25.seconds = 0L;
#line 565
  __constr_expr_25.ns = 0L;
#line 565
  yyval.rel = __constr_expr_25;
#line 565
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 566
  goto switch_break;
  case_70: /* CIL Label */ 
#line 570
  __constr_expr_26.year = 0L;
#line 570
  __constr_expr_26.month = 0L;
#line 570
  __constr_expr_26.day = 0L;
#line 570
  __constr_expr_26.hour = 0L;
#line 570
  __constr_expr_26.minutes = 0L;
#line 570
  __constr_expr_26.seconds = 0L;
#line 570
  __constr_expr_26.ns = 0L;
#line 570
  yyval.rel = __constr_expr_26;
#line 570
  yyval.rel.day = (yyvsp + 0)->intval;
#line 571
  goto switch_break;
  case_74: /* CIL Label */ 
#line 578
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 578
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 579
  goto switch_break;
  case_76: /* CIL Label */ 
#line 584
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 584
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 585
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 589
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 590
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 597
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 598
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 600
  goto switch_break;
  case_79: /* CIL Label */ 
#line 604
  yyval.intval = -1L;
#line 605
  goto switch_break;
  case_80: /* CIL Label */ 
#line 606
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 607
  goto switch_break;
  case_81: /* CIL Label */ 
#line 611
  yyval.intval = 2L;
#line 612
  goto switch_break;
  case_82: /* CIL Label */ 
#line 613
  yyval.intval = (yyvsp + 0)->intval;
#line 614
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2328 "getdate.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2332
  yyvsp -= yylen;
#line 2332
  yyssp -= yylen;
#line 2333
  yylen = 0;
#line 2336
  yyvsp ++;
#line 2336
  *yyvsp = yyval;
#line 2342
  yyn = (int )yyr1[yyn];
#line 2344
  yystate = (int )((int const   )yypgoto[yyn - 27] + (int const   )*yyssp);
#line 2345
  if (0 <= yystate) {
#line 2345
    if (yystate <= 98) {
#line 2345
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2346
        yystate = (int )yytable[yystate];
      } else {
#line 2348
        yystate = (int )yydefgoto[yyn - 27];
      }
    } else {
#line 2348
      yystate = (int )yydefgoto[yyn - 27];
    }
  } else {
#line 2348
    yystate = (int )yydefgoto[yyn - 27];
  }
#line 2350
  goto yynewstate;
  yyerrlab: 
#line 2358
  if (! yyerrstatus) {
    {
#line 2360
    yynerrs ++;
#line 2362
    yyerror((parser_control const   *)pc, "syntax error");
    }
  }
#line 2400
  if (yyerrstatus == 3) {
#line 2405
    if (yychar <= 0) {
#line 2408
      if (yychar == 0) {
#line 2409
        goto yyabortlab;
      }
    } else {
      {
#line 2413
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2415
      yychar = -2;
      }
    }
  }
#line 2421
  goto yyerrlab1;
#line 2437
  yyvsp -= yylen;
#line 2437
  yyssp -= yylen;
#line 2438
  yylen = 0;
#line 2440
  yystate = (int )*yyssp;
#line 2441
  goto yyerrlab1;
  yyerrlab1: 
#line 2448
  yyerrstatus = 3;
  {
#line 2450
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2452
    yyn = (int )yypact[yystate];
#line 2453
    if (yyn != -82) {
#line 2455
      yyn ++;
#line 2456
      if (0 <= yyn) {
#line 2456
        if (yyn <= 98) {
#line 2456
          if ((int const   )yycheck[yyn] == 1) {
#line 2458
            yyn = (int )yytable[yyn];
#line 2459
            if (0 < yyn) {
#line 2460
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2465
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2466
      goto yyabortlab;
    }
    {
#line 2469
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2471
    yyvsp --;
#line 2471
    yyssp --;
#line 2472
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2476
  yyvsp ++;
#line 2476
  *yyvsp = yylval;
#line 2482
  yystate = yyn;
#line 2483
  goto yynewstate;
  yyacceptlab: 
#line 2490
  yyresult = 0;
#line 2491
  goto yyreturn;
  yyabortlab: 
#line 2497
  yyresult = 1;
#line 2498
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2505
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2506
  yyresult = 2;
  }
  yyreturn: 
#line 2511
  if (yychar != -2) {
    {
#line 2512
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
    }
  }
#line 2516
  yyvsp -= yylen;
#line 2516
  yyssp -= yylen;
  {
#line 2518
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2518
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2518
      goto while_break___2;
    }
    {
#line 2520
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2522
    yyvsp --;
#line 2522
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2525
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2526
    free((void *)yyss);
    }
  }
#line 2533
  return (yyresult);
}
}
#line 618 "getdate.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 627 "getdate.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 632 "getdate.y"
static table const   month_and_day_table[25]  = 
#line 632
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 661 "getdate.y"
static table const   time_units_table[11]  = 
#line 661
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 677 "getdate.y"
static table const   relative_time_table[20]  = 
#line 677
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 705 "getdate.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 718 "getdate.y"
static table const   time_zone_table[48]  = 
#line 718
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 771 "getdate.y"
static table const   military_table[26]  = 
#line 771
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 273, 420}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 810 "getdate.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 817
  if (s.digits <= 2UL) {
#line 817
    if (mm < 0L) {
#line 818
      s.value *= 100L;
    }
  }
#line 820
  if (mm < 0L) {
#line 821
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 823
    if (s.negative) {
#line 823
      tmp = - mm;
    } else {
#line 823
      tmp = mm;
    }
#line 823
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 828
  tmp___0 = abs((int )n_minutes);
  }
#line 828
  if (1440 < tmp___0) {
#line 829
    (pc->zones_seen) ++;
  }
#line 831
  return (n_minutes);
}
}
#line 834 "getdate.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 842
  if (meridian == 0) {
#line 842
    goto case_0;
  }
#line 844
  if (meridian == 1) {
#line 844
    goto case_1;
  }
#line 839
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 841
  if (0L <= hours) {
#line 841
    if (hours < 24L) {
#line 841
      tmp = hours;
    } else {
#line 841
      tmp = -1L;
    }
  } else {
#line 841
    tmp = -1L;
  }
#line 841
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 843
  if (0L < hours) {
#line 843
    if (hours < 12L) {
#line 843
      tmp___1 = hours;
    } else {
#line 843
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 843
    if (hours == 12L) {
#line 843
      tmp___0 = 0;
    } else {
#line 843
      tmp___0 = -1;
    }
#line 843
    tmp___1 = (long )tmp___0;
  }
#line 843
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 845
  if (0L < hours) {
#line 845
    if (hours < 12L) {
#line 845
      tmp___3 = hours + 12L;
    } else {
#line 845
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 845
    if (hours == 12L) {
#line 845
      tmp___2 = 12;
    } else {
#line 845
      tmp___2 = -1;
    }
#line 845
    tmp___3 = (long )tmp___2;
  }
#line 845
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 849 "getdate.y"
static long to_year(textint textyear ) 
{ 
  long year___1 ;
  int tmp ;

  {
#line 852
  year___1 = textyear.value;
#line 854
  if (year___1 < 0L) {
#line 855
    year___1 = - year___1;
  } else
#line 859
  if (textyear.digits == 2UL) {
#line 860
    if (year___1 < 69L) {
#line 860
      tmp = 2000;
    } else {
#line 860
      tmp = 1900;
    }
#line 860
    year___1 += (long )tmp;
  }
#line 862
  return (year___1);
}
}
#line 865 "getdate.y"
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 870
  tp = universal_time_zone_table;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! tp->name) {
#line 870
      goto while_break;
    }
    {
#line 871
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 871
    if (tmp == 0) {
#line 872
      return (tp);
    }
#line 870
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 876
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 876
    if (! tp->name) {
#line 876
      goto while_break___0;
    }
    {
#line 877
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 877
    if (tmp___0 == 0) {
#line 878
      return (tp);
    }
#line 876
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 880
  tp = time_zone_table;
  {
#line 880
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 880
    if (! tp->name) {
#line 880
      goto while_break___1;
    }
    {
#line 881
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 881
    if (tmp___1 == 0) {
#line 882
      return (tp);
    }
#line 880
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 884
  return ((table const   *)((void *)0));
}
}
#line 914 "getdate.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;

  {
#line 925
  p = word;
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! *p) {
#line 925
      goto while_break;
    }
    {
#line 927
    ch = (unsigned char )*p;
#line 928
    tmp = c_toupper((int )ch);
#line 928
    *p = (char )tmp;
#line 925
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  tp = meridian_table;
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 931
    if (! tp->name) {
#line 931
      goto while_break___0;
    }
    {
#line 932
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 932
    if (tmp___0 == 0) {
#line 933
      return (tp);
    }
#line 931
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 936
  wordlen = strlen((char const   *)word);
  }
#line 937
  if (wordlen == 3UL) {
#line 937
    tmp___1 = 1;
  } else
#line 937
  if (wordlen == 4UL) {
#line 937
    if ((int )*(word + 3) == 46) {
#line 937
      tmp___1 = 1;
    } else {
#line 937
      tmp___1 = 0;
    }
  } else {
#line 937
    tmp___1 = 0;
  }
#line 937
  abbrev = (_Bool )tmp___1;
#line 939
  tp = month_and_day_table;
  {
#line 939
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 939
    if (! tp->name) {
#line 939
      goto while_break___1;
    }
#line 940
    if (abbrev) {
      {
#line 940
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 940
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 940
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 940
      tmp___4 = tmp___3;
      }
    }
#line 940
    if (tmp___4 == 0) {
#line 941
      return (tp);
    }
#line 939
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 943
  tp = lookup_zone(pc, (char const   *)word);
  }
#line 943
  if (tp) {
#line 944
    return (tp);
  }
  {
#line 946
  tmp___5 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
  }
#line 946
  if (tmp___5 == 0) {
#line 947
    return (dst_table);
  }
#line 949
  tp = time_units_table;
  {
#line 949
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 949
    if (! tp->name) {
#line 949
      goto while_break___2;
    }
    {
#line 950
    tmp___6 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 950
    if (tmp___6 == 0) {
#line 951
      return (tp);
    }
#line 949
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 954
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 956
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 957
    tp = time_units_table;
    {
#line 957
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 957
      if (! tp->name) {
#line 957
        goto while_break___3;
      }
      {
#line 958
      tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 958
      if (tmp___7 == 0) {
#line 959
        return (tp);
      }
#line 957
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 960
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 963
  tp = relative_time_table;
  {
#line 963
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 963
    if (! tp->name) {
#line 963
      goto while_break___4;
    }
    {
#line 964
    tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 964
    if (tmp___8 == 0) {
#line 965
      return (tp);
    }
#line 963
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 968
  if (wordlen == 1UL) {
#line 969
    tp = military_table;
    {
#line 969
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 969
      if (! tp->name) {
#line 969
        goto while_break___5;
      }
#line 970
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 971
        return (tp);
      }
#line 969
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 974
  period_found = (_Bool)0;
#line 974
  q = word;
#line 974
  p = q;
  {
#line 974
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 974
    tmp___9 = *q;
#line 974
    *p = tmp___9;
#line 974
    if (! tmp___9) {
#line 974
      goto while_break___6;
    }
#line 975
    if ((int )*q == 46) {
#line 976
      period_found = (_Bool)1;
    } else {
#line 978
      p ++;
    }
#line 974
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 979
  if (period_found) {
    {
#line 979
    tp = lookup_zone(pc, (char const   *)word);
    }
#line 979
    if (tp) {
#line 980
      return (tp);
    }
  }
#line 982
  return ((table const   *)((void *)0));
}
}
#line 985 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 993
      c = (unsigned char )*(pc->input);
#line 993
      tmp = c_isspace((int )c);
      }
#line 993
      if (! tmp) {
#line 993
        goto while_break___0;
      }
#line 994
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    if ((unsigned int )c - 48U <= 9U) {
#line 996
      goto _L___2;
    } else
#line 996
    if ((int )c == 45) {
#line 996
      goto _L___2;
    } else
#line 996
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1001
      if ((int )c == 45) {
#line 1001
        goto _L;
      } else
#line 1001
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1003
        if ((int )c == 45) {
#line 1003
          sign = -1;
        } else {
#line 1003
          sign = 1;
        }
        {
#line 1004
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1004
          (pc->input) ++;
#line 1004
          c = (unsigned char )*(pc->input);
#line 1004
          tmp___0 = c_isspace((int )c);
          }
#line 1004
          if (! tmp___0) {
#line 1004
            goto while_break___1;
          }
#line 1005
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1006
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1008
          goto __Cont;
        }
      } else {
#line 1011
        sign = 0;
      }
#line 1012
      p = pc->input;
#line 1013
      value = 0UL;
      {
#line 1013
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1015
        value1 = value + (unsigned long )((int )c - 48);
#line 1016
        if (value1 < value) {
#line 1017
          return ('?');
        }
#line 1018
        value = value1;
#line 1019
        p ++;
#line 1019
        c = (unsigned char )*p;
#line 1020
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1021
          goto while_break___2;
        }
#line 1022
        if (1844674407370955161UL < value) {
#line 1023
          return ('?');
        }
#line 1013
        value *= 10UL;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1025
      if ((int )c == 46) {
#line 1025
        goto _L___1;
      } else
#line 1025
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1025
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1033
          if (sign < 0) {
#line 1035
            s = (time_t )(- value);
#line 1036
            if (0L < s) {
#line 1037
              return ('?');
            }
#line 1038
            value1___0 = (unsigned long )(- s);
          } else {
#line 1042
            s = (time_t )value;
#line 1043
            if (s < 0L) {
#line 1044
              return ('?');
            }
#line 1045
            value1___0 = (unsigned long )s;
          }
#line 1047
          if (value != value1___0) {
#line 1048
            return ('?');
          }
#line 1051
          p ++;
#line 1052
          tmp___1 = p;
#line 1052
          p ++;
#line 1052
          ns = (int )((int const   )*tmp___1 - 48);
#line 1053
          digits = 2;
          {
#line 1053
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1053
            if (! (digits <= 9)) {
#line 1053
              goto while_break___3;
            }
#line 1055
            ns *= 10;
#line 1056
            if ((unsigned int )*p - 48U <= 9U) {
#line 1057
              tmp___2 = p;
#line 1057
              p ++;
#line 1057
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1053
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1061
          if (sign < 0) {
            {
#line 1062
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1062
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1062
                goto while_break___4;
              }
#line 1063
              if ((int const   )*p != 48) {
#line 1065
                ns ++;
#line 1066
                goto while_break___4;
              }
#line 1062
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1068
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1068
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1068
              goto while_break___5;
            }
#line 1069
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1074
          if (sign < 0) {
#line 1074
            if (ns) {
#line 1076
              s --;
#line 1077
              if (! (s < 0L)) {
#line 1078
                return ('?');
              }
#line 1079
              ns = 1000000000 - ns;
            }
          }
#line 1082
          lvalp->timespec.tv_sec = s;
#line 1083
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1084
          pc->input = p;
#line 1085
          if (sign) {
#line 1085
            tmp___3 = 276;
          } else {
#line 1085
            tmp___3 = 277;
          }
#line 1085
          return (tmp___3);
        } else {
#line 1025
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1089
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1090
        if (sign < 0) {
#line 1092
          lvalp->textintval.value = (long )(- value);
#line 1093
          if (0L < lvalp->textintval.value) {
#line 1094
            return ('?');
          }
        } else {
#line 1098
          lvalp->textintval.value = (long )value;
#line 1099
          if (lvalp->textintval.value < 0L) {
#line 1100
            return ('?');
          }
        }
#line 1102
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1103
        pc->input = p;
#line 1104
        if (sign) {
#line 1104
          tmp___4 = 274;
        } else {
#line 1104
          tmp___4 = 275;
        }
#line 1104
        return (tmp___4);
      }
    }
    {
#line 1108
    tmp___7 = c_isalpha((int )c);
    }
#line 1108
    if (tmp___7) {
#line 1111
      p___0 = buff;
      {
#line 1114
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1116
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1117
          tmp___5 = p___0;
#line 1117
          p___0 ++;
#line 1117
          *tmp___5 = (char )c;
        }
        {
#line 1118
        (pc->input) ++;
#line 1118
        c = (unsigned char )*(pc->input);
#line 1114
        tmp___6 = c_isalpha((int )c);
        }
#line 1114
        if (! tmp___6) {
#line 1114
          if (! ((int )c == 46)) {
#line 1114
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1122
      *p___0 = (char )'\000';
#line 1123
      tp = lookup_word((parser_control const   *)pc, buff);
      }
#line 1124
      if (! tp) {
#line 1125
        return ('?');
      }
#line 1126
      lvalp->intval = (long )tp->value;
#line 1127
      return ((int )tp->type);
    }
#line 1130
    if ((int )c != 40) {
#line 1131
      tmp___8 = pc->input;
#line 1131
      (pc->input) ++;
#line 1131
      return ((int )*tmp___8);
    }
#line 1132
    count = (size_t )0;
    {
#line 1133
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1135
      tmp___9 = pc->input;
#line 1135
      (pc->input) ++;
#line 1135
      c = (unsigned char )*tmp___9;
#line 1136
      if ((int )c == 0) {
#line 1137
        return ((int )c);
      }
#line 1138
      if ((int )c == 40) {
#line 1139
        count ++;
      } else
#line 1140
      if ((int )c == 41) {
#line 1141
        count --;
      }
#line 1133
      if (! (count != 0UL)) {
#line 1133
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1148 "getdate.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1152
  return (0);
}
}
#line 1159 "getdate.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1162
  if (t == -1L) {
    {
#line 1167
    tmp = localtime((time_t const   *)(& t));
#line 1167
    tm1 = (struct tm  const  *)tmp;
    }
#line 1168
    if (! tm1) {
#line 1169
      return ((_Bool)0);
    }
  }
#line 1172
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1186 "getdate.y"
static char *get_tz(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1189
  tmp = getenv("TZ");
#line 1189
  tz = tmp;
  }
#line 1190
  if (tz) {
    {
#line 1192
    tmp___0 = strlen((char const   *)tz);
#line 1192
    tzsize = tmp___0 + 1UL;
    }
#line 1193
    if (tzsize <= 100UL) {
      {
#line 1193
      tmp___1 = memcpy((void */* __restrict  */)tzbuf, (void const   */* __restrict  */)tz,
                       tzsize);
#line 1193
      tz = (char *)tmp___1;
      }
    } else {
      {
#line 1193
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1193
      tz = (char *)tmp___2;
      }
    }
  }
#line 1197
  return (tz);
}
}
#line 1204 "getdate.y"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  relative_time __constr_expr_27 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___10 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int year___1 ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long d3 ;
  time_t t3 ;
  long d4 ;
  time_t t4 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 1215
  tz_was_altered = (_Bool)0;
#line 1216
  tz0 = (char *)((void *)0);
#line 1218
  ok = (_Bool)1;
#line 1220
  if (! now) {
    {
#line 1222
    gettime(& gettime_buffer);
#line 1223
    now = (struct timespec  const  *)(& gettime_buffer);
    }
  }
  {
#line 1226
  Start = (time_t )now->tv_sec;
#line 1227
  Start_ns = (long )now->tv_nsec;
#line 1229
  tmp___0 = localtime(& now->tv_sec);
#line 1229
  tmp = (struct tm  const  *)tmp___0;
  }
#line 1230
  if (! tmp) {
#line 1231
    return ((_Bool)0);
  }
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1233
    c = (unsigned char )*p;
#line 1233
    tmp___1 = c_isspace((int )c);
    }
#line 1233
    if (! tmp___1) {
#line 1233
      goto while_break;
    }
#line 1234
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1236
  tmp___5 = strncmp(p, "TZ=\"", (size_t )4);
  }
#line 1236
  if (tmp___5 == 0) {
#line 1238
    tzbase = p + 4;
#line 1239
    tzsize = (size_t )1;
#line 1242
    s = tzbase;
    {
#line 1242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1242
      if (! *s) {
#line 1242
        goto while_break___0;
      }
#line 1243
      if ((int const   )*s == 92) {
#line 1245
        s ++;
#line 1246
        if (! ((int const   )*s == 92)) {
#line 1246
          if (! ((int const   )*s == 34)) {
#line 1247
            goto while_break___0;
          }
        }
      } else
#line 1249
      if ((int const   )*s == 34) {
        {
#line 1254
        large_tz = (_Bool )(100UL < tzsize);
#line 1256
        tz0 = get_tz((char *)(tz0buf));
        }
#line 1257
        if (large_tz) {
          {
#line 1257
          tmp___2 = xmalloc(tzsize);
#line 1257
          tz1 = (char *)tmp___2;
          }
        } else {
#line 1257
          tz1 = tz1buf;
        }
#line 1257
        z = tz1;
#line 1258
        s = tzbase;
        {
#line 1258
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1258
          if (! ((int const   )*s != 34)) {
#line 1258
            goto while_break___1;
          }
#line 1259
          tmp___3 = z;
#line 1259
          z ++;
#line 1259
          s += (int const   )*s == 92;
#line 1259
          *tmp___3 = (char )*s;
#line 1258
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1260
        *z = (char )'\000';
#line 1261
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1261
        setenv_ok = (_Bool )(tmp___4 == 0);
        }
#line 1262
        if (large_tz) {
          {
#line 1263
          free((void *)tz1);
          }
        }
#line 1264
        if (! setenv_ok) {
#line 1265
          goto fail;
        }
#line 1266
        tz_was_altered = (_Bool)1;
#line 1267
        p = s + 1;
      }
#line 1242
      s ++;
#line 1242
      tzsize ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1274
  if ((int const   )*p == 0) {
#line 1275
    p = "0";
  }
#line 1277
  pc.input = p;
#line 1278
  pc.year.value = (long )tmp->tm_year;
#line 1279
  pc.year.value += 1900L;
#line 1280
  pc.year.digits = (size_t )0;
#line 1281
  pc.month = (long )(tmp->tm_mon + 1);
#line 1282
  pc.day = (long )tmp->tm_mday;
#line 1283
  pc.hour = (long )tmp->tm_hour;
#line 1284
  pc.minutes = (long )tmp->tm_min;
#line 1285
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1286
  pc.seconds.tv_nsec = Start_ns;
#line 1287
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1289
  pc.meridian = 2;
#line 1290
  __constr_expr_27.year = 0L;
#line 1290
  __constr_expr_27.month = 0L;
#line 1290
  __constr_expr_27.day = 0L;
#line 1290
  __constr_expr_27.hour = 0L;
#line 1290
  __constr_expr_27.minutes = 0L;
#line 1290
  __constr_expr_27.seconds = 0L;
#line 1290
  __constr_expr_27.ns = 0L;
#line 1290
  pc.rel = __constr_expr_27;
#line 1291
  pc.timespec_seen = (_Bool)0;
#line 1292
  pc.rels_seen = (_Bool)0;
#line 1293
  pc.dates_seen = (size_t )0;
#line 1294
  pc.days_seen = (size_t )0;
#line 1295
  pc.times_seen = (size_t )0;
#line 1296
  pc.local_zones_seen = (size_t )0;
#line 1297
  pc.dsts_seen = (size_t )0;
#line 1298
  pc.zones_seen = (size_t )0;
#line 1301
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1302
  pc.local_time_zone_table[0].type = 269;
#line 1303
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1304
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1310
  quarter = 1;
  {
#line 1310
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1310
    if (! (quarter <= 3)) {
#line 1310
      goto while_break___2;
    }
    {
#line 1312
    probe = Start + (time_t )(quarter * 7776000);
#line 1313
    tmp___6 = localtime((time_t const   *)(& probe));
#line 1313
    probe_tm = (struct tm  const  *)tmp___6;
    }
#line 1314
    if (probe_tm) {
#line 1314
      if (probe_tm->tm_zone) {
#line 1314
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1318
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1319
          pc.local_time_zone_table[1].type = 269;
#line 1320
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1321
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1323
          goto while_break___2;
        }
      }
    }
#line 1310
    quarter ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1347
  if (pc.local_time_zone_table[0].name) {
#line 1347
    if (pc.local_time_zone_table[1].name) {
      {
#line 1347
      tmp___7 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
      }
#line 1347
      if (! tmp___7) {
#line 1354
        pc.local_time_zone_table[0].value = -1;
#line 1355
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1358
  tmp___8 = yyparse(& pc);
  }
#line 1358
  if (tmp___8 != 0) {
#line 1359
    goto fail;
  }
#line 1361
  if (pc.timespec_seen) {
#line 1362
    *result = pc.seconds;
  } else {
#line 1365
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1367
      goto fail;
    }
    {
#line 1369
    tmp___9 = to_year(pc.year);
#line 1369
    tm.tm_year = (int )(tmp___9 - 1900L);
#line 1370
    tm.tm_mon = (int )(pc.month - 1L);
#line 1371
    tm.tm_mday = (int )pc.day;
    }
#line 1372
    if (pc.times_seen) {
#line 1372
      goto _L;
    } else
#line 1372
    if (pc.rels_seen) {
#line 1372
      if (! pc.dates_seen) {
#line 1372
        if (! pc.days_seen) {
          _L: /* CIL Label */ 
          {
#line 1374
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
#line 1375
          if (tm.tm_hour < 0) {
#line 1376
            goto fail;
          }
#line 1377
          tm.tm_min = (int )pc.minutes;
#line 1378
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1382
          tm.tm_sec = 0;
#line 1382
          tm.tm_min = tm.tm_sec;
#line 1382
          tm.tm_hour = tm.tm_min;
#line 1383
          pc.seconds.tv_nsec = (__syscall_slong_t )0;
        }
      } else {
#line 1382
        tm.tm_sec = 0;
#line 1382
        tm.tm_min = tm.tm_sec;
#line 1382
        tm.tm_hour = tm.tm_min;
#line 1383
        pc.seconds.tv_nsec = (__syscall_slong_t )0;
      }
    } else {
#line 1382
      tm.tm_sec = 0;
#line 1382
      tm.tm_min = tm.tm_sec;
#line 1382
      tm.tm_hour = tm.tm_min;
#line 1383
      pc.seconds.tv_nsec = (__syscall_slong_t )0;
    }
#line 1387
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1388
      tm.tm_isdst = -1;
    }
#line 1392
    if (pc.local_zones_seen) {
#line 1393
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 1395
    tm0 = tm;
#line 1397
    Start = mktime(& tm);
#line 1399
    tmp___13 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
    }
#line 1399
    if (! tmp___13) {
#line 1401
      if (! pc.zones_seen) {
#line 1402
        goto fail;
      } else {
#line 1415
        time_zone = pc.time_zone;
#line 1416
        if (time_zone < 0L) {
#line 1416
          tmp___10 = - time_zone;
        } else {
#line 1416
          tmp___10 = time_zone;
        }
#line 1416
        abs_time_zone = tmp___10;
#line 1417
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1418
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1421
        if (! tz_was_altered) {
          {
#line 1422
          tz0 = get_tz((char *)(tz0buf));
          }
        }
        {
#line 1423
        sprintf((char */* __restrict  */)(tz1buf___0), (char const   */* __restrict  */)"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1425
        tmp___11 = setenv("TZ", (char const   *)(tz1buf___0), 1);
        }
#line 1425
        if (tmp___11 != 0) {
#line 1426
          goto fail;
        }
        {
#line 1427
        tz_was_altered = (_Bool)1;
#line 1428
        tm = tm0;
#line 1429
        Start = mktime(& tm);
#line 1430
        tmp___12 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
        }
#line 1430
        if (! tmp___12) {
#line 1431
          goto fail;
        }
      }
    }
#line 1435
    if (pc.days_seen) {
#line 1435
      if (! pc.dates_seen) {
        {
#line 1437
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )(0L < pc.day_ordinal))));
#line 1439
        tm.tm_isdst = -1;
#line 1440
        Start = mktime(& tm);
        }
#line 1441
        if (Start == -1L) {
#line 1442
          goto fail;
        }
      }
    }
#line 1446
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1448
      year___1 = (int )((long )tm.tm_year + pc.rel.year);
#line 1449
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1450
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1451
      if ((((year___1 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1454
        goto fail;
      }
      {
#line 1455
      tm.tm_year = year___1;
#line 1456
      tm.tm_mon = month;
#line 1457
      tm.tm_mday = day;
#line 1458
      tm.tm_hour = tm0.tm_hour;
#line 1459
      tm.tm_min = tm0.tm_min;
#line 1460
      tm.tm_sec = tm0.tm_sec;
#line 1461
      tm.tm_isdst = tm0.tm_isdst;
#line 1462
      Start = mktime(& tm);
      }
#line 1463
      if (Start == -1L) {
#line 1464
        goto fail;
      }
    }
#line 1469
    if (pc.zones_seen) {
#line 1471
      delta = pc.time_zone * 60L;
#line 1474
      delta -= tm.tm_gmtoff;
#line 1482
      t1 = Start - delta;
#line 1483
      if ((Start < t1) != (delta < 0L)) {
#line 1484
        goto fail;
      }
#line 1485
      Start = t1;
    }
#line 1496
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1497
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1498
    t0 = Start;
#line 1499
    d1 = 3600L * pc.rel.hour;
#line 1500
    t1___0 = t0 + d1;
#line 1501
    d2 = 60L * pc.rel.minutes;
#line 1502
    t2 = t1___0 + d2;
#line 1503
    d3 = pc.rel.seconds;
#line 1504
    t3 = t2 + d3;
#line 1505
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1506
    t4 = t3 + d4;
#line 1508
    if ((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) {
#line 1514
      goto fail;
    }
#line 1516
    result->tv_sec = t4;
#line 1517
    result->tv_nsec = normalized_ns;
  }
#line 1521
  goto done;
  fail: 
#line 1524
  ok = (_Bool)0;
  done: 
#line 1526
  if (tz_was_altered) {
#line 1527
    if (tz0) {
      {
#line 1527
      tmp___14 = setenv("TZ", (char const   *)tz0, 1);
#line 1527
      tmp___16 = tmp___14;
      }
    } else {
      {
#line 1527
      tmp___15 = unsetenv("TZ");
#line 1527
      tmp___16 = tmp___15;
      }
    }
#line 1527
    ok = (_Bool )((int )ok & (tmp___16 == 0));
  }
#line 1528
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    {
#line 1529
    free((void *)tz0);
    }
  }
#line 1530
  return (ok);
}
}
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/full-write.h"
size_t full_write(int fd , void const   *buf___1 , size_t count ) ;
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/safe-write.h"
size_t safe_write(int fd , void const   *buf___1 , size_t count ) ;
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/full-write.c"
size_t full_write(int fd , void const   *buf___1 , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 61
  total = (size_t )0;
#line 62
  ptr = (char const   *)buf___1;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (count > 0UL)) {
#line 64
      goto while_break;
    }
    {
#line 66
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 66
    n_rw = tmp;
    }
#line 67
    if (n_rw == 0xffffffffffffffffUL) {
#line 68
      goto while_break;
    }
#line 69
    if (n_rw == 0UL) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      *tmp___0 = 28;
      }
#line 72
      goto while_break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (total);
}
}
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/full-read.h"
size_t full_read(int fd , void *buf___1 , size_t count ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/safe-read.h"
size_t safe_read(int fd , void *buf___1 , size_t count ) ;
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/full-write.c"
size_t full_read(int fd , void *buf___1 , size_t count ) 
{ 
  size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 61
  total = (size_t )0;
#line 62
  ptr = (char *)buf___1;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (count > 0UL)) {
#line 64
      goto while_break;
    }
    {
#line 66
    tmp = safe_read(fd, (void *)ptr, count);
#line 66
    n_rw = tmp;
    }
#line 67
    if (n_rw == 0xffffffffffffffffUL) {
#line 68
      goto while_break;
    }
#line 69
    if (n_rw == 0UL) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      *tmp___0 = 0;
      }
#line 72
      goto while_break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (total);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 237 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__leaf__)) fts_children)(FTS *sp ,
                                                                                int instr ) ;
#line 238
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_close)(FTS *sp ) ;
#line 239
 __attribute__((__nothrow__)) FTS *( __attribute__((__leaf__)) fts_open)(char * const  *argv ,
                                                                         int options ,
                                                                         int (*compar)(FTSENT const   ** ,
                                                                                       FTSENT const   ** ) ) ;
#line 241
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__leaf__)) fts_read)(FTS *sp ) ;
#line 242
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 202 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 203
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 204
static void fts_lfree(FTSENT *head ) ;
#line 205
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 206
static size_t fts_maxarglen(char * const  *argv ) ;
#line 207
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 208
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 209
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 210
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 211
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state___0 ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state___0 , struct stat  const  *sb ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 283 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 286
    if (tmp___0) {
#line 286
      goto while_break;
    }
    {
#line 288
    tmp = i_ring_pop(fd_ring);
#line 288
    fd = tmp;
    }
#line 289
    if (0 <= fd) {
      {
#line 290
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 297 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((int )p->fts_info == 11)) {
      {
#line 300
      abort();
      }
    }
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (required) {
#line 301
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 301
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 304
  return;
}
}
#line 308 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
__inline static DIR *opendirat(int fd , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 312
  tmp = openat(fd, dir, 0);
#line 312
  new_fd = tmp;
  }
#line 315
  if (new_fd < 0) {
#line 316
    return ((DIR *)((void *)0));
  }
  {
#line 317
  dirp = fdopendir(new_fd);
  }
#line 318
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
#line 320
    tmp___0 = __errno_location();
#line 320
    saved_errno = *tmp___0;
#line 321
    close(new_fd);
#line 322
    tmp___1 = __errno_location();
#line 322
    *tmp___1 = saved_errno;
    }
  }
#line 324
  return (dirp);
}
}
#line 332 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 336
  old = sp->fts_cwd_fd;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (old != fd)) {
#line 337
      if (! (old == -100)) {
        {
#line 337
        abort();
        }
      }
    }
#line 337
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  if (chdir_down_one) {
    {
#line 343
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 343
    prev_fd_in_slot = tmp;
    }
#line 345
    if (0 <= prev_fd_in_slot) {
      {
#line 346
      close(prev_fd_in_slot);
      }
    }
  } else
#line 348
  if (! (sp->fts_options & 4)) {
#line 350
    if (0 <= old) {
      {
#line 351
      close(old);
      }
    }
  }
#line 354
  sp->fts_cwd_fd = fd;
#line 355
  return;
}
}
#line 361 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
__inline static int diropen(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 365
  if (sp->fts_options & 16) {
#line 365
    tmp = 131072;
  } else {
#line 365
    tmp = 0;
  }
#line 365
  open_flags = 67840 | tmp;
#line 368
  if (sp->fts_options & 512) {
    {
#line 368
    tmp___0 = openat((int )sp->fts_cwd_fd, dir, open_flags);
#line 368
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 368
    tmp___1 = open_safer(dir, open_flags);
#line 368
    tmp___2 = tmp___1;
    }
  }
#line 368
  return (tmp___2);
}
}
#line 373
 __attribute__((__nothrow__)) FTS *( __attribute__((__leaf__)) fts_open)(char * const  *argv ,
                                                                         int options ,
                                                                         int (*compar)(FTSENT const   ** ,
                                                                                       FTSENT const   ** ) ) ;
#line 373 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
FTS *( __attribute__((__leaf__)) fts_open)(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                                             FTSENT const   ** ) ) 
{ 
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  size_t len ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  struct _ftsent *tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;

  {
#line 381
  parent = (FTSENT *)((void *)0);
#line 382
  tmp = (FTSENT *)((void *)0);
#line 387
  if (options & -2048) {
    {
#line 388
    tmp___0 = __errno_location();
#line 388
    *tmp___0 = 22;
    }
#line 389
    return ((FTS *)((void *)0));
  }
#line 391
  if (options & 4) {
#line 391
    if (options & 512) {
      {
#line 392
      tmp___1 = __errno_location();
#line 392
      *tmp___1 = 22;
      }
#line 393
      return ((FTS *)((void *)0));
    }
  }
#line 395
  if (! (options & 18)) {
    {
#line 396
    tmp___2 = __errno_location();
#line 396
    *tmp___2 = 22;
    }
#line 397
    return ((FTS *)((void *)0));
  }
  {
#line 401
  tmp___3 = malloc(sizeof(FTS ));
#line 401
  sp = (FTS *)tmp___3;
  }
#line 401
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 402
    return ((FTS *)((void *)0));
  }
  {
#line 403
  memset((void *)sp, 0, sizeof(FTS ));
#line 404
  sp->fts_compar = compar;
#line 405
  sp->fts_options = options;
  }
#line 408
  if (sp->fts_options & 2) {
#line 409
    sp->fts_options |= 4;
#line 410
    sp->fts_options &= -513;
  }
#line 414
  sp->fts_cwd_fd = -100;
#line 415
  if (sp->fts_options & 512) {

  }
  {
#line 455
  tmp___5 = fts_maxarglen(argv);
#line 455
  maxarglen = tmp___5;
  }
#line 456
  if (maxarglen > 4096UL) {
#line 456
    tmp___6 = maxarglen;
  } else {
#line 456
    tmp___6 = (size_t )4096;
  }
  {
#line 456
  tmp___7 = fts_palloc(sp, tmp___6);
  }
#line 456
  if (! tmp___7) {
#line 457
    goto mem1;
  }
#line 461
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    {
#line 462
    parent = fts_alloc(sp, "", (size_t )0);
    }
#line 462
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 463
      goto mem2;
    }
#line 464
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 478
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 478
    tmp___8 = 1;
  } else
#line 478
  if (sp->fts_options & 1024) {
#line 478
    tmp___8 = 1;
  } else {
#line 478
    tmp___8 = 0;
  }
#line 478
  defer_stat = (_Bool )tmp___8;
#line 481
  root = (FTSENT *)((void *)0);
#line 481
  nitems = (size_t )0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 481
      goto while_break;
    }
    {
#line 483
    len = strlen((char const   *)*argv);
    }
#line 483
    if (len == 0UL) {
      {
#line 484
      tmp___9 = __errno_location();
#line 484
      *tmp___9 = 2;
      }
#line 485
      goto mem3;
    }
    {
#line 488
    p = fts_alloc(sp, (char const   *)*argv, len);
    }
#line 488
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 489
      goto mem3;
    }
#line 490
    p->fts_level = (ptrdiff_t )0;
#line 491
    p->fts_parent = parent;
#line 492
    p->fts_accpath = p->fts_name;
#line 496
    if (defer_stat) {
#line 496
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        {
#line 497
        p->fts_info = (unsigned short)11;
#line 498
        fts_set_stat_required(p, (_Bool)1);
        }
      } else {
        {
#line 500
        p->fts_info = fts_stat(sp, p, (_Bool)0);
        }
      }
    } else {
      {
#line 500
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    }
#line 507
    if (compar) {
#line 508
      p->fts_link = root;
#line 509
      root = p;
    } else {
#line 511
      p->fts_link = (struct _ftsent *)((void *)0);
#line 512
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 513
        root = p;
#line 513
        tmp = root;
      } else {
#line 515
        tmp->fts_link = p;
#line 516
        tmp = p;
      }
    }
#line 481
    argv ++;
#line 481
    nitems ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if (compar) {
#line 520
    if (nitems > 1UL) {
      {
#line 521
      root = fts_sort(sp, root, nitems);
      }
    }
  }
  {
#line 528
  tmp___10 = fts_alloc(sp, "", (size_t )0);
#line 528
  sp->fts_cur = tmp___10;
  }
#line 528
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 529
    goto mem3;
  }
  {
#line 530
  (sp->fts_cur)->fts_link = root;
#line 531
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 532
  tmp___11 = setup_dir(sp);
  }
#line 532
  if (! tmp___11) {
#line 533
    goto mem3;
  }
#line 542
  if (! (sp->fts_options & 4)) {
#line 542
    if (! (sp->fts_options & 512)) {
      {
#line 542
      tmp___12 = diropen((FTS const   *)sp, ".");
#line 542
      sp->fts_rfd = tmp___12;
      }
#line 542
      if (tmp___12 < 0) {
#line 544
        sp->fts_options |= 4;
      }
    }
  }
  {
#line 546
  i_ring_init(& sp->fts_fd_ring, -1);
  }
#line 547
  return (sp);
  mem3: 
  {
#line 549
  fts_lfree(root);
#line 550
  free((void *)parent);
  }
  mem2: 
  {
#line 551
  free((void *)sp->fts_path);
  }
  mem1: 
  {
#line 552
  free((void *)sp);
  }
#line 553
  return ((FTS *)((void *)0));
}
}
#line 556 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 570
  tmp = p->fts_namelen;
#line 570
  p->fts_pathlen = tmp;
#line 570
  len = tmp;
#line 571
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 572
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 572
  if (cp) {
#line 572
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 573
      cp ++;
#line 573
      len = strlen((char const   *)cp);
#line 574
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 575
      p->fts_namelen = len;
      }
    } else
#line 572
    if (*(cp + 1)) {
      {
#line 573
      cp ++;
#line 573
      len = strlen((char const   *)cp);
#line 574
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 575
      p->fts_namelen = len;
      }
    }
  }
#line 577
  tmp___0 = sp->fts_path;
#line 577
  p->fts_path = tmp___0;
#line 577
  p->fts_accpath = tmp___0;
#line 578
  return;
}
}
#line 580
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_close)(FTS *sp ) ;
#line 580 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
int ( __attribute__((__leaf__)) fts_close)(FTS *sp ) 
{ 
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 584
  saved_errno = 0;
#line 591
  if (sp->fts_cur) {
#line 592
    p = sp->fts_cur;
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! (p->fts_level >= 0L)) {
#line 592
        goto while_break;
      }
#line 593
      freep = p;
#line 594
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 594
        p = p->fts_link;
      } else {
#line 594
        p = p->fts_parent;
      }
      {
#line 595
      free((void *)freep);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 597
    free((void *)p);
    }
  }
#line 601
  if (sp->fts_child) {
    {
#line 602
    fts_lfree(sp->fts_child);
    }
  }
  {
#line 603
  free((void *)sp->fts_array);
#line 604
  free((void *)sp->fts_path);
  }
#line 606
  if (sp->fts_options & 512) {
#line 608
    if (0 <= sp->fts_cwd_fd) {
      {
#line 609
      close(sp->fts_cwd_fd);
      }
    }
  } else
#line 611
  if (! (sp->fts_options & 4)) {
    {
#line 614
    tmp___0 = fchdir(sp->fts_rfd);
    }
#line 614
    if (tmp___0) {
      {
#line 615
      tmp = __errno_location();
#line 615
      saved_errno = *tmp;
      }
    }
    {
#line 616
    close(sp->fts_rfd);
    }
  }
  {
#line 619
  fd_ring_clear(& sp->fts_fd_ring);
  }
#line 622
  if (sp->fts_leaf_optimization_works_ht) {
    {
#line 623
    hash_free(sp->fts_leaf_optimization_works_ht);
    }
  }
  {
#line 626
  free_dir(sp);
#line 629
  free((void *)sp);
  }
#line 632
  if (saved_errno) {
    {
#line 633
    tmp___1 = __errno_location();
#line 633
    *tmp___1 = saved_errno;
    }
#line 634
    return (-1);
  }
#line 637
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 655 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 666
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 666
  if (tmp != 0) {
#line 667
    return ((_Bool)1);
  }
  {
#line 674
  if (fs_buf.f_type == 26985L) {
#line 674
    goto case_26985;
  }
#line 674
  if (fs_buf.f_type == 16914836L) {
#line 674
    goto case_26985;
  }
#line 679
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 677
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 680
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 687 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 693
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 693
  if (tmp != 0) {
#line 694
    return ((_Bool)0);
  }
  {
#line 703
  if (fs_buf.f_type == 1382369651L) {
#line 703
    goto case_1382369651;
  }
#line 712
  goto switch_default;
  case_1382369651: /* CIL Label */ 
#line 704
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 713
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 736 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 739
  ax = (struct LCO_ent  const  *)x;
#line 740
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 743 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 746
  ax = (struct LCO_ent  const  *)x;
#line 747
  ay = (struct LCO_ent  const  *)y;
#line 748
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 754 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 757
  sp = (FTS *)p->fts_fts;
#line 758
  h = sp->fts_leaf_optimization_works_ht;
#line 766
  if (! (sp->fts_options & 512)) {
#line 767
    return ((_Bool)0);
  }
#line 770
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 772
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 772
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 772
    h = tmp___0;
    }
#line 775
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 776
      return ((_Bool)0);
    }
  }
  {
#line 778
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 779
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 779
  ent = (struct LCO_ent *)tmp___1;
  }
#line 780
  if (ent) {
#line 781
    return (ent->opt_ok);
  }
  {
#line 784
  tmp___2 = malloc(sizeof(*t2));
#line 784
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 785
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 786
    return ((_Bool)0);
  }
  {
#line 789
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 790
  t2->opt_ok = opt_ok;
#line 791
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 793
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 793
  ent = (struct LCO_ent *)tmp___3;
  }
#line 794
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 797
    free((void *)t2);
    }
#line 798
    return ((_Bool)0);
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 800
      abort();
      }
    }
#line 800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  return (opt_ok);
}
}
#line 814
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__leaf__)) fts_read)(FTS *sp ) ;
#line 814 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
FTSENT *( __attribute__((__leaf__)) fts_read)(FTS *sp ) 
{ 
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  FTSENT *parent ;
  _Bool tmp___14 ;
  int *tmp___15 ;
  _Bool tmp___16 ;
  int *tmp___17 ;
  struct _ftsent *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int saved_errno ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  FTSENT *tmp___32 ;

  {
#line 822
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 823
    return ((FTSENT *)((void *)0));
  } else
#line 822
  if (sp->fts_options & 8192) {
#line 823
    return ((FTSENT *)((void *)0));
  }
#line 826
  p = sp->fts_cur;
#line 829
  instr = p->fts_instr;
#line 830
  p->fts_instr = (unsigned short)3;
#line 833
  if ((int )instr == 1) {
    {
#line 834
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 835
    return (p);
  }
#line 846
  if ((int )instr == 2) {
#line 846
    if ((int )p->fts_info == 12) {
#line 846
      goto _L;
    } else
#line 846
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */ 
      {
#line 848
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 849
      if ((int )p->fts_info == 1) {
#line 849
        if (! (sp->fts_options & 4)) {
          {
#line 850
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 850
          p->fts_symfd = tmp___1;
          }
#line 850
          if (tmp___1 < 0) {
            {
#line 851
            tmp___0 = __errno_location();
#line 851
            p->fts_errno = *tmp___0;
#line 852
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 854
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 856
      goto check_for_dir;
    }
  }
#line 860
  if ((int )p->fts_info == 1) {
#line 862
    if ((int )instr == 4) {
#line 862
      goto _L___0;
    } else
#line 862
    if (sp->fts_options & 64) {
#line 862
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */ 
#line 864
        if ((int )p->fts_flags & 2) {
          {
#line 865
          close(p->fts_symfd);
          }
        }
#line 866
        if (sp->fts_child) {
          {
#line 867
          fts_lfree(sp->fts_child);
#line 868
          sp->fts_child = (struct _ftsent *)((void *)0);
          }
        }
#line 870
        p->fts_info = (unsigned short)6;
        {
#line 871
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 871
          leave_dir(sp, p);
          }
#line 871
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 872
        return (p);
      }
    }
#line 876
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 876
      if (sp->fts_options & 4096) {
        {
#line 877
        sp->fts_options &= -4097;
#line 878
        fts_lfree(sp->fts_child);
#line 879
        sp->fts_child = (struct _ftsent *)((void *)0);
        }
      }
    }
#line 894
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      {
#line 895
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      }
#line 895
      if (tmp___3) {
        {
#line 896
        tmp___2 = __errno_location();
#line 896
        p->fts_errno = *tmp___2;
#line 897
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 898
        p = sp->fts_child;
        }
        {
#line 898
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 898
          if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 898
            goto while_break___0;
          }
#line 900
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 898
          p = p->fts_link;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 903
      tmp___4 = fts_build(sp, 3);
#line 903
      sp->fts_child = tmp___4;
      }
#line 903
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 904
        if (sp->fts_options & 8192) {
#line 905
          return ((FTSENT *)((void *)0));
        }
#line 909
        if (p->fts_errno) {
#line 909
          if ((int )p->fts_info != 4) {
#line 910
            p->fts_info = (unsigned short)7;
          }
        }
        {
#line 911
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 911
          leave_dir(sp, p);
          }
#line 911
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 912
        return (p);
      }
    }
#line 914
    p = sp->fts_child;
#line 915
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 916
    goto name;
  }
  next: 
#line 920
  tmp = p;
#line 921
  p = p->fts_link;
#line 921
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 922
    sp->fts_cur = p;
#line 923
    free((void *)tmp);
    }
#line 930
    if (p->fts_level == 0L) {
      {
#line 931
      fd_ring_clear(& sp->fts_fd_ring);
      }
#line 931
      if (! (sp->fts_options & 4)) {
#line 931
        if (sp->fts_options & 512) {
#line 931
          if (sp->fts_options & 512) {
#line 931
            tmp___5 = -100;
          } else {
#line 931
            tmp___5 = sp->fts_rfd;
          }
          {
#line 931
          cwd_advance_fd(sp, tmp___5, (_Bool)1);
#line 931
          tmp___8 = 0;
          }
        } else {
#line 931
          if (sp->fts_options & 512) {
#line 931
            tmp___6 = -100;
          } else {
#line 931
            tmp___6 = sp->fts_rfd;
          }
          {
#line 931
          tmp___7 = fchdir(tmp___6);
#line 931
          tmp___8 = tmp___7;
          }
        }
#line 931
        if (tmp___8) {
#line 931
          tmp___9 = 1;
        } else {
#line 931
          tmp___9 = 0;
        }
      } else {
#line 931
        tmp___9 = 0;
      }
#line 931
      if (tmp___9) {
#line 932
        sp->fts_options |= 8192;
#line 933
        return ((FTSENT *)((void *)0));
      }
      {
#line 935
      fts_load(sp, p);
      }
#line 936
      goto check_for_dir;
    }
#line 944
    if ((int )p->fts_instr == 4) {
#line 945
      goto next;
    }
#line 946
    if ((int )p->fts_instr == 2) {
      {
#line 947
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      }
#line 948
      if ((int )p->fts_info == 1) {
#line 948
        if (! (sp->fts_options & 4)) {
          {
#line 949
          tmp___11 = diropen((FTS const   *)sp, ".");
#line 949
          p->fts_symfd = tmp___11;
          }
#line 949
          if (tmp___11 < 0) {
            {
#line 950
            tmp___10 = __errno_location();
#line 950
            p->fts_errno = *tmp___10;
#line 951
            p->fts_info = (unsigned short)7;
            }
          } else {
#line 953
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 955
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 958
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 958
      tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 958
      tmp___12 = (p->fts_parent)->fts_pathlen;
    }
    {
#line 958
    t = sp->fts_path + tmp___12;
#line 959
    tmp___13 = t;
#line 959
    t ++;
#line 959
    *tmp___13 = (char )'/';
#line 960
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    }
    check_for_dir: 
#line 962
    sp->fts_cur = p;
#line 963
    if ((int )p->fts_info == 11) {
#line 965
      if (p->fts_statp[0].st_size == 2L) {
#line 967
        parent = p->fts_parent;
#line 968
        if (0L < p->fts_level) {
#line 968
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 968
            if (sp->fts_options & 8) {
#line 968
              if (sp->fts_options & 16) {
                {
#line 968
                tmp___14 = link_count_optimize_ok((FTSENT const   *)parent);
                }
#line 968
                if (! tmp___14) {
#line 968
                  goto _L___4;
                }
              } else {
#line 968
                goto _L___4;
              }
            } else {
#line 968
              goto _L___4;
            }
          } else {
#line 968
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 980
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          }
#line 981
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 981
            if (p->fts_level != 0L) {
#line 981
              if (parent->fts_n_dirs_remaining) {
#line 984
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        {
#line 988
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 988
          if (! (p->fts_statp[0].st_size == 1L)) {
            {
#line 988
            abort();
            }
          }
#line 988
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 991
    if ((int )p->fts_info == 1) {
#line 996
      if (p->fts_level == 0L) {
#line 997
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      {
#line 999
      tmp___16 = enter_dir(sp, p);
      }
#line 999
      if (! tmp___16) {
        {
#line 1001
        tmp___15 = __errno_location();
#line 1001
        *tmp___15 = 12;
        }
#line 1002
        return ((FTSENT *)((void *)0));
      }
    }
#line 1005
    return (p);
  }
  {
#line 1009
  p = tmp->fts_parent;
#line 1010
  sp->fts_cur = p;
#line 1011
  free((void *)tmp);
  }
#line 1013
  if (p->fts_level == -1L) {
    {
#line 1018
    free((void *)p);
#line 1019
    tmp___17 = __errno_location();
#line 1019
    *tmp___17 = 0;
#line 1020
    tmp___18 = (struct _ftsent *)((void *)0);
#line 1020
    sp->fts_cur = tmp___18;
    }
#line 1020
    return (tmp___18);
  }
  {
#line 1023
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1023
    if (! ((int )p->fts_info != 11)) {
      {
#line 1023
      abort();
      }
    }
#line 1023
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1026
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1034
  if (p->fts_level == 0L) {
    {
#line 1035
    fd_ring_clear(& sp->fts_fd_ring);
    }
#line 1035
    if (! (sp->fts_options & 4)) {
#line 1035
      if (sp->fts_options & 512) {
#line 1035
        if (sp->fts_options & 512) {
#line 1035
          tmp___20 = -100;
        } else {
#line 1035
          tmp___20 = sp->fts_rfd;
        }
        {
#line 1035
        cwd_advance_fd(sp, tmp___20, (_Bool)1);
#line 1035
        tmp___23 = 0;
        }
      } else {
#line 1035
        if (sp->fts_options & 512) {
#line 1035
          tmp___21 = -100;
        } else {
#line 1035
          tmp___21 = sp->fts_rfd;
        }
        {
#line 1035
        tmp___22 = fchdir(tmp___21);
#line 1035
        tmp___23 = tmp___22;
        }
      }
#line 1035
      if (tmp___23) {
#line 1035
        tmp___24 = 1;
      } else {
#line 1035
        tmp___24 = 0;
      }
    } else {
#line 1035
      tmp___24 = 0;
    }
#line 1035
    if (tmp___24) {
      {
#line 1036
      tmp___19 = __errno_location();
#line 1036
      p->fts_errno = *tmp___19;
#line 1037
      sp->fts_options |= 8192;
      }
    }
  } else
#line 1039
  if ((int )p->fts_flags & 2) {
#line 1040
    if (! (sp->fts_options & 4)) {
#line 1040
      if (sp->fts_options & 512) {
        {
#line 1040
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1040
        tmp___29 = 0;
        }
      } else {
        {
#line 1040
        tmp___28 = fchdir(p->fts_symfd);
#line 1040
        tmp___29 = tmp___28;
        }
      }
#line 1040
      if (tmp___29) {
        {
#line 1041
        tmp___25 = __errno_location();
#line 1041
        saved_errno = *tmp___25;
#line 1042
        close(p->fts_symfd);
#line 1043
        tmp___26 = __errno_location();
#line 1043
        *tmp___26 = saved_errno;
#line 1044
        tmp___27 = __errno_location();
#line 1044
        p->fts_errno = *tmp___27;
#line 1045
        sp->fts_options |= 8192;
        }
      }
    }
    {
#line 1047
    close(p->fts_symfd);
    }
  } else
#line 1048
  if (! ((int )p->fts_flags & 1)) {
    {
#line 1048
    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    }
#line 1048
    if (tmp___31) {
      {
#line 1050
      tmp___30 = __errno_location();
#line 1050
      p->fts_errno = *tmp___30;
#line 1051
      sp->fts_options |= 8192;
      }
    }
  }
#line 1053
  if (p->fts_errno) {
#line 1053
    p->fts_info = (unsigned short)7;
  } else {
#line 1053
    p->fts_info = (unsigned short)6;
  }
#line 1054
  if (p->fts_errno == 0) {
    {
#line 1055
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1055
      leave_dir(sp, p);
      }
#line 1055
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1056
  if (sp->fts_options & 8192) {
#line 1056
    tmp___32 = (FTSENT *)((void *)0);
  } else {
#line 1056
    tmp___32 = p;
  }
#line 1056
  return (tmp___32);
}
}
#line 1066
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1066 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr ) 
{ 
  int *tmp ;

  {
#line 1069
  if (instr != 0) {
#line 1069
    if (instr != 1) {
#line 1069
      if (instr != 2) {
#line 1069
        if (instr != 3) {
#line 1069
          if (instr != 4) {
            {
#line 1071
            tmp = __errno_location();
#line 1071
            *tmp = 22;
            }
#line 1072
            return (1);
          }
        }
      }
    }
  }
#line 1074
  p->fts_instr = (unsigned short )instr;
#line 1075
  return (0);
}
}
#line 1078
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__leaf__)) fts_children)(FTS *sp ,
                                                                                int instr ) ;
#line 1078 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
FTSENT *( __attribute__((__leaf__)) fts_children)(FTS *sp , int instr ) 
{ 
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1084
  if (instr != 0) {
#line 1084
    if (instr != 4096) {
      {
#line 1085
      tmp = __errno_location();
#line 1085
      *tmp = 22;
      }
#line 1086
      return ((FTSENT *)((void *)0));
    }
  }
  {
#line 1090
  p = sp->fts_cur;
#line 1096
  tmp___0 = __errno_location();
#line 1096
  *tmp___0 = 0;
  }
#line 1099
  if (sp->fts_options & 8192) {
#line 1100
    return ((FTSENT *)((void *)0));
  }
#line 1103
  if ((int )p->fts_info == 9) {
#line 1104
    return (p->fts_link);
  }
#line 1111
  if ((int )p->fts_info != 1) {
#line 1112
    return ((FTSENT *)((void *)0));
  }
#line 1115
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    {
#line 1116
    fts_lfree(sp->fts_child);
    }
  }
#line 1118
  if (instr == 4096) {
#line 1119
    sp->fts_options |= 4096;
#line 1120
    instr = 2;
  } else {
#line 1122
    instr = 1;
  }
#line 1131
  if (p->fts_level != 0L) {
    {
#line 1133
    tmp___1 = fts_build(sp, instr);
#line 1133
    sp->fts_child = tmp___1;
    }
#line 1133
    return (tmp___1);
  } else
#line 1131
  if ((int )*(p->fts_accpath + 0) == 47) {
    {
#line 1133
    tmp___1 = fts_build(sp, instr);
#line 1133
    sp->fts_child = tmp___1;
    }
#line 1133
    return (tmp___1);
  } else
#line 1131
  if (sp->fts_options & 4) {
    {
#line 1133
    tmp___1 = fts_build(sp, instr);
#line 1133
    sp->fts_child = tmp___1;
    }
#line 1133
    return (tmp___1);
  }
  {
#line 1135
  fd = diropen((FTS const   *)sp, ".");
  }
#line 1135
  if (fd < 0) {
#line 1136
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1136
    sp->fts_child = tmp___2;
#line 1136
    return (tmp___2);
  }
  {
#line 1137
  sp->fts_child = fts_build(sp, instr);
  }
#line 1138
  if (sp->fts_options & 512) {
    {
#line 1140
    cwd_advance_fd(sp, fd, (_Bool)1);
    }
  } else {
    {
#line 1144
    tmp___5 = fchdir(fd);
    }
#line 1144
    if (tmp___5) {
      {
#line 1146
      tmp___3 = __errno_location();
#line 1146
      saved_errno = *tmp___3;
#line 1147
      close(fd);
#line 1148
      tmp___4 = __errno_location();
#line 1148
      *tmp___4 = saved_errno;
      }
#line 1149
      return ((FTSENT *)((void *)0));
    }
    {
#line 1151
    close(fd);
    }
  }
#line 1153
  return (sp->fts_child);
}
}
#line 1161 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1164
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1164
    tmp___0 = -1;
  } else {
#line 1164
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1164
      tmp = 1;
    } else {
#line 1164
      tmp = 0;
    }
#line 1164
    tmp___0 = tmp;
  }
#line 1164
  return (tmp___0);
}
}
#line 1170 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1176
  if (dtype == 6U) {
#line 1176
    goto case_6;
  }
#line 1179
  if (dtype == 2U) {
#line 1179
    goto case_2;
  }
#line 1182
  if (dtype == 4U) {
#line 1182
    goto case_4;
  }
#line 1185
  if (dtype == 1U) {
#line 1185
    goto case_1;
  }
#line 1188
  if (dtype == 10U) {
#line 1188
    goto case_10;
  }
#line 1191
  if (dtype == 8U) {
#line 1191
    goto case_8;
  }
#line 1194
  if (dtype == 12U) {
#line 1194
    goto case_12;
  }
#line 1197
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1177
  type = (mode_t )24576;
#line 1178
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1180
  type = (mode_t )8192;
#line 1181
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1183
  type = (mode_t )16384;
#line 1184
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1186
  type = (mode_t )4096;
#line 1187
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1189
  type = (mode_t )40960;
#line 1190
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1192
  type = (mode_t )32768;
#line 1193
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1195
  type = (mode_t )49152;
#line 1196
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1198
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1200
  st->st_mode = type;
#line 1201
  return;
}
}
#line 1217 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ 
  register struct dirent *dp ;
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *cur ;
  FTSENT *tail ;
  DIR *dirp ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int *tmp ;
  DIR *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int dir_fd ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  _Bool is_dir ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  size_t tmp___10 ;
  _Bool tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  _Bool skip_stat ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1237
  cur = sp->fts_cur;
#line 1254
  if (! (sp->fts_options & 4)) {
#line 1254
    if (sp->fts_options & 512) {
      {
#line 1254
      tmp___0 = opendirat(sp->fts_cwd_fd, (char const   *)cur->fts_accpath);
#line 1254
      dirp = tmp___0;
      }
    } else {
      {
#line 1254
      tmp___1 = opendir((char const   *)cur->fts_accpath);
#line 1254
      dirp = tmp___1;
      }
    }
  } else {
    {
#line 1254
    tmp___1 = opendir((char const   *)cur->fts_accpath);
#line 1254
    dirp = tmp___1;
    }
  }
#line 1254
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 1255
    if (type == 3) {
      {
#line 1256
      cur->fts_info = (unsigned short)4;
#line 1257
      tmp = __errno_location();
#line 1257
      cur->fts_errno = *tmp;
      }
    }
#line 1259
    return ((FTSENT *)((void *)0));
  }
#line 1264
  if ((int )cur->fts_info == 11) {
    {
#line 1265
    cur->fts_info = fts_stat(sp, cur, (_Bool)0);
    }
  }
#line 1272
  if (type == 2) {
#line 1273
    nlinks = (nlink_t )0;
#line 1275
    nostat = (_Bool)0;
  } else
#line 1276
  if (sp->fts_options & 8) {
#line 1276
    if (sp->fts_options & 16) {
#line 1277
      if (sp->fts_options & 32) {
#line 1277
        tmp___2 = 0;
      } else {
#line 1277
        tmp___2 = 2;
      }
#line 1277
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___2;
#line 1279
      nostat = (_Bool)1;
    } else {
#line 1281
      nlinks = (nlink_t )-1;
#line 1282
      nostat = (_Bool)0;
    }
  } else {
#line 1281
    nlinks = (nlink_t )-1;
#line 1282
    nostat = (_Bool)0;
  }
#line 1300
  if (nlinks) {
#line 1300
    goto _L___0;
  } else
#line 1300
  if (type == 3) {
    _L___0: /* CIL Label */ 
    {
#line 1301
    tmp___3 = dirfd(dirp);
#line 1301
    dir_fd = tmp___3;
    }
#line 1302
    if (sp->fts_options & 512) {
#line 1302
      if (0 <= dir_fd) {
        {
#line 1303
        dir_fd = dup_safer(dir_fd);
        }
      }
    }
#line 1304
    if (dir_fd < 0) {
#line 1304
      goto _L;
    } else {
      {
#line 1304
      tmp___5 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1304
      if (tmp___5) {
        _L: /* CIL Label */ 
#line 1305
        if (nlinks) {
#line 1305
          if (type == 3) {
            {
#line 1306
            tmp___4 = __errno_location();
#line 1306
            cur->fts_errno = *tmp___4;
            }
          }
        }
        {
#line 1307
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1308
        descend = (_Bool)0;
#line 1309
        closedir(dirp);
        }
#line 1310
        if (sp->fts_options & 512) {
#line 1310
          if (0 <= dir_fd) {
            {
#line 1311
            close(dir_fd);
            }
          }
        }
#line 1312
        dirp = (DIR *)((void *)0);
      } else {
#line 1314
        descend = (_Bool)1;
      }
    }
  } else {
#line 1316
    descend = (_Bool)0;
  }
#line 1328
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1328
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1328
    len = cur->fts_pathlen;
  }
#line 1329
  if (sp->fts_options & 4) {
#line 1330
    cp = sp->fts_path + len;
#line 1331
    tmp___6 = cp;
#line 1331
    cp ++;
#line 1331
    *tmp___6 = (char )'/';
  } else {
#line 1334
    cp = (char *)((void *)0);
  }
#line 1336
  len ++;
#line 1337
  maxlen = sp->fts_pathlen - len;
#line 1339
  level = cur->fts_level + 1L;
#line 1342
  doadjust = (_Bool)0;
#line 1343
  tail = (FTSENT *)((void *)0);
#line 1343
  head = tail;
#line 1343
  nitems = (size_t )0;
  {
#line 1343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1343
    if (dirp) {
      {
#line 1343
      dp = readdir(dirp);
      }
#line 1343
      if (! dp) {
#line 1343
        goto while_break;
      }
    } else {
#line 1343
      goto while_break;
    }
#line 1346
    if (! (sp->fts_options & 32)) {
#line 1346
      if ((int )dp->d_name[0] == 46) {
#line 1346
        if (! dp->d_name[1]) {
#line 1347
          goto __Cont;
        } else
#line 1346
        if ((int )dp->d_name[1] == 46) {
#line 1346
          if (! dp->d_name[2]) {
#line 1347
            goto __Cont;
          }
        }
      }
    }
    {
#line 1349
    tmp___7 = strlen((char const   *)(dp->d_name));
#line 1349
    p = fts_alloc(sp, (char const   *)(dp->d_name), tmp___7);
    }
#line 1349
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1351
      goto mem1;
    }
    {
#line 1352
    tmp___12 = strlen((char const   *)(dp->d_name));
    }
#line 1352
    if (tmp___12 >= maxlen) {
      {
#line 1354
      oldaddr = (void *)sp->fts_path;
#line 1355
      tmp___10 = strlen((char const   *)(dp->d_name));
#line 1355
      tmp___11 = fts_palloc(sp, (tmp___10 + len) + 1UL);
      }
#line 1355
      if (! tmp___11) {
        mem1: 
        {
#line 1361
        tmp___8 = __errno_location();
#line 1361
        saved_errno = *tmp___8;
#line 1362
        free((void *)p);
#line 1363
        fts_lfree(head);
#line 1364
        closedir(dirp);
#line 1365
        cur->fts_info = (unsigned short)7;
#line 1366
        sp->fts_options |= 8192;
#line 1367
        tmp___9 = __errno_location();
#line 1367
        *tmp___9 = saved_errno;
        }
#line 1368
        return ((FTSENT *)((void *)0));
      }
#line 1371
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1372
        doadjust = (_Bool)1;
#line 1373
        if (sp->fts_options & 4) {
#line 1374
          cp = sp->fts_path + len;
        }
      }
#line 1376
      maxlen = sp->fts_pathlen - len;
    }
    {
#line 1379
    tmp___13 = strlen((char const   *)(dp->d_name));
#line 1379
    new_len = len + tmp___13;
    }
#line 1380
    if (new_len < len) {
      {
#line 1387
      free((void *)p);
#line 1388
      fts_lfree(head);
#line 1389
      closedir(dirp);
#line 1390
      cur->fts_info = (unsigned short)7;
#line 1391
      sp->fts_options |= 8192;
#line 1392
      tmp___14 = __errno_location();
#line 1392
      *tmp___14 = 36;
      }
#line 1393
      return ((FTSENT *)((void *)0));
    }
#line 1395
    p->fts_level = level;
#line 1396
    p->fts_parent = sp->fts_cur;
#line 1397
    p->fts_pathlen = new_len;
#line 1405
    p->fts_statp[0].st_ino = dp->d_ino;
#line 1408
    if (sp->fts_options & 4) {
      {
#line 1409
      p->fts_accpath = p->fts_path;
#line 1410
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1412
      p->fts_accpath = p->fts_name;
    }
#line 1414
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1414
      goto _L___1;
    } else
#line 1414
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1427
      if (sp->fts_options & 16) {
#line 1427
        if (sp->fts_options & 8) {
#line 1427
          if ((int )dp->d_type != 0) {
#line 1427
            if (! ((int )dp->d_type == 4)) {
#line 1427
              tmp___15 = 1;
            } else {
#line 1427
              tmp___15 = 0;
            }
          } else {
#line 1427
            tmp___15 = 0;
          }
        } else {
#line 1427
          tmp___15 = 0;
        }
      } else {
#line 1427
        tmp___15 = 0;
      }
      {
#line 1427
      skip_stat = (_Bool )tmp___15;
#line 1431
      p->fts_info = (unsigned short)11;
#line 1434
      set_stat_type(p->fts_statp, (unsigned int )dp->d_type);
#line 1435
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      }
#line 1436
      if (sp->fts_options & 16) {
#line 1436
        if ((int )dp->d_type == 4) {
#line 1436
          tmp___16 = 1;
        } else {
#line 1436
          tmp___16 = 0;
        }
      } else {
#line 1436
        tmp___16 = 0;
      }
#line 1436
      is_dir = (_Bool )tmp___16;
    } else {
      {
#line 1439
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
#line 1440
      if ((int )p->fts_info == 1) {
#line 1440
        tmp___17 = 1;
      } else
#line 1440
      if ((int )p->fts_info == 2) {
#line 1440
        tmp___17 = 1;
      } else
#line 1440
      if ((int )p->fts_info == 5) {
#line 1440
        tmp___17 = 1;
      } else {
#line 1440
        tmp___17 = 0;
      }
#line 1440
      is_dir = (_Bool )tmp___17;
    }
#line 1446
    if (nlinks > 0UL) {
#line 1446
      if (is_dir) {
#line 1447
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1450
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1451
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1452
      tail = p;
#line 1452
      head = tail;
    } else {
#line 1454
      tail->fts_link = p;
#line 1455
      tail = p;
    }
#line 1457
    nitems ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1459
  if (dirp) {
    {
#line 1460
    closedir(dirp);
    }
  }
#line 1466
  if (doadjust) {
    {
#line 1467
    fts_padjust(sp, head);
    }
  }
#line 1473
  if (sp->fts_options & 4) {
#line 1474
    if (len == sp->fts_pathlen) {
#line 1475
      cp --;
    } else
#line 1474
    if (nitems == 0UL) {
#line 1475
      cp --;
    }
#line 1476
    *cp = (char )'\000';
  }
#line 1486
  if (descend) {
#line 1486
    if (type == 1) {
#line 1486
      goto _L___2;
    } else
#line 1486
    if (! nitems) {
      _L___2: /* CIL Label */ 
#line 1486
      if (cur->fts_level == 0L) {
        {
#line 1486
        fd_ring_clear(& sp->fts_fd_ring);
        }
#line 1486
        if (! (sp->fts_options & 4)) {
#line 1486
          if (sp->fts_options & 512) {
#line 1486
            if (sp->fts_options & 512) {
#line 1486
              tmp___18 = -100;
            } else {
#line 1486
              tmp___18 = sp->fts_rfd;
            }
            {
#line 1486
            cwd_advance_fd(sp, tmp___18, (_Bool)1);
#line 1486
            tmp___21 = 0;
            }
          } else {
#line 1486
            if (sp->fts_options & 512) {
#line 1486
              tmp___19 = -100;
            } else {
#line 1486
              tmp___19 = sp->fts_rfd;
            }
            {
#line 1486
            tmp___20 = fchdir(tmp___19);
#line 1486
            tmp___21 = tmp___20;
            }
          }
#line 1486
          if (tmp___21) {
#line 1486
            tmp___22 = 1;
          } else {
#line 1486
            tmp___22 = 0;
          }
        } else {
#line 1486
          tmp___22 = 0;
        }
#line 1486
        tmp___24 = tmp___22;
      } else {
        {
#line 1486
        tmp___23 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1486
        tmp___24 = tmp___23;
        }
      }
#line 1486
      if (tmp___24) {
        {
#line 1490
        cur->fts_info = (unsigned short)7;
#line 1491
        sp->fts_options |= 8192;
#line 1492
        fts_lfree(head);
        }
#line 1493
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1497
  if (! nitems) {
#line 1498
    if (type == 3) {
#line 1499
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1500
    fts_lfree(head);
    }
#line 1501
    return ((FTSENT *)((void *)0));
  }
#line 1508
  if (nitems > 10000UL) {
#line 1508
    if (! sp->fts_compar) {
#line 1508
      if (sp->fts_options & 512) {
        {
#line 1508
        tmp___25 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        }
#line 1508
        if (tmp___25) {
          {
#line 1512
          sp->fts_compar = & fts_compare_ino;
#line 1513
          head = fts_sort(sp, head, nitems);
#line 1514
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1518
  if (sp->fts_compar) {
#line 1518
    if (nitems > 1UL) {
      {
#line 1519
      head = fts_sort(sp, head, nitems);
      }
    }
  }
#line 1520
  return (head);
}
}
#line 1667 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1671
  sbp = p->fts_statp;
#line 1674
  if (p->fts_level == 0L) {
#line 1674
    if (sp->fts_options & 1) {
#line 1675
      follow = (_Bool)1;
    }
  }
#line 1691
  if (sp->fts_options & 2) {
#line 1691
    goto _L;
  } else
#line 1691
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1692
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1692
    if (tmp___3) {
      {
#line 1693
      tmp = __errno_location();
#line 1693
      saved_errno = *tmp;
#line 1694
      tmp___1 = __errno_location();
      }
#line 1694
      if (*tmp___1 == 2) {
        {
#line 1694
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1694
        if (tmp___2 == 0) {
          {
#line 1696
          tmp___0 = __errno_location();
#line 1696
          *tmp___0 = 0;
          }
#line 1697
          return ((unsigned short)13);
        }
      }
#line 1699
      p->fts_errno = saved_errno;
#line 1700
      goto err;
    }
  } else {
    {
#line 1702
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1702
    if (tmp___5) {
      {
#line 1704
      tmp___4 = __errno_location();
#line 1704
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1705
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1706
      return ((unsigned short)10);
    }
  }
#line 1709
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1710
    if (sp->fts_options & 32) {
#line 1710
      tmp___6 = 0;
    } else {
#line 1710
      tmp___6 = 2;
    }
#line 1710
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1712
    if ((int )p->fts_name[0] == 46) {
#line 1712
      if (! p->fts_name[1]) {
#line 1712
        goto _L___0;
      } else
#line 1712
      if ((int )p->fts_name[1] == 46) {
#line 1712
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1714
          if (p->fts_level == 0L) {
#line 1714
            tmp___7 = 1;
          } else {
#line 1714
            tmp___7 = 5;
          }
#line 1714
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1738
    return ((unsigned short)1);
  }
#line 1740
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1741
    return ((unsigned short)12);
  }
#line 1742
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1743
    return ((unsigned short)8);
  }
#line 1744
  return ((unsigned short)3);
}
}
#line 1747 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1755
  pa = (FTSENT const   **)a;
#line 1756
  pb = (FTSENT const   **)b;
#line 1757
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1757
  return (tmp);
}
}
#line 1760 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare___0)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1774
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1774
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1774
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1774
      tmp = & fts_compar;
    }
  } else {
#line 1774
    tmp = & fts_compar;
  }
#line 1774
  compare___0 = tmp;
#line 1787
  if (nitems > sp->fts_nitems) {
#line 1790
    sp->fts_nitems = nitems + 40UL;
#line 1791
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1794
      free((void *)sp->fts_array);
#line 1795
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1796
      sp->fts_nitems = (size_t )0;
      }
#line 1797
      return (head);
    } else {
      {
#line 1791
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1791
      a = (FTSENT **)tmp___0;
      }
#line 1791
      if (! a) {
        {
#line 1794
        free((void *)sp->fts_array);
#line 1795
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1796
        sp->fts_nitems = (size_t )0;
        }
#line 1797
        return (head);
      }
    }
#line 1799
    sp->fts_array = a;
  }
#line 1801
  ap = sp->fts_array;
#line 1801
  p = head;
  {
#line 1801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1801
    if (! p) {
#line 1801
      goto while_break;
    }
#line 1802
    tmp___1 = ap;
#line 1802
    ap ++;
#line 1802
    *tmp___1 = p;
#line 1801
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1803
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare___0);
#line 1804
  ap = sp->fts_array;
#line 1804
  head = *ap;
  }
  {
#line 1804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1804
    nitems --;
#line 1804
    if (! nitems) {
#line 1804
      goto while_break___0;
    }
#line 1805
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1804
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1806
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1807
  return (head);
}
}
#line 1810 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1821
  len = sizeof(FTSENT ) + namelen;
#line 1822
  tmp = malloc(len);
#line 1822
  p = (FTSENT *)tmp;
  }
#line 1822
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1823
    return ((FTSENT *)((void *)0));
  }
  {
#line 1826
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
#line 1827
  p->fts_name[namelen] = (char )'\000';
#line 1829
  p->fts_namelen = namelen;
#line 1830
  p->fts_fts = sp;
#line 1831
  p->fts_path = sp->fts_path;
#line 1832
  p->fts_errno = 0;
#line 1833
  p->fts_flags = (unsigned short)0;
#line 1834
  p->fts_instr = (unsigned short)3;
#line 1835
  p->fts_number = 0L;
#line 1836
  p->fts_pointer = (void *)0;
  }
#line 1837
  return (p);
}
}
#line 1840 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_lfree(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1847
    p = head;
#line 1847
    if (! p) {
#line 1847
      goto while_break;
    }
    {
#line 1848
    head = head->fts_link;
#line 1849
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1851
  return;
}
}
#line 1860 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1865
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1870
  if (new_len < sp->fts_pathlen) {
    {
#line 1871
    free((void *)sp->fts_path);
#line 1872
    sp->fts_path = (char *)((void *)0);
#line 1873
    tmp = __errno_location();
#line 1873
    *tmp = 36;
    }
#line 1874
    return ((_Bool)0);
  }
  {
#line 1876
  sp->fts_pathlen = new_len;
#line 1877
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1877
  p = (char *)tmp___0;
  }
#line 1878
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1879
    free((void *)sp->fts_path);
#line 1880
    sp->fts_path = (char *)((void *)0);
    }
#line 1881
    return ((_Bool)0);
  }
#line 1883
  sp->fts_path = p;
#line 1884
  return ((_Bool)1);
}
}
#line 1891 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 1896
  addr = sp->fts_path;
#line 1906
  p = sp->fts_child;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    if (! p) {
#line 1906
      goto while_break;
    }
    {
#line 1907
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1907
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1907
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1907
      p->fts_path = addr;
#line 1907
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1906
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1910
  p = head;
  {
#line 1910
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1910
    if (! (p->fts_level >= 0L)) {
#line 1910
      goto while_break___1;
    }
    {
#line 1911
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1911
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1911
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1911
      p->fts_path = addr;
#line 1911
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1912
    if (p->fts_link) {
#line 1912
      p = p->fts_link;
    } else {
#line 1912
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1914
  return;
}
}
#line 1916 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static size_t fts_maxarglen(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 1922
  max = (size_t )0;
  {
#line 1922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1922
    if (! *argv) {
#line 1922
      goto while_break;
    }
    {
#line 1923
    len = strlen((char const   *)*argv);
    }
#line 1923
    if (len > max) {
#line 1924
      max = len;
    }
#line 1922
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1925
  return (max + 1UL);
}
}
#line 1937 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 1942
  if (dir) {
    {
#line 1942
    tmp = strcmp(dir, "..");
    }
#line 1942
    if (tmp == 0) {
#line 1942
      tmp___0 = 1;
    } else {
#line 1942
      tmp___0 = 0;
    }
  } else {
#line 1942
    tmp___0 = 0;
  }
#line 1942
  is_dotdot = (_Bool )tmp___0;
#line 1949
  if (sp->fts_options & 4) {
#line 1951
    if (sp->fts_options & 512) {
#line 1951
      if (0 <= fd) {
        {
#line 1952
        close(fd);
        }
      }
    }
#line 1953
    return (0);
  }
#line 1956
  if (fd < 0) {
#line 1956
    if (is_dotdot) {
#line 1956
      if (sp->fts_options & 512) {
        {
#line 1963
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 1963
        if (! tmp___1) {
          {
#line 1967
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 1968
          is_dotdot = (_Bool)1;
          }
#line 1969
          if (0 <= parent_fd) {
#line 1971
            fd = parent_fd;
#line 1972
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 1977
  newfd = fd;
#line 1978
  if (fd < 0) {
    {
#line 1978
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 1978
    if (newfd < 0) {
#line 1979
      return (-1);
    }
  }
#line 1988
  if (sp->fts_options & 2) {
#line 1988
    goto _L;
  } else
#line 1988
  if (dir) {
    {
#line 1988
    tmp___4 = strcmp(dir, "..");
    }
#line 1988
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 1992
      tmp___2 = fstat(newfd, & sb);
      }
#line 1992
      if (tmp___2) {
#line 1994
        ret = -1;
#line 1995
        goto bail;
      }
#line 1997
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2000
        tmp___3 = __errno_location();
#line 2000
        *tmp___3 = 2;
#line 2001
        ret = -1;
        }
#line 2002
        goto bail;
      } else
#line 1997
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2000
        tmp___3 = __errno_location();
#line 2000
        *tmp___3 = 2;
#line 2001
        ret = -1;
        }
#line 2002
        goto bail;
      }
    }
  }
#line 2006
  if (sp->fts_options & 512) {
    {
#line 2008
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2009
    return (0);
  }
  {
#line 2012
  ret = fchdir(newfd);
  }
  bail: 
#line 2014
  if (fd < 0) {
    {
#line 2016
    tmp___5 = __errno_location();
#line 2016
    oerrno = *tmp___5;
#line 2017
    close(newfd);
#line 2018
    tmp___6 = __errno_location();
#line 2018
    *tmp___6 = oerrno;
    }
  }
#line 2020
  return (ret);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/fsusage.h"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf ) ;
#line 94 "/home/khheo/project/benchmark/coreutils-7.1/lib/fsusage.c"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) 
{ 
  struct statfs fsd ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;

  {
  {
#line 173
  tmp = statfs(file, & fsd);
  }
#line 173
  if (tmp < 0) {
#line 174
    return (-1);
  }
#line 176
  if (sizeof(fsd.f_bsize) < sizeof(uintmax_t )) {
#line 176
    if (sizeof(fsd.f_bsize) < sizeof(int )) {
#line 176
      tmp___1 = - (1 << sizeof(fsd.f_bsize) * 8UL);
    } else {
#line 176
      tmp___1 = 0;
    }
#line 176
    if (~ fsd.f_bsize == (__fsword_t )tmp___1) {
#line 176
      fsp->fsu_blocksize = 0xffffffffffffffffUL;
    } else {
#line 176
      fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
    }
  } else {
#line 176
    fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
  }
#line 227
  if (sizeof(fsd.f_blocks) < sizeof(uintmax_t )) {
#line 227
    if (sizeof(fsd.f_blocks) < sizeof(int )) {
#line 227
      tmp___3 = - (1 << sizeof(fsd.f_blocks) * 8UL);
    } else {
#line 227
      tmp___3 = 0;
    }
#line 227
    if (~ fsd.f_blocks == (__fsblkcnt_t )tmp___3) {
#line 227
      fsp->fsu_blocks = 0xffffffffffffffffUL;
    } else {
#line 227
      fsp->fsu_blocks = fsd.f_blocks;
    }
  } else {
#line 227
    fsp->fsu_blocks = fsd.f_blocks;
  }
#line 228
  if (sizeof(fsd.f_bfree) < sizeof(uintmax_t )) {
#line 228
    if (sizeof(fsd.f_bfree) < sizeof(int )) {
#line 228
      tmp___5 = - (1 << sizeof(fsd.f_bfree) * 8UL);
    } else {
#line 228
      tmp___5 = 0;
    }
#line 228
    if (~ fsd.f_bfree == (__fsblkcnt_t )tmp___5) {
#line 228
      fsp->fsu_bfree = 0xffffffffffffffffUL;
    } else {
#line 228
      fsp->fsu_bfree = fsd.f_bfree;
    }
  } else {
#line 228
    fsp->fsu_bfree = fsd.f_bfree;
  }
#line 229
  fsp->fsu_bavail = fsd.f_bavail | ~ ((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) - 1UL);
#line 230
  fsp->fsu_bavail_top_bit_set = (_Bool )((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) != 0UL);
#line 231
  if (sizeof(fsd.f_files) < sizeof(uintmax_t )) {
#line 231
    if (sizeof(fsd.f_files) < sizeof(int )) {
#line 231
      tmp___7 = - (1 << sizeof(fsd.f_files) * 8UL);
    } else {
#line 231
      tmp___7 = 0;
    }
#line 231
    if (~ fsd.f_files == (__fsfilcnt_t )tmp___7) {
#line 231
      fsp->fsu_files = 0xffffffffffffffffUL;
    } else {
#line 231
      fsp->fsu_files = fsd.f_files;
    }
  } else {
#line 231
    fsp->fsu_files = fsd.f_files;
  }
#line 232
  if (sizeof(fsd.f_ffree) < sizeof(uintmax_t )) {
#line 232
    if (sizeof(fsd.f_ffree) < sizeof(int )) {
#line 232
      tmp___9 = - (1 << sizeof(fsd.f_ffree) * 8UL);
    } else {
#line 232
      tmp___9 = 0;
    }
#line 232
    if (~ fsd.f_ffree == (__fsfilcnt_t )tmp___9) {
#line 232
      fsp->fsu_ffree = 0xffffffffffffffffUL;
    } else {
#line 232
      fsp->fsu_ffree = fsd.f_ffree;
    }
  } else {
#line 232
    fsp->fsu_ffree = fsd.f_ffree;
  }
#line 236
  return (0);
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/fseterr.h"
void fseterr(FILE *fp ) ;
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/fseterr.c"
void fseterr(FILE *fp ) 
{ 


  {
#line 33
  fp->_flags |= 32;
#line 72
  return;
}
}
#line 707 "/usr/include/stdio.h"
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/fseeko.c"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) 
{ 
  off_t pos ;
  off_t tmp ;
  int tmp___0 ;
  __off_t tmp___1 ;
  int tmp___2 ;

  {
#line 45
  if ((unsigned long )fp->_IO_read_end == (unsigned long )fp->_IO_read_ptr) {
#line 45
    if ((unsigned long )fp->_IO_write_ptr == (unsigned long )fp->_IO_write_base) {
#line 45
      if ((unsigned long )fp->_IO_save_base == (unsigned long )((void *)0)) {
#line 93
        if (whence == 2) {
#line 93
          if (offset > 0L) {
#line 93
            tmp = (off_t )0;
          } else {
#line 93
            tmp = offset;
          }
        } else {
#line 93
          tmp = offset;
        }
        {
#line 93
        tmp___0 = fileno(fp);
#line 93
        tmp___1 = lseek(tmp___0, tmp, whence);
#line 93
        pos = tmp___1;
        }
#line 97
        if (pos == -1L) {
#line 102
          return (-1);
        }
#line 106
        fp->_flags &= -17;
#line 118
        if (whence == 2) {
#line 118
          if (! (offset > 0L)) {
#line 119
            return (0);
          }
        } else {
#line 119
          return (0);
        }
      }
    }
  }
  {
#line 121
  tmp___2 = fseeko(fp, offset, whence);
  }
#line 121
  return (tmp___2);
}
}
#line 477 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadahead.h"
size_t freadahead(FILE *fp ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadseek.c"
__inline static void freadptrinc(FILE *fp , size_t increment ) 
{ 


  {
#line 38
  fp->_IO_read_ptr += increment;
#line 60
  return;
}
}
#line 62 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadseek.c"
int freadseek(FILE *fp , size_t offset ) 
{ 
  size_t total_buffered ;
  int fd ;
  size_t buffered ;
  size_t increment ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char buf___1[4096] ;
  size_t count ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;

  {
#line 68
  if (offset == 0UL) {
#line 69
    return (0);
  }
  {
#line 73
  total_buffered = freadahead(fp);
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (total_buffered > 0UL)) {
#line 76
      goto while_break;
    }
    {
#line 80
    tmp___0 = freadptr(fp, & buffered);
    }
#line 80
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 80
      if (buffered > 0UL) {
#line 82
        if (buffered < offset) {
#line 82
          tmp = buffered;
        } else {
#line 82
          tmp = offset;
        }
        {
#line 82
        increment = tmp;
#line 84
        freadptrinc(fp, increment);
#line 85
        offset -= increment;
        }
#line 86
        if (offset == 0UL) {
#line 87
          return (0);
        }
#line 88
        total_buffered -= increment;
#line 89
        if (total_buffered == 0UL) {
#line 90
          goto while_break;
        }
      }
    }
    {
#line 94
    tmp___1 = fgetc(fp);
    }
#line 94
    if (tmp___1 == -1) {
#line 95
      goto eof;
    }
#line 96
    offset --;
#line 97
    if (offset == 0UL) {
#line 98
      return (0);
    }
#line 99
    total_buffered --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  fd = fileno(fp);
  }
#line 104
  if (fd >= 0) {
    {
#line 104
    tmp___5 = lseek(fd, (__off_t )0, 1);
    }
#line 104
    if (tmp___5 >= 0L) {
      {
#line 107
      tmp___2 = rpl_fseeko(fp, (off_t )offset, 1);
      }
#line 107
      return (tmp___2);
    } else {
#line 104
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (sizeof(buf___1) < offset) {
#line 117
        tmp___3 = sizeof(buf___1);
      } else {
#line 117
        tmp___3 = offset;
      }
      {
#line 117
      count = tmp___3;
#line 118
      tmp___4 = fread((void */* __restrict  */)(buf___1), (size_t )1, count, (FILE */* __restrict  */)fp);
      }
#line 118
      if (tmp___4 < count) {
#line 119
        goto eof;
      }
#line 120
      offset -= count;
#line 115
      if (! (offset > 0UL)) {
#line 115
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    return (0);
  }
  eof: 
  {
#line 129
  tmp___6 = ferror(fp);
  }
#line 129
  if (tmp___6) {
#line 130
    return (-1);
  } else {
#line 133
    return (0);
  }
}
}
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadptr.c"
char const   *freadptr(FILE *fp , size_t *sizep ) 
{ 
  size_t size ;

  {
#line 33
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 34
    return ((char const   *)((void *)0));
  }
#line 35
  size = (size_t )(fp->_IO_read_end - fp->_IO_read_ptr);
#line 36
  if (size == 0UL) {
#line 37
    return ((char const   *)((void *)0));
  }
#line 38
  *sizep = size;
#line 39
  return ((char const   *)fp->_IO_read_ptr);
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/freadahead.c"
size_t freadahead(FILE *fp ) 
{ 
  long tmp ;

  {
#line 29
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 30
    return ((size_t )0);
  }
#line 31
  if (fp->_flags & 256) {
#line 31
    tmp = fp->_IO_save_end - fp->_IO_save_base;
  } else {
#line 31
    tmp = 0L;
  }
#line 31
  return ((size_t )((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
}
}
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/fpurge.h"
int fpurge(FILE *fp ) ;
#line 72 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) __fpurge)(FILE *__fp ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/fpurge.c"
int fpurge(FILE *fp ) 
{ 


  {
  {
#line 34
  __fpurge(fp);
  }
#line 36
  return (0);
}
}
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 125 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 282 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    tmp___0 = len;
#line 285
    len --;
#line 285
    if (! (tmp___0 > 0UL)) {
#line 285
      goto while_break;
    }
    {
#line 287
    tmp = tolower((int )((unsigned char )*src));
#line 287
    fputc(tmp, fp);
#line 288
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 292 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    tmp___0 = len;
#line 295
    len --;
#line 295
    if (! (tmp___0 > 0UL)) {
#line 295
      goto while_break;
    }
    {
#line 297
    tmp = toupper((int )((unsigned char )*src));
#line 297
    fputc(tmp, fp);
#line 298
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 358 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 364
  big_enough_multiple_of_7 = 378;
#line 365
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 406 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static size_t strftime_case_(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                             int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___1 ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  size_t _i___25 ;
  size_t _i___26 ;

  {
#line 416
  maxsize = (size_t )-1;
#line 419
  hour12 = (int )tp->tm_hour;
#line 444
  i = (size_t )0;
#line 445
  p = s;
#line 460
  zone = (char const   *)((void *)0);
#line 468
  zone = (char const   *)tp->tm_zone;
#line 486
  if (hour12 > 12) {
#line 487
    hour12 -= 12;
  } else
#line 489
  if (hour12 == 0) {
#line 490
    hour12 = 12;
  }
#line 492
  f = format;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((int const   )*f != 0)) {
#line 492
      goto while_break;
    }
#line 494
    pad = 0;
#line 496
    digits = 0;
#line 510
    width = -1;
#line 511
    to_lowcase = (_Bool)0;
#line 512
    to_uppcase = upcase;
#line 514
    change_case = (_Bool)0;
#line 597
    if ((int const   )*f != 37) {
      {
#line 599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 599
        _n = 1;
#line 599
        _delta = width - _n;
#line 599
        if (_delta > 0) {
#line 599
          tmp = _delta;
        } else {
#line 599
          tmp = 0;
        }
#line 599
        _incr = _n + tmp;
#line 599
        if ((size_t )_incr >= maxsize - i) {
#line 599
          return ((size_t )0);
        }
#line 599
        if (p) {
#line 599
          if (digits == 0) {
#line 599
            if (_delta > 0) {
#line 599
              if (pad == 48) {
                {
#line 599
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 599
                  _i = (size_t )0;
                  {
#line 599
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 599
                    if (! (_i < (size_t )_delta)) {
#line 599
                      goto while_break___2;
                    }
                    {
#line 599
                    fputc('0', p);
#line 599
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 599
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 599
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 599
                  _i___0 = (size_t )0;
                  {
#line 599
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 599
                    if (! (_i___0 < (size_t )_delta)) {
#line 599
                      goto while_break___4;
                    }
                    {
#line 599
                    fputc(' ', p);
#line 599
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 599
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 599
          fputc((int )*f, p);
          }
        }
#line 599
        i += (size_t )_incr;
#line 599
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 600
      goto __Cont;
    }
    {
#line 606
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 608
      f ++;
      {
#line 613
      if ((int const   )*f == 48) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 45) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 95) {
#line 613
        goto case_48;
      }
#line 618
      if ((int const   )*f == 94) {
#line 618
        goto case_94;
      }
#line 621
      if ((int const   )*f == 35) {
#line 621
        goto case_35;
      }
#line 625
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 614
      pad = (int )*f;
#line 615
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 619
      to_uppcase = (_Bool)1;
#line 620
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 622
      change_case = (_Bool)1;
#line 623
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 626
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 628
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 632
    if ((unsigned int )*f - 48U <= 9U) {
#line 634
      width = 0;
      {
#line 635
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 637
        if (width > 214748364) {
#line 640
          width = 2147483647;
        } else
#line 637
        if (width == 214748364) {
#line 637
          if ((int const   )*f - 48 > 7) {
#line 640
            width = 2147483647;
          } else {
#line 643
            width *= 10;
#line 644
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 643
          width *= 10;
#line 644
          width += (int )((int const   )*f - 48);
        }
#line 646
        f ++;
#line 635
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 635
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 655
    if ((int const   )*f == 79) {
#line 655
      goto case_79;
    }
#line 655
    if ((int const   )*f == 69) {
#line 655
      goto case_79;
    }
#line 659
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 656
    tmp___0 = f;
#line 656
    f ++;
#line 656
    modifier = (int )*tmp___0;
#line 657
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 660
    modifier = 0;
#line 661
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 665
    format_char = (int )*f;
    {
#line 688
    if (format_char == 37) {
#line 688
      goto case_37;
    }
#line 694
    if (format_char == 97) {
#line 694
      goto case_97;
    }
#line 709
    if (format_char == 65) {
#line 709
      goto case_65;
    }
#line 725
    if (format_char == 104) {
#line 725
      goto case_104;
    }
#line 725
    if (format_char == 98) {
#line 725
      goto case_104;
    }
#line 740
    if (format_char == 66) {
#line 740
      goto case_66;
    }
#line 755
    if (format_char == 99) {
#line 755
      goto case_99;
    }
#line 814
    if (format_char == 67) {
#line 814
      goto case_67;
    }
#line 843
    if (format_char == 120) {
#line 843
      goto case_120;
    }
#line 856
    if (format_char == 68) {
#line 856
      goto case_68;
    }
#line 862
    if (format_char == 100) {
#line 862
      goto case_100;
    }
#line 868
    if (format_char == 101) {
#line 868
      goto case_101;
    }
#line 994
    if (format_char == 70) {
#line 994
      goto case_70;
    }
#line 1000
    if (format_char == 72) {
#line 1000
      goto case_72;
    }
#line 1006
    if (format_char == 73) {
#line 1006
      goto case_73;
    }
#line 1012
    if (format_char == 107) {
#line 1012
      goto case_107;
    }
#line 1018
    if (format_char == 108) {
#line 1018
      goto case_108;
    }
#line 1024
    if (format_char == 106) {
#line 1024
      goto case_106;
    }
#line 1030
    if (format_char == 77) {
#line 1030
      goto case_77;
    }
#line 1036
    if (format_char == 109) {
#line 1036
      goto case_109;
    }
#line 1043
    if (format_char == 78) {
#line 1043
      goto case_78;
    }
#line 1061
    if (format_char == 110) {
#line 1061
      goto case_110;
    }
#line 1065
    if (format_char == 80) {
#line 1065
      goto case_80;
    }
#line 1072
    if (format_char == 112) {
#line 1072
      goto case_112;
    }
#line 1085
    if (format_char == 82) {
#line 1085
      goto case_82;
    }
#line 1089
    if (format_char == 114) {
#line 1089
      goto case_114;
    }
#line 1100
    if (format_char == 83) {
#line 1100
      goto case_83;
    }
#line 1106
    if (format_char == 115) {
#line 1106
      goto case_115;
    }
#line 1133
    if (format_char == 88) {
#line 1133
      goto case_88;
    }
#line 1146
    if (format_char == 84) {
#line 1146
      goto case_84;
    }
#line 1150
    if (format_char == 116) {
#line 1150
      goto case_116;
    }
#line 1154
    if (format_char == 117) {
#line 1154
      goto case_117;
    }
#line 1157
    if (format_char == 85) {
#line 1157
      goto case_85;
    }
#line 1165
    if (format_char == 71) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 103) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 86) {
#line 1165
      goto case_71;
    }
#line 1221
    if (format_char == 87) {
#line 1221
      goto case_87;
    }
#line 1227
    if (format_char == 119) {
#line 1227
      goto case_119;
    }
#line 1233
    if (format_char == 89) {
#line 1233
      goto case_89;
    }
#line 1257
    if (format_char == 121) {
#line 1257
      goto case_121;
    }
#line 1280
    if (format_char == 90) {
#line 1280
      goto case_90;
    }
#line 1309
    if (format_char == 58) {
#line 1309
      goto case_58;
    }
#line 1319
    if (format_char == 122) {
#line 1319
      goto case_122;
    }
#line 1397
    if (format_char == 0) {
#line 1397
      goto case_0___0;
    }
#line 1400
    goto bad_format;
    case_37: /* CIL Label */ 
#line 689
    if (modifier != 0) {
#line 690
      goto bad_format;
    }
    {
#line 691
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 691
      _n___0 = 1;
#line 691
      _delta___0 = width - _n___0;
#line 691
      if (_delta___0 > 0) {
#line 691
        tmp___1 = _delta___0;
      } else {
#line 691
        tmp___1 = 0;
      }
#line 691
      _incr___0 = _n___0 + tmp___1;
#line 691
      if ((size_t )_incr___0 >= maxsize - i) {
#line 691
        return ((size_t )0);
      }
#line 691
      if (p) {
#line 691
        if (digits == 0) {
#line 691
          if (_delta___0 > 0) {
#line 691
            if (pad == 48) {
              {
#line 691
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 691
                _i___1 = (size_t )0;
                {
#line 691
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 691
                  if (! (_i___1 < (size_t )_delta___0)) {
#line 691
                    goto while_break___9;
                  }
                  {
#line 691
                  fputc('0', p);
#line 691
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 691
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 691
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 691
                _i___2 = (size_t )0;
                {
#line 691
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 691
                  if (! (_i___2 < (size_t )_delta___0)) {
#line 691
                    goto while_break___11;
                  }
                  {
#line 691
                  fputc(' ', p);
#line 691
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 691
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 691
        fputc((int )*f, p);
        }
      }
#line 691
      i += (size_t )_incr___0;
#line 691
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 692
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 695
    if (modifier != 0) {
#line 696
      goto bad_format;
    }
#line 697
    if (change_case) {
#line 699
      to_uppcase = (_Bool)1;
#line 700
      to_lowcase = (_Bool)0;
    }
#line 706
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 710
    if (modifier != 0) {
#line 711
      goto bad_format;
    }
#line 712
    if (change_case) {
#line 714
      to_uppcase = (_Bool)1;
#line 715
      to_lowcase = (_Bool)0;
    }
#line 721
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 731
    if (modifier != 0) {
#line 732
      goto bad_format;
    }
#line 737
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 741
    if (modifier != 0) {
#line 742
      goto bad_format;
    }
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 752
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 756
    if (modifier == 79) {
#line 757
      goto bad_format;
    }
#line 766
    goto underlying_strftime;
    subformat: 
    {
#line 771
    tmp___2 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut, ns);
#line 771
    len = tmp___2;
    }
    {
#line 775
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 775
      _n___1 = (int )len;
#line 775
      _delta___1 = width - _n___1;
#line 775
      if (_delta___1 > 0) {
#line 775
        tmp___3 = _delta___1;
      } else {
#line 775
        tmp___3 = 0;
      }
#line 775
      _incr___1 = _n___1 + tmp___3;
#line 775
      if ((size_t )_incr___1 >= maxsize - i) {
#line 775
        return ((size_t )0);
      }
#line 775
      if (p) {
#line 775
        if (digits == 0) {
#line 775
          if (_delta___1 > 0) {
#line 775
            if (pad == 48) {
              {
#line 775
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 775
                _i___3 = (size_t )0;
                {
#line 775
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 775
                  if (! (_i___3 < (size_t )_delta___1)) {
#line 775
                    goto while_break___14;
                  }
                  {
#line 775
                  fputc('0', p);
#line 775
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 775
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 775
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 775
                _i___4 = (size_t )0;
                {
#line 775
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 775
                  if (! (_i___4 < (size_t )_delta___1)) {
#line 775
                    goto while_break___16;
                  }
                  {
#line 775
                  fputc(' ', p);
#line 775
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 775
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 775
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
        }
      }
#line 775
      i += (size_t )_incr___1;
#line 775
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 780
    goto switch_break___1;
    underlying_strftime: 
#line 788
    u = ufmt;
#line 801
    tmp___4 = u;
#line 801
    u ++;
#line 801
    *tmp___4 = (char )' ';
#line 802
    tmp___5 = u;
#line 802
    u ++;
#line 802
    *tmp___5 = (char )'%';
#line 803
    if (modifier != 0) {
#line 804
      tmp___6 = u;
#line 804
      u ++;
#line 804
      *tmp___6 = (char )modifier;
    }
    {
#line 805
    tmp___7 = u;
#line 805
    u ++;
#line 805
    *tmp___7 = (char )format_char;
#line 806
    *u = (char )'\000';
#line 807
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 808
    if (len___0 != 0UL) {
      {
#line 809
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 809
        _n___2 = (int )(len___0 - 1UL);
#line 809
        _delta___2 = width - _n___2;
#line 809
        if (_delta___2 > 0) {
#line 809
          tmp___8 = _delta___2;
        } else {
#line 809
          tmp___8 = 0;
        }
#line 809
        _incr___2 = _n___2 + tmp___8;
#line 809
        if ((size_t )_incr___2 >= maxsize - i) {
#line 809
          return ((size_t )0);
        }
#line 809
        if (p) {
#line 809
          if (digits == 0) {
#line 809
            if (_delta___2 > 0) {
#line 809
              if (pad == 48) {
                {
#line 809
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 809
                  _i___5 = (size_t )0;
                  {
#line 809
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 809
                    if (! (_i___5 < (size_t )_delta___2)) {
#line 809
                      goto while_break___19;
                    }
                    {
#line 809
                    fputc('0', p);
#line 809
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 809
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 809
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 809
                  _i___6 = (size_t )0;
                  {
#line 809
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 809
                    if (! (_i___6 < (size_t )_delta___2)) {
#line 809
                      goto while_break___21;
                    }
                    {
#line 809
                    fputc(' ', p);
#line 809
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 809
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
#line 809
          if (to_lowcase) {
            {
#line 809
            fwrite_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 809
          if (to_uppcase) {
            {
#line 809
            fwrite_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 809
            fwrite((void const   */* __restrict  */)(ubuf + 1), (size_t )_n___2, (size_t )1,
                   (FILE */* __restrict  */)p);
            }
          }
        }
#line 809
        i += (size_t )_incr___2;
#line 809
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 811
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 815
    if (modifier == 79) {
#line 816
      goto bad_format;
    }
#line 817
    if (modifier == 69) {
#line 833
      goto underlying_strftime;
    }
#line 838
    century = (int )(tp->tm_year / 100 + 19);
#line 839
    if (tp->tm_year % 100 < 0) {
#line 839
      if (0 < century) {
#line 839
        tmp___9 = 1;
      } else {
#line 839
        tmp___9 = 0;
      }
    } else {
#line 839
      tmp___9 = 0;
    }
#line 839
    century -= tmp___9;
#line 840
    digits = 2;
#line 840
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 840
    u_number_value = (unsigned int )century;
#line 840
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 844
    if (modifier == 79) {
#line 845
      goto bad_format;
    }
#line 854
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 857
    if (modifier != 0) {
#line 858
      goto bad_format;
    }
#line 859
    subfmt = "%m/%d/%y";
#line 860
    goto subformat;
    case_100: /* CIL Label */ 
#line 863
    if (modifier == 69) {
#line 864
      goto bad_format;
    }
#line 866
    digits = 2;
#line 866
    number_value = (int )tp->tm_mday;
#line 866
    goto do_number;
    case_101: /* CIL Label */ 
#line 869
    if (modifier == 69) {
#line 870
      goto bad_format;
    }
#line 872
    digits = 2;
#line 872
    number_value = (int )tp->tm_mday;
#line 872
    goto do_number_spacepad;
    do_tz_offset: 
#line 878
    always_output_a_sign = (_Bool)1;
#line 879
    goto do_number_body;
    do_number_spacepad: 
#line 883
    if (pad != 48) {
#line 883
      if (pad != 45) {
#line 884
        pad = '_';
      }
    }
    do_number: 
#line 888
    negative_number = (_Bool )(number_value < 0);
#line 889
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 892
    always_output_a_sign = (_Bool)0;
#line 893
    tz_colon_mask = 0;
    do_number_body: 
#line 901
    if (modifier == 79) {
#line 901
      if (! negative_number) {
#line 919
        goto underlying_strftime;
      }
    }
#line 923
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 925
    if (negative_number) {
#line 926
      u_number_value = - u_number_value;
    }
    {
#line 928
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 930
      if (tz_colon_mask & 1) {
#line 931
        bufp --;
#line 931
        *bufp = (char )':';
      }
#line 932
      tz_colon_mask >>= 1;
#line 933
      bufp --;
#line 933
      *bufp = (char )(u_number_value % 10U + 48U);
#line 934
      u_number_value /= 10U;
#line 928
      if (! (u_number_value != 0U)) {
#line 928
        if (! (tz_colon_mask != 0)) {
#line 928
          goto while_break___22;
        }
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 939
    if (digits < width) {
#line 940
      digits = width;
    }
#line 942
    if (negative_number) {
#line 942
      sign_char = (char )'-';
    } else {
#line 942
      if (always_output_a_sign) {
#line 942
        tmp___10 = '+';
      } else {
#line 942
        tmp___10 = 0;
      }
#line 942
      sign_char = (char )tmp___10;
    }
#line 946
    if (pad == 45) {
#line 948
      if (sign_char) {
        {
#line 949
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 949
          _n___3 = 1;
#line 949
          _delta___3 = width - _n___3;
#line 949
          if (_delta___3 > 0) {
#line 949
            tmp___11 = _delta___3;
          } else {
#line 949
            tmp___11 = 0;
          }
#line 949
          _incr___3 = _n___3 + tmp___11;
#line 949
          if ((size_t )_incr___3 >= maxsize - i) {
#line 949
            return ((size_t )0);
          }
#line 949
          if (p) {
#line 949
            if (digits == 0) {
#line 949
              if (_delta___3 > 0) {
#line 949
                if (pad == 48) {
                  {
#line 949
                  while (1) {
                    while_continue___24: /* CIL Label */ ;
#line 949
                    _i___7 = (size_t )0;
                    {
#line 949
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 949
                      if (! (_i___7 < (size_t )_delta___3)) {
#line 949
                        goto while_break___25;
                      }
                      {
#line 949
                      fputc('0', p);
#line 949
                      _i___7 ++;
                      }
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 949
                    goto while_break___24;
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                } else {
                  {
#line 949
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 949
                    _i___8 = (size_t )0;
                    {
#line 949
                    while (1) {
                      while_continue___27: /* CIL Label */ ;
#line 949
                      if (! (_i___8 < (size_t )_delta___3)) {
#line 949
                        goto while_break___27;
                      }
                      {
#line 949
                      fputc(' ', p);
#line 949
                      _i___8 ++;
                      }
                    }
                    while_break___27: /* CIL Label */ ;
                    }
#line 949
                    goto while_break___26;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 949
            fputc((int )sign_char, p);
            }
          }
#line 949
          i += (size_t )_incr___3;
#line 949
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    } else {
#line 953
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 956
      if (padding > 0) {
#line 958
        if (pad == 95) {
#line 960
          if ((size_t )padding >= maxsize - i) {
#line 961
            return ((size_t )0);
          }
#line 963
          if (p) {
            {
#line 964
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 964
              _i___9 = (size_t )0;
              {
#line 964
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 964
                if (! (_i___9 < (size_t )padding)) {
#line 964
                  goto while_break___29;
                }
                {
#line 964
                fputc(' ', p);
#line 964
                _i___9 ++;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
#line 964
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 965
          i += (size_t )padding;
#line 966
          if (width > padding) {
#line 966
            width -= padding;
          } else {
#line 966
            width = 0;
          }
#line 967
          if (sign_char) {
            {
#line 968
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 968
              _n___4 = 1;
#line 968
              _delta___4 = width - _n___4;
#line 968
              if (_delta___4 > 0) {
#line 968
                tmp___12 = _delta___4;
              } else {
#line 968
                tmp___12 = 0;
              }
#line 968
              _incr___4 = _n___4 + tmp___12;
#line 968
              if ((size_t )_incr___4 >= maxsize - i) {
#line 968
                return ((size_t )0);
              }
#line 968
              if (p) {
#line 968
                if (digits == 0) {
#line 968
                  if (_delta___4 > 0) {
#line 968
                    if (pad == 48) {
                      {
#line 968
                      while (1) {
                        while_continue___31: /* CIL Label */ ;
#line 968
                        _i___10 = (size_t )0;
                        {
#line 968
                        while (1) {
                          while_continue___32: /* CIL Label */ ;
#line 968
                          if (! (_i___10 < (size_t )_delta___4)) {
#line 968
                            goto while_break___32;
                          }
                          {
#line 968
                          fputc('0', p);
#line 968
                          _i___10 ++;
                          }
                        }
                        while_break___32: /* CIL Label */ ;
                        }
#line 968
                        goto while_break___31;
                      }
                      while_break___31: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 968
                      while (1) {
                        while_continue___33: /* CIL Label */ ;
#line 968
                        _i___11 = (size_t )0;
                        {
#line 968
                        while (1) {
                          while_continue___34: /* CIL Label */ ;
#line 968
                          if (! (_i___11 < (size_t )_delta___4)) {
#line 968
                            goto while_break___34;
                          }
                          {
#line 968
                          fputc(' ', p);
#line 968
                          _i___11 ++;
                          }
                        }
                        while_break___34: /* CIL Label */ ;
                        }
#line 968
                        goto while_break___33;
                      }
                      while_break___33: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 968
                fputc((int )sign_char, p);
                }
              }
#line 968
              i += (size_t )_incr___4;
#line 968
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        } else {
#line 972
          if ((size_t )digits >= maxsize - i) {
#line 973
            return ((size_t )0);
          }
#line 975
          if (sign_char) {
            {
#line 976
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 976
              _n___5 = 1;
#line 976
              _delta___5 = width - _n___5;
#line 976
              if (_delta___5 > 0) {
#line 976
                tmp___13 = _delta___5;
              } else {
#line 976
                tmp___13 = 0;
              }
#line 976
              _incr___5 = _n___5 + tmp___13;
#line 976
              if ((size_t )_incr___5 >= maxsize - i) {
#line 976
                return ((size_t )0);
              }
#line 976
              if (p) {
#line 976
                if (digits == 0) {
#line 976
                  if (_delta___5 > 0) {
#line 976
                    if (pad == 48) {
                      {
#line 976
                      while (1) {
                        while_continue___36: /* CIL Label */ ;
#line 976
                        _i___12 = (size_t )0;
                        {
#line 976
                        while (1) {
                          while_continue___37: /* CIL Label */ ;
#line 976
                          if (! (_i___12 < (size_t )_delta___5)) {
#line 976
                            goto while_break___37;
                          }
                          {
#line 976
                          fputc('0', p);
#line 976
                          _i___12 ++;
                          }
                        }
                        while_break___37: /* CIL Label */ ;
                        }
#line 976
                        goto while_break___36;
                      }
                      while_break___36: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 976
                      while (1) {
                        while_continue___38: /* CIL Label */ ;
#line 976
                        _i___13 = (size_t )0;
                        {
#line 976
                        while (1) {
                          while_continue___39: /* CIL Label */ ;
#line 976
                          if (! (_i___13 < (size_t )_delta___5)) {
#line 976
                            goto while_break___39;
                          }
                          {
#line 976
                          fputc(' ', p);
#line 976
                          _i___13 ++;
                          }
                        }
                        while_break___39: /* CIL Label */ ;
                        }
#line 976
                        goto while_break___38;
                      }
                      while_break___38: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 976
                fputc((int )sign_char, p);
                }
              }
#line 976
              i += (size_t )_incr___5;
#line 976
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
          }
#line 978
          if (p) {
            {
#line 979
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 979
              _i___14 = (size_t )0;
              {
#line 979
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 979
                if (! (_i___14 < (size_t )padding)) {
#line 979
                  goto while_break___41;
                }
                {
#line 979
                fputc('0', p);
#line 979
                _i___14 ++;
                }
              }
              while_break___41: /* CIL Label */ ;
              }
#line 979
              goto while_break___40;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
#line 980
          i += (size_t )padding;
#line 981
          width = 0;
        }
      } else
#line 986
      if (sign_char) {
        {
#line 987
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 987
          _n___6 = 1;
#line 987
          _delta___6 = width - _n___6;
#line 987
          if (_delta___6 > 0) {
#line 987
            tmp___14 = _delta___6;
          } else {
#line 987
            tmp___14 = 0;
          }
#line 987
          _incr___6 = _n___6 + tmp___14;
#line 987
          if ((size_t )_incr___6 >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 987
          if (p) {
#line 987
            if (digits == 0) {
#line 987
              if (_delta___6 > 0) {
#line 987
                if (pad == 48) {
                  {
#line 987
                  while (1) {
                    while_continue___43: /* CIL Label */ ;
#line 987
                    _i___15 = (size_t )0;
                    {
#line 987
                    while (1) {
                      while_continue___44: /* CIL Label */ ;
#line 987
                      if (! (_i___15 < (size_t )_delta___6)) {
#line 987
                        goto while_break___44;
                      }
                      {
#line 987
                      fputc('0', p);
#line 987
                      _i___15 ++;
                      }
                    }
                    while_break___44: /* CIL Label */ ;
                    }
#line 987
                    goto while_break___43;
                  }
                  while_break___43: /* CIL Label */ ;
                  }
                } else {
                  {
#line 987
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 987
                    _i___16 = (size_t )0;
                    {
#line 987
                    while (1) {
                      while_continue___46: /* CIL Label */ ;
#line 987
                      if (! (_i___16 < (size_t )_delta___6)) {
#line 987
                        goto while_break___46;
                      }
                      {
#line 987
                      fputc(' ', p);
#line 987
                      _i___16 ++;
                      }
                    }
                    while_break___46: /* CIL Label */ ;
                    }
#line 987
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 987
            fputc((int )sign_char, p);
            }
          }
#line 987
          i += (size_t )_incr___6;
#line 987
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
    }
    {
#line 991
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 991
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 991
      _delta___7 = width - _n___7;
#line 991
      if (_delta___7 > 0) {
#line 991
        tmp___15 = _delta___7;
      } else {
#line 991
        tmp___15 = 0;
      }
#line 991
      _incr___7 = _n___7 + tmp___15;
#line 991
      if ((size_t )_incr___7 >= maxsize - i) {
#line 991
        return ((size_t )0);
      }
#line 991
      if (p) {
#line 991
        if (digits == 0) {
#line 991
          if (_delta___7 > 0) {
#line 991
            if (pad == 48) {
              {
#line 991
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 991
                _i___17 = (size_t )0;
                {
#line 991
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 991
                  if (! (_i___17 < (size_t )_delta___7)) {
#line 991
                    goto while_break___49;
                  }
                  {
#line 991
                  fputc('0', p);
#line 991
                  _i___17 ++;
                  }
                }
                while_break___49: /* CIL Label */ ;
                }
#line 991
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
            } else {
              {
#line 991
              while (1) {
                while_continue___50: /* CIL Label */ ;
#line 991
                _i___18 = (size_t )0;
                {
#line 991
                while (1) {
                  while_continue___51: /* CIL Label */ ;
#line 991
                  if (! (_i___18 < (size_t )_delta___7)) {
#line 991
                    goto while_break___51;
                  }
                  {
#line 991
                  fputc(' ', p);
#line 991
                  _i___18 ++;
                  }
                }
                while_break___51: /* CIL Label */ ;
                }
#line 991
                goto while_break___50;
              }
              while_break___50: /* CIL Label */ ;
              }
            }
          }
        }
#line 991
        if (to_lowcase) {
          {
#line 991
          fwrite_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 991
        if (to_uppcase) {
          {
#line 991
          fwrite_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 991
          fwrite((void const   */* __restrict  */)bufp, (size_t )_n___7, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 991
      i += (size_t )_incr___7;
#line 991
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
#line 992
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 995
    if (modifier != 0) {
#line 996
      goto bad_format;
    }
#line 997
    subfmt = "%Y-%m-%d";
#line 998
    goto subformat;
    case_72: /* CIL Label */ 
#line 1001
    if (modifier == 69) {
#line 1002
      goto bad_format;
    }
#line 1004
    digits = 2;
#line 1004
    number_value = (int )tp->tm_hour;
#line 1004
    goto do_number;
    case_73: /* CIL Label */ 
#line 1007
    if (modifier == 69) {
#line 1008
      goto bad_format;
    }
#line 1010
    digits = 2;
#line 1010
    number_value = hour12;
#line 1010
    goto do_number;
    case_107: /* CIL Label */ 
#line 1013
    if (modifier == 69) {
#line 1014
      goto bad_format;
    }
#line 1016
    digits = 2;
#line 1016
    number_value = (int )tp->tm_hour;
#line 1016
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1019
    if (modifier == 69) {
#line 1020
      goto bad_format;
    }
#line 1022
    digits = 2;
#line 1022
    number_value = hour12;
#line 1022
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1025
    if (modifier == 69) {
#line 1026
      goto bad_format;
    }
#line 1028
    digits = 3;
#line 1028
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1028
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1028
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1031
    if (modifier == 69) {
#line 1032
      goto bad_format;
    }
#line 1034
    digits = 2;
#line 1034
    number_value = (int )tp->tm_min;
#line 1034
    goto do_number;
    case_109: /* CIL Label */ 
#line 1037
    if (modifier == 69) {
#line 1038
      goto bad_format;
    }
#line 1040
    digits = 2;
#line 1040
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1040
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1040
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1044
    if (modifier == 69) {
#line 1045
      goto bad_format;
    }
#line 1047
    number_value = ns;
#line 1048
    if (width == -1) {
#line 1049
      width = 9;
    } else {
#line 1054
      j = width;
      {
#line 1054
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1054
        if (! (j < 9)) {
#line 1054
          goto while_break___52;
        }
#line 1055
        number_value /= 10;
#line 1054
        j ++;
      }
      while_break___52: /* CIL Label */ ;
      }
    }
#line 1058
    digits = width;
#line 1058
    number_value = number_value;
#line 1058
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1062
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1062
      _n___8 = 1;
#line 1062
      _delta___8 = width - _n___8;
#line 1062
      if (_delta___8 > 0) {
#line 1062
        tmp___16 = _delta___8;
      } else {
#line 1062
        tmp___16 = 0;
      }
#line 1062
      _incr___8 = _n___8 + tmp___16;
#line 1062
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1062
        return ((size_t )0);
      }
#line 1062
      if (p) {
#line 1062
        if (digits == 0) {
#line 1062
          if (_delta___8 > 0) {
#line 1062
            if (pad == 48) {
              {
#line 1062
              while (1) {
                while_continue___54: /* CIL Label */ ;
#line 1062
                _i___19 = (size_t )0;
                {
#line 1062
                while (1) {
                  while_continue___55: /* CIL Label */ ;
#line 1062
                  if (! (_i___19 < (size_t )_delta___8)) {
#line 1062
                    goto while_break___55;
                  }
                  {
#line 1062
                  fputc('0', p);
#line 1062
                  _i___19 ++;
                  }
                }
                while_break___55: /* CIL Label */ ;
                }
#line 1062
                goto while_break___54;
              }
              while_break___54: /* CIL Label */ ;
              }
            } else {
              {
#line 1062
              while (1) {
                while_continue___56: /* CIL Label */ ;
#line 1062
                _i___20 = (size_t )0;
                {
#line 1062
                while (1) {
                  while_continue___57: /* CIL Label */ ;
#line 1062
                  if (! (_i___20 < (size_t )_delta___8)) {
#line 1062
                    goto while_break___57;
                  }
                  {
#line 1062
                  fputc(' ', p);
#line 1062
                  _i___20 ++;
                  }
                }
                while_break___57: /* CIL Label */ ;
                }
#line 1062
                goto while_break___56;
              }
              while_break___56: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1062
        fputc('\n', p);
        }
      }
#line 1062
      i += (size_t )_incr___8;
#line 1062
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 1063
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1066
    to_lowcase = (_Bool)1;
#line 1068
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1073
    if (change_case) {
#line 1075
      to_uppcase = (_Bool)0;
#line 1076
      to_lowcase = (_Bool)1;
    }
#line 1082
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1086
    subfmt = "%H:%M";
#line 1087
    goto subformat;
    case_114: /* CIL Label */ 
#line 1097
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1101
    if (modifier == 69) {
#line 1102
      goto bad_format;
    }
#line 1104
    digits = 2;
#line 1104
    number_value = (int )tp->tm_sec;
#line 1104
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1111
    ltm = (struct tm )*tp;
#line 1112
    t = mktime(& ltm);
#line 1117
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1118
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1120
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1122
      d = (int )(t % 10L);
#line 1123
      t /= 10L;
#line 1124
      bufp --;
#line 1124
      if (negative_number) {
#line 1124
        tmp___17 = - d;
      } else {
#line 1124
        tmp___17 = d;
      }
#line 1124
      *bufp = (char )(tmp___17 + 48);
#line 1120
      if (! (t != 0L)) {
#line 1120
        goto while_break___58;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
#line 1128
    digits = 1;
#line 1129
    always_output_a_sign = (_Bool)0;
#line 1130
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1134
    if (modifier == 79) {
#line 1135
      goto bad_format;
    }
#line 1144
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1147
    subfmt = "%H:%M:%S";
#line 1148
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1151
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1151
      _n___9 = 1;
#line 1151
      _delta___9 = width - _n___9;
#line 1151
      if (_delta___9 > 0) {
#line 1151
        tmp___18 = _delta___9;
      } else {
#line 1151
        tmp___18 = 0;
      }
#line 1151
      _incr___9 = _n___9 + tmp___18;
#line 1151
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1151
        return ((size_t )0);
      }
#line 1151
      if (p) {
#line 1151
        if (digits == 0) {
#line 1151
          if (_delta___9 > 0) {
#line 1151
            if (pad == 48) {
              {
#line 1151
              while (1) {
                while_continue___60: /* CIL Label */ ;
#line 1151
                _i___21 = (size_t )0;
                {
#line 1151
                while (1) {
                  while_continue___61: /* CIL Label */ ;
#line 1151
                  if (! (_i___21 < (size_t )_delta___9)) {
#line 1151
                    goto while_break___61;
                  }
                  {
#line 1151
                  fputc('0', p);
#line 1151
                  _i___21 ++;
                  }
                }
                while_break___61: /* CIL Label */ ;
                }
#line 1151
                goto while_break___60;
              }
              while_break___60: /* CIL Label */ ;
              }
            } else {
              {
#line 1151
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1151
                _i___22 = (size_t )0;
                {
#line 1151
                while (1) {
                  while_continue___63: /* CIL Label */ ;
#line 1151
                  if (! (_i___22 < (size_t )_delta___9)) {
#line 1151
                    goto while_break___63;
                  }
                  {
#line 1151
                  fputc(' ', p);
#line 1151
                  _i___22 ++;
                  }
                }
                while_break___63: /* CIL Label */ ;
                }
#line 1151
                goto while_break___62;
              }
              while_break___62: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1151
        fputc('\t', p);
        }
      }
#line 1151
      i += (size_t )_incr___9;
#line 1151
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 1152
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1155
    digits = 1;
#line 1155
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1155
    goto do_number;
    case_85: /* CIL Label */ 
#line 1158
    if (modifier == 69) {
#line 1159
      goto bad_format;
    }
#line 1161
    digits = 2;
#line 1161
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1161
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1166
    if (modifier == 69) {
#line 1167
      goto bad_format;
    }
#line 1173
    if (tp->tm_year < 0) {
#line 1173
      tmp___19 = 300;
    } else {
#line 1173
      tmp___19 = -100;
    }
    {
#line 1173
    year___1 = (int )(tp->tm_year + (int const   )tmp___19);
#line 1177
    year_adjust = 0;
#line 1178
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1178
    days = tmp___20;
    }
#line 1180
    if (days < 0) {
#line 1183
      year_adjust = -1;
#line 1184
      if ((year___1 - 1) % 4 == 0) {
#line 1184
        if ((year___1 - 1) % 100 != 0) {
#line 1184
          tmp___21 = 1;
        } else
#line 1184
        if ((year___1 - 1) % 400 == 0) {
#line 1184
          tmp___21 = 1;
        } else {
#line 1184
          tmp___21 = 0;
        }
      } else {
#line 1184
        tmp___21 = 0;
      }
      {
#line 1184
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1189
      if (year___1 % 4 == 0) {
#line 1189
        if (year___1 % 100 != 0) {
#line 1189
          tmp___22 = 1;
        } else
#line 1189
        if (year___1 % 400 == 0) {
#line 1189
          tmp___22 = 1;
        } else {
#line 1189
          tmp___22 = 0;
        }
      } else {
#line 1189
        tmp___22 = 0;
      }
      {
#line 1189
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1189
      d___0 = tmp___23;
      }
#line 1191
      if (0 <= d___0) {
#line 1194
        year_adjust = 1;
#line 1195
        days = d___0;
      }
    }
    {
#line 1201
    if ((int const   )*f == 103) {
#line 1201
      goto case_103___0;
    }
#line 1211
    if ((int const   )*f == 71) {
#line 1211
      goto case_71___0;
    }
#line 1216
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1203
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1204
    digits = 2;
#line 1204
    if (0 <= yy) {
#line 1204
      number_value = yy;
    } else {
#line 1204
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1204
        tmp___24 = - yy;
      } else {
#line 1204
        tmp___24 = yy + 100;
      }
#line 1204
      number_value = tmp___24;
    }
#line 1204
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1212
    digits = 4;
#line 1212
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1212
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1212
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1217
    digits = 2;
#line 1217
    number_value = days / 7 + 1;
#line 1217
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1222
    if (modifier == 69) {
#line 1223
      goto bad_format;
    }
#line 1225
    digits = 2;
#line 1225
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1225
    goto do_number;
    case_119: /* CIL Label */ 
#line 1228
    if (modifier == 69) {
#line 1229
      goto bad_format;
    }
#line 1231
    digits = 1;
#line 1231
    number_value = (int )tp->tm_wday;
#line 1231
    goto do_number;
    case_89: /* CIL Label */ 
#line 1234
    if (modifier == 69) {
#line 1248
      goto underlying_strftime;
    }
#line 1251
    if (modifier == 79) {
#line 1252
      goto bad_format;
    } else {
#line 1254
      digits = 4;
    }
#line 1254
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1254
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1254
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1258
    if (modifier == 69) {
#line 1269
      goto underlying_strftime;
    }
#line 1274
    yy___0 = (int )(tp->tm_year % 100);
#line 1275
    if (yy___0 < 0) {
#line 1276
      if (tp->tm_year < -1900) {
#line 1276
        yy___0 = - yy___0;
      } else {
#line 1276
        yy___0 += 100;
      }
    }
#line 1277
    digits = 2;
#line 1277
    number_value = yy___0;
#line 1277
    goto do_number;
    case_90: /* CIL Label */ 
#line 1281
    if (change_case) {
#line 1283
      to_uppcase = (_Bool)0;
#line 1284
      to_lowcase = (_Bool)1;
    }
#line 1292
    if (! zone) {
#line 1293
      zone = "";
    }
    {
#line 1305
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 1305
      tmp___25 = strlen(zone);
#line 1305
      _n___10 = (int )tmp___25;
#line 1305
      _delta___10 = width - _n___10;
      }
#line 1305
      if (_delta___10 > 0) {
#line 1305
        tmp___26 = _delta___10;
      } else {
#line 1305
        tmp___26 = 0;
      }
#line 1305
      _incr___10 = _n___10 + tmp___26;
#line 1305
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1305
        return ((size_t )0);
      }
#line 1305
      if (p) {
#line 1305
        if (digits == 0) {
#line 1305
          if (_delta___10 > 0) {
#line 1305
            if (pad == 48) {
              {
#line 1305
              while (1) {
                while_continue___65: /* CIL Label */ ;
#line 1305
                _i___23 = (size_t )0;
                {
#line 1305
                while (1) {
                  while_continue___66: /* CIL Label */ ;
#line 1305
                  if (! (_i___23 < (size_t )_delta___10)) {
#line 1305
                    goto while_break___66;
                  }
                  {
#line 1305
                  fputc('0', p);
#line 1305
                  _i___23 ++;
                  }
                }
                while_break___66: /* CIL Label */ ;
                }
#line 1305
                goto while_break___65;
              }
              while_break___65: /* CIL Label */ ;
              }
            } else {
              {
#line 1305
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1305
                _i___24 = (size_t )0;
                {
#line 1305
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1305
                  if (! (_i___24 < (size_t )_delta___10)) {
#line 1305
                    goto while_break___68;
                  }
                  {
#line 1305
                  fputc(' ', p);
#line 1305
                  _i___24 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1305
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            }
          }
        }
#line 1305
        if (to_lowcase) {
          {
#line 1305
          fwrite_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1305
        if (to_uppcase) {
          {
#line 1305
          fwrite_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1305
          fwrite((void const   */* __restrict  */)zone, (size_t )_n___10, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 1305
      i += (size_t )_incr___10;
#line 1305
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 1307
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1312
    colons = (size_t )1;
    {
#line 1312
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1312
      if (! ((int const   )*(f + colons) == 58)) {
#line 1312
        goto while_break___69;
      }
#line 1313
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1312
      colons ++;
    }
    while_break___69: /* CIL Label */ ;
    }
#line 1314
    if ((int const   )*(f + colons) != 122) {
#line 1315
      goto bad_format;
    }
#line 1316
    f += colons;
#line 1317
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1320
    colons = (size_t )0;
    do_z_conversion: 
#line 1323
    if (tp->tm_isdst < 0) {
#line 1324
      goto switch_break___1;
    }
#line 1332
    diff = (int )tp->tm_gmtoff;
#line 1369
    hour_diff = (diff / 60) / 60;
#line 1370
    min_diff = (diff / 60) % 60;
#line 1371
    sec_diff = diff % 60;
    {
#line 1375
    if (colons == 0UL) {
#line 1375
      goto case_0;
    }
#line 1378
    if (colons == 1UL) {
#line 1378
      goto tz_hh_mm;
    }
#line 1381
    if (colons == 2UL) {
#line 1381
      goto tz_hh_mm_ss;
    }
#line 1385
    if (colons == 3UL) {
#line 1385
      goto case_3;
    }
#line 1392
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1376
    digits = 5;
#line 1376
    negative_number = (_Bool )(diff < 0);
#line 1376
    tz_colon_mask = 0;
#line 1376
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1376
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1379
    digits = 6;
#line 1379
    negative_number = (_Bool )(diff < 0);
#line 1379
    tz_colon_mask = 4;
#line 1379
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1379
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1382
    digits = 9;
#line 1382
    negative_number = (_Bool )(diff < 0);
#line 1382
    tz_colon_mask = 20;
#line 1382
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1382
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1386
    if (sec_diff != 0) {
#line 1387
      goto tz_hh_mm_ss;
    }
#line 1388
    if (min_diff != 0) {
#line 1389
      goto tz_hh_mm;
    }
#line 1390
    digits = 3;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )hour_diff;
#line 1390
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1393
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1398
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1407
    flen = 1;
    {
#line 1407
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 1407
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1407
        goto while_break___70;
      }
#line 1408
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1407
      flen ++;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 1409
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1409
      _n___11 = flen;
#line 1409
      _delta___11 = width - _n___11;
#line 1409
      if (_delta___11 > 0) {
#line 1409
        tmp___27 = _delta___11;
      } else {
#line 1409
        tmp___27 = 0;
      }
#line 1409
      _incr___11 = _n___11 + tmp___27;
#line 1409
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1409
        return ((size_t )0);
      }
#line 1409
      if (p) {
#line 1409
        if (digits == 0) {
#line 1409
          if (_delta___11 > 0) {
#line 1409
            if (pad == 48) {
              {
#line 1409
              while (1) {
                while_continue___72: /* CIL Label */ ;
#line 1409
                _i___25 = (size_t )0;
                {
#line 1409
                while (1) {
                  while_continue___73: /* CIL Label */ ;
#line 1409
                  if (! (_i___25 < (size_t )_delta___11)) {
#line 1409
                    goto while_break___73;
                  }
                  {
#line 1409
                  fputc('0', p);
#line 1409
                  _i___25 ++;
                  }
                }
                while_break___73: /* CIL Label */ ;
                }
#line 1409
                goto while_break___72;
              }
              while_break___72: /* CIL Label */ ;
              }
            } else {
              {
#line 1409
              while (1) {
                while_continue___74: /* CIL Label */ ;
#line 1409
                _i___26 = (size_t )0;
                {
#line 1409
                while (1) {
                  while_continue___75: /* CIL Label */ ;
#line 1409
                  if (! (_i___26 < (size_t )_delta___11)) {
#line 1409
                    goto while_break___75;
                  }
                  {
#line 1409
                  fputc(' ', p);
#line 1409
                  _i___26 ++;
                  }
                }
                while_break___75: /* CIL Label */ ;
                }
#line 1409
                goto while_break___74;
              }
              while_break___74: /* CIL Label */ ;
              }
            }
          }
        }
#line 1409
        if (to_lowcase) {
          {
#line 1409
          fwrite_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1409
        if (to_uppcase) {
          {
#line 1409
          fwrite_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1409
          fwrite((void const   */* __restrict  */)(f + (1 - flen)), (size_t )_n___11,
                 (size_t )1, (FILE */* __restrict  */)p);
          }
        }
      }
#line 1409
      i += (size_t )_incr___11;
#line 1409
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 1411
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 492
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return (i);
}
}
#line 1429 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1434
  tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
  }
#line 1434
  return (tmp);
}
}
#line 265 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 34
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
#line 34
  fp = tmp;
  }
#line 36
  if (fp) {
    {
#line 38
    tmp___0 = fileno(fp);
#line 38
    fd = tmp___0;
    }
#line 40
    if (0 <= fd) {
#line 40
      if (fd <= 2) {
        {
#line 42
        tmp___1 = dup_safer(fd);
#line 42
        f = tmp___1;
        }
#line 44
        if (f < 0) {
          {
#line 46
          tmp___2 = __errno_location();
#line 46
          e = *tmp___2;
#line 47
          fclose(fp);
#line 48
          tmp___3 = __errno_location();
#line 48
          *tmp___3 = e;
          }
#line 49
          return ((FILE *)((void *)0));
        }
        {
#line 52
        tmp___6 = fclose(fp);
        }
#line 52
        if (tmp___6 != 0) {
#line 52
          goto _L;
        } else {
          {
#line 52
          fp = fdopen(f, mode);
          }
#line 52
          if (! fp) {
            _L: /* CIL Label */ 
            {
#line 55
            tmp___4 = __errno_location();
#line 55
            e___0 = *tmp___4;
#line 56
            close(f);
#line 57
            tmp___5 = __errno_location();
#line 57
            *tmp___5 = e___0;
            }
#line 58
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
#line 63
  return (fp);
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.h"
int filevercmp(char const   *s1 , char const   *s2 ) ;
#line 123 "./c-ctype.h"
_Bool c_isalnum(int c ) ;
#line 127
_Bool c_isdigit(int c ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
static char const   *match_suffix(char const   **str ) 
{ 
  char const   *match ;
  _Bool read_alpha ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 36
  match = (char const   *)((void *)0);
#line 37
  read_alpha = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! *(*str)) {
#line 38
      goto while_break;
    }
#line 40
    if (read_alpha) {
      {
#line 42
      read_alpha = (_Bool)0;
#line 43
      tmp = c_isalpha((int )*(*str));
      }
#line 43
      if (! tmp) {
#line 44
        match = (char const   *)((void *)0);
      }
    } else
#line 46
    if (46 == (int )*(*str)) {
#line 48
      read_alpha = (_Bool)1;
#line 49
      if (! match) {
#line 50
        match = *str;
      }
    } else {
      {
#line 52
      tmp___0 = c_isalnum((int )*(*str));
      }
#line 52
      if (! tmp___0) {
#line 53
        match = (char const   *)((void *)0);
      }
    }
#line 54
    (*str) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (match);
}
}
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
__inline static int order(unsigned char c ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 63
  tmp___0 = c_isdigit((int )c);
  }
#line 63
  if (tmp___0) {
#line 64
    return (0);
  } else {
    {
#line 65
    tmp = c_isalpha((int )c);
    }
#line 65
    if (tmp) {
#line 66
      return ((int )c);
    } else
#line 67
    if ((int )c == 126) {
#line 68
      return (-1);
    } else {
#line 70
      return (((int )c + 255) + 1);
    }
  }
}
}
#line 83 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
static int verrevcmp(char const   *s1 , size_t s1_len , char const   *s2 , size_t s2_len ) 
{ 
  size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
#line 86
  s1_pos = (size_t )0;
#line 87
  s2_pos = (size_t )0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (s1_pos < s1_len)) {
#line 88
      if (! (s2_pos < s2_len)) {
#line 88
        goto while_break;
      }
    }
#line 90
    first_diff = 0;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (s1_pos < s1_len) {
        {
#line 91
        tmp___3 = c_isdigit((int )*(s1 + s1_pos));
        }
#line 91
        if (tmp___3) {
#line 91
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 91
      if (s2_pos < s2_len) {
        {
#line 91
        tmp___4 = c_isdigit((int )*(s2 + s2_pos));
        }
#line 91
        if (tmp___4) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 94
      if (s1_pos == s1_len) {
#line 94
        tmp___0 = 0;
      } else {
        {
#line 94
        tmp = order((unsigned char )*(s1 + s1_pos));
#line 94
        tmp___0 = tmp;
        }
      }
#line 94
      s1_c = tmp___0;
#line 95
      if (s2_pos == s2_len) {
#line 95
        tmp___2 = 0;
      } else {
        {
#line 95
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
#line 95
        tmp___2 = tmp___1;
        }
      }
#line 95
      s2_c = tmp___2;
#line 96
      if (s1_c != s2_c) {
#line 97
        return (s1_c - s2_c);
      }
#line 98
      s1_pos ++;
#line 99
      s2_pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (! ((int const   )*(s1 + s1_pos) == 48)) {
#line 101
        goto while_break___1;
      }
#line 102
      s1_pos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 103
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 103
      if (! ((int const   )*(s2 + s2_pos) == 48)) {
#line 103
        goto while_break___2;
      }
#line 104
      s2_pos ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 105
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 105
      tmp___5 = c_isdigit((int )*(s1 + s1_pos));
      }
#line 105
      if (tmp___5) {
        {
#line 105
        tmp___6 = c_isdigit((int )*(s2 + s2_pos));
        }
#line 105
        if (! tmp___6) {
#line 105
          goto while_break___3;
        }
      } else {
#line 105
        goto while_break___3;
      }
#line 107
      if (! first_diff) {
#line 108
        first_diff = (int )((int const   )*(s1 + s1_pos) - (int const   )*(s2 + s2_pos));
      }
#line 109
      s1_pos ++;
#line 110
      s2_pos ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 112
    tmp___7 = c_isdigit((int )*(s1 + s1_pos));
    }
#line 112
    if (tmp___7) {
#line 113
      return (1);
    }
    {
#line 114
    tmp___8 = c_isdigit((int )*(s2 + s2_pos));
    }
#line 114
    if (tmp___8) {
#line 115
      return (-1);
    }
#line 116
    if (first_diff) {
#line 117
      return (first_diff);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 124 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
int filevercmp(char const   *s1 , char const   *s2 ) 
{ 
  char const   *s1_pos ;
  char const   *s2_pos ;
  char const   *s1_suffix ;
  char const   *s2_suffix ;
  size_t s1_len ;
  size_t s2_len ;
  int result ;
  int simple_cmp ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 127
  s1_pos = s1;
#line 128
  s2_pos = s2;
#line 134
  tmp = strcmp(s1, s2);
#line 134
  simple_cmp = tmp;
  }
#line 135
  if (simple_cmp == 0) {
#line 136
    return (0);
  }
  {
#line 139
  s1_suffix = match_suffix(& s1_pos);
#line 140
  s2_suffix = match_suffix(& s2_pos);
  }
#line 141
  if (s1_suffix) {
#line 141
    tmp___0 = s1_suffix;
  } else {
#line 141
    tmp___0 = s1_pos;
  }
#line 141
  s1_len = (size_t )(tmp___0 - s1);
#line 142
  if (s2_suffix) {
#line 142
    tmp___1 = s2_suffix;
  } else {
#line 142
    tmp___1 = s2_pos;
  }
#line 142
  s2_len = (size_t )(tmp___1 - s2);
#line 145
  if (s1_suffix) {
#line 145
    goto _L;
  } else
#line 145
  if (s2_suffix) {
    _L: /* CIL Label */ 
#line 145
    if (s1_len == s2_len) {
      {
#line 145
      tmp___2 = strncmp(s1, s2, s1_len);
      }
#line 145
      if (0 == tmp___2) {
#line 148
        s1_len = (size_t )(s1_pos - s1);
#line 149
        s2_len = (size_t )(s2_pos - s2);
      }
    }
  }
  {
#line 152
  result = verrevcmp(s1, s1_len, s2, s2_len);
  }
#line 153
  if (result == 0) {
#line 153
    tmp___3 = simple_cmp;
  } else {
#line 153
    tmp___3 = result;
  }
#line 153
  return (tmp___3);
}
}
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/filenamecat.h"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 23
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.h"
size_t base_len(char const   *name ) ;
#line 65
char *last_component(char const   *name ) ;
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/filenamecat.c"
static char const   *longest_relative_suffix(char const   *f ) 
{ 


  {
#line 41
  f += 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int const   )*f == 47)) {
#line 41
      goto while_break;
    }
#line 42
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 41
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (f);
}
}
#line 61 "/home/khheo/project/benchmark/coreutils-7.1/lib/filenamecat.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 64
  tmp = last_component(dir);
#line 64
  dirbase = (char const   *)tmp;
#line 65
  tmp___0 = base_len(dirbase);
#line 65
  dirbaselen = tmp___0;
#line 66
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 67
  if (dirbaselen) {
#line 67
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 67
      tmp___1 = 1;
    } else {
#line 67
      tmp___1 = 0;
    }
  } else {
#line 67
    tmp___1 = 0;
  }
  {
#line 67
  needs_separator = (size_t )tmp___1;
#line 69
  tmp___2 = longest_relative_suffix(abase);
#line 69
  base = tmp___2;
#line 70
  tmp___3 = strlen(base);
#line 70
  baselen = tmp___3;
#line 72
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 72
  p_concat = (char *)tmp___4;
  }
#line 75
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 76
    return ((char *)((void *)0));
  }
  {
#line 78
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 78
  p = (char *)tmp___5;
#line 79
  *p = (char )'/';
#line 80
  p += needs_separator;
  }
#line 82
  if (base_in_result) {
#line 83
    if ((int const   )*(abase + 0) == 47) {
#line 83
      tmp___6 = 1;
    } else {
#line 83
      tmp___6 = 0;
    }
#line 83
    *base_in_result = p - tmp___6;
  }
  {
#line 85
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 85
  p = (char *)tmp___7;
#line 86
  *p = (char )'\000';
  }
#line 88
  return (p_concat);
}
}
#line 95 "/home/khheo/project/benchmark/coreutils-7.1/lib/filenamecat.c"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 98
  tmp = mfile_name_concat(dir, abase, base_in_result);
#line 98
  p = tmp;
  }
#line 99
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 100
    xalloc_die();
    }
  }
#line 101
  return (p);
}
}
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/filemode.h"
void strmode(mode_t mode , char *str ) ;
#line 30
void filemodestring(struct stat  const  *statp , char *str ) ;
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/filemode.c"
static char ftypelet(mode_t bits ) 
{ 


  {
#line 57
  if ((bits & 61440U) == 32768U) {
#line 58
    return ((char )'-');
  }
#line 59
  if ((bits & 61440U) == 16384U) {
#line 60
    return ((char )'d');
  }
#line 63
  if ((bits & 61440U) == 24576U) {
#line 64
    return ((char )'b');
  }
#line 65
  if ((bits & 61440U) == 8192U) {
#line 66
    return ((char )'c');
  }
#line 67
  if ((bits & 61440U) == 40960U) {
#line 68
    return ((char )'l');
  }
#line 69
  if ((bits & 61440U) == 4096U) {
#line 70
    return ((char )'p');
  }
#line 73
  if ((bits & 61440U) == 49152U) {
#line 74
    return ((char )'s');
  }
#line 90
  return ((char )'?');
}
}
#line 95 "/home/khheo/project/benchmark/coreutils-7.1/lib/filemode.c"
void strmode(mode_t mode , char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 98
  *(str + 0) = ftypelet(mode);
  }
#line 99
  if (mode & 256U) {
#line 99
    *(str + 1) = (char )'r';
  } else {
#line 99
    *(str + 1) = (char )'-';
  }
#line 100
  if (mode & 128U) {
#line 100
    *(str + 2) = (char )'w';
  } else {
#line 100
    *(str + 2) = (char )'-';
  }
#line 101
  if (mode & 2048U) {
#line 101
    if (mode & 64U) {
#line 101
      tmp = 's';
    } else {
#line 101
      tmp = 'S';
    }
#line 101
    *(str + 3) = (char )tmp;
  } else {
#line 101
    if (mode & 64U) {
#line 101
      tmp___0 = 'x';
    } else {
#line 101
      tmp___0 = '-';
    }
#line 101
    *(str + 3) = (char )tmp___0;
  }
#line 104
  if (mode & (unsigned int )(256 >> 3)) {
#line 104
    *(str + 4) = (char )'r';
  } else {
#line 104
    *(str + 4) = (char )'-';
  }
#line 105
  if (mode & (unsigned int )(128 >> 3)) {
#line 105
    *(str + 5) = (char )'w';
  } else {
#line 105
    *(str + 5) = (char )'-';
  }
#line 106
  if (mode & 1024U) {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___1 = 's';
    } else {
#line 106
      tmp___1 = 'S';
    }
#line 106
    *(str + 6) = (char )tmp___1;
  } else {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___2 = 'x';
    } else {
#line 106
      tmp___2 = '-';
    }
#line 106
    *(str + 6) = (char )tmp___2;
  }
#line 109
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 109
    *(str + 7) = (char )'r';
  } else {
#line 109
    *(str + 7) = (char )'-';
  }
#line 110
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 110
    *(str + 8) = (char )'w';
  } else {
#line 110
    *(str + 8) = (char )'-';
  }
#line 111
  if (mode & 512U) {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___3 = 't';
    } else {
#line 111
      tmp___3 = 'T';
    }
#line 111
    *(str + 9) = (char )tmp___3;
  } else {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___4 = 'x';
    } else {
#line 111
      tmp___4 = '-';
    }
#line 111
    *(str + 9) = (char )tmp___4;
  }
#line 114
  *(str + 10) = (char )' ';
#line 115
  *(str + 11) = (char )'\000';
#line 116
  return;
}
}
#line 165 "/home/khheo/project/benchmark/coreutils-7.1/lib/filemode.c"
void filemodestring(struct stat  const  *statp , char *str ) 
{ 


  {
  {
#line 168
  strmode((mode_t )statp->st_mode, str);
  }
#line 170
  if (statp->st_mode - statp->st_mode) {
#line 171
    *(str + 0) = (char )'F';
  } else
#line 174
  if (statp->st_mode - statp->st_mode) {
#line 175
    *(str + 0) = (char )'Q';
  } else
#line 176
  if (statp->st_mode - statp->st_mode) {
#line 177
    *(str + 0) = (char )'S';
  }
#line 180
  return;
}
}
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-type.h"
char const   *file_type(struct stat  const  *st ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-type.c"
char const   *file_type(struct stat  const  *st ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;

  {
#line 37
  if ((st->st_mode & 61440U) == 32768U) {
#line 38
    if (st->st_size == 0L) {
      {
#line 38
      tmp = gettext("regular empty file");
#line 38
      tmp___1 = tmp;
      }
    } else {
      {
#line 38
      tmp___0 = gettext("regular file");
#line 38
      tmp___1 = tmp___0;
      }
    }
#line 38
    return ((char const   *)tmp___1);
  }
#line 40
  if ((st->st_mode & 61440U) == 16384U) {
    {
#line 41
    tmp___2 = gettext("directory");
    }
#line 41
    return ((char const   *)tmp___2);
  }
#line 43
  if ((st->st_mode & 61440U) == 24576U) {
    {
#line 44
    tmp___3 = gettext("block special file");
    }
#line 44
    return ((char const   *)tmp___3);
  }
#line 46
  if ((st->st_mode & 61440U) == 8192U) {
    {
#line 47
    tmp___4 = gettext("character special file");
    }
#line 47
    return ((char const   *)tmp___4);
  }
#line 49
  if ((st->st_mode & 61440U) == 4096U) {
    {
#line 50
    tmp___5 = gettext("fifo");
    }
#line 50
    return ((char const   *)tmp___5);
  }
#line 52
  if ((st->st_mode & 61440U) == 40960U) {
    {
#line 53
    tmp___6 = gettext("symbolic link");
    }
#line 53
    return ((char const   *)tmp___6);
  }
#line 55
  if ((st->st_mode & 61440U) == 49152U) {
    {
#line 56
    tmp___7 = gettext("socket");
    }
#line 56
    return ((char const   *)tmp___7);
  }
#line 58
  if (st->st_mode - st->st_mode) {
    {
#line 59
    tmp___8 = gettext("message queue");
    }
#line 59
    return ((char const   *)tmp___8);
  }
#line 61
  if (st->st_mode - st->st_mode) {
    {
#line 62
    tmp___9 = gettext("semaphore");
    }
#line 62
    return ((char const   *)tmp___9);
  }
#line 64
  if (st->st_mode - st->st_mode) {
    {
#line 65
    tmp___10 = gettext("shared memory object");
    }
#line 65
    return ((char const   *)tmp___10);
  }
  {
#line 70
  tmp___12 = gettext("weird file");
  }
#line 70
  return ((char const   *)tmp___12);
}
}
#line 7 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-set.h"
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___1 , char const   *file ,
                                                      struct stat  const  *stats ) ;
#line 11
_Bool seen_file(Hash_table const   *ht___1 , char const   *file , struct stat  const  *stats ) ;
#line 61 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-set.c"
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___1 , char const   *file ,
                                                      struct stat  const  *stats ) 
{ 
  struct F_triple *ent ;
  void *tmp ;
  struct F_triple *ent_from_table ;
  void *tmp___0 ;

  {
#line 33
  if ((unsigned long )ht___1 == (unsigned long )((void *)0)) {
#line 34
    return;
  }
  {
#line 36
  tmp = xmalloc(sizeof(*ent));
#line 36
  ent = (struct F_triple *)tmp;
#line 37
  ent->name = xstrdup(file);
#line 38
  ent->st_ino = (ino_t )stats->st_ino;
#line 39
  ent->st_dev = (dev_t )stats->st_dev;
#line 42
  tmp___0 = hash_insert(ht___1, (void const   *)ent);
#line 42
  ent_from_table = (struct F_triple *)tmp___0;
  }
#line 43
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
    {
#line 46
    xalloc_die();
    }
  }
#line 49
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
    {
#line 53
    triple_free((void *)ent);
    }
  }
#line 56
  return;
}
}
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-set.c"
_Bool seen_file(Hash_table const   *ht___1 , char const   *file , struct stat  const  *stats ) 
{ 
  struct F_triple new_ent ;
  void *tmp ;
  int tmp___0 ;

  {
#line 66
  if ((unsigned long )ht___1 == (unsigned long )((void *)0)) {
#line 67
    return ((_Bool)0);
  }
  {
#line 69
  new_ent.name = (char *)file;
#line 70
  new_ent.st_ino = (ino_t )stats->st_ino;
#line 71
  new_ent.st_dev = (dev_t )stats->st_dev;
#line 73
  tmp = hash_lookup(ht___1, (void const   *)(& new_ent));
  }
#line 73
  if (tmp) {
#line 73
    tmp___0 = 1;
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  return ((_Bool )tmp___0);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 274 "/home/khheo/project/benchmark/coreutils-7.1/lib/file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 


  {
#line 519
  return (0);
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 427 "./stdio.h"
int rpl_fflush(FILE *stream ) ;
#line 51 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __freading)(FILE *__fp ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/fflush.c"
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp ) 
{ 


  {
#line 41
  if (fp->_flags & 256) {
    {
#line 43
    rpl_fseeko(fp, (off_t )0, 1);
    }
  }
#line 44
  return;
}
}
#line 102 "/home/khheo/project/benchmark/coreutils-7.1/lib/fflush.c"
int rpl_fflush(FILE *stream ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
#line 125
    tmp = fflush(stream);
    }
#line 125
    return (tmp);
  } else {
    {
#line 124
    tmp___0 = __freading(stream);
    }
#line 124
    if (! (tmp___0 != 0)) {
      {
#line 125
      tmp = fflush(stream);
      }
#line 125
      return (tmp);
    }
  }
  {
#line 129
  clear_ungetc_buffer_preserving_position(stream);
#line 131
  tmp___1 = fflush(stream);
  }
#line 131
  return (tmp___1);
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 40
  if (0 <= fd) {
#line 40
    if (fd <= 2) {
      {
#line 42
      tmp = dup_safer(fd);
#line 42
      f = tmp;
#line 43
      tmp___0 = __errno_location();
#line 43
      e = *tmp___0;
#line 44
      close(fd);
#line 45
      tmp___1 = __errno_location();
#line 45
      *tmp___1 = e;
#line 46
      fd = f;
      }
    }
  }
#line 49
  return (fd);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/fd-reopen.h"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) ;
#line 537 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/fd-reopen.c"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) 
{ 
  int fd ;
  int tmp ;
  int fd2 ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 34
  tmp = open(file, flags, mode);
#line 34
  fd = tmp;
  }
#line 36
  if (fd == desired_fd) {
#line 37
    return (fd);
  } else
#line 36
  if (fd < 0) {
#line 37
    return (fd);
  } else {
    {
#line 40
    tmp___0 = dup2(fd, desired_fd);
#line 40
    fd2 = tmp___0;
#line 41
    tmp___1 = __errno_location();
#line 41
    saved_errno = *tmp___1;
#line 42
    close(fd);
#line 43
    tmp___2 = __errno_location();
#line 43
    *tmp___2 = saved_errno;
    }
#line 44
    return (fd2);
  }
}
}
#line 18 "/home/khheo/project/benchmark/coreutils-7.1/lib/exitfail.h"
int volatile   exit_failure ;
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.h"
struct exclude *new_exclude(void) ;
#line 37
void free_exclude(struct exclude *ex ) ;
#line 38
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 39
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___3 , int options ,
                     char line_end ) ;
#line 41
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 42
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 58
void *xrealloc(void *p , size_t n ) ;
#line 194 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 197
  n = *pn;
#line 199
  if (! p) {
#line 201
    if (! n) {
#line 209
      n = 64UL / s;
#line 210
      n += (size_t )(! n);
    }
  } else {
#line 219
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 220
      xalloc_die();
      }
    }
#line 221
    n += (n + 1UL) / 2UL;
  }
  {
#line 224
  *pn = n;
#line 225
  tmp = xrealloc(p, n * s);
  }
#line 225
  return (tmp);
}
}
#line 77 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 80
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 80
  return ((struct exclude *)tmp___0);
}
}
#line 85 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 


  {
  {
#line 88
  free((void *)ex->exclude);
#line 89
  free((void *)ex);
  }
#line 90
  return;
}
}
#line 95 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 98
  if (! (options & (1 << 3))) {
#line 99
    if (options & (1 << 4)) {
      {
#line 99
      tmp = mbscasecmp(pattern, f);
#line 99
      tmp___1 = tmp;
      }
    } else {
      {
#line 99
      tmp___0 = strcmp(pattern, f);
#line 99
      tmp___1 = tmp___0;
      }
    }
#line 99
    return (tmp___1);
  } else
#line 102
  if (! (options & (1 << 4))) {
    {
#line 104
    tmp___2 = strlen(pattern);
#line 104
    patlen = tmp___2;
#line 105
    tmp___3 = strncmp(pattern, f, patlen);
#line 105
    r = tmp___3;
    }
#line 106
    if (! r) {
#line 108
      r = (int )*(f + patlen);
#line 109
      if (r == 47) {
#line 110
        r = 0;
      }
    }
#line 112
    return (r);
  } else {
    {
#line 123
    tmp___4 = xstrdup(f);
#line 123
    fcopy = tmp___4;
#line 126
    p = fcopy;
    }
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 128
      p = strchr((char const   *)p, '/');
      }
#line 129
      if (p) {
#line 130
        *p = (char )'\000';
      }
      {
#line 131
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 132
      if (! p) {
#line 133
        goto while_break;
      } else
#line 132
      if (r___0 <= 0) {
#line 133
        goto while_break;
      }
#line 126
      tmp___5 = p;
#line 126
      p ++;
#line 126
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 135
    free((void *)fcopy);
    }
#line 136
    return (r___0);
  }
}
}
#line 140 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 143
  if (options & (1 << 28)) {
#line 143
    tmp = & fnmatch;
  } else {
#line 143
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 143
  matcher = tmp;
#line 147
  tmp___0 = (*matcher)(pattern, f, options);
#line 147
  matched = (_Bool )(tmp___0 == 0);
  }
#line 150
  if (! (options & (1 << 30))) {
#line 151
    p = f;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (*p) {
#line 151
        if (! (! matched)) {
#line 151
          goto while_break;
        }
      } else {
#line 151
        goto while_break;
      }
#line 152
      if ((int const   )*p == 47) {
#line 152
        if ((int const   )*(p + 1) != 47) {
          {
#line 153
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 153
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 151
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 155
  return (matched);
}
}
#line 160 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool excluded ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 163
  exclude_count = (size_t )ex->exclude_count;
#line 166
  if (exclude_count == 0UL) {
#line 167
    return ((_Bool)0);
  } else {
#line 170
    exclude = (struct patopts  const  *)ex->exclude;
#line 174
    excluded = (_Bool )(! (! ((exclude + 0)->options & (int const   )(1 << 29))));
#line 178
    i = (size_t )0;
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 178
      if (! (i < exclude_count)) {
#line 178
        goto while_break;
      }
#line 180
      pattern = (char const   *)(exclude + i)->pattern;
#line 181
      options = (int )(exclude + i)->options;
#line 182
      if ((int )excluded == ! (! (options & (1 << 29)))) {
        {
#line 183
        tmp = exclude_fnmatch(pattern, f, options);
#line 183
        excluded = (_Bool )((int )excluded ^ (int )tmp);
        }
      }
#line 178
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 186
    return (excluded);
  }
}
}
#line 192 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 197
  if (ex->exclude_count == ex->exclude_alloc) {
    {
#line 198
    tmp = x2nrealloc((void *)ex->exclude, & ex->exclude_alloc, sizeof(*(ex->exclude)));
#line 198
    ex->exclude = (struct patopts *)tmp;
    }
  }
#line 201
  tmp___0 = ex->exclude_count;
#line 201
  (ex->exclude_count) ++;
#line 201
  patopts = ex->exclude + tmp___0;
#line 202
  patopts->pattern = pattern;
#line 203
  patopts->options = options;
#line 204
  return;
}
}
#line 211 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___3 , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___1 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 216
  if ((int const   )*(file_name___3 + 0) == 45) {
#line 216
    if (! *(file_name___3 + 1)) {
#line 216
      tmp = 1;
    } else {
#line 216
      tmp = 0;
    }
  } else {
#line 216
    tmp = 0;
  }
#line 216
  use_stdin = (_Bool )tmp;
#line 218
  buf___1 = (char *)((void *)0);
#line 222
  buf_alloc = (size_t )0;
#line 223
  buf_count = (size_t )0;
#line 225
  e = 0;
#line 227
  if (use_stdin) {
#line 228
    in = stdin;
  } else {
    {
#line 229
    in = fopen((char const   */* __restrict  */)file_name___3, (char const   */* __restrict  */)"r");
    }
#line 229
    if (! in) {
#line 230
      return (-1);
    }
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    c = getc_unlocked(in);
    }
#line 232
    if (! (c != -1)) {
#line 232
      goto while_break;
    }
#line 234
    if (buf_count == buf_alloc) {
      {
#line 235
      tmp___0 = x2realloc((void *)buf___1, & buf_alloc);
#line 235
      buf___1 = (char *)tmp___0;
      }
    }
#line 236
    tmp___1 = buf_count;
#line 236
    buf_count ++;
#line 236
    *(buf___1 + tmp___1) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  tmp___3 = ferror_unlocked(in);
  }
#line 239
  if (tmp___3) {
    {
#line 240
    tmp___2 = __errno_location();
#line 240
    e = *tmp___2;
    }
  }
#line 242
  if (! use_stdin) {
    {
#line 242
    tmp___5 = fclose(in);
    }
#line 242
    if (tmp___5 != 0) {
      {
#line 243
      tmp___4 = __errno_location();
#line 243
      e = *tmp___4;
      }
    }
  }
  {
#line 245
  tmp___6 = xrealloc((void *)buf___1, buf_count + 1UL);
#line 245
  buf___1 = (char *)tmp___6;
#line 246
  *(buf___1 + buf_count) = line_end;
  }
#line 247
  if (buf_count == 0UL) {
#line 247
    tmp___7 = 0;
  } else
#line 247
  if ((int )*(buf___1 + (buf_count - 1UL)) == (int )line_end) {
#line 247
    tmp___7 = 0;
  } else {
#line 247
    tmp___7 = 1;
  }
#line 247
  lim = (char const   *)((buf___1 + buf_count) + tmp___7);
#line 248
  pattern = (char const   *)buf___1;
#line 250
  p = buf___1;
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 250
      goto while_break___0;
    }
#line 251
    if ((int )*p == (int )line_end) {
      {
#line 253
      pattern_end = p;
#line 255
      tmp___9 = __ctype_b_loc();
      }
#line 255
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 257
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 258
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 259
            goto next_pattern;
          } else {
            {
#line 260
            tmp___8 = __ctype_b_loc();
            }
#line 260
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 261
              goto while_break___1;
            }
          }
#line 257
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 264
      *pattern_end = (char )'\000';
#line 265
      (*add_func)(ex, pattern, options);
      }
      next_pattern: 
#line 268
      pattern = (char const   *)(p + 1);
    }
#line 250
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 271
  tmp___10 = __errno_location();
#line 271
  *tmp___10 = e;
  }
#line 272
  if (e) {
#line 272
    tmp___11 = -1;
  } else {
#line 272
    tmp___11 = 0;
  }
#line 272
  return (tmp___11);
}
}
#line 5 "/home/khheo/project/benchmark/coreutils-7.1/lib/euidaccess-stat.h"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) ;
#line 681 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 696
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) group_member)(__gid_t __gid ) ;
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/euidaccess-stat.c"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) 
{ 
  uid_t euid ;
  unsigned int granted ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  gid_t egid ;
  __gid_t tmp___11 ;
  int tmp___12 ;

  {
#line 57
  mode &= 7;
#line 63
  if (mode == 0) {
#line 64
    return ((_Bool)1);
  }
  {
#line 66
  euid = geteuid();
  }
#line 70
  if (euid == 0U) {
#line 70
    if ((mode & 1) == 0) {
#line 72
      return ((_Bool)1);
    } else
#line 70
    if (st->st_mode & (unsigned int const   )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 72
      return ((_Bool)1);
    }
  }
#line 75
  if (256 == 4 << 6) {
#line 75
    if (128 == 2 << 6) {
#line 75
      if (64 == 1 << 6) {
#line 75
        if (256 >> 3 == 4 << 3) {
#line 75
          if (128 >> 3 == 2 << 3) {
#line 75
            if (64 >> 3 == 1 << 3) {
#line 75
              if ((256 >> 3) >> 3 == 4) {
#line 75
                if ((128 >> 3) >> 3 == 2) {
#line 75
                  if ((64 >> 3) >> 3 == 1) {
#line 84
                    granted = (unsigned int )st->st_mode;
                  } else {
#line 75
                    goto _L___6;
                  }
                } else {
#line 75
                  goto _L___6;
                }
              } else {
#line 75
                goto _L___6;
              }
            } else {
#line 75
              goto _L___6;
            }
          } else {
#line 75
            goto _L___6;
          }
        } else {
#line 75
          goto _L___6;
        }
      } else {
#line 75
        goto _L___6;
      }
    } else {
#line 75
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
#line 86
    if (st->st_mode & 256U) {
#line 86
      tmp___2 = 4 << 6;
    } else {
#line 86
      tmp___2 = 0;
    }
#line 86
    if (st->st_mode & 128U) {
#line 86
      tmp___3 = 2 << 6;
    } else {
#line 86
      tmp___3 = 0;
    }
#line 86
    if (st->st_mode & 64U) {
#line 86
      tmp___4 = 1 << 6;
    } else {
#line 86
      tmp___4 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )(256 >> 3)) {
#line 86
      tmp___5 = 4 << 3;
    } else {
#line 86
      tmp___5 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )(128 >> 3)) {
#line 86
      tmp___6 = 2 << 3;
    } else {
#line 86
      tmp___6 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )(64 >> 3)) {
#line 86
      tmp___7 = 1 << 3;
    } else {
#line 86
      tmp___7 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
#line 86
      tmp___8 = 4;
    } else {
#line 86
      tmp___8 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )((128 >> 3) >> 3)) {
#line 86
      tmp___9 = 2;
    } else {
#line 86
      tmp___9 = 0;
    }
#line 86
    if (st->st_mode & (unsigned int const   )((64 >> 3) >> 3)) {
#line 86
      tmp___10 = 1;
    } else {
#line 86
      tmp___10 = 0;
    }
#line 86
    granted = (unsigned int )((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) + tmp___6) + tmp___7) + tmp___8) + tmp___9) + tmp___10);
  }
#line 96
  if (euid == (uid_t )st->st_uid) {
#line 97
    granted >>= 6;
  } else {
    {
#line 100
    tmp___11 = getegid();
#line 100
    egid = tmp___11;
    }
#line 101
    if (egid == (gid_t )st->st_gid) {
#line 102
      granted >>= 3;
    } else {
      {
#line 101
      tmp___12 = group_member((__gid_t )st->st_gid);
      }
#line 101
      if (tmp___12) {
#line 102
        granted >>= 3;
      }
    }
  }
#line 105
  if (((unsigned int )mode & ~ granted) == 0U) {
#line 106
    return ((_Bool)1);
  }
#line 108
  return ((_Bool)0);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 36
  tmp = fcntl(fd, 0, 3);
  }
#line 36
  return (tmp);
}
}
#line 62 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 64
size_t dir_len(char const   *file ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = xmalloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
#line 79
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 80
  if (append_dot) {
#line 81
    tmp___2 = length;
#line 81
    length ++;
#line 81
    *(dir + tmp___2) = (char )'.';
  }
#line 82
  *(dir + length) = (char )'\000';
#line 83
  return (dir);
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirchownmod.h"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 481
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 486
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                             __uid_t __owner ,
                                                                                             __gid_t __group ) ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirchownmod.c"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) 
{ 
  struct stat st ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mode_t dir_mode ;
  int *tmp___2 ;
  mode_t indeterminate ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mode_t chmod_mode ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int e ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 66
  if (fd < 0) {
    {
#line 66
    tmp = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& st));
#line 66
    tmp___1 = tmp;
    }
  } else {
    {
#line 66
    tmp___0 = fstat(fd, & st);
#line 66
    tmp___1 = tmp___0;
    }
  }
#line 66
  result = tmp___1;
#line 68
  if (result == 0) {
#line 70
    dir_mode = st.st_mode;
#line 76
    if (! ((dir_mode & 61440U) == 16384U)) {
      {
#line 78
      tmp___2 = __errno_location();
#line 78
      *tmp___2 = 20;
#line 79
      result = -1;
      }
    } else {
#line 87
      indeterminate = (mode_t )0;
#line 94
      if (owner != 4294967295U) {
#line 94
        if (owner != st.st_uid) {
#line 94
          goto _L;
        } else {
#line 94
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 94
      if (group != 4294967295U) {
#line 94
        if (group != st.st_gid) {
          _L: /* CIL Label */ 
#line 97
          if (0 <= fd) {
            {
#line 97
            tmp___3 = fchown(fd, owner, group);
#line 97
            result = tmp___3;
            }
          } else {
#line 97
            if (mkdir_mode != 4294967295U) {
              {
#line 97
              tmp___4 = lchown(dir, owner, group);
#line 97
              tmp___6 = tmp___4;
              }
            } else {
              {
#line 97
              tmp___5 = chown(dir, owner, group);
#line 97
              tmp___6 = tmp___5;
              }
            }
#line 97
            result = tmp___6;
          }
#line 108
          if (result == 0) {
#line 108
            if (dir_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 109
              indeterminate = dir_mode & 3072U;
            }
          }
        }
      }
#line 115
      if (result == 0) {
#line 115
        if (((dir_mode ^ mode) | indeterminate) & mode_bits) {
#line 117
          chmod_mode = mode | ((dir_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & ~ mode_bits);
#line 119
          if (0 <= fd) {
            {
#line 119
            tmp___7 = fchmod(fd, chmod_mode);
#line 119
            result = tmp___7;
            }
          } else {
#line 119
            if (mkdir_mode != 4294967295U) {
              {
#line 119
              tmp___8 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___8;
              }
            } else {
              {
#line 119
              tmp___9 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___9;
              }
            }
#line 119
            result = tmp___10;
          }
        }
      }
    }
  }
#line 128
  if (0 <= fd) {
#line 130
    if (result == 0) {
      {
#line 131
      result = close(fd);
      }
    } else {
      {
#line 134
      tmp___11 = __errno_location();
#line 134
      e = *tmp___11;
#line 135
      close(fd);
#line 136
      tmp___12 = __errno_location();
#line 136
      *tmp___12 = e;
      }
    }
  }
#line 140
  return (result);
}
}
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/diacrit.h"
char const   diacrit_base[256] ;
#line 21
char const   diacrit_diac[256] ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/diacrit.c"
char const   diacrit_base[256]  = 
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/diacrit.c"
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'A', 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'C', 
        (char const   )'E',      (char const   )'E',      (char const   )'E',      (char const   )'E', 
        (char const   )'I',      (char const   )'I',      (char const   )'I',      (char const   )'I', 
        (char const   )0,      (char const   )'N',      (char const   )'O',      (char const   )'O', 
        (char const   )'O',      (char const   )'O',      (char const   )'O',      (char const   )0, 
        (char const   )'O',      (char const   )'U',      (char const   )'U',      (char const   )'U', 
        (char const   )'U',      (char const   )'Y',      (char const   )0,      (char const   )0, 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'e',      (char const   )'e',      (char const   )'e', 
        (char const   )'i',      (char const   )'i',      (char const   )'i',      (char const   )'i', 
        (char const   )0,      (char const   )'n',      (char const   )'o',      (char const   )'o', 
        (char const   )'o',      (char const   )'o',      (char const   )'o',      (char const   )0, 
        (char const   )'o',      (char const   )'u',      (char const   )'u',      (char const   )'u', 
        (char const   )'u',      (char const   )'y',      (char const   )0,      (char const   )'y'};
#line 103 "/home/khheo/project/benchmark/coreutils-7.1/lib/diacrit.c"
char const   diacrit_diac[256]  = 
#line 103
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )4,      (char const   )0, 
        (char const   )3,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )6,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0};
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.c"
__inline static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state___0 ) 
{ 


  {
#line 45
  state___0->chdir_counter = (uintmax_t )0;
#line 46
  state___0->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state___0 , struct stat  const  *sb ) 
{ 
  _Bool tmp___0 ;

  {
#line 60
  if (! (state___0->magic == 9827862)) {
    {
#line 60
    __assert_fail("state->magic == CC_MAGIC", "/home/khheo/project/benchmark/coreutils-7.1/lib/cycle-check.c",
                  60U, "cycle_check");
    }
  }
#line 65
  if (state___0->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state___0->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state___0->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
  {
#line 70
  (state___0->chdir_counter) ++;
#line 70
  tmp___0 = is_zero_or_power_of_two(state___0->chdir_counter);
  }
#line 70
  if (tmp___0) {
#line 77
    if (state___0->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state___0->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state___0->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = creat(file, mode);
#line 30
  tmp___0 = fd_safer(tmp);
  }
#line 30
  return (tmp___0);
}
}
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 26
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/quote.h"
char const   *quote(char const   *name ) ;
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/copy-acl.c"
static int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
                     int dest_desc , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 520
  tmp = qset_acl(dst_name, dest_desc, mode);
  }
#line 520
  return (tmp);
}
}
#line 535 "/home/khheo/project/benchmark/coreutils-7.1/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 539
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 539
  ret = tmp;
  }
  {
#line 542
  if (ret == -2) {
#line 542
    goto case_neg_2;
  }
#line 546
  if (ret == -1) {
#line 546
    goto case_neg_1;
  }
#line 550
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 543
  tmp___0 = quote(src_name);
#line 543
  tmp___1 = __errno_location();
#line 543
  error(0, *tmp___1, "%s", tmp___0);
  }
#line 544
  return (-1);
  case_neg_1: /* CIL Label */ 
  {
#line 547
  tmp___2 = quote(dst_name);
#line 547
  tmp___3 = gettext("preserving permissions for %s");
#line 547
  tmp___4 = __errno_location();
#line 547
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  }
#line 548
  return (-1);
  switch_default: /* CIL Label */ 
#line 551
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 297 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
char *quotearg_colon(char const   *arg ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/closein.h"
void close_stdin_set_file_name(char const   *file ) ;
#line 26
void close_stdin(void) ;
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/closein.c"
static char const   *file_name___0  ;
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/closein.c"
void close_stdin_set_file_name(char const   *file ) 
{ 


  {
#line 45
  file_name___0 = file;
#line 46
  return;
}
}
#line 78 "/home/khheo/project/benchmark/coreutils-7.1/lib/closein.c"
void close_stdin(void) 
{ 
  _Bool fail ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *close_error ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 81
  fail = (_Bool)0;
#line 86
  tmp___1 = freadahead(stdin);
  }
#line 86
  if (tmp___1 > 0UL) {
    {
#line 90
    tmp = rpl_fseeko(stdin, (off_t )0, 1);
    }
#line 90
    if (tmp == 0) {
      {
#line 90
      tmp___0 = rpl_fflush(stdin);
      }
#line 90
      if (tmp___0 != 0) {
#line 91
        fail = (_Bool)1;
      }
    }
  }
  {
#line 93
  tmp___2 = close_stream(stdin);
  }
#line 93
  if (tmp___2 != 0) {
#line 94
    fail = (_Bool)1;
  }
#line 95
  if (fail) {
    {
#line 99
    tmp___3 = gettext("error closing file");
#line 99
    close_error = (char const   *)tmp___3;
    }
#line 100
    if (file_name___0) {
      {
#line 101
      tmp___4 = quotearg_colon(file_name___0);
#line 101
      tmp___5 = __errno_location();
#line 101
      error(0, *tmp___5, "%s: %s", tmp___4, close_error);
      }
    } else {
      {
#line 104
      tmp___6 = __errno_location();
#line 104
      error(0, *tmp___6, "%s", close_error);
      }
    }
  }
  {
#line 107
  close_stdout();
  }
#line 109
  if (fail) {
    {
#line 110
    _exit((int )exit_failure);
    }
  }
#line 111
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 59
  tmp = __fpending(stream);
#line 59
  some_pending = (_Bool )(tmp != 0UL);
#line 60
  tmp___0 = ferror_unlocked(stream);
#line 60
  prev_fail = (_Bool )(tmp___0 != 0);
#line 61
  tmp___1 = fclose(stream);
#line 61
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 71
  if (prev_fail) {
#line 71
    goto _L___0;
  } else
#line 71
  if (fclose_fail) {
#line 71
    if (some_pending) {
#line 71
      goto _L___0;
    } else {
      {
#line 71
      tmp___3 = __errno_location();
      }
#line 71
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 73
        if (! fclose_fail) {
          {
#line 74
          tmp___2 = __errno_location();
#line 74
          *tmp___2 = 0;
          }
        }
#line 75
        return (-1);
      }
    }
  }
#line 78
  return (0);
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  tmp = fcntl(desc, 1, 0);
#line 40
  flags = tmp;
  }
#line 42
  if (0 <= flags) {
#line 44
    if (value) {
#line 44
      tmp___0 = flags | 1;
    } else {
#line 44
      tmp___0 = flags & -2;
    }
#line 44
    newflags = tmp___0;
#line 46
    if (flags == newflags) {
#line 48
      return (0);
    } else {
      {
#line 46
      tmp___1 = fcntl(desc, 2, newflags);
      }
#line 46
      if (tmp___1 != -1) {
#line 48
        return (0);
      }
    }
  }
#line 51
  return (-1);
}
}
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 114
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 45
  cdb->fd = -100;
#line 46
  return;
}
}
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = fchdir((int )cdb->fd);
  }
#line 51
  return (tmp);
}
}
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 57
  if (0 <= (int )cdb->fd) {
    {
#line 59
    tmp = close((int )cdb->fd);
#line 59
    close_fail = (_Bool )tmp;
    }
#line 60
    if (! (! close_fail)) {
      {
#line 60
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                    60U, "cdb_free");
      }
    }
  }
#line 62
  return;
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 71
  tmp = openat(cdb->fd, dir, 67840);
#line 71
  new_fd = tmp;
  }
#line 73
  if (new_fd < 0) {
#line 74
    return (-1);
  }
  {
#line 76
  cdb_free((struct cd_buf  const  *)cdb);
#line 77
  cdb->fd = new_fd;
  }
#line 79
  return (0);
}
}
#line 83 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
__inline static char *find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 86
  tmp = strspn(s, "/");
#line 86
  n_slash = tmp;
  }
#line 87
  return ((char *)s + n_slash);
}
}
#line 105 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___9 ;
  int *tmp___10 ;
  int tmp___12 ;
  int tmp___13 ;
  int saved_errno ;
  int *tmp___14 ;
  int *tmp___15 ;

  {
  {
#line 108
  tmp = chdir((char const   *)dir);
#line 108
  e = tmp;
  }
#line 109
  if (e == 0) {
#line 110
    return (e);
  } else {
    {
#line 109
    tmp___0 = __errno_location();
    }
#line 109
    if (*tmp___0 != 36) {
#line 110
      return (e);
    }
  }
  {
#line 113
  tmp___1 = strlen((char const   *)dir);
#line 113
  len = tmp___1;
#line 114
  dir_end = dir + len;
#line 118
  cdb_init(& cdb);
  }
#line 122
  if (! (0UL < len)) {
    {
#line 122
    __assert_fail("0 < len", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                  122U, "chdir_long");
    }
  }
#line 123
  if (! (4096UL <= len)) {
    {
#line 123
    __assert_fail("PATH_MAX <= len", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                  123U, "chdir_long");
    }
  }
  {
#line 126
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 133
  if (n_leading_slash == 2UL) {
    {
#line 138
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 138
    slash = (char *)tmp___4;
    }
#line 139
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 141
      tmp___5 = __errno_location();
#line 141
      *tmp___5 = 36;
      }
#line 142
      return (-1);
    }
    {
#line 144
    *slash = (char )'\000';
#line 145
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 146
    *slash = (char )'/';
    }
#line 147
    if (err != 0) {
#line 148
      goto Fail;
    }
    {
#line 149
    dir = find_non_slash((char const   *)(slash + 1));
    }
  } else
#line 151
  if (n_leading_slash) {
    {
#line 153
    tmp___6 = cdb_advance_fd(& cdb, "/");
    }
#line 153
    if (tmp___6 != 0) {
#line 154
      goto Fail;
    }
#line 155
    dir += n_leading_slash;
  }
#line 158
  if (! ((int )*dir != 47)) {
    {
#line 158
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                  158U, "chdir_long");
    }
  }
#line 159
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 159
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                  159U, "chdir_long");
    }
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (4096L <= dir_end - dir)) {
#line 161
      goto while_break;
    }
    {
#line 167
    tmp___9 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 167
    slash___0 = (char *)tmp___9;
    }
#line 168
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 170
      tmp___10 = __errno_location();
#line 170
      *tmp___10 = 36;
      }
#line 171
      return (-1);
    }
#line 174
    *slash___0 = (char )'\000';
#line 175
    if (! (slash___0 - dir < 4096L)) {
      {
#line 175
      __assert_fail("slash - dir < PATH_MAX", "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c",
                    175U, "chdir_long");
      }
    }
    {
#line 176
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 177
    *slash___0 = (char )'/';
    }
#line 178
    if (err___0 != 0) {
#line 179
      goto Fail;
    }
    {
#line 181
    dir = find_non_slash((char const   *)(slash___0 + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 186
    tmp___12 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 186
    if (tmp___12 != 0) {
#line 187
      goto Fail;
    }
  }
  {
#line 190
  tmp___13 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 190
  if (tmp___13 != 0) {
#line 191
    goto Fail;
  }
  {
#line 193
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 194
  return (0);
  Fail: 
  {
#line 198
  tmp___14 = __errno_location();
#line 198
  saved_errno = *tmp___14;
#line 199
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 200
  tmp___15 = __errno_location();
#line 200
  *tmp___15 = saved_errno;
  }
#line 201
  return (-1);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.h"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) ;
#line 17 "/home/khheo/project/benchmark/coreutils-7.1/lib/xgetcwd.h"
char *xgetcwd(void) ;
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/areadlink.h"
char *areadlink_with_size(char const   *file , size_t size ) ;
#line 127 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.c"
static _Bool seen_triple(Hash_table **ht___1 , char const   *filename , struct stat  const  *st ) 
{ 
  size_t initial_capacity ;
  _Bool tmp ;

  {
#line 130
  if ((unsigned long )*ht___1 == (unsigned long )((void *)0)) {
    {
#line 132
    initial_capacity = (size_t )7;
#line 133
    *ht___1 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
    }
#line 138
    if ((unsigned long )*ht___1 == (unsigned long )((void *)0)) {
      {
#line 139
      xalloc_die();
      }
    }
  }
  {
#line 142
  tmp = seen_file((Hash_table const   *)*ht___1, filename, st);
  }
#line 142
  if (tmp) {
#line 143
    return ((_Bool)1);
  }
  {
#line 145
  record_file(*ht___1, filename, st);
  }
#line 146
  return ((_Bool)0);
}
}
#line 154 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.c"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) 
{ 
  char *rname ;
  char *dest ;
  char *extra_buf ;
  char const   *start ;
  char const   *end ;
  char const   *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___1 ;
  int *tmp ;
  int *tmp___0 ;
  char *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct stat st ;
  char *tmp___3 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *buf___1 ;
  size_t n ;
  size_t len ;
  int *tmp___7 ;
  _Bool tmp___8 ;
  int *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;

  {
#line 157
  extra_buf = (char *)((void *)0);
#line 161
  extra_len = (size_t )0;
#line 162
  ht___1 = (Hash_table *)((void *)0);
#line 164
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 166
    tmp = __errno_location();
#line 166
    *tmp = 22;
    }
#line 167
    return ((char *)((void *)0));
  }
#line 170
  if ((int const   )*(name + 0) == 0) {
    {
#line 172
    tmp___0 = __errno_location();
#line 172
    *tmp___0 = 2;
    }
#line 173
    return ((char *)((void *)0));
  }
#line 176
  if ((int const   )*(name + 0) != 47) {
    {
#line 178
    rname = xgetcwd();
    }
#line 179
    if (! rname) {
#line 180
      return ((char *)((void *)0));
    }
    {
#line 181
    dest = strchr((char const   *)rname, '\000');
    }
#line 182
    if (dest - rname < 4096L) {
      {
#line 184
      tmp___1 = xrealloc((void *)rname, (size_t )4096);
#line 184
      p = (char *)tmp___1;
#line 185
      dest = p + (dest - rname);
#line 186
      rname = p;
#line 187
      rname_limit = (char const   *)(rname + 4096);
      }
    } else {
#line 191
      rname_limit = (char const   *)dest;
    }
  } else {
    {
#line 196
    tmp___2 = xmalloc((size_t )4096);
#line 196
    rname = (char *)tmp___2;
#line 197
    rname_limit = (char const   *)(rname + 4096);
#line 198
    *(rname + 0) = (char )'/';
#line 199
    dest = rname + 1;
    }
  }
#line 202
  end = name;
#line 202
  start = end;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *start) {
#line 202
      goto while_break;
    }
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! ((int const   )*start == 47)) {
#line 205
        goto while_break___0;
      }
#line 206
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    end = start;
    {
#line 209
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 209
      if (*end) {
#line 209
        if (! ((int const   )*end != 47)) {
#line 209
          goto while_break___1;
        }
      } else {
#line 209
        goto while_break___1;
      }
#line 209
      end ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 212
    if (end - start == 0L) {
#line 213
      goto while_break;
    } else
#line 214
    if (end - start == 1L) {
#line 214
      if (! ((int const   )*(start + 0) == 46)) {
#line 214
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 216
    if (end - start == 2L) {
#line 216
      if ((int const   )*(start + 0) == 46) {
#line 216
        if ((int const   )*(start + 1) == 46) {
#line 219
          if ((unsigned long )dest > (unsigned long )(rname + 1)) {
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 220
              dest --;
#line 220
              if (! ((int )*(dest + -1) != 47)) {
#line 220
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 216
          goto _L___0;
        }
      } else {
#line 216
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 226
      if ((int )*(dest + -1) != 47) {
#line 227
        tmp___3 = dest;
#line 227
        dest ++;
#line 227
        *tmp___3 = (char )'/';
      }
#line 229
      if ((unsigned long )(dest + (end - start)) >= (unsigned long )rname_limit) {
#line 231
        dest_offset = dest - rname;
#line 232
        new_size = (size_t )(rname_limit - (char const   *)rname);
#line 234
        if ((end - start) + 1L > 4096L) {
#line 235
          new_size += (size_t )((end - start) + 1L);
        } else {
#line 237
          new_size += 4096UL;
        }
        {
#line 238
        tmp___4 = xrealloc((void *)rname, new_size);
#line 238
        rname = (char *)tmp___4;
#line 239
        rname_limit = (char const   *)(rname + new_size);
#line 241
        dest = rname + dest_offset;
        }
      }
      {
#line 244
      tmp___5 = memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)start,
                       (size_t )(end - start));
#line 244
      dest = (char *)tmp___5;
#line 245
      dest += end - start;
#line 246
      *dest = (char )'\000';
#line 248
      tmp___6 = lstat((char const   */* __restrict  */)rname, (struct stat */* __restrict  */)(& st));
      }
#line 248
      if (tmp___6 != 0) {
#line 250
        if ((unsigned int )can_mode == 0U) {
#line 251
          goto error;
        }
#line 252
        if ((unsigned int )can_mode == 1U) {
#line 252
          if (*end) {
#line 253
            goto error;
          }
        }
#line 254
        st.st_mode = (__mode_t )0;
      }
#line 257
      if ((st.st_mode & 61440U) == 40960U) {
        {
#line 266
        tmp___8 = seen_triple(& ht___1, name, (struct stat  const  *)(& st));
        }
#line 266
        if (tmp___8) {
          {
#line 268
          tmp___7 = __errno_location();
#line 268
          *tmp___7 = 40;
          }
#line 269
          if ((unsigned int )can_mode == 2U) {
#line 270
            goto __Cont;
          } else {
#line 272
            goto error;
          }
        }
        {
#line 275
        buf___1 = areadlink_with_size((char const   *)rname, (size_t )st.st_size);
        }
#line 276
        if (! buf___1) {
#line 278
          if ((unsigned int )can_mode == 2U) {
            {
#line 278
            tmp___9 = __errno_location();
            }
#line 278
            if (*tmp___9 != 12) {
#line 279
              goto __Cont;
            } else {
#line 281
              goto error;
            }
          } else {
#line 281
            goto error;
          }
        }
        {
#line 284
        n = strlen((char const   *)buf___1);
#line 285
        len = strlen(end);
        }
#line 287
        if (! extra_len) {
#line 289
          if ((n + len) + 1UL > 4096UL) {
#line 289
            extra_len = (n + len) + 1UL;
          } else {
#line 289
            extra_len = (size_t )4096;
          }
          {
#line 291
          tmp___10 = xmalloc(extra_len);
#line 291
          extra_buf = (char *)tmp___10;
          }
        } else
#line 293
        if ((n + len) + 1UL > extra_len) {
          {
#line 295
          extra_len = (n + len) + 1UL;
#line 296
          tmp___11 = xrealloc((void *)extra_buf, extra_len);
#line 296
          extra_buf = (char *)tmp___11;
          }
        }
        {
#line 300
        memmove((void *)(extra_buf + n), (void const   *)end, len + 1UL);
#line 301
        tmp___12 = memcpy((void */* __restrict  */)extra_buf, (void const   */* __restrict  */)buf___1,
                          n);
#line 301
        end = (char const   *)tmp___12;
#line 301
        name = end;
        }
#line 303
        if ((int )*(buf___1 + 0) == 47) {
#line 304
          dest = rname + 1;
        } else
#line 307
        if ((unsigned long )dest > (unsigned long )(rname + 1)) {
          {
#line 308
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 308
            dest --;
#line 308
            if (! ((int )*(dest + -1) != 47)) {
#line 308
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 310
        free((void *)buf___1);
        }
      } else
#line 314
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 314
        if (*end) {
#line 314
          if ((unsigned int )can_mode != 2U) {
            {
#line 316
            tmp___13 = __errno_location();
#line 316
            *tmp___13 = 20;
            }
#line 317
            goto error;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 202
    start = end;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 322
    if ((int )*(dest + -1) == 47) {
#line 323
      dest --;
    }
  }
  {
#line 324
  *dest = (char )'\000';
#line 326
  free((void *)extra_buf);
  }
#line 327
  if (ht___1) {
    {
#line 328
    hash_free(ht___1);
    }
  }
#line 329
  return (rname);
  error: 
  {
#line 332
  free((void *)extra_buf);
#line 333
  free((void *)rname);
  }
#line 334
  if (ht___1) {
    {
#line 335
    hash_free(ht___1);
    }
  }
#line 336
  return ((char *)((void *)0));
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.h"
char *canon_host(char const   *host ) ;
#line 24
char *canon_host_r(char const   *host , int *cherror ) ;
#line 26
char const   *ch_strerror(void) ;
#line 660 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 666
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 669
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
static int last_cherror  ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
char *canon_host(char const   *host ) 
{ 
  char *tmp ;

  {
  {
#line 35
  tmp = canon_host_r(host, & last_cherror);
  }
#line 35
  return (tmp);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
static struct addrinfo hints  ;
#line 59 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
char *canon_host_r(char const   *host , int *cherror ) 
{ 
  char *retval ;
  struct addrinfo *res ;
  int status ;
  char const   *tmp ;

  {
  {
#line 62
  retval = (char *)((void *)0);
#line 64
  res = (struct addrinfo *)((void *)0);
#line 67
  hints.ai_flags = 2;
#line 68
  status = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 69
  if (! status) {
#line 74
    if (res->ai_canonname) {
#line 74
      tmp = (char const   *)res->ai_canonname;
    } else {
#line 74
      tmp = host;
    }
    {
#line 74
    retval = strdup(tmp);
    }
#line 75
    if (! retval) {
#line 75
      if (cherror) {
#line 76
        *cherror = -10;
      }
    }
    {
#line 77
    freeaddrinfo(res);
    }
  } else
#line 79
  if (cherror) {
#line 80
    *cherror = status;
  }
#line 82
  return (retval);
}
}
#line 86 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
char const   *ch_strerror(void) 
{ 
  char const   *tmp ;

  {
  {
#line 89
  tmp = gai_strerror(last_cherror);
  }
#line 89
  return (tmp);
}
}
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.h"
long double c_strtold(char const   *nptr , char **endptr ) ;
#line 141 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) locale_t ( __attribute__((__leaf__)) newlocale)(int __category_mask ,
                                                                                     char const   *__locale ,
                                                                                     locale_t __base ) ;
#line 303 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long double ( __attribute__((__nonnull__(1,3),
__leaf__)) strtold_l)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                      locale_t __loc ) ;
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache  ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
__inline static locale_t c_locale(void) 
{ 
  locale_t tmp ;

  {
#line 58
  if (! c_locale_cache) {
    {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache = (locale_t volatile   )tmp;
    }
  }
#line 60
  return ((locale_t )c_locale_cache);
}
}
#line 65 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
long double c_strtold(char const   *nptr , char **endptr ) 
{ 
  long double r ;
  locale_t locale ;
  locale_t tmp ;

  {
  {
#line 72
  tmp = c_locale();
#line 72
  locale = tmp;
  }
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((long double )0);
  }
  {
#line 80
  r = strtold_l((char const   */* __restrict  */)nptr, (char **/* __restrict  */)endptr,
                locale);
  }
#line 111
  return (r);
}
}
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.h"
double c_strtod(char const   *nptr , char **endptr ) ;
#line 295 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1,3), __leaf__)) strtod_l)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    locale_t __loc ) ;
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache___0  ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
__inline static locale_t c_locale___0(void) 
{ 
  locale_t tmp ;

  {
#line 58
  if (! c_locale_cache___0) {
    {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache___0 = (locale_t volatile   )tmp;
    }
  }
#line 60
  return ((locale_t )c_locale_cache___0);
}
}
#line 65 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
double c_strtod(char const   *nptr , char **endptr ) 
{ 
  double r ;
  locale_t locale ;
  locale_t tmp ;

  {
  {
#line 72
  tmp = c_locale___0();
#line 72
  locale = tmp;
  }
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((double )0);
  }
  {
#line 80
  r = strtod_l((char const   */* __restrict  */)nptr, (char **/* __restrict  */)endptr,
               locale);
  }
#line 111
  return (r);
}
}
#line 47 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 136 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.h"
int c_tolower(int c ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 30
  p1 = (unsigned char const   *)s1;
#line 31
  p2 = (unsigned char const   *)s2;
#line 34
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 35
    return (0);
  } else
#line 34
  if (n == 0UL) {
#line 35
    return (0);
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    tmp = c_tolower((int )*p1);
#line 39
    c1 = (unsigned char )tmp;
#line 40
    tmp___0 = c_tolower((int )*p2);
#line 40
    c2 = (unsigned char )tmp___0;
#line 42
    n --;
    }
#line 42
    if (n == 0UL) {
#line 43
      goto while_break;
    } else
#line 42
    if ((int )c1 == 0) {
#line 43
      goto while_break;
    }
#line 45
    p1 ++;
#line 46
    p2 ++;
#line 37
    if (! ((int )c1 == (int )c2)) {
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((int )c1 - (int )c2);
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 30
  p1 = (unsigned char const   *)s1;
#line 31
  p2 = (unsigned char const   *)s2;
#line 34
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 35
    return (0);
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    tmp = c_tolower((int )*p1);
#line 39
    c1 = (unsigned char )tmp;
#line 40
    tmp___0 = c_tolower((int )*p2);
#line 40
    c2 = (unsigned char )tmp___0;
    }
#line 42
    if ((int )c1 == 0) {
#line 43
      goto while_break;
    }
#line 45
    p1 ++;
#line 46
    p2 ++;
#line 37
    if (! ((int )c1 == (int )c2)) {
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((int )c1 - (int )c2);
}
}
#line 121 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isblank(int c ) ;
#line 126
_Bool c_iscntrl(int c ) ;
#line 128
_Bool c_islower(int c ) ;
#line 129
_Bool c_isgraph(int c ) ;
#line 130
_Bool c_isprint(int c ) ;
#line 131
_Bool c_ispunct(int c ) ;
#line 133
_Bool c_isupper(int c ) ;
#line 134
_Bool c_isxdigit(int c ) ;
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 30
  if (c >= 0) {
#line 30
    if (c <= 127) {
#line 30
      tmp = 1;
    } else {
#line 30
      tmp = 0;
    }
  } else {
#line 30
    tmp = 0;
  }
#line 30
  return ((_Bool )tmp);
}
}
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 39
  if (c >= 48) {
#line 39
    if (c <= 57) {
#line 39
      tmp = 1;
    } else {
#line 39
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 39
  if ((c & -33) >= 65) {
#line 39
    if ((c & -33) <= 90) {
#line 39
      tmp = 1;
    } else {
#line 39
      tmp = 0;
    }
  } else {
#line 39
    tmp = 0;
  }
#line 39
  return ((_Bool )tmp);
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 73
  if ((c & -33) >= 65) {
#line 73
    if ((c & -33) <= 90) {
#line 73
      tmp = 1;
    } else {
#line 73
      tmp = 0;
    }
  } else {
#line 73
    tmp = 0;
  }
#line 73
  return ((_Bool )tmp);
}
}
#line 97 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 100
  if (c == 32) {
#line 100
    tmp = 1;
  } else
#line 100
  if (c == 9) {
#line 100
    tmp = 1;
  } else {
#line 100
    tmp = 0;
  }
#line 100
  return ((_Bool )tmp);
}
}
#line 103 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 107
  if ((c & -32) == 0) {
#line 107
    tmp = 1;
  } else
#line 107
  if (c == 127) {
#line 107
    tmp = 1;
  } else {
#line 107
    tmp = 0;
  }
#line 107
  return ((_Bool )tmp);
}
}
#line 137 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 141
  if (c >= 48) {
#line 141
    if (c <= 57) {
#line 141
      tmp = 1;
    } else {
#line 141
      tmp = 0;
    }
  } else {
#line 141
    tmp = 0;
  }
#line 141
  return ((_Bool )tmp);
}
}
#line 154 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 158
  if (c >= 97) {
#line 158
    if (c <= 122) {
#line 158
      tmp = 1;
    } else {
#line 158
      tmp = 0;
    }
  } else {
#line 158
    tmp = 0;
  }
#line 158
  return ((_Bool )tmp);
}
}
#line 174 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 178
  if (c >= 33) {
#line 178
    if (c <= 126) {
#line 178
      tmp = 1;
    } else {
#line 178
      tmp = 0;
    }
  } else {
#line 178
    tmp = 0;
  }
#line 178
  return ((_Bool )tmp);
}
}
#line 208 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 212
  if (c >= 32) {
#line 212
    if (c <= 126) {
#line 212
      tmp = 1;
    } else {
#line 212
      tmp = 0;
    }
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return ((_Bool )tmp);
}
}
#line 242 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 246
  if (c >= 33) {
#line 246
    if (c <= 126) {
#line 246
      if (c >= 48) {
#line 246
        if (c <= 57) {
#line 246
          tmp = 0;
        } else {
#line 246
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 246
      if ((c & -33) >= 65) {
#line 246
        if ((c & -33) <= 90) {
#line 246
          tmp = 0;
        } else {
#line 246
          tmp = 1;
        }
      } else {
#line 246
        tmp = 1;
      }
    } else {
#line 246
      tmp = 0;
    }
  } else {
#line 246
    tmp = 0;
  }
#line 246
  return ((_Bool )tmp);
}
}
#line 266 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 269
  if (c == 32) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 9) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 10) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 11) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 12) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 13) {
#line 269
    tmp = 1;
  } else {
#line 269
    tmp = 0;
  }
#line 269
  return ((_Bool )tmp);
}
}
#line 273 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 277
  if (c >= 65) {
#line 277
    if (c <= 90) {
#line 277
      tmp = 1;
    } else {
#line 277
      tmp = 0;
    }
  } else {
#line 277
    tmp = 0;
  }
#line 277
  return ((_Bool )tmp);
}
}
#line 293 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 299
  if (c >= 48) {
#line 299
    if (c <= 57) {
#line 299
      tmp = 1;
    } else {
#line 299
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 299
  if ((c & -33) >= 65) {
#line 299
    if ((c & -33) <= 70) {
#line 299
      tmp = 1;
    } else {
#line 299
      tmp = 0;
    }
  } else {
#line 299
    tmp = 0;
  }
#line 299
  return ((_Bool )tmp);
}
}
#line 320 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 324
  if (c >= 65) {
#line 324
    if (c <= 90) {
#line 324
      tmp = (c - 65) + 97;
    } else {
#line 324
      tmp = c;
    }
  } else {
#line 324
    tmp = c;
  }
#line 324
  return (tmp);
}
}
#line 359 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 363
  if (c >= 97) {
#line 363
    if (c <= 122) {
#line 363
      tmp = (c - 97) + 65;
    } else {
#line 363
      tmp = c;
    }
  } else {
#line 363
    tmp = c;
  }
#line 363
  return (tmp);
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/buffer-lcm.h"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) ;
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/buffer-lcm.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ 
  size_t size ;
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;

  {
#line 32
  if (! a) {
#line 33
    if (b) {
#line 33
      size = b;
    } else {
#line 33
      size = (size_t )8192;
    }
  } else {
#line 36
    if (b) {
#line 44
      m = a;
#line 44
      n = b;
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
#line 44
        r = m % n;
#line 44
        if (! (r != 0UL)) {
#line 44
          goto while_break;
        }
#line 45
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 44
        m = n;
#line 44
        n = r;
      }
      while_break: /* CIL Label */ ;
      }
#line 48
      q = a / n;
#line 49
      lcm = q * b;
#line 50
      if (lcm <= lcm_max) {
#line 50
        if (lcm / b == q) {
#line 51
          return (lcm);
        }
      }
    }
#line 54
    size = a;
  }
#line 57
  if (size <= lcm_max) {
#line 57
    tmp = size;
  } else {
#line 57
    tmp = lcm_max;
  }
#line 57
  return (tmp);
}
}
#line 61 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/basename.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 34
  base = name + 0;
#line 36
  saw_slash = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((int const   )*base == 47)) {
#line 38
      goto while_break;
    }
#line 39
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  p = base;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! *p) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int const   )*p == 47) {
#line 44
      saw_slash = (_Bool)1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base = p;
#line 48
      saw_slash = (_Bool)0;
    }
#line 41
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  return ((char *)base);
}
}
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 76
  tmp = last_component(name);
#line 76
  base = (char const   *)tmp;
  }
#line 81
  if (! *base) {
    {
#line 82
    tmp___0 = base_len(name);
#line 82
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 82
    return (tmp___1);
  }
  {
#line 85
  length = base_len(base);
  }
#line 86
  if ((int const   )*(base + length) == 47) {
#line 87
    length ++;
  }
  {
#line 103
  tmp___3 = xstrndup(base, length);
  }
#line 103
  return (tmp___3);
}
}
#line 110 "/home/khheo/project/benchmark/coreutils-7.1/lib/basename.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 114
  prefix_len = (size_t )0;
#line 116
  len = strlen(name);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (1UL < len) {
#line 116
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 116
        goto while_break;
      }
    } else {
#line 116
      goto while_break;
    }
#line 117
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 116
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (len);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.h"
_Bool isbase64(char ch ) ;
#line 40
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
#line 43
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
#line 45
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
#line 47
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) ;
#line 51
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 61
  return ((unsigned char )ch);
}
}
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
static char const   b64str[64]  = 
#line 72
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ 
  char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict  tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict  tmp___9 ;
  unsigned char tmp___10 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (inlen) {
#line 75
      if (! outlen) {
#line 75
        goto while_break;
      }
    } else {
#line 75
      goto while_break;
    }
    {
#line 77
    tmp = out;
#line 77
    out ++;
#line 77
    tmp___0 = to_uchar((char )*(in + 0));
#line 77
    *tmp = (char )b64str[((int )tmp___0 >> 2) & 63];
#line 78
    outlen --;
    }
#line 78
    if (! outlen) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp___1 = out;
#line 80
    out ++;
#line 80
    tmp___2 = to_uchar((char )*(in + 0));
#line 80
    inlen --;
    }
#line 80
    if (inlen) {
      {
#line 80
      tmp___3 = to_uchar((char )*(in + 1));
#line 80
      tmp___4 = (int )tmp___3 >> 4;
      }
    } else {
#line 80
      tmp___4 = 0;
    }
#line 80
    *tmp___1 = (char )b64str[(((int )tmp___2 << 4) + tmp___4) & 63];
#line 83
    outlen --;
#line 83
    if (! outlen) {
#line 84
      goto while_break;
    }
#line 85
    tmp___5 = out;
#line 85
    out ++;
#line 85
    if (inlen) {
      {
#line 85
      tmp___6 = to_uchar((char )*(in + 1));
#line 85
      inlen --;
      }
#line 85
      if (inlen) {
        {
#line 85
        tmp___7 = to_uchar((char )*(in + 2));
#line 85
        tmp___8 = (int )tmp___7 >> 6;
        }
      } else {
#line 85
        tmp___8 = 0;
      }
#line 85
      *tmp___5 = (char )b64str[(((int )tmp___6 << 2) + tmp___8) & 63];
    } else {
#line 85
      *tmp___5 = (char )'=';
    }
#line 91
    outlen --;
#line 91
    if (! outlen) {
#line 92
      goto while_break;
    }
#line 93
    tmp___9 = out;
#line 93
    out ++;
#line 93
    if (inlen) {
      {
#line 93
      tmp___10 = to_uchar((char )*(in + 2));
#line 93
      *tmp___9 = (char )b64str[(int )tmp___10 & 63];
      }
    } else {
#line 93
      *tmp___9 = (char )'=';
    }
#line 94
    outlen --;
#line 94
    if (! outlen) {
#line 95
      goto while_break;
    }
#line 96
    if (inlen) {
#line 97
      inlen --;
    }
#line 98
    if (inlen) {
#line 99
      in += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (outlen) {
#line 103
    *out = (char )'\000';
  }
#line 104
  return;
}
}
#line 115 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ 
  size_t outlen ;
  void *tmp ;

  {
#line 118
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
#line 132
  if (inlen > outlen) {
#line 134
    *out = (char *)((void *)0);
#line 135
    return ((size_t )0);
  }
  {
#line 138
  tmp = malloc(outlen);
#line 138
  *out = (char *)tmp;
  }
#line 139
  if (! *out) {
#line 140
    return (outlen);
  }
  {
#line 142
  base64_encode((char const   */* __restrict  */)in, inlen, (char */* __restrict  */)*out,
                outlen);
  }
#line 144
  return (outlen - 1UL);
}
}
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
static signed char const   b64[256]  = 
#line 223
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 299 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
_Bool isbase64(char ch ) 
{ 
  unsigned char tmp ;

  {
  {
#line 302
  tmp = to_uchar(ch);
  }
#line 302
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
#line 306 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 


  {
#line 309
  ctx->i = 0U;
#line 310
  return;
}
}
#line 319 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
__inline static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                            char const   * __restrict  in_end , size_t *n_non_newline ) 
{ 
  char const   *t ;
  void *tmp ;
  char const   *p ;
  char c ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 324
  if (ctx->i == 4U) {
#line 325
    ctx->i = 0U;
  }
#line 327
  if (ctx->i == 0U) {
#line 329
    t = (char const   *)*in;
#line 330
    if (4L <= in_end - *in) {
      {
#line 330
      tmp = memchr((void const   *)t, '\n', (size_t )4);
      }
#line 330
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 333
        *in += 4;
#line 334
        *n_non_newline = (size_t )4;
#line 335
        return ((char *)t);
      }
    }
  }
#line 341
  p = (char const   *)*in;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! ((unsigned long )p < (unsigned long )in_end)) {
#line 342
      goto while_break;
    }
#line 344
    tmp___0 = p;
#line 344
    p ++;
#line 344
    c = (char )*tmp___0;
#line 345
    if ((int )c != 10) {
#line 347
      tmp___1 = ctx->i;
#line 347
      (ctx->i) ++;
#line 347
      ctx->buf[tmp___1] = c;
#line 348
      if (ctx->i == 4U) {
#line 349
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  *in = (char const   */* __restrict  */)p;
#line 354
  *n_non_newline = (size_t )ctx->i;
#line 355
  return (ctx->buf);
}
}
#line 373 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
__inline static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                               size_t *outleft ) 
{ 
  char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 377
  out = (char *)*outp;
#line 378
  if (inlen < 2UL) {
#line 379
    return ((_Bool)0);
  }
  {
#line 381
  tmp = isbase64((char )*(in + 0));
  }
#line 381
  if (tmp) {
    {
#line 381
    tmp___0 = isbase64((char )*(in + 1));
    }
#line 381
    if (! tmp___0) {
#line 382
      return ((_Bool)0);
    }
  } else {
#line 382
    return ((_Bool)0);
  }
#line 384
  if (*outleft) {
    {
#line 386
    tmp___1 = out;
#line 386
    out ++;
#line 386
    tmp___2 = to_uchar((char )*(in + 0));
#line 386
    tmp___3 = to_uchar((char )*(in + 1));
#line 386
    *tmp___1 = (char )(((int const   )b64[tmp___2] << 2) | ((int const   )b64[tmp___3] >> 4));
#line 388
    (*outleft) --;
    }
  }
#line 391
  if (inlen == 2UL) {
    {
#line 392
    while (1) {
      while_continue: /* CIL Label */ ;
#line 392
      *outp = (char */* __restrict  */)out;
#line 392
      return ((_Bool)0);
#line 392
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 394
  if ((int const   )*(in + 2) == 61) {
#line 396
    if (inlen != 4UL) {
      {
#line 397
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 397
        *outp = (char */* __restrict  */)out;
#line 397
        return ((_Bool)0);
#line 397
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 399
    if ((int const   )*(in + 3) != 61) {
      {
#line 400
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 400
        *outp = (char */* __restrict  */)out;
#line 400
        return ((_Bool)0);
#line 400
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 404
    tmp___4 = isbase64((char )*(in + 2));
    }
#line 404
    if (! tmp___4) {
      {
#line 405
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 405
        *outp = (char */* __restrict  */)out;
#line 405
        return ((_Bool)0);
#line 405
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 407
    if (*outleft) {
      {
#line 409
      tmp___5 = out;
#line 409
      out ++;
#line 409
      tmp___6 = to_uchar((char )*(in + 1));
#line 409
      tmp___7 = to_uchar((char )*(in + 2));
#line 409
      *tmp___5 = (char )((((int const   )b64[tmp___6] << 4) & 240) | ((int const   )b64[tmp___7] >> 2));
#line 411
      (*outleft) --;
      }
    }
#line 414
    if (inlen == 3UL) {
      {
#line 415
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 415
        *outp = (char */* __restrict  */)out;
#line 415
        return ((_Bool)0);
#line 415
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 417
    if ((int const   )*(in + 3) == 61) {
#line 419
      if (inlen != 4UL) {
        {
#line 420
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 420
          *outp = (char */* __restrict  */)out;
#line 420
          return ((_Bool)0);
#line 420
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 424
      tmp___8 = isbase64((char )*(in + 3));
      }
#line 424
      if (! tmp___8) {
        {
#line 425
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 425
          *outp = (char */* __restrict  */)out;
#line 425
          return ((_Bool)0);
#line 425
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 427
      if (*outleft) {
        {
#line 429
        tmp___9 = out;
#line 429
        out ++;
#line 429
        tmp___10 = to_uchar((char )*(in + 2));
#line 429
        tmp___11 = to_uchar((char )*(in + 3));
#line 429
        *tmp___9 = (char )((((int const   )b64[tmp___10] << 6) & 192) | (int const   )b64[tmp___11]);
#line 431
        (*outleft) --;
        }
      }
    }
  }
#line 436
  *outp = (char */* __restrict  */)out;
#line 437
  return ((_Bool)1);
}
}
#line 458 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) 
{ 
  size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 463
  outleft = *outlen;
#line 464
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
#line 465
  flush_ctx = (_Bool)0;
#line 466
  ctx_i = 0U;
#line 468
  if (ignore_newlines) {
#line 470
    ctx_i = ctx->i;
#line 471
    flush_ctx = (_Bool )(inlen == 0UL);
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    outleft_save = outleft;
#line 478
    if (ctx_i == 0U) {
#line 478
      if (! flush_ctx) {
        {
#line 480
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 484
          outleft_save = outleft;
#line 485
          tmp = decode_4(in, inlen, & out, & outleft);
          }
#line 485
          if (! tmp) {
#line 486
            goto while_break___0;
          }
#line 488
          in += 4;
#line 489
          inlen -= 4UL;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 493
    if (inlen == 0UL) {
#line 493
      if (! flush_ctx) {
#line 494
        goto while_break;
      }
    }
#line 498
    if (inlen) {
#line 498
      if ((int const   )*in == 10) {
#line 498
        if (ignore_newlines) {
#line 500
          in ++;
#line 501
          inlen --;
#line 502
          goto while_continue;
        }
      }
    }
#line 506
    out -= outleft_save - outleft;
#line 507
    outleft = outleft_save;
#line 510
    in_end = (char const   *)(in + inlen);
#line 513
    if (ignore_newlines) {
      {
#line 514
      tmp___0 = get_4(ctx, & in, (char const   */* __restrict  */)in_end, & inlen);
#line 514
      non_nl = (char const   *)tmp___0;
      }
    } else {
#line 516
      non_nl = (char const   *)in;
    }
#line 521
    if (inlen == 0UL) {
#line 523
      inlen = (size_t )0;
#line 524
      goto while_break;
    } else
#line 521
    if (inlen < 4UL) {
#line 521
      if (! flush_ctx) {
#line 521
        if (ignore_newlines) {
#line 523
          inlen = (size_t )0;
#line 524
          goto while_break;
        }
      }
    }
    {
#line 526
    tmp___1 = decode_4((char const   */* __restrict  */)non_nl, inlen, & out, & outleft);
    }
#line 526
    if (! tmp___1) {
#line 527
      goto while_break;
    }
#line 529
    inlen = (size_t )(in_end - (char const   *)in);
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  *outlen -= outleft;
#line 535
  return ((_Bool )(inlen == 0UL));
}
}
#line 549 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) 
{ 
  size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 559
  needlen = 3UL * (inlen / 4UL) + 2UL;
#line 561
  tmp = malloc(needlen);
#line 561
  *out = (char *)tmp;
  }
#line 562
  if (! *out) {
#line 563
    return ((_Bool)1);
  }
  {
#line 565
  tmp___0 = base64_decode_ctx(ctx, (char const   */* __restrict  */)in, inlen, (char */* __restrict  */)*out,
                              & needlen);
  }
#line 565
  if (! tmp___0) {
    {
#line 567
    free((void *)*out);
#line 568
    *out = (char *)((void *)0);
    }
#line 569
    return ((_Bool)0);
  }
#line 572
  if (outlen) {
#line 573
    *outlen = needlen;
  }
#line 575
  return ((_Bool)1);
}
}
#line 47 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.h"
void (*argmatch_die)(void) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 131 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 134
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 134
    tmp = -1;
  } else {
#line 134
    tmp = -2;
  }
#line 134
  if ((size_t )tmp / s < n) {
    {
#line 135
    xalloc_die();
    }
  }
  {
#line 136
  tmp___0 = xrealloc(p, n * s);
  }
#line 136
  return (tmp___0);
}
}
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 90 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 98 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
  {
#line 101
  tmp = last_component((char const   *)file);
#line 101
  base = tmp;
#line 102
  tmp___0 = base_len((char const   *)base);
#line 102
  baselen = tmp___0;
#line 103
  baselen_max = (size_t )255;
  }
#line 105
  if (14UL < baselen) {
    {
#line 113
    memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
           sizeof("."));
#line 114
    strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 115
    tmp___2 = __errno_location();
#line 115
    *tmp___2 = 0;
#line 116
    name_max = pathconf((char const   *)file, 3);
    }
#line 117
    if (0L <= name_max) {
#line 117
      goto _L;
    } else {
      {
#line 117
      tmp___3 = __errno_location();
      }
#line 117
      if (*tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 119
        baselen_max = (size_t )name_max;
#line 119
        size = (long )baselen_max;
#line 120
        if (name_max != size) {
#line 121
          baselen_max = (size_t )-1;
        }
      }
    }
    {
#line 123
    memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
           sizeof("."));
    }
  }
#line 141
  if (baselen_max < baselen) {
#line 143
    baselen = (size_t )((file + filelen) - base);
#line 144
    if (baselen_max <= baselen) {
#line 145
      baselen = baselen_max - 1UL;
    }
#line 146
    *(base + baselen) = e;
#line 147
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 149
  return;
}
}
#line 178 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___1 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 181
  result = (enum numbered_backup_result )2;
#line 184
  buf___1 = *buffer;
#line 185
  versionlenmax = (size_t )1;
#line 186
  tmp = last_component((char const   *)buf___1);
#line 186
  base = tmp;
#line 187
  base_offset = (size_t )(base - buf___1);
#line 188
  tmp___0 = base_len((char const   *)base);
#line 188
  baselen = tmp___0;
#line 193
  memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
         sizeof("."));
#line 194
  strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 195
  dirp = opendir((char const   *)buf___1);
#line 196
  memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
         sizeof("."));
#line 197
  strcpy((char */* __restrict  */)(base + baselen), (char const   */* __restrict  */)".~1~");
  }
#line 199
  if (! dirp) {
#line 200
    return (result);
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    dp = readdir(dirp);
    }
#line 202
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 202
      goto while_break;
    }
#line 210
    if (! (dp->d_ino != 0UL)) {
#line 211
      goto while_continue;
    } else {
      {
#line 210
      tmp___2 = strlen((char const   *)(dp->d_name));
      }
#line 210
      if (tmp___2 < baselen + 4UL) {
#line 211
        goto while_continue;
      }
    }
    {
#line 213
    tmp___3 = memcmp((void const   *)(buf___1 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
    }
#line 213
    if (tmp___3 != 0) {
#line 214
      goto while_continue;
    }
#line 216
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 222
    if (49 <= (int )*p) {
#line 222
      if (! ((int const   )*p <= 57)) {
#line 223
        goto while_continue;
      }
    } else {
#line 223
      goto while_continue;
    }
#line 224
    all_9s = (_Bool )((int const   )*p == 57);
#line 225
    versionlen = (size_t )1;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! ((unsigned int )*(p + versionlen) - 48U <= 9U)) {
#line 225
        goto while_break___0;
      }
#line 226
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 225
      versionlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 228
    if ((int const   )*(p + versionlen) == 126) {
#line 228
      if (! *(p + (versionlen + 1UL))) {
#line 228
        if (! (versionlenmax < versionlen)) {
#line 228
          if (versionlenmax == versionlen) {
            {
#line 228
            tmp___4 = memcmp((void const   *)((buf___1 + filelen) + 2), (void const   *)p,
                             versionlen);
            }
#line 228
            if (! (tmp___4 <= 0)) {
#line 232
              goto while_continue;
            }
          } else {
#line 232
            goto while_continue;
          }
        }
      } else {
#line 232
        goto while_continue;
      }
    } else {
#line 232
      goto while_continue;
    }
#line 238
    versionlenmax = (size_t )all_9s + versionlen;
#line 239
    if (all_9s) {
#line 239
      result = (enum numbered_backup_result )1;
    } else {
#line 239
      result = (enum numbered_backup_result )0;
    }
#line 240
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 241
    if (buffer_size <= new_buflen) {
      {
#line 243
      tmp___5 = xnrealloc((void *)buf___1, (size_t )2, new_buflen);
#line 243
      buf___1 = (char *)tmp___5;
#line 244
      buffer_size = new_buflen * 2UL;
      }
    }
    {
#line 246
    q = buf___1 + filelen;
#line 247
    tmp___6 = q;
#line 247
    q ++;
#line 247
    *tmp___6 = (char )'.';
#line 248
    tmp___7 = q;
#line 248
    q ++;
#line 248
    *tmp___7 = (char )'~';
#line 249
    *q = (char )'0';
#line 250
    q += (int )all_9s;
#line 251
    memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, versionlen + 2UL);
#line 255
    q += versionlen;
    }
    {
#line 256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 256
      q --;
#line 256
      if (! ((int )*q == 57)) {
#line 256
        goto while_break___1;
      }
#line 257
      *q = (char )'0';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 258
    *q = (char )((int )*q + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  closedir(dirp);
#line 262
  *buffer = buf___1;
  }
#line 263
  return (result);
}
}
#line 270 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ 
  size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
  {
#line 273
  tmp = strlen(file);
#line 273
  filelen = tmp;
#line 276
  simple = (_Bool)1;
#line 280
  tmp___0 = strlen(simple_backup_suffix);
#line 280
  simple_backup_suffix_size = tmp___0 + 1UL;
#line 281
  backup_suffix_size_guess = simple_backup_suffix_size;
  }
#line 283
  if (backup_suffix_size_guess < 9UL) {
#line 284
    backup_suffix_size_guess = (size_t )9;
  }
  {
#line 286
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 287
  tmp___1 = xmalloc(ssize);
#line 287
  s = (char *)tmp___1;
#line 288
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)file, filelen + 1UL);
  }
#line 290
  if ((unsigned int )backup_type != 1U) {
    {
#line 291
    tmp___2 = numbered_backup(& s, ssize, filelen);
    }
    {
#line 293
    if ((unsigned int )tmp___2 == 0U) {
#line 293
      goto case_0;
    }
#line 296
    if ((unsigned int )tmp___2 == 1U) {
#line 296
      goto case_1;
    }
#line 300
    if ((unsigned int )tmp___2 == 2U) {
#line 300
      goto case_2;
    }
#line 291
    goto switch_break;
    case_0: /* CIL Label */ 
#line 294
    return (s);
    case_1: /* CIL Label */ 
#line 297
    simple = (_Bool)0;
#line 298
    goto switch_break;
    case_2: /* CIL Label */ 
#line 301
    simple = (_Bool )((unsigned int )backup_type == 2U);
#line 302
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 305
  if (simple) {
    {
#line 306
    memcpy((void */* __restrict  */)(s + filelen), (void const   */* __restrict  */)simple_backup_suffix,
           simple_backup_suffix_size);
    }
  }
  {
#line 307
  check_extension(s, filelen, (char )'~');
  }
#line 308
  return (s);
}
}
#line 311 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static char const   * const  backup_args[9]  = 
#line 311
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)((void *)0)};
#line 322 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 322
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 339 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ 
  ptrdiff_t tmp ;

  {
#line 342
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 343
    return ((enum backup_type )2);
  } else
#line 342
  if ((int const   )*version == 0) {
#line 343
    return ((enum backup_type )2);
  } else {
    {
#line 345
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
    }
#line 345
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 355 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
#line 358
  if (version) {
#line 358
    if (*version) {
      {
#line 359
      tmp = get_version(context, version);
      }
#line 359
      return (tmp);
    } else {
      {
#line 361
      tmp___0 = getenv("VERSION_CONTROL");
#line 361
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      }
#line 361
      return (tmp___1);
    }
  } else {
    {
#line 361
    tmp___0 = getenv("VERSION_CONTROL");
#line 361
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    }
#line 361
    return (tmp___1);
  }
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 289 "./stdio.h"
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...) ;
#line 291
int ( /* format attribute */  rpl_vasprintf)(char **resultp , char const   *format ,
                                             va_list args ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/asprintf.c"
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...) 
{ 
  va_list args ;
  int result ;

  {
  {
#line 35
  __builtin_va_start(args, format);
#line 36
  result = rpl_vasprintf(resultp, format, args);
#line 37
  __builtin_va_end(args);
  }
#line 38
  return (result);
}
}
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 74
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 31
  __builtin_va_start(args, format);
#line 32
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 33
  __builtin_va_end(args);
  }
#line 34
  return (result);
}
}
#line 606 "/usr/include/stdio.h"
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.h"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) ;
#line 40
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) ;
#line 42
char *( __attribute__((__nonnull__(1))) argv_iter)(struct argv_iterator *ai , enum argv_iter_err *err ) ;
#line 44
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator  const  *ai ) ;
#line 46
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) ;
#line 39 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) 
{ 
  struct argv_iterator *ai ;
  void *tmp ;

  {
  {
#line 42
  tmp = malloc(sizeof(*ai));
#line 42
  ai = (struct argv_iterator *)tmp;
  }
#line 43
  if (! ai) {
#line 44
    return ((struct argv_iterator *)((void *)0));
  }
#line 45
  ai->fp = (FILE *)((void *)0);
#line 46
  ai->arg_list = argv;
#line 47
  ai->p = argv;
#line 48
  return (ai);
}
}
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) 
{ 
  struct argv_iterator *ai ;
  void *tmp ;

  {
  {
#line 56
  tmp = malloc(sizeof(*ai));
#line 56
  ai = (struct argv_iterator *)tmp;
  }
#line 57
  if (! ai) {
#line 58
    return ((struct argv_iterator *)((void *)0));
  }
#line 59
  ai->fp = fp;
#line 60
  ai->tok = (char *)((void *)0);
#line 61
  ai->buf_len = (size_t )0;
#line 63
  ai->item_idx = (size_t )0;
#line 64
  ai->arg_list = (char **)((void *)0);
#line 65
  return (ai);
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
char *( __attribute__((__nonnull__(1))) argv_iter)(struct argv_iterator *ai , enum argv_iter_err *err ) 
{ 
  ssize_t len ;
  __ssize_t tmp ;
  int tmp___1 ;
  char **tmp___2 ;

  {
#line 71
  if (ai->fp) {
    {
#line 73
    tmp = getdelim((char **/* __restrict  */)(& ai->tok), (size_t */* __restrict  */)(& ai->buf_len),
                   '\000', (FILE */* __restrict  */)ai->fp);
#line 73
    len = tmp;
    }
#line 74
    if (len < 0L) {
      {
#line 76
      tmp___1 = feof(ai->fp);
      }
#line 76
      if (tmp___1) {
#line 76
        *err = (enum argv_iter_err )2;
      } else {
#line 76
        *err = (enum argv_iter_err )4;
      }
#line 77
      return ((char *)((void *)0));
    }
#line 80
    *err = (enum argv_iter_err )1;
#line 81
    (ai->item_idx) ++;
#line 82
    return (ai->tok);
  } else
#line 86
  if ((unsigned long )*(ai->p) == (unsigned long )((void *)0)) {
#line 88
    *err = (enum argv_iter_err )2;
#line 89
    return ((char *)((void *)0));
  } else {
#line 93
    *err = (enum argv_iter_err )1;
#line 94
    tmp___2 = ai->p;
#line 94
    (ai->p) ++;
#line 94
    return (*tmp___2);
  }
}
}
#line 99 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator  const  *ai ) 
{ 
  size_t tmp ;

  {
#line 102
  if (ai->fp) {
#line 102
    tmp = ai->item_idx;
  } else {
#line 102
    tmp = (size_t const   )(ai->p - ai->arg_list);
  }
#line 102
  return ((size_t )tmp);
}
}
#line 105 "/home/khheo/project/benchmark/coreutils-7.1/lib/argv-iter.c"
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) 
{ 


  {
#line 108
  if (ai->fp) {
    {
#line 109
    free((void *)ai->tok);
    }
  }
  {
#line 110
  free((void *)ai);
  }
#line 111
  return;
}
}
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.h"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 275 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
void usage(int status ) ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0UL) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
              *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___0) {
        {
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
                *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", `%s\'",
                *(arglist + i));
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  putc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 811 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/areadlink-with-size.c"
char *areadlink_with_size(char const   *file , size_t size ) 
{ 
  size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 61
  symlink_max = (size_t )1024;
#line 62
  INITIAL_LIMIT_BOUND = (size_t )8192;
#line 63
  if (symlink_max < INITIAL_LIMIT_BOUND) {
#line 63
    tmp = symlink_max + 1UL;
  } else {
#line 63
    tmp = INITIAL_LIMIT_BOUND;
  }
#line 63
  initial_limit = tmp;
#line 68
  if (size < initial_limit) {
#line 68
    tmp___0 = size + 1UL;
  } else {
#line 68
    tmp___0 = initial_limit;
  }
#line 68
  buf_size = tmp___0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp___1 = malloc(buf_size);
#line 74
    buffer = (char *)tmp___1;
    }
#line 76
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 77
      return ((char *)((void *)0));
    }
    {
#line 78
    r = readlink((char const   */* __restrict  */)file, (char */* __restrict  */)buffer,
                 buf_size);
#line 79
    link_length = (size_t )r;
    }
#line 83
    if (r < 0L) {
      {
#line 83
      tmp___4 = __errno_location();
      }
#line 83
      if (*tmp___4 != 34) {
        {
#line 85
        tmp___2 = __errno_location();
#line 85
        saved_errno = *tmp___2;
#line 86
        free((void *)buffer);
#line 87
        tmp___3 = __errno_location();
#line 87
        *tmp___3 = saved_errno;
        }
#line 88
        return ((char *)((void *)0));
      }
    }
#line 91
    if (link_length < buf_size) {
#line 93
      *(buffer + link_length) = (char)0;
#line 94
      return (buffer);
    }
    {
#line 97
    free((void *)buffer);
    }
#line 98
    if (buf_size <= 4611686018427387903UL) {
#line 99
      buf_size *= 2UL;
    } else
#line 100
    if (buf_size < 9223372036854775807UL) {
#line 101
      buf_size = (size_t )9223372036854775807L;
    } else {
      {
#line 104
      tmp___5 = __errno_location();
#line 104
      *tmp___5 = 12;
      }
#line 105
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/yesno.h"
_Bool yesno(void) ;
#line 943 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *__response ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/yesno.c"
_Bool yesno(void) 
{ 
  _Bool yes ;
  char *response ;
  size_t response_size ;
  ssize_t response_len ;
  __ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 37
  response = (char *)((void *)0);
#line 38
  response_size = (size_t )0;
#line 39
  tmp = getline((char **/* __restrict  */)(& response), (size_t */* __restrict  */)(& response_size),
                (FILE */* __restrict  */)stdin);
#line 39
  response_len = tmp;
  }
#line 41
  if (response_len <= 0L) {
#line 42
    yes = (_Bool)0;
  } else {
    {
#line 45
    *(response + (response_len - 1L)) = (char )'\000';
#line 46
    tmp___0 = rpmatch((char const   *)response);
#line 46
    yes = (_Bool )(0 < tmp___0);
    }
  }
  {
#line 49
  free((void *)response);
  }
#line 59
  return (yes);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/xvasprintf.h"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 123
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 123
    tmp = -1;
  } else {
#line 123
    tmp = -2;
  }
#line 123
  if ((size_t )tmp / s < n) {
    {
#line 124
    xalloc_die();
    }
  }
  {
#line 125
  tmp___0 = xmalloc(n * s);
  }
#line 125
  return (tmp___0);
}
}
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 58
  sum = size1 + size2;
#line 59
  if (sum >= size1) {
#line 59
    tmp = sum;
  } else {
#line 59
    tmp = 0xffffffffffffffffUL;
  }
#line 59
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *next___0 ;
  char const   *tmp___8 ;
  size_t len ;
  size_t tmp___9 ;

  {
  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy(ap, args);
#line 44
  i = argcount;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i > 0UL)) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 46
    next = tmp___0;
#line 47
    tmp___1 = strlen(next);
#line 47
    tmp___2 = xsum(totalsize, tmp___1);
#line 47
    totalsize = (size_t )tmp___2;
#line 44
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  __builtin_va_end(ap);
  }
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
    {
#line 61
    tmp___4 = xmalloc(totalsize + 1UL);
#line 61
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 61
    tmp___5 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp___6 = tmp___5;
    }
  }
#line 61
  result = (char *)tmp___6;
#line 62
  p = result;
#line 63
  i = argcount;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (i > 0UL)) {
#line 63
      goto while_break___0;
    }
    {
#line 65
    tmp___8 = __builtin_va_arg(args, char const   *);
#line 65
    next___0 = tmp___8;
#line 66
    tmp___9 = strlen(next___0);
#line 66
    len = tmp___9;
#line 67
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)next___0,
           len);
#line 68
    p += len;
#line 63
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 75 "/home/khheo/project/benchmark/coreutils-7.1/lib/xvasprintf.c"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if ((int const   )*f == 0) {
      {
#line 91
      tmp = xstrcat(argcount, args);
      }
#line 91
      return (tmp);
    }
#line 92
    if ((int const   )*f != 37) {
#line 93
      goto while_break;
    }
#line 94
    f ++;
#line 95
    if ((int const   )*f != 115) {
#line 96
      goto while_break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  tmp___1 = rpl_vasprintf(& result, format, args);
  }
#line 102
  if (tmp___1 < 0) {
    {
#line 104
    tmp___0 = __errno_location();
    }
#line 104
    if (*tmp___0 == 12) {
      {
#line 105
      xalloc_die();
      }
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 301 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__leaf__)) strtoumax)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ,
                                                                                      int __base ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale(uintmax_t *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (uintmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(uintmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                    83U, "xstrtoumax");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                  83U, "xstrtoumax");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___1 = __ctype_b_loc();
    }
#line 91
    if (! ((int const   )*(*tmp___1 + (int )ch) & 8192)) {
#line 91
      goto while_break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
  {
#line 97
  tmp___2 = __errno_location();
#line 97
  *tmp___2 = 0;
#line 98
  tmp = strtoumax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___3) {
#line 105
          tmp = (uintmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___5 = __errno_location();
    }
#line 109
    if (*tmp___5 != 0) {
      {
#line 111
      tmp___4 = __errno_location();
      }
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___6) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___7) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___0(unsigned long *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___0(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                    83U, "xstrtoul");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                  83U, "xstrtoul");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___1 = __ctype_b_loc();
    }
#line 91
    if (! ((int const   )*(*tmp___1 + (int )ch) & 8192)) {
#line 91
      goto while_break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
  {
#line 97
  tmp___2 = __errno_location();
#line 97
  *tmp___2 = 0;
#line 98
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___3) {
#line 105
          tmp = 1UL;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___5 = __errno_location();
    }
#line 109
    if (*tmp___5 != 0) {
      {
#line 111
      tmp___4 = __errno_location();
      }
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___6) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___7) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtod.h"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtod.c"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) 
{ 
  long double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
  }
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 62
  if (val != (long double )0) {
    {
#line 62
    tmp___0 = __errno_location();
    }
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___1(long *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___1(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                    83U, "xstrtol");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                  83U, "xstrtol");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
  {
#line 97
  tmp___2 = __errno_location();
#line 97
  *tmp___2 = 0;
#line 98
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___3) {
#line 105
          tmp = 1L;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___5 = __errno_location();
    }
#line 109
    if (*tmp___5 != 0) {
      {
#line 111
      tmp___4 = __errno_location();
      }
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___6) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___7) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.h"
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct option  const  *long_options___2 ,
                                                  char const   *arg ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___2 ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___2 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 91
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct option  const  *long_options___2 ,
                                                  char const   *arg ) ;
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___2 ,
                   char const   *arg ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___2, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___2(intmax_t *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (intmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___2(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                    83U, "xstrtoimax");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c",
                  83U, "xstrtoimax");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
  {
#line 97
  tmp___2 = __errno_location();
#line 97
  *tmp___2 = 0;
#line 98
  tmp = strtoimax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___3) {
#line 105
          tmp = (intmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___5 = __errno_location();
    }
#line 109
    if (*tmp___5 != 0) {
      {
#line 111
      tmp___4 = __errno_location();
      }
#line 111
      if (*tmp___4 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___6) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___7) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale___2(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale___2(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale___2(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtod.h"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtod.c"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) 
{ 
  double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
  }
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 62
  if (val != (double )0) {
    {
#line 62
    tmp___0 = __errno_location();
    }
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 174 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 56
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 67
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 122 "./stdio.h"
int ( /* format attribute */  rpl_vfprintf)(FILE *fp , char const   *format , va_list args ) ;
#line 169
int ( /* format attribute */  rpl_vprintf)(char const   *format , va_list args ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/xprintf.h"
int ( /* format attribute */  xprintf)(char const   * __restrict  format  , ...) ;
#line 38
int ( /* format attribute */  xvprintf)(char const   * __restrict  format , va_list args ) ;
#line 40
int ( /* format attribute */  xfprintf)(FILE * __restrict  stream , char const   * __restrict  format 
                                        , ...) ;
#line 42
int ( /* format attribute */  xvfprintf)(FILE * __restrict  stream , char const   * __restrict  format ,
                                         va_list args ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/xprintf.c"
int ( /* format attribute */  xprintf)(char const   * __restrict  format  , ...) 
{ 
  va_list args ;
  int retval ;

  {
  {
#line 36
  __builtin_va_start(args, format);
#line 37
  retval = xvprintf(format, args);
#line 38
  __builtin_va_end(args);
  }
#line 40
  return (retval);
}
}
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/xprintf.c"
int ( /* format attribute */  xvprintf)(char const   * __restrict  format , va_list args ) 
{ 
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 48
  tmp = rpl_vprintf((char const   *)format, args);
#line 48
  retval = tmp;
  }
#line 49
  if (retval < 0) {
    {
#line 49
    tmp___2 = ferror(stdout);
    }
#line 49
    if (! tmp___2) {
      {
#line 50
      tmp___0 = gettext("cannot perform formatted output");
#line 50
      tmp___1 = __errno_location();
#line 50
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
      }
    }
  }
#line 52
  return (retval);
}
}
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/xprintf.c"
int ( /* format attribute */  xfprintf)(FILE * __restrict  stream , char const   * __restrict  format 
                                        , ...) 
{ 
  va_list args ;
  int retval ;

  {
  {
#line 62
  __builtin_va_start(args, format);
#line 63
  retval = xvfprintf(stream, format, args);
#line 64
  __builtin_va_end(args);
  }
#line 66
  return (retval);
}
}
#line 71 "/home/khheo/project/benchmark/coreutils-7.1/lib/xprintf.c"
int ( /* format attribute */  xvfprintf)(FILE * __restrict  stream , char const   * __restrict  format ,
                                         va_list args ) 
{ 
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 74
  tmp = rpl_vfprintf((FILE *)stream, (char const   *)format, args);
#line 74
  retval = tmp;
  }
#line 75
  if (retval < 0) {
    {
#line 75
    tmp___2 = ferror((FILE *)stream);
    }
#line 75
    if (! tmp___2) {
      {
#line 76
      tmp___0 = gettext("cannot perform formatted output");
#line 76
      tmp___1 = __errno_location();
#line 76
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
      }
    }
  }
#line 78
  return (retval);
}
}
#line 1 "/home/khheo/project/benchmark/coreutils-7.1/lib/xnanosleep.h"
int xnanosleep(double seconds ) ;
#line 66 "./time.h"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) ;
#line 47 "/home/khheo/project/benchmark/coreutils-7.1/lib/xnanosleep.c"
int xnanosleep(double seconds ) 
{ 
  _Bool overflow ;
  int tmp ;
  int tmp___0 ;
  struct timespec ts_sleep ;
  time_t floor_seconds ;
  double ns ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 59
  if ((time_t )((double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) / (double )2) == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL)) / 2L) {
#line 59
    tmp___0 = (double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) < seconds;
  } else {
#line 59
    if ((time_t )((long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) / (long double )2) == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL)) / 2L) {
#line 59
      tmp = (long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) < (long double )seconds;
    } else {
#line 59
      tmp = (long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) <= (long double )seconds;
    }
#line 59
    tmp___0 = tmp;
  }
#line 59
  overflow = (_Bool )tmp___0;
#line 67
  if (! ((double )0 <= seconds)) {
    {
#line 67
    __assert_fail("0 <= seconds", "/home/khheo/project/benchmark/coreutils-7.1/lib/xnanosleep.c",
                  67U, "xnanosleep");
    }
  }
#line 70
  if (! overflow) {
#line 72
    floor_seconds = (time_t )seconds;
#line 73
    ns = (double )1000000000 * (seconds - (double )floor_seconds);
#line 74
    ts_sleep.tv_sec = floor_seconds;
#line 81
    ts_sleep.tv_nsec = (__syscall_slong_t )ns;
#line 82
    ts_sleep.tv_nsec += (__syscall_slong_t )((double )ts_sleep.tv_nsec < ns);
#line 85
    if (1000000000L <= ts_sleep.tv_nsec) {
#line 87
      if (ts_sleep.tv_sec == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) {
#line 88
        overflow = (_Bool)1;
      } else {
#line 91
        (ts_sleep.tv_sec) ++;
#line 92
        ts_sleep.tv_nsec -= 1000000000L;
      }
    }
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (overflow) {
#line 101
      ts_sleep.tv_sec = ~ (-1L << (sizeof(time_t ) * 8UL - 1UL));
#line 102
      ts_sleep.tv_nsec = (__syscall_slong_t )999999999;
    }
    {
#line 111
    tmp___2 = __errno_location();
#line 111
    *tmp___2 = 0;
#line 112
    tmp___3 = rpl_nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
    }
#line 112
    if (tmp___3 == 0) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp___4 = __errno_location();
    }
#line 114
    if (*tmp___4 != 4) {
      {
#line 114
      tmp___5 = __errno_location();
      }
#line 114
      if (*tmp___5 != 0) {
#line 115
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return (0);
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmemxfrm.h"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) ;
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/memxfrm.h"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) ;
#line 280 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmemxfrm.c"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) 
{ 
  size_t translated_size ;
  size_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 50
  tmp = memxfrm(dest, destsize, src, srcsize);
#line 50
  translated_size = tmp;
#line 52
  tmp___5 = __errno_location();
  }
#line 52
  if (*tmp___5) {
    {
#line 54
    tmp___0 = gettext("string transformation failed");
#line 54
    tmp___1 = __errno_location();
#line 54
    error(0, *tmp___1, (char const   *)tmp___0);
#line 55
    tmp___2 = gettext("set LC_ALL=\'C\' to work around the problem");
#line 55
    error(0, 0, (char const   *)tmp___2);
#line 56
    tmp___3 = quotearg_n_style_mem(0, (enum quoting_style )6, (char const   *)src,
                                   srcsize);
#line 56
    tmp___4 = gettext("the untransformed string was %s");
#line 56
    error((int )exit_failure, 0, (char const   *)tmp___4, tmp___3);
    }
  }
#line 61
  return (translated_size);
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/memcoll.h"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmemcoll.h"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmemcoll.c"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ 
  int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 43
  tmp = memcoll(s1, s1len, s2, s2len);
#line 43
  diff = tmp;
#line 44
  tmp___0 = __errno_location();
#line 44
  collation_errno = *tmp___0;
  }
#line 46
  if (collation_errno) {
    {
#line 48
    tmp___1 = gettext("string comparison failed");
#line 48
    error(0, collation_errno, (char const   *)tmp___1);
#line 49
    tmp___2 = gettext("Set LC_ALL=\'C\' to work around the problem.");
#line 49
    error(0, 0, (char const   *)tmp___2);
#line 50
    tmp___3 = quotearg_n_style_mem(1, (enum quoting_style )6, (char const   *)s2,
                                   s2len);
#line 50
    tmp___4 = quotearg_n_style_mem(0, (enum quoting_style )6, (char const   *)s1,
                                   s1len);
#line 50
    tmp___5 = gettext("The strings compared were %s and %s.");
#line 50
    error((int )exit_failure, 0, (char const   *)tmp___5, tmp___4, tmp___3);
    }
  }
#line 56
  return (diff);
}
}
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 49
  tmp = malloc(n);
#line 49
  p = tmp;
  }
#line 50
  if (! p) {
#line 50
    if (n != 0UL) {
      {
#line 51
      xalloc_die();
      }
    }
  }
#line 52
  return (p);
}
}
#line 58 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n != 0UL) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 83 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 92 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 110 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/coreutils-7.1/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 1 "/home/khheo/project/benchmark/coreutils-7.1/lib/xgethostname.h"
char *xgethostname(void) ;
#line 880 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/xgethostname.c"
char *xgethostname(void) 
{ 
  char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 46
  hostname = (char *)((void *)0);
#line 47
  size = (size_t )34;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    tmp = x2realloc((void *)hostname, & size);
#line 56
    hostname = (char *)tmp;
#line 57
    size_1 = size - 1UL;
#line 58
    *(hostname + (size_1 - 1UL)) = (char )'\000';
#line 59
    tmp___0 = __errno_location();
#line 59
    *tmp___0 = 0;
#line 61
    tmp___7 = gethostname(hostname, size_1);
    }
#line 61
    if (tmp___7 == 0) {
#line 63
      if (! *(hostname + (size_1 - 1UL))) {
#line 64
        goto while_break;
      }
    } else {
      {
#line 66
      tmp___3 = __errno_location();
      }
#line 66
      if (*tmp___3 != 0) {
        {
#line 66
        tmp___4 = __errno_location();
        }
#line 66
        if (*tmp___4 != 36) {
          {
#line 66
          tmp___5 = __errno_location();
          }
#line 66
          if (*tmp___5 != 22) {
            {
#line 66
            tmp___6 = __errno_location();
            }
#line 66
            if (*tmp___6 != 12) {
              {
#line 70
              tmp___1 = __errno_location();
#line 70
              saved_errno = *tmp___1;
#line 71
              free((void *)hostname);
#line 72
              tmp___2 = __errno_location();
#line 72
              *tmp___2 = saved_errno;
              }
#line 73
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (hostname);
}
}
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 36
  tmp = getcwd((char *)((void *)0), (size_t )0);
#line 36
  cwd = tmp;
  }
#line 37
  if (! cwd) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (cwd);
}
}
#line 3 "/home/khheo/project/benchmark/coreutils-7.1/lib/xfts.h"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/xfts.c"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) 
{ 
  FTS *fts ;
  FTS *tmp ;
  _Bool invalid_arg ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 40
  tmp = fts_open(argv, options | 512, compar);
#line 40
  fts = tmp;
  }
#line 41
  if ((unsigned long )fts == (unsigned long )((void *)0)) {
#line 50
    invalid_arg = (_Bool)0;
    {
#line 51
    while (1) {
      while_continue: /* CIL Label */ ;
#line 51
      if (! *argv) {
#line 51
        goto while_break;
      }
#line 53
      if ((int )*(*argv) == 0) {
#line 54
        invalid_arg = (_Bool)1;
      }
#line 51
      argv ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 56
    if (invalid_arg) {
      {
#line 57
      tmp___0 = quote("");
#line 57
      tmp___1 = gettext("invalid argument: %s");
#line 57
      error(1, 0, (char const   *)tmp___1, tmp___0);
      }
    } else {
      {
#line 59
      xalloc_die();
      }
    }
  }
#line 62
  return (fts);
}
}
#line 238 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/xfreopen.h"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/xfreopen.c"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) 
{ 
  char const   *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;

  {
  {
#line 31
  tmp___11 = freopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)mode,
                     (FILE */* __restrict  */)fp);
  }
#line 31
  if (! tmp___11) {
#line 33
    if (filename) {
#line 33
      tmp___6 = filename;
    } else {
#line 33
      if ((unsigned long )fp == (unsigned long )stdin) {
        {
#line 33
        tmp = gettext("stdin");
#line 33
        tmp___5 = tmp;
        }
      } else {
#line 33
        if ((unsigned long )fp == (unsigned long )stdout) {
          {
#line 33
          tmp___0 = gettext("stdout");
#line 33
          tmp___4 = tmp___0;
          }
        } else {
#line 33
          if ((unsigned long )fp == (unsigned long )stderr) {
            {
#line 33
            tmp___1 = gettext("stderr");
#line 33
            tmp___3 = tmp___1;
            }
          } else {
            {
#line 33
            tmp___2 = gettext("unknown stream");
#line 33
            tmp___3 = tmp___2;
            }
          }
#line 33
          tmp___4 = tmp___3;
        }
#line 33
        tmp___5 = tmp___4;
      }
#line 33
      tmp___6 = (char const   *)tmp___5;
    }
    {
#line 33
    f = tmp___6;
#line 38
    tmp___7 = quote_n(1, mode);
#line 38
    tmp___8 = quote_n(0, f);
#line 38
    tmp___9 = gettext("failed to reopen %s with mode %s");
#line 38
    tmp___10 = __errno_location();
#line 38
    error((int )exit_failure, *tmp___10, (char const   *)tmp___9, tmp___8, tmp___7);
    }
  }
#line 41
  return;
}
}
#line 47 "/home/khheo/project/benchmark/coreutils-7.1/lib/xvasprintf.h"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) ;
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/xasprintf.c"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 28
  __builtin_va_start(args, format);
#line 29
  result = xvasprintf(format, args);
#line 30
  __builtin_va_end(args);
  }
#line 32
  return (result);
}
}
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.h"
_Bool can_write_any_file(void) ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.c"
static _Bool initialized  ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.c"
static _Bool can_write  ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.c"
_Bool can_write_any_file(void) 
{ 
  _Bool can ;
  __uid_t tmp ;

  {
#line 38
  if (! initialized) {
    {
#line 40
    can = (_Bool)0;
#line 52
    tmp = geteuid();
#line 52
    can = (_Bool )(tmp == 0U);
#line 54
    can_write = can;
#line 55
    initialized = (_Bool)1;
    }
  }
#line 58
  return (can_write);
}
}
#line 39 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1664]  = 
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )255, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 271 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 271
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )25,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 305 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 309
  if (uc >> 9 < 240U) {
#line 311
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 312
    if (ind >= 0) {
#line 313
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 315
        if (uc > 0U) {
#line 315
          if (uc < 160U) {
#line 316
            return (-1);
          } else {
#line 318
            return (0);
          }
        } else {
#line 318
          return (0);
        }
      }
    }
  } else
#line 321
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 323
    if (uc >= 917760U) {
#line 325
      if (uc <= 917999U) {
#line 326
        return (0);
      }
    } else {
#line 330
      if (uc >= 917536U) {
#line 330
        tmp = uc <= 917631U;
      } else {
#line 330
        tmp = uc == 917505U;
      }
#line 330
      if (tmp) {
#line 331
        return (0);
      }
    }
  }
#line 338
  if (uc >= 4352U) {
#line 338
    if (uc < 4448U) {
#line 352
      return (2);
    } else
#line 338
    if (uc >= 9001U) {
#line 338
      if (uc < 9003U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 338
    if (uc >= 11904U) {
#line 338
      if (uc < 42192U) {
#line 338
        if (! (uc == 12351U)) {
#line 338
          if (uc >= 19904U) {
#line 338
            if (uc < 19968U) {
#line 338
              goto _L___8;
            } else {
#line 352
              return (2);
            }
          } else {
#line 352
            return (2);
          }
        } else {
#line 338
          goto _L___8;
        }
      } else {
#line 338
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 338
    if (uc >= 44032U) {
#line 338
      if (uc < 55204U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 338
    if (uc >= 63744U) {
#line 338
      if (uc < 64256U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 338
    if (uc >= 65040U) {
#line 338
      if (uc < 65056U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 338
    if (uc >= 65072U) {
#line 338
      if (uc < 65136U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 338
    if (uc >= 65280U) {
#line 338
      if (uc < 65377U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 338
    if (uc >= 65504U) {
#line 338
      if (uc < 65511U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 338
    if (uc >= 131072U) {
#line 338
      if (uc <= 173782U) {
#line 352
        return (2);
      } else {
#line 338
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 338
    if (uc >= 194560U) {
#line 338
      if (uc <= 195101U) {
#line 352
        return (2);
      }
    }
  }
#line 355
  if (uc >= 161U) {
#line 355
    if (uc < 65377U) {
#line 355
      if (uc != 8361U) {
        {
#line 355
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 355
        if (tmp___0) {
#line 357
          return (2);
        }
      }
    }
  }
#line 358
  return (1);
}
}
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/vprintf.c"
int ( /* format attribute */  rpl_vprintf)(char const   *format , va_list args ) 
{ 
  int tmp ;

  {
  {
#line 32
  tmp = rpl_vfprintf(stdout, format, args);
  }
#line 32
  return (tmp);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/vfprintf.c"
int ( /* format attribute */  rpl_vfprintf)(FILE *fp , char const   *format , va_list args ) 
{ 
  char buf___1[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 41
  lenbuf = sizeof(buf___1);
#line 43
  output = vasnprintf(buf___1, & lenbuf, format, args);
#line 44
  len = lenbuf;
  }
#line 46
  if (! output) {
    {
#line 48
    fseterr(fp);
    }
#line 49
    return (-1);
  }
  {
#line 52
  tmp___1 = fwrite((void const   */* __restrict  */)output, (size_t )1, len, (FILE */* __restrict  */)fp);
  }
#line 52
  if (tmp___1 < len) {
#line 54
    if ((unsigned long )output != (unsigned long )(buf___1)) {
      {
#line 56
      tmp = __errno_location();
#line 56
      saved_errno = *tmp;
#line 57
      free((void *)output);
#line 58
      tmp___0 = __errno_location();
#line 58
      *tmp___0 = saved_errno;
      }
    }
#line 60
    return (-1);
  }
#line 63
  if (len > 2147483647UL) {
    {
#line 65
    tmp___2 = __errno_location();
#line 65
    *tmp___2 = 75;
#line 66
    fseterr(fp);
    }
#line 67
    return (-1);
  }
#line 70
  return ((int )len);
}
}
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 31
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) ;
#line 36
void emit_bug_reporting_address(void) ;
#line 39 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  va_list tmp_authors ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 50
  __builtin_va_copy(tmp_authors, authors);
#line 52
  n_authors = (size_t )0;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    tmp___0 = __builtin_va_arg(tmp_authors, char const   *);
    }
#line 53
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 53
      goto while_break;
    }
#line 54
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  if (command_name) {
    {
#line 58
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 60
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 65
  tmp___1 = gettext("(C)");
#line 65
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp___1, 2009);
#line 67
  tmp___2 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 67
  fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stream);
  }
  {
#line 78
  if (n_authors == 0UL) {
#line 78
    goto case_0;
  }
#line 81
  if (n_authors == 1UL) {
#line 81
    goto case_1;
  }
#line 85
  if (n_authors == 2UL) {
#line 85
    goto case_2;
  }
#line 89
  if (n_authors == 3UL) {
#line 89
    goto case_3;
  }
#line 93
  if (n_authors == 4UL) {
#line 93
    goto case_4;
  }
#line 99
  if (n_authors == 5UL) {
#line 99
    goto case_5;
  }
#line 105
  if (n_authors == 6UL) {
#line 105
    goto case_6;
  }
#line 112
  if (n_authors == 7UL) {
#line 112
    goto case_7;
  }
#line 119
  if (n_authors == 8UL) {
#line 119
    goto case_8;
  }
#line 127
  if (n_authors == 9UL) {
#line 127
    goto case_9;
  }
#line 135
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 80
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 83
  tmp___3 = gettext("Written by %s.\n");
#line 83
  rpl_vfprintf(stream, (char const   *)tmp___3, authors);
  }
#line 84
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 87
  tmp___4 = gettext("Written by %s and %s.\n");
#line 87
  rpl_vfprintf(stream, (char const   *)tmp___4, authors);
  }
#line 88
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 91
  tmp___5 = gettext("Written by %s, %s, and %s.\n");
#line 91
  rpl_vfprintf(stream, (char const   *)tmp___5, authors);
  }
#line 92
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 97
  tmp___6 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 97
  rpl_vfprintf(stream, (char const   *)tmp___6, authors);
  }
#line 98
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 103
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 103
  rpl_vfprintf(stream, (char const   *)tmp___7, authors);
  }
#line 104
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 109
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 109
  rpl_vfprintf(stream, (char const   *)tmp___8, authors);
  }
#line 111
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 116
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 116
  rpl_vfprintf(stream, (char const   *)tmp___9, authors);
  }
#line 118
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 123
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 123
  rpl_vfprintf(stream, (char const   *)tmp___10, authors);
  }
#line 126
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 131
  tmp___11 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 131
  rpl_vfprintf(stream, (char const   *)tmp___11, authors);
  }
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 141
  tmp___12 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 141
  rpl_vfprintf(stream, (char const   *)tmp___12, authors);
  }
#line 144
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 146
  __builtin_va_end(authors);
  }
#line 147
  return;
}
}
#line 163 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 170
  __builtin_va_start(authors, version);
#line 171
  version_etc_va(stream, command_name, package, version, authors);
  }
#line 172
  return;
}
}
#line 174 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 181
  tmp = gettext("\nReport bugs to <%s>.\n");
#line 181
  printf((char const   */* __restrict  */)tmp, "bug-coreutils@gnu.org");
#line 182
  tmp___0 = gettext("%s home page: <http://www.gnu.org/software/%s/>.\n");
#line 182
  printf((char const   */* __restrict  */)tmp___0, "GNU coreutils", "coreutils");
#line 184
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>.\n");
#line 184
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 186
  return;
}
}
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/error.h"
extern void ( /* format attribute */  error_at_line)(int __status , int __errnum ,
                                                     char const   *__fname , unsigned int __lineno ,
                                                     char const   *__format  , ...) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/verror.h"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) ;
#line 44
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) ;
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/verror.c"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) 
{ 


  {
  {
#line 45
  verror_at_line(status, errnum, (char const   *)((void *)0), 0U, format, args);
  }
#line 46
  return;
}
}
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/verror.c"
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) 
{ 
  char *message ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 58
  tmp = xvasprintf(format, args);
#line 58
  message = tmp;
  }
#line 59
  if (message) {
#line 64
    if (file) {
      {
#line 65
      error_at_line(status, errnum, file, line_number, "%s", message);
      }
    } else {
      {
#line 67
      error(status, errnum, "%s", message);
      }
    }
  } else {
    {
#line 73
    tmp___0 = gettext("unable to display error message");
#line 73
    tmp___1 = __errno_location();
#line 73
    error(0, *tmp___1, (char const   *)tmp___0);
#line 74
    abort();
    }
  }
  {
#line 76
  free((void *)message);
  }
#line 77
  return;
}
}
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasprintf.c"
int ( /* format attribute */  rpl_vasprintf)(char **resultp , char const   *format ,
                                             va_list args ) 
{ 
  size_t length ;
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 37
  tmp = vasnprintf((char *)((void *)0), & length, format, args);
#line 37
  result = tmp;
  }
#line 38
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 39
    return (-1);
  }
#line 41
  if (length > 2147483647UL) {
    {
#line 43
    free((void *)result);
#line 44
    tmp___0 = __errno_location();
#line 44
    *tmp___0 = 75;
    }
#line 45
    return (-1);
  }
#line 48
  *resultp = result;
#line 50
  return ((int )length);
}
}
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 174 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 79
  tmp = xsum(size1, size2);
#line 79
  tmp___0 = xsum((size_t )tmp, size3);
#line 79
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 79
  return (tmp___1);
}
}
#line 83 "/home/khheo/project/benchmark/coreutils-7.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 91
  if (size1 >= size2) {
#line 91
    tmp = size1;
  } else {
#line 91
    tmp = size2;
  }
#line 91
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 222 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.c"
static char decimal_point_char(void) 
{ 
  char const   *point ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 231
  tmp = nl_langinfo(65536);
#line 231
  point = (char const   *)tmp;
  }
#line 240
  if ((int const   )*(point + 0) != 0) {
#line 240
    tmp___0 = (int const   )*(point + 0);
  } else {
#line 240
    tmp___0 = (int const   )'.';
  }
#line 240
  return ((char )tmp___0);
}
}
#line 259 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.c"
static int is_infinite_or_zerol(long double x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp = rpl_isnanl(x);
  }
#line 262
  if (tmp) {
#line 262
    tmp___0 = 1;
  } else
#line 262
  if (x + x == x) {
#line 262
    tmp___0 = 1;
  } else {
#line 262
    tmp___0 = 0;
  }
#line 262
  return (tmp___0);
}
}
#line 2769
extern int ( /* missing proto */  __builtin_signbitl)() ;
#line 2769
extern int ( /* missing proto */  __builtin_signbit)() ;
#line 2769
extern int ( /* missing proto */  __builtin_signbitf)() ;
#line 1440 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated___0 ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__))  tmp___19 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__))  tmp___22 ;
  size_t __attribute__((__pure__))  tmp___23 ;
  size_t __attribute__((__pure__))  tmp___24 ;
  size_t tmp_memsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__))  tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  size_t n___1 ;
  char const   *mp ;
  char *tmp___84 ;
  char const   *tmp___85 ;
  size_t n___2 ;
  char const   *mp___0 ;
  char *tmp___86 ;
  char const   *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___93 ;
  size_t __attribute__((__pure__))  tmp___94 ;
  size_t __attribute__((__pure__))  tmp___95 ;
  void *tmp___96 ;
  void *tmp___97 ;
  size_t __attribute__((__pure__))  tmp___98 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  int arg___6 ;
  unsigned int arg___7 ;
  long arg___8 ;
  unsigned long arg___9 ;
  long long arg___10 ;
  unsigned long long arg___11 ;
  double arg___12 ;
  long double arg___13 ;
  int arg___14 ;
  wint_t arg___15 ;
  char const   *arg___16 ;
  wchar_t const   *arg___17 ;
  void *arg___18 ;
  size_t bigger_need ;
  size_t tmp___99 ;
  size_t __attribute__((__pure__))  tmp___100 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___101 ;
  void *tmp___102 ;
  void *tmp___103 ;
  int *tmp___104 ;
  size_t n___3 ;
  size_t tmp___105 ;
  size_t __attribute__((__pure__))  tmp___106 ;
  size_t __attribute__((__pure__))  tmp___107 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___108 ;
  void *tmp___109 ;
  void *tmp___110 ;
  int tmp___111 ;
  size_t memory_size___5 ;
  char *memory___5 ;
  size_t tmp___112 ;
  size_t __attribute__((__pure__))  tmp___113 ;
  size_t __attribute__((__pure__))  tmp___114 ;
  void *tmp___115 ;
  void *tmp___116 ;
  size_t __attribute__((__pure__))  tmp___117 ;
  char *memory___6 ;
  void *tmp___118 ;
  int *tmp___119 ;
  int *tmp___120 ;

  {
  {
#line 1447
  tmp = printf_parse(format, & d, & a);
  }
#line 1447
  if (tmp < 0) {
#line 1449
    return ((char *)((void *)0));
  }
  {
#line 1456
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1456
  if (tmp___1 < 0) {
    {
#line 1458
    free((void *)d.dir);
    }
#line 1458
    if (a.arg) {
      {
#line 1458
      free((void *)a.arg);
      }
    }
    {
#line 1459
    tmp___0 = __errno_location();
#line 1459
    *tmp___0 = 22;
    }
#line 1460
    return ((char *)((void *)0));
  }
  {
#line 1477
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1477
  buf_neededlength = (size_t )tmp___2;
  }
#line 1480
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1482
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1482
    buf___1 = (char *)tmp___3;
#line 1483
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1488
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1488
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1488
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1488
    buf_memsize = tmp___4;
#line 1489
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1490
      goto out_of_memory_1;
    }
    {
#line 1491
    tmp___5 = malloc(buf_memsize);
#line 1491
    buf___1 = (char *)tmp___5;
    }
#line 1492
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 1493
      goto out_of_memory_1;
    }
#line 1494
    buf_malloced = buf___1;
  }
#line 1497
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1499
    result = resultbuf;
#line 1500
    allocated___0 = *lengthp;
  } else {
#line 1504
    result = (char *)((void *)0);
#line 1505
    allocated___0 = (size_t )0;
  }
#line 1507
  length = (size_t )0;
#line 1537
  cp = format;
#line 1537
  i = (size_t )0;
#line 1537
  dp = d.dir + 0;
  {
#line 1537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1539
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1541
      n = (size_t )(dp->dir_start - cp);
#line 1542
      tmp___6 = xsum(length, n);
#line 1542
      augmented_length = (size_t )tmp___6;
      }
#line 1544
      if (augmented_length > allocated___0) {
#line 1544
        if (allocated___0 > 0UL) {
#line 1544
          if (allocated___0 <= 9223372036854775807UL) {
#line 1544
            tmp___7 = allocated___0 * 2UL;
          } else {
#line 1544
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1544
          allocated___0 = tmp___7;
        } else {
#line 1544
          allocated___0 = (size_t )12;
        }
#line 1544
        if (augmented_length > allocated___0) {
#line 1544
          allocated___0 = augmented_length;
        }
#line 1544
        if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1544
          memory_size = allocated___0 * sizeof(char );
        } else {
#line 1544
          memory_size = 0xffffffffffffffffUL;
        }
#line 1544
        if (memory_size == 0xffffffffffffffffUL) {
#line 1544
          goto out_of_memory;
        }
#line 1544
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1544
          tmp___8 = malloc(memory_size);
#line 1544
          memory = (char *)tmp___8;
          }
        } else
#line 1544
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1544
          tmp___8 = malloc(memory_size);
#line 1544
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1544
          tmp___9 = realloc((void *)result, memory_size);
#line 1544
          memory = (char *)tmp___9;
          }
        }
#line 1544
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1544
          goto out_of_memory;
        }
#line 1544
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1544
          if (length > 0UL) {
            {
#line 1544
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1544
        result = memory;
      }
#line 1548
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1550
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1551
        length = augmented_length;
        }
      } else {
        {
#line 1555
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1556
          tmp___10 = length;
#line 1556
          length ++;
#line 1556
          tmp___11 = cp;
#line 1556
          cp ++;
#line 1556
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1555
          n --;
#line 1555
          if (! (n > 0UL)) {
#line 1555
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1560
    if (i == d.count) {
#line 1561
      goto while_break;
    }
#line 1564
    if ((int )dp->conversion == 37) {
#line 1568
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1569
        abort();
        }
      }
      {
#line 1570
      tmp___12 = xsum(length, (size_t )1);
#line 1570
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1571
      if (augmented_length___0 > allocated___0) {
#line 1571
        if (allocated___0 > 0UL) {
#line 1571
          if (allocated___0 <= 9223372036854775807UL) {
#line 1571
            tmp___13 = allocated___0 * 2UL;
          } else {
#line 1571
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1571
          allocated___0 = tmp___13;
        } else {
#line 1571
          allocated___0 = (size_t )12;
        }
#line 1571
        if (augmented_length___0 > allocated___0) {
#line 1571
          allocated___0 = augmented_length___0;
        }
#line 1571
        if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1571
          memory_size___0 = allocated___0 * sizeof(char );
        } else {
#line 1571
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1571
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1571
          goto out_of_memory;
        }
#line 1571
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1571
          tmp___14 = malloc(memory_size___0);
#line 1571
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1571
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1571
          tmp___14 = malloc(memory_size___0);
#line 1571
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1571
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1571
          memory___0 = (char *)tmp___15;
          }
        }
#line 1571
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1571
          goto out_of_memory;
        }
#line 1571
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1571
          if (length > 0UL) {
            {
#line 1571
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1571
        result = memory___0;
      }
#line 1572
      *(result + length) = (char )'%';
#line 1573
      length = augmented_length___0;
    } else {
#line 1577
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1578
        abort();
        }
      }
#line 1580
      if ((int )dp->conversion == 110) {
        {
#line 1584
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1584
          goto case_18;
        }
#line 1587
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1587
          goto case_19;
        }
#line 1590
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1590
          goto case_20;
        }
#line 1593
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1593
          goto case_21;
        }
#line 1597
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1597
          goto case_22;
        }
#line 1601
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1585
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1586
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1588
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1589
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1591
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1592
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1594
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1595
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1598
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1599
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1602
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else
#line 2562
      if ((int )dp->conversion == 102) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 70) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 101) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 69) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 103) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 71) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 97) {
#line 2562
        goto _L___11;
      } else
#line 2562
      if ((int )dp->conversion == 65) {
        _L___11: /* CIL Label */ 
#line 2562
        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
          {
#line 2562
          tmp___111 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
          }
#line 2562
          if (tmp___111) {
#line 2591
            flags = dp->flags;
#line 2602
            has_width = 0;
#line 2603
            width = (size_t )0;
#line 2604
            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 2606
              if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 2610
                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
                  {
#line 2611
                  abort();
                  }
                }
#line 2612
                arg = (a.arg + dp->width_arg_index)->a.a_int;
#line 2613
                if (arg < 0) {
#line 2617
                  flags |= 2;
#line 2618
                  width = (size_t )((unsigned int )(- arg));
                } else {
#line 2621
                  width = (size_t )arg;
                }
              } else {
#line 2625
                digitp = dp->width_start;
                {
#line 2627
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 2628
                  tmp___17 = digitp;
#line 2628
                  digitp ++;
#line 2628
                  if (width <= 1844674407370955161UL) {
#line 2628
                    tmp___18 = width * 10UL;
                  } else {
#line 2628
                    tmp___18 = 0xffffffffffffffffUL;
                  }
                  {
#line 2628
                  tmp___19 = xsum(tmp___18, (size_t )((int const   )*tmp___17 - 48));
#line 2628
                  width = (size_t )tmp___19;
                  }
#line 2627
                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
#line 2627
                    goto while_break___1;
                  }
                }
                while_break___1: /* CIL Label */ ;
                }
              }
#line 2631
              has_width = 1;
            }
#line 2634
            has_precision = 0;
#line 2635
            precision = (size_t )0;
#line 2636
            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 2638
              if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 2642
                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
                  {
#line 2643
                  abort();
                  }
                }
#line 2644
                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 2647
                if (arg___0 >= 0) {
#line 2649
                  precision = (size_t )arg___0;
#line 2650
                  has_precision = 1;
                }
              } else {
#line 2655
                digitp___0 = dp->precision_start + 1;
#line 2657
                precision = (size_t )0;
                {
#line 2658
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 2658
                  if (! ((unsigned long )digitp___0 != (unsigned long )dp->precision_end)) {
#line 2658
                    goto while_break___2;
                  }
#line 2659
                  tmp___20 = digitp___0;
#line 2659
                  digitp___0 ++;
#line 2659
                  if (precision <= 1844674407370955161UL) {
#line 2659
                    tmp___21 = precision * 10UL;
                  } else {
#line 2659
                    tmp___21 = 0xffffffffffffffffUL;
                  }
                  {
#line 2659
                  tmp___22 = xsum(tmp___21, (size_t )((int const   )*tmp___20 - 48));
#line 2659
                  precision = (size_t )tmp___22;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 2660
                has_precision = 1;
              }
            }
#line 2668
            if (! has_precision) {
#line 2669
              if (! ((int )dp->conversion == 97)) {
#line 2669
                if (! ((int )dp->conversion == 65)) {
#line 2670
                  precision = (size_t )6;
                }
              }
            }
#line 2682
            tmp_length = (size_t )0;
#line 2684
            if (tmp_length < precision) {
#line 2685
              tmp_length = precision;
            }
            {
#line 2719
            tmp___23 = xsum(tmp_length, (size_t )12);
#line 2719
            tmp_length = (size_t )tmp___23;
            }
#line 2721
            if (tmp_length < width) {
#line 2722
              tmp_length = width;
            }
            {
#line 2724
            tmp___24 = xsum(tmp_length, (size_t )1);
#line 2724
            tmp_length = (size_t )tmp___24;
            }
#line 2726
            if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
#line 2727
              tmp___16 = tmpbuf;
            } else {
#line 2730
              if (tmp_length <= 0xffffffffffffffffUL / sizeof(char )) {
#line 2730
                tmp___25 = tmp_length * sizeof(char );
              } else {
#line 2730
                tmp___25 = 0xffffffffffffffffUL;
              }
#line 2730
              tmp_memsize = tmp___25;
#line 2732
              if (tmp_memsize == 0xffffffffffffffffUL) {
#line 2734
                goto out_of_memory;
              }
              {
#line 2735
              tmp___26 = malloc(tmp_memsize);
#line 2735
              tmp___16 = (char *)tmp___26;
              }
#line 2736
              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 2738
                goto out_of_memory;
              }
            }
            {
#line 2741
            pad_ptr = (char *)((void *)0);
#line 2742
            p = tmp___16;
#line 2749
            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 2751
            tmp___69 = rpl_isnanl(arg___1);
            }
#line 2751
            if (tmp___69) {
#line 2753
              if ((int )dp->conversion >= 65) {
#line 2753
                if ((int )dp->conversion <= 90) {
#line 2755
                  tmp___27 = p;
#line 2755
                  p ++;
#line 2755
                  *tmp___27 = (char )'N';
#line 2755
                  tmp___28 = p;
#line 2755
                  p ++;
#line 2755
                  *tmp___28 = (char )'A';
#line 2755
                  tmp___29 = p;
#line 2755
                  p ++;
#line 2755
                  *tmp___29 = (char )'N';
                } else {
#line 2753
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 2759
                tmp___30 = p;
#line 2759
                p ++;
#line 2759
                *tmp___30 = (char )'n';
#line 2759
                tmp___31 = p;
#line 2759
                p ++;
#line 2759
                *tmp___31 = (char )'a';
#line 2759
                tmp___32 = p;
#line 2759
                p ++;
#line 2759
                *tmp___32 = (char )'n';
              }
            } else {
#line 2764
              sign = 0;
#line 2767
              __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 2767
              oldcw = _cw;
#line 2767
              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 2767
              __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 2769
              if (sizeof(arg___1) == sizeof(long double )) {
                {
#line 2769
                tmp___33 = __builtin_signbitl(arg___1);
#line 2769
                tmp___37 = tmp___33;
                }
              } else {
#line 2769
                if (sizeof(arg___1) == sizeof(double )) {
                  {
#line 2769
                  tmp___34 = __builtin_signbit(arg___1);
#line 2769
                  tmp___36 = tmp___34;
                  }
                } else {
                  {
#line 2769
                  tmp___35 = __builtin_signbitf(arg___1);
#line 2769
                  tmp___36 = tmp___35;
                  }
                }
#line 2769
                tmp___37 = tmp___36;
              }
#line 2769
              if (tmp___37) {
#line 2771
                sign = -1;
#line 2772
                arg___1 = - arg___1;
              }
#line 2775
              if (sign < 0) {
#line 2776
                tmp___38 = p;
#line 2776
                p ++;
#line 2776
                *tmp___38 = (char )'-';
              } else
#line 2777
              if (flags & 4) {
#line 2778
                tmp___39 = p;
#line 2778
                p ++;
#line 2778
                *tmp___39 = (char )'+';
              } else
#line 2779
              if (flags & 8) {
#line 2780
                tmp___40 = p;
#line 2780
                p ++;
#line 2780
                *tmp___40 = (char )' ';
              }
#line 2782
              if (arg___1 > 0.0L) {
#line 2782
                if (arg___1 + arg___1 == arg___1) {
#line 2784
                  if ((int )dp->conversion >= 65) {
#line 2784
                    if ((int )dp->conversion <= 90) {
#line 2786
                      tmp___41 = p;
#line 2786
                      p ++;
#line 2786
                      *tmp___41 = (char )'I';
#line 2786
                      tmp___42 = p;
#line 2786
                      p ++;
#line 2786
                      *tmp___42 = (char )'N';
#line 2786
                      tmp___43 = p;
#line 2786
                      p ++;
#line 2786
                      *tmp___43 = (char )'F';
                    } else {
#line 2784
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 2790
                    tmp___44 = p;
#line 2790
                    p ++;
#line 2790
                    *tmp___44 = (char )'i';
#line 2790
                    tmp___45 = p;
#line 2790
                    p ++;
#line 2790
                    *tmp___45 = (char )'n';
#line 2790
                    tmp___46 = p;
#line 2790
                    p ++;
#line 2790
                    *tmp___46 = (char )'f';
                  }
                } else {
#line 2782
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
#line 3146
                if (! (arg___1 == 0.0L)) {
                  {
#line 3147
                  abort();
                  }
                }
#line 3149
                pad_ptr = p;
#line 3151
                if ((int )dp->conversion == 102) {
#line 3151
                  goto _L___7;
                } else
#line 3151
                if ((int )dp->conversion == 70) {
                  _L___7: /* CIL Label */ 
#line 3153
                  tmp___47 = p;
#line 3153
                  p ++;
#line 3153
                  *tmp___47 = (char )'0';
#line 3154
                  if (flags & 16) {
#line 3154
                    goto _L___1;
                  } else
#line 3154
                  if (precision > 0UL) {
                    _L___1: /* CIL Label */ 
                    {
#line 3156
                    tmp___48 = p;
#line 3156
                    p ++;
#line 3156
                    *tmp___48 = decimal_point_char();
                    }
                    {
#line 3157
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 3157
                      if (! (precision > 0UL)) {
#line 3157
                        goto while_break___3;
                      }
#line 3158
                      tmp___49 = p;
#line 3158
                      p ++;
#line 3158
                      *tmp___49 = (char )'0';
#line 3157
                      precision --;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
                  }
                } else
#line 3161
                if ((int )dp->conversion == 101) {
#line 3161
                  goto _L___6;
                } else
#line 3161
                if ((int )dp->conversion == 69) {
                  _L___6: /* CIL Label */ 
#line 3163
                  tmp___50 = p;
#line 3163
                  p ++;
#line 3163
                  *tmp___50 = (char )'0';
#line 3164
                  if (flags & 16) {
#line 3164
                    goto _L___2;
                  } else
#line 3164
                  if (precision > 0UL) {
                    _L___2: /* CIL Label */ 
                    {
#line 3166
                    tmp___51 = p;
#line 3166
                    p ++;
#line 3166
                    *tmp___51 = decimal_point_char();
                    }
                    {
#line 3167
                    while (1) {
                      while_continue___4: /* CIL Label */ ;
#line 3167
                      if (! (precision > 0UL)) {
#line 3167
                        goto while_break___4;
                      }
#line 3168
                      tmp___52 = p;
#line 3168
                      p ++;
#line 3168
                      *tmp___52 = (char )'0';
#line 3167
                      precision --;
                    }
                    while_break___4: /* CIL Label */ ;
                    }
                  }
#line 3170
                  tmp___53 = p;
#line 3170
                  p ++;
#line 3170
                  *tmp___53 = dp->conversion;
#line 3171
                  tmp___54 = p;
#line 3171
                  p ++;
#line 3171
                  *tmp___54 = (char )'+';
#line 3172
                  tmp___55 = p;
#line 3172
                  p ++;
#line 3172
                  *tmp___55 = (char )'0';
#line 3173
                  tmp___56 = p;
#line 3173
                  p ++;
#line 3173
                  *tmp___56 = (char )'0';
                } else
#line 3175
                if ((int )dp->conversion == 103) {
#line 3175
                  goto _L___5;
                } else
#line 3175
                if ((int )dp->conversion == 71) {
                  _L___5: /* CIL Label */ 
#line 3177
                  tmp___57 = p;
#line 3177
                  p ++;
#line 3177
                  *tmp___57 = (char )'0';
#line 3178
                  if (flags & 16) {
#line 3180
                    if (precision > 0UL) {
#line 3180
                      tmp___58 = precision - 1UL;
                    } else {
#line 3180
                      tmp___58 = (size_t )0;
                    }
                    {
#line 3180
                    ndigits = tmp___58;
#line 3182
                    tmp___59 = p;
#line 3182
                    p ++;
#line 3182
                    *tmp___59 = decimal_point_char();
                    }
                    {
#line 3183
                    while (1) {
                      while_continue___5: /* CIL Label */ ;
#line 3183
                      if (! (ndigits > 0UL)) {
#line 3183
                        goto while_break___5;
                      }
#line 3184
                      tmp___60 = p;
#line 3184
                      p ++;
#line 3184
                      *tmp___60 = (char )'0';
#line 3183
                      ndigits --;
                    }
                    while_break___5: /* CIL Label */ ;
                    }
                  }
                } else
#line 3187
                if ((int )dp->conversion == 97) {
#line 3187
                  goto _L___4;
                } else
#line 3187
                if ((int )dp->conversion == 65) {
                  _L___4: /* CIL Label */ 
#line 3189
                  tmp___61 = p;
#line 3189
                  p ++;
#line 3189
                  *tmp___61 = (char )'0';
#line 3190
                  tmp___62 = p;
#line 3190
                  p ++;
#line 3190
                  *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
#line 3191
                  pad_ptr = p;
#line 3192
                  tmp___63 = p;
#line 3192
                  p ++;
#line 3192
                  *tmp___63 = (char )'0';
#line 3193
                  if (flags & 16) {
#line 3193
                    goto _L___3;
                  } else
#line 3193
                  if (precision > 0UL) {
                    _L___3: /* CIL Label */ 
                    {
#line 3195
                    tmp___64 = p;
#line 3195
                    p ++;
#line 3195
                    *tmp___64 = decimal_point_char();
                    }
                    {
#line 3196
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 3196
                      if (! (precision > 0UL)) {
#line 3196
                        goto while_break___6;
                      }
#line 3197
                      tmp___65 = p;
#line 3197
                      p ++;
#line 3197
                      *tmp___65 = (char )'0';
#line 3196
                      precision --;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                  }
#line 3199
                  tmp___66 = p;
#line 3199
                  p ++;
#line 3199
                  *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
#line 3200
                  tmp___67 = p;
#line 3200
                  p ++;
#line 3200
                  *tmp___67 = (char )'+';
#line 3201
                  tmp___68 = p;
#line 3201
                  p ++;
#line 3201
                  *tmp___68 = (char )'0';
                } else {
                  {
#line 3204
                  abort();
                  }
                }
              }
#line 3208
              _ncw___0 = oldcw;
#line 3208
              __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
            }
#line 3688
            if (has_width) {
#line 3688
              if ((size_t )(p - tmp___16) < width) {
#line 3690
                pad = width - (size_t )(p - tmp___16);
#line 3691
                end = p + pad;
#line 3693
                if (flags & 2) {
                  {
#line 3696
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 3696
                    if (! (pad > 0UL)) {
#line 3696
                      goto while_break___7;
                    }
#line 3697
                    tmp___70 = p;
#line 3697
                    p ++;
#line 3697
                    *tmp___70 = (char )' ';
#line 3696
                    pad --;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                } else
#line 3699
                if (flags & 32) {
#line 3699
                  if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
#line 3702
                    q = end;
                    {
#line 3704
                    while (1) {
                      while_continue___8: /* CIL Label */ ;
#line 3704
                      if (! ((unsigned long )p > (unsigned long )pad_ptr)) {
#line 3704
                        goto while_break___8;
                      }
#line 3705
                      q --;
#line 3705
                      p --;
#line 3705
                      *q = *p;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
                    {
#line 3706
                    while (1) {
                      while_continue___9: /* CIL Label */ ;
#line 3706
                      if (! (pad > 0UL)) {
#line 3706
                        goto while_break___9;
                      }
#line 3707
                      tmp___71 = p;
#line 3707
                      p ++;
#line 3707
                      *tmp___71 = (char )'0';
#line 3706
                      pad --;
                    }
                    while_break___9: /* CIL Label */ ;
                    }
                  } else {
#line 3699
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
#line 3712
                  q___0 = end;
                  {
#line 3714
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 3714
                    if (! ((unsigned long )p > (unsigned long )tmp___16)) {
#line 3714
                      goto while_break___10;
                    }
#line 3715
                    q___0 --;
#line 3715
                    p --;
#line 3715
                    *q___0 = *p;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
                  {
#line 3716
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 3716
                    if (! (pad > 0UL)) {
#line 3716
                      goto while_break___11;
                    }
#line 3717
                    tmp___72 = p;
#line 3717
                    p ++;
#line 3717
                    *tmp___72 = (char )' ';
#line 3716
                    pad --;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                }
#line 3720
                p = end;
              }
            }
#line 3724
            count = (size_t )(p - tmp___16);
#line 3726
            if (count >= tmp_length) {
              {
#line 3729
              abort();
              }
            }
#line 3732
            if (count >= allocated___0 - length) {
              {
#line 3734
              tmp___73 = xsum(length, count);
#line 3734
              n___0 = (size_t )tmp___73;
              }
#line 3736
              if (n___0 > allocated___0) {
#line 3736
                if (allocated___0 > 0UL) {
#line 3736
                  if (allocated___0 <= 9223372036854775807UL) {
#line 3736
                    tmp___74 = allocated___0 * 2UL;
                  } else {
#line 3736
                    tmp___74 = 0xffffffffffffffffUL;
                  }
#line 3736
                  allocated___0 = tmp___74;
                } else {
#line 3736
                  allocated___0 = (size_t )12;
                }
#line 3736
                if (n___0 > allocated___0) {
#line 3736
                  allocated___0 = n___0;
                }
#line 3736
                if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 3736
                  memory_size___1 = allocated___0 * sizeof(char );
                } else {
#line 3736
                  memory_size___1 = 0xffffffffffffffffUL;
                }
#line 3736
                if (memory_size___1 == 0xffffffffffffffffUL) {
#line 3736
                  goto out_of_memory;
                }
#line 3736
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 3736
                  tmp___75 = malloc(memory_size___1);
#line 3736
                  memory___1 = (char *)tmp___75;
                  }
                } else
#line 3736
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 3736
                  tmp___75 = malloc(memory_size___1);
#line 3736
                  memory___1 = (char *)tmp___75;
                  }
                } else {
                  {
#line 3736
                  tmp___76 = realloc((void *)result, memory_size___1);
#line 3736
                  memory___1 = (char *)tmp___76;
                  }
                }
#line 3736
                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 3736
                  goto out_of_memory;
                }
#line 3736
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 3736
                  if (length > 0UL) {
                    {
#line 3736
                    memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 3736
                result = memory___1;
              }
            }
            {
#line 3740
            memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)tmp___16,
                   count * sizeof(char ));
            }
#line 3741
            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
              {
#line 3742
              free((void *)tmp___16);
              }
            }
#line 3743
            length += count;
          } else {
#line 2562
            goto _L___10;
          }
        } else {
#line 2562
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
#line 3749
        type = (a.arg + dp->arg_index)->type;
#line 3750
        flags___0 = dp->flags;
#line 4098
        fbp = buf___1;
#line 4099
        tmp___77 = fbp;
#line 4099
        fbp ++;
#line 4099
        *tmp___77 = (char )'%';
#line 4105
        if (flags___0 & 1) {
#line 4106
          tmp___78 = fbp;
#line 4106
          fbp ++;
#line 4106
          *tmp___78 = (char )'\'';
        }
#line 4108
        if (flags___0 & 2) {
#line 4109
          tmp___79 = fbp;
#line 4109
          fbp ++;
#line 4109
          *tmp___79 = (char )'-';
        }
#line 4110
        if (flags___0 & 4) {
#line 4111
          tmp___80 = fbp;
#line 4111
          fbp ++;
#line 4111
          *tmp___80 = (char )'+';
        }
#line 4112
        if (flags___0 & 8) {
#line 4113
          tmp___81 = fbp;
#line 4113
          fbp ++;
#line 4113
          *tmp___81 = (char )' ';
        }
#line 4114
        if (flags___0 & 16) {
#line 4115
          tmp___82 = fbp;
#line 4115
          fbp ++;
#line 4115
          *tmp___82 = (char )'#';
        }
#line 4118
        if (flags___0 & 32) {
#line 4119
          tmp___83 = fbp;
#line 4119
          fbp ++;
#line 4119
          *tmp___83 = (char )'0';
        }
#line 4120
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4122
          n___1 = (size_t )(dp->width_end - dp->width_start);
#line 4125
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4127
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   n___1 * sizeof(char ));
#line 4128
            fbp += n___1;
            }
          } else {
#line 4132
            mp = dp->width_start;
            {
#line 4133
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 4134
              tmp___84 = fbp;
#line 4134
              fbp ++;
#line 4134
              tmp___85 = mp;
#line 4134
              mp ++;
#line 4134
              *tmp___84 = (char )((unsigned char )*tmp___85);
#line 4133
              n___1 --;
#line 4133
              if (! (n___1 > 0UL)) {
#line 4133
                goto while_break___12;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
#line 4141
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4143
          n___2 = (size_t )(dp->precision_end - dp->precision_start);
#line 4146
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4148
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   n___2 * sizeof(char ));
#line 4149
            fbp += n___2;
            }
          } else {
#line 4153
            mp___0 = dp->precision_start;
            {
#line 4154
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 4155
              tmp___86 = fbp;
#line 4155
              fbp ++;
#line 4155
              tmp___87 = mp___0;
#line 4155
              mp___0 ++;
#line 4155
              *tmp___86 = (char )((unsigned char )*tmp___87);
#line 4154
              n___2 --;
#line 4154
              if (! (n___2 > 0UL)) {
#line 4154
                goto while_break___13;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
          }
        }
        {
#line 4165
        if ((unsigned int )type == 10U) {
#line 4165
          goto case_10;
        }
#line 4165
        if ((unsigned int )type == 9U) {
#line 4165
          goto case_10;
        }
#line 4182
        if ((unsigned int )type == 16U) {
#line 4182
          goto case_16;
        }
#line 4182
        if ((unsigned int )type == 14U) {
#line 4182
          goto case_16;
        }
#line 4182
        if ((unsigned int )type == 8U) {
#line 4182
          goto case_16;
        }
#line 4182
        if ((unsigned int )type == 7U) {
#line 4182
          goto case_16;
        }
#line 4186
        if ((unsigned int )type == 12U) {
#line 4186
          goto case_12;
        }
#line 4189
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4172
        tmp___88 = fbp;
#line 4172
        fbp ++;
#line 4172
        *tmp___88 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4184
        tmp___89 = fbp;
#line 4184
        fbp ++;
#line 4184
        *tmp___89 = (char )'l';
#line 4185
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4187
        tmp___90 = fbp;
#line 4187
        fbp ++;
#line 4187
        *tmp___90 = (char )'L';
#line 4188
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4190
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4197
        *fbp = dp->conversion;
#line 4227
        *(fbp + 1) = (char )'\000';
#line 4234
        prefix_count = 0U;
#line 4235
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4237
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4238
            abort();
            }
          }
#line 4239
          tmp___91 = prefix_count;
#line 4239
          prefix_count ++;
#line 4239
          prefixes[tmp___91] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4241
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4243
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4244
            abort();
            }
          }
#line 4245
          tmp___92 = prefix_count;
#line 4245
          prefix_count ++;
#line 4245
          prefixes[tmp___92] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4257
        tmp___98 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4257
        if (tmp___98 > (size_t __attribute__((__pure__))  )allocated___0) {
#line 4257
          if (allocated___0 > 0UL) {
#line 4257
            if (allocated___0 <= 9223372036854775807UL) {
#line 4257
              tmp___93 = allocated___0 * 2UL;
            } else {
#line 4257
              tmp___93 = 0xffffffffffffffffUL;
            }
#line 4257
            allocated___0 = tmp___93;
          } else {
#line 4257
            allocated___0 = (size_t )12;
          }
          {
#line 4257
          tmp___95 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4257
          if (tmp___95 > (size_t __attribute__((__pure__))  )allocated___0) {
            {
#line 4257
            tmp___94 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4257
            allocated___0 = (size_t )tmp___94;
            }
          }
#line 4257
          if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4257
            memory_size___2 = allocated___0 * sizeof(char );
          } else {
#line 4257
            memory_size___2 = 0xffffffffffffffffUL;
          }
#line 4257
          if (memory_size___2 == 0xffffffffffffffffUL) {
#line 4257
            goto out_of_memory;
          }
#line 4257
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4257
            tmp___96 = malloc(memory_size___2);
#line 4257
            memory___2 = (char *)tmp___96;
            }
          } else
#line 4257
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4257
            tmp___96 = malloc(memory_size___2);
#line 4257
            memory___2 = (char *)tmp___96;
            }
          } else {
            {
#line 4257
            tmp___97 = realloc((void *)result, memory_size___2);
#line 4257
            memory___2 = (char *)tmp___97;
            }
          }
#line 4257
          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 4257
            goto out_of_memory;
          }
#line 4257
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4257
            if (length > 0UL) {
              {
#line 4257
              memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4257
          result = memory___2;
        }
#line 4262
        *(result + length) = (char )'\000';
        {
#line 4265
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4267
          count___0 = -1;
#line 4270
          retcount = 0;
#line 4271
          maxlen = allocated___0 - length;
#line 4274
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4275
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
#line 4276
          maxlen *= sizeof(char ) / sizeof(char );
          {
#line 4320
          if ((unsigned int )type == 1U) {
#line 4320
            goto case_1;
          }
#line 4326
          if ((unsigned int )type == 2U) {
#line 4326
            goto case_2___0;
          }
#line 4332
          if ((unsigned int )type == 3U) {
#line 4332
            goto case_3;
          }
#line 4338
          if ((unsigned int )type == 4U) {
#line 4338
            goto case_4;
          }
#line 4344
          if ((unsigned int )type == 5U) {
#line 4344
            goto case_5;
          }
#line 4350
          if ((unsigned int )type == 6U) {
#line 4350
            goto case_6;
          }
#line 4356
          if ((unsigned int )type == 7U) {
#line 4356
            goto case_7___0;
          }
#line 4362
          if ((unsigned int )type == 8U) {
#line 4362
            goto case_8___0;
          }
#line 4369
          if ((unsigned int )type == 9U) {
#line 4369
            goto case_9___0;
          }
#line 4375
          if ((unsigned int )type == 10U) {
#line 4375
            goto case_10___0;
          }
#line 4382
          if ((unsigned int )type == 11U) {
#line 4382
            goto case_11;
          }
#line 4388
          if ((unsigned int )type == 12U) {
#line 4388
            goto case_12___0;
          }
#line 4394
          if ((unsigned int )type == 13U) {
#line 4394
            goto case_13;
          }
#line 4401
          if ((unsigned int )type == 14U) {
#line 4401
            goto case_14___0;
          }
#line 4408
          if ((unsigned int )type == 15U) {
#line 4408
            goto case_15;
          }
#line 4415
          if ((unsigned int )type == 16U) {
#line 4415
            goto case_16___0;
          }
#line 4422
          if ((unsigned int )type == 17U) {
#line 4422
            goto case_17;
          }
#line 4428
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4322
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4323
          if (prefix_count == 0U) {
#line 4323
            goto case_0;
          }
#line 4323
          if (prefix_count == 1U) {
#line 4323
            goto case_1___0;
          }
#line 4323
          if (prefix_count == 2U) {
#line 4323
            goto case_2;
          }
#line 4323
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4323
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___2, & count___0);
          }
#line 4323
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4323
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___2, & count___0);
          }
#line 4323
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4323
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___2, & count___0);
          }
#line 4323
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4323
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4325
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4328
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4329
          if (prefix_count == 0U) {
#line 4329
            goto case_0___0;
          }
#line 4329
          if (prefix_count == 1U) {
#line 4329
            goto case_1___1;
          }
#line 4329
          if (prefix_count == 2U) {
#line 4329
            goto case_2___1;
          }
#line 4329
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4329
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___3, & count___0);
          }
#line 4329
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4329
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___3, & count___0);
          }
#line 4329
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4329
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___3, & count___0);
          }
#line 4329
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4329
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4331
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4334
          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4335
          if (prefix_count == 0U) {
#line 4335
            goto case_0___1;
          }
#line 4335
          if (prefix_count == 1U) {
#line 4335
            goto case_1___2;
          }
#line 4335
          if (prefix_count == 2U) {
#line 4335
            goto case_2___2;
          }
#line 4335
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4335
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___4, & count___0);
          }
#line 4335
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4335
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___4, & count___0);
          }
#line 4335
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4335
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___4, & count___0);
          }
#line 4335
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4335
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4337
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4340
          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4341
          if (prefix_count == 0U) {
#line 4341
            goto case_0___2;
          }
#line 4341
          if (prefix_count == 1U) {
#line 4341
            goto case_1___3;
          }
#line 4341
          if (prefix_count == 2U) {
#line 4341
            goto case_2___3;
          }
#line 4341
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4341
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___5, & count___0);
          }
#line 4341
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4341
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___5, & count___0);
          }
#line 4341
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4341
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___5, & count___0);
          }
#line 4341
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4341
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4343
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4346
          arg___6 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4347
          if (prefix_count == 0U) {
#line 4347
            goto case_0___3;
          }
#line 4347
          if (prefix_count == 1U) {
#line 4347
            goto case_1___4;
          }
#line 4347
          if (prefix_count == 2U) {
#line 4347
            goto case_2___4;
          }
#line 4347
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4347
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___6, & count___0);
          }
#line 4347
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4347
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___6, & count___0);
          }
#line 4347
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4347
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___6, & count___0);
          }
#line 4347
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4347
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 4349
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 4352
          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 4353
          if (prefix_count == 0U) {
#line 4353
            goto case_0___4;
          }
#line 4353
          if (prefix_count == 1U) {
#line 4353
            goto case_1___5;
          }
#line 4353
          if (prefix_count == 2U) {
#line 4353
            goto case_2___5;
          }
#line 4353
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 4353
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___7, & count___0);
          }
#line 4353
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 4353
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___7, & count___0);
          }
#line 4353
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 4353
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___7, & count___0);
          }
#line 4353
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 4353
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 4355
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 4358
          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 4359
          if (prefix_count == 0U) {
#line 4359
            goto case_0___5;
          }
#line 4359
          if (prefix_count == 1U) {
#line 4359
            goto case_1___6;
          }
#line 4359
          if (prefix_count == 2U) {
#line 4359
            goto case_2___6;
          }
#line 4359
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 4359
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___8, & count___0);
          }
#line 4359
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 4359
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___8, & count___0);
          }
#line 4359
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 4359
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___8, & count___0);
          }
#line 4359
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 4359
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 4361
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 4364
          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 4365
          if (prefix_count == 0U) {
#line 4365
            goto case_0___6;
          }
#line 4365
          if (prefix_count == 1U) {
#line 4365
            goto case_1___7;
          }
#line 4365
          if (prefix_count == 2U) {
#line 4365
            goto case_2___7;
          }
#line 4365
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 4365
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___9, & count___0);
          }
#line 4365
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 4365
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___9, & count___0);
          }
#line 4365
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 4365
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___9, & count___0);
          }
#line 4365
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 4365
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 4367
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 4371
          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 4372
          if (prefix_count == 0U) {
#line 4372
            goto case_0___7;
          }
#line 4372
          if (prefix_count == 1U) {
#line 4372
            goto case_1___8;
          }
#line 4372
          if (prefix_count == 2U) {
#line 4372
            goto case_2___8;
          }
#line 4372
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 4372
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___10,
                              & count___0);
          }
#line 4372
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 4372
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___10, & count___0);
          }
#line 4372
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 4372
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___10, & count___0);
          }
#line 4372
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 4372
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 4374
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 4377
          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 4378
          if (prefix_count == 0U) {
#line 4378
            goto case_0___8;
          }
#line 4378
          if (prefix_count == 1U) {
#line 4378
            goto case_1___9;
          }
#line 4378
          if (prefix_count == 2U) {
#line 4378
            goto case_2___9;
          }
#line 4378
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 4378
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___11,
                              & count___0);
          }
#line 4378
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 4378
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___11, & count___0);
          }
#line 4378
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 4378
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___11, & count___0);
          }
#line 4378
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 4378
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 4380
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 4384
          arg___12 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 4385
          if (prefix_count == 0U) {
#line 4385
            goto case_0___9;
          }
#line 4385
          if (prefix_count == 1U) {
#line 4385
            goto case_1___10;
          }
#line 4385
          if (prefix_count == 2U) {
#line 4385
            goto case_2___10;
          }
#line 4385
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 4385
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___12,
                              & count___0);
          }
#line 4385
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 4385
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___12, & count___0);
          }
#line 4385
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 4385
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___12, & count___0);
          }
#line 4385
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 4385
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 4387
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 4390
          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 4391
          if (prefix_count == 0U) {
#line 4391
            goto case_0___10;
          }
#line 4391
          if (prefix_count == 1U) {
#line 4391
            goto case_1___11;
          }
#line 4391
          if (prefix_count == 2U) {
#line 4391
            goto case_2___11;
          }
#line 4391
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 4391
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___13,
                              & count___0);
          }
#line 4391
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 4391
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___13, & count___0);
          }
#line 4391
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 4391
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___13, & count___0);
          }
#line 4391
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 4391
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 4393
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 4396
          arg___14 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 4397
          if (prefix_count == 0U) {
#line 4397
            goto case_0___11;
          }
#line 4397
          if (prefix_count == 1U) {
#line 4397
            goto case_1___12;
          }
#line 4397
          if (prefix_count == 2U) {
#line 4397
            goto case_2___12;
          }
#line 4397
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 4397
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___14,
                              & count___0);
          }
#line 4397
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 4397
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___14, & count___0);
          }
#line 4397
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 4397
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___14, & count___0);
          }
#line 4397
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 4397
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 4399
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 4403
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 4404
          if (prefix_count == 0U) {
#line 4404
            goto case_0___12;
          }
#line 4404
          if (prefix_count == 1U) {
#line 4404
            goto case_1___13;
          }
#line 4404
          if (prefix_count == 2U) {
#line 4404
            goto case_2___13;
          }
#line 4404
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 4404
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___15,
                              & count___0);
          }
#line 4404
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 4404
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___15, & count___0);
          }
#line 4404
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 4404
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___15, & count___0);
          }
#line 4404
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 4404
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 4406
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 4410
          arg___16 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 4411
          if (prefix_count == 0U) {
#line 4411
            goto case_0___13;
          }
#line 4411
          if (prefix_count == 1U) {
#line 4411
            goto case_1___14;
          }
#line 4411
          if (prefix_count == 2U) {
#line 4411
            goto case_2___14;
          }
#line 4411
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 4411
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___16,
                              & count___0);
          }
#line 4411
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 4411
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___16, & count___0);
          }
#line 4411
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 4411
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___16, & count___0);
          }
#line 4411
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 4411
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 4413
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 4417
          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 4418
          if (prefix_count == 0U) {
#line 4418
            goto case_0___14;
          }
#line 4418
          if (prefix_count == 1U) {
#line 4418
            goto case_1___15;
          }
#line 4418
          if (prefix_count == 2U) {
#line 4418
            goto case_2___15;
          }
#line 4418
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 4418
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___17,
                              & count___0);
          }
#line 4418
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 4418
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___17, & count___0);
          }
#line 4418
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 4418
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___17, & count___0);
          }
#line 4418
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 4418
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 4420
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 4424
          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 4425
          if (prefix_count == 0U) {
#line 4425
            goto case_0___15;
          }
#line 4425
          if (prefix_count == 1U) {
#line 4425
            goto case_1___16;
          }
#line 4425
          if (prefix_count == 2U) {
#line 4425
            goto case_2___16;
          }
#line 4425
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 4425
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___18,
                              & count___0);
          }
#line 4425
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 4425
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___18, & count___0);
          }
#line 4425
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 4425
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___18, & count___0);
          }
#line 4425
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 4425
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 4427
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 4429
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 4437
          if (count___0 >= 0) {
#line 4441
            if ((size_t )count___0 < maxlen) {
#line 4441
              if ((int )*((result + length) + count___0) != 0) {
                {
#line 4443
                abort();
                }
              }
            }
#line 4445
            if (retcount > count___0) {
#line 4446
              count___0 = retcount;
            }
          } else
#line 4452
          if ((int )*(fbp + 1) != 0) {
#line 4456
            *(fbp + 1) = (char )'\000';
#line 4457
            goto __Cont;
          } else
#line 4462
          if (retcount < 0) {
#line 4469
            if (allocated___0 <= 9223372036854775807UL) {
#line 4469
              tmp___99 = allocated___0 * 2UL;
            } else {
#line 4469
              tmp___99 = 0xffffffffffffffffUL;
            }
            {
#line 4469
            tmp___100 = xsum(tmp___99, (size_t )12);
#line 4469
            bigger_need = (size_t )tmp___100;
            }
#line 4471
            if (bigger_need > allocated___0) {
#line 4471
              if (allocated___0 > 0UL) {
#line 4471
                if (allocated___0 <= 9223372036854775807UL) {
#line 4471
                  tmp___101 = allocated___0 * 2UL;
                } else {
#line 4471
                  tmp___101 = 0xffffffffffffffffUL;
                }
#line 4471
                allocated___0 = tmp___101;
              } else {
#line 4471
                allocated___0 = (size_t )12;
              }
#line 4471
              if (bigger_need > allocated___0) {
#line 4471
                allocated___0 = bigger_need;
              }
#line 4471
              if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4471
                memory_size___3 = allocated___0 * sizeof(char );
              } else {
#line 4471
                memory_size___3 = 0xffffffffffffffffUL;
              }
#line 4471
              if (memory_size___3 == 0xffffffffffffffffUL) {
#line 4471
                goto out_of_memory;
              }
#line 4471
              if ((unsigned long )result == (unsigned long )resultbuf) {
                {
#line 4471
                tmp___102 = malloc(memory_size___3);
#line 4471
                memory___3 = (char *)tmp___102;
                }
              } else
#line 4471
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 4471
                tmp___102 = malloc(memory_size___3);
#line 4471
                memory___3 = (char *)tmp___102;
                }
              } else {
                {
#line 4471
                tmp___103 = realloc((void *)result, memory_size___3);
#line 4471
                memory___3 = (char *)tmp___103;
                }
              }
#line 4471
              if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 4471
                goto out_of_memory;
              }
#line 4471
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4471
                if (length > 0UL) {
                  {
#line 4471
                  memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                         length);
                  }
                }
              }
#line 4471
              result = memory___3;
            }
#line 4472
            goto __Cont;
          } else {
#line 4475
            count___0 = retcount;
          }
#line 4481
          if (count___0 < 0) {
#line 4483
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 4483
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 4484
                free((void *)result);
                }
              }
            }
#line 4485
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 4486
              free((void *)buf_malloced);
              }
            }
            {
#line 4487
            free((void *)d.dir);
            }
#line 4487
            if (a.arg) {
              {
#line 4487
              free((void *)a.arg);
              }
            }
            {
#line 4488
            tmp___104 = __errno_location();
#line 4488
            *tmp___104 = 22;
            }
#line 4489
            return ((char *)((void *)0));
          }
#line 4498
          if ((size_t )((unsigned int )count___0 + 1U) >= maxlen) {
#line 4503
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4504
              goto overflow;
            } else {
#line 4516
              if (allocated___0 <= 9223372036854775807UL) {
#line 4516
                tmp___105 = allocated___0 * 2UL;
              } else {
#line 4516
                tmp___105 = 0xffffffffffffffffUL;
              }
              {
#line 4516
              tmp___106 = xsum(length, (((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4516
              tmp___107 = xmax((size_t )tmp___106, tmp___105);
#line 4516
              n___3 = (size_t )tmp___107;
              }
#line 4523
              if (n___3 > allocated___0) {
#line 4523
                if (allocated___0 > 0UL) {
#line 4523
                  if (allocated___0 <= 9223372036854775807UL) {
#line 4523
                    tmp___108 = allocated___0 * 2UL;
                  } else {
#line 4523
                    tmp___108 = 0xffffffffffffffffUL;
                  }
#line 4523
                  allocated___0 = tmp___108;
                } else {
#line 4523
                  allocated___0 = (size_t )12;
                }
#line 4523
                if (n___3 > allocated___0) {
#line 4523
                  allocated___0 = n___3;
                }
#line 4523
                if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4523
                  memory_size___4 = allocated___0 * sizeof(char );
                } else {
#line 4523
                  memory_size___4 = 0xffffffffffffffffUL;
                }
#line 4523
                if (memory_size___4 == 0xffffffffffffffffUL) {
#line 4523
                  goto out_of_memory;
                }
#line 4523
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 4523
                  tmp___109 = malloc(memory_size___4);
#line 4523
                  memory___4 = (char *)tmp___109;
                  }
                } else
#line 4523
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 4523
                  tmp___109 = malloc(memory_size___4);
#line 4523
                  memory___4 = (char *)tmp___109;
                  }
                } else {
                  {
#line 4523
                  tmp___110 = realloc((void *)result, memory_size___4);
#line 4523
                  memory___4 = (char *)tmp___110;
                  }
                }
#line 4523
                if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 4523
                  goto out_of_memory;
                }
#line 4523
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4523
                  if (length > 0UL) {
                    {
#line 4523
                    memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 4523
                result = memory___4;
              }
#line 4524
              goto __Cont;
            }
          }
#line 4822
          length += (size_t )count___0;
#line 4823
          goto while_break___14;
          __Cont: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
#line 1537
    cp = dp->dir_end;
#line 1537
    i ++;
#line 1537
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4830
  tmp___117 = xsum(length, (size_t )1);
  }
#line 4830
  if (tmp___117 > (size_t __attribute__((__pure__))  )allocated___0) {
#line 4830
    if (allocated___0 > 0UL) {
#line 4830
      if (allocated___0 <= 9223372036854775807UL) {
#line 4830
        tmp___112 = allocated___0 * 2UL;
      } else {
#line 4830
        tmp___112 = 0xffffffffffffffffUL;
      }
#line 4830
      allocated___0 = tmp___112;
    } else {
#line 4830
      allocated___0 = (size_t )12;
    }
    {
#line 4830
    tmp___114 = xsum(length, (size_t )1);
    }
#line 4830
    if (tmp___114 > (size_t __attribute__((__pure__))  )allocated___0) {
      {
#line 4830
      tmp___113 = xsum(length, (size_t )1);
#line 4830
      allocated___0 = (size_t )tmp___113;
      }
    }
#line 4830
    if (allocated___0 <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4830
      memory_size___5 = allocated___0 * sizeof(char );
    } else {
#line 4830
      memory_size___5 = 0xffffffffffffffffUL;
    }
#line 4830
    if (memory_size___5 == 0xffffffffffffffffUL) {
#line 4830
      goto out_of_memory;
    }
#line 4830
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 4830
      tmp___115 = malloc(memory_size___5);
#line 4830
      memory___5 = (char *)tmp___115;
      }
    } else
#line 4830
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 4830
      tmp___115 = malloc(memory_size___5);
#line 4830
      memory___5 = (char *)tmp___115;
      }
    } else {
      {
#line 4830
      tmp___116 = realloc((void *)result, memory_size___5);
#line 4830
      memory___5 = (char *)tmp___116;
      }
    }
#line 4830
    if ((unsigned long )memory___5 == (unsigned long )((void *)0)) {
#line 4830
      goto out_of_memory;
    }
#line 4830
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4830
      if (length > 0UL) {
        {
#line 4830
        memcpy((void */* __restrict  */)memory___5, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 4830
    result = memory___5;
  }
#line 4831
  *(result + length) = (char )'\000';
#line 4833
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 4833
    if (length + 1UL < allocated___0) {
      {
#line 4838
      tmp___118 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 4838
      memory___6 = (char *)tmp___118;
      }
#line 4839
      if ((unsigned long )memory___6 != (unsigned long )((void *)0)) {
#line 4840
        result = memory___6;
      }
    }
  }
#line 4843
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 4844
    free((void *)buf_malloced);
    }
  }
  {
#line 4845
  free((void *)d.dir);
  }
#line 4845
  if (a.arg) {
    {
#line 4845
    free((void *)a.arg);
    }
  }
#line 4846
  *lengthp = length;
#line 4851
  return (result);
  overflow: 
#line 4855
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 4855
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 4856
      free((void *)result);
      }
    }
  }
#line 4857
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 4858
    free((void *)buf_malloced);
    }
  }
  {
#line 4859
  free((void *)d.dir);
  }
#line 4859
  if (a.arg) {
    {
#line 4859
    free((void *)a.arg);
    }
  }
  {
#line 4860
  tmp___119 = __errno_location();
#line 4860
  *tmp___119 = 75;
  }
#line 4861
  return ((char *)((void *)0));
  out_of_memory: 
#line 4865
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 4865
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 4866
      free((void *)result);
      }
    }
  }
#line 4867
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 4868
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
  {
#line 4870
  free((void *)d.dir);
  }
#line 4870
  if (a.arg) {
    {
#line 4870
    free((void *)a.arg);
    }
  }
  {
#line 4871
  tmp___120 = __errno_location();
#line 4871
  *tmp___120 = 12;
  }
#line 4872
  return ((char *)((void *)0));
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimens.h"
int gl_futimens(int fd  __attribute__((__unused__)) , char const   *file , struct timespec  const  *timespec ) ;
#line 3
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 360 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd ,
                                                                                                char const   *__path ,
                                                                                                struct timespec  const  *__times ,
                                                                                                int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimens)(int __fd ,
                                                                               struct timespec  const  *__times ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 151
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimesat)(int __fd ,
                                                                                char const   *__file ,
                                                                                struct timeval  const  *__tvp ) ;
#line 77 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimens.c"
int gl_futimens(int fd  __attribute__((__unused__)) , char const   *file , struct timespec  const  *timespec ) 
{ 
  int result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int result___0 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  struct timeval timeval[2] ;
  struct timeval  const  *t ;
  int tmp___5 ;
  int tmp___6 ;
  int fd2 ;
  int tmp___7 ;
  int dup_errno ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 103
  if (fd < 0) {
    {
#line 105
    tmp = utimensat(-100, file, timespec, 0);
#line 105
    result = tmp;
    }
#line 114
    if (0 < result) {
      {
#line 115
      tmp___0 = __errno_location();
#line 115
      *tmp___0 = 38;
      }
    }
#line 118
    if (result == 0) {
#line 119
      return (result);
    } else {
      {
#line 118
      tmp___1 = __errno_location();
      }
#line 118
      if (*tmp___1 != 38) {
#line 119
        return (result);
      }
    }
  }
  {
#line 124
  tmp___2 = futimens(fd, timespec);
#line 124
  result___0 = tmp___2;
  }
#line 127
  if (0 < result___0) {
    {
#line 128
    tmp___3 = __errno_location();
#line 128
    *tmp___3 = 38;
    }
  }
#line 130
  if (result___0 == 0) {
#line 131
    return (result___0);
  } else {
    {
#line 130
    tmp___4 = __errno_location();
    }
#line 130
    if (*tmp___4 != 38) {
#line 131
      return (result___0);
    }
  }
#line 142
  if (timespec) {
#line 144
    timeval[0].tv_sec = (__time_t )(timespec + 0)->tv_sec;
#line 145
    timeval[0].tv_usec = (__suseconds_t )((timespec + 0)->tv_nsec / 1000L);
#line 146
    timeval[1].tv_sec = (__time_t )(timespec + 1)->tv_sec;
#line 147
    timeval[1].tv_usec = (__suseconds_t )((timespec + 1)->tv_nsec / 1000L);
#line 148
    t = (struct timeval  const  *)(timeval);
  } else {
#line 151
    t = (struct timeval  const  *)((void *)0);
  }
#line 153
  if (fd < 0) {
    {
#line 156
    tmp___5 = futimesat(-100, file, (struct timeval  const  *)t);
    }
#line 156
    return (tmp___5);
  } else {
    {
#line 172
    tmp___6 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    }
#line 172
    if (tmp___6 == 0) {
#line 173
      return (0);
    }
  }
#line 181
  if (! file) {
    {
#line 188
    tmp___10 = __errno_location();
    }
#line 188
    if (*tmp___10 == 38) {
      {
#line 190
      tmp___7 = dup(fd);
#line 190
      fd2 = tmp___7;
#line 191
      tmp___8 = __errno_location();
#line 191
      dup_errno = *tmp___8;
      }
#line 192
      if (0 <= fd2) {
        {
#line 193
        close(fd2);
        }
      }
      {
#line 194
      tmp___9 = __errno_location();
      }
#line 194
      if (fd2 < 0) {
#line 194
        if (dup_errno == 9) {
#line 194
          *tmp___9 = 9;
        } else {
#line 194
          *tmp___9 = 38;
        }
      } else {
#line 194
        *tmp___9 = 38;
      }
    }
#line 197
    return (-1);
  }
  {
#line 201
  tmp___11 = utimes(file, (struct timeval  const  *)t);
  }
#line 201
  return (tmp___11);
}
}
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 226
  tmp = gl_futimens(-1, file, timespec);
  }
#line 226
  return (tmp);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.h"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) ;
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/stat-time.h"
__inline static long get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 53
  return ((long )st->st_atim.tv_nsec);
}
}
#line 62 "/home/khheo/project/benchmark/coreutils-7.1/lib/stat-time.h"
__inline static long get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 66
  return ((long )st->st_ctim.tv_nsec);
}
}
#line 75 "/home/khheo/project/benchmark/coreutils-7.1/lib/stat-time.h"
__inline static long get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 79
  return ((long )st->st_mtim.tv_nsec);
}
}
#line 75 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static size_t dev_info_hash(void const   *x , size_t table_size ) 
{ 
  struct fs_res  const  *p ;

  {
#line 78
  p = (struct fs_res  const  *)x;
#line 87
  return ((size_t )(p->dev % (unsigned long const   )table_size));
}
}
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static _Bool dev_info_compare(void const   *x , void const   *y ) 
{ 
  struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
#line 94
  a = (struct fs_res  const  *)x;
#line 95
  b = (struct fs_res  const  *)y;
#line 96
  return ((_Bool )(a->dev == b->dev));
}
}
#line 141 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static Hash_table *ht  ;
#line 144 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static struct fs_res *new_dst_res  ;
#line 110 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) 
{ 
  time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long tmp ;
  int src_ns ;
  long tmp___0 ;
  struct fs_res *dst_res ;
  int res ;
  void *tmp___1 ;
  void *tmp___2 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long tmp___3 ;
  int dst_c_ns ;
  long tmp___4 ;
  int dst_m_ns ;
  _Bool odd_second ;
  int a ;
  int c ;
  int m ;
  int SR10 ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int tmp___5 ;
  int stat_result ;
  int tmp___6 ;
  long tmp___7 ;
  int old_res ;
  int a___0 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 131
  dst_s = (time_t )dst_stat->st_mtim.tv_sec;
#line 132
  src_s = (time_t )src_stat->st_mtim.tv_sec;
#line 133
  tmp = get_stat_mtime_ns(dst_stat);
#line 133
  dst_ns = (int )tmp;
#line 134
  tmp___0 = get_stat_mtime_ns(src_stat);
#line 134
  src_ns = (int )tmp___0;
  }
#line 136
  if (options & 1) {
#line 150
    if (! ht) {
      {
#line 151
      ht = hash_initialize((size_t )16, (Hash_tuning const   *)((void *)0), & dev_info_hash,
                           & dev_info_compare, (void (*)(void * ))(& free));
      }
    }
#line 152
    if (! new_dst_res) {
      {
#line 154
      tmp___1 = xmalloc(sizeof(*new_dst_res));
#line 154
      new_dst_res = (struct fs_res *)tmp___1;
#line 155
      new_dst_res->resolution = 2000000000;
#line 156
      new_dst_res->exact = (_Bool)0;
      }
    }
    {
#line 158
    new_dst_res->dev = (dev_t )dst_stat->st_dev;
#line 159
    tmp___2 = hash_insert(ht, (void const   *)new_dst_res);
#line 159
    dst_res = (struct fs_res *)tmp___2;
    }
#line 160
    if (! dst_res) {
      {
#line 161
      xalloc_die();
      }
    }
#line 163
    if ((unsigned long )dst_res == (unsigned long )new_dst_res) {
#line 167
      new_dst_res = (struct fs_res *)((void *)0);
    }
#line 170
    res = dst_res->resolution;
#line 172
    if (! dst_res->exact) {
      {
#line 177
      dst_a_s = (time_t )dst_stat->st_atim.tv_sec;
#line 178
      dst_c_s = (time_t )dst_stat->st_ctim.tv_sec;
#line 179
      dst_m_s = dst_s;
#line 180
      tmp___3 = get_stat_atime_ns(dst_stat);
#line 180
      dst_a_ns = (int )tmp___3;
#line 181
      tmp___4 = get_stat_ctime_ns(dst_stat);
#line 181
      dst_c_ns = (int )tmp___4;
#line 182
      dst_m_ns = dst_ns;
#line 191
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
#line 200
      a = dst_a_ns;
#line 201
      c = dst_c_ns;
#line 202
      m = dst_m_ns;
#line 206
      SR10 = 1000;
#line 206
      SR10 *= 10;
      }
#line 208
      if (((a % SR10 | c % SR10) | m % SR10) != 0) {
#line 209
        res = 1000;
      } else {
#line 211
        res = SR10;
#line 211
        a /= SR10;
#line 211
        c /= SR10;
#line 211
        m /= SR10;
        {
#line 211
        while (1) {
          while_continue: /* CIL Label */ ;
#line 211
          if (res < dst_res->resolution) {
#line 211
            if (! (((a % 10 | c % 10) | m % 10) == 0)) {
#line 211
              goto while_break;
            }
          } else {
#line 211
            goto while_break;
          }
#line 215
          if (res == 1000000000) {
#line 217
            if (! odd_second) {
#line 218
              res *= 2;
            }
#line 219
            goto while_break;
          }
#line 211
          res *= 10;
#line 211
          a /= 10;
#line 211
          c /= 10;
#line 211
          m /= 10;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 223
      dst_res->resolution = res;
#line 226
      if (1000 < res) {
#line 233
        src_ns -= src_ns % 1000;
#line 239
        s = src_s & (long )(~ (res == 2000000000));
#line 240
        if (src_s < dst_s) {
#line 241
          return (1);
        } else
#line 240
        if (src_s == dst_s) {
#line 240
          if (src_ns <= dst_ns) {
#line 241
            return (1);
          }
        }
#line 242
        if (dst_s < s) {
#line 244
          return (-1);
        } else
#line 242
        if (dst_s == s) {
#line 242
          if (dst_ns < src_ns - src_ns % res) {
#line 244
            return (-1);
          }
        }
#line 253
        timespec[0].tv_sec = dst_a_s;
#line 254
        timespec[0].tv_nsec = (__syscall_slong_t )dst_a_ns;
#line 255
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
#line 256
        timespec[1].tv_nsec = (__syscall_slong_t )(dst_m_ns + res / 9);
#line 261
        if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 263
          return (-2);
        } else {
          {
#line 261
          tmp___5 = utimens(dst_name, (struct timespec  const  *)(timespec));
          }
#line 261
          if (tmp___5 != 0) {
#line 263
            return (-2);
          }
        }
        {
#line 270
        tmp___6 = stat((char const   */* __restrict  */)dst_name, (struct stat */* __restrict  */)(& dst_status));
#line 270
        stat_result = tmp___6;
#line 272
        tmp___7 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
        }
#line 272
        if (((long )stat_result | (dst_status.st_mtim.tv_sec ^ dst_m_s)) | (tmp___7 ^ (long )dst_m_ns)) {
          {
#line 278
          timespec[1].tv_sec = dst_m_s;
#line 279
          timespec[1].tv_nsec = (__syscall_slong_t )dst_m_ns;
#line 280
          utimens(dst_name, (struct timespec  const  *)(timespec));
          }
        }
#line 283
        if (stat_result != 0) {
#line 284
          return (-2);
        }
        {
#line 290
        old_res = res;
#line 291
        tmp___8 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
#line 291
        a___0 = (int )(1000000000L * (dst_status.st_mtim.tv_sec & 1L) + tmp___8);
#line 294
        res = 1000;
#line 296
        a___0 /= res;
        }
        {
#line 296
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 296
          if (! (a___0 % 10 != 0)) {
#line 296
            goto while_break___0;
          }
#line 298
          if (res == 1000000000) {
#line 300
            res *= 2;
#line 301
            goto while_break___0;
          }
#line 303
          res *= 10;
#line 304
          if (res == old_res) {
#line 305
            goto while_break___0;
          }
#line 296
          a___0 /= 10;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 310
      dst_res->resolution = res;
#line 311
      dst_res->exact = (_Bool)1;
    }
#line 315
    src_s &= (long )(~ (res == 2000000000));
#line 316
    src_ns -= src_ns % res;
  }
#line 320
  if (dst_s < src_s) {
#line 320
    tmp___11 = -1;
  } else {
#line 320
    if (dst_s > src_s) {
#line 320
      tmp___10 = 1;
    } else {
#line 320
      if (dst_ns < src_ns) {
#line 320
        tmp___9 = -1;
      } else {
#line 320
        tmp___9 = dst_ns > src_ns;
      }
#line 320
      tmp___10 = tmp___9;
    }
#line 320
    tmp___11 = tmp___10;
  }
#line 320
  return (tmp___11);
}
}
#line 6 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.h"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
#line 77 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) ;
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_invalid_user  =    "invalid user";
#line 107 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_invalid_group  =    "invalid group";
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_bad_spec  =    "invalid spec";
#line 101 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) 
{ 
  char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;

  {
#line 115
  gname = (char *)((void *)0);
#line 116
  unum = *uid;
#line 117
  gnum = *gid;
#line 119
  error_msg = (char const   *)((void *)0);
#line 120
  tmp = (char *)((void *)0);
#line 120
  *groupname = tmp;
#line 120
  *username = tmp;
#line 126
  u = (char *)((void *)0);
#line 127
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 129
    if (*spec) {
      {
#line 130
      u = xstrdup(spec);
      }
    }
  } else {
#line 134
    ulen = (size_t )(separator - spec);
#line 135
    if (ulen != 0UL) {
      {
#line 137
      tmp___0 = xmemdup((void const   *)spec, ulen + 1UL);
#line 137
      u = (char *)tmp___0;
#line 138
      *(u + ulen) = (char )'\000';
      }
    }
  }
#line 142
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 142
    g = (char const   *)((void *)0);
  } else
#line 142
  if ((int const   )*(separator + 1) == 0) {
#line 142
    g = (char const   *)((void *)0);
  } else {
#line 142
    g = separator + 1;
  }
#line 155
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 158
    if ((int )*u == 43) {
#line 158
      pwd = (struct passwd *)((void *)0);
    } else {
      {
#line 158
      tmp___1 = getpwnam((char const   *)u);
#line 158
      pwd = tmp___1;
      }
    }
#line 159
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 161
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 161
        if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 161
          tmp___2 = 1;
        } else {
#line 161
          tmp___2 = 0;
        }
      } else {
#line 161
        tmp___2 = 0;
      }
#line 161
      use_login_group = (_Bool )tmp___2;
#line 162
      if (use_login_group) {
#line 166
        error_msg = E_bad_spec;
      } else {
        {
#line 171
        tmp___4 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp___3,
                           "");
        }
#line 171
        if ((unsigned int )tmp___4 == 0U) {
#line 171
          if (tmp___3 <= 4294967295UL) {
#line 173
            unum = (uid_t )tmp___3;
          } else {
#line 175
            error_msg = E_invalid_user;
          }
        } else {
#line 175
          error_msg = E_invalid_user;
        }
      }
    } else {
#line 180
      unum = pwd->pw_uid;
#line 181
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 181
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          {
#line 186
          gnum = pwd->pw_gid;
#line 187
          grp = getgrgid(gnum);
          }
#line 188
          if (grp) {
#line 188
            tmp___6 = grp->gr_name;
          } else {
            {
#line 188
            tmp___5 = umaxtostr((uintmax_t )gnum, buf___1);
#line 188
            tmp___6 = tmp___5;
            }
          }
          {
#line 188
          gname = xstrdup((char const   *)tmp___6);
#line 189
          endgrent();
          }
        }
      }
    }
    {
#line 192
    endpwent();
    }
  }
#line 195
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 195
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 199
      if ((int const   )*g == 43) {
#line 199
        grp = (struct group *)((void *)0);
      } else {
        {
#line 199
        tmp___7 = getgrnam(g);
#line 199
        grp = tmp___7;
        }
      }
#line 200
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
        {
#line 203
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, "");
        }
#line 203
        if ((unsigned int )tmp___9 == 0U) {
#line 203
          if (tmp___8 <= 4294967295UL) {
#line 204
            gnum = (gid_t )tmp___8;
          } else {
#line 206
            error_msg = E_invalid_group;
          }
        } else {
#line 206
          error_msg = E_invalid_group;
        }
      } else {
#line 209
        gnum = grp->gr_gid;
      }
      {
#line 210
      endgrent();
#line 211
      gname = xstrdup(g);
      }
    }
  }
#line 214
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 216
    *uid = unum;
#line 217
    *gid = gnum;
#line 218
    *username = u;
#line 219
    *groupname = gname;
#line 220
    u = (char *)((void *)0);
  } else {
    {
#line 223
    free((void *)gname);
    }
  }
  {
#line 225
  free((void *)u);
#line 226
  tmp___10 = gettext(error_msg);
  }
#line 226
  return ((char const   *)tmp___10);
}
}
#line 245 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) 
{ 
  char const   *colon ;
  char *tmp ;
  char const   *error_msg ;
  char const   *tmp___0 ;
  char const   *dot ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 249
  tmp = strchr(spec, ':');
#line 249
  colon = (char const   *)tmp;
#line 250
  tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
#line 250
  error_msg = tmp___0;
  }
#line 253
  if (! colon) {
#line 253
    if (error_msg) {
      {
#line 261
      tmp___1 = strchr(spec, '.');
#line 261
      dot = (char const   *)tmp___1;
      }
#line 262
      if (dot) {
        {
#line 262
        tmp___2 = parse_with_separator(spec, dot, uid, gid, username, groupname);
        }
#line 262
        if (! tmp___2) {
#line 264
          error_msg = (char const   *)((void *)0);
        }
      }
    }
  }
#line 267
  return (error_msg);
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.h"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
#line 40
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
#line 45
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 301 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 307 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistr.h"
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int tmp ;

  {
#line 310
  if (uc < 128U) {
#line 310
    if (n > 0) {
#line 312
      *(s + 0) = (uint8_t )uc;
#line 313
      return (1);
    } else {
      {
#line 316
      tmp = u8_uctomb_aux(s, uc, n);
      }
#line 316
      return (tmp);
    }
  } else {
    {
#line 316
    tmp = u8_uctomb_aux(s, uc, n);
    }
#line 316
    return (tmp);
  }
}
}
#line 71 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static int initialized___0  ;
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static int is_utf8  ;
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static iconv_t utf8_to_local  ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) 
{ 
  char inbuf[6] ;
  int count ;
  char const   *charset ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char outbuf[25] ;
  char const   *inptr ;
  size_t inbytesleft ;
  char *outptr ;
  size_t outbytesleft ;
  size_t res ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 80
  if (! initialized___0) {
    {
#line 82
    tmp = locale_charset();
#line 82
    charset = tmp;
#line 84
    tmp___0 = strcmp(charset, "UTF-8");
    }
#line 84
    if (tmp___0) {
#line 84
      tmp___1 = 0;
    } else {
#line 84
      tmp___1 = 1;
    }
#line 84
    is_utf8 = tmp___1;
#line 86
    if (! is_utf8) {
      {
#line 88
      utf8_to_local = iconv_open(charset, "UTF-8");
      }
#line 89
      if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
        {
#line 91
        utf8_to_local = iconv_open("ASCII", "UTF-8");
        }
      }
    }
#line 94
    initialized___0 = 1;
  }
#line 98
  if (! is_utf8) {
#line 101
    if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
      {
#line 102
      tmp___2 = (*failure)(code, "iconv function not usable", callback_arg);
      }
#line 102
      return (tmp___2);
    }
  }
  {
#line 109
  count = u8_uctomb((unsigned char *)(inbuf), code, (int )sizeof(inbuf));
  }
#line 110
  if (count < 0) {
    {
#line 111
    tmp___3 = (*failure)(code, "character out of range", callback_arg);
    }
#line 111
    return (tmp___3);
  }
#line 114
  if (! is_utf8) {
    {
#line 123
    inptr = (char const   *)(inbuf);
#line 124
    inbytesleft = (size_t )count;
#line 125
    outptr = outbuf;
#line 126
    outbytesleft = sizeof(outbuf);
#line 129
    res = iconv(utf8_to_local, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytesleft),
                (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytesleft));
    }
#line 132
    if (inbytesleft > 0UL) {
      {
#line 138
      tmp___4 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      }
#line 138
      return (tmp___4);
    } else
#line 132
    if (res == 0xffffffffffffffffUL) {
      {
#line 138
      tmp___4 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      }
#line 138
      return (tmp___4);
    }
    {
#line 145
    res = iconv(utf8_to_local, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytesleft));
    }
#line 146
    if (res == 0xffffffffffffffffUL) {
      {
#line 147
      tmp___5 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      }
#line 147
      return (tmp___5);
    }
    {
#line 150
    tmp___6 = (*success)((char const   *)(outbuf), (size_t )(outptr - outbuf), callback_arg);
    }
#line 150
    return (tmp___6);
  }
  {
#line 155
  tmp___7 = (*success)((char const   *)(inbuf), (size_t )count, callback_arg);
  }
#line 155
  return (tmp___7);
}
}
#line 160 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) 
{ 
  FILE *stream ;

  {
  {
#line 163
  stream = (FILE *)callback_arg;
#line 165
  fwrite((void const   */* __restrict  */)buf___1, (size_t )1, buflen, (FILE */* __restrict  */)stream);
  }
#line 166
  return (0L);
}
}
#line 170 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static long exit_failure_callback(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 174
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
#line 175
    tmp = gettext("cannot convert U+%04X to local character set");
#line 175
    error(1, 0, (char const   *)tmp, code);
    }
  } else {
    {
#line 177
    tmp___0 = gettext(msg);
#line 177
    tmp___1 = gettext("cannot convert U+%04X to local character set: %s");
#line 177
    error(1, 0, (char const   *)tmp___1, code, tmp___0);
    }
  }
#line 179
  return (-1L);
}
}
#line 184 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static long fallback_failure_callback(unsigned int code , char const   *msg  __attribute__((__unused__)) ,
                                      void *callback_arg ) 
{ 
  FILE *stream ;

  {
#line 189
  stream = (FILE *)callback_arg;
#line 191
  if (code < 65536U) {
    {
#line 192
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\\u%04X",
            code);
    }
  } else {
    {
#line 194
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\\U%08X",
            code);
    }
  }
#line 195
  return (-1L);
}
}
#line 201 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) 
{ 
  long (*tmp)(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) ;

  {
#line 204
  if (exit_on_error) {
#line 204
    tmp = & exit_failure_callback;
  } else {
#line 204
    tmp = & fallback_failure_callback;
  }
  {
#line 204
  unicode_to_mb(code, & fwrite_success_callback, tmp, (void *)stream);
  }
#line 209
  return;
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___1 + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0UL) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48UL - i % 10UL);
#line 41
      i /= 10UL;
#line 41
      if (! (i != 0UL)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48UL + i % 10UL);
#line 49
      i /= 10UL;
#line 49
      if (! (i != 0UL)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___1 + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0U) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48U - i % 10U);
#line 41
      i /= 10U;
#line 41
      if (! (i != 0U)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48U + i % 10U);
#line 49
      i /= 10U;
#line 49
      if (! (i != 0U)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 28
  if (uc < 128U) {
#line 30
    return (-2);
  } else
#line 31
  if (uc < 2048U) {
#line 32
    count = 2;
  } else
#line 33
  if (uc < 65536U) {
#line 35
    if (uc < 55296U) {
#line 36
      count = 3;
    } else
#line 35
    if (uc >= 57344U) {
#line 36
      count = 3;
    } else {
#line 38
      return (-1);
    }
  } else
#line 48
  if (uc < 1114112U) {
#line 49
    count = 4;
  } else {
#line 52
    return (-1);
  }
#line 54
  if (n < count) {
#line 55
    return (-2);
  }
  {
#line 63
  if (count == 4) {
#line 63
    goto case_4;
  }
#line 64
  if (count == 3) {
#line 64
    goto case_3;
  }
#line 65
  if (count == 2) {
#line 65
    goto case_2;
  }
#line 57
  goto switch_break;
  case_4: /* CIL Label */ 
#line 63
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 63
  uc >>= 6;
#line 63
  uc |= 65536U;
  case_3: /* CIL Label */ 
#line 64
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 64
  uc >>= 6;
#line 64
  uc |= 2048U;
  case_2: /* CIL Label */ 
#line 65
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 192U;
#line 66
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 68
  return (count);
}
}
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 130 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 115 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h"
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp___2 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
#line 118
  if (iter->next_done) {
#line 119
    return;
  }
#line 120
  if (iter->in_shift) {
#line 121
    goto with_shift;
  }
  {
#line 123
  tmp___6 = is_basic((char )*(iter->cur.ptr));
  }
#line 123
  if (tmp___6) {
#line 128
    iter->cur.bytes = (size_t )1;
#line 129
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 130
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 134
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 134
    if (! tmp___2) {
      {
#line 134
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h",
                    134U, "mbiter_multi_next");
      }
    }
#line 135
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 137
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 139
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 142
      iter->cur.bytes = (size_t )1;
#line 143
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 147
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 150
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 157
      if (iter->cur.bytes == 0UL) {
#line 160
        iter->cur.bytes = (size_t )1;
#line 161
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 161
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h",
                        161U, "mbiter_multi_next");
          }
        }
#line 162
        if (! (iter->cur.wc == 0)) {
          {
#line 162
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/coreutils-7.1/lib/mbiter.h",
                        162U, "mbiter_multi_next");
          }
        }
      }
      {
#line 164
      iter->cur.wc_valid = (_Bool)1;
#line 168
      tmp___5 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 168
      if (tmp___5) {
#line 169
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 172
  iter->next_done = (_Bool)1;
#line 173
  return;
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int state___0 ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state___0 = 0;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state___0 == 0) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 77
              state___0 = 0;
#line 78
              goto __Cont;
            }
          }
        }
#line 81
        if (state___0 == 0) {
#line 81
          if (i.cur.wc_valid) {
            {
#line 81
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 81
            if (! tmp___4) {
#line 83
              state___0 = 1;
#line 84
              goto __Cont;
            }
          } else {
#line 83
            state___0 = 1;
#line 84
            goto __Cont;
          }
        }
#line 87
        if (state___0 == 1) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (! tmp___5) {
#line 89
              state___0 = 1;
#line 90
              goto __Cont;
            }
          } else {
#line 89
            state___0 = 1;
#line 90
            goto __Cont;
          }
        }
#line 93
        if (state___0 == 1) {
#line 93
          if (i.cur.wc_valid) {
            {
#line 93
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 93
            if (tmp___7) {
#line 95
              state___0 = 2;
#line 96
              r = (char *)i.cur.ptr;
            } else {
#line 93
              goto _L;
            }
          } else {
#line 93
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 98
        if (state___0 == 2) {
#line 98
          if (i.cur.wc_valid) {
            {
#line 98
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 98
            if (tmp___6) {
#line 100
              state___0 = 2;
            } else {
#line 104
              state___0 = 1;
            }
          } else {
#line 104
            state___0 = 1;
          }
        } else {
#line 104
          state___0 = 1;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 108
      if (state___0 == 2) {
#line 109
        *r = (char )'\000';
      }
    }
  } else {
#line 117
    if (how != 0) {
#line 118
      p = d;
      {
#line 118
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 118
        if (*p) {
          {
#line 118
          tmp___8 = __ctype_b_loc();
          }
#line 118
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 118
            goto while_break___1;
          }
        } else {
#line 118
          goto while_break___1;
        }
#line 118
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 121
      tmp___9 = strlen((char const   *)p);
#line 121
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 125
    if (how != 1) {
      {
#line 126
      tmp___10 = strlen((char const   *)d);
#line 126
      p = (d + tmp___10) - 1;
      }
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 126
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 126
          tmp___11 = __ctype_b_loc();
          }
#line 126
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 126
            goto while_break___2;
          }
        } else {
#line 126
          goto while_break___2;
        }
#line 127
        *p = (char )'\000';
#line 126
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 131
  return (d);
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.h"
int gen_tempname(char *tmpl , int kind ) ;
#line 41
int gen_tempname_len(char *tmpl , int kind , size_t x_suffix_len ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.h"
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) ;
#line 38
randint randint_genmax(struct randint_source *s , randint genmax ) ;
#line 49
int randint_all_free(struct randint_source *s ) ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 155 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
__inline static _Bool check_x_suffix(char const   *s , size_t len ) 
{ 
  size_t tmp ;

  {
  {
#line 158
  tmp = strspn(s, "X");
  }
#line 158
  return ((_Bool )(tmp == len));
}
}
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
static char const   letters[63]  = 
#line 162
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 179 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
int gen_tempname_len(char *tmpl , int kind , size_t x_suffix_len ) 
{ 
  size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  size_t i ;
  randint tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 185
  fd = -1;
#line 186
  tmp = __errno_location();
#line 186
  save_errno = *tmp;
#line 203
  attempts = 238328U;
#line 206
  len = strlen((char const   *)tmpl);
  }
#line 207
  if (len < x_suffix_len) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    *tmp___0 = 22;
    }
#line 211
    return (-1);
  } else {
    {
#line 207
    tmp___1 = check_x_suffix((char const   *)(tmpl + (len - x_suffix_len)), x_suffix_len);
    }
#line 207
    if (! tmp___1) {
      {
#line 210
      tmp___0 = __errno_location();
#line 210
      *tmp___0 = 22;
      }
#line 211
      return (-1);
    }
  }
  {
#line 214
  rand_src = randint_all_new((char const   *)((void *)0), (size_t )8);
  }
#line 215
  if (! rand_src) {
#line 216
    return (-1);
  }
#line 219
  XXXXXX = tmpl + (len - x_suffix_len);
#line 221
  count = 0U;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (count < attempts)) {
#line 221
      goto while_break;
    }
#line 225
    i = (size_t )0;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! (i < x_suffix_len)) {
#line 225
        goto while_break___0;
      }
      {
#line 227
      tmp___2 = randint_genmax(rand_src, sizeof(letters) - 2UL);
#line 227
      *(XXXXXX + i) = (char )letters[tmp___2];
#line 225
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 232
    if (kind == 0) {
#line 232
      goto case_0;
    }
#line 236
    if (kind == 1) {
#line 236
      goto case_1;
    }
#line 240
    if (kind == 2) {
#line 240
      goto case_2;
    }
#line 244
    if (kind == 3) {
#line 244
      goto case_3;
    }
#line 266
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 233
    fd = open((char const   *)tmpl, 194, 384);
    }
#line 234
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 237
    fd = open((char const   *)tmpl, 194, 384);
    }
#line 238
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 241
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    }
#line 242
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 249
    tmp___5 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
    }
#line 249
    if (tmp___5 < 0) {
      {
#line 251
      tmp___4 = __errno_location();
      }
#line 251
      if (*tmp___4 == 2) {
        {
#line 253
        tmp___3 = __errno_location();
#line 253
        *tmp___3 = save_errno;
#line 254
        fd = 0;
        }
#line 255
        goto done;
      } else {
#line 260
        fd = -1;
#line 261
        goto done;
      }
    }
#line 264
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 267
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c",
                  267U, "gen_tempname_len");
    }
    switch_break: /* CIL Label */ ;
    }
#line 270
    if (fd >= 0) {
      {
#line 272
      tmp___6 = __errno_location();
#line 272
      *tmp___6 = save_errno;
      }
#line 273
      goto done;
    } else {
      {
#line 275
      tmp___7 = __errno_location();
      }
#line 275
      if (*tmp___7 != 17) {
#line 277
        fd = -1;
#line 278
        goto done;
      }
    }
    __Cont: /* CIL Label */ 
#line 221
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  randint_all_free(rand_src);
#line 285
  tmp___8 = __errno_location();
#line 285
  *tmp___8 = 17;
  }
#line 286
  return (-1);
  done: 
  {
#line 290
  tmp___9 = __errno_location();
#line 290
  saved_errno = *tmp___9;
#line 291
  randint_all_free(rand_src);
#line 292
  tmp___10 = __errno_location();
#line 292
  *tmp___10 = saved_errno;
  }
#line 294
  return (fd);
}
}
#line 297 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
int gen_tempname(char *tmpl , int kind ) 
{ 
  int tmp ;

  {
  {
#line 300
  tmp = gen_tempname_len(tmpl, kind, (size_t )6);
  }
#line 300
  return (tmp);
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnumcmp.h"
int strnumcmp(char const   *a , char const   *b , int decimal_point___0 , int thousands_sep___0 ) ;
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnumcmp-in.h"
__inline static int fraccompare(char const   *a , char const   *b , char decimal_point___0 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 77
  if ((int const   )*a == (int const   )decimal_point___0) {
#line 77
    if ((int const   )*b == (int const   )decimal_point___0) {
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;
#line 79
        a ++;
#line 79
        b ++;
#line 79
        if (! ((int const   )*a == (int const   )*b)) {
#line 79
          goto while_break;
        }
#line 80
        if (! ((unsigned int )*a - 48U <= 9U)) {
#line 81
          return (0);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 82
      if ((unsigned int )*a - 48U <= 9U) {
#line 82
        if ((unsigned int )*b - 48U <= 9U) {
#line 83
          return ((int )((int const   )*a - (int const   )*b));
        }
      }
#line 84
      if ((unsigned int )*a - 48U <= 9U) {
#line 85
        goto a_trailing_nonzero;
      }
#line 86
      if ((unsigned int )*b - 48U <= 9U) {
#line 87
        goto b_trailing_nonzero;
      }
#line 88
      return (0);
    } else {
#line 77
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 90
    tmp___0 = a;
#line 90
    a ++;
#line 90
    if ((int const   )*tmp___0 == (int const   )decimal_point___0) {
      a_trailing_nonzero: 
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (! ((int const   )*a == 48)) {
#line 93
          goto while_break___0;
        }
#line 94
        a ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 95
      return ((unsigned int )*a - 48U <= 9U);
    } else {
#line 97
      tmp = b;
#line 97
      b ++;
#line 97
      if ((int const   )*tmp == (int const   )decimal_point___0) {
        b_trailing_nonzero: 
        {
#line 100
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 100
          if (! ((int const   )*b == 48)) {
#line 100
            goto while_break___1;
          }
#line 101
          b ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 102
        return (- ((unsigned int )*b - 48U <= 9U));
      }
    }
  }
#line 104
  return (0);
}
}
#line 114 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnumcmp-in.h"
__inline static int numcompare(char const   *a , char const   *b , int decimal_point___0 ,
                               int thousands_sep___0 ) 
{ 
  unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 118
  tmpa = (unsigned char )*a;
#line 119
  tmpb = (unsigned char )*b;
#line 124
  if ((int )tmpa == 45) {
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 127
      a ++;
#line 127
      tmpa = (unsigned char )*a;
#line 126
      if (! ((int )tmpa == 48)) {
#line 126
        if (! ((int )tmpa == thousands_sep___0)) {
#line 126
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    if ((int )tmpb != 45) {
#line 131
      if ((int )tmpa == decimal_point___0) {
        {
#line 132
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 133
          a ++;
#line 133
          tmpa = (unsigned char )*a;
#line 132
          if (! ((int )tmpa == 48)) {
#line 132
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 135
      if ((unsigned int )tmpa - 48U <= 9U) {
#line 136
        return (-1);
      }
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (! ((int )tmpb == 48)) {
#line 137
          if (! ((int )tmpb == thousands_sep___0)) {
#line 137
            goto while_break___1;
          }
        }
#line 138
        b ++;
#line 138
        tmpb = (unsigned char )*b;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 139
      if ((int )tmpb == decimal_point___0) {
        {
#line 140
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 141
          b ++;
#line 141
          tmpb = (unsigned char )*b;
#line 140
          if (! ((int )tmpb == 48)) {
#line 140
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 143
      return (- ((unsigned int )tmpb - 48U <= 9U));
    }
    {
#line 145
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 146
      b ++;
#line 146
      tmpb = (unsigned char )*b;
#line 145
      if (! ((int )tmpb == 48)) {
#line 145
        if (! ((int )tmpb == thousands_sep___0)) {
#line 145
          goto while_break___3;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 149
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 149
      if ((int )tmpa == (int )tmpb) {
#line 149
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 149
          goto while_break___4;
        }
      } else {
#line 149
        goto while_break___4;
      }
      {
#line 151
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 152
        a ++;
#line 152
        tmpa = (unsigned char )*a;
#line 151
        if (! ((int )tmpa == thousands_sep___0)) {
#line 151
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 154
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 155
        b ++;
#line 155
        tmpb = (unsigned char )*b;
#line 154
        if (! ((int )tmpb == thousands_sep___0)) {
#line 154
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 159
    if ((int )tmpa == decimal_point___0) {
#line 159
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point___0);
        }
#line 161
        return (tmp___0);
      } else {
#line 159
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 159
    if ((int )tmpb == decimal_point___0) {
#line 159
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
        {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point___0);
        }
#line 161
        return (tmp___0);
      }
    }
#line 163
    tmp = (int )tmpb - (int )tmpa;
#line 165
    log_a = (size_t )0;
    {
#line 165
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 165
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 165
        goto while_break___7;
      }
      {
#line 166
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 167
        a ++;
#line 167
        tmpa = (unsigned char )*a;
#line 166
        if (! ((int )tmpa == thousands_sep___0)) {
#line 166
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 165
      log_a ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 170
    log_b = (size_t )0;
    {
#line 170
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 170
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 170
        goto while_break___9;
      }
      {
#line 171
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 172
        b ++;
#line 172
        tmpb = (unsigned char )*b;
#line 171
        if (! ((int )tmpb == thousands_sep___0)) {
#line 171
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 170
      log_b ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 175
    if (log_a != log_b) {
#line 176
      if (log_a < log_b) {
#line 176
        tmp___1 = 1;
      } else {
#line 176
        tmp___1 = -1;
      }
#line 176
      return (tmp___1);
    }
#line 178
    if (! log_a) {
#line 179
      return (0);
    }
#line 181
    return (tmp);
  } else
#line 183
  if ((int )tmpb == 45) {
    {
#line 185
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 186
      b ++;
#line 186
      tmpb = (unsigned char )*b;
#line 185
      if (! ((int )tmpb == 48)) {
#line 185
        if (! ((int )tmpb == thousands_sep___0)) {
#line 185
          goto while_break___11;
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 188
    if ((int )tmpb == decimal_point___0) {
      {
#line 189
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 190
        b ++;
#line 190
        tmpb = (unsigned char )*b;
#line 189
        if (! ((int )tmpb == 48)) {
#line 189
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 192
    if ((unsigned int )tmpb - 48U <= 9U) {
#line 193
      return (1);
    }
    {
#line 194
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 194
      if (! ((int )tmpa == 48)) {
#line 194
        if (! ((int )tmpa == thousands_sep___0)) {
#line 194
          goto while_break___13;
        }
      }
#line 195
      a ++;
#line 195
      tmpa = (unsigned char )*a;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 196
    if ((int )tmpa == decimal_point___0) {
      {
#line 197
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 198
        a ++;
#line 198
        tmpa = (unsigned char )*a;
#line 197
        if (! ((int )tmpa == 48)) {
#line 197
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 200
    return ((unsigned int )tmpa - 48U <= 9U);
  } else {
    {
#line 204
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 204
      if (! ((int )tmpa == 48)) {
#line 204
        if (! ((int )tmpa == thousands_sep___0)) {
#line 204
          goto while_break___15;
        }
      }
#line 205
      a ++;
#line 205
      tmpa = (unsigned char )*a;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 206
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 206
      if (! ((int )tmpb == 48)) {
#line 206
        if (! ((int )tmpb == thousands_sep___0)) {
#line 206
          goto while_break___16;
        }
      }
#line 207
      b ++;
#line 207
      tmpb = (unsigned char )*b;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 209
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 209
      if ((int )tmpa == (int )tmpb) {
#line 209
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 209
          goto while_break___17;
        }
      } else {
#line 209
        goto while_break___17;
      }
      {
#line 211
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 212
        a ++;
#line 212
        tmpa = (unsigned char )*a;
#line 211
        if (! ((int )tmpa == thousands_sep___0)) {
#line 211
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 214
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 215
        b ++;
#line 215
        tmpb = (unsigned char )*b;
#line 214
        if (! ((int )tmpb == thousands_sep___0)) {
#line 214
          goto while_break___19;
        }
      }
      while_break___19: /* CIL Label */ ;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
#line 219
    if ((int )tmpa == decimal_point___0) {
#line 219
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point___0);
        }
#line 221
        return (tmp___2);
      } else {
#line 219
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 219
    if ((int )tmpb == decimal_point___0) {
#line 219
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
        {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point___0);
        }
#line 221
        return (tmp___2);
      }
    }
#line 223
    tmp = (int )tmpa - (int )tmpb;
#line 225
    log_a = (size_t )0;
    {
#line 225
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 225
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 225
        goto while_break___20;
      }
      {
#line 226
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 227
        a ++;
#line 227
        tmpa = (unsigned char )*a;
#line 226
        if (! ((int )tmpa == thousands_sep___0)) {
#line 226
          goto while_break___21;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
#line 225
      log_a ++;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 230
    log_b = (size_t )0;
    {
#line 230
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 230
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 230
        goto while_break___22;
      }
      {
#line 231
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 232
        b ++;
#line 232
        tmpb = (unsigned char )*b;
#line 231
        if (! ((int )tmpb == thousands_sep___0)) {
#line 231
          goto while_break___23;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
#line 230
      log_b ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 235
    if (log_a != log_b) {
#line 236
      if (log_a < log_b) {
#line 236
        tmp___3 = -1;
      } else {
#line 236
        tmp___3 = 1;
      }
#line 236
      return (tmp___3);
    }
#line 238
    if (! log_a) {
#line 239
      return (0);
    }
#line 241
    return (tmp);
  }
}
}
#line 26 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnumcmp.c"
int strnumcmp(char const   *a , char const   *b , int decimal_point___0 , int thousands_sep___0 ) 
{ 
  int tmp ;

  {
  {
#line 30
  tmp = numcompare(a, b, decimal_point___0, thousands_sep___0);
  }
#line 30
  return (tmp);
}
}
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 67 "/home/khheo/project/benchmark/coreutils-7.1/lib/dirname.h"
_Bool strip_trailing_slashes(char *file ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 32
  tmp = last_component((char const   *)file);
#line 32
  base = tmp;
  }
#line 38
  if (! *base) {
#line 39
    base = file;
  }
  {
#line 40
  tmp___0 = base_len((char const   *)base);
#line 40
  base_lim = base + tmp___0;
#line 41
  had_slash = (_Bool )((int )*base_lim != 0);
#line 42
  *base_lim = (char )'\000';
  }
#line 43
  return (had_slash);
}
}
#line 1 "/home/khheo/project/benchmark/coreutils-7.1/lib/strnumcmp.h"
int strintcmp(char const   *a , char const   *b ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/strintcmp.c"
int strintcmp(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
  {
#line 31
  tmp = numcompare(a, b, -1, -1);
  }
#line 31
  return (tmp);
}
}
#line 51 "/usr/include/iconv.h"
extern int iconv_close(iconv_t __cd ) ;
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 55
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (insize > 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 72
    res = tmp___0;
    }
#line 76
    if (res == 0xffffffffffffffffUL) {
      {
#line 78
      tmp___2 = __errno_location();
      }
#line 78
      if (! (*tmp___2 == 7)) {
        {
#line 80
        tmp___1 = __errno_location();
        }
#line 80
        if (*tmp___1 == 22) {
#line 81
          goto while_break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  outptr___0 = tmp.buf;
#line 103
  outsize___0 = (size_t )4096;
#line 104
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 104
  res___0 = tmp___3;
  }
#line 106
  if (res___0 == 0xffffffffffffffffUL) {
#line 107
    return (-1);
  }
#line 108
  count += (size_t )(outptr___0 - tmp.buf);
#line 111
  length = count;
#line 115
  if (length == 0UL) {
#line 117
    *lengthp = (size_t )0;
#line 118
    return (0);
  }
#line 120
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 120
    if (*lengthp >= length) {
#line 121
      result = *resultp;
    } else {
#line 120
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 124
    tmp___4 = malloc(length);
#line 124
    result = (char *)tmp___4;
    }
#line 125
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 127
      tmp___5 = __errno_location();
#line 127
      *tmp___5 = 12;
      }
#line 128
      return (-1);
    }
  }
  {
#line 136
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 141
  inptr___0 = src;
#line 142
  insize___0 = srclen;
#line 143
  outptr___1 = result;
#line 144
  outsize___1 = length;
  }
  {
#line 146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 146
    if (! (insize___0 > 0UL)) {
#line 146
      goto while_break___0;
    }
    {
#line 148
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 148
    res___1 = tmp___6;
    }
#line 152
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 154
      tmp___7 = __errno_location();
      }
#line 154
      if (*tmp___7 == 22) {
#line 155
        goto while_break___0;
      } else {
#line 157
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 175
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 175
  res___2 = tmp___8;
  }
#line 177
  if (res___2 == 0xffffffffffffffffUL) {
#line 178
    goto fail;
  }
#line 181
  if (outsize___1 != 0UL) {
    {
#line 182
    abort();
    }
  }
#line 185
  *resultp = result;
#line 186
  *lengthp = length;
#line 188
  return (0);
  fail: 
#line 192
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 194
    tmp___9 = __errno_location();
#line 194
    saved_errno = *tmp___9;
#line 195
    free((void *)result);
#line 196
    tmp___10 = __errno_location();
#line 196
    *tmp___10 = saved_errno;
    }
  }
#line 198
  return (-1);
}
}
#line 203 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used___0 ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___1 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 253
  inptr = src;
#line 254
  tmp = strlen(src);
#line 254
  inbytes_remaining = tmp;
#line 259
  result_size = inbytes_remaining;
#line 261
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 262
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 263
    result_size *= 16UL;
  }
  {
#line 265
  result_size ++;
#line 267
  tmp___0 = malloc(result_size);
#line 267
  result = (char *)tmp___0;
  }
#line 268
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 270
    tmp___1 = __errno_location();
#line 270
    *tmp___1 = 12;
    }
#line 271
    return ((char *)((void *)0));
  }
  {
#line 278
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 283
  outptr = result;
#line 284
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 290
    res = tmp___2;
    }
#line 294
    if (res == 0xffffffffffffffffUL) {
      {
#line 296
      tmp___7 = __errno_location();
      }
#line 296
      if (*tmp___7 == 22) {
#line 297
        goto while_break;
      } else {
        {
#line 298
        tmp___6 = __errno_location();
        }
#line 298
        if (*tmp___6 == 7) {
#line 300
          used___0 = (size_t )(outptr - result);
#line 301
          newsize = result_size * 2UL;
#line 304
          if (! (newsize > result_size)) {
            {
#line 306
            tmp___3 = __errno_location();
#line 306
            *tmp___3 = 12;
            }
#line 307
            goto failed;
          }
          {
#line 309
          tmp___4 = realloc((void *)result, newsize);
#line 309
          newresult = (char *)tmp___4;
          }
#line 310
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 312
            tmp___5 = __errno_location();
#line 312
            *tmp___5 = 12;
            }
#line 313
            goto failed;
          }
#line 315
          result = newresult;
#line 316
          result_size = newsize;
#line 317
          outptr = result + used___0;
#line 318
          outbytes_remaining = (result_size - 1UL) - used___0;
        } else {
#line 321
          goto failed;
        }
      }
    } else {
#line 324
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 332
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 332
    res___0 = tmp___8;
    }
#line 334
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 336
      tmp___12 = __errno_location();
      }
#line 336
      if (*tmp___12 == 7) {
#line 338
        used___1 = (size_t )(outptr - result);
#line 339
        newsize___0 = result_size * 2UL;
#line 342
        if (! (newsize___0 > result_size)) {
          {
#line 344
          tmp___9 = __errno_location();
#line 344
          *tmp___9 = 12;
          }
#line 345
          goto failed;
        }
        {
#line 347
        tmp___10 = realloc((void *)result, newsize___0);
#line 347
        newresult___0 = (char *)tmp___10;
        }
#line 348
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 350
          tmp___11 = __errno_location();
#line 350
          *tmp___11 = 12;
          }
#line 351
          goto failed;
        }
#line 353
        result = newresult___0;
#line 354
        result_size = newsize___0;
#line 355
        outptr = result + used___1;
#line 356
        outbytes_remaining = (result_size - 1UL) - used___1;
      } else {
#line 359
        goto failed;
      }
    } else {
#line 362
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 367
  tmp___13 = outptr;
#line 367
  outptr ++;
#line 367
  *tmp___13 = (char )'\000';
#line 369
  length = (size_t )(outptr - result);
#line 373
  if (length < result_size) {
    {
#line 375
    tmp___14 = realloc((void *)result, length);
#line 375
    smaller_result = (char *)tmp___14;
    }
#line 377
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 378
      result = smaller_result;
    }
  }
#line 381
  return (result);
  failed: 
  {
#line 385
  tmp___15 = __errno_location();
#line 385
  saved_errno = *tmp___15;
#line 386
  free((void *)result);
#line 387
  tmp___16 = __errno_location();
#line 387
  *tmp___16 = saved_errno;
  }
#line 388
  return ((char *)((void *)0));
}
}
#line 396 "/home/khheo/project/benchmark/coreutils-7.1/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 399
  if ((int const   )*src == 0) {
#line 399
    goto _L;
  } else {
    {
#line 399
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 399
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 401
      tmp = strdup(src);
#line 401
      result = tmp;
      }
#line 403
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 404
        tmp___0 = __errno_location();
#line 404
        *tmp___0 = 12;
        }
      }
#line 405
      return (result);
    } else {
      {
#line 422
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 423
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 424
        return ((char *)((void *)0));
      }
      {
#line 426
      result___0 = str_cd_iconv(src, cd);
      }
#line 428
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 431
        tmp___1 = __errno_location();
#line 431
        saved_errno = *tmp___1;
#line 432
        iconv_close(cd);
#line 433
        tmp___2 = __errno_location();
#line 433
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 437
        tmp___5 = iconv_close(cd);
        }
#line 437
        if (tmp___5 < 0) {
          {
#line 441
          tmp___3 = __errno_location();
#line 441
          saved_errno___0 = *tmp___3;
#line 442
          free((void *)result___0);
#line 443
          tmp___4 = __errno_location();
#line 443
          *tmp___4 = saved_errno___0;
          }
#line 444
          return ((char *)((void *)0));
        }
      }
#line 447
      return (result___0);
    }
  }
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 302 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    tmp___0 = len;
#line 306
    len --;
#line 306
    if (! (tmp___0 > 0UL)) {
#line 306
      goto while_break;
    }
    {
#line 307
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 307
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (dest);
}
}
#line 311 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    tmp___0 = len;
#line 315
    len --;
#line 315
    if (! (tmp___0 > 0UL)) {
#line 315
      goto while_break;
    }
    {
#line 316
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 316
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (dest);
}
}
#line 406 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year___1 ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;

  {
#line 419
  hour12 = (int )tp->tm_hour;
#line 444
  i = (size_t )0;
#line 445
  p = s;
#line 460
  zone = (char const   *)((void *)0);
#line 468
  zone = (char const   *)tp->tm_zone;
#line 486
  if (hour12 > 12) {
#line 487
    hour12 -= 12;
  } else
#line 489
  if (hour12 == 0) {
#line 490
    hour12 = 12;
  }
#line 492
  f = format;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((int const   )*f != 0)) {
#line 492
      goto while_break;
    }
#line 494
    pad = 0;
#line 496
    digits = 0;
#line 510
    width = -1;
#line 511
    to_lowcase = (_Bool)0;
#line 512
    to_uppcase = upcase;
#line 514
    change_case = (_Bool)0;
#line 597
    if ((int const   )*f != 37) {
      {
#line 599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 599
        _n = 1;
#line 599
        _delta = width - _n;
#line 599
        if (_delta > 0) {
#line 599
          tmp = _delta;
        } else {
#line 599
          tmp = 0;
        }
#line 599
        _incr = _n + tmp;
#line 599
        if ((size_t )_incr >= maxsize - i) {
#line 599
          return ((size_t )0);
        }
#line 599
        if (p) {
#line 599
          if (digits == 0) {
#line 599
            if (_delta > 0) {
#line 599
              if (pad == 48) {
                {
#line 599
                memset((void *)p, '0', (size_t )_delta);
#line 599
                p += _delta;
                }
              } else {
                {
#line 599
                memset((void *)p, ' ', (size_t )_delta);
#line 599
                p += _delta;
                }
              }
            }
          }
#line 599
          *p = (char )*f;
#line 599
          p += _n;
        }
#line 599
        i += (size_t )_incr;
#line 599
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 600
      goto __Cont;
    }
    {
#line 606
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 608
      f ++;
      {
#line 613
      if ((int const   )*f == 48) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 45) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 95) {
#line 613
        goto case_48;
      }
#line 618
      if ((int const   )*f == 94) {
#line 618
        goto case_94;
      }
#line 621
      if ((int const   )*f == 35) {
#line 621
        goto case_35;
      }
#line 625
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 614
      pad = (int )*f;
#line 615
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 619
      to_uppcase = (_Bool)1;
#line 620
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 622
      change_case = (_Bool)1;
#line 623
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 626
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 628
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 632
    if ((unsigned int )*f - 48U <= 9U) {
#line 634
      width = 0;
      {
#line 635
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 637
        if (width > 214748364) {
#line 640
          width = 2147483647;
        } else
#line 637
        if (width == 214748364) {
#line 637
          if ((int const   )*f - 48 > 7) {
#line 640
            width = 2147483647;
          } else {
#line 643
            width *= 10;
#line 644
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 643
          width *= 10;
#line 644
          width += (int )((int const   )*f - 48);
        }
#line 646
        f ++;
#line 635
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 635
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 655
    if ((int const   )*f == 79) {
#line 655
      goto case_79;
    }
#line 655
    if ((int const   )*f == 69) {
#line 655
      goto case_79;
    }
#line 659
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 656
    tmp___0 = f;
#line 656
    f ++;
#line 656
    modifier = (int )*tmp___0;
#line 657
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 660
    modifier = 0;
#line 661
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 665
    format_char = (int )*f;
    {
#line 688
    if (format_char == 37) {
#line 688
      goto case_37;
    }
#line 694
    if (format_char == 97) {
#line 694
      goto case_97;
    }
#line 709
    if (format_char == 65) {
#line 709
      goto case_65;
    }
#line 725
    if (format_char == 104) {
#line 725
      goto case_104;
    }
#line 725
    if (format_char == 98) {
#line 725
      goto case_104;
    }
#line 740
    if (format_char == 66) {
#line 740
      goto case_66;
    }
#line 755
    if (format_char == 99) {
#line 755
      goto case_99;
    }
#line 814
    if (format_char == 67) {
#line 814
      goto case_67;
    }
#line 843
    if (format_char == 120) {
#line 843
      goto case_120;
    }
#line 856
    if (format_char == 68) {
#line 856
      goto case_68;
    }
#line 862
    if (format_char == 100) {
#line 862
      goto case_100;
    }
#line 868
    if (format_char == 101) {
#line 868
      goto case_101;
    }
#line 994
    if (format_char == 70) {
#line 994
      goto case_70;
    }
#line 1000
    if (format_char == 72) {
#line 1000
      goto case_72;
    }
#line 1006
    if (format_char == 73) {
#line 1006
      goto case_73;
    }
#line 1012
    if (format_char == 107) {
#line 1012
      goto case_107;
    }
#line 1018
    if (format_char == 108) {
#line 1018
      goto case_108;
    }
#line 1024
    if (format_char == 106) {
#line 1024
      goto case_106;
    }
#line 1030
    if (format_char == 77) {
#line 1030
      goto case_77;
    }
#line 1036
    if (format_char == 109) {
#line 1036
      goto case_109;
    }
#line 1043
    if (format_char == 78) {
#line 1043
      goto case_78;
    }
#line 1061
    if (format_char == 110) {
#line 1061
      goto case_110;
    }
#line 1065
    if (format_char == 80) {
#line 1065
      goto case_80;
    }
#line 1072
    if (format_char == 112) {
#line 1072
      goto case_112;
    }
#line 1085
    if (format_char == 82) {
#line 1085
      goto case_82;
    }
#line 1089
    if (format_char == 114) {
#line 1089
      goto case_114;
    }
#line 1100
    if (format_char == 83) {
#line 1100
      goto case_83;
    }
#line 1106
    if (format_char == 115) {
#line 1106
      goto case_115;
    }
#line 1133
    if (format_char == 88) {
#line 1133
      goto case_88;
    }
#line 1146
    if (format_char == 84) {
#line 1146
      goto case_84;
    }
#line 1150
    if (format_char == 116) {
#line 1150
      goto case_116;
    }
#line 1154
    if (format_char == 117) {
#line 1154
      goto case_117;
    }
#line 1157
    if (format_char == 85) {
#line 1157
      goto case_85;
    }
#line 1165
    if (format_char == 71) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 103) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 86) {
#line 1165
      goto case_71;
    }
#line 1221
    if (format_char == 87) {
#line 1221
      goto case_87;
    }
#line 1227
    if (format_char == 119) {
#line 1227
      goto case_119;
    }
#line 1233
    if (format_char == 89) {
#line 1233
      goto case_89;
    }
#line 1257
    if (format_char == 121) {
#line 1257
      goto case_121;
    }
#line 1280
    if (format_char == 90) {
#line 1280
      goto case_90;
    }
#line 1309
    if (format_char == 58) {
#line 1309
      goto case_58;
    }
#line 1319
    if (format_char == 122) {
#line 1319
      goto case_122;
    }
#line 1397
    if (format_char == 0) {
#line 1397
      goto case_0___0;
    }
#line 1400
    goto bad_format;
    case_37: /* CIL Label */ 
#line 689
    if (modifier != 0) {
#line 690
      goto bad_format;
    }
    {
#line 691
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 691
      _n___0 = 1;
#line 691
      _delta___0 = width - _n___0;
#line 691
      if (_delta___0 > 0) {
#line 691
        tmp___1 = _delta___0;
      } else {
#line 691
        tmp___1 = 0;
      }
#line 691
      _incr___0 = _n___0 + tmp___1;
#line 691
      if ((size_t )_incr___0 >= maxsize - i) {
#line 691
        return ((size_t )0);
      }
#line 691
      if (p) {
#line 691
        if (digits == 0) {
#line 691
          if (_delta___0 > 0) {
#line 691
            if (pad == 48) {
              {
#line 691
              memset((void *)p, '0', (size_t )_delta___0);
#line 691
              p += _delta___0;
              }
            } else {
              {
#line 691
              memset((void *)p, ' ', (size_t )_delta___0);
#line 691
              p += _delta___0;
              }
            }
          }
        }
#line 691
        *p = (char )*f;
#line 691
        p += _n___0;
      }
#line 691
      i += (size_t )_incr___0;
#line 691
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 692
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 695
    if (modifier != 0) {
#line 696
      goto bad_format;
    }
#line 697
    if (change_case) {
#line 699
      to_uppcase = (_Bool)1;
#line 700
      to_lowcase = (_Bool)0;
    }
#line 706
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 710
    if (modifier != 0) {
#line 711
      goto bad_format;
    }
#line 712
    if (change_case) {
#line 714
      to_uppcase = (_Bool)1;
#line 715
      to_lowcase = (_Bool)0;
    }
#line 721
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 731
    if (modifier != 0) {
#line 732
      goto bad_format;
    }
#line 737
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 741
    if (modifier != 0) {
#line 742
      goto bad_format;
    }
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 752
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 756
    if (modifier == 79) {
#line 757
      goto bad_format;
    }
#line 766
    goto underlying_strftime;
    subformat: 
    {
#line 771
    tmp___2 = strftime_case____0(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
#line 771
    len = tmp___2;
    }
    {
#line 775
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 775
      _n___1 = (int )len;
#line 775
      _delta___1 = width - _n___1;
#line 775
      if (_delta___1 > 0) {
#line 775
        tmp___3 = _delta___1;
      } else {
#line 775
        tmp___3 = 0;
      }
#line 775
      _incr___1 = _n___1 + tmp___3;
#line 775
      if ((size_t )_incr___1 >= maxsize - i) {
#line 775
        return ((size_t )0);
      }
#line 775
      if (p) {
#line 775
        if (digits == 0) {
#line 775
          if (_delta___1 > 0) {
#line 775
            if (pad == 48) {
              {
#line 775
              memset((void *)p, '0', (size_t )_delta___1);
#line 775
              p += _delta___1;
              }
            } else {
              {
#line 775
              memset((void *)p, ' ', (size_t )_delta___1);
#line 775
              p += _delta___1;
              }
            }
          }
        }
        {
#line 775
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 775
        p += _n___1;
        }
      }
#line 775
      i += (size_t )_incr___1;
#line 775
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 780
    goto switch_break___1;
    underlying_strftime: 
#line 788
    u = ufmt;
#line 801
    tmp___4 = u;
#line 801
    u ++;
#line 801
    *tmp___4 = (char )' ';
#line 802
    tmp___5 = u;
#line 802
    u ++;
#line 802
    *tmp___5 = (char )'%';
#line 803
    if (modifier != 0) {
#line 804
      tmp___6 = u;
#line 804
      u ++;
#line 804
      *tmp___6 = (char )modifier;
    }
    {
#line 805
    tmp___7 = u;
#line 805
    u ++;
#line 805
    *tmp___7 = (char )format_char;
#line 806
    *u = (char )'\000';
#line 807
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 808
    if (len___0 != 0UL) {
      {
#line 809
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 809
        _n___2 = (int )(len___0 - 1UL);
#line 809
        _delta___2 = width - _n___2;
#line 809
        if (_delta___2 > 0) {
#line 809
          tmp___8 = _delta___2;
        } else {
#line 809
          tmp___8 = 0;
        }
#line 809
        _incr___2 = _n___2 + tmp___8;
#line 809
        if ((size_t )_incr___2 >= maxsize - i) {
#line 809
          return ((size_t )0);
        }
#line 809
        if (p) {
#line 809
          if (digits == 0) {
#line 809
            if (_delta___2 > 0) {
#line 809
              if (pad == 48) {
                {
#line 809
                memset((void *)p, '0', (size_t )_delta___2);
#line 809
                p += _delta___2;
                }
              } else {
                {
#line 809
                memset((void *)p, ' ', (size_t )_delta___2);
#line 809
                p += _delta___2;
                }
              }
            }
          }
#line 809
          if (to_lowcase) {
            {
#line 809
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 809
          if (to_uppcase) {
            {
#line 809
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 809
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
            }
          }
#line 809
          p += _n___2;
        }
#line 809
        i += (size_t )_incr___2;
#line 809
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 811
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 815
    if (modifier == 79) {
#line 816
      goto bad_format;
    }
#line 817
    if (modifier == 69) {
#line 833
      goto underlying_strftime;
    }
#line 838
    century = (int )(tp->tm_year / 100 + 19);
#line 839
    if (tp->tm_year % 100 < 0) {
#line 839
      if (0 < century) {
#line 839
        tmp___9 = 1;
      } else {
#line 839
        tmp___9 = 0;
      }
    } else {
#line 839
      tmp___9 = 0;
    }
#line 839
    century -= tmp___9;
#line 840
    digits = 2;
#line 840
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 840
    u_number_value = (unsigned int )century;
#line 840
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 844
    if (modifier == 79) {
#line 845
      goto bad_format;
    }
#line 854
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 857
    if (modifier != 0) {
#line 858
      goto bad_format;
    }
#line 859
    subfmt = "%m/%d/%y";
#line 860
    goto subformat;
    case_100: /* CIL Label */ 
#line 863
    if (modifier == 69) {
#line 864
      goto bad_format;
    }
#line 866
    digits = 2;
#line 866
    number_value = (int )tp->tm_mday;
#line 866
    goto do_number;
    case_101: /* CIL Label */ 
#line 869
    if (modifier == 69) {
#line 870
      goto bad_format;
    }
#line 872
    digits = 2;
#line 872
    number_value = (int )tp->tm_mday;
#line 872
    goto do_number_spacepad;
    do_tz_offset: 
#line 878
    always_output_a_sign = (_Bool)1;
#line 879
    goto do_number_body;
    do_number_spacepad: 
#line 883
    if (pad != 48) {
#line 883
      if (pad != 45) {
#line 884
        pad = '_';
      }
    }
    do_number: 
#line 888
    negative_number = (_Bool )(number_value < 0);
#line 889
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 892
    always_output_a_sign = (_Bool)0;
#line 893
    tz_colon_mask = 0;
    do_number_body: 
#line 901
    if (modifier == 79) {
#line 901
      if (! negative_number) {
#line 919
        goto underlying_strftime;
      }
    }
#line 923
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 925
    if (negative_number) {
#line 926
      u_number_value = - u_number_value;
    }
    {
#line 928
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 930
      if (tz_colon_mask & 1) {
#line 931
        bufp --;
#line 931
        *bufp = (char )':';
      }
#line 932
      tz_colon_mask >>= 1;
#line 933
      bufp --;
#line 933
      *bufp = (char )(u_number_value % 10U + 48U);
#line 934
      u_number_value /= 10U;
#line 928
      if (! (u_number_value != 0U)) {
#line 928
        if (! (tz_colon_mask != 0)) {
#line 928
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 939
    if (digits < width) {
#line 940
      digits = width;
    }
#line 942
    if (negative_number) {
#line 942
      sign_char = (char )'-';
    } else {
#line 942
      if (always_output_a_sign) {
#line 942
        tmp___10 = '+';
      } else {
#line 942
        tmp___10 = 0;
      }
#line 942
      sign_char = (char )tmp___10;
    }
#line 946
    if (pad == 45) {
#line 948
      if (sign_char) {
        {
#line 949
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 949
          _n___3 = 1;
#line 949
          _delta___3 = width - _n___3;
#line 949
          if (_delta___3 > 0) {
#line 949
            tmp___11 = _delta___3;
          } else {
#line 949
            tmp___11 = 0;
          }
#line 949
          _incr___3 = _n___3 + tmp___11;
#line 949
          if ((size_t )_incr___3 >= maxsize - i) {
#line 949
            return ((size_t )0);
          }
#line 949
          if (p) {
#line 949
            if (digits == 0) {
#line 949
              if (_delta___3 > 0) {
#line 949
                if (pad == 48) {
                  {
#line 949
                  memset((void *)p, '0', (size_t )_delta___3);
#line 949
                  p += _delta___3;
                  }
                } else {
                  {
#line 949
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 949
                  p += _delta___3;
                  }
                }
              }
            }
#line 949
            *p = sign_char;
#line 949
            p += _n___3;
          }
#line 949
          i += (size_t )_incr___3;
#line 949
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 953
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 956
      if (padding > 0) {
#line 958
        if (pad == 95) {
#line 960
          if ((size_t )padding >= maxsize - i) {
#line 961
            return ((size_t )0);
          }
#line 963
          if (p) {
            {
#line 964
            memset((void *)p, ' ', (size_t )padding);
#line 964
            p += padding;
            }
          }
#line 965
          i += (size_t )padding;
#line 966
          if (width > padding) {
#line 966
            width -= padding;
          } else {
#line 966
            width = 0;
          }
#line 967
          if (sign_char) {
            {
#line 968
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 968
              _n___4 = 1;
#line 968
              _delta___4 = width - _n___4;
#line 968
              if (_delta___4 > 0) {
#line 968
                tmp___12 = _delta___4;
              } else {
#line 968
                tmp___12 = 0;
              }
#line 968
              _incr___4 = _n___4 + tmp___12;
#line 968
              if ((size_t )_incr___4 >= maxsize - i) {
#line 968
                return ((size_t )0);
              }
#line 968
              if (p) {
#line 968
                if (digits == 0) {
#line 968
                  if (_delta___4 > 0) {
#line 968
                    if (pad == 48) {
                      {
#line 968
                      memset((void *)p, '0', (size_t )_delta___4);
#line 968
                      p += _delta___4;
                      }
                    } else {
                      {
#line 968
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 968
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 968
                *p = sign_char;
#line 968
                p += _n___4;
              }
#line 968
              i += (size_t )_incr___4;
#line 968
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 972
          if ((size_t )digits >= maxsize - i) {
#line 973
            return ((size_t )0);
          }
#line 975
          if (sign_char) {
            {
#line 976
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 976
              _n___5 = 1;
#line 976
              _delta___5 = width - _n___5;
#line 976
              if (_delta___5 > 0) {
#line 976
                tmp___13 = _delta___5;
              } else {
#line 976
                tmp___13 = 0;
              }
#line 976
              _incr___5 = _n___5 + tmp___13;
#line 976
              if ((size_t )_incr___5 >= maxsize - i) {
#line 976
                return ((size_t )0);
              }
#line 976
              if (p) {
#line 976
                if (digits == 0) {
#line 976
                  if (_delta___5 > 0) {
#line 976
                    if (pad == 48) {
                      {
#line 976
                      memset((void *)p, '0', (size_t )_delta___5);
#line 976
                      p += _delta___5;
                      }
                    } else {
                      {
#line 976
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 976
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 976
                *p = sign_char;
#line 976
                p += _n___5;
              }
#line 976
              i += (size_t )_incr___5;
#line 976
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 978
          if (p) {
            {
#line 979
            memset((void *)p, '0', (size_t )padding);
#line 979
            p += padding;
            }
          }
#line 980
          i += (size_t )padding;
#line 981
          width = 0;
        }
      } else
#line 986
      if (sign_char) {
        {
#line 987
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 987
          _n___6 = 1;
#line 987
          _delta___6 = width - _n___6;
#line 987
          if (_delta___6 > 0) {
#line 987
            tmp___14 = _delta___6;
          } else {
#line 987
            tmp___14 = 0;
          }
#line 987
          _incr___6 = _n___6 + tmp___14;
#line 987
          if ((size_t )_incr___6 >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 987
          if (p) {
#line 987
            if (digits == 0) {
#line 987
              if (_delta___6 > 0) {
#line 987
                if (pad == 48) {
                  {
#line 987
                  memset((void *)p, '0', (size_t )_delta___6);
#line 987
                  p += _delta___6;
                  }
                } else {
                  {
#line 987
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 987
                  p += _delta___6;
                  }
                }
              }
            }
#line 987
            *p = sign_char;
#line 987
            p += _n___6;
          }
#line 987
          i += (size_t )_incr___6;
#line 987
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 991
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 991
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 991
      _delta___7 = width - _n___7;
#line 991
      if (_delta___7 > 0) {
#line 991
        tmp___15 = _delta___7;
      } else {
#line 991
        tmp___15 = 0;
      }
#line 991
      _incr___7 = _n___7 + tmp___15;
#line 991
      if ((size_t )_incr___7 >= maxsize - i) {
#line 991
        return ((size_t )0);
      }
#line 991
      if (p) {
#line 991
        if (digits == 0) {
#line 991
          if (_delta___7 > 0) {
#line 991
            if (pad == 48) {
              {
#line 991
              memset((void *)p, '0', (size_t )_delta___7);
#line 991
              p += _delta___7;
              }
            } else {
              {
#line 991
              memset((void *)p, ' ', (size_t )_delta___7);
#line 991
              p += _delta___7;
              }
            }
          }
        }
#line 991
        if (to_lowcase) {
          {
#line 991
          memcpy_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 991
        if (to_uppcase) {
          {
#line 991
          memcpy_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 991
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 (size_t )_n___7);
          }
        }
#line 991
        p += _n___7;
      }
#line 991
      i += (size_t )_incr___7;
#line 991
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 992
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 995
    if (modifier != 0) {
#line 996
      goto bad_format;
    }
#line 997
    subfmt = "%Y-%m-%d";
#line 998
    goto subformat;
    case_72: /* CIL Label */ 
#line 1001
    if (modifier == 69) {
#line 1002
      goto bad_format;
    }
#line 1004
    digits = 2;
#line 1004
    number_value = (int )tp->tm_hour;
#line 1004
    goto do_number;
    case_73: /* CIL Label */ 
#line 1007
    if (modifier == 69) {
#line 1008
      goto bad_format;
    }
#line 1010
    digits = 2;
#line 1010
    number_value = hour12;
#line 1010
    goto do_number;
    case_107: /* CIL Label */ 
#line 1013
    if (modifier == 69) {
#line 1014
      goto bad_format;
    }
#line 1016
    digits = 2;
#line 1016
    number_value = (int )tp->tm_hour;
#line 1016
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1019
    if (modifier == 69) {
#line 1020
      goto bad_format;
    }
#line 1022
    digits = 2;
#line 1022
    number_value = hour12;
#line 1022
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1025
    if (modifier == 69) {
#line 1026
      goto bad_format;
    }
#line 1028
    digits = 3;
#line 1028
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1028
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1028
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1031
    if (modifier == 69) {
#line 1032
      goto bad_format;
    }
#line 1034
    digits = 2;
#line 1034
    number_value = (int )tp->tm_min;
#line 1034
    goto do_number;
    case_109: /* CIL Label */ 
#line 1037
    if (modifier == 69) {
#line 1038
      goto bad_format;
    }
#line 1040
    digits = 2;
#line 1040
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1040
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1040
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1044
    if (modifier == 69) {
#line 1045
      goto bad_format;
    }
#line 1047
    number_value = ns;
#line 1048
    if (width == -1) {
#line 1049
      width = 9;
    } else {
#line 1054
      j = width;
      {
#line 1054
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1054
        if (! (j < 9)) {
#line 1054
          goto while_break___12;
        }
#line 1055
        number_value /= 10;
#line 1054
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1058
    digits = width;
#line 1058
    number_value = number_value;
#line 1058
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1062
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1062
      _n___8 = 1;
#line 1062
      _delta___8 = width - _n___8;
#line 1062
      if (_delta___8 > 0) {
#line 1062
        tmp___16 = _delta___8;
      } else {
#line 1062
        tmp___16 = 0;
      }
#line 1062
      _incr___8 = _n___8 + tmp___16;
#line 1062
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1062
        return ((size_t )0);
      }
#line 1062
      if (p) {
#line 1062
        if (digits == 0) {
#line 1062
          if (_delta___8 > 0) {
#line 1062
            if (pad == 48) {
              {
#line 1062
              memset((void *)p, '0', (size_t )_delta___8);
#line 1062
              p += _delta___8;
              }
            } else {
              {
#line 1062
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1062
              p += _delta___8;
              }
            }
          }
        }
#line 1062
        *p = (char )'\n';
#line 1062
        p += _n___8;
      }
#line 1062
      i += (size_t )_incr___8;
#line 1062
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1063
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1066
    to_lowcase = (_Bool)1;
#line 1068
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1073
    if (change_case) {
#line 1075
      to_uppcase = (_Bool)0;
#line 1076
      to_lowcase = (_Bool)1;
    }
#line 1082
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1086
    subfmt = "%H:%M";
#line 1087
    goto subformat;
    case_114: /* CIL Label */ 
#line 1097
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1101
    if (modifier == 69) {
#line 1102
      goto bad_format;
    }
#line 1104
    digits = 2;
#line 1104
    number_value = (int )tp->tm_sec;
#line 1104
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1111
    ltm = (struct tm )*tp;
#line 1112
    t = mktime(& ltm);
#line 1117
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1118
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1120
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1122
      d = (int )(t % 10L);
#line 1123
      t /= 10L;
#line 1124
      bufp --;
#line 1124
      if (negative_number) {
#line 1124
        tmp___17 = - d;
      } else {
#line 1124
        tmp___17 = d;
      }
#line 1124
      *bufp = (char )(tmp___17 + 48);
#line 1120
      if (! (t != 0L)) {
#line 1120
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1128
    digits = 1;
#line 1129
    always_output_a_sign = (_Bool)0;
#line 1130
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1134
    if (modifier == 79) {
#line 1135
      goto bad_format;
    }
#line 1144
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1147
    subfmt = "%H:%M:%S";
#line 1148
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1151
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1151
      _n___9 = 1;
#line 1151
      _delta___9 = width - _n___9;
#line 1151
      if (_delta___9 > 0) {
#line 1151
        tmp___18 = _delta___9;
      } else {
#line 1151
        tmp___18 = 0;
      }
#line 1151
      _incr___9 = _n___9 + tmp___18;
#line 1151
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1151
        return ((size_t )0);
      }
#line 1151
      if (p) {
#line 1151
        if (digits == 0) {
#line 1151
          if (_delta___9 > 0) {
#line 1151
            if (pad == 48) {
              {
#line 1151
              memset((void *)p, '0', (size_t )_delta___9);
#line 1151
              p += _delta___9;
              }
            } else {
              {
#line 1151
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1151
              p += _delta___9;
              }
            }
          }
        }
#line 1151
        *p = (char )'\t';
#line 1151
        p += _n___9;
      }
#line 1151
      i += (size_t )_incr___9;
#line 1151
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1152
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1155
    digits = 1;
#line 1155
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1155
    goto do_number;
    case_85: /* CIL Label */ 
#line 1158
    if (modifier == 69) {
#line 1159
      goto bad_format;
    }
#line 1161
    digits = 2;
#line 1161
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1161
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1166
    if (modifier == 69) {
#line 1167
      goto bad_format;
    }
#line 1173
    if (tp->tm_year < 0) {
#line 1173
      tmp___19 = 300;
    } else {
#line 1173
      tmp___19 = -100;
    }
    {
#line 1173
    year___1 = (int )(tp->tm_year + (int const   )tmp___19);
#line 1177
    year_adjust = 0;
#line 1178
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1178
    days = tmp___20;
    }
#line 1180
    if (days < 0) {
#line 1183
      year_adjust = -1;
#line 1184
      if ((year___1 - 1) % 4 == 0) {
#line 1184
        if ((year___1 - 1) % 100 != 0) {
#line 1184
          tmp___21 = 1;
        } else
#line 1184
        if ((year___1 - 1) % 400 == 0) {
#line 1184
          tmp___21 = 1;
        } else {
#line 1184
          tmp___21 = 0;
        }
      } else {
#line 1184
        tmp___21 = 0;
      }
      {
#line 1184
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1189
      if (year___1 % 4 == 0) {
#line 1189
        if (year___1 % 100 != 0) {
#line 1189
          tmp___22 = 1;
        } else
#line 1189
        if (year___1 % 400 == 0) {
#line 1189
          tmp___22 = 1;
        } else {
#line 1189
          tmp___22 = 0;
        }
      } else {
#line 1189
        tmp___22 = 0;
      }
      {
#line 1189
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1189
      d___0 = tmp___23;
      }
#line 1191
      if (0 <= d___0) {
#line 1194
        year_adjust = 1;
#line 1195
        days = d___0;
      }
    }
    {
#line 1201
    if ((int const   )*f == 103) {
#line 1201
      goto case_103___0;
    }
#line 1211
    if ((int const   )*f == 71) {
#line 1211
      goto case_71___0;
    }
#line 1216
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1203
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1204
    digits = 2;
#line 1204
    if (0 <= yy) {
#line 1204
      number_value = yy;
    } else {
#line 1204
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1204
        tmp___24 = - yy;
      } else {
#line 1204
        tmp___24 = yy + 100;
      }
#line 1204
      number_value = tmp___24;
    }
#line 1204
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1212
    digits = 4;
#line 1212
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1212
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1212
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1217
    digits = 2;
#line 1217
    number_value = days / 7 + 1;
#line 1217
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1222
    if (modifier == 69) {
#line 1223
      goto bad_format;
    }
#line 1225
    digits = 2;
#line 1225
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1225
    goto do_number;
    case_119: /* CIL Label */ 
#line 1228
    if (modifier == 69) {
#line 1229
      goto bad_format;
    }
#line 1231
    digits = 1;
#line 1231
    number_value = (int )tp->tm_wday;
#line 1231
    goto do_number;
    case_89: /* CIL Label */ 
#line 1234
    if (modifier == 69) {
#line 1248
      goto underlying_strftime;
    }
#line 1251
    if (modifier == 79) {
#line 1252
      goto bad_format;
    } else {
#line 1254
      digits = 4;
    }
#line 1254
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1254
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1254
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1258
    if (modifier == 69) {
#line 1269
      goto underlying_strftime;
    }
#line 1274
    yy___0 = (int )(tp->tm_year % 100);
#line 1275
    if (yy___0 < 0) {
#line 1276
      if (tp->tm_year < -1900) {
#line 1276
        yy___0 = - yy___0;
      } else {
#line 1276
        yy___0 += 100;
      }
    }
#line 1277
    digits = 2;
#line 1277
    number_value = yy___0;
#line 1277
    goto do_number;
    case_90: /* CIL Label */ 
#line 1281
    if (change_case) {
#line 1283
      to_uppcase = (_Bool)0;
#line 1284
      to_lowcase = (_Bool)1;
    }
#line 1292
    if (! zone) {
#line 1293
      zone = "";
    }
    {
#line 1305
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1305
      tmp___25 = strlen(zone);
#line 1305
      _n___10 = (int )tmp___25;
#line 1305
      _delta___10 = width - _n___10;
      }
#line 1305
      if (_delta___10 > 0) {
#line 1305
        tmp___26 = _delta___10;
      } else {
#line 1305
        tmp___26 = 0;
      }
#line 1305
      _incr___10 = _n___10 + tmp___26;
#line 1305
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1305
        return ((size_t )0);
      }
#line 1305
      if (p) {
#line 1305
        if (digits == 0) {
#line 1305
          if (_delta___10 > 0) {
#line 1305
            if (pad == 48) {
              {
#line 1305
              memset((void *)p, '0', (size_t )_delta___10);
#line 1305
              p += _delta___10;
              }
            } else {
              {
#line 1305
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1305
              p += _delta___10;
              }
            }
          }
        }
#line 1305
        if (to_lowcase) {
          {
#line 1305
          memcpy_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1305
        if (to_uppcase) {
          {
#line 1305
          memcpy_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1305
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 (size_t )_n___10);
          }
        }
#line 1305
        p += _n___10;
      }
#line 1305
      i += (size_t )_incr___10;
#line 1305
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1307
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1312
    colons = (size_t )1;
    {
#line 1312
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1312
      if (! ((int const   )*(f + colons) == 58)) {
#line 1312
        goto while_break___17;
      }
#line 1313
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1312
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1314
    if ((int const   )*(f + colons) != 122) {
#line 1315
      goto bad_format;
    }
#line 1316
    f += colons;
#line 1317
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1320
    colons = (size_t )0;
    do_z_conversion: 
#line 1323
    if (tp->tm_isdst < 0) {
#line 1324
      goto switch_break___1;
    }
#line 1332
    diff = (int )tp->tm_gmtoff;
#line 1369
    hour_diff = (diff / 60) / 60;
#line 1370
    min_diff = (diff / 60) % 60;
#line 1371
    sec_diff = diff % 60;
    {
#line 1375
    if (colons == 0UL) {
#line 1375
      goto case_0;
    }
#line 1378
    if (colons == 1UL) {
#line 1378
      goto tz_hh_mm;
    }
#line 1381
    if (colons == 2UL) {
#line 1381
      goto tz_hh_mm_ss;
    }
#line 1385
    if (colons == 3UL) {
#line 1385
      goto case_3;
    }
#line 1392
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1376
    digits = 5;
#line 1376
    negative_number = (_Bool )(diff < 0);
#line 1376
    tz_colon_mask = 0;
#line 1376
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1376
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1379
    digits = 6;
#line 1379
    negative_number = (_Bool )(diff < 0);
#line 1379
    tz_colon_mask = 4;
#line 1379
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1379
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1382
    digits = 9;
#line 1382
    negative_number = (_Bool )(diff < 0);
#line 1382
    tz_colon_mask = 20;
#line 1382
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1382
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1386
    if (sec_diff != 0) {
#line 1387
      goto tz_hh_mm_ss;
    }
#line 1388
    if (min_diff != 0) {
#line 1389
      goto tz_hh_mm;
    }
#line 1390
    digits = 3;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )hour_diff;
#line 1390
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1393
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1398
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1407
    flen = 1;
    {
#line 1407
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1407
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1407
        goto while_break___18;
      }
#line 1408
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1407
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1409
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1409
      _n___11 = flen;
#line 1409
      _delta___11 = width - _n___11;
#line 1409
      if (_delta___11 > 0) {
#line 1409
        tmp___27 = _delta___11;
      } else {
#line 1409
        tmp___27 = 0;
      }
#line 1409
      _incr___11 = _n___11 + tmp___27;
#line 1409
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1409
        return ((size_t )0);
      }
#line 1409
      if (p) {
#line 1409
        if (digits == 0) {
#line 1409
          if (_delta___11 > 0) {
#line 1409
            if (pad == 48) {
              {
#line 1409
              memset((void *)p, '0', (size_t )_delta___11);
#line 1409
              p += _delta___11;
              }
            } else {
              {
#line 1409
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1409
              p += _delta___11;
              }
            }
          }
        }
#line 1409
        if (to_lowcase) {
          {
#line 1409
          memcpy_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1409
        if (to_uppcase) {
          {
#line 1409
          memcpy_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1409
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
          }
        }
#line 1409
        p += _n___11;
      }
#line 1409
      i += (size_t )_incr___11;
#line 1409
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1411
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 492
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  if (p) {
#line 1416
    if (maxsize != 0UL) {
#line 1417
      *p = (char )'\000';
    }
  }
#line 1420
  return (i);
}
}
#line 1429 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1434
  tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
#line 1434
  return (tmp);
}
}
#line 366 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void) ;
#line 368
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.h"
int sig2str(int signum , char *signame ) ;
#line 31
int str2sig(char const   *signame , int *signum ) ;
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
static struct numname numname_table[35]  = 
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000'}}, 
        {2,
      {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000'}}, 
        {3,
      {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
       (char const   )'\000'}}, 
        {4, {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000'}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000'}}, 
        {6, {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
          (char const   )'\000'}}, 
        {8, {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000'}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {7, {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000'}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000'}}, 
        {13, {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
           (char const   )'\000'}}, 
        {14, {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {15, {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {10, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
           (char const   )'\000'}}, 
        {12, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
           (char const   )'\000'}}, 
        {17, {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
           (char const   )'\000'}}, 
        {23, {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000'}}, 
        {19,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000'}}, 
        {20, {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
           (char const   )'\000'}}, 
        {18, {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
           (char const   )'\000'}}, 
        {21, {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
           (char const   )'\000'}}, 
        {22, {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
           (char const   )'\000'}}, 
        {31, {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000'}}, 
        {29,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {26, {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
           (char const   )'R', (char const   )'M', (char const   )'\000'}}, 
        {27, {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
           (char const   )'\000'}}, 
        {24, {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
           (char const   )'\000'}}, 
        {25, {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
           (char const   )'\000'}}, 
        {6, {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000'}}, 
        {17,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000'}}, 
        {30,
      {(char const   )'P', (char const   )'W', (char const   )'R', (char const   )'\000'}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000'}}, 
        {29, {(char const   )'I', (char const   )'O', (char const   )'\000'}}, 
        {16, {(char const   )'S', (char const   )'T', (char const   )'K', (char const   )'F',
           (char const   )'L', (char const   )'T', (char const   )'\000'}}, 
        {0, {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
          (char const   )'\000'}}};
#line 258 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
static int str2signum(char const   *signame ) 
{ 
  char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  int tmp___0 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___1 ;
  int rtmax ;
  int tmp___2 ;
  long n___0 ;
  long tmp___3 ;
  long n___1 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 261
  if ((unsigned int )*signame - 48U <= 9U) {
    {
#line 264
    tmp = strtol((char const   */* __restrict  */)signame, (char **/* __restrict  */)(& endp),
                 10);
#line 264
    n = tmp;
    }
#line 265
    if (! *endp) {
#line 265
      if (n <= 64L) {
#line 266
        return ((int )n);
      }
    }
  } else {
#line 271
    i = 0U;
    {
#line 271
    while (1) {
      while_continue: /* CIL Label */ ;
#line 271
      if (! ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0]))) {
#line 271
        goto while_break;
      }
      {
#line 272
      tmp___0 = strcmp(numname_table[i].name, signame);
      }
#line 272
      if (tmp___0 == 0) {
#line 273
        return (numname_table[i].num);
      }
#line 271
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 277
    tmp___1 = __libc_current_sigrtmin();
#line 277
    rtmin = tmp___1;
#line 278
    tmp___2 = __libc_current_sigrtmax();
#line 278
    rtmax = tmp___2;
    }
#line 280
    if (0 < rtmin) {
      {
#line 280
      tmp___6 = strncmp(signame, "RTMIN", (size_t )5);
      }
#line 280
      if (tmp___6 == 0) {
        {
#line 282
        tmp___3 = strtol((char const   */* __restrict  */)(signame + 5), (char **/* __restrict  */)(& endp___0),
                         10);
#line 282
        n___0 = tmp___3;
        }
#line 283
        if (! *endp___0) {
#line 283
          if (0L <= n___0) {
#line 283
            if (n___0 <= (long )(rtmax - rtmin)) {
#line 284
              return ((int )((long )rtmin + n___0));
            }
          }
        }
      } else {
#line 280
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 286
    if (0 < rtmax) {
      {
#line 286
      tmp___5 = strncmp(signame, "RTMAX", (size_t )5);
      }
#line 286
      if (tmp___5 == 0) {
        {
#line 288
        tmp___4 = strtol((char const   */* __restrict  */)(signame + 5), (char **/* __restrict  */)(& endp___0),
                         10);
#line 288
        n___1 = tmp___4;
        }
#line 289
        if (! *endp___0) {
#line 289
          if ((long )(rtmin - rtmax) <= n___1) {
#line 289
            if (n___1 <= 0L) {
#line 290
              return ((int )((long )rtmax + n___1));
            }
          }
        }
      }
    }
  }
#line 295
  return (-1);
}
}
#line 301 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
int str2sig(char const   *signame , int *signum ) 
{ 
  int tmp ;

  {
  {
#line 304
  *signum = str2signum(signame);
  }
#line 305
  if (*signum < 0) {
#line 305
    tmp = -1;
  } else {
#line 305
    tmp = 0;
  }
#line 305
  return (tmp);
}
}
#line 312 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
int sig2str(int signum , char *signame ) 
{ 
  unsigned int i ;
  int rtmin ;
  int tmp ;
  int rtmax ;
  int tmp___0 ;
  int delta ;
  char const   *tmp___1 ;
  int delta___0 ;
  char const   *tmp___2 ;

  {
#line 316
  i = 0U;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0]))) {
#line 316
      goto while_break;
    }
#line 317
    if (numname_table[i].num == signum) {
      {
#line 319
      strcpy((char */* __restrict  */)signame, (char const   */* __restrict  */)(numname_table[i].name));
      }
#line 320
      return (0);
    }
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  tmp = __libc_current_sigrtmin();
#line 324
  rtmin = tmp;
#line 325
  tmp___0 = __libc_current_sigrtmax();
#line 325
  rtmax = tmp___0;
  }
#line 327
  if (rtmin <= signum) {
#line 327
    if (! (signum <= rtmax)) {
#line 328
      return (-1);
    }
  } else {
#line 328
    return (-1);
  }
#line 330
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
#line 332
    delta = signum - rtmin;
#line 333
    if (delta) {
#line 333
      tmp___1 = "RTMIN+%d";
    } else {
#line 333
      tmp___1 = "RTMIN";
    }
    {
#line 333
    sprintf((char */* __restrict  */)signame, (char const   */* __restrict  */)tmp___1,
            delta);
    }
  } else {
#line 337
    delta___0 = rtmax - signum;
#line 338
    if (delta___0) {
#line 338
      tmp___2 = "RTMAX-%d";
    } else {
#line 338
      tmp___2 = "RTMAX";
    }
    {
#line 338
    sprintf((char */* __restrict  */)signame, (char const   */* __restrict  */)tmp___2,
            delta___0);
    }
  }
#line 341
  return (0);
}
}
#line 673 "/usr/include/stdio.h"
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 39 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.h"
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
#line 40
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
#line 46
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 53
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 60
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 61
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 70
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 71
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 77
int sha512_stream(FILE *stream , void *resblock ) ;
#line 78
int sha384_stream(FILE *stream , void *resblock ) ;
#line 84
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 85
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static unsigned char const   fillbuf[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void sha512_init_ctx(struct sha512_ctx *ctx ) 
{ 
  u64 tmp ;

  {
#line 66
  ctx->state[0] = (1779033703UL << 32) + 4089235720UL;
#line 67
  ctx->state[1] = (3144134277UL << 32) + 2227873595UL;
#line 68
  ctx->state[2] = (1013904242UL << 32) + 4271175723UL;
#line 69
  ctx->state[3] = (2773480762UL << 32) + 1595750129UL;
#line 70
  ctx->state[4] = (1359893119UL << 32) + 2917565137UL;
#line 71
  ctx->state[5] = (2600822924UL << 32) + 725511199UL;
#line 72
  ctx->state[6] = (528734635UL << 32) + 4215389547UL;
#line 73
  ctx->state[7] = (1541459225UL << 32) + 327033209UL;
#line 75
  tmp = (u64 )0;
#line 75
  ctx->total[1] = tmp;
#line 75
  ctx->total[0] = tmp;
#line 76
  ctx->buflen = (size_t )0;
#line 77
  return;
}
}
#line 79 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void sha384_init_ctx(struct sha512_ctx *ctx ) 
{ 
  u64 tmp ;

  {
#line 82
  ctx->state[0] = (3418070365UL << 32) + 3238371032UL;
#line 83
  ctx->state[1] = (1654270250UL << 32) + 914150663UL;
#line 84
  ctx->state[2] = (2438529370UL << 32) + 812702999UL;
#line 85
  ctx->state[3] = (355462360UL << 32) + 4144912697UL;
#line 86
  ctx->state[4] = (1731405415UL << 32) + 4290775857UL;
#line 87
  ctx->state[5] = (2394180231UL << 32) + 1750603025UL;
#line 88
  ctx->state[6] = (3675008525UL << 32) + 1694076839UL;
#line 89
  ctx->state[7] = (1203062813UL << 32) + 3204075428UL;
#line 91
  tmp = (u64 )0;
#line 91
  ctx->total[1] = tmp;
#line 91
  ctx->total[0] = tmp;
#line 92
  ctx->buflen = (size_t )0;
#line 93
  return;
}
}
#line 98 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
__inline static void set_uint64(char *cp , u64 v ) 
{ 


  {
  {
#line 101
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(& v), sizeof(v));
  }
#line 102
  return;
}
}
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 110
  r = (char *)resbuf;
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < 8)) {
#line 112
      goto while_break;
    }
    {
#line 113
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 112
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (resbuf);
}
}
#line 118 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 122
  r = (char *)resbuf;
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 6)) {
#line 124
      goto while_break;
    }
    {
#line 125
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 124
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (resbuf);
}
}
#line 132 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 136
  bytes = ctx->buflen;
#line 137
  if (bytes < 112UL) {
#line 137
    tmp = 16;
  } else {
#line 137
    tmp = 32;
  }
#line 137
  size = (size_t )tmp;
#line 140
  ctx->total[0] += bytes;
#line 141
  if (ctx->total[0] < bytes) {
#line 142
    (ctx->total[1]) ++;
  }
  {
#line 147
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
#line 150
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
#line 153
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2UL) * 8UL - bytes);
#line 156
  sha512_process_block((void const   *)(ctx->buffer), size * 8UL, ctx);
  }
#line 157
  return;
}
}
#line 159 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
  {
#line 162
  sha512_conclude_ctx(ctx);
#line 163
  tmp = sha512_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
  {
#line 169
  sha512_conclude_ctx(ctx);
#line 170
  tmp = sha384_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
  }
#line 170
  return (tmp);
}
}
#line 176 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
int sha512_stream(FILE *stream , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 184
  sha512_init_ctx(& ctx);
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    sum = (size_t )0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 198
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 200
      sum += n;
      }
#line 202
      if (sum == 4096UL) {
#line 203
        goto while_break___0;
      }
#line 205
      if (n == 0UL) {
        {
#line 210
        tmp = ferror_unlocked(stream);
        }
#line 210
        if (tmp) {
#line 211
          return (1);
        }
#line 212
        goto process_partial_block;
      }
      {
#line 218
      tmp___0 = feof_unlocked(stream);
      }
#line 218
      if (tmp___0) {
#line 219
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 225
    sha512_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 231
  if (sum > 0UL) {
    {
#line 232
    sha512_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 235
  sha512_finish_ctx(& ctx, resblock);
  }
#line 236
  return (0);
}
}
#line 240 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
int sha384_stream(FILE *stream , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 248
  sha384_init_ctx(& ctx);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    sum = (size_t )0;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 262
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 264
      sum += n;
      }
#line 266
      if (sum == 4096UL) {
#line 267
        goto while_break___0;
      }
#line 269
      if (n == 0UL) {
        {
#line 274
        tmp = ferror_unlocked(stream);
        }
#line 274
        if (tmp) {
#line 275
          return (1);
        }
#line 276
        goto process_partial_block;
      }
      {
#line 282
      tmp___0 = feof_unlocked(stream);
      }
#line 282
      if (tmp___0) {
#line 283
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 289
    sha512_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 295
  if (sum > 0UL) {
    {
#line 296
    sha512_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 299
  sha384_finish_ctx(& ctx, resblock);
  }
#line 300
  return (0);
}
}
#line 307 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  void *tmp ;

  {
  {
#line 313
  sha512_init_ctx(& ctx);
#line 316
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 319
  tmp = sha512_finish_ctx(& ctx, resblock);
  }
#line 319
  return (tmp);
}
}
#line 322 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  void *tmp ;

  {
  {
#line 328
  sha384_init_ctx(& ctx);
#line 331
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 334
  tmp = sha384_finish_ctx(& ctx, resblock);
  }
#line 334
  return (tmp);
}
}
#line 337 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 342
  if (ctx->buflen != 0UL) {
#line 344
    left_over = ctx->buflen;
#line 345
    if (256UL - left_over > len) {
#line 345
      tmp = len;
    } else {
#line 345
      tmp = 256UL - left_over;
    }
    {
#line 345
    add = tmp;
#line 347
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 348
    ctx->buflen += add;
    }
#line 350
    if (ctx->buflen > 128UL) {
      {
#line 352
      sha512_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffff80UL,
                           ctx);
#line 354
      ctx->buflen &= 127UL;
#line 356
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffff80UL)),
             ctx->buflen);
      }
    }
#line 361
    buffer = (void const   *)((char const   *)buffer + add);
#line 362
    len -= add;
  }
#line 366
  if (len >= 128UL) {
#line 371
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_972123420 *)0)->x) != 0UL) {
      {
#line 372
      while (1) {
        while_continue: /* CIL Label */ ;
#line 372
        if (! (len > 128UL)) {
#line 372
          goto while_break;
        }
        {
#line 374
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )128);
#line 374
        sha512_process_block((void const   *)tmp___0, (size_t )128, ctx);
#line 375
        buffer = (void const   *)((char const   *)buffer + 128);
#line 376
        len -= 128UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 381
      sha512_process_block(buffer, len & 0xffffffffffffff80UL, ctx);
#line 382
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffff80UL));
#line 383
      len &= 127UL;
      }
    }
  }
#line 388
  if (len > 0UL) {
    {
#line 390
    left_over___0 = ctx->buflen;
#line 392
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 393
    left_over___0 += len;
    }
#line 394
    if (left_over___0 >= 128UL) {
      {
#line 396
      sha512_process_block((void const   *)(ctx->buffer), (size_t )128, ctx);
#line 397
      left_over___0 -= 128UL;
#line 398
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 400
    ctx->buflen = left_over___0;
  }
#line 402
  return;
}
}
#line 408 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static u64 const   sha512_round_constants[80]  = 
#line 408
  {      (u64 const   )((1116352408UL << 32) + 3609767458UL),      (u64 const   )((1899447441UL << 32) + 602891725UL),      (u64 const   )((3049323471UL << 32) + 3964484399UL),      (u64 const   )((3921009573UL << 32) + 2173295548UL), 
        (u64 const   )((961987163UL << 32) + 4081628472UL),      (u64 const   )((1508970993UL << 32) + 3053834265UL),      (u64 const   )((2453635748UL << 32) + 2937671579UL),      (u64 const   )((2870763221UL << 32) + 3664609560UL), 
        (u64 const   )((3624381080UL << 32) + 2734883394UL),      (u64 const   )((310598401UL << 32) + 1164996542UL),      (u64 const   )((607225278UL << 32) + 1323610764UL),      (u64 const   )((1426881987UL << 32) + 3590304994UL), 
        (u64 const   )((1925078388UL << 32) + 4068182383UL),      (u64 const   )((2162078206UL << 32) + 991336113UL),      (u64 const   )((2614888103UL << 32) + 633803317UL),      (u64 const   )((3248222580UL << 32) + 3479774868UL), 
        (u64 const   )((3835390401UL << 32) + 2666613458UL),      (u64 const   )((4022224774UL << 32) + 944711139UL),      (u64 const   )((264347078UL << 32) + 2341262773UL),      (u64 const   )((604807628UL << 32) + 2007800933UL), 
        (u64 const   )((770255983UL << 32) + 1495990901UL),      (u64 const   )((1249150122UL << 32) + 1856431235UL),      (u64 const   )((1555081692UL << 32) + 3175218132UL),      (u64 const   )((1996064986UL << 32) + 2198950837UL), 
        (u64 const   )((2554220882UL << 32) + 3999719339UL),      (u64 const   )((2821834349UL << 32) + 766784016UL),      (u64 const   )((2952996808UL << 32) + 2566594879UL),      (u64 const   )((3210313671UL << 32) + 3203337956UL), 
        (u64 const   )((3336571891UL << 32) + 1034457026UL),      (u64 const   )((3584528711UL << 32) + 2466948901UL),      (u64 const   )((113926993UL << 32) + 3758326383UL),      (u64 const   )((338241895UL << 32) + 168717936UL), 
        (u64 const   )((666307205UL << 32) + 1188179964UL),      (u64 const   )((773529912UL << 32) + 1546045734UL),      (u64 const   )((1294757372UL << 32) + 1522805485UL),      (u64 const   )((1396182291UL << 32) + 2643833823UL), 
        (u64 const   )((1695183700UL << 32) + 2343527390UL),      (u64 const   )((1986661051UL << 32) + 1014477480UL),      (u64 const   )((2177026350UL << 32) + 1206759142UL),      (u64 const   )((2456956037UL << 32) + 344077627UL), 
        (u64 const   )((2730485921UL << 32) + 1290863460UL),      (u64 const   )((2820302411UL << 32) + 3158454273UL),      (u64 const   )((3259730800UL << 32) + 3505952657UL),      (u64 const   )((3345764771UL << 32) + 106217008UL), 
        (u64 const   )((3516065817UL << 32) + 3606008344UL),      (u64 const   )((3600352804UL << 32) + 1432725776UL),      (u64 const   )((4094571909UL << 32) + 1467031594UL),      (u64 const   )((275423344UL << 32) + 851169720UL), 
        (u64 const   )((430227734UL << 32) + 3100823752UL),      (u64 const   )((506948616UL << 32) + 1363258195UL),      (u64 const   )((659060556UL << 32) + 3750685593UL),      (u64 const   )((883997877UL << 32) + 3785050280UL), 
        (u64 const   )((958139571UL << 32) + 3318307427UL),      (u64 const   )((1322822218UL << 32) + 3812723403UL),      (u64 const   )((1537002063UL << 32) + 2003034995UL),      (u64 const   )((1747873779UL << 32) + 3602036899UL), 
        (u64 const   )((1955562222UL << 32) + 1575990012UL),      (u64 const   )((2024104815UL << 32) + 1125592928UL),      (u64 const   )((2227730452UL << 32) + 2716904306UL),      (u64 const   )((2361852424UL << 32) + 442776044UL), 
        (u64 const   )((2428436474UL << 32) + 593698344UL),      (u64 const   )((2756734187UL << 32) + 3733110249UL),      (u64 const   )((3204031479UL << 32) + 2999351573UL),      (u64 const   )((3329325298UL << 32) + 3815920427UL), 
        (u64 const   )((3391569614UL << 32) + 3928383900UL),      (u64 const   )((3515267271UL << 32) + 566280711UL),      (u64 const   )((3940187606UL << 32) + 3454069534UL),      (u64 const   )((4118630271UL << 32) + 4000239992UL), 
        (u64 const   )((116418474UL << 32) + 1914138554UL),      (u64 const   )((174292421UL << 32) + 2731055270UL),      (u64 const   )((289380356UL << 32) + 3203993006UL),      (u64 const   )((460393269UL << 32) + 320620315UL), 
        (u64 const   )((685471733UL << 32) + 587496836UL),      (u64 const   )((852142971UL << 32) + 1086792851UL),      (u64 const   )((1017036298UL << 32) + 365543100UL),      (u64 const   )((1126000580UL << 32) + 2618297676UL), 
        (u64 const   )((1288033470UL << 32) + 3409855158UL),      (u64 const   )((1501505948UL << 32) + 4234509866UL),      (u64 const   )((1607167915UL << 32) + 987167468UL),      (u64 const   )((1816402316UL << 32) + 1246189591UL)};
#line 459 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ 
  u64 const   *words ;
  u64 const   *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 tmp ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  u64 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;

  {
#line 462
  words = (u64 const   *)buffer;
#line 463
  endp = words + len / sizeof(u64 );
#line 465
  a = ctx->state[0];
#line 466
  b = ctx->state[1];
#line 467
  c = ctx->state[2];
#line 468
  d = ctx->state[3];
#line 469
  e = ctx->state[4];
#line 470
  f = ctx->state[5];
#line 471
  g = ctx->state[6];
#line 472
  h = ctx->state[7];
#line 477
  ctx->total[0] += len;
#line 478
  if (ctx->total[0] < len) {
#line 479
    (ctx->total[1]) ++;
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 504
      goto while_break;
    }
#line 508
    t = 0;
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 508
      if (! (t < 16)) {
#line 508
        goto while_break___0;
      }
#line 510
      x[t] = (u64 )((((*words << 56) | ((*words & 65280UL) << 40)) | (((*words & 16711680UL) << 24) | ((*words & 4278190080UL) << 8))) | ((((*words >> 8) & 4278190080UL) | ((*words >> 24) & 16711680UL)) | (((*words >> 40) & 65280UL) | (*words >> 56))));
#line 511
      words ++;
#line 508
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 514
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 514
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 514
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[0] + (u64 const   )x[0])));
#line 514
      d += t1;
#line 514
      h = t0 + t1;
#line 514
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 515
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 515
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[1] + (u64 const   )x[1])));
#line 515
      c += t1___0;
#line 515
      g = t0___0 + t1___0;
#line 515
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 516
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 516
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 516
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[2] + (u64 const   )x[2])));
#line 516
      b += t1___1;
#line 516
      f = t0___1 + t1___1;
#line 516
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 517
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 517
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 517
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[3] + (u64 const   )x[3])));
#line 517
      a += t1___2;
#line 517
      e = t0___2 + t1___2;
#line 517
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 518
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 518
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 518
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[4] + (u64 const   )x[4])));
#line 518
      h += t1___3;
#line 518
      d = t0___3 + t1___3;
#line 518
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 519
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 519
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 519
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[5] + (u64 const   )x[5])));
#line 519
      g += t1___4;
#line 519
      c = t0___4 + t1___4;
#line 519
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 520
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 520
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 520
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[6] + (u64 const   )x[6])));
#line 520
      f += t1___5;
#line 520
      b = t0___5 + t1___5;
#line 520
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 521
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 521
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 521
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[7] + (u64 const   )x[7])));
#line 521
      e += t1___6;
#line 521
      a = t0___6 + t1___6;
#line 521
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 522
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 522
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 522
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[8] + (u64 const   )x[8])));
#line 522
      d += t1___7;
#line 522
      h = t0___7 + t1___7;
#line 522
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 523
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 523
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 523
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[9] + (u64 const   )x[9])));
#line 523
      c += t1___8;
#line 523
      g = t0___8 + t1___8;
#line 523
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 524
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 524
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 524
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[10] + (u64 const   )x[10])));
#line 524
      b += t1___9;
#line 524
      f = t0___9 + t1___9;
#line 524
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 525
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 525
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 525
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[11] + (u64 const   )x[11])));
#line 525
      a += t1___10;
#line 525
      e = t0___10 + t1___10;
#line 525
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 526
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 526
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 526
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[12] + (u64 const   )x[12])));
#line 526
      h += t1___11;
#line 526
      d = t0___11 + t1___11;
#line 526
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 527
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 527
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 527
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[13] + (u64 const   )x[13])));
#line 527
      g += t1___12;
#line 527
      c = t0___12 + t1___12;
#line 527
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 528
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 528
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 528
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[14] + (u64 const   )x[14])));
#line 528
      f += t1___13;
#line 528
      b = t0___13 + t1___13;
#line 528
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 529
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 529
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 529
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[15] + (u64 const   )x[15])));
#line 529
      e += t1___14;
#line 529
      a = t0___14 + t1___14;
#line 529
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 530
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 530
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 530
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 530
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[16] + (u64 const   )x[0])));
#line 530
      d += t1___15;
#line 530
      h = t0___15 + t1___15;
#line 530
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 531
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 531
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 531
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 531
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[17] + (u64 const   )x[1])));
#line 531
      c += t1___16;
#line 531
      g = t0___16 + t1___16;
#line 531
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 532
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 532
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 532
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 532
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[18] + (u64 const   )x[2])));
#line 532
      b += t1___17;
#line 532
      f = t0___17 + t1___17;
#line 532
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 533
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 533
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 533
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 533
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[19] + (u64 const   )x[3])));
#line 533
      a += t1___18;
#line 533
      e = t0___18 + t1___18;
#line 533
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 534
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 534
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 534
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 534
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[20] + (u64 const   )x[4])));
#line 534
      h += t1___19;
#line 534
      d = t0___19 + t1___19;
#line 534
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 535
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 535
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 535
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 535
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[21] + (u64 const   )x[5])));
#line 535
      g += t1___20;
#line 535
      c = t0___20 + t1___20;
#line 535
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 536
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 536
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 536
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 536
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[22] + (u64 const   )x[6])));
#line 536
      f += t1___21;
#line 536
      b = t0___21 + t1___21;
#line 536
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 537
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 537
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 537
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 537
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[23] + (u64 const   )x[7])));
#line 537
      e += t1___22;
#line 537
      a = t0___22 + t1___22;
#line 537
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 538
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 538
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 538
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 538
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[24] + (u64 const   )x[8])));
#line 538
      d += t1___23;
#line 538
      h = t0___23 + t1___23;
#line 538
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 539
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 539
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 539
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[25] + (u64 const   )x[9])));
#line 539
      c += t1___24;
#line 539
      g = t0___24 + t1___24;
#line 539
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 540
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 540
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 540
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 540
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[26] + (u64 const   )x[10])));
#line 540
      b += t1___25;
#line 540
      f = t0___25 + t1___25;
#line 540
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 541
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 541
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 541
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 541
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[27] + (u64 const   )x[11])));
#line 541
      a += t1___26;
#line 541
      e = t0___26 + t1___26;
#line 541
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 542
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 542
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 542
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 542
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[28] + (u64 const   )x[12])));
#line 542
      h += t1___27;
#line 542
      d = t0___27 + t1___27;
#line 542
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 543
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 543
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 543
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 543
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[29] + (u64 const   )x[13])));
#line 543
      g += t1___28;
#line 543
      c = t0___28 + t1___28;
#line 543
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 544
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 544
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 544
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 544
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[30] + (u64 const   )x[14])));
#line 544
      f += t1___29;
#line 544
      b = t0___29 + t1___29;
#line 544
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 545
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 545
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 545
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 545
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[31] + (u64 const   )x[15])));
#line 545
      e += t1___30;
#line 545
      a = t0___30 + t1___30;
#line 545
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 546
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 546
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 546
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 546
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[32] + (u64 const   )x[0])));
#line 546
      d += t1___31;
#line 546
      h = t0___31 + t1___31;
#line 546
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 547
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 547
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 547
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 547
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[33] + (u64 const   )x[1])));
#line 547
      c += t1___32;
#line 547
      g = t0___32 + t1___32;
#line 547
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 548
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 548
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 548
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 548
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[34] + (u64 const   )x[2])));
#line 548
      b += t1___33;
#line 548
      f = t0___33 + t1___33;
#line 548
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 549
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 549
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 549
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 549
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[35] + (u64 const   )x[3])));
#line 549
      a += t1___34;
#line 549
      e = t0___34 + t1___34;
#line 549
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 550
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 550
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 550
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 550
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[36] + (u64 const   )x[4])));
#line 550
      h += t1___35;
#line 550
      d = t0___35 + t1___35;
#line 550
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 551
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 551
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 551
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 551
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[37] + (u64 const   )x[5])));
#line 551
      g += t1___36;
#line 551
      c = t0___36 + t1___36;
#line 551
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 552
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 552
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 552
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 552
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[38] + (u64 const   )x[6])));
#line 552
      f += t1___37;
#line 552
      b = t0___37 + t1___37;
#line 552
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 553
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 553
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 553
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 553
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[39] + (u64 const   )x[7])));
#line 553
      e += t1___38;
#line 553
      a = t0___38 + t1___38;
#line 553
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 554
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 554
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 554
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 554
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[40] + (u64 const   )x[8])));
#line 554
      d += t1___39;
#line 554
      h = t0___39 + t1___39;
#line 554
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 555
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 555
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 555
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 555
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[41] + (u64 const   )x[9])));
#line 555
      c += t1___40;
#line 555
      g = t0___40 + t1___40;
#line 555
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 556
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 556
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 556
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 556
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[42] + (u64 const   )x[10])));
#line 556
      b += t1___41;
#line 556
      f = t0___41 + t1___41;
#line 556
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 557
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 557
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 557
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 557
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[43] + (u64 const   )x[11])));
#line 557
      a += t1___42;
#line 557
      e = t0___42 + t1___42;
#line 557
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 558
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 558
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 558
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 558
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[44] + (u64 const   )x[12])));
#line 558
      h += t1___43;
#line 558
      d = t0___43 + t1___43;
#line 558
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 559
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 559
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 559
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 559
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[45] + (u64 const   )x[13])));
#line 559
      g += t1___44;
#line 559
      c = t0___44 + t1___44;
#line 559
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 560
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 560
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 560
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 560
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[46] + (u64 const   )x[14])));
#line 560
      f += t1___45;
#line 560
      b = t0___45 + t1___45;
#line 560
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 561
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 561
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 561
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 561
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[47] + (u64 const   )x[15])));
#line 561
      e += t1___46;
#line 561
      a = t0___46 + t1___46;
#line 561
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 562
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 562
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 562
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 562
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[48] + (u64 const   )x[0])));
#line 562
      d += t1___47;
#line 562
      h = t0___47 + t1___47;
#line 562
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 563
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 563
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 563
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 563
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[49] + (u64 const   )x[1])));
#line 563
      c += t1___48;
#line 563
      g = t0___48 + t1___48;
#line 563
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 564
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 564
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 564
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 564
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[50] + (u64 const   )x[2])));
#line 564
      b += t1___49;
#line 564
      f = t0___49 + t1___49;
#line 564
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 565
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 565
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 565
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 565
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[51] + (u64 const   )x[3])));
#line 565
      a += t1___50;
#line 565
      e = t0___50 + t1___50;
#line 565
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 566
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 566
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 566
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 566
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[52] + (u64 const   )x[4])));
#line 566
      h += t1___51;
#line 566
      d = t0___51 + t1___51;
#line 566
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 567
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 567
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 567
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 567
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[53] + (u64 const   )x[5])));
#line 567
      g += t1___52;
#line 567
      c = t0___52 + t1___52;
#line 567
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 568
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 568
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 568
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 568
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[54] + (u64 const   )x[6])));
#line 568
      f += t1___53;
#line 568
      b = t0___53 + t1___53;
#line 568
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 569
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 569
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 569
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 569
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[55] + (u64 const   )x[7])));
#line 569
      e += t1___54;
#line 569
      a = t0___54 + t1___54;
#line 569
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 570
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 570
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 570
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 570
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[56] + (u64 const   )x[8])));
#line 570
      d += t1___55;
#line 570
      h = t0___55 + t1___55;
#line 570
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 571
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 571
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 571
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 571
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[57] + (u64 const   )x[9])));
#line 571
      c += t1___56;
#line 571
      g = t0___56 + t1___56;
#line 571
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 572
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 572
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 572
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 572
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[58] + (u64 const   )x[10])));
#line 572
      b += t1___57;
#line 572
      f = t0___57 + t1___57;
#line 572
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 573
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 573
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 573
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 573
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[59] + (u64 const   )x[11])));
#line 573
      a += t1___58;
#line 573
      e = t0___58 + t1___58;
#line 573
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 574
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 574
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 574
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 574
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[60] + (u64 const   )x[12])));
#line 574
      h += t1___59;
#line 574
      d = t0___59 + t1___59;
#line 574
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 575
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 575
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 575
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 575
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[61] + (u64 const   )x[13])));
#line 575
      g += t1___60;
#line 575
      c = t0___60 + t1___60;
#line 575
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 576
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 576
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 576
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 576
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[62] + (u64 const   )x[14])));
#line 576
      f += t1___61;
#line 576
      b = t0___61 + t1___61;
#line 576
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 577
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 577
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 577
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 577
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[63] + (u64 const   )x[15])));
#line 577
      e += t1___62;
#line 577
      a = t0___62 + t1___62;
#line 577
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 578
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 578
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 578
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 578
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[64] + (u64 const   )x[0])));
#line 578
      d += t1___63;
#line 578
      h = t0___63 + t1___63;
#line 578
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    {
#line 579
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 579
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 579
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 579
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[65] + (u64 const   )x[1])));
#line 579
      c += t1___64;
#line 579
      g = t0___64 + t1___64;
#line 579
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 580
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 580
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 580
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 580
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[66] + (u64 const   )x[2])));
#line 580
      b += t1___65;
#line 580
      f = t0___65 + t1___65;
#line 580
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    {
#line 581
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 581
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 581
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 581
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[67] + (u64 const   )x[3])));
#line 581
      a += t1___66;
#line 581
      e = t0___66 + t1___66;
#line 581
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 582
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 582
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 582
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 582
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[68] + (u64 const   )x[4])));
#line 582
      h += t1___67;
#line 582
      d = t0___67 + t1___67;
#line 582
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 583
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 583
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 583
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 583
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[69] + (u64 const   )x[5])));
#line 583
      g += t1___68;
#line 583
      c = t0___68 + t1___68;
#line 583
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 584
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 584
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 584
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 584
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[70] + (u64 const   )x[6])));
#line 584
      f += t1___69;
#line 584
      b = t0___69 + t1___69;
#line 584
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    {
#line 585
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 585
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 585
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 585
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[71] + (u64 const   )x[7])));
#line 585
      e += t1___70;
#line 585
      a = t0___70 + t1___70;
#line 585
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
    {
#line 586
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 586
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 586
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 586
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[72] + (u64 const   )x[8])));
#line 586
      d += t1___71;
#line 586
      h = t0___71 + t1___71;
#line 586
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 587
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 587
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 587
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 587
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[73] + (u64 const   )x[9])));
#line 587
      c += t1___72;
#line 587
      g = t0___72 + t1___72;
#line 587
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
    {
#line 588
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 588
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 588
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 588
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[74] + (u64 const   )x[10])));
#line 588
      b += t1___73;
#line 588
      f = t0___73 + t1___73;
#line 588
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
    {
#line 589
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 589
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 589
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 589
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[75] + (u64 const   )x[11])));
#line 589
      a += t1___74;
#line 589
      e = t0___74 + t1___74;
#line 589
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    {
#line 590
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 590
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 590
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 590
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[76] + (u64 const   )x[12])));
#line 590
      h += t1___75;
#line 590
      d = t0___75 + t1___75;
#line 590
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 591
    while (1) {
      while_continue___78: /* CIL Label */ ;
#line 591
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 591
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 591
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[77] + (u64 const   )x[13])));
#line 591
      g += t1___76;
#line 591
      c = t0___76 + t1___76;
#line 591
      goto while_break___78;
    }
    while_break___78: /* CIL Label */ ;
    }
    {
#line 592
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 592
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 592
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 592
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[78] + (u64 const   )x[14])));
#line 592
      f += t1___77;
#line 592
      b = t0___77 + t1___77;
#line 592
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    {
#line 593
    while (1) {
      while_continue___80: /* CIL Label */ ;
#line 593
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 593
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 593
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[79] + (u64 const   )x[15])));
#line 593
      e += t1___78;
#line 593
      a = t0___78 + t1___78;
#line 593
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 595
    tmp = ctx->state[0] + a;
#line 595
    ctx->state[0] = tmp;
#line 595
    a = tmp;
#line 596
    tmp___0 = ctx->state[1] + b;
#line 596
    ctx->state[1] = tmp___0;
#line 596
    b = tmp___0;
#line 597
    tmp___1 = ctx->state[2] + c;
#line 597
    ctx->state[2] = tmp___1;
#line 597
    c = tmp___1;
#line 598
    tmp___2 = ctx->state[3] + d;
#line 598
    ctx->state[3] = tmp___2;
#line 598
    d = tmp___2;
#line 599
    tmp___3 = ctx->state[4] + e;
#line 599
    ctx->state[4] = tmp___3;
#line 599
    e = tmp___3;
#line 600
    tmp___4 = ctx->state[5] + f;
#line 600
    ctx->state[5] = tmp___4;
#line 600
    f = tmp___4;
#line 601
    tmp___5 = ctx->state[6] + g;
#line 601
    ctx->state[6] = tmp___5;
#line 601
    g = tmp___5;
#line 602
    tmp___6 = ctx->state[7] + h;
#line 602
    ctx->state[7] = tmp___6;
#line 602
    h = tmp___6;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  return;
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.h"
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
#line 39
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
#line 45
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 52
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 59
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 60
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 66
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 67
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 73
int sha256_stream(FILE *stream , void *resblock ) ;
#line 74
int sha224_stream(FILE *stream , void *resblock ) ;
#line 80
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 81
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void sha256_init_ctx(struct sha256_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 59
  ctx->state[0] = (uint32_t )1779033703UL;
#line 60
  ctx->state[1] = (uint32_t )3144134277UL;
#line 61
  ctx->state[2] = (uint32_t )1013904242UL;
#line 62
  ctx->state[3] = (uint32_t )2773480762UL;
#line 63
  ctx->state[4] = (uint32_t )1359893119UL;
#line 64
  ctx->state[5] = (uint32_t )2600822924UL;
#line 65
  ctx->state[6] = (uint32_t )528734635UL;
#line 66
  ctx->state[7] = (uint32_t )1541459225UL;
#line 68
  tmp = (uint32_t )0;
#line 68
  ctx->total[1] = tmp;
#line 68
  ctx->total[0] = tmp;
#line 69
  ctx->buflen = (size_t )0;
#line 70
  return;
}
}
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void sha224_init_ctx(struct sha256_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 75
  ctx->state[0] = (uint32_t )3238371032UL;
#line 76
  ctx->state[1] = (uint32_t )914150663UL;
#line 77
  ctx->state[2] = (uint32_t )812702999UL;
#line 78
  ctx->state[3] = (uint32_t )4144912697UL;
#line 79
  ctx->state[4] = (uint32_t )4290775857UL;
#line 80
  ctx->state[5] = (uint32_t )1750603025UL;
#line 81
  ctx->state[6] = (uint32_t )1694076839UL;
#line 82
  ctx->state[7] = (uint32_t )3204075428UL;
#line 84
  tmp = (uint32_t )0;
#line 84
  ctx->total[1] = tmp;
#line 84
  ctx->total[0] = tmp;
#line 85
  ctx->buflen = (size_t )0;
#line 86
  return;
}
}
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 


  {
  {
#line 94
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(& v), sizeof(v));
  }
#line 95
  return;
}
}
#line 99 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 103
  r = (char *)resbuf;
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < 8)) {
#line 105
      goto while_break;
    }
    {
#line 106
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (resbuf);
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 115
  r = (char *)resbuf;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 7)) {
#line 117
      goto while_break;
    }
    {
#line 118
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 117
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (resbuf);
}
}
#line 125 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 129
  bytes = ctx->buflen;
#line 130
  if (bytes < 56UL) {
#line 130
    tmp = 16;
  } else {
#line 130
    tmp = 32;
  }
#line 130
  size = (size_t )tmp;
#line 133
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
#line 134
  if ((size_t )ctx->total[0] < bytes) {
#line 135
    (ctx->total[1]) ++;
  }
  {
#line 140
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
#line 142
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
#line 145
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf___0),
         (size - 2UL) * 4UL - bytes);
#line 148
  sha256_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
  {
#line 154
  sha256_conclude_ctx(ctx);
#line 155
  tmp = sha256_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
  }
#line 155
  return (tmp);
}
}
#line 158 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
  {
#line 161
  sha256_conclude_ctx(ctx);
#line 162
  tmp = sha224_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
  }
#line 162
  return (tmp);
}
}
#line 168 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
int sha256_stream(FILE *stream , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 176
  sha256_init_ctx(& ctx);
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    sum = (size_t )0;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 190
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 192
      sum += n;
      }
#line 194
      if (sum == 4096UL) {
#line 195
        goto while_break___0;
      }
#line 197
      if (n == 0UL) {
        {
#line 202
        tmp = ferror_unlocked(stream);
        }
#line 202
        if (tmp) {
#line 203
          return (1);
        }
#line 204
        goto process_partial_block;
      }
      {
#line 210
      tmp___0 = feof_unlocked(stream);
      }
#line 210
      if (tmp___0) {
#line 211
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 217
    sha256_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 223
  if (sum > 0UL) {
    {
#line 224
    sha256_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 227
  sha256_finish_ctx(& ctx, resblock);
  }
#line 228
  return (0);
}
}
#line 232 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
int sha224_stream(FILE *stream , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 240
  sha224_init_ctx(& ctx);
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    sum = (size_t )0;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 254
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 256
      sum += n;
      }
#line 258
      if (sum == 4096UL) {
#line 259
        goto while_break___0;
      }
#line 261
      if (n == 0UL) {
        {
#line 266
        tmp = ferror_unlocked(stream);
        }
#line 266
        if (tmp) {
#line 267
          return (1);
        }
#line 268
        goto process_partial_block;
      }
      {
#line 274
      tmp___0 = feof_unlocked(stream);
      }
#line 274
      if (tmp___0) {
#line 275
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    sha256_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 287
  if (sum > 0UL) {
    {
#line 288
    sha256_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 291
  sha224_finish_ctx(& ctx, resblock);
  }
#line 292
  return (0);
}
}
#line 299 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  void *tmp ;

  {
  {
#line 305
  sha256_init_ctx(& ctx);
#line 308
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 311
  tmp = sha256_finish_ctx(& ctx, resblock);
  }
#line 311
  return (tmp);
}
}
#line 314 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  void *tmp ;

  {
  {
#line 320
  sha224_init_ctx(& ctx);
#line 323
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 326
  tmp = sha224_finish_ctx(& ctx, resblock);
  }
#line 326
  return (tmp);
}
}
#line 329 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 334
  if (ctx->buflen != 0UL) {
#line 336
    left_over = ctx->buflen;
#line 337
    if (128UL - left_over > len) {
#line 337
      tmp = len;
    } else {
#line 337
      tmp = 128UL - left_over;
    }
    {
#line 337
    add = tmp;
#line 339
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 340
    ctx->buflen += add;
    }
#line 342
    if (ctx->buflen > 64UL) {
      {
#line 344
      sha256_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffffc0UL,
                           ctx);
#line 346
      ctx->buflen &= 63UL;
#line 348
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             ctx->buflen);
      }
    }
#line 353
    buffer = (void const   *)((char const   *)buffer + add);
#line 354
    len -= add;
  }
#line 358
  if (len >= 64UL) {
#line 363
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290 *)0)->x) != 0UL) {
      {
#line 364
      while (1) {
        while_continue: /* CIL Label */ ;
#line 364
        if (! (len > 64UL)) {
#line 364
          goto while_break;
        }
        {
#line 366
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 366
        sha256_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 367
        buffer = (void const   *)((char const   *)buffer + 64);
#line 368
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 373
      sha256_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 374
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 375
      len &= 63UL;
      }
    }
  }
#line 380
  if (len > 0UL) {
    {
#line 382
    left_over___0 = ctx->buflen;
#line 384
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 385
    left_over___0 += len;
    }
#line 386
    if (left_over___0 >= 64UL) {
      {
#line 388
      sha256_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 389
      left_over___0 -= 64UL;
#line 390
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 392
    ctx->buflen = left_over___0;
  }
#line 394
  return;
}
}
#line 400 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static uint32_t const   sha256_round_constants[64]  = 
#line 400
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
#line 427 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ 
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t tm ;
  uint32_t t0 ;
  uint32_t t1 ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 430
  words = (uint32_t const   *)buffer;
#line 431
  nwords = len / sizeof(uint32_t );
#line 432
  endp = words + nwords;
#line 434
  a = ctx->state[0];
#line 435
  b = ctx->state[1];
#line 436
  c = ctx->state[2];
#line 437
  d = ctx->state[3];
#line 438
  e = ctx->state[4];
#line 439
  f = ctx->state[5];
#line 440
  g = ctx->state[6];
#line 441
  h = ctx->state[7];
#line 446
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 447
  if ((size_t )ctx->total[0] < len) {
#line 448
    (ctx->total[1]) ++;
  }
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 468
      goto while_break;
    }
#line 474
    t = 0;
    {
#line 474
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 474
      if (! (t < 16)) {
#line 474
        goto while_break___0;
      }
#line 476
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 477
      words ++;
#line 474
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 480
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 480
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 480
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[0]) + x[0];
#line 480
      d += t1;
#line 480
      h = t0 + t1;
#line 480
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 481
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 481
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 481
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[1]) + x[1];
#line 481
      c += t1;
#line 481
      g = t0 + t1;
#line 481
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 482
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 482
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 482
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[2]) + x[2];
#line 482
      b += t1;
#line 482
      f = t0 + t1;
#line 482
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 483
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 483
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 483
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[3]) + x[3];
#line 483
      a += t1;
#line 483
      e = t0 + t1;
#line 483
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 484
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 484
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 484
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[4]) + x[4];
#line 484
      h += t1;
#line 484
      d = t0 + t1;
#line 484
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 485
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 485
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[5]) + x[5];
#line 485
      g += t1;
#line 485
      c = t0 + t1;
#line 485
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 486
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 486
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 486
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[6]) + x[6];
#line 486
      f += t1;
#line 486
      b = t0 + t1;
#line 486
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 487
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 487
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[7]) + x[7];
#line 487
      e += t1;
#line 487
      a = t0 + t1;
#line 487
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 488
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 488
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 488
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[8]) + x[8];
#line 488
      d += t1;
#line 488
      h = t0 + t1;
#line 488
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 489
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 489
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 489
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[9]) + x[9];
#line 489
      c += t1;
#line 489
      g = t0 + t1;
#line 489
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 490
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 490
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 490
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[10]) + x[10];
#line 490
      b += t1;
#line 490
      f = t0 + t1;
#line 490
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 491
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 491
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 491
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[11]) + x[11];
#line 491
      a += t1;
#line 491
      e = t0 + t1;
#line 491
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 492
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 492
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 492
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[12]) + x[12];
#line 492
      h += t1;
#line 492
      d = t0 + t1;
#line 492
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 493
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 493
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 493
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[13]) + x[13];
#line 493
      g += t1;
#line 493
      c = t0 + t1;
#line 493
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 494
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 494
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 494
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[14]) + x[14];
#line 494
      f += t1;
#line 494
      b = t0 + t1;
#line 494
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 495
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 495
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 495
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[15]) + x[15];
#line 495
      e += t1;
#line 495
      a = t0 + t1;
#line 495
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 496
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 496
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 496
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 496
      x[0] = tm;
#line 496
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[16]) + x[0];
#line 496
      d += t1;
#line 496
      h = t0 + t1;
#line 496
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 497
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 497
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 497
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 497
      x[1] = tm;
#line 497
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[17]) + x[1];
#line 497
      c += t1;
#line 497
      g = t0 + t1;
#line 497
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 498
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 498
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 498
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 498
      x[2] = tm;
#line 498
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[18]) + x[2];
#line 498
      b += t1;
#line 498
      f = t0 + t1;
#line 498
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 499
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 499
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 499
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 499
      x[3] = tm;
#line 499
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[19]) + x[3];
#line 499
      a += t1;
#line 499
      e = t0 + t1;
#line 499
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 500
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 500
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 500
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 500
      x[4] = tm;
#line 500
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[20]) + x[4];
#line 500
      h += t1;
#line 500
      d = t0 + t1;
#line 500
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 501
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 501
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 501
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 501
      x[5] = tm;
#line 501
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[21]) + x[5];
#line 501
      g += t1;
#line 501
      c = t0 + t1;
#line 501
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 502
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 502
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 502
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 502
      x[6] = tm;
#line 502
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[22]) + x[6];
#line 502
      f += t1;
#line 502
      b = t0 + t1;
#line 502
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 503
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 503
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 503
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 503
      x[7] = tm;
#line 503
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[23]) + x[7];
#line 503
      e += t1;
#line 503
      a = t0 + t1;
#line 503
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 504
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 504
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 504
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 504
      x[8] = tm;
#line 504
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[24]) + x[8];
#line 504
      d += t1;
#line 504
      h = t0 + t1;
#line 504
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 505
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 505
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 505
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 505
      x[9] = tm;
#line 505
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[25]) + x[9];
#line 505
      c += t1;
#line 505
      g = t0 + t1;
#line 505
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 506
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 506
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 506
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 506
      x[10] = tm;
#line 506
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[26]) + x[10];
#line 506
      b += t1;
#line 506
      f = t0 + t1;
#line 506
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 507
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 507
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 507
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 507
      x[11] = tm;
#line 507
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[27]) + x[11];
#line 507
      a += t1;
#line 507
      e = t0 + t1;
#line 507
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 508
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 508
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 508
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 508
      x[12] = tm;
#line 508
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[28]) + x[12];
#line 508
      h += t1;
#line 508
      d = t0 + t1;
#line 508
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 509
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 509
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 509
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 509
      x[13] = tm;
#line 509
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[29]) + x[13];
#line 509
      g += t1;
#line 509
      c = t0 + t1;
#line 509
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 510
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 510
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 510
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 510
      x[14] = tm;
#line 510
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[30]) + x[14];
#line 510
      f += t1;
#line 510
      b = t0 + t1;
#line 510
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 511
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 511
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 511
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 511
      x[15] = tm;
#line 511
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[31]) + x[15];
#line 511
      e += t1;
#line 511
      a = t0 + t1;
#line 511
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 512
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 512
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 512
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 512
      x[0] = tm;
#line 512
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[32]) + x[0];
#line 512
      d += t1;
#line 512
      h = t0 + t1;
#line 512
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 513
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 513
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 513
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 513
      x[1] = tm;
#line 513
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[33]) + x[1];
#line 513
      c += t1;
#line 513
      g = t0 + t1;
#line 513
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 514
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 514
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 514
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 514
      x[2] = tm;
#line 514
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[34]) + x[2];
#line 514
      b += t1;
#line 514
      f = t0 + t1;
#line 514
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 515
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 515
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 515
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 515
      x[3] = tm;
#line 515
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[35]) + x[3];
#line 515
      a += t1;
#line 515
      e = t0 + t1;
#line 515
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 516
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 516
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 516
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 516
      x[4] = tm;
#line 516
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[36]) + x[4];
#line 516
      h += t1;
#line 516
      d = t0 + t1;
#line 516
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 517
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 517
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 517
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 517
      x[5] = tm;
#line 517
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[37]) + x[5];
#line 517
      g += t1;
#line 517
      c = t0 + t1;
#line 517
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 518
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 518
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 518
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 518
      x[6] = tm;
#line 518
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[38]) + x[6];
#line 518
      f += t1;
#line 518
      b = t0 + t1;
#line 518
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 519
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 519
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 519
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 519
      x[7] = tm;
#line 519
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[39]) + x[7];
#line 519
      e += t1;
#line 519
      a = t0 + t1;
#line 519
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 520
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 520
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 520
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 520
      x[8] = tm;
#line 520
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[40]) + x[8];
#line 520
      d += t1;
#line 520
      h = t0 + t1;
#line 520
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 521
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 521
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 521
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 521
      x[9] = tm;
#line 521
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[41]) + x[9];
#line 521
      c += t1;
#line 521
      g = t0 + t1;
#line 521
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 522
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 522
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 522
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 522
      x[10] = tm;
#line 522
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[42]) + x[10];
#line 522
      b += t1;
#line 522
      f = t0 + t1;
#line 522
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 523
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 523
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 523
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 523
      x[11] = tm;
#line 523
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[43]) + x[11];
#line 523
      a += t1;
#line 523
      e = t0 + t1;
#line 523
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 524
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 524
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 524
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 524
      x[12] = tm;
#line 524
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[44]) + x[12];
#line 524
      h += t1;
#line 524
      d = t0 + t1;
#line 524
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 525
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 525
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 525
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 525
      x[13] = tm;
#line 525
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[45]) + x[13];
#line 525
      g += t1;
#line 525
      c = t0 + t1;
#line 525
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 526
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 526
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 526
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 526
      x[14] = tm;
#line 526
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[46]) + x[14];
#line 526
      f += t1;
#line 526
      b = t0 + t1;
#line 526
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 527
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 527
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 527
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 527
      x[15] = tm;
#line 527
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[47]) + x[15];
#line 527
      e += t1;
#line 527
      a = t0 + t1;
#line 527
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 528
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 528
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 528
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 528
      x[0] = tm;
#line 528
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[48]) + x[0];
#line 528
      d += t1;
#line 528
      h = t0 + t1;
#line 528
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 529
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 529
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 529
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 529
      x[1] = tm;
#line 529
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[49]) + x[1];
#line 529
      c += t1;
#line 529
      g = t0 + t1;
#line 529
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 530
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 530
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 530
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 530
      x[2] = tm;
#line 530
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[50]) + x[2];
#line 530
      b += t1;
#line 530
      f = t0 + t1;
#line 530
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 531
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 531
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 531
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 531
      x[3] = tm;
#line 531
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[51]) + x[3];
#line 531
      a += t1;
#line 531
      e = t0 + t1;
#line 531
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 532
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 532
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 532
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 532
      x[4] = tm;
#line 532
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[52]) + x[4];
#line 532
      h += t1;
#line 532
      d = t0 + t1;
#line 532
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 533
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 533
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 533
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 533
      x[5] = tm;
#line 533
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[53]) + x[5];
#line 533
      g += t1;
#line 533
      c = t0 + t1;
#line 533
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 534
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 534
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 534
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 534
      x[6] = tm;
#line 534
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[54]) + x[6];
#line 534
      f += t1;
#line 534
      b = t0 + t1;
#line 534
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 535
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 535
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 535
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 535
      x[7] = tm;
#line 535
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[55]) + x[7];
#line 535
      e += t1;
#line 535
      a = t0 + t1;
#line 535
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 536
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 536
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 536
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 536
      x[8] = tm;
#line 536
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[56]) + x[8];
#line 536
      d += t1;
#line 536
      h = t0 + t1;
#line 536
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 537
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 537
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 537
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 537
      x[9] = tm;
#line 537
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[57]) + x[9];
#line 537
      c += t1;
#line 537
      g = t0 + t1;
#line 537
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 538
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 538
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 538
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 538
      x[10] = tm;
#line 538
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[58]) + x[10];
#line 538
      b += t1;
#line 538
      f = t0 + t1;
#line 538
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 539
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 539
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 539
      x[11] = tm;
#line 539
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[59]) + x[11];
#line 539
      a += t1;
#line 539
      e = t0 + t1;
#line 539
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 540
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 540
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 540
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 540
      x[12] = tm;
#line 540
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[60]) + x[12];
#line 540
      h += t1;
#line 540
      d = t0 + t1;
#line 540
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 541
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 541
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 541
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 541
      x[13] = tm;
#line 541
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[61]) + x[13];
#line 541
      g += t1;
#line 541
      c = t0 + t1;
#line 541
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 542
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 542
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 542
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 542
      x[14] = tm;
#line 542
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[62]) + x[14];
#line 542
      f += t1;
#line 542
      b = t0 + t1;
#line 542
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 543
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 543
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 543
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 543
      x[15] = tm;
#line 543
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[63]) + x[15];
#line 543
      e += t1;
#line 543
      a = t0 + t1;
#line 543
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 545
    tmp = ctx->state[0] + a;
#line 545
    ctx->state[0] = tmp;
#line 545
    a = tmp;
#line 546
    tmp___0 = ctx->state[1] + b;
#line 546
    ctx->state[1] = tmp___0;
#line 546
    b = tmp___0;
#line 547
    tmp___1 = ctx->state[2] + c;
#line 547
    ctx->state[2] = tmp___1;
#line 547
    c = tmp___1;
#line 548
    tmp___2 = ctx->state[3] + d;
#line 548
    ctx->state[3] = tmp___2;
#line 548
    d = tmp___2;
#line 549
    tmp___3 = ctx->state[4] + e;
#line 549
    ctx->state[4] = tmp___3;
#line 549
    e = tmp___3;
#line 550
    tmp___4 = ctx->state[5] + f;
#line 550
    ctx->state[5] = tmp___4;
#line 550
    f = tmp___4;
#line 551
    tmp___5 = ctx->state[6] + g;
#line 551
    ctx->state[6] = tmp___5;
#line 551
    g = tmp___5;
#line 552
    tmp___6 = ctx->state[7] + h;
#line 552
    ctx->state[7] = tmp___6;
#line 552
    h = tmp___6;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return;
}
}
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 50
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 57
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 64
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 70
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 76
int sha1_stream(FILE *stream , void *resblock ) ;
#line 82
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
static unsigned char const   fillbuf___1[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 60
  ctx->A = (uint32_t )1732584193;
#line 61
  ctx->B = 4023233417U;
#line 62
  ctx->C = 2562383102U;
#line 63
  ctx->D = (uint32_t )271733878;
#line 64
  ctx->E = 3285377520U;
#line 66
  tmp = (uint32_t )0;
#line 66
  ctx->total[1] = tmp;
#line 66
  ctx->total[0] = tmp;
#line 67
  ctx->buflen = (uint32_t )0;
#line 68
  return;
}
}
#line 81 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
  {
#line 84
  r = (char *)resbuf;
#line 85
  set_uint32(r + 0UL, (uint32_t )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24)));
#line 86
  set_uint32(r + sizeof(ctx->B), (uint32_t )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24)));
#line 87
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24)));
#line 88
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24)));
#line 89
  set_uint32(r + 4UL * sizeof(ctx->E), (uint32_t )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24)));
  }
#line 91
  return (resbuf);
}
}
#line 96 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 100
  bytes = ctx->buflen;
#line 101
  if (bytes < 56U) {
#line 101
    tmp = 16;
  } else {
#line 101
    tmp = 32;
  }
#line 101
  size = (size_t )tmp;
#line 104
  ctx->total[0] += bytes;
#line 105
  if (ctx->total[0] < bytes) {
#line 106
    (ctx->total[1]) ++;
  }
  {
#line 109
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 110
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 112
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf___1),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 115
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 117
  tmp___0 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
  }
#line 117
  return (tmp___0);
}
}
#line 123 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 131
  sha1_init_ctx(& ctx);
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    sum = (size_t )0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 145
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 147
      sum += n;
      }
#line 149
      if (sum == 4096UL) {
#line 150
        goto while_break___0;
      }
#line 152
      if (n == 0UL) {
        {
#line 157
        tmp = ferror_unlocked(stream);
        }
#line 157
        if (tmp) {
#line 158
          return (1);
        }
#line 159
        goto process_partial_block;
      }
      {
#line 165
      tmp___0 = feof_unlocked(stream);
      }
#line 165
      if (tmp___0) {
#line 166
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 172
    sha1_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 178
  if (sum > 0UL) {
    {
#line 179
    sha1_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 182
  sha1_finish_ctx(& ctx, resblock);
  }
#line 183
  return (0);
}
}
#line 190 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  void *tmp ;

  {
  {
#line 196
  sha1_init_ctx(& ctx);
#line 199
  sha1_process_bytes((void const   *)buffer, len, & ctx);
#line 202
  tmp = sha1_finish_ctx(& ctx, resblock);
  }
#line 202
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 210
  if (ctx->buflen != 0U) {
#line 212
    left_over = (size_t )ctx->buflen;
#line 213
    if (128UL - left_over > len) {
#line 213
      tmp = len;
    } else {
#line 213
      tmp = 128UL - left_over;
    }
    {
#line 213
    add = tmp;
#line 215
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 216
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
#line 218
    if (ctx->buflen > 64U) {
      {
#line 220
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
#line 222
      ctx->buflen &= 63U;
#line 224
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 229
    buffer = (void const   *)((char const   *)buffer + add);
#line 230
    len -= add;
  }
#line 234
  if (len >= 64UL) {
#line 239
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290___0 *)0)->x) != 0UL) {
      {
#line 240
      while (1) {
        while_continue: /* CIL Label */ ;
#line 240
        if (! (len > 64UL)) {
#line 240
          goto while_break;
        }
        {
#line 242
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 242
        sha1_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 243
        buffer = (void const   *)((char const   *)buffer + 64);
#line 244
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 249
      sha1_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 250
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 251
      len &= 63UL;
      }
    }
  }
#line 256
  if (len > 0UL) {
    {
#line 258
    left_over___0 = (size_t )ctx->buflen;
#line 260
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 261
    left_over___0 += len;
    }
#line 262
    if (left_over___0 >= 64UL) {
      {
#line 264
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 265
      left_over___0 -= 64UL;
#line 266
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 268
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 270
  return;
}
}
#line 290 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ 
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t tm ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 293
  words = (uint32_t const   *)buffer;
#line 294
  nwords = len / sizeof(uint32_t );
#line 295
  endp = words + nwords;
#line 297
  a = ctx->A;
#line 298
  b = ctx->B;
#line 299
  c = ctx->C;
#line 300
  d = ctx->D;
#line 301
  e = ctx->E;
#line 306
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 307
  if ((size_t )ctx->total[0] < len) {
#line 308
    (ctx->total[1]) ++;
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 323
      goto while_break;
    }
#line 327
    t = 0;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (! (t < 16)) {
#line 327
        goto while_break___0;
      }
#line 329
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 330
      words ++;
#line 327
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 333
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 333
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 333
      b = (b << 30) | (b >> 2);
#line 333
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 334
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 334
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 334
      a = (a << 30) | (a >> 2);
#line 334
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 335
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 335
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 335
      e = (e << 30) | (e >> 2);
#line 335
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 336
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 336
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 336
      d = (d << 30) | (d >> 2);
#line 336
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 337
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 337
      c = (c << 30) | (c >> 2);
#line 337
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 338
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 338
      b = (b << 30) | (b >> 2);
#line 338
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 339
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 339
      a = (a << 30) | (a >> 2);
#line 339
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 340
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 340
      e = (e << 30) | (e >> 2);
#line 340
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 341
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 341
      d = (d << 30) | (d >> 2);
#line 341
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 342
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 342
      c = (c << 30) | (c >> 2);
#line 342
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 343
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 343
      b = (b << 30) | (b >> 2);
#line 343
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 344
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 344
      a = (a << 30) | (a >> 2);
#line 344
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 345
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 345
      e = (e << 30) | (e >> 2);
#line 345
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 346
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 346
      d = (d << 30) | (d >> 2);
#line 346
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 347
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 347
      c = (c << 30) | (c >> 2);
#line 347
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 348
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 348
      b = (b << 30) | (b >> 2);
#line 348
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 349
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 349
      x[0] = (tm << 1) | (tm >> 31);
#line 349
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 349
      a = (a << 30) | (a >> 2);
#line 349
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 350
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 350
      x[1] = (tm << 1) | (tm >> 31);
#line 350
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 350
      e = (e << 30) | (e >> 2);
#line 350
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 351
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 351
      x[2] = (tm << 1) | (tm >> 31);
#line 351
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 351
      d = (d << 30) | (d >> 2);
#line 351
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 352
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 352
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 352
      x[3] = (tm << 1) | (tm >> 31);
#line 352
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 352
      c = (c << 30) | (c >> 2);
#line 352
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 353
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 353
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 353
      x[4] = (tm << 1) | (tm >> 31);
#line 353
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 353
      b = (b << 30) | (b >> 2);
#line 353
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 354
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 354
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 354
      x[5] = (tm << 1) | (tm >> 31);
#line 354
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 354
      a = (a << 30) | (a >> 2);
#line 354
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 355
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 355
      x[6] = (tm << 1) | (tm >> 31);
#line 355
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 355
      e = (e << 30) | (e >> 2);
#line 355
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 356
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 356
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 356
      x[7] = (tm << 1) | (tm >> 31);
#line 356
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 356
      d = (d << 30) | (d >> 2);
#line 356
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 357
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 357
      x[8] = (tm << 1) | (tm >> 31);
#line 357
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 357
      c = (c << 30) | (c >> 2);
#line 357
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 358
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 358
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 358
      x[9] = (tm << 1) | (tm >> 31);
#line 358
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 358
      b = (b << 30) | (b >> 2);
#line 358
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 359
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 359
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 359
      x[10] = (tm << 1) | (tm >> 31);
#line 359
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 359
      a = (a << 30) | (a >> 2);
#line 359
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 360
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 360
      x[11] = (tm << 1) | (tm >> 31);
#line 360
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 360
      e = (e << 30) | (e >> 2);
#line 360
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 361
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 361
      x[12] = (tm << 1) | (tm >> 31);
#line 361
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 361
      d = (d << 30) | (d >> 2);
#line 361
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 362
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 362
      x[13] = (tm << 1) | (tm >> 31);
#line 362
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 362
      c = (c << 30) | (c >> 2);
#line 362
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 363
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 363
      x[14] = (tm << 1) | (tm >> 31);
#line 363
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 363
      b = (b << 30) | (b >> 2);
#line 363
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 364
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 364
      x[15] = (tm << 1) | (tm >> 31);
#line 364
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 364
      a = (a << 30) | (a >> 2);
#line 364
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 365
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 365
      x[0] = (tm << 1) | (tm >> 31);
#line 365
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 365
      e = (e << 30) | (e >> 2);
#line 365
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 366
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 366
      x[1] = (tm << 1) | (tm >> 31);
#line 366
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 366
      d = (d << 30) | (d >> 2);
#line 366
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 367
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 367
      x[2] = (tm << 1) | (tm >> 31);
#line 367
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 367
      c = (c << 30) | (c >> 2);
#line 367
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 368
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 368
      x[3] = (tm << 1) | (tm >> 31);
#line 368
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 368
      b = (b << 30) | (b >> 2);
#line 368
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 369
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 369
      x[4] = (tm << 1) | (tm >> 31);
#line 369
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 369
      a = (a << 30) | (a >> 2);
#line 369
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 370
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 370
      x[5] = (tm << 1) | (tm >> 31);
#line 370
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 370
      e = (e << 30) | (e >> 2);
#line 370
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 371
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 371
      x[6] = (tm << 1) | (tm >> 31);
#line 371
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 371
      d = (d << 30) | (d >> 2);
#line 371
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 372
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 372
      x[7] = (tm << 1) | (tm >> 31);
#line 372
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 372
      c = (c << 30) | (c >> 2);
#line 372
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 373
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 373
      x[8] = (tm << 1) | (tm >> 31);
#line 373
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 373
      b = (b << 30) | (b >> 2);
#line 373
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 374
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 374
      x[9] = (tm << 1) | (tm >> 31);
#line 374
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 374
      a = (a << 30) | (a >> 2);
#line 374
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 375
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 375
      x[10] = (tm << 1) | (tm >> 31);
#line 375
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 375
      e = (e << 30) | (e >> 2);
#line 375
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 376
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 376
      x[11] = (tm << 1) | (tm >> 31);
#line 376
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 376
      d = (d << 30) | (d >> 2);
#line 376
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 377
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 377
      x[12] = (tm << 1) | (tm >> 31);
#line 377
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 377
      c = (c << 30) | (c >> 2);
#line 377
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 378
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 378
      x[13] = (tm << 1) | (tm >> 31);
#line 378
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 378
      b = (b << 30) | (b >> 2);
#line 378
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 379
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 379
      x[14] = (tm << 1) | (tm >> 31);
#line 379
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 379
      a = (a << 30) | (a >> 2);
#line 379
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 380
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 380
      x[15] = (tm << 1) | (tm >> 31);
#line 380
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 380
      e = (e << 30) | (e >> 2);
#line 380
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 381
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 381
      x[0] = (tm << 1) | (tm >> 31);
#line 381
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 381
      d = (d << 30) | (d >> 2);
#line 381
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 382
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 382
      x[1] = (tm << 1) | (tm >> 31);
#line 382
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 382
      c = (c << 30) | (c >> 2);
#line 382
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 383
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 383
      x[2] = (tm << 1) | (tm >> 31);
#line 383
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 383
      b = (b << 30) | (b >> 2);
#line 383
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 384
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 384
      x[3] = (tm << 1) | (tm >> 31);
#line 384
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 384
      a = (a << 30) | (a >> 2);
#line 384
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 385
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 385
      x[4] = (tm << 1) | (tm >> 31);
#line 385
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 385
      e = (e << 30) | (e >> 2);
#line 385
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 386
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 386
      x[5] = (tm << 1) | (tm >> 31);
#line 386
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 386
      d = (d << 30) | (d >> 2);
#line 386
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 387
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 387
      x[6] = (tm << 1) | (tm >> 31);
#line 387
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 387
      c = (c << 30) | (c >> 2);
#line 387
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 388
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 388
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 388
      x[7] = (tm << 1) | (tm >> 31);
#line 388
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 388
      b = (b << 30) | (b >> 2);
#line 388
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 389
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 389
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 389
      x[8] = (tm << 1) | (tm >> 31);
#line 389
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 389
      a = (a << 30) | (a >> 2);
#line 389
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 390
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 390
      x[9] = (tm << 1) | (tm >> 31);
#line 390
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 390
      e = (e << 30) | (e >> 2);
#line 390
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 391
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 391
      x[10] = (tm << 1) | (tm >> 31);
#line 391
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 391
      d = (d << 30) | (d >> 2);
#line 391
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 392
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 392
      x[11] = (tm << 1) | (tm >> 31);
#line 392
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 392
      c = (c << 30) | (c >> 2);
#line 392
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 393
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 393
      x[12] = (tm << 1) | (tm >> 31);
#line 393
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 393
      b = (b << 30) | (b >> 2);
#line 393
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 394
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 394
      x[13] = (tm << 1) | (tm >> 31);
#line 394
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 394
      a = (a << 30) | (a >> 2);
#line 394
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 395
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 395
      x[14] = (tm << 1) | (tm >> 31);
#line 395
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 395
      e = (e << 30) | (e >> 2);
#line 395
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 396
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 396
      x[15] = (tm << 1) | (tm >> 31);
#line 396
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 396
      d = (d << 30) | (d >> 2);
#line 396
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 397
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 397
      x[0] = (tm << 1) | (tm >> 31);
#line 397
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 397
      c = (c << 30) | (c >> 2);
#line 397
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 398
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 398
      x[1] = (tm << 1) | (tm >> 31);
#line 398
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 398
      b = (b << 30) | (b >> 2);
#line 398
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 399
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 399
      x[2] = (tm << 1) | (tm >> 31);
#line 399
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 399
      a = (a << 30) | (a >> 2);
#line 399
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 400
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 400
      x[3] = (tm << 1) | (tm >> 31);
#line 400
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 400
      e = (e << 30) | (e >> 2);
#line 400
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 401
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 401
      x[4] = (tm << 1) | (tm >> 31);
#line 401
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 401
      d = (d << 30) | (d >> 2);
#line 401
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 402
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 402
      x[5] = (tm << 1) | (tm >> 31);
#line 402
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 402
      c = (c << 30) | (c >> 2);
#line 402
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 403
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 403
      x[6] = (tm << 1) | (tm >> 31);
#line 403
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 403
      b = (b << 30) | (b >> 2);
#line 403
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 404
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 404
      x[7] = (tm << 1) | (tm >> 31);
#line 404
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 404
      a = (a << 30) | (a >> 2);
#line 404
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 405
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 405
      x[8] = (tm << 1) | (tm >> 31);
#line 405
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 405
      e = (e << 30) | (e >> 2);
#line 405
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 406
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 406
      x[9] = (tm << 1) | (tm >> 31);
#line 406
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 406
      d = (d << 30) | (d >> 2);
#line 406
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 407
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 407
      x[10] = (tm << 1) | (tm >> 31);
#line 407
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 407
      c = (c << 30) | (c >> 2);
#line 407
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
    {
#line 408
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 408
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 408
      x[11] = (tm << 1) | (tm >> 31);
#line 408
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 408
      b = (b << 30) | (b >> 2);
#line 408
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    {
#line 409
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 409
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 409
      x[12] = (tm << 1) | (tm >> 31);
#line 409
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 409
      a = (a << 30) | (a >> 2);
#line 409
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 410
    while (1) {
      while_continue___78: /* CIL Label */ ;
#line 410
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 410
      x[13] = (tm << 1) | (tm >> 31);
#line 410
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 410
      e = (e << 30) | (e >> 2);
#line 410
      goto while_break___78;
    }
    while_break___78: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 411
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 411
      x[14] = (tm << 1) | (tm >> 31);
#line 411
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 411
      d = (d << 30) | (d >> 2);
#line 411
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___80: /* CIL Label */ ;
#line 412
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 412
      x[15] = (tm << 1) | (tm >> 31);
#line 412
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 412
      c = (c << 30) | (c >> 2);
#line 412
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 414
    tmp = ctx->A + a;
#line 414
    ctx->A = tmp;
#line 414
    a = tmp;
#line 415
    tmp___0 = ctx->B + b;
#line 415
    ctx->B = tmp___0;
#line 415
    b = tmp___0;
#line 416
    tmp___1 = ctx->C + c;
#line 416
    ctx->C = tmp___1;
#line 416
    c = tmp___1;
#line 417
    tmp___2 = ctx->D + d;
#line 417
    ctx->D = tmp___2;
#line 417
    d = tmp___2;
#line 418
    tmp___3 = ctx->E + e;
#line 418
    ctx->E = tmp___3;
#line 418
    e = tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 222 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_settime)(clockid_t __clock_id ,
                                                                                    struct timespec  const  *__tp ) ;
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/timespec.h"
int settime(struct timespec  const  *ts ) ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                                                   struct timezone  const  *__tz ) ;
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/settime.c"
int settime(struct timespec  const  *ts ) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;
  struct timeval tv ;
  int tmp___1 ;

  {
  {
#line 47
  tmp = clock_settime(0, ts);
#line 47
  r = tmp;
  }
#line 48
  if (r == 0) {
#line 49
    return (r);
  } else {
    {
#line 48
    tmp___0 = __errno_location();
    }
#line 48
    if (*tmp___0 == 1) {
#line 49
      return (r);
    }
  }
  {
#line 57
  tv.tv_sec = (__time_t )ts->tv_sec;
#line 58
  tv.tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
#line 59
  tmp___1 = settimeofday((struct timeval  const  *)(& tv), (struct timezone  const  *)0);
  }
#line 59
  return (tmp___1);
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/acl.h"
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 27
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/set-mode-acl.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 39
  if (desc != -1) {
    {
#line 40
    tmp = fchmod(desc, mode);
    }
#line 40
    return (tmp);
  } else {
    {
#line 42
    tmp___0 = chmod(name, mode);
    }
#line 42
    return (tmp___0);
  }
}
}
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/set-mode-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 477
  tmp = chmod_or_fchmod(name, desc, mode);
  }
#line 477
  return (tmp);
}
}
#line 483 "/home/khheo/project/benchmark/coreutils-7.1/lib/set-mode-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int r ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 486
  tmp = qset_acl(name, desc, mode);
#line 486
  r = tmp;
  }
#line 487
  if (r != 0) {
    {
#line 488
    tmp___0 = quote(name);
#line 488
    tmp___1 = gettext("setting permissions for %s");
#line 488
    tmp___2 = __errno_location();
#line 488
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 489
  return (r);
}
}
#line 24 "./selinux/selinux.h"
__inline static int getfilecon(char const   *s  __attribute__((__unused__)) , char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 26
  tmp = __errno_location();
#line 26
  *tmp = 95;
  }
#line 26
  return (-1);
}
}
#line 30 "./selinux/selinux.h"
__inline static int setfilecon(char const   *s  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 32
  tmp = __errno_location();
#line 32
  *tmp = 95;
  }
#line 32
  return (-1);
}
}
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/selinux-at.h"
int getfileconat(int fd , char const   *file , char **con ) ;
#line 21
int lgetfileconat(int fd , char const   *file , char **con ) ;
#line 22
int setfileconat(int fd , char const   *file , char *con ) ;
#line 23
int lsetfileconat(int fd , char const   *file , char *con ) ;
#line 96 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat.h"
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 97
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 30
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 31
void free_cwd(struct saved_cwd *cwd ) ;
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-priv.h"
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/at-func.c"
int getfileconat(int fd , char const   *file , char **con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char buf___1[512] ;
  char *proc_file ;
  char *tmp___1 ;
  int proc_result ;
  int tmp___2 ;
  int proc_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;

  {
#line 37
  if (fd == -100) {
    {
#line 38
    tmp = getfilecon(file, con);
    }
#line 38
    return (tmp);
  } else
#line 37
  if ((int const   )*(file + 0) == 47) {
    {
#line 38
    tmp = getfilecon(file, con);
    }
#line 38
    return (tmp);
  }
  {
#line 42
  tmp___1 = openat_proc_name((char *)(buf___1), fd, file);
#line 42
  proc_file = tmp___1;
  }
#line 43
  if (proc_file) {
    {
#line 45
    tmp___2 = getfilecon((char const   *)proc_file, con);
#line 45
    proc_result = tmp___2;
#line 46
    tmp___4 = __errno_location();
#line 46
    proc_errno = *tmp___4;
    }
#line 47
    if ((unsigned long )proc_file != (unsigned long )(buf___1)) {
      {
#line 48
      free((void *)proc_file);
      }
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (proc_errno == 20)) {
#line 54
      if (! (proc_errno == 2)) {
#line 54
        if (! (proc_errno == 1)) {
#line 54
          if (! (proc_errno == 13)) {
#line 54
            if (! (proc_errno == 38)) {
#line 54
              if (! (proc_errno == 95)) {
                {
#line 56
                tmp___5 = __errno_location();
#line 56
                *tmp___5 = proc_errno;
                }
#line 57
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 62
  tmp___7 = save_cwd(& saved_cwd);
  }
#line 62
  if (tmp___7 != 0) {
    {
#line 63
    tmp___6 = __errno_location();
#line 63
    openat_save_fail(*tmp___6);
    }
  }
  {
#line 65
  tmp___10 = fchdir(fd);
  }
#line 65
  if (tmp___10 != 0) {
    {
#line 67
    tmp___8 = __errno_location();
#line 67
    saved_errno = *tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    tmp___9 = __errno_location();
#line 69
    *tmp___9 = saved_errno;
    }
#line 70
    return (-1);
  }
  {
#line 73
  tmp___11 = getfilecon(file, con);
#line 73
  err = tmp___11;
  }
#line 74
  if (err < 0) {
    {
#line 74
    tmp___13 = __errno_location();
#line 74
    saved_errno = *tmp___13;
    }
  } else {
#line 74
    saved_errno = 0;
  }
  {
#line 76
  tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 76
  if (tmp___15 != 0) {
    {
#line 77
    tmp___14 = __errno_location();
#line 77
    openat_restore_fail(*tmp___14);
    }
  }
  {
#line 79
  free_cwd(& saved_cwd);
  }
#line 81
  if (saved_errno) {
    {
#line 82
    tmp___16 = __errno_location();
#line 82
    *tmp___16 = saved_errno;
    }
  }
#line 83
  return (err);
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/at-func.c"
int lgetfileconat(int fd , char const   *file , char **con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char buf___1[512] ;
  char *proc_file ;
  char *tmp___1 ;
  int proc_result ;
  int tmp___2 ;
  int proc_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;

  {
#line 37
  if (fd == -100) {
    {
#line 38
    tmp = getfilecon(file, con);
    }
#line 38
    return (tmp);
  } else
#line 37
  if ((int const   )*(file + 0) == 47) {
    {
#line 38
    tmp = getfilecon(file, con);
    }
#line 38
    return (tmp);
  }
  {
#line 42
  tmp___1 = openat_proc_name((char *)(buf___1), fd, file);
#line 42
  proc_file = tmp___1;
  }
#line 43
  if (proc_file) {
    {
#line 45
    tmp___2 = getfilecon((char const   *)proc_file, con);
#line 45
    proc_result = tmp___2;
#line 46
    tmp___4 = __errno_location();
#line 46
    proc_errno = *tmp___4;
    }
#line 47
    if ((unsigned long )proc_file != (unsigned long )(buf___1)) {
      {
#line 48
      free((void *)proc_file);
      }
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (proc_errno == 20)) {
#line 54
      if (! (proc_errno == 2)) {
#line 54
        if (! (proc_errno == 1)) {
#line 54
          if (! (proc_errno == 13)) {
#line 54
            if (! (proc_errno == 38)) {
#line 54
              if (! (proc_errno == 95)) {
                {
#line 56
                tmp___5 = __errno_location();
#line 56
                *tmp___5 = proc_errno;
                }
#line 57
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 62
  tmp___7 = save_cwd(& saved_cwd);
  }
#line 62
  if (tmp___7 != 0) {
    {
#line 63
    tmp___6 = __errno_location();
#line 63
    openat_save_fail(*tmp___6);
    }
  }
  {
#line 65
  tmp___10 = fchdir(fd);
  }
#line 65
  if (tmp___10 != 0) {
    {
#line 67
    tmp___8 = __errno_location();
#line 67
    saved_errno = *tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    tmp___9 = __errno_location();
#line 69
    *tmp___9 = saved_errno;
    }
#line 70
    return (-1);
  }
  {
#line 73
  tmp___11 = getfilecon(file, con);
#line 73
  err = tmp___11;
  }
#line 74
  if (err < 0) {
    {
#line 74
    tmp___13 = __errno_location();
#line 74
    saved_errno = *tmp___13;
    }
  } else {
#line 74
    saved_errno = 0;
  }
  {
#line 76
  tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 76
  if (tmp___15 != 0) {
    {
#line 77
    tmp___14 = __errno_location();
#line 77
    openat_restore_fail(*tmp___14);
    }
  }
  {
#line 79
  free_cwd(& saved_cwd);
  }
#line 81
  if (saved_errno) {
    {
#line 82
    tmp___16 = __errno_location();
#line 82
    *tmp___16 = saved_errno;
    }
  }
#line 83
  return (err);
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/at-func.c"
int setfileconat(int fd , char const   *file , char *con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char buf___1[512] ;
  char *proc_file ;
  char *tmp___1 ;
  int proc_result ;
  int tmp___2 ;
  int proc_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;

  {
#line 37
  if (fd == -100) {
    {
#line 38
    tmp = setfilecon(file, con);
    }
#line 38
    return (tmp);
  } else
#line 37
  if ((int const   )*(file + 0) == 47) {
    {
#line 38
    tmp = setfilecon(file, con);
    }
#line 38
    return (tmp);
  }
  {
#line 42
  tmp___1 = openat_proc_name((char *)(buf___1), fd, file);
#line 42
  proc_file = tmp___1;
  }
#line 43
  if (proc_file) {
    {
#line 45
    tmp___2 = setfilecon((char const   *)proc_file, con);
#line 45
    proc_result = tmp___2;
#line 46
    tmp___4 = __errno_location();
#line 46
    proc_errno = *tmp___4;
    }
#line 47
    if ((unsigned long )proc_file != (unsigned long )(buf___1)) {
      {
#line 48
      free((void *)proc_file);
      }
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (proc_errno == 20)) {
#line 54
      if (! (proc_errno == 2)) {
#line 54
        if (! (proc_errno == 1)) {
#line 54
          if (! (proc_errno == 13)) {
#line 54
            if (! (proc_errno == 38)) {
#line 54
              if (! (proc_errno == 95)) {
                {
#line 56
                tmp___5 = __errno_location();
#line 56
                *tmp___5 = proc_errno;
                }
#line 57
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 62
  tmp___7 = save_cwd(& saved_cwd);
  }
#line 62
  if (tmp___7 != 0) {
    {
#line 63
    tmp___6 = __errno_location();
#line 63
    openat_save_fail(*tmp___6);
    }
  }
  {
#line 65
  tmp___10 = fchdir(fd);
  }
#line 65
  if (tmp___10 != 0) {
    {
#line 67
    tmp___8 = __errno_location();
#line 67
    saved_errno = *tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    tmp___9 = __errno_location();
#line 69
    *tmp___9 = saved_errno;
    }
#line 70
    return (-1);
  }
  {
#line 73
  tmp___11 = setfilecon(file, con);
#line 73
  err = tmp___11;
  }
#line 74
  if (err < 0) {
    {
#line 74
    tmp___13 = __errno_location();
#line 74
    saved_errno = *tmp___13;
    }
  } else {
#line 74
    saved_errno = 0;
  }
  {
#line 76
  tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 76
  if (tmp___15 != 0) {
    {
#line 77
    tmp___14 = __errno_location();
#line 77
    openat_restore_fail(*tmp___14);
    }
  }
  {
#line 79
  free_cwd(& saved_cwd);
  }
#line 81
  if (saved_errno) {
    {
#line 82
    tmp___16 = __errno_location();
#line 82
    *tmp___16 = saved_errno;
    }
  }
#line 83
  return (err);
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/at-func.c"
int lsetfileconat(int fd , char const   *file , char *con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char buf___1[512] ;
  char *proc_file ;
  char *tmp___1 ;
  int proc_result ;
  int tmp___2 ;
  int proc_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;

  {
#line 37
  if (fd == -100) {
    {
#line 38
    tmp = setfilecon(file, con);
    }
#line 38
    return (tmp);
  } else
#line 37
  if ((int const   )*(file + 0) == 47) {
    {
#line 38
    tmp = setfilecon(file, con);
    }
#line 38
    return (tmp);
  }
  {
#line 42
  tmp___1 = openat_proc_name((char *)(buf___1), fd, file);
#line 42
  proc_file = tmp___1;
  }
#line 43
  if (proc_file) {
    {
#line 45
    tmp___2 = setfilecon((char const   *)proc_file, con);
#line 45
    proc_result = tmp___2;
#line 46
    tmp___4 = __errno_location();
#line 46
    proc_errno = *tmp___4;
    }
#line 47
    if ((unsigned long )proc_file != (unsigned long )(buf___1)) {
      {
#line 48
      free((void *)proc_file);
      }
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (proc_errno == 20)) {
#line 54
      if (! (proc_errno == 2)) {
#line 54
        if (! (proc_errno == 1)) {
#line 54
          if (! (proc_errno == 13)) {
#line 54
            if (! (proc_errno == 38)) {
#line 54
              if (! (proc_errno == 95)) {
                {
#line 56
                tmp___5 = __errno_location();
#line 56
                *tmp___5 = proc_errno;
                }
#line 57
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 62
  tmp___7 = save_cwd(& saved_cwd);
  }
#line 62
  if (tmp___7 != 0) {
    {
#line 63
    tmp___6 = __errno_location();
#line 63
    openat_save_fail(*tmp___6);
    }
  }
  {
#line 65
  tmp___10 = fchdir(fd);
  }
#line 65
  if (tmp___10 != 0) {
    {
#line 67
    tmp___8 = __errno_location();
#line 67
    saved_errno = *tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    tmp___9 = __errno_location();
#line 69
    *tmp___9 = saved_errno;
    }
#line 70
    return (-1);
  }
  {
#line 73
  tmp___11 = setfilecon(file, con);
#line 73
  err = tmp___11;
  }
#line 74
  if (err < 0) {
    {
#line 74
    tmp___13 = __errno_location();
#line 74
    saved_errno = *tmp___13;
    }
  } else {
#line 74
    saved_errno = 0;
  }
  {
#line 76
  tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 76
  if (tmp___15 != 0) {
    {
#line 77
    tmp___14 = __errno_location();
#line 77
    openat_restore_fail(*tmp___14);
    }
  }
  {
#line 79
  free_cwd(& saved_cwd);
  }
#line 81
  if (saved_errno) {
    {
#line 82
    tmp___16 = __errno_location();
#line 82
    *tmp___16 = saved_errno;
    }
  }
#line 83
  return (err);
}
}
#line 70 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.h"
__inline static void savewd_init(struct savewd *wd ) 
{ 


  {
#line 73
  wd->state = (enum __anonenum_state_467303978 )0;
#line 74
  return;
}
}
#line 108
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) ;
#line 117
int savewd_restore(struct savewd *wd , int status ) ;
#line 128
void savewd_finish(struct savewd *wd ) ;
#line 144
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
#line 759 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 123 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
static _Bool savewd_save(struct savewd *wd ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 49
  if ((unsigned int )wd->state == 0U) {
#line 49
    goto case_0;
  }
#line 69
  if ((unsigned int )wd->state == 3U) {
#line 69
    goto case_3;
  }
#line 89
  if ((unsigned int )wd->state == 5U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 4U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 2U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 1U) {
#line 89
    goto case_5;
  }
#line 92
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 52
  tmp = open_safer(".", 0);
#line 52
  fd = tmp;
  }
#line 53
  if (0 <= fd) {
#line 55
    wd->state = (enum __anonenum_state_467303978 )1;
#line 56
    wd->val.fd = fd;
#line 57
    goto switch_break;
  }
  {
#line 59
  tmp___1 = __errno_location();
  }
#line 59
  if (*tmp___1 != 13) {
    {
#line 59
    tmp___2 = __errno_location();
    }
#line 59
    if (*tmp___2 != 116) {
      {
#line 61
      wd->state = (enum __anonenum_state_467303978 )4;
#line 62
      tmp___0 = __errno_location();
#line 62
      wd->val.errnum = *tmp___0;
      }
#line 63
      goto switch_break;
    }
  }
#line 66
  wd->state = (enum __anonenum_state_467303978 )3;
#line 67
  wd->val.child = -1;
  case_3: /* CIL Label */ 
#line 70
  if (wd->val.child < 0) {
    {
#line 75
    wd->val.child = fork();
    }
#line 76
    if (wd->val.child != 0) {
#line 78
      if (0 < wd->val.child) {
#line 79
        return ((_Bool)1);
      }
      {
#line 80
      wd->state = (enum __anonenum_state_467303978 )4;
#line 81
      tmp___3 = __errno_location();
#line 81
      wd->val.errnum = *tmp___3;
      }
    }
  }
#line 84
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 90
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 93
  __assert_fail("false", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                93U, "savewd_save");
  }
  switch_break: /* CIL Label */ ;
  }
#line 96
  return ((_Bool)0);
}
}
#line 99 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) 
{ 
  int fd ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___5 ;
  int e ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 103
  fd = -1;
#line 104
  result = 0;
#line 108
  if (open_result) {
#line 108
    goto _L;
  } else
#line 108
  if (options & 1) {
    _L: /* CIL Label */ 
#line 111
    if (options & 1) {
#line 111
      tmp = 131072;
    } else {
#line 111
      tmp = 0;
    }
    {
#line 111
    fd = open(dir, 67840 | tmp);
    }
#line 115
    if (open_result) {
      {
#line 117
      *(open_result + 0) = fd;
#line 118
      tmp___0 = __errno_location();
#line 118
      *(open_result + 1) = *tmp___0;
      }
    }
#line 121
    if (fd < 0) {
      {
#line 121
      tmp___1 = __errno_location();
      }
#line 121
      if (*tmp___1 != 13) {
#line 122
        result = -1;
      } else
#line 121
      if (options & 2) {
#line 122
        result = -1;
      }
    }
  }
#line 125
  if (result == 0) {
#line 125
    if (0 <= fd) {
#line 125
      if (! (options & 4)) {
#line 125
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 127
      tmp___5 = savewd_save(wd);
      }
#line 127
      if (tmp___5) {
#line 129
        open_result = (int *)((void *)0);
#line 130
        result = -2;
      } else {
#line 134
        if (fd < 0) {
          {
#line 134
          tmp___2 = chdir(dir);
#line 134
          result = tmp___2;
          }
        } else {
          {
#line 134
          tmp___3 = fchdir(fd);
#line 134
          result = tmp___3;
          }
        }
#line 136
        if (result == 0) {
          {
#line 139
          if ((unsigned int )wd->state == 1U) {
#line 139
            goto case_1;
          }
#line 145
          if ((unsigned int )wd->state == 5U) {
#line 145
            goto case_5;
          }
#line 145
          if ((unsigned int )wd->state == 2U) {
#line 145
            goto case_5;
          }
#line 145
          if ((unsigned int )wd->state == 4U) {
#line 145
            goto case_5;
          }
#line 148
          if ((unsigned int )wd->state == 3U) {
#line 148
            goto case_3;
          }
#line 152
          goto switch_default;
          case_1: /* CIL Label */ 
#line 140
          wd->state = (enum __anonenum_state_467303978 )2;
#line 141
          goto switch_break;
          case_5: /* CIL Label */ 
          case_2: /* CIL Label */ 
          case_4: /* CIL Label */ 
#line 146
          goto switch_break;
          case_3: /* CIL Label */ 
#line 149
          if (! (wd->val.child == 0)) {
            {
#line 149
            __assert_fail("wd->val.child == 0", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                          149U, "savewd_chdir");
            }
          }
#line 150
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 153
          __assert_fail("false", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                        153U, "savewd_chdir");
          }
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 158
  if (0 <= fd) {
#line 158
    if (! open_result) {
      {
#line 160
      tmp___6 = __errno_location();
#line 160
      e = *tmp___6;
#line 161
      close(fd);
#line 162
      tmp___7 = __errno_location();
#line 162
      *tmp___7 = e;
      }
    }
  }
#line 165
  return (result);
}
}
#line 168 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
int savewd_restore(struct savewd *wd , int status ) 
{ 
  int chdir_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  pid_t child ;
  int child_status ;
  int *tmp___5 ;
  __pid_t tmp___6 ;

  {
  {
#line 174
  if ((unsigned int )wd->state == 1U) {
#line 174
    goto case_1;
  }
#line 174
  if ((unsigned int )wd->state == 0U) {
#line 174
    goto case_1;
  }
#line 179
  if ((unsigned int )wd->state == 2U) {
#line 179
    goto case_2;
  }
#line 194
  if ((unsigned int )wd->state == 4U) {
#line 194
    goto case_4;
  }
#line 199
  if ((unsigned int )wd->state == 3U) {
#line 199
    goto case_3;
  }
#line 219
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 177
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 181
  tmp___0 = fchdir(wd->val.fd);
  }
#line 181
  if (tmp___0 == 0) {
#line 183
    wd->state = (enum __anonenum_state_467303978 )1;
#line 184
    goto switch_break;
  } else {
    {
#line 188
    tmp = __errno_location();
#line 188
    chdir_errno = *tmp;
#line 189
    close(wd->val.fd);
#line 190
    wd->state = (enum __anonenum_state_467303978 )4;
#line 191
    wd->val.errnum = chdir_errno;
    }
  }
  case_4: /* CIL Label */ 
  {
#line 196
  tmp___1 = __errno_location();
#line 196
  *tmp___1 = wd->val.errnum;
  }
#line 197
  return (-1);
  case_3: /* CIL Label */ 
#line 203
  child = wd->val.child;
#line 204
  if (child == 0) {
    {
#line 205
    _exit(status);
    }
  }
#line 206
  if (0 < child) {
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 209
      tmp___6 = waitpid(child, & child_status, 0);
      }
#line 209
      if (! (tmp___6 < 0)) {
#line 209
        goto while_break;
      }
      {
#line 210
      tmp___5 = __errno_location();
      }
#line 210
      if (! (*tmp___5 == 4)) {
        {
#line 210
        __assert_fail("errno == EINTR", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                      210U, "savewd_restore");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 211
    wd->val.child = -1;
#line 212
    if (! ((child_status & 127) == 0)) {
      {
#line 213
      raise(child_status & 127);
      }
    }
#line 214
    return ((child_status & 65280) >> 8);
  }
#line 217
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 220
  __assert_fail("false", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                220U, "savewd_restore");
  }
  switch_break: /* CIL Label */ ;
  }
#line 223
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
void savewd_finish(struct savewd *wd ) 
{ 


  {
  {
#line 232
  if ((unsigned int )wd->state == 4U) {
#line 232
    goto case_4;
  }
#line 232
  if ((unsigned int )wd->state == 0U) {
#line 232
    goto case_4;
  }
#line 236
  if ((unsigned int )wd->state == 2U) {
#line 236
    goto case_2;
  }
#line 236
  if ((unsigned int )wd->state == 1U) {
#line 236
    goto case_2;
  }
#line 240
  if ((unsigned int )wd->state == 3U) {
#line 240
    goto case_3;
  }
#line 244
  goto switch_default;
  case_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 233
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 237
  close(wd->val.fd);
  }
#line 238
  goto switch_break;
  case_3: /* CIL Label */ 
#line 241
  if (! (wd->val.child < 0)) {
    {
#line 241
    __assert_fail("wd->val.child < 0", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                  241U, "savewd_finish");
    }
  }
#line 242
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 245
  __assert_fail("false", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                245U, "savewd_finish");
  }
  switch_break: /* CIL Label */ ;
  }
#line 248
  wd->state = (enum __anonenum_state_467303978 )5;
#line 249
  return;
}
}
#line 261 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
__inline static _Bool savewd_delegating(struct savewd  const  *wd ) 
{ 
  int tmp ;

  {
#line 264
  if ((unsigned int const   )wd->state == 3U) {
#line 264
    if (0 < (int )wd->val.child) {
#line 264
      tmp = 1;
    } else {
#line 264
      tmp = 0;
    }
  } else {
#line 264
    tmp = 0;
  }
#line 264
  return ((_Bool )tmp);
}
}
#line 267 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) 
{ 
  int i ;
  int last_relative ;
  int exit_status ;
  struct savewd wd ;
  int s ;
  int tmp ;
  _Bool tmp___0 ;
  int r ;
  int tmp___1 ;
  int s___0 ;
  int tmp___2 ;

  {
  {
#line 272
  i = 0;
#line 274
  exit_status = 0;
#line 276
  savewd_init(& wd);
#line 278
  last_relative = n_files - 1;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (0 <= last_relative)) {
#line 278
      goto while_break;
    }
#line 279
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
#line 280
      goto while_break;
    }
#line 278
    last_relative --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < last_relative)) {
#line 282
      goto while_break___0;
    }
    {
#line 284
    tmp___0 = savewd_delegating((struct savewd  const  *)(& wd));
    }
#line 284
    if (! tmp___0) {
      {
#line 286
      tmp = (*act)(*(file + i), & wd, options);
#line 286
      s = tmp;
      }
#line 287
      if (exit_status < s) {
#line 288
        exit_status = s;
      }
    }
#line 291
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
      {
#line 293
      tmp___1 = savewd_restore(& wd, exit_status);
#line 293
      r = tmp___1;
      }
#line 294
      if (exit_status < r) {
#line 295
        exit_status = r;
      }
    }
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 299
  savewd_finish(& wd);
  }
  {
#line 301
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 301
    if (! (i < n_files)) {
#line 301
      goto while_break___1;
    }
    {
#line 303
    tmp___2 = (*act)(*(file + i), & wd, options);
#line 303
    s___0 = tmp___2;
    }
#line 304
    if (exit_status < s___0) {
#line 305
      exit_status = s___0;
    }
#line 301
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 308
  return (exit_status);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/savedir.h"
char *savedir(char const   *dir ) ;
#line 24
char *fdsavedir(int fd ) ;
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/savedir.c"
static char *savedirstream(DIR *dirp ) 
{ 
  char *name_space ;
  size_t allocated___0 ;
  size_t used___0 ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 60
  allocated___0 = (size_t )512;
#line 61
  used___0 = (size_t )0;
#line 64
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 65
    return ((char *)((void *)0));
  }
  {
#line 67
  tmp = xmalloc(allocated___0);
#line 67
  name_space = (char *)tmp;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp___0 = __errno_location();
#line 74
    *tmp___0 = 0;
#line 75
    tmp___1 = readdir(dirp);
#line 75
    dp = (struct dirent  const  *)tmp___1;
    }
#line 76
    if (! dp) {
#line 77
      goto while_break;
    }
#line 81
    entry = (char const   *)(dp->d_name);
#line 82
    if ((int const   )*(entry + 0) != 46) {
#line 82
      tmp___5 = 0;
    } else {
#line 82
      if ((int const   )*(entry + 1) != 46) {
#line 82
        tmp___4 = 1;
      } else {
#line 82
        tmp___4 = 2;
      }
#line 82
      tmp___5 = tmp___4;
    }
#line 82
    if ((int const   )*(entry + tmp___5) != 0) {
      {
#line 84
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 84
      entry_size = tmp___2 + 1UL;
      }
#line 85
      if (used___0 + entry_size < used___0) {
        {
#line 86
        xalloc_die();
        }
      }
#line 87
      if (allocated___0 <= used___0 + entry_size) {
        {
#line 89
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 91
          if (2UL * allocated___0 < allocated___0) {
            {
#line 92
            xalloc_die();
            }
          }
#line 93
          allocated___0 *= 2UL;
#line 89
          if (! (allocated___0 <= used___0 + entry_size)) {
#line 89
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 97
        tmp___3 = xrealloc((void *)name_space, allocated___0);
#line 97
        name_space = (char *)tmp___3;
        }
      }
      {
#line 99
      memcpy((void */* __restrict  */)(name_space + used___0), (void const   */* __restrict  */)entry,
             entry_size);
#line 100
      used___0 += entry_size;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  *(name_space + used___0) = (char )'\000';
#line 104
  tmp___6 = __errno_location();
#line 104
  save_errno = *tmp___6;
#line 105
  tmp___8 = closedir(dirp);
  }
#line 105
  if (tmp___8 != 0) {
    {
#line 106
    tmp___7 = __errno_location();
#line 106
    save_errno = *tmp___7;
    }
  }
#line 107
  if (save_errno != 0) {
    {
#line 109
    free((void *)name_space);
#line 110
    tmp___9 = __errno_location();
#line 110
    *tmp___9 = save_errno;
    }
#line 111
    return ((char *)((void *)0));
  }
#line 113
  return (name_space);
}
}
#line 121 "/home/khheo/project/benchmark/coreutils-7.1/lib/savedir.c"
char *savedir(char const   *dir ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
  {
#line 124
  tmp = opendir(dir);
#line 124
  tmp___0 = savedirstream(tmp);
  }
#line 124
  return (tmp___0);
}
}
#line 132 "/home/khheo/project/benchmark/coreutils-7.1/lib/savedir.c"
char *fdsavedir(int fd ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
  {
#line 135
  tmp = fdopendir(fd);
#line 135
  tmp___0 = savedirstream(tmp);
  }
#line 135
  return (tmp___0);
}
}
#line 67 "/home/khheo/project/benchmark/coreutils-7.1/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;

  {
  {
#line 70
  cwd->name = (char *)((void *)0);
#line 72
  cwd->desc = open_safer(".", 0);
  }
#line 73
  if (cwd->desc < 0) {
    {
#line 75
    cwd->name = xgetcwd();
    }
#line 76
    if (cwd->name) {
#line 76
      tmp = 0;
    } else {
#line 76
      tmp = -1;
    }
#line 76
    return (tmp);
  }
#line 79
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/coreutils-7.1/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 89
  if (0 <= (int )cwd->desc) {
    {
#line 90
    tmp = fchdir((int )cwd->desc);
    }
#line 90
    return (tmp);
  } else {
    {
#line 92
    tmp___0 = chdir_long((char *)cwd->name);
    }
#line 92
    return (tmp___0);
  }
}
}
#line 95 "/home/khheo/project/benchmark/coreutils-7.1/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 98
  if (cwd->desc >= 0) {
    {
#line 99
    close(cwd->desc);
    }
  }
  {
#line 100
  free((void *)cwd->name);
  }
#line 101
  return;
}
}
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/same.c"
_Bool same_name(char const   *source , char const   *dest ) 
{ 
  char const   *source_basename ;
  char *tmp ;
  char const   *dest_basename ;
  char *tmp___0 ;
  size_t source_baselen ;
  size_t tmp___1 ;
  size_t dest_baselen ;
  size_t tmp___2 ;
  _Bool identical_basenames ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 56
  tmp = last_component(source);
#line 56
  source_basename = (char const   *)tmp;
#line 57
  tmp___0 = last_component(dest);
#line 57
  dest_basename = (char const   *)tmp___0;
#line 58
  tmp___1 = base_len(source_basename);
#line 58
  source_baselen = tmp___1;
#line 59
  tmp___2 = base_len(dest_basename);
#line 59
  dest_baselen = tmp___2;
  }
#line 60
  if (source_baselen == dest_baselen) {
    {
#line 60
    tmp___3 = memcmp((void const   *)source_basename, (void const   *)dest_basename,
                     dest_baselen);
    }
#line 60
    if (tmp___3 == 0) {
#line 60
      tmp___4 = 1;
    } else {
#line 60
      tmp___4 = 0;
    }
  } else {
#line 60
    tmp___4 = 0;
  }
#line 60
  identical_basenames = (_Bool )tmp___4;
#line 63
  compare_dirs = identical_basenames;
#line 64
  same = (_Bool)0;
#line 77
  if (compare_dirs) {
    {
#line 84
    source_dirname = dir_name(source);
#line 85
    dest_dirname = dir_name(dest);
#line 87
    tmp___6 = stat((char const   */* __restrict  */)source_dirname, (struct stat */* __restrict  */)(& source_dir_stats));
    }
#line 87
    if (tmp___6) {
      {
#line 90
      tmp___5 = __errno_location();
#line 90
      error(1, *tmp___5, "%s", source_dirname);
      }
    }
    {
#line 93
    tmp___8 = stat((char const   */* __restrict  */)dest_dirname, (struct stat */* __restrict  */)(& dest_dir_stats));
    }
#line 93
    if (tmp___8) {
      {
#line 96
      tmp___7 = __errno_location();
#line 96
      error(1, *tmp___7, "%s", dest_dirname);
      }
    }
#line 99
    if (source_dir_stats.st_ino == dest_dir_stats.st_ino) {
#line 99
      if (source_dir_stats.st_dev == dest_dir_stats.st_dev) {
#line 99
        tmp___9 = 1;
      } else {
#line 99
        tmp___9 = 0;
      }
    } else {
#line 99
      tmp___9 = 0;
    }
    {
#line 99
    same = (_Bool )tmp___9;
#line 120
    free((void *)source_dirname);
#line 121
    free((void *)dest_dirname);
    }
  }
#line 124
  return (same);
}
}
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/safe-read.c"
size_t safe_write(int fd , void const   *buf___1 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = write(fd, buf___1, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/safe-read.c"
size_t safe_read(int fd , void *buf___1 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf___1, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/coreutils-7.1/lib/root-dev-ino.h"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/root-dev-ino.c"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 32
  tmp = lstat((char const   */* __restrict  */)"/", (struct stat */* __restrict  */)(& statbuf));
  }
#line 32
  if (tmp) {
#line 33
    return ((struct dev_ino *)((void *)0));
  }
#line 34
  root_d_i->st_ino = statbuf.st_ino;
#line 35
  root_d_i->st_dev = statbuf.st_dev;
#line 36
  return (root_d_i);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 235 "./regex.h"
reg_syntax_t rpl_re_syntax_options  ;
#line 551
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) ;
#line 556
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 563
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 571
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) ;
#line 579
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) ;
#line 589
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) ;
#line 595
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) ;
#line 614
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 656
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) ;
#line 660
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 665
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                    size_t errbuf_size ) ;
#line 668
void rpl_regfree(regex_t *preg ) ;
#line 131 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcscoll)(wchar_t const   *__s1 ,
                                                                              wchar_t const   *__s2 ) ;
#line 284
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswlower)(wint_t __wc ) ;
#line 155
extern  __attribute__((__nothrow__)) wctype_t ( __attribute__((__leaf__)) wctype)(char const   *__property ) ;
#line 159
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswctype)(wint_t __wc ,
                                                                               wctype_t __desc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 429 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) ;
#line 433
static void build_wcs_buffer(re_string_t *pstr ) ;
#line 434
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) ;
#line 437
static void build_upper_buffer(re_string_t *pstr ) ;
#line 438
static void re_string_translate_buffer(re_string_t *pstr ) ;
#line 439
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 736 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_set(bitset_word_t *set , Idx i ) 
{ 


  {
#line 739
  *(set + i / 64UL) |= 1UL << i % 64UL;
#line 740
  return;
}
}
#line 742 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_clear(bitset_word_t *set , Idx i ) 
{ 


  {
#line 745
  *(set + i / 64UL) &= ~ (1UL << i % 64UL);
#line 746
  return;
}
}
#line 748 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static _Bool bitset_contain(bitset_word_t * const  set , Idx i ) 
{ 


  {
#line 751
  return ((_Bool )((*(set + i / 64UL) >> i % 64UL) & 1UL));
}
}
#line 754 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_empty(bitset_word_t *set ) 
{ 


  {
  {
#line 757
  memset((void *)set, '\000', sizeof(bitset_t ));
  }
#line 758
  return;
}
}
#line 760 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_set_all(bitset_word_t *set ) 
{ 


  {
  {
#line 763
  memset((void *)set, -1, sizeof(bitset_word_t ) * 4UL);
  }
#line 767
  return;
}
}
#line 769 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_copy(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 


  {
  {
#line 772
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, sizeof(bitset_t ));
  }
#line 773
  return;
}
}
#line 775 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_not(bitset_word_t *set ) 
{ 
  int bitset_i ;

  {
#line 779
  bitset_i = 0;
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (bitset_i < 4)) {
#line 779
      goto while_break;
    }
#line 780
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 779
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  return;
}
}
#line 787 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 791
  bitset_i = 0;
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! (bitset_i < 4)) {
#line 791
      goto while_break;
    }
#line 792
    *(dest + bitset_i) |= *(src + bitset_i);
#line 791
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  return;
}
}
#line 795 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static void bitset_mask(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 799
  bitset_i = 0;
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! (bitset_i < 4)) {
#line 799
      goto while_break;
    }
#line 800
    *(dest + bitset_i) &= *(src + bitset_i);
#line 799
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 801
  return;
}
}
#line 805 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static int __attribute__((__pure__))  re_string_char_size_at(re_string_t const   *pstr ,
                                                                      Idx idx ) 
{ 
  int byte_idx ;

  {
#line 810
  if (pstr->mb_cur_max == 1) {
#line 811
    return ((int __attribute__((__pure__))  )1);
  }
#line 812
  byte_idx = 1;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 812
    if (! (idx + (Idx )byte_idx < (Idx )pstr->valid_len)) {
#line 812
      goto while_break;
    }
#line 813
    if (*(pstr->wcs + (idx + (Idx )byte_idx)) != 4294967295U) {
#line 814
      goto while_break;
    }
#line 812
    byte_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 815
  return ((int __attribute__((__pure__))  )byte_idx);
}
}
#line 818 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
__inline static wint_t __attribute__((__pure__))  re_string_wchar_at(re_string_t const   *pstr ,
                                                                     Idx idx ) 
{ 


  {
#line 822
  if (pstr->mb_cur_max == 1) {
#line 823
    return ((wint_t __attribute__((__pure__))  )((wint_t )*(pstr->mbs + idx)));
  }
#line 824
  return ((wint_t __attribute__((__pure__))  )*(pstr->wcs + idx));
}
}
#line 827 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
static int __attribute__((__pure__))  re_string_elem_size_at(re_string_t const   *pstr ,
                                                             Idx idx ) 
{ 


  {
#line 851
  return ((int __attribute__((__pure__))  )1);
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) ;
#line 25
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) ;
#line 28
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , Idx len ,
                                        Idx init_len , unsigned char *trans , _Bool icase ,
                                        re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  Idx init_buf_len ;
  long tmp ;

  {
#line 47
  if (init_len < (Idx )dfa->mb_cur_max) {
#line 48
    init_len = (Idx )dfa->mb_cur_max;
  }
#line 49
  if (len + 1UL < init_len) {
#line 49
    init_buf_len = len + 1UL;
  } else {
#line 49
    init_buf_len = init_len;
  }
  {
#line 50
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 52
  ret = re_string_realloc_buffers(pstr, init_buf_len);
#line 53
  tmp = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 53
  if (tmp) {
#line 54
    return (ret);
  }
#line 56
  pstr->word_char = (re_const_bitset_ptr_t )(dfa->word_char);
#line 57
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
#line 58
  if (pstr->mbs_allocated) {
#line 58
    pstr->mbs = pstr->mbs;
  } else {
#line 58
    pstr->mbs = (unsigned char *)str;
  }
#line 59
  if (pstr->mbs_allocated) {
#line 59
    pstr->valid_len = (Idx )0;
  } else
#line 59
  if (dfa->mb_cur_max > 1) {
#line 59
    pstr->valid_len = (Idx )0;
  } else {
#line 59
    pstr->valid_len = len;
  }
#line 60
  pstr->valid_raw_len = pstr->valid_len;
#line 61
  return ((reg_errcode_t )0);
}
}
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , Idx len ,
                                         unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 72
  memset((void *)pstr, '\000', sizeof(re_string_t ));
#line 73
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
  }
#line 75
  if (len > 0UL) {
    {
#line 77
    ret = re_string_realloc_buffers(pstr, len + 1UL);
#line 78
    tmp = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 78
    if (tmp) {
#line 79
      return (ret);
    }
  }
#line 81
  if (pstr->mbs_allocated) {
#line 81
    pstr->mbs = pstr->mbs;
  } else {
#line 81
    pstr->mbs = (unsigned char *)str;
  }
#line 83
  if (icase) {
#line 86
    if (dfa->mb_cur_max > 1) {
      {
#line 88
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 90
        ret = build_wcs_upper_buffer(pstr);
#line 91
        tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 91
        if (tmp___0) {
#line 92
          return (ret);
        }
#line 93
        if (pstr->valid_raw_len >= len) {
#line 94
          goto while_break;
        }
#line 95
        if (pstr->bufs_len > pstr->valid_len + (Idx )dfa->mb_cur_max) {
#line 96
          goto while_break;
        }
        {
#line 97
        ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2UL);
#line 98
        tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 98
        if (tmp___1) {
#line 99
          return (ret);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 104
      build_upper_buffer(pstr);
      }
    }
  } else
#line 109
  if (dfa->mb_cur_max > 1) {
    {
#line 110
    build_wcs_buffer(pstr);
    }
  } else
#line 114
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
#line 115
    re_string_translate_buffer(pstr);
    }
  } else {
#line 118
    pstr->valid_len = pstr->bufs_len;
#line 119
    pstr->valid_raw_len = pstr->bufs_len;
  }
#line 124
  return ((reg_errcode_t )0);
}
}
#line 129 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) 
{ 
  wint_t *new_wcs ;
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  Idx *new_offsets ;
  void *tmp___3 ;
  long tmp___4 ;
  unsigned char *new_mbs ;
  void *tmp___5 ;
  long tmp___6 ;

  {
#line 134
  if (pstr->mb_cur_max > 1) {
#line 139
    if (sizeof(wint_t ) < sizeof(Idx )) {
#line 139
      tmp = sizeof(Idx );
    } else {
#line 139
      tmp = sizeof(wint_t );
    }
    {
#line 139
    max_object_size = tmp;
#line 140
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < new_buf_len),
                               0L);
    }
#line 140
    if (tmp___0) {
#line 141
      return ((reg_errcode_t )12);
    }
    {
#line 143
    tmp___1 = realloc((void *)pstr->wcs, new_buf_len * sizeof(wint_t ));
#line 143
    new_wcs = (wint_t *)tmp___1;
#line 144
    tmp___2 = __builtin_expect((long )((unsigned long )new_wcs == (unsigned long )((void *)0)),
                               0L);
    }
#line 144
    if (tmp___2) {
#line 145
      return ((reg_errcode_t )12);
    }
#line 146
    pstr->wcs = new_wcs;
#line 147
    if ((unsigned long )pstr->offsets != (unsigned long )((void *)0)) {
      {
#line 149
      tmp___3 = realloc((void *)pstr->offsets, new_buf_len * sizeof(Idx ));
#line 149
      new_offsets = (Idx *)tmp___3;
#line 150
      tmp___4 = __builtin_expect((long )((unsigned long )new_offsets == (unsigned long )((void *)0)),
                                 0L);
      }
#line 150
      if (tmp___4) {
#line 151
        return ((reg_errcode_t )12);
      }
#line 152
      pstr->offsets = new_offsets;
    }
  }
#line 156
  if (pstr->mbs_allocated) {
    {
#line 158
    tmp___5 = realloc((void *)pstr->mbs, new_buf_len * sizeof(unsigned char ));
#line 158
    new_mbs = (unsigned char *)tmp___5;
#line 160
    tmp___6 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
    }
#line 160
    if (tmp___6) {
#line 161
      return ((reg_errcode_t )12);
    }
#line 162
    pstr->mbs = new_mbs;
  }
#line 164
  pstr->bufs_len = new_buf_len;
#line 165
  return ((reg_errcode_t )0);
}
}
#line 169 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  int tmp ;

  {
#line 175
  pstr->raw_mbs = (unsigned char const   *)str;
#line 176
  pstr->len = len;
#line 177
  pstr->raw_len = len;
#line 178
  pstr->trans = trans;
#line 179
  pstr->icase = (unsigned char )icase;
#line 180
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 180
    tmp = 1;
  } else
#line 180
  if (icase) {
#line 180
    tmp = 1;
  } else {
#line 180
    tmp = 0;
  }
#line 180
  pstr->mbs_allocated = (unsigned char )tmp;
#line 181
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
#line 182
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
#line 183
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
#line 184
  pstr->stop = pstr->len;
#line 185
  pstr->raw_stop = pstr->stop;
#line 186
  return;
}
}
#line 201 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr ) 
{ 
  unsigned char buf___1[64] ;
  mbstate_t prev_st ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i ;
  int ch ;
  unsigned char tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 217
  if (pstr->bufs_len > pstr->len) {
#line 217
    end_idx = pstr->len;
  } else {
#line 217
    end_idx = pstr->bufs_len;
  }
#line 218
  byte_idx = pstr->valid_len;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (byte_idx < end_idx)) {
#line 218
      goto while_break;
    }
    {
#line 223
    remain_len = end_idx - byte_idx;
#line 224
    prev_st = pstr->cur_state;
#line 226
    tmp___0 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                               0L);
    }
#line 226
    if (tmp___0) {
#line 230
      i = 0;
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (i < pstr->mb_cur_max) {
#line 230
          if (! ((Idx )i < remain_len)) {
#line 230
            goto while_break___0;
          }
        } else {
#line 230
          goto while_break___0;
        }
#line 232
        ch = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + byte_idx) + (Idx )i));
#line 233
        tmp = *(pstr->trans + ch);
#line 233
        *(pstr->mbs + (byte_idx + (Idx )i)) = tmp;
#line 233
        buf___1[i] = tmp;
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 235
      p = (char const   *)(buf___1);
    } else {
#line 238
      p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx;
    }
    {
#line 239
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                     remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 240
    tmp___4 = __builtin_expect((long )(mbclen == 0xfffffffffffffffeUL), 0L);
    }
#line 240
    if (tmp___4) {
#line 243
      pstr->cur_state = prev_st;
#line 244
      goto while_break;
    } else {
#line 246
      if (mbclen == 0xffffffffffffffffUL) {
#line 246
        tmp___2 = 1;
      } else
#line 246
      if (mbclen == 0UL) {
#line 246
        tmp___2 = 1;
      } else {
#line 246
        tmp___2 = 0;
      }
      {
#line 246
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
      }
#line 246
      if (tmp___3) {
        {
#line 249
        mbclen = (size_t )1;
#line 250
        wc = (wchar_t )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 251
        tmp___1 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                   0L);
        }
#line 251
        if (tmp___1) {
#line 252
          wc = (wchar_t )*(pstr->trans + wc);
        }
#line 253
        pstr->cur_state = prev_st;
      }
    }
#line 257
    tmp___5 = byte_idx;
#line 257
    byte_idx ++;
#line 257
    *(pstr->wcs + tmp___5) = (wint_t )wc;
#line 259
    remain_len = (byte_idx + mbclen) - 1UL;
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      if (! (byte_idx < remain_len)) {
#line 259
        goto while_break___1;
      }
#line 260
      tmp___6 = byte_idx;
#line 260
      byte_idx ++;
#line 260
      *(pstr->wcs + tmp___6) = 4294967295U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  pstr->valid_len = byte_idx;
#line 263
  pstr->valid_raw_len = byte_idx;
#line 264
  return;
}
}
#line 269 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  Idx src_idx ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  char buf___1[64] ;
  wchar_t wc ;
  int tmp ;
  int tmp___0 ;
  wchar_t wcu ;
  size_t mbcdlen ;
  wint_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  int ch ;
  Idx tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i ;
  int ch___0 ;
  long tmp___9 ;
  wchar_t wcu___0 ;
  size_t mbcdlen___0 ;
  wint_t tmp___10 ;
  size_t i___0 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  size_t i___1 ;
  long tmp___15 ;
  Idx tmp___16 ;
  Idx tmp___17 ;
  int ch___1 ;
  long tmp___18 ;
  long tmp___19 ;
  Idx tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
#line 283
  byte_idx = pstr->valid_len;
#line 284
  if (pstr->bufs_len > pstr->len) {
#line 284
    end_idx = pstr->len;
  } else {
#line 284
    end_idx = pstr->bufs_len;
  }
#line 288
  if (! pstr->map_notascii) {
#line 288
    if ((unsigned long )pstr->trans == (unsigned long )((void *)0)) {
#line 288
      if (! pstr->offsets_needed) {
        {
#line 290
        while (1) {
          while_continue: /* CIL Label */ ;
#line 290
          if (! (byte_idx < end_idx)) {
#line 290
            goto while_break;
          }
#line 294
          if (((int const   )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)) & -128) == 0) {
            {
#line 294
            tmp___0 = mbsinit((mbstate_t const   *)(& pstr->cur_state));
            }
#line 294
            if (tmp___0) {
              {
#line 298
              tmp = toupper((int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
#line 298
              *(pstr->mbs + byte_idx) = (unsigned char )tmp;
#line 302
              *(pstr->wcs + byte_idx) = (wint_t )((wchar_t )*(pstr->mbs + byte_idx));
#line 303
              byte_idx ++;
              }
#line 304
              goto while_continue;
            }
          }
          {
#line 307
          remain_len = end_idx - byte_idx;
#line 308
          prev_st = pstr->cur_state;
#line 309
          mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                           remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 312
          tmp___8 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
          }
#line 312
          if (tmp___8) {
            {
#line 314
            wcu = wc;
#line 315
            tmp___3 = iswlower((wint_t )wc);
            }
#line 315
            if (tmp___3) {
              {
#line 319
              tmp___1 = towupper((wint_t )wc);
#line 319
              wcu = (wchar_t )tmp___1;
#line 320
              mbcdlen = wcrtomb((char */* __restrict  */)(buf___1), wcu, (mbstate_t */* __restrict  */)(& prev_st));
#line 321
              tmp___2 = __builtin_expect((long )(mbclen == mbcdlen), 1L);
              }
#line 321
              if (tmp___2) {
                {
#line 322
                memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                       mbclen);
                }
              } else {
#line 325
                src_idx = byte_idx;
#line 326
                goto offsets_needed;
              }
            } else {
              {
#line 330
              memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                     mbclen);
              }
            }
#line 332
            tmp___4 = byte_idx;
#line 332
            byte_idx ++;
#line 332
            *(pstr->wcs + tmp___4) = (wint_t )wcu;
#line 334
            remain_len = (byte_idx + mbclen) - 1UL;
            {
#line 334
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 334
              if (! (byte_idx < remain_len)) {
#line 334
                goto while_break___0;
              }
#line 335
              tmp___5 = byte_idx;
#line 335
              byte_idx ++;
#line 335
              *(pstr->wcs + tmp___5) = 4294967295U;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 337
          if (mbclen == 0xffffffffffffffffUL) {
#line 337
            goto _L;
          } else
#line 337
          if (mbclen == 0UL) {
            _L: /* CIL Label */ 
            {
#line 340
            ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 341
            *(pstr->mbs + byte_idx) = (unsigned char )ch;
#line 343
            tmp___6 = byte_idx;
#line 343
            byte_idx ++;
#line 343
            *(pstr->wcs + tmp___6) = (wint_t )ch;
#line 344
            tmp___7 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
            }
#line 344
            if (tmp___7) {
#line 345
              pstr->cur_state = prev_st;
            }
          } else {
#line 350
            pstr->cur_state = prev_st;
#line 351
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 354
        pstr->valid_len = byte_idx;
#line 355
        pstr->valid_raw_len = byte_idx;
#line 356
        return ((reg_errcode_t )0);
      } else {
#line 288
        goto _L___2;
      }
    } else {
#line 288
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 359
    src_idx = pstr->valid_raw_len;
    {
#line 359
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 359
      if (! (byte_idx < end_idx)) {
#line 359
        goto while_break___1;
      }
      offsets_needed: 
      {
#line 364
      remain_len = end_idx - byte_idx;
#line 365
      prev_st = pstr->cur_state;
#line 366
      tmp___9 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 366
      if (tmp___9) {
#line 370
        i = 0;
        {
#line 370
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 370
          if (i < pstr->mb_cur_max) {
#line 370
            if (! ((Idx )i < remain_len)) {
#line 370
              goto while_break___2;
            }
          } else {
#line 370
            goto while_break___2;
          }
#line 372
          ch___0 = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + src_idx) + (Idx )i));
#line 373
          buf___1[i] = (char )*(pstr->trans + ch___0);
#line 370
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 375
        p = (char const   *)(buf___1);
      } else {
#line 378
        p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + src_idx;
      }
      {
#line 379
      mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc___0), (char const   */* __restrict  */)p,
                       remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 380
      tmp___22 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
      }
#line 380
      if (tmp___22) {
        {
#line 382
        wcu___0 = wc___0;
#line 383
        tmp___14 = iswlower((wint_t )wc___0);
        }
#line 383
        if (tmp___14) {
          {
#line 387
          tmp___10 = towupper((wint_t )wc___0);
#line 387
          wcu___0 = (wchar_t )tmp___10;
#line 388
          mbcdlen___0 = wcrtomb((char */* __restrict  */)(buf___1), wcu___0, (mbstate_t */* __restrict  */)(& prev_st));
#line 389
          tmp___13 = __builtin_expect((long )(mbclen == mbcdlen___0), 1L);
          }
#line 389
          if (tmp___13) {
            {
#line 390
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                   mbclen);
            }
          } else
#line 391
          if (mbcdlen___0 != 0xffffffffffffffffUL) {
#line 395
            if (byte_idx + mbcdlen___0 > pstr->bufs_len) {
#line 397
              pstr->cur_state = prev_st;
#line 398
              goto while_break___1;
            }
#line 401
            if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
              {
#line 403
              tmp___11 = malloc(pstr->bufs_len * sizeof(Idx ));
#line 403
              pstr->offsets = (Idx *)tmp___11;
              }
#line 405
              if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
#line 406
                return ((reg_errcode_t )12);
              }
            }
#line 408
            if (! pstr->offsets_needed) {
#line 410
              i___0 = (size_t )0;
              {
#line 410
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 410
                if (! (i___0 < byte_idx)) {
#line 410
                  goto while_break___3;
                }
#line 411
                *(pstr->offsets + i___0) = i___0;
#line 410
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 412
              pstr->offsets_needed = (unsigned char)1;
            }
            {
#line 415
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                   mbcdlen___0);
#line 416
            *(pstr->wcs + byte_idx) = (wint_t )wcu___0;
#line 417
            *(pstr->offsets + byte_idx) = src_idx;
#line 418
            i___0 = (size_t )1;
            }
            {
#line 418
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 418
              if (! (i___0 < mbcdlen___0)) {
#line 418
                goto while_break___4;
              }
#line 420
              if (i___0 < mbclen) {
#line 420
                tmp___12 = i___0;
              } else {
#line 420
                tmp___12 = mbclen - 1UL;
              }
#line 420
              *(pstr->offsets + (byte_idx + i___0)) = src_idx + tmp___12;
#line 422
              *(pstr->wcs + (byte_idx + i___0)) = 4294967295U;
#line 418
              i___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 424
            pstr->len += mbcdlen___0 - mbclen;
#line 425
            if (pstr->raw_stop > src_idx) {
#line 426
              pstr->stop += mbcdlen___0 - mbclen;
            }
#line 427
            if (pstr->bufs_len > pstr->len) {
#line 427
              end_idx = pstr->len;
            } else {
#line 427
              end_idx = pstr->bufs_len;
            }
#line 429
            byte_idx += mbcdlen___0;
#line 430
            src_idx += mbclen;
#line 431
            goto __Cont;
          } else {
            {
#line 434
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                   mbclen);
            }
          }
        } else {
          {
#line 437
          memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                 mbclen);
          }
        }
        {
#line 439
        tmp___15 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
        }
#line 439
        if (tmp___15) {
#line 442
          i___1 = (size_t )0;
          {
#line 442
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 442
            if (! (i___1 < mbclen)) {
#line 442
              goto while_break___5;
            }
#line 443
            *(pstr->offsets + (byte_idx + i___1)) = src_idx + i___1;
#line 442
            i___1 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 445
        src_idx += mbclen;
#line 447
        tmp___16 = byte_idx;
#line 447
        byte_idx ++;
#line 447
        *(pstr->wcs + tmp___16) = (wint_t )wcu___0;
#line 449
        remain_len = (byte_idx + mbclen) - 1UL;
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 449
          if (! (byte_idx < remain_len)) {
#line 449
            goto while_break___6;
          }
#line 450
          tmp___17 = byte_idx;
#line 450
          byte_idx ++;
#line 450
          *(pstr->wcs + tmp___17) = 4294967295U;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 452
      if (mbclen == 0xffffffffffffffffUL) {
#line 452
        goto _L___0;
      } else
#line 452
      if (mbclen == 0UL) {
        _L___0: /* CIL Label */ 
        {
#line 455
        ch___1 = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + src_idx));
#line 457
        tmp___18 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 457
        if (tmp___18) {
#line 458
          ch___1 = (int )*(pstr->trans + ch___1);
        }
        {
#line 459
        *(pstr->mbs + byte_idx) = (unsigned char )ch___1;
#line 461
        tmp___19 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
        }
#line 461
        if (tmp___19) {
#line 462
          *(pstr->offsets + byte_idx) = src_idx;
        }
        {
#line 463
        src_idx ++;
#line 466
        tmp___20 = byte_idx;
#line 466
        byte_idx ++;
#line 466
        *(pstr->wcs + tmp___20) = (wint_t )ch___1;
#line 467
        tmp___21 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
        }
#line 467
        if (tmp___21) {
#line 468
          pstr->cur_state = prev_st;
        }
      } else {
#line 473
        pstr->cur_state = prev_st;
#line 474
        goto while_break___1;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 477
  pstr->valid_len = byte_idx;
#line 478
  pstr->valid_raw_len = src_idx;
#line 479
  return ((reg_errcode_t )0);
}
}
#line 485 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx re_string_skip_chars(re_string_t *pstr , Idx new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  Idx rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  Idx remain_len ;
  int tmp ;
  long tmp___0 ;

  {
#line 492
  wc = 4294967295U;
#line 495
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (rawbuf_idx < new_raw_idx)) {
#line 495
      goto while_break;
    }
    {
#line 500
    remain_len = pstr->len - rawbuf_idx;
#line 501
    prev_st = pstr->cur_state;
#line 502
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)pstr->raw_mbs + rawbuf_idx),
                     remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
    }
#line 504
    if (mbclen == 0xfffffffffffffffeUL) {
#line 504
      tmp = 1;
    } else
#line 504
    if (mbclen == 0xffffffffffffffffUL) {
#line 504
      tmp = 1;
    } else
#line 504
    if (mbclen == 0UL) {
#line 504
      tmp = 1;
    } else {
#line 504
      tmp = 0;
    }
    {
#line 504
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 504
    if (tmp___0) {
#line 507
      if (mbclen == 0UL) {
#line 508
        wc = (wint_t )0;
      } else
#line 507
      if (remain_len == 0UL) {
#line 508
        wc = (wint_t )0;
      } else {
#line 510
        wc = (wint_t )*((unsigned char *)(pstr->raw_mbs + rawbuf_idx));
      }
#line 511
      mbclen = (size_t )1;
#line 512
      pstr->cur_state = prev_st;
    } else {
#line 515
      wc = (wint_t )wc2;
    }
#line 517
    rawbuf_idx += mbclen;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  *last_wc = wc;
#line 520
  return (rawbuf_idx);
}
}
#line 527 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void build_upper_buffer(re_string_t *pstr ) 
{ 
  Idx char_idx ;
  Idx end_idx ;
  int ch ;
  long tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 532
  if (pstr->bufs_len > pstr->len) {
#line 532
    end_idx = pstr->len;
  } else {
#line 532
    end_idx = pstr->bufs_len;
  }
#line 534
  char_idx = pstr->valid_len;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (char_idx < end_idx)) {
#line 534
      goto while_break;
    }
    {
#line 536
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 537
    tmp = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                           0L);
    }
#line 537
    if (tmp) {
#line 538
      ch = (int )*(pstr->trans + ch);
    }
    {
#line 539
    tmp___1 = __ctype_b_loc();
    }
#line 539
    if ((int const   )*(*tmp___1 + ch) & 512) {
      {
#line 540
      tmp___0 = toupper(ch);
#line 540
      *(pstr->mbs + char_idx) = (unsigned char )tmp___0;
      }
    } else {
#line 542
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
#line 534
    char_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  pstr->valid_len = char_idx;
#line 545
  pstr->valid_raw_len = char_idx;
#line 546
  return;
}
}
#line 550 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr ) 
{ 
  Idx buf_idx ;
  Idx end_idx ;
  int ch ;

  {
#line 555
  if (pstr->bufs_len > pstr->len) {
#line 555
    end_idx = pstr->len;
  } else {
#line 555
    end_idx = pstr->bufs_len;
  }
#line 557
  buf_idx = pstr->valid_len;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (buf_idx < end_idx)) {
#line 557
      goto while_break;
    }
#line 559
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 560
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
#line 557
    buf_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  pstr->valid_len = buf_idx;
#line 564
  pstr->valid_raw_len = buf_idx;
#line 565
  return;
}
}
#line 571 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , Idx idx , int eflags ) 
{ 
  Idx offset ;
  long tmp ;
  Idx low ;
  Idx high ;
  Idx mid ;
  long tmp___0 ;
  long tmp___1 ;
  Idx prev_valid_len ;
  long tmp___2 ;
  Idx wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  Idx mlen ;
  unsigned char buf___1[6] ;
  size_t mbclen ;
  int i ;
  Idx tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int c ;
  int tmp___13 ;
  _Bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
  {
#line 577
  tmp = __builtin_expect((long )(pstr->raw_mbs_idx <= idx), 0L);
  }
#line 577
  if (tmp) {
#line 578
    offset = idx - pstr->raw_mbs_idx;
  } else {
#line 583
    if (pstr->mb_cur_max > 1) {
      {
#line 584
      memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
      }
    }
#line 586
    pstr->len = pstr->raw_len;
#line 587
    pstr->stop = pstr->raw_stop;
#line 588
    pstr->valid_len = (Idx )0;
#line 589
    pstr->raw_mbs_idx = (Idx )0;
#line 590
    pstr->valid_raw_len = (Idx )0;
#line 591
    pstr->offsets_needed = (unsigned char)0;
#line 592
    if (eflags & 1) {
#line 592
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 592
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 594
    if (! pstr->mbs_allocated) {
#line 595
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
#line 596
    offset = idx;
  }
  {
#line 599
  tmp___17 = __builtin_expect((long )(offset != 0UL), 1L);
  }
#line 599
  if (tmp___17) {
    {
#line 602
    tmp___15 = __builtin_expect((long )(offset < pstr->valid_raw_len), 1L);
    }
#line 602
    if (tmp___15) {
      {
#line 606
      tmp___1 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 606
      if (tmp___1) {
#line 608
        low = (Idx )0;
#line 608
        high = pstr->valid_len;
        {
#line 609
        while (1) {
          while_continue: /* CIL Label */ ;
#line 611
          mid = (high + low) / 2UL;
#line 612
          if (*(pstr->offsets + mid) > offset) {
#line 613
            high = mid;
          } else
#line 614
          if (*(pstr->offsets + mid) < offset) {
#line 615
            low = mid + 1UL;
          } else {
#line 617
            goto while_break;
          }
#line 609
          if (! (low < high)) {
#line 609
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 620
        if (*(pstr->offsets + mid) < offset) {
#line 621
          mid ++;
        }
        {
#line 622
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, mid - 1UL,
                                                 eflags);
        }
#line 628
        if (pstr->valid_len > offset) {
#line 628
          if (mid == offset) {
#line 628
            if (*(pstr->offsets + mid) == offset) {
              {
#line 631
              memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
#line 633
              memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
#line 634
              pstr->valid_len -= offset;
#line 635
              pstr->valid_raw_len -= offset;
#line 636
              low = (Idx )0;
              }
              {
#line 636
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 636
                if (! (low < pstr->valid_len)) {
#line 636
                  goto while_break___0;
                }
#line 637
                *(pstr->offsets + low) = *(pstr->offsets + (low + offset)) - offset;
#line 636
                low ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
#line 628
              goto _L___0;
            }
          } else {
#line 628
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 643
          pstr->len = (pstr->raw_len - idx) + offset;
#line 644
          pstr->stop = (pstr->raw_stop - idx) + offset;
#line 645
          pstr->offsets_needed = (unsigned char)0;
          {
#line 646
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 646
            if (mid > 0UL) {
#line 646
              if (! (*(pstr->offsets + (mid - 1UL)) == offset)) {
#line 646
                goto while_break___1;
              }
            } else {
#line 646
              goto while_break___1;
            }
#line 647
            mid --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 648
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 648
            if (! (mid < pstr->valid_len)) {
#line 648
              goto while_break___2;
            }
#line 649
            if (*(pstr->wcs + mid) != 4294967295U) {
#line 650
              goto while_break___2;
            } else {
#line 652
              mid ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 653
          if (mid == pstr->valid_len) {
#line 654
            pstr->valid_len = (Idx )0;
          } else {
#line 657
            pstr->valid_len = *(pstr->offsets + mid) - offset;
#line 658
            if (pstr->valid_len) {
#line 660
              low = (Idx )0;
              {
#line 660
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 660
                if (! (low < pstr->valid_len)) {
#line 660
                  goto while_break___3;
                }
#line 661
                *(pstr->wcs + low) = 4294967295U;
#line 660
                low ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 662
              memset((void *)pstr->mbs, 255, pstr->valid_len);
              }
            }
          }
#line 665
          pstr->valid_raw_len = pstr->valid_len;
        }
      } else {
        {
#line 671
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1UL,
                                                 eflags);
        }
#line 674
        if (pstr->mb_cur_max > 1) {
          {
#line 675
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
          }
        }
        {
#line 678
        tmp___0 = __builtin_expect((long )pstr->mbs_allocated, 0L);
        }
#line 678
        if (tmp___0) {
          {
#line 679
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
          }
        }
#line 681
        pstr->valid_len -= offset;
#line 682
        pstr->valid_raw_len -= offset;
      }
    } else {
      {
#line 692
      prev_valid_len = pstr->valid_len;
#line 694
      tmp___2 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 694
      if (tmp___2) {
#line 696
        pstr->len = (pstr->raw_len - idx) + offset;
#line 697
        pstr->stop = (pstr->raw_stop - idx) + offset;
#line 698
        pstr->offsets_needed = (unsigned char)0;
      }
#line 701
      pstr->valid_len = (Idx )0;
#line 703
      if (pstr->mb_cur_max > 1) {
#line 706
        wc = 4294967295U;
#line 708
        if (pstr->is_utf8) {
#line 714
          raw = pstr->raw_mbs + pstr->raw_mbs_idx;
#line 715
          end = raw + (offset - (Idx )pstr->mb_cur_max);
#line 716
          if ((unsigned long )end < (unsigned long )pstr->raw_mbs) {
#line 717
            end = pstr->raw_mbs;
          }
#line 718
          p = (raw + offset) - 1;
          {
#line 730
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 730
            if (! ((unsigned long )p >= (unsigned long )end)) {
#line 730
              goto while_break___4;
            }
#line 731
            if (((int const   )*p & 192) != 128) {
              {
#line 735
              mlen = (Idx )((raw + pstr->len) - p);
#line 739
              tmp___4 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                         0L);
              }
#line 739
              if (tmp___4) {
#line 741
                if (mlen < 6UL) {
#line 741
                  tmp___3 = mlen;
                } else {
#line 741
                  tmp___3 = (Idx )6;
                }
#line 741
                i = (int )tmp___3;
                {
#line 742
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 742
                  i --;
#line 742
                  if (! (i >= 0)) {
#line 742
                    goto while_break___5;
                  }
#line 743
                  buf___1[i] = *(pstr->trans + *(p + i));
                }
                while_break___5: /* CIL Label */ ;
                }
              }
              {
#line 747
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 748
              mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)p),
                               mlen, (mbstate_t */* __restrict  */)(& cur_state));
              }
#line 750
              if ((size_t )((raw + offset) - p) <= mbclen) {
#line 750
                if (mbclen < 0xfffffffffffffffeUL) {
                  {
#line 753
                  memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
#line 755
                  pstr->valid_len = mbclen - (size_t )((raw + offset) - p);
#line 756
                  wc = (wint_t )wc2;
                  }
                }
              }
#line 758
              goto while_break___4;
            }
#line 730
            p --;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 762
        if (wc == 4294967295U) {
          {
#line 763
          tmp___5 = re_string_skip_chars(pstr, idx, & wc);
#line 763
          pstr->valid_len = tmp___5 - idx;
          }
        }
#line 764
        if (wc == 4294967295U) {
          {
#line 765
          pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, prev_valid_len - 1UL,
                                                   eflags);
          }
        } else {
          {
#line 768
          tmp___9 = __builtin_expect((long )((int )pstr->word_ops_used != 0), 0L);
          }
#line 768
          if (tmp___9) {
            {
#line 768
            tmp___10 = iswalnum(wc);
            }
#line 768
            if (tmp___10) {
#line 768
              pstr->tip_context = 1U;
            } else
#line 768
            if (wc == 95U) {
#line 768
              pstr->tip_context = 1U;
            } else {
#line 768
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 768
            if (wc == 10U) {
#line 768
              if (pstr->newline_anchor) {
#line 768
                tmp___8 = 1 << 1;
              } else {
#line 768
                tmp___8 = 0;
              }
            } else {
#line 768
              tmp___8 = 0;
            }
#line 768
            pstr->tip_context = (unsigned int )tmp___8;
          }
        }
        {
#line 774
        tmp___11 = __builtin_expect((long )pstr->valid_len, 0L);
        }
#line 774
        if (tmp___11) {
#line 776
          wcs_idx = (Idx )0;
          {
#line 776
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 776
            if (! (wcs_idx < pstr->valid_len)) {
#line 776
              goto while_break___6;
            }
#line 777
            *(pstr->wcs + wcs_idx) = 4294967295U;
#line 776
            wcs_idx ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 778
          if (pstr->mbs_allocated) {
            {
#line 779
            memset((void *)pstr->mbs, 255, pstr->valid_len);
            }
          }
        }
#line 781
        pstr->valid_raw_len = pstr->valid_len;
      } else {
#line 786
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1UL));
#line 787
        pstr->valid_raw_len = (Idx )0;
#line 788
        if (pstr->trans) {
#line 789
          c = (int )*(pstr->trans + c);
        }
        {
#line 790
        tmp___14 = bitset_contain((bitset_word_t */* const  */)pstr->word_char, (Idx )c);
        }
#line 790
        if (tmp___14) {
#line 790
          pstr->tip_context = 1U;
        } else {
#line 790
          if (c == 10) {
#line 790
            if (pstr->newline_anchor) {
#line 790
              tmp___13 = 1 << 1;
            } else {
#line 790
              tmp___13 = 0;
            }
          } else {
#line 790
            tmp___13 = 0;
          }
#line 790
          pstr->tip_context = (unsigned int )tmp___13;
        }
      }
    }
    {
#line 796
    tmp___16 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 796
    if (! tmp___16) {
#line 797
      pstr->mbs += offset;
    }
  }
#line 799
  pstr->raw_mbs_idx = idx;
#line 800
  pstr->len -= offset;
#line 801
  pstr->stop -= offset;
#line 805
  if (pstr->mb_cur_max > 1) {
#line 807
    if (pstr->icase) {
      {
#line 809
      tmp___18 = build_wcs_upper_buffer(pstr);
#line 809
      ret = tmp___18;
#line 810
      tmp___19 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 810
      if (tmp___19) {
#line 811
        return (ret);
      }
    } else {
      {
#line 814
      build_wcs_buffer(pstr);
      }
    }
  } else {
    {
#line 818
    tmp___20 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 818
    if (tmp___20) {
#line 820
      if (pstr->icase) {
        {
#line 821
        build_upper_buffer(pstr);
        }
      } else
#line 822
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
        {
#line 823
        re_string_translate_buffer(pstr);
        }
      }
    } else {
#line 826
      pstr->valid_len = pstr->len;
    }
  }
#line 828
  pstr->cur_idx = (Idx )0;
#line 829
  return ((reg_errcode_t )0);
}
}
#line 832 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case(re_string_t const   *pstr ,
                                                                         Idx idx ) 
{ 
  int ch ;
  Idx off ;
  long tmp ;

  {
  {
#line 840
  tmp = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 840
  if (tmp) {
#line 841
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
  }
#line 844
  if (pstr->mb_cur_max > 1) {
#line 844
    if (*(pstr->wcs + (pstr->cur_idx + (Idx const   )idx)) != 4294967295U) {
#line 844
      if (! (pstr->valid_len == (pstr->cur_idx + (Idx const   )idx) + 1UL)) {
#line 844
        if (! (*(pstr->wcs + ((pstr->cur_idx + (Idx const   )idx) + 1UL)) != 4294967295U)) {
#line 846
          return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
        }
      }
    } else {
#line 846
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 849
  off = (Idx )(pstr->cur_idx + (Idx const   )idx);
#line 851
  if (pstr->offsets_needed) {
#line 852
    off = *(pstr->offsets + off);
  }
#line 855
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (Idx const   )off));
#line 862
  if (pstr->offsets_needed) {
#line 862
    if (! ((ch & -128) == 0)) {
#line 863
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 866
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
#line 869 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_fetch_byte_case(re_string_t *pstr ) 
{ 
  Idx tmp ;
  long tmp___0 ;
  Idx off ;
  int ch ;
  Idx tmp___1 ;
  Idx tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 873
  tmp___0 = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 873
  if (tmp___0) {
#line 874
    tmp = pstr->cur_idx;
#line 874
    (pstr->cur_idx) ++;
#line 874
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp));
  }
#line 877
  if (pstr->offsets_needed) {
#line 889
    if (! (pstr->cur_idx == pstr->valid_len)) {
#line 889
      if (! (*(pstr->wcs + pstr->cur_idx) != 4294967295U)) {
#line 890
        tmp___1 = pstr->cur_idx;
#line 890
        (pstr->cur_idx) ++;
#line 890
        return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___1));
      }
    }
#line 892
    off = *(pstr->offsets + pstr->cur_idx);
#line 893
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + off));
#line 895
    if (! ((ch & -128) == 0)) {
#line 896
      tmp___2 = pstr->cur_idx;
#line 896
      (pstr->cur_idx) ++;
#line 896
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___2));
    }
    {
#line 898
    tmp___3 = re_string_char_size_at((re_string_t const   *)pstr, pstr->cur_idx);
#line 898
    pstr->cur_idx += (Idx )tmp___3;
    }
#line 900
    return ((unsigned char __attribute__((__pure__))  )ch);
  }
#line 904
  tmp___4 = pstr->cur_idx;
#line 904
  (pstr->cur_idx) ++;
#line 904
  return ((unsigned char __attribute__((__pure__))  )*(pstr->raw_mbs + (pstr->raw_mbs_idx + tmp___4)));
}
}
#line 907 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_destruct(re_string_t *pstr ) 
{ 


  {
  {
#line 912
  free((void *)pstr->wcs);
#line 913
  free((void *)pstr->offsets);
  }
#line 915
  if (pstr->mbs_allocated) {
    {
#line 916
    free((void *)pstr->mbs);
    }
  }
#line 917
  return;
}
}
#line 921
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 921 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags ) 
{ 
  int c ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  wint_t wc ;
  Idx wc_idx ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;

  {
  {
#line 926
  tmp = __builtin_expect((long )(! (idx < 0xfffffffffffffffeUL)), 0L);
  }
#line 926
  if (tmp) {
#line 929
    return ((unsigned int )input->tip_context);
  }
  {
#line 930
  tmp___1 = __builtin_expect((long )(idx == (Idx )input->len), 0L);
  }
#line 930
  if (tmp___1) {
#line 931
    if (eflags & (1 << 1)) {
#line 931
      tmp___0 = ((1 << 1) << 1) << 1;
    } else {
#line 931
      tmp___0 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
#line 931
    return ((unsigned int )tmp___0);
  }
#line 934
  if (input->mb_cur_max > 1) {
#line 937
    wc_idx = idx;
    {
#line 938
    while (1) {
      while_continue: /* CIL Label */ ;
#line 938
      if (! (*(input->wcs + wc_idx) == 4294967295U)) {
#line 938
        goto while_break;
      }
#line 944
      wc_idx --;
#line 945
      if (! (wc_idx < 0xfffffffffffffffeUL)) {
#line 946
        return ((unsigned int )input->tip_context);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 948
    wc = *(input->wcs + wc_idx);
#line 949
    tmp___2 = __builtin_expect((long )((int const   )input->word_ops_used != 0), 0L);
    }
#line 949
    if (tmp___2) {
      {
#line 949
      tmp___3 = iswalnum(wc);
      }
#line 949
      if (tmp___3) {
#line 950
        return (1U);
      } else
#line 949
      if (wc == 95U) {
#line 950
        return (1U);
      }
    }
#line 951
    if (wc == 10U) {
#line 951
      if (input->newline_anchor) {
#line 951
        tmp___4 = 1 << 1;
      } else {
#line 951
        tmp___4 = 0;
      }
    } else {
#line 951
      tmp___4 = 0;
    }
#line 951
    return ((unsigned int )tmp___4);
  } else {
    {
#line 957
    c = (int )*(input->mbs + idx);
#line 958
    tmp___5 = bitset_contain((bitset_word_t */* const  */)input->word_char, (Idx )c);
    }
#line 958
    if (tmp___5) {
#line 959
      return (1U);
    }
#line 960
    if (c == 10) {
#line 960
      if (input->newline_anchor) {
#line 960
        tmp___6 = 1 << 1;
      } else {
#line 960
        tmp___6 = 0;
      }
    } else {
#line 960
      tmp___6 = 0;
    }
#line 960
    return ((unsigned int )tmp___6);
  }
}
}
#line 966 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_alloc(re_node_set *set , Idx size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 970
  set->alloc = size;
#line 971
  set->nelem = (Idx )0;
#line 972
  tmp = malloc(size * sizeof(Idx ));
#line 972
  set->elems = (Idx *)tmp;
#line 973
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 973
  if (tmp___0) {
#line 974
    return ((reg_errcode_t )12);
  }
#line 975
  return ((reg_errcode_t )0);
}
}
#line 978 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_1(re_node_set *set , Idx elem ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
  {
#line 982
  set->alloc = (Idx )1;
#line 983
  set->nelem = (Idx )1;
#line 984
  tmp = malloc(sizeof(Idx ));
#line 984
  set->elems = (Idx *)tmp;
#line 985
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 985
  if (tmp___1) {
#line 987
    tmp___0 = (Idx )0;
#line 987
    set->nelem = tmp___0;
#line 987
    set->alloc = tmp___0;
#line 988
    return ((reg_errcode_t )12);
  }
#line 990
  *(set->elems + 0) = elem;
#line 991
  return ((reg_errcode_t )0);
}
}
#line 994 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_2(re_node_set *set , Idx elem1 , Idx elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 998
  set->alloc = (Idx )2;
#line 999
  tmp = malloc(2UL * sizeof(Idx ));
#line 999
  set->elems = (Idx *)tmp;
#line 1000
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 1000
  if (tmp___0) {
#line 1001
    return ((reg_errcode_t )12);
  }
#line 1002
  if (elem1 == elem2) {
#line 1004
    set->nelem = (Idx )1;
#line 1005
    *(set->elems + 0) = elem1;
  } else {
#line 1009
    set->nelem = (Idx )2;
#line 1010
    if (elem1 < elem2) {
#line 1012
      *(set->elems + 0) = elem1;
#line 1013
      *(set->elems + 1) = elem2;
    } else {
#line 1017
      *(set->elems + 0) = elem2;
#line 1018
      *(set->elems + 1) = elem1;
    }
  }
#line 1021
  return ((reg_errcode_t )0);
}
}
#line 1024 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
#line 1028
  dest->nelem = (Idx )src->nelem;
#line 1029
  if (src->nelem > 0UL) {
    {
#line 1031
    dest->alloc = dest->nelem;
#line 1032
    tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1032
    dest->elems = (Idx *)tmp;
#line 1033
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1033
    if (tmp___1) {
#line 1035
      tmp___0 = (Idx )0;
#line 1035
      dest->nelem = tmp___0;
#line 1035
      dest->alloc = tmp___0;
#line 1036
      return ((reg_errcode_t )12);
    }
    {
#line 1038
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
    }
  } else {
    {
#line 1041
    memset((void *)dest, '\000', sizeof(re_node_set ));
    }
  }
#line 1042
  return ((reg_errcode_t )0);
}
}
#line 1049 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx is ;
  Idx id ;
  Idx delta ;
  Idx sbase ;
  Idx new_alloc ;
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  Idx tmp___2 ;

  {
#line 1055
  if (src1->nelem == 0UL) {
#line 1056
    return ((reg_errcode_t )0);
  } else
#line 1055
  if (src2->nelem == 0UL) {
#line 1056
    return ((reg_errcode_t )0);
  }
#line 1060
  if ((src1->nelem + src2->nelem) + (Idx const   )dest->nelem > (Idx const   )dest->alloc) {
    {
#line 1062
    new_alloc = (Idx )((src1->nelem + src2->nelem) + (Idx const   )dest->alloc);
#line 1063
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1063
    new_elems = (Idx *)tmp;
#line 1064
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1064
    if (tmp___0) {
#line 1065
      return ((reg_errcode_t )12);
    }
#line 1066
    dest->elems = new_elems;
#line 1067
    dest->alloc = new_alloc;
  }
#line 1072
  sbase = (dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem;
#line 1073
  i1 = (Idx )(src1->nelem - 1UL);
#line 1074
  i2 = (Idx )(src2->nelem - 1UL);
#line 1075
  id = dest->nelem - 1UL;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
#line 1081
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1081
        if (id < 0xfffffffffffffffeUL) {
#line 1081
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
#line 1081
            goto while_break___0;
          }
        } else {
#line 1081
          goto while_break___0;
        }
#line 1082
        id --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1084
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1085
        sbase --;
#line 1085
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else
#line 1084
      if (*(dest->elems + id) != *(src1->elems + i1)) {
#line 1085
        sbase --;
#line 1085
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1087
      i1 --;
#line 1087
      if (i1 < 0xfffffffffffffffeUL) {
#line 1087
        i2 --;
#line 1087
        if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1088
          goto while_break;
        }
      } else {
#line 1088
        goto while_break;
      }
    } else
#line 1092
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1094
      i2 --;
#line 1094
      if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1095
        goto while_break;
      }
    } else {
#line 1099
      i1 --;
#line 1099
      if (! (i1 < 0xfffffffffffffffeUL)) {
#line 1100
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  id = dest->nelem - 1UL;
#line 1105
  is = ((dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem) - 1UL;
#line 1106
  delta = (is - sbase) + 1UL;
#line 1111
  dest->nelem += delta;
#line 1112
  if (delta > 0UL) {
#line 1112
    if (id < 0xfffffffffffffffeUL) {
      {
#line 1113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1115
        if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1118
          tmp___1 = delta;
#line 1118
          delta --;
#line 1118
          tmp___2 = is;
#line 1118
          is --;
#line 1118
          *(dest->elems + (id + tmp___1)) = *(dest->elems + tmp___2);
#line 1119
          if (delta == 0UL) {
#line 1120
            goto while_break___1;
          }
        } else {
#line 1125
          *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1126
          id --;
#line 1126
          if (! (id < 0xfffffffffffffffeUL)) {
#line 1127
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 1132
  memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
         delta * sizeof(Idx ));
  }
#line 1134
  return ((reg_errcode_t )0);
}
}
#line 1140 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 1146
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1146
    if (src1->nelem > 0UL) {
#line 1146
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1146
        if (src2->nelem > 0UL) {
          {
#line 1148
          dest->alloc = (Idx )(src1->nelem + src2->nelem);
#line 1149
          tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1149
          dest->elems = (Idx *)tmp;
#line 1150
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
#line 1150
          if (tmp___0) {
#line 1151
            return ((reg_errcode_t )12);
          }
        } else {
#line 1146
          goto _L___2;
        }
      } else {
#line 1146
        goto _L___2;
      }
    } else {
#line 1146
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1155
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1155
      if (src1->nelem > 0UL) {
        {
#line 1156
        tmp___1 = re_node_set_init_copy(dest, src1);
        }
#line 1156
        return (tmp___1);
      } else {
#line 1155
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1157
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1157
      if (src2->nelem > 0UL) {
        {
#line 1158
        tmp___2 = re_node_set_init_copy(dest, src2);
        }
#line 1158
        return (tmp___2);
      } else {
        {
#line 1160
        memset((void *)dest, '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 1160
      memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    }
#line 1161
    return ((reg_errcode_t )0);
  }
#line 1163
  id = (Idx )0;
#line 1163
  i2 = id;
#line 1163
  i1 = i2;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (i1 < (Idx )src1->nelem) {
#line 1163
      if (! (i2 < (Idx )src2->nelem)) {
#line 1163
        goto while_break;
      }
    } else {
#line 1163
      goto while_break;
    }
#line 1165
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1167
      tmp___3 = id;
#line 1167
      id ++;
#line 1167
      tmp___4 = i2;
#line 1167
      i2 ++;
#line 1167
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
#line 1168
      goto __Cont;
    }
#line 1170
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1171
      i2 ++;
    }
#line 1172
    tmp___5 = id;
#line 1172
    id ++;
#line 1172
    tmp___6 = i1;
#line 1172
    i1 ++;
#line 1172
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  if (i1 < (Idx )src1->nelem) {
    {
#line 1176
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src1->elems + i1),
           (size_t )((src1->nelem - (Idx const   )i1) * (Idx const   )sizeof(Idx )));
#line 1178
    id += (Idx )(src1->nelem - (Idx const   )i1);
    }
  } else
#line 1180
  if (i2 < (Idx )src2->nelem) {
    {
#line 1182
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src2->elems + i2),
           (size_t )((src2->nelem - (Idx const   )i2) * (Idx const   )sizeof(Idx )));
#line 1184
    id += (Idx )(src2->nelem - (Idx const   )i2);
    }
  }
#line 1186
  dest->nelem = id;
#line 1187
  return ((reg_errcode_t )0);
}
}
#line 1193 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ 
  Idx is ;
  Idx id ;
  Idx sbase ;
  Idx delta ;
  Idx new_alloc ;
  Idx *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;

  {
#line 1198
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1199
    return ((reg_errcode_t )0);
  } else
#line 1198
  if (src->nelem == 0UL) {
#line 1199
    return ((reg_errcode_t )0);
  }
#line 1200
  if (dest->alloc < (Idx )(2UL * src->nelem + (Idx const   )dest->nelem)) {
    {
#line 1202
    new_alloc = (Idx )(2UL * (src->nelem + (Idx const   )dest->alloc));
#line 1203
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1203
    new_buffer = (Idx *)tmp;
#line 1204
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
#line 1204
    if (tmp___0) {
#line 1205
      return ((reg_errcode_t )12);
    }
#line 1206
    dest->elems = new_buffer;
#line 1207
    dest->alloc = new_alloc;
  }
  {
#line 1210
  tmp___1 = __builtin_expect((long )(dest->nelem == 0UL), 0L);
  }
#line 1210
  if (tmp___1) {
    {
#line 1212
    dest->nelem = (Idx )src->nelem;
#line 1213
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
    }
#line 1214
    return ((reg_errcode_t )0);
  }
#line 1219
  sbase = dest->nelem + (Idx )(2UL * src->nelem);
#line 1219
  is = (Idx )(src->nelem - 1UL);
#line 1219
  id = dest->nelem - 1UL;
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1219
    if (is < 0xfffffffffffffffeUL) {
#line 1219
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1219
        goto while_break;
      }
    } else {
#line 1219
      goto while_break;
    }
#line 1223
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1224
      is --;
#line 1224
      id --;
    } else
#line 1225
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1226
      sbase --;
#line 1226
      tmp___2 = is;
#line 1226
      is --;
#line 1226
      *(dest->elems + sbase) = *(src->elems + tmp___2);
    } else {
#line 1228
      id --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  if (is < 0xfffffffffffffffeUL) {
    {
#line 1234
    sbase -= is + 1UL;
#line 1235
    memcpy((void */* __restrict  */)(dest->elems + sbase), (void const   */* __restrict  */)src->elems,
           (is + 1UL) * sizeof(Idx ));
    }
  }
#line 1238
  id = dest->nelem - 1UL;
#line 1239
  is = (dest->nelem + (Idx )(2UL * src->nelem)) - 1UL;
#line 1240
  delta = (is - sbase) + 1UL;
#line 1241
  if (delta == 0UL) {
#line 1242
    return ((reg_errcode_t )0);
  }
#line 1246
  dest->nelem += delta;
  {
#line 1247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1249
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1252
      tmp___3 = delta;
#line 1252
      delta --;
#line 1252
      tmp___4 = is;
#line 1252
      is --;
#line 1252
      *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
#line 1253
      if (delta == 0UL) {
#line 1254
        goto while_break___0;
      }
    } else {
#line 1259
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1260
      id --;
#line 1260
      if (! (id < 0xfffffffffffffffeUL)) {
        {
#line 1263
        memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
               delta * sizeof(Idx ));
        }
#line 1265
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1270
  return ((reg_errcode_t )0);
}
}
#line 1277 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool re_node_set_insert(re_node_set *set , Idx elem ) 
{ 
  Idx idx ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx *new_elems ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 1283
  if (set->alloc == 0UL) {
    {
#line 1284
    tmp = re_node_set_init_1(set, elem);
#line 1284
    tmp___0 = __builtin_expect((long )((int )tmp == 0), 1L);
    }
#line 1284
    return ((_Bool )tmp___0);
  }
  {
#line 1286
  tmp___1 = __builtin_expect((long )set->nelem, 0L);
  }
#line 1286
  if (tmp___1 == 0L) {
#line 1289
    *(set->elems + 0) = elem;
#line 1290
    (set->nelem) ++;
#line 1291
    return ((_Bool)1);
  }
#line 1295
  if (set->alloc == set->nelem) {
    {
#line 1298
    set->alloc *= 2UL;
#line 1299
    tmp___2 = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1299
    new_elems = (Idx *)tmp___2;
#line 1300
    tmp___3 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1300
    if (tmp___3) {
#line 1301
      return ((_Bool)0);
    }
#line 1302
    set->elems = new_elems;
  }
#line 1307
  if (elem < *(set->elems + 0)) {
#line 1309
    idx = (Idx )0;
#line 1310
    idx = set->nelem;
    {
#line 1310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1310
      if (! (idx > 0UL)) {
#line 1310
        goto while_break;
      }
#line 1311
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1310
      idx --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1315
    idx = set->nelem;
    {
#line 1315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1315
      if (! (*(set->elems + (idx - 1UL)) > elem)) {
#line 1315
        goto while_break___0;
      }
#line 1316
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1315
      idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1320
  *(set->elems + idx) = elem;
#line 1321
  (set->nelem) ++;
#line 1322
  return ((_Bool)1);
}
}
#line 1329 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool re_node_set_insert_last(re_node_set *set , Idx elem ) 
{ 
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 1334
  if (set->alloc == set->nelem) {
    {
#line 1337
    set->alloc = (set->alloc + 1UL) * 2UL;
#line 1338
    tmp = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1338
    new_elems = (Idx *)tmp;
#line 1339
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1339
    if (tmp___0) {
#line 1340
      return ((_Bool)0);
    }
#line 1341
    set->elems = new_elems;
  }
#line 1345
  tmp___1 = set->nelem;
#line 1345
  (set->nelem) ++;
#line 1345
  *(set->elems + tmp___1) = elem;
#line 1346
  return ((_Bool)1);
}
}
#line 1352 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool __attribute__((__pure__))  re_node_set_compare(re_node_set const   *set1 ,
                                                            re_node_set const   *set2 ) 
{ 
  Idx i ;

  {
#line 1357
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1357
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1357
  if (set1->nelem != set2->nelem) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  }
#line 1359
  i = (Idx )set1->nelem;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    i --;
#line 1359
    if (! (i < 0xfffffffffffffffeUL)) {
#line 1359
      goto while_break;
    }
#line 1360
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 1361
      return ((_Bool __attribute__((__pure__))  )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 1367 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx __attribute__((__pure__))  re_node_set_contains(re_node_set const   *set ,
                                                           Idx elem ) 
{ 
  __re_size_t idx ;
  __re_size_t right ;
  __re_size_t mid ;
  __re_size_t tmp ;

  {
#line 1372
  if (! ((Idx )(set->nelem - 1UL) < 0xfffffffffffffffdUL)) {
#line 1373
    return ((Idx __attribute__((__pure__))  )0);
  }
#line 1376
  idx = (__re_size_t )0;
#line 1377
  right = (__re_size_t )(set->nelem - 1UL);
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1378
    if (! (idx < right)) {
#line 1378
      goto while_break;
    }
#line 1380
    mid = (idx + right) / 2UL;
#line 1381
    if (*(set->elems + mid) < elem) {
#line 1382
      idx = mid + 1UL;
    } else {
#line 1384
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1386
  if (*(set->elems + idx) == elem) {
#line 1386
    tmp = idx + 1UL;
  } else {
#line 1386
    tmp = (__re_size_t )0;
  }
#line 1386
  return ((Idx __attribute__((__pure__))  )tmp);
}
}
#line 1389 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , Idx idx ) 
{ 


  {
#line 1393
  if (idx < 0UL) {
#line 1394
    return;
  } else
#line 1393
  if (idx >= set->nelem) {
#line 1394
    return;
  }
#line 1395
  (set->nelem) --;
  {
#line 1396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1396
    if (! (idx < set->nelem)) {
#line 1396
      goto while_break;
    }
#line 1397
    *(set->elems + idx) = *(set->elems + (idx + 1UL));
#line 1396
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1404 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx re_dfa_add_node(re_dfa_t *dfa , re_token_t token ) 
{ 
  size_t new_nodes_alloc ;
  Idx *new_nexts ;
  Idx *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int type ;
  int tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 1408
  tmp___12 = __builtin_expect((long )(dfa->nodes_len >= dfa->nodes_alloc), 0L);
  }
#line 1408
  if (tmp___12) {
#line 1410
    new_nodes_alloc = dfa->nodes_alloc * 2UL;
#line 1414
    if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1414
      tmp___2 = sizeof(Idx );
    } else {
#line 1414
      tmp___2 = sizeof(re_node_set );
    }
#line 1414
    if (sizeof(re_token_t ) < tmp___2) {
#line 1414
      if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1414
        tmp___0 = sizeof(Idx );
      } else {
#line 1414
        tmp___0 = sizeof(re_node_set );
      }
#line 1414
      tmp___1 = tmp___0;
    } else {
#line 1414
      tmp___1 = sizeof(re_token_t );
    }
    {
#line 1414
    max_object_size = tmp___1;
#line 1420
    tmp___3 = __builtin_expect((long )(9223372036854775807UL / max_object_size < dfa->nodes_alloc),
                               0L);
    }
#line 1420
    if (tmp___3) {
#line 1421
      return ((Idx )-1);
    }
    {
#line 1423
    tmp___4 = realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1423
    new_nodes = (re_token_t *)tmp___4;
#line 1424
    tmp___5 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
    }
#line 1424
    if (tmp___5) {
#line 1425
      return ((Idx )-1);
    }
    {
#line 1426
    dfa->nodes = new_nodes;
#line 1427
    tmp___6 = realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(Idx ));
#line 1427
    new_nexts = (Idx *)tmp___6;
#line 1428
    tmp___7 = realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(Idx ));
#line 1428
    new_indices = (Idx *)tmp___7;
#line 1429
    tmp___8 = realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1429
    new_edests = (re_node_set *)tmp___8;
#line 1430
    tmp___9 = realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1430
    new_eclosures = (re_node_set *)tmp___9;
    }
#line 1431
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else {
#line 1431
      tmp___10 = 0;
    }
    {
#line 1431
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 1431
    if (tmp___11) {
#line 1433
      return ((Idx )-1);
    }
#line 1434
    dfa->nexts = new_nexts;
#line 1435
    dfa->org_indices = new_indices;
#line 1436
    dfa->edests = new_edests;
#line 1437
    dfa->eclosures = new_eclosures;
#line 1438
    dfa->nodes_alloc = new_nodes_alloc;
  }
#line 1440
  *(dfa->nodes + dfa->nodes_len) = token;
#line 1441
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 1444
  type = (int )token.type;
#line 1445
  if (type == 5) {
#line 1445
    if (dfa->mb_cur_max > 1) {
#line 1445
      tmp___13 = 1;
    } else {
#line 1445
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1445
  if (type == 6) {
#line 1445
    tmp___13 = 1;
  } else {
#line 1445
    tmp___13 = 0;
  }
  {
#line 1445
  (dfa->nodes + dfa->nodes_len)->accept_mb = (unsigned int )tmp___13;
#line 1449
  *(dfa->nexts + dfa->nodes_len) = (Idx )-1;
#line 1450
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1451
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1452
  tmp___14 = dfa->nodes_len;
#line 1452
  (dfa->nodes_len) ++;
  }
#line 1452
  return (tmp___14);
}
}
#line 1455 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
__inline static re_hashval_t calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  Idx i ;

  {
#line 1459
  hash = (re_hashval_t )(nodes->nelem + (Idx const   )context);
#line 1461
  i = (Idx )0;
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! (i < (Idx )nodes->nelem)) {
#line 1461
      goto while_break;
    }
#line 1462
    hash += *(nodes->elems + i);
#line 1461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (hash);
}
}
#line 1475 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                       re_node_set const   *nodes ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  long tmp ;
  re_dfastate_t *state___0 ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1488
  tmp = __builtin_expect((long )(nodes->nelem == 0UL), 0L);
  }
#line 1488
  if (tmp) {
#line 1490
    *err = (reg_errcode_t )0;
#line 1491
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1493
  hash = calc_state_hash(nodes, 0U);
#line 1494
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1496
  i = (Idx )0;
  }
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! (i < spot->num)) {
#line 1496
      goto while_break;
    }
#line 1498
    state___0 = *(spot->array + i);
#line 1499
    if (hash != state___0->hash) {
#line 1500
      goto __Cont;
    }
    {
#line 1501
    tmp___0 = re_node_set_compare((re_node_set const   *)(& state___0->nodes), nodes);
    }
#line 1501
    if (tmp___0) {
#line 1502
      return (state___0);
    }
    __Cont: /* CIL Label */ 
#line 1496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  new_state = create_ci_newstate(dfa, nodes, hash);
#line 1507
  tmp___1 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1507
  if (tmp___1) {
#line 1508
    *err = (reg_errcode_t )12;
  }
#line 1510
  return (new_state);
}
}
#line 1523 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state___0 ;
  _Bool __attribute__((__pure__))  tmp ;
  long tmp___0 ;

  {
#line 1536
  if (nodes->nelem == 0UL) {
#line 1538
    *err = (reg_errcode_t )0;
#line 1539
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1541
  hash = calc_state_hash(nodes, context);
#line 1542
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1544
  i = (Idx )0;
  }
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1544
    if (! (i < spot->num)) {
#line 1544
      goto while_break;
    }
#line 1546
    state___0 = *(spot->array + i);
#line 1547
    if (state___0->hash == hash) {
#line 1547
      if (state___0->context == context) {
        {
#line 1547
        tmp = re_node_set_compare((re_node_set const   *)state___0->entrance_nodes,
                                  nodes);
        }
#line 1547
        if (tmp) {
#line 1550
          return (state___0);
        }
      }
    }
#line 1544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1553
  new_state = create_cd_newstate(dfa, nodes, context, hash);
#line 1554
  tmp___0 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1554
  if (tmp___0) {
#line 1555
    *err = (reg_errcode_t )12;
  }
#line 1557
  return (new_state);
}
}
#line 1564 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t register_state(re_dfa_t const   *dfa , re_dfastate_t *newstate ,
                                    re_hashval_t hash ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  Idx i ;
  long tmp ;
  Idx elem ;
  _Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  Idx new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx tmp___6 ;

  {
  {
#line 1572
  newstate->hash = hash;
#line 1573
  err = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1574
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1574
  if (tmp) {
#line 1575
    return ((reg_errcode_t )12);
  }
#line 1576
  i = (Idx )0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1576
    if (! (i < newstate->nodes.nelem)) {
#line 1576
      goto while_break;
    }
#line 1578
    elem = *(newstate->nodes.elems + i);
#line 1579
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
      {
#line 1580
      tmp___0 = re_node_set_insert_last(& newstate->non_eps_nodes, elem);
      }
#line 1580
      if (tmp___0) {
#line 1580
        tmp___1 = 0;
      } else {
#line 1580
        tmp___1 = 1;
      }
      {
#line 1580
      tmp___2 = __builtin_expect((long )tmp___1, 0L);
      }
#line 1580
      if (tmp___2) {
#line 1581
        return ((reg_errcode_t )12);
      }
    }
#line 1576
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1584
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1585
  tmp___5 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
  }
#line 1585
  if (tmp___5) {
    {
#line 1587
    new_alloc = 2UL * spot->num + 2UL;
#line 1588
    tmp___3 = realloc((void *)spot->array, new_alloc * sizeof(re_dfastate_t *));
#line 1588
    new_array = (re_dfastate_t **)tmp___3;
#line 1590
    tmp___4 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 1590
    if (tmp___4) {
#line 1591
      return ((reg_errcode_t )12);
    }
#line 1592
    spot->array = new_array;
#line 1593
    spot->alloc = new_alloc;
  }
#line 1595
  tmp___6 = spot->num;
#line 1595
  (spot->num) ++;
#line 1595
  *(spot->array + tmp___6) = newstate;
#line 1596
  return ((reg_errcode_t )0);
}
}
#line 1599 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void free_state(re_dfastate_t *state___0 ) 
{ 


  {
  {
#line 1602
  free((void *)state___0->non_eps_nodes.elems);
#line 1603
  free((void *)state___0->inveclosure.elems);
  }
#line 1604
  if ((unsigned long )state___0->entrance_nodes != (unsigned long )(& state___0->nodes)) {
    {
#line 1606
    free((void *)(state___0->entrance_nodes)->elems);
#line 1607
    free((void *)state___0->entrance_nodes);
    }
  }
  {
#line 1609
  free((void *)state___0->nodes.elems);
#line 1610
  free((void *)state___0->word_trtable);
#line 1611
  free((void *)state___0->trtable);
#line 1612
  free((void *)state___0);
  }
#line 1613
  return;
}
}
#line 1618 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) 
{ 
  Idx i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___2 ;

  {
  {
#line 1627
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1627
  newstate = (re_dfastate_t *)tmp;
#line 1628
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1628
  if (tmp___0) {
#line 1629
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1630
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1631
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1631
  if (tmp___1) {
    {
#line 1633
    free((void *)newstate);
    }
#line 1634
    return ((re_dfastate_t *)((void *)0));
  }
#line 1637
  newstate->entrance_nodes = & newstate->nodes;
#line 1638
  i = (Idx )0;
  {
#line 1638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1638
    if (! (i < (Idx )nodes->nelem)) {
#line 1638
      goto while_break;
    }
#line 1640
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1641
    type = node->type;
#line 1642
    if ((unsigned int )type == 1U) {
#line 1642
      if (! node->constraint) {
#line 1643
        goto __Cont;
      }
    }
#line 1645
    newstate->accept_mb |= node->accept_mb;
#line 1649
    if ((unsigned int )type == 2U) {
#line 1650
      newstate->halt = 1U;
    } else
#line 1651
    if ((unsigned int )type == 4U) {
#line 1652
      newstate->has_backref = 1U;
    } else
#line 1653
    if ((unsigned int )type == 12U) {
#line 1654
      newstate->has_constraint = 1U;
    } else
#line 1653
    if (node->constraint) {
#line 1654
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1656
  err = register_state(dfa, newstate, hash);
#line 1657
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1657
  if (tmp___2) {
    {
#line 1659
    free_state(newstate);
#line 1660
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1662
  return (newstate);
}
}
#line 1668 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) 
{ 
  Idx i ;
  Idx nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1673
  nctx_nodes = (Idx )0;
#line 1677
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1677
  newstate = (re_dfastate_t *)tmp;
#line 1678
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1678
  if (tmp___0) {
#line 1679
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1680
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1681
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1681
  if (tmp___1) {
    {
#line 1683
    free((void *)newstate);
    }
#line 1684
    return ((re_dfastate_t *)((void *)0));
  }
#line 1687
  newstate->context = context;
#line 1688
  newstate->entrance_nodes = & newstate->nodes;
#line 1690
  i = (Idx )0;
  {
#line 1690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1690
    if (! (i < (Idx )nodes->nelem)) {
#line 1690
      goto while_break;
    }
#line 1692
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1693
    type = node->type;
#line 1694
    constraint = node->constraint;
#line 1696
    if ((unsigned int )type == 1U) {
#line 1696
      if (! constraint) {
#line 1697
        goto __Cont;
      }
    }
#line 1699
    newstate->accept_mb |= node->accept_mb;
#line 1703
    if ((unsigned int )type == 2U) {
#line 1704
      newstate->halt = 1U;
    } else
#line 1705
    if ((unsigned int )type == 4U) {
#line 1706
      newstate->has_backref = 1U;
    }
#line 1708
    if (constraint) {
#line 1710
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
#line 1712
        tmp___2 = malloc(sizeof(re_node_set ));
#line 1712
        newstate->entrance_nodes = (re_node_set *)tmp___2;
#line 1713
        tmp___3 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
#line 1713
        if (tmp___3) {
          {
#line 1715
          free_state(newstate);
          }
#line 1716
          return ((re_dfastate_t *)((void *)0));
        }
        {
#line 1718
        re_node_set_init_copy(newstate->entrance_nodes, nodes);
#line 1719
        nctx_nodes = (Idx )0;
#line 1720
        newstate->has_constraint = 1U;
        }
      }
#line 1723
      if (constraint & 1U) {
#line 1723
        if (! (context & 1U)) {
          {
#line 1725
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1723
      if (constraint & 2U) {
#line 1723
        if (context & 1U) {
          {
#line 1725
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1723
      if (constraint & 16U) {
#line 1723
        if (! (context & (unsigned int )(1 << 1))) {
          {
#line 1725
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1723
      if (constraint & 64U) {
#line 1723
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
#line 1725
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1690
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1730
  err = register_state(dfa, newstate, hash);
#line 1731
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1731
  if (tmp___4) {
    {
#line 1733
    free_state(newstate);
#line 1734
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1736
  return (newstate);
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
#line 23
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 26
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) ;
#line 28
static void free_charset(re_charset_t *cset ) ;
#line 30
static void free_workarea_compile(regex_t *preg ) ;
#line 31
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
#line 33
static void optimize_utf8(re_dfa_t *dfa ) ;
#line 35
static reg_errcode_t analyze(regex_t *preg ) ;
#line 36
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
#line 39
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
#line 42
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
#line 43
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
#line 44
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
#line 46
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
#line 47
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) ;
#line 48
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
#line 49
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) ;
#line 50
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) ;
#line 52
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
#line 53
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) ;
#line 55
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) ;
#line 56
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 58
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 60
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
#line 62
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 65
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 68
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 71
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 74
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 77
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 80
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) ;
#line 86
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
#line 90
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) ;
#line 94
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) ;
#line 108
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) ;
#line 113
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
#line 116
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
#line 119
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) ;
#line 120
static void free_token(re_token_t *node ) ;
#line 121
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) ;
#line 122
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
#line 129 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static char const   __re_error_msgid[369]  = 
#line 129
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 183 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static size_t const   __re_error_msgid_idx[17]  = 
#line 183
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 220 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;
  char *tmp ;

  {
  {
#line 230
  bufp->no_sub = (unsigned int )(! (! (rpl_re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
#line 233
  bufp->newline_anchor = 1U;
#line 235
  ret = re_compile_internal(bufp, pattern, length, rpl_re_syntax_options);
  }
#line 237
  if (! ret) {
#line 238
    return ((char const   *)((void *)0));
  }
  {
#line 239
  tmp = gettext(__re_error_msgid + __re_error_msgid_idx[(int )ret]);
  }
#line 239
  return ((char const   *)tmp);
}
}
#line 260 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 264
  ret = rpl_re_syntax_options;
#line 266
  rpl_re_syntax_options = syntax;
#line 267
  return (ret);
}
}
#line 273 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa ;
  char *fastmap ;

  {
  {
#line 277
  dfa = (re_dfa_t *)bufp->buffer;
#line 278
  fastmap = bufp->fastmap;
#line 280
  memset((void *)fastmap, '\000', sizeof(char ) * 256UL);
#line 281
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
  }
#line 282
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_word) {
    {
#line 283
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
    }
  }
#line 284
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_nl) {
    {
#line 285
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
    }
  }
#line 286
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_begbuf) {
    {
#line 287
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
    }
  }
#line 288
  bufp->fastmap_accurate = 1U;
#line 289
  return (0);
}
}
#line 295 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          _Bool icase ,
                                                                          int ch ) 
{ 
  int tmp ;

  {
#line 299
  *(fastmap + ch) = (char)1;
#line 300
  if (icase) {
    {
#line 301
    tmp = tolower(ch);
#line 301
    *(fastmap + tmp) = (char)1;
    }
  }
#line 302
  return;
}
}
#line 307 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  Idx node_cnt ;
  _Bool icase ;
  int tmp ;
  Idx node ;
  re_token_type_t type ;
  unsigned char buf___1[16] ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  size_t tmp___2 ;
  wint_t tmp___3 ;
  size_t tmp___4 ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;
  re_charset_t *cset ;
  Idx i___0 ;
  unsigned char c ;
  mbstate_t mbs ;
  size_t tmp___5 ;
  char buf___2[256] ;
  mbstate_t state___1 ;
  size_t tmp___6 ;
  wint_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 311
  dfa = (re_dfa_t *)bufp->buffer;
#line 313
  if (dfa->mb_cur_max == 1) {
#line 313
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 313
      tmp = 1;
    } else {
#line 313
      tmp = 0;
    }
  } else {
#line 313
    tmp = 0;
  }
#line 313
  icase = (_Bool )tmp;
#line 314
  node_cnt = (Idx )0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (node_cnt < (Idx )init_state->nodes.nelem)) {
#line 314
      goto while_break;
    }
#line 316
    node = *(init_state->nodes.elems + node_cnt);
#line 317
    type = (dfa->nodes + node)->type;
#line 319
    if ((unsigned int )type == 1U) {
      {
#line 321
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
      }
#line 323
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 323
        if (dfa->mb_cur_max > 1) {
#line 330
          p = buf___1;
#line 331
          tmp___0 = p;
#line 331
          p ++;
#line 331
          *tmp___0 = (dfa->nodes + node)->opr.c;
          {
#line 332
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 332
            node ++;
#line 332
            if (node < dfa->nodes_len) {
#line 332
              if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 332
                if (! (dfa->nodes + node)->mb_partial) {
#line 332
                  goto while_break___0;
                }
              } else {
#line 332
                goto while_break___0;
              }
            } else {
#line 332
              goto while_break___0;
            }
#line 335
            tmp___1 = p;
#line 335
            p ++;
#line 335
            *tmp___1 = (dfa->nodes + node)->opr.c;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 336
          memset((void *)(& state___0), '\000', sizeof(state___0));
#line 337
          tmp___2 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)((char const   *)(buf___1)),
                            (size_t )(p - buf___1), (mbstate_t */* __restrict  */)(& state___0));
          }
#line 337
          if (tmp___2 == (size_t )(p - buf___1)) {
            {
#line 337
            tmp___3 = towlower((wint_t )wc);
#line 337
            tmp___4 = wcrtomb((char */* __restrict  */)((char *)(buf___1)), (wchar_t )tmp___3,
                              (mbstate_t */* __restrict  */)(& state___0));
            }
#line 337
            if (tmp___4 != 0xffffffffffffffffUL) {
              {
#line 341
              re_set_fastmap(fastmap, (_Bool)0, (int )buf___1[0]);
              }
            }
          }
        }
      }
    } else
#line 345
    if ((unsigned int )type == 3U) {
#line 348
      i = 0;
#line 348
      ch = 0;
      {
#line 348
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 348
        if (! (i < 4)) {
#line 348
          goto while_break___1;
        }
#line 351
        w = *((dfa->nodes + node)->opr.sbcset + i);
#line 352
        j = 0;
        {
#line 352
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 352
          if (! (j < 64)) {
#line 352
            goto while_break___2;
          }
#line 353
          if (w & (1UL << j)) {
            {
#line 354
            re_set_fastmap(fastmap, icase, ch);
            }
          }
#line 352
          j ++;
#line 352
          ch ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 348
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 358
    if ((unsigned int )type == 6U) {
#line 360
      cset = (dfa->nodes + node)->opr.mbcset;
#line 385
      if (dfa->mb_cur_max > 1) {
#line 385
        if (cset->nchar_classes) {
#line 385
          goto _L___0;
        } else
#line 385
        if (cset->non_match) {
          _L___0: /* CIL Label */ 
#line 392
          c = (unsigned char)0;
          {
#line 393
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 396
            memset((void *)(& mbs), 0, sizeof(mbs));
#line 397
            tmp___5 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)((char *)(& c)),
                              (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
            }
#line 397
            if (tmp___5 == 0xfffffffffffffffeUL) {
              {
#line 398
              re_set_fastmap(fastmap, (_Bool)0, (int )c);
              }
            }
#line 393
            c = (unsigned char )((int )c + 1);
#line 393
            if (! ((int )c != 0)) {
#line 393
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 385
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 406
        i___0 = (Idx )0;
        {
#line 406
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 406
          if (! (i___0 < cset->nmbchars)) {
#line 406
            goto while_break___4;
          }
          {
#line 410
          memset((void *)(& state___1), '\000', sizeof(state___1));
#line 411
          tmp___6 = wcrtomb((char */* __restrict  */)(buf___2), *(cset->mbchars + i___0),
                            (mbstate_t */* __restrict  */)(& state___1));
          }
#line 411
          if (tmp___6 != 0xffffffffffffffffUL) {
            {
#line 412
            re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___2)));
            }
          }
#line 413
          if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 413
            if (dfa->mb_cur_max > 1) {
              {
#line 415
              tmp___7 = towlower((wint_t )*(cset->mbchars + i___0));
#line 415
              tmp___8 = wcrtomb((char */* __restrict  */)(buf___2), (wchar_t )tmp___7,
                                (mbstate_t */* __restrict  */)(& state___1));
              }
#line 415
              if (tmp___8 != 0xffffffffffffffffUL) {
                {
#line 417
                re_set_fastmap(fastmap, (_Bool)0, (int )*((unsigned char *)(buf___2)));
                }
              }
            }
          }
#line 406
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else
#line 423
    if ((unsigned int )type == 5U) {
#line 423
      goto _L___1;
    } else
#line 423
    if ((unsigned int )type == 7U) {
#line 423
      goto _L___1;
    } else
#line 423
    if ((unsigned int )type == 2U) {
      _L___1: /* CIL Label */ 
      {
#line 429
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
      }
#line 430
      if ((unsigned int )type == 2U) {
#line 431
        bufp->can_be_null = 1U;
      }
#line 432
      return;
    }
#line 314
    node_cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 473 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
#line 480
  if (cflags & 1) {
#line 480
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 480
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
#line 480
  syntax = tmp;
#line 483
  preg->buffer = (unsigned char *)((void *)0);
#line 484
  preg->allocated = (__re_long_size_t )0;
#line 485
  preg->used = (__re_long_size_t )0;
#line 488
  tmp___0 = malloc(256UL * sizeof(char ));
#line 488
  preg->fastmap = (char *)tmp___0;
#line 489
  tmp___1 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
  }
#line 489
  if (tmp___1) {
#line 490
    return (12);
  }
#line 492
  if (cflags & (1 << 1)) {
#line 492
    tmp___2 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 492
    tmp___2 = 0UL;
  }
#line 492
  syntax |= tmp___2;
#line 495
  if (cflags & (1 << 2)) {
#line 497
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 498
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 500
    preg->newline_anchor = 1U;
  } else {
#line 503
    preg->newline_anchor = 0U;
  }
  {
#line 504
  preg->no_sub = (unsigned int )(! (! (cflags & (1 << 3))));
#line 505
  preg->translate = (unsigned char *)((void *)0);
#line 507
  tmp___3 = strlen((char const   *)pattern);
#line 507
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, tmp___3, syntax);
  }
#line 511
  if ((int )ret == 16) {
#line 512
    ret = (reg_errcode_t )8;
  }
  {
#line 515
  tmp___4 = __builtin_expect((long )((int )ret == 0), 1L);
  }
#line 515
  if (tmp___4) {
    {
#line 518
    rpl_re_compile_fastmap((struct re_pattern_buffer *)preg);
    }
  } else {
    {
#line 522
    free((void *)preg->fastmap);
#line 523
    preg->fastmap = (char *)((void *)0);
    }
  }
#line 526
  return ((int )ret);
}
}
#line 543 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                    size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t cpy_size ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 551
  if (errcode < 0) {
#line 551
    tmp = 1;
  } else
#line 551
  if (errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
#line 551
    tmp = 1;
  } else {
#line 551
    tmp = 0;
  }
  {
#line 551
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 551
  if (tmp___0) {
    {
#line 558
    abort();
    }
  }
  {
#line 560
  tmp___1 = gettext(__re_error_msgid + __re_error_msgid_idx[errcode]);
#line 560
  msg = (char const   *)tmp___1;
#line 562
  tmp___2 = strlen(msg);
#line 562
  msg_size = tmp___2 + 1UL;
#line 564
  tmp___4 = __builtin_expect((long )(errbuf_size != 0UL), 1L);
  }
#line 564
  if (tmp___4) {
    {
#line 566
    cpy_size = msg_size;
#line 567
    tmp___3 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
    }
#line 567
    if (tmp___3) {
#line 569
      cpy_size = errbuf_size - 1UL;
#line 570
      *(errbuf + cpy_size) = (char )'\000';
    }
    {
#line 572
    memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
           cpy_size);
    }
  }
#line 575
  return (msg_size);
}
}
#line 587 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bitset_word_t utf8_sb_map[4]  = {      0xffffffffffffffffUL,      0xffffffffffffffffUL};
#line 607 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_dfa_content(re_dfa_t *dfa ) 
{ 
  Idx i ;
  Idx j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state___0 ;

  {
#line 612
  if (dfa->nodes) {
#line 613
    i = (Idx )0;
    {
#line 613
    while (1) {
      while_continue: /* CIL Label */ ;
#line 613
      if (! (i < dfa->nodes_len)) {
#line 613
        goto while_break;
      }
      {
#line 614
      free_token(dfa->nodes + i);
#line 613
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 615
  free((void *)dfa->nexts);
#line 616
  i = (Idx )0;
  }
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! (i < dfa->nodes_len)) {
#line 616
      goto while_break___0;
    }
#line 618
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
      {
#line 619
      free((void *)(dfa->eclosures + i)->elems);
      }
    }
#line 620
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
      {
#line 621
      free((void *)(dfa->inveclosures + i)->elems);
      }
    }
#line 622
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
      {
#line 623
      free((void *)(dfa->edests + i)->elems);
      }
    }
#line 616
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 625
  free((void *)dfa->edests);
#line 626
  free((void *)dfa->eclosures);
#line 627
  free((void *)dfa->inveclosures);
#line 628
  free((void *)dfa->nodes);
  }
#line 630
  if (dfa->state_table) {
#line 631
    i = (Idx )0;
    {
#line 631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 631
      if (! (i <= dfa->state_hash_mask)) {
#line 631
        goto while_break___1;
      }
#line 633
      entry = dfa->state_table + i;
#line 634
      j = (Idx )0;
      {
#line 634
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 634
        if (! (j < entry->num)) {
#line 634
          goto while_break___2;
        }
        {
#line 636
        state___0 = *(entry->array + j);
#line 637
        free_state(state___0);
#line 634
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 639
      free((void *)entry->array);
#line 631
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 641
  free((void *)dfa->state_table);
  }
#line 643
  if ((unsigned long )dfa->sb_char != (unsigned long )(utf8_sb_map)) {
    {
#line 644
    free((void *)dfa->sb_char);
    }
  }
  {
#line 646
  free((void *)dfa->subexp_map);
#line 651
  free((void *)dfa);
  }
#line 652
  return;
}
}
#line 657 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
void rpl_regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
  {
#line 661
  dfa = (re_dfa_t *)preg->buffer;
#line 662
  tmp = __builtin_expect((long )((unsigned long )dfa != (unsigned long )((void *)0)),
                         1L);
  }
#line 662
  if (tmp) {
    {
#line 663
    free_dfa_content(dfa);
    }
  }
  {
#line 664
  preg->buffer = (unsigned char *)((void *)0);
#line 665
  preg->allocated = (__re_long_size_t )0;
#line 667
  free((void *)preg->fastmap);
#line 668
  preg->fastmap = (char *)((void *)0);
#line 670
  free((void *)preg->translate);
#line 671
  preg->translate = (unsigned char *)((void *)0);
  }
#line 672
  return;
}
}
#line 750 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 754
  err = (reg_errcode_t )0;
#line 759
  preg->fastmap_accurate = 0U;
#line 760
  preg->syntax = syntax;
#line 761
  tmp = 0U;
#line 761
  preg->not_eol = tmp;
#line 761
  preg->not_bol = tmp;
#line 762
  preg->used = (__re_long_size_t )0;
#line 763
  preg->re_nsub = (size_t )0;
#line 764
  preg->can_be_null = 0U;
#line 765
  preg->regs_allocated = 0U;
#line 768
  dfa = (re_dfa_t *)preg->buffer;
#line 769
  tmp___1 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
  }
#line 769
  if (tmp___1) {
    {
#line 775
    tmp___0 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 775
    dfa = (re_dfa_t *)tmp___0;
    }
#line 776
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
#line 777
      return ((reg_errcode_t )12);
    }
#line 778
    preg->allocated = sizeof(re_dfa_t );
#line 779
    preg->buffer = (unsigned char *)dfa;
  }
  {
#line 781
  preg->used = sizeof(re_dfa_t );
#line 783
  err = init_dfa(dfa, length);
#line 784
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 784
  if (tmp___2) {
    {
#line 786
    free_dfa_content(dfa);
#line 787
    preg->buffer = (unsigned char *)((void *)0);
#line 788
    preg->allocated = (__re_long_size_t )0;
    }
#line 789
    return (err);
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 799
  err = re_string_construct(& regexp, pattern, length, preg->translate, (_Bool )((syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                            (re_dfa_t const   *)dfa);
#line 801
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 801
  if (tmp___3) {
    re_compile_internal_free_return: 
    {
#line 804
    free_workarea_compile(preg);
#line 805
    re_string_destruct(& regexp);
#line 806
    free_dfa_content(dfa);
#line 807
    preg->buffer = (unsigned char *)((void *)0);
#line 808
    preg->allocated = (__re_long_size_t )0;
    }
#line 809
    return (err);
  }
  {
#line 813
  preg->re_nsub = (size_t )0;
#line 814
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
#line 815
  tmp___4 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 815
  if (tmp___4) {
#line 816
    goto re_compile_internal_free_return;
  }
  {
#line 819
  err = analyze(preg);
#line 820
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 820
  if (tmp___5) {
#line 821
    goto re_compile_internal_free_return;
  }
#line 825
  if (dfa->is_utf8) {
#line 825
    if (! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 825
      if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
        {
#line 826
        optimize_utf8(dfa);
        }
      }
    }
  }
  {
#line 830
  err = create_initial_state(dfa);
#line 833
  free_workarea_compile(preg);
#line 834
  re_string_destruct(& regexp);
#line 836
  tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 836
  if (tmp___6) {
    {
#line 838
    free_dfa_content(dfa);
#line 839
    preg->buffer = (unsigned char *)((void *)0);
#line 840
    preg->allocated = (__re_long_size_t )0;
    }
  }
#line 843
  return (err);
}
}
#line 849 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) 
{ 
  __re_size_t table_size ;
  size_t max_i18n_object_size ;
  unsigned long tmp ;
  size_t max_object_size ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  long tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  size_t tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int i ;
  int j ;
  int ch ;
  void *tmp___46 ;
  long tmp___47 ;
  wint_t wch ;
  wint_t tmp___48 ;
  int tmp___49 ;
  long tmp___50 ;

  {
#line 854
  if (sizeof(wchar_t ) < sizeof(wctype_t )) {
#line 854
    tmp = sizeof(wctype_t );
  } else {
#line 854
    tmp = sizeof(wchar_t );
  }
#line 854
  max_i18n_object_size = tmp;
#line 858
  if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
    tmp___39 = max_i18n_object_size;
  } else {
#line 858
    tmp___39 = sizeof(regmatch_t );
  }
#line 858
  if (sizeof(re_node_set ) < tmp___39) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___37 = max_i18n_object_size;
    } else {
#line 858
      tmp___37 = sizeof(regmatch_t );
    }
#line 858
    tmp___38 = tmp___37;
  } else {
#line 858
    tmp___38 = sizeof(re_node_set );
  }
#line 858
  if (sizeof(re_token_t ) < tmp___38) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___34 = max_i18n_object_size;
    } else {
#line 858
      tmp___34 = sizeof(regmatch_t );
    }
#line 858
    if (sizeof(re_node_set ) < tmp___34) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___32 = max_i18n_object_size;
      } else {
#line 858
        tmp___32 = sizeof(regmatch_t );
      }
#line 858
      tmp___33 = tmp___32;
    } else {
#line 858
      tmp___33 = sizeof(re_node_set );
    }
#line 858
    tmp___35 = tmp___33;
  } else {
#line 858
    tmp___35 = sizeof(re_token_t );
  }
#line 858
  if (sizeof(struct re_state_table_entry ) < tmp___35) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___25 = max_i18n_object_size;
    } else {
#line 858
      tmp___25 = sizeof(regmatch_t );
    }
#line 858
    if (sizeof(re_node_set ) < tmp___25) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___23 = max_i18n_object_size;
      } else {
#line 858
        tmp___23 = sizeof(regmatch_t );
      }
#line 858
      tmp___24 = tmp___23;
    } else {
#line 858
      tmp___24 = sizeof(re_node_set );
    }
#line 858
    if (sizeof(re_token_t ) < tmp___24) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___20 = max_i18n_object_size;
      } else {
#line 858
        tmp___20 = sizeof(regmatch_t );
      }
#line 858
      if (sizeof(re_node_set ) < tmp___20) {
#line 858
        if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
          tmp___18 = max_i18n_object_size;
        } else {
#line 858
          tmp___18 = sizeof(regmatch_t );
        }
#line 858
        tmp___19 = tmp___18;
      } else {
#line 858
        tmp___19 = sizeof(re_node_set );
      }
#line 858
      tmp___21 = tmp___19;
    } else {
#line 858
      tmp___21 = sizeof(re_token_t );
    }
#line 858
    tmp___26 = tmp___21;
  } else {
#line 858
    tmp___26 = sizeof(struct re_state_table_entry );
  }
  {
#line 858
  max_object_size = tmp___26;
#line 865
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
#line 868
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 874
  tmp___40 = __builtin_expect((long )((0xffffffffffffffffUL / max_object_size) / 2UL <= pat_len),
                              0L);
  }
#line 874
  if (tmp___40) {
#line 875
    return ((reg_errcode_t )12);
  }
  {
#line 877
  dfa->nodes_alloc = pat_len + 1UL;
#line 878
  tmp___41 = malloc(dfa->nodes_alloc * sizeof(re_token_t ));
#line 878
  dfa->nodes = (re_token_t *)tmp___41;
#line 881
  table_size = (__re_size_t )1;
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (table_size > pat_len) {
#line 883
      goto while_break;
    }
#line 881
    table_size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  tmp___42 = calloc(sizeof(struct re_state_table_entry ), table_size);
#line 885
  dfa->state_table = (struct re_state_table_entry *)tmp___42;
#line 886
  dfa->state_hash_mask = table_size - 1UL;
#line 888
  tmp___43 = __ctype_get_mb_cur_max();
#line 888
  dfa->mb_cur_max = (int )tmp___43;
#line 896
  tmp___44 = locale_charset();
#line 896
  tmp___45 = strcmp(tmp___44, "UTF-8");
  }
#line 896
  if (tmp___45 == 0) {
#line 897
    dfa->is_utf8 = 1U;
  }
#line 901
  dfa->map_notascii = 0U;
#line 905
  if (dfa->mb_cur_max > 1) {
#line 907
    if (dfa->is_utf8) {
#line 908
      dfa->sb_char = (re_bitset_ptr_t )(utf8_sb_map);
    } else {
      {
#line 913
      tmp___46 = calloc(sizeof(bitset_t ), (size_t )1);
#line 913
      dfa->sb_char = (re_bitset_ptr_t )tmp___46;
#line 914
      tmp___47 = __builtin_expect((long )((unsigned long )dfa->sb_char == (unsigned long )((void *)0)),
                                  0L);
      }
#line 914
      if (tmp___47) {
#line 915
        return ((reg_errcode_t )12);
      }
#line 918
      i = 0;
#line 918
      ch = 0;
      {
#line 918
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 918
        if (! (i < 4)) {
#line 918
          goto while_break___0;
        }
#line 919
        j = 0;
        {
#line 919
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 919
          if (! (j < 64)) {
#line 919
            goto while_break___1;
          }
          {
#line 921
          tmp___48 = btowc(ch);
#line 921
          wch = tmp___48;
          }
#line 922
          if (wch != 4294967295U) {
#line 923
            *(dfa->sb_char + i) |= 1UL << j;
          }
#line 925
          if ((ch & -128) == 0) {
#line 925
            if (wch != (wint_t )ch) {
#line 926
              dfa->map_notascii = 1U;
            }
          }
#line 919
          j ++;
#line 919
          ch ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 918
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 933
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
#line 933
    tmp___49 = 1;
  } else
#line 933
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
#line 933
    tmp___49 = 1;
  } else {
#line 933
    tmp___49 = 0;
  }
  {
#line 933
  tmp___50 = __builtin_expect((long )tmp___49, 0L);
  }
#line 933
  if (tmp___50) {
#line 934
    return ((reg_errcode_t )12);
  }
#line 935
  return ((reg_errcode_t )0);
}
}
#line 942 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void init_word_char(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  unsigned short const   **tmp ;

  {
#line 947
  dfa->word_ops_used = 1U;
#line 948
  i = 0;
#line 948
  ch = 0;
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (i < 4)) {
#line 948
      goto while_break;
    }
#line 949
    j = 0;
    {
#line 949
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 949
      if (! (j < 64)) {
#line 949
        goto while_break___0;
      }
      {
#line 950
      tmp = __ctype_b_loc();
      }
#line 950
      if ((int const   )*(*tmp + ch) & 8) {
#line 951
        dfa->word_char[i] |= 1UL << j;
      } else
#line 950
      if (ch == 95) {
#line 951
        dfa->word_char[i] |= 1UL << j;
      }
#line 949
      j ++;
#line 949
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  return;
}
}
#line 956 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 959
  dfa = (re_dfa_t *)preg->buffer;
#line 961
  storage = dfa->str_tree_storage;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! storage) {
#line 961
      goto while_break;
    }
    {
#line 963
    next = storage->next;
#line 964
    free((void *)storage);
#line 961
    storage = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 966
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 967
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 968
  dfa->str_tree = (bin_tree_t *)((void *)0);
#line 969
  free((void *)dfa->org_indices);
#line 970
  dfa->org_indices = (Idx *)((void *)0);
  }
#line 971
  return;
}
}
#line 975 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ 
  Idx first ;
  Idx i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  Idx node_idx ;
  re_token_type_t type ;
  Idx clexp_idx ;
  re_token_t *clexp_node ;
  Idx dest_idx ;
  Idx __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_dfastate_t *tmp___4 ;
  re_dfastate_t *tmp___5 ;

  {
  {
#line 984
  first = ((dfa->str_tree)->first)->node_idx;
#line 985
  dfa->init_node = first;
#line 986
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
#line 987
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 987
  if (tmp) {
#line 988
    return (err);
  }
#line 994
  if (dfa->nbackref > 0UL) {
#line 995
    i = (Idx )0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < init_nodes.nelem)) {
#line 995
        goto while_break;
      }
#line 997
      node_idx = *(init_nodes.elems + i);
#line 998
      type = (dfa->nodes + node_idx)->type;
#line 1001
      if ((unsigned int )type != 4U) {
#line 1002
        goto __Cont;
      }
#line 1003
      clexp_idx = (Idx )0;
      {
#line 1003
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1003
        if (! (clexp_idx < init_nodes.nelem)) {
#line 1003
          goto while_break___0;
        }
#line 1006
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 1007
        if ((unsigned int )clexp_node->type == 9U) {
#line 1007
          if (clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
#line 1009
            goto while_break___0;
          }
        }
#line 1003
        clexp_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1011
      if (clexp_idx == init_nodes.nelem) {
#line 1012
        goto __Cont;
      }
#line 1014
      if ((unsigned int )type == 4U) {
        {
#line 1016
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
#line 1017
        tmp___0 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
        }
#line 1017
        if (! tmp___0) {
          {
#line 1019
          re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
#line 1020
          i = (Idx )0;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 995
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1026
  dfa->init_state = re_acquire_state_context(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
#line 1028
  tmp___1 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1028
  if (tmp___1) {
#line 1029
    return (err);
  }
#line 1030
  if ((dfa->init_state)->has_constraint) {
    {
#line 1032
    dfa->init_state_word = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                    (re_node_set const   *)(& init_nodes),
                                                    1U);
#line 1034
    dfa->init_state_nl = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                  (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
#line 1036
    dfa->init_state_begbuf = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
#line 1040
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else
#line 1040
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else
#line 1040
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else {
#line 1040
      tmp___2 = 0;
    }
    {
#line 1040
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    }
#line 1040
    if (tmp___3) {
#line 1042
      return (err);
    }
  } else {
#line 1045
    tmp___5 = dfa->init_state;
#line 1045
    dfa->init_state_begbuf = tmp___5;
#line 1045
    tmp___4 = tmp___5;
#line 1045
    dfa->init_state_nl = tmp___4;
#line 1045
    dfa->init_state_word = tmp___4;
  }
  {
#line 1048
  free((void *)init_nodes.elems);
  }
#line 1049
  return ((reg_errcode_t )0);
}
}
#line 1057 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void optimize_utf8(re_dfa_t *dfa ) 
{ 
  Idx node ;
  int i ;
  _Bool mb_chars ;
  _Bool has_period ;
  int rshift ;
  int tmp ;

  {
#line 1062
  mb_chars = (_Bool)0;
#line 1063
  has_period = (_Bool)0;
#line 1065
  node = (Idx )0;
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if (! (node < dfa->nodes_len)) {
#line 1065
      goto while_break;
    }
    {
#line 1068
    if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1068
      goto case_1;
    }
#line 1072
    if ((unsigned int )(dfa->nodes + node)->type == 12U) {
#line 1072
      goto case_12;
    }
#line 1087
    if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1087
      goto case_5;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 11U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 2U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 10U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1095
      goto case_9;
    }
#line 1097
    if ((unsigned int )(dfa->nodes + node)->type == 6U) {
#line 1097
      goto case_6;
    }
#line 1099
    if ((unsigned int )(dfa->nodes + node)->type == 3U) {
#line 1099
      goto case_3;
    }
#line 1113
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 1069
    if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1070
      mb_chars = (_Bool)1;
    }
#line 1071
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 128U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 64U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 32U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 16U) {
#line 1078
      goto case_128;
    }
#line 1080
    goto switch_default;
    case_128: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 1079
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1084
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 1086
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1088
    has_period = (_Bool)1;
#line 1089
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1096
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1098
    return;
    case_3: /* CIL Label */ 
#line 1102
    rshift = 0;
#line 1105
    i = 2;
    {
#line 1105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1105
      if (! (i < 4)) {
#line 1105
        goto while_break___0;
      }
#line 1107
      if (*((dfa->nodes + node)->opr.sbcset + i) >> rshift != 0UL) {
#line 1108
        return;
      }
#line 1109
      rshift = 0;
#line 1105
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1112
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1114
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1065
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  if (mb_chars) {
#line 1117
    goto _L___0;
  } else
#line 1117
  if (has_period) {
    _L___0: /* CIL Label */ 
#line 1118
    node = (Idx )0;
    {
#line 1118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1118
      if (! (node < dfa->nodes_len)) {
#line 1118
        goto while_break___1;
      }
#line 1120
      if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1120
        if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1122
          (dfa->nodes + node)->mb_partial = 0U;
        } else {
#line 1120
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1123
      if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1124
        (dfa->nodes + node)->type = (re_token_type_t )7;
      }
#line 1118
      node ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1128
  dfa->mb_cur_max = 1;
#line 1129
  dfa->is_utf8 = 0U;
#line 1130
  if (dfa->nbackref > 0UL) {
#line 1130
    tmp = 1;
  } else
#line 1130
  if (has_period) {
#line 1130
    tmp = 1;
  } else {
#line 1130
    tmp = 0;
  }
#line 1130
  dfa->has_mb_node = (unsigned int )tmp;
#line 1131
  return;
}
}
#line 1137 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t analyze(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  Idx i ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;

  {
  {
#line 1140
  dfa = (re_dfa_t *)preg->buffer;
#line 1144
  tmp = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1144
  dfa->nexts = (Idx *)tmp;
#line 1145
  tmp___0 = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1145
  dfa->org_indices = (Idx *)tmp___0;
#line 1146
  tmp___1 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1146
  dfa->edests = (re_node_set *)tmp___1;
#line 1147
  tmp___2 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1147
  dfa->eclosures = (re_node_set *)tmp___2;
  }
#line 1148
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else {
#line 1148
    tmp___3 = 0;
  }
  {
#line 1148
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 1148
  if (tmp___4) {
#line 1150
    return ((reg_errcode_t )12);
  }
  {
#line 1152
  tmp___5 = malloc(preg->re_nsub * sizeof(Idx ));
#line 1152
  dfa->subexp_map = (Idx *)tmp___5;
  }
#line 1153
  if ((unsigned long )dfa->subexp_map != (unsigned long )((void *)0)) {
#line 1156
    i = (Idx )0;
    {
#line 1156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1156
      if (! (i < preg->re_nsub)) {
#line 1156
        goto while_break;
      }
#line 1157
      *(dfa->subexp_map + i) = i;
#line 1156
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1158
    preorder(dfa->str_tree, & optimize_subexps, (void *)dfa);
#line 1159
    i = (Idx )0;
    }
    {
#line 1159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1159
      if (! (i < preg->re_nsub)) {
#line 1159
        goto while_break___0;
      }
#line 1160
      if (*(dfa->subexp_map + i) != i) {
#line 1161
        goto while_break___0;
      }
#line 1159
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1162
    if (i == preg->re_nsub) {
      {
#line 1164
      free((void *)dfa->subexp_map);
#line 1165
      dfa->subexp_map = (Idx *)((void *)0);
      }
    }
  }
  {
#line 1169
  ret = postorder(dfa->str_tree, & lower_subexps, (void *)preg);
#line 1170
  tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1170
  if (tmp___6) {
#line 1171
    return (ret);
  }
  {
#line 1172
  ret = postorder(dfa->str_tree, & calc_first, (void *)dfa);
#line 1173
  tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1173
  if (tmp___7) {
#line 1174
    return (ret);
  }
  {
#line 1175
  preorder(dfa->str_tree, & calc_next, (void *)dfa);
#line 1176
  ret = preorder(dfa->str_tree, & link_nfa_nodes, (void *)dfa);
#line 1177
  tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1177
  if (tmp___8) {
#line 1178
    return (ret);
  }
  {
#line 1179
  ret = calc_eclosure(dfa);
#line 1180
  tmp___9 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1180
  if (tmp___9) {
#line 1181
    return (ret);
  }
#line 1185
  if (! preg->no_sub) {
#line 1185
    if (preg->re_nsub > 0UL) {
#line 1185
      if (dfa->has_plural_match) {
#line 1185
        goto _L;
      } else {
#line 1185
        goto _L___1;
      }
    } else {
#line 1185
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1185
  if (dfa->nbackref) {
    _L: /* CIL Label */ 
    {
#line 1188
    tmp___10 = malloc(dfa->nodes_len * sizeof(re_node_set ));
#line 1188
    dfa->inveclosures = (re_node_set *)tmp___10;
#line 1189
    tmp___11 = __builtin_expect((long )((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)),
                                0L);
    }
#line 1189
    if (tmp___11) {
#line 1190
      return ((reg_errcode_t )12);
    }
    {
#line 1191
    ret = calc_inveclosure(dfa);
    }
  }
#line 1194
  return (ret);
}
}
#line 1200 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;

  {
#line 1206
  node = root;
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1210
      if (! node->left) {
#line 1210
        if (! node->right) {
#line 1210
          goto while_break___0;
        }
      }
#line 1211
      if (node->left) {
#line 1212
        node = node->left;
      } else {
#line 1214
        node = node->right;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1216
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1218
      tmp = (*fn)(extra, node);
#line 1218
      err = tmp;
#line 1219
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1219
      if (tmp___0) {
#line 1220
        return (err);
      }
#line 1221
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 1222
        return ((reg_errcode_t )0);
      }
#line 1223
      prev = node;
#line 1224
      node = node->parent;
#line 1216
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1216
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1216
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1228
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1232 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  bin_tree_t *prev ;

  {
#line 1238
  node = root;
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1240
    tmp = (*fn)(extra, node);
#line 1240
    err = tmp;
#line 1241
    tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1241
    if (tmp___0) {
#line 1242
      return (err);
    }
#line 1245
    if (node->left) {
#line 1246
      node = node->left;
    } else {
#line 1249
      prev = (bin_tree_t *)((void *)0);
      {
#line 1250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1250
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1250
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1250
            goto while_break___0;
          }
        }
#line 1252
        prev = node;
#line 1253
        node = node->parent;
#line 1254
        if (! node) {
#line 1255
          return ((reg_errcode_t )0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1257
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1265 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  Idx other_idx ;

  {
#line 1268
  dfa = (re_dfa_t *)extra;
#line 1270
  if ((unsigned int )node->token.type == 4U) {
#line 1270
    if (dfa->subexp_map) {
#line 1272
      idx = (int )node->token.opr.idx;
#line 1273
      node->token.opr.idx = *(dfa->subexp_map + idx);
#line 1274
      dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
#line 1270
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1277
  if ((unsigned int )node->token.type == 17U) {
#line 1277
    if (node->left) {
#line 1277
      if ((unsigned int )(node->left)->token.type == 17U) {
#line 1280
        other_idx = (node->left)->token.opr.idx;
#line 1282
        node->left = (node->left)->left;
#line 1283
        if (node->left) {
#line 1284
          (node->left)->parent = node;
        }
#line 1286
        *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
#line 1287
        if (other_idx < 64UL) {
#line 1288
          dfa->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
#line 1291
  return ((reg_errcode_t )0);
}
}
#line 1296 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err ;

  {
#line 1299
  preg = (regex_t *)extra;
#line 1300
  err = (reg_errcode_t )0;
#line 1302
  if (node->left) {
#line 1302
    if ((unsigned int )(node->left)->token.type == 17U) {
      {
#line 1304
      node->left = lower_subexp(& err, preg, node->left);
      }
#line 1305
      if (node->left) {
#line 1306
        (node->left)->parent = node;
      }
    }
  }
#line 1308
  if (node->right) {
#line 1308
    if ((unsigned int )(node->right)->token.type == 17U) {
      {
#line 1310
      node->right = lower_subexp(& err, preg, node->right);
      }
#line 1311
      if (node->right) {
#line 1312
        (node->right)->parent = node;
      }
    }
  }
#line 1315
  return (err);
}
}
#line 1318 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1321
  dfa = (re_dfa_t *)preg->buffer;
#line 1322
  body = node->left;
#line 1325
  if (preg->no_sub) {
#line 1325
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1325
      if (node->token.opr.idx >= 64UL) {
#line 1334
        return (node->left);
      } else
#line 1325
      if (! (dfa->used_bkref_map & (1UL << node->token.opr.idx))) {
#line 1334
        return (node->left);
      }
    }
  }
  {
#line 1338
  op = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )8);
#line 1339
  cls = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )9);
  }
#line 1340
  if (body) {
    {
#line 1340
    tmp = create_tree(dfa, body, cls, (re_token_type_t )16);
#line 1340
    tree1 = tmp;
    }
  } else {
#line 1340
    tree1 = cls;
  }
  {
#line 1341
  tree = create_tree(dfa, op, tree1, (re_token_type_t )16);
  }
#line 1342
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else {
#line 1342
    tmp___0 = 0;
  }
  {
#line 1342
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1342
  if (tmp___1) {
#line 1344
    *err = (reg_errcode_t )12;
#line 1345
    return ((bin_tree_t *)((void *)0));
  }
#line 1348
  tmp___2 = node->token.opr.idx;
#line 1348
  cls->token.opr.idx = tmp___2;
#line 1348
  op->token.opr.idx = tmp___2;
#line 1349
  tmp___3 = node->token.opt_subexp;
#line 1349
  cls->token.opt_subexp = tmp___3;
#line 1349
  op->token.opt_subexp = tmp___3;
#line 1350
  return (tree);
}
}
#line 1355 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
#line 1358
  dfa = (re_dfa_t *)extra;
#line 1359
  if ((unsigned int )node->token.type == 16U) {
#line 1361
    node->first = (node->left)->first;
#line 1362
    node->node_idx = (node->left)->node_idx;
  } else {
    {
#line 1366
    node->first = node;
#line 1367
    node->node_idx = re_dfa_add_node(dfa, node->token);
#line 1368
    tmp = __builtin_expect((long )(node->node_idx == 0xffffffffffffffffUL), 0L);
    }
#line 1368
    if (tmp) {
#line 1369
      return ((reg_errcode_t )12);
    }
#line 1370
    if ((unsigned int )node->token.type == 12U) {
#line 1371
      (dfa->nodes + node->node_idx)->constraint = (unsigned int )node->token.opr.ctx_type;
    }
  }
#line 1373
  return ((reg_errcode_t )0);
}
}
#line 1377 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 1382
  if ((unsigned int )node->token.type == 11U) {
#line 1382
    goto case_11;
  }
#line 1385
  if ((unsigned int )node->token.type == 16U) {
#line 1385
    goto case_16;
  }
#line 1389
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1383
  (node->left)->next = node;
#line 1384
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1386
  (node->left)->next = (node->right)->first;
#line 1387
  (node->right)->next = node->next;
#line 1388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1390
  if (node->left) {
#line 1391
    (node->left)->next = node->next;
  }
#line 1392
  if (node->right) {
#line 1393
    (node->right)->next = node->next;
  }
#line 1394
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1396
  return ((reg_errcode_t )0);
}
}
#line 1400 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  Idx idx ;
  reg_errcode_t err ;
  Idx left ;
  Idx right ;

  {
#line 1403
  dfa = (re_dfa_t *)extra;
#line 1404
  idx = node->node_idx;
#line 1405
  err = (reg_errcode_t )0;
  {
#line 1409
  if ((unsigned int )node->token.type == 16U) {
#line 1409
    goto case_16;
  }
#line 1412
  if ((unsigned int )node->token.type == 2U) {
#line 1412
    goto case_2;
  }
#line 1417
  if ((unsigned int )node->token.type == 10U) {
#line 1417
    goto case_10;
  }
#line 1417
  if ((unsigned int )node->token.type == 11U) {
#line 1417
    goto case_10;
  }
#line 1437
  if ((unsigned int )node->token.type == 9U) {
#line 1437
    goto case_9;
  }
#line 1437
  if ((unsigned int )node->token.type == 8U) {
#line 1437
    goto case_9;
  }
#line 1437
  if ((unsigned int )node->token.type == 12U) {
#line 1437
    goto case_9;
  }
#line 1441
  if ((unsigned int )node->token.type == 4U) {
#line 1441
    goto case_4;
  }
#line 1447
  goto switch_default;
  case_16: /* CIL Label */ 
#line 1410
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1413
  if (! ((unsigned long )node->next == (unsigned long )((void *)0))) {
    {
#line 1413
    __assert_fail("node->next == NULL", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1413U, "link_nfa_nodes");
    }
  }
#line 1414
  goto switch_break;
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 1420
  dfa->has_plural_match = 1U;
#line 1421
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1422
    left = ((node->left)->first)->node_idx;
  } else {
#line 1424
    left = (node->next)->node_idx;
  }
#line 1425
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1426
    right = ((node->right)->first)->node_idx;
  } else {
#line 1428
    right = (node->next)->node_idx;
  }
#line 1429
  if (! (left < 0xfffffffffffffffeUL)) {
    {
#line 1429
    __assert_fail("REG_VALID_INDEX (left)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1429U, "link_nfa_nodes");
    }
  }
#line 1430
  if (! (right < 0xfffffffffffffffeUL)) {
    {
#line 1430
    __assert_fail("REG_VALID_INDEX (right)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1430U, "link_nfa_nodes");
    }
  }
  {
#line 1431
  err = re_node_set_init_2(dfa->edests + idx, left, right);
  }
#line 1433
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 1438
  err = re_node_set_init_1(dfa->edests + idx, (node->next)->node_idx);
  }
#line 1439
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1442
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1443
  if ((unsigned int )node->token.type == 4U) {
    {
#line 1444
    re_node_set_init_1(dfa->edests + idx, *(dfa->nexts + idx));
    }
  }
#line 1445
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1448
  if (! (! ((unsigned int )node->token.type & 8U))) {
    {
#line 1448
    __assert_fail("!IS_EPSILON_NODE (node->token.type)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1448U, "link_nfa_nodes");
    }
  }
#line 1449
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1450
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1453
  return (err);
}
}
#line 1460 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , Idx top_org_node , Idx top_clone_node ,
                                            Idx root_node , unsigned int init_constraint ) 
{ 
  Idx org_node ;
  Idx clone_node ;
  _Bool ok ;
  unsigned int constraint ;
  Idx org_dest ;
  Idx clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  reg_errcode_t err ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 1467
  constraint = init_constraint;
#line 1468
  org_node = top_org_node;
#line 1468
  clone_node = top_clone_node;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1471
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
      {
#line 1477
      org_dest = *(dfa->nexts + org_node);
#line 1478
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1479
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1480
      tmp = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1480
      if (tmp) {
#line 1481
        return ((reg_errcode_t )12);
      }
      {
#line 1482
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1483
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1484
      tmp___0 = __builtin_expect((long )(! ok), 0L);
      }
#line 1484
      if (tmp___0) {
#line 1485
        return ((reg_errcode_t )12);
      }
    } else
#line 1487
    if ((dfa->edests + org_node)->nelem == 0UL) {
#line 1492
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1493
      goto while_break;
    } else
#line 1495
    if ((dfa->edests + org_node)->nelem == 1UL) {
      {
#line 1499
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1500
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1501
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
      }
#line 1504
      if (org_node == root_node) {
#line 1504
        if (clone_node != org_node) {
          {
#line 1506
          ok = re_node_set_insert(dfa->edests + clone_node, org_dest);
#line 1507
          tmp___1 = __builtin_expect((long )(! ok), 0L);
          }
#line 1507
          if (tmp___1) {
#line 1508
            return ((reg_errcode_t )12);
          }
#line 1509
          goto while_break;
        }
      }
      {
#line 1512
      constraint |= (dfa->nodes + org_node)->constraint;
#line 1513
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1514
      tmp___2 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1514
      if (tmp___2) {
#line 1515
        return ((reg_errcode_t )12);
      }
      {
#line 1516
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1517
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 1517
      if (tmp___3) {
#line 1518
        return ((reg_errcode_t )12);
      }
    } else {
      {
#line 1524
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1525
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1527
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
      }
#line 1528
      if (clone_dest == 0xffffffffffffffffUL) {
        {
#line 1532
        clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1533
        tmp___4 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
        }
#line 1533
        if (tmp___4) {
#line 1534
          return ((reg_errcode_t )12);
        }
        {
#line 1535
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1536
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1536
        if (tmp___5) {
#line 1537
          return ((reg_errcode_t )12);
        }
        {
#line 1538
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
#line 1540
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1540
        if (tmp___6) {
#line 1541
          return (err);
        }
      } else {
        {
#line 1547
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1548
        tmp___7 = __builtin_expect((long )(! ok), 0L);
        }
#line 1548
        if (tmp___7) {
#line 1549
          return ((reg_errcode_t )12);
        }
      }
      {
#line 1552
      org_dest = *((dfa->edests + org_node)->elems + 1);
#line 1553
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1554
      tmp___8 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1554
      if (tmp___8) {
#line 1555
        return ((reg_errcode_t )12);
      }
      {
#line 1556
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1557
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 1557
      if (tmp___9) {
#line 1558
        return ((reg_errcode_t )12);
      }
    }
#line 1560
    org_node = org_dest;
#line 1561
    clone_node = clone_dest;
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  return ((reg_errcode_t )0);
}
}
#line 1569 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) 
{ 
  Idx idx ;

  {
#line 1574
  idx = (Idx )(dfa->nodes_len - 1UL);
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if ((dfa->nodes + idx)->duplicated) {
#line 1574
      if (! (idx > 0UL)) {
#line 1574
        goto while_break;
      }
    } else {
#line 1574
      goto while_break;
    }
#line 1576
    if (org_node == *(dfa->org_indices + idx)) {
#line 1576
      if (constraint == (dfa->nodes + idx)->constraint) {
#line 1578
        return (idx);
      }
    }
#line 1574
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1580
  return ((Idx )-1);
}
}
#line 1587 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) 
{ 
  Idx dup_idx ;
  Idx tmp ;
  long tmp___0 ;

  {
  {
#line 1590
  tmp = re_dfa_add_node(dfa, *(dfa->nodes + org_idx));
#line 1590
  dup_idx = tmp;
#line 1591
  tmp___0 = __builtin_expect((long )(dup_idx != 0xffffffffffffffffUL), 1L);
  }
#line 1591
  if (tmp___0) {
#line 1593
    (dfa->nodes + dup_idx)->constraint = constraint;
#line 1594
    (dfa->nodes + dup_idx)->constraint |= (dfa->nodes + org_idx)->constraint;
#line 1595
    (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1598
    *(dfa->org_indices + dup_idx) = org_idx;
  }
#line 1600
  return (dup_idx);
}
}
#line 1603 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) 
{ 
  Idx src ;
  Idx idx ;
  _Bool ok ;
  Idx *elems ;
  long tmp ;

  {
#line 1608
  idx = (Idx )0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (idx < dfa->nodes_len)) {
#line 1608
      goto while_break;
    }
    {
#line 1609
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
#line 1608
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  src = (Idx )0;
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (! (src < dfa->nodes_len)) {
#line 1611
      goto while_break___0;
    }
#line 1613
    elems = (dfa->eclosures + src)->elems;
#line 1614
    idx = (Idx )0;
    {
#line 1614
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1614
      if (! (idx < (dfa->eclosures + src)->nelem)) {
#line 1614
        goto while_break___1;
      }
      {
#line 1616
      ok = re_node_set_insert_last(dfa->inveclosures + *(elems + idx), src);
#line 1617
      tmp = __builtin_expect((long )(! ok), 0L);
      }
#line 1617
      if (tmp) {
#line 1618
        return ((reg_errcode_t )12);
      }
#line 1614
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1611
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1622
  return ((reg_errcode_t )0);
}
}
#line 1627 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ 
  Idx node_idx ;
  _Bool incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
#line 1635
  incomplete = (_Bool)0;
#line 1637
  node_idx = (Idx )0;
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (node_idx == dfa->nodes_len) {
#line 1643
      if (! incomplete) {
#line 1644
        goto while_break;
      }
#line 1645
      incomplete = (_Bool)0;
#line 1646
      node_idx = (Idx )0;
    }
#line 1654
    if ((dfa->eclosures + node_idx)->nelem != 0UL) {
#line 1655
      goto __Cont;
    }
    {
#line 1657
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, (_Bool)1);
#line 1658
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1658
    if (tmp) {
#line 1659
      return (err);
    }
#line 1661
    if ((dfa->eclosures + node_idx)->nelem == 0UL) {
      {
#line 1663
      incomplete = (_Bool)1;
#line 1664
      free((void *)eclosure_elem.elems);
      }
    }
    __Cont: /* CIL Label */ 
#line 1637
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1667
  return ((reg_errcode_t )0);
}
}
#line 1672 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  _Bool incomplete ;
  _Bool ok ;
  re_node_set eclosure ;
  long tmp ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  Idx edest ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1680
  incomplete = (_Bool)0;
#line 1681
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1UL);
#line 1682
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1682
  if (tmp) {
#line 1683
    return (err);
  }
#line 1687
  (dfa->eclosures + node)->nelem = (Idx )-1;
#line 1691
  if ((dfa->nodes + node)->constraint) {
#line 1691
    if ((dfa->edests + node)->nelem) {
#line 1691
      if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
        {
#line 1695
        err = duplicate_node_closure(dfa, node, node, node, (dfa->nodes + node)->constraint);
#line 1697
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1697
        if (tmp___0) {
#line 1698
          return (err);
        }
      }
    }
  }
#line 1702
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1703
    i = (Idx )0;
    {
#line 1703
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1703
      if (! (i < (dfa->edests + node)->nelem)) {
#line 1703
        goto while_break;
      }
#line 1706
      edest = *((dfa->edests + node)->elems + i);
#line 1709
      if ((dfa->eclosures + edest)->nelem == 0xffffffffffffffffUL) {
#line 1711
        incomplete = (_Bool)1;
#line 1712
        goto __Cont;
      }
#line 1716
      if ((dfa->eclosures + edest)->nelem == 0UL) {
        {
#line 1718
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, (_Bool)0);
#line 1719
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1719
        if (tmp___1) {
#line 1720
          return (err);
        }
      } else {
#line 1723
        eclosure_elem = *(dfa->eclosures + edest);
      }
      {
#line 1725
      re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
      }
#line 1728
      if ((dfa->eclosures + edest)->nelem == 0UL) {
        {
#line 1730
        incomplete = (_Bool)1;
#line 1731
        free((void *)eclosure_elem.elems);
        }
      }
      __Cont: /* CIL Label */ 
#line 1703
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1736
  ok = re_node_set_insert(& eclosure, node);
#line 1737
  tmp___2 = __builtin_expect((long )(! ok), 0L);
  }
#line 1737
  if (tmp___2) {
#line 1738
    return ((reg_errcode_t )12);
  }
#line 1739
  if (incomplete) {
#line 1739
    if (! root) {
#line 1740
      (dfa->eclosures + node)->nelem = (Idx )0;
    } else {
#line 1742
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
#line 1742
    *(dfa->eclosures + node) = eclosure;
  }
#line 1743
  *new_set = eclosure;
#line 1744
  return ((reg_errcode_t )0);
}
}
#line 1752 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp ;

  {
  {
#line 1756
  tmp = peek_token(result, input, syntax);
#line 1756
  input->cur_idx += (Idx )tmp;
  }
#line 1757
  return;
}
}
#line 1762 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp ;
  wint_t wc ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  wint_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char prev ;
  re_token_t next ;

  {
#line 1768
  if (input->stop <= input->cur_idx) {
#line 1770
    token->type = (re_token_type_t )2;
#line 1771
    return (0);
  }
#line 1774
  c = *(input->mbs + input->cur_idx);
#line 1775
  token->opr.c = c;
#line 1777
  token->word_char = 0U;
#line 1779
  token->mb_partial = 0U;
#line 1780
  if (input->mb_cur_max > 1) {
#line 1780
    if (! (input->cur_idx == input->valid_len)) {
#line 1780
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1783
        token->type = (re_token_type_t )1;
#line 1784
        token->mb_partial = 1U;
#line 1785
        return (1);
      }
    }
  }
#line 1788
  if ((int )c == 92) {
#line 1791
    if (input->cur_idx + 1UL >= input->len) {
#line 1793
      token->type = (re_token_type_t )36;
#line 1794
      return (1);
    }
    {
#line 1797
    tmp = re_string_peek_byte_case((re_string_t const   *)input, (Idx )1);
#line 1797
    c2 = (unsigned char )tmp;
#line 1798
    token->opr.c = c2;
#line 1799
    token->type = (re_token_type_t )1;
    }
#line 1801
    if (input->mb_cur_max > 1) {
      {
#line 1803
      tmp___0 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1UL);
#line 1803
      wc = (wint_t )tmp___0;
#line 1805
      tmp___1 = iswalnum(wc);
      }
#line 1805
      if (tmp___1) {
#line 1805
        tmp___2 = 1;
      } else
#line 1805
      if (wc == 95U) {
#line 1805
        tmp___2 = 1;
      } else {
#line 1805
        tmp___2 = 0;
      }
#line 1805
      token->word_char = (unsigned int )(tmp___2 != 0);
    } else {
      {
#line 1809
      tmp___3 = __ctype_b_loc();
      }
#line 1809
      if ((int const   )*(*tmp___3 + (int )c2) & 8) {
#line 1809
        tmp___4 = 1;
      } else
#line 1809
      if ((int )c2 == 95) {
#line 1809
        tmp___4 = 1;
      } else {
#line 1809
        tmp___4 = 0;
      }
#line 1809
      token->word_char = (unsigned int )(tmp___4 != 0);
    }
    {
#line 1813
    if ((int )c2 == 124) {
#line 1813
      goto case_124;
    }
#line 1818
    if ((int )c2 == 57) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 56) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 55) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 54) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 53) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 52) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 51) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 50) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 49) {
#line 1818
      goto case_57;
    }
#line 1825
    if ((int )c2 == 60) {
#line 1825
      goto case_60;
    }
#line 1832
    if ((int )c2 == 62) {
#line 1832
      goto case_62;
    }
#line 1839
    if ((int )c2 == 98) {
#line 1839
      goto case_98;
    }
#line 1846
    if ((int )c2 == 66) {
#line 1846
      goto case_66;
    }
#line 1853
    if ((int )c2 == 119) {
#line 1853
      goto case_119;
    }
#line 1857
    if ((int )c2 == 87) {
#line 1857
      goto case_87;
    }
#line 1861
    if ((int )c2 == 115) {
#line 1861
      goto case_115;
    }
#line 1865
    if ((int )c2 == 83) {
#line 1865
      goto case_83;
    }
#line 1869
    if ((int )c2 == 96) {
#line 1869
      goto case_96;
    }
#line 1876
    if ((int )c2 == 39) {
#line 1876
      goto case_39;
    }
#line 1883
    if ((int )c2 == 40) {
#line 1883
      goto case_40;
    }
#line 1887
    if ((int )c2 == 41) {
#line 1887
      goto case_41;
    }
#line 1891
    if ((int )c2 == 43) {
#line 1891
      goto case_43;
    }
#line 1895
    if ((int )c2 == 63) {
#line 1895
      goto case_63;
    }
#line 1899
    if ((int )c2 == 123) {
#line 1899
      goto case_123;
    }
#line 1903
    if ((int )c2 == 125) {
#line 1903
      goto case_125;
    }
#line 1907
    goto switch_default;
    case_124: /* CIL Label */ 
#line 1814
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1814
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1815
        token->type = (re_token_type_t )10;
      }
    }
#line 1816
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1819
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1821
      token->type = (re_token_type_t )4;
#line 1822
      token->opr.idx = (Idx )((int )c2 - 49);
    }
#line 1824
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1826
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1828
      token->type = (re_token_type_t )12;
#line 1829
      token->opr.ctx_type = (re_context_type )6;
    }
#line 1831
    goto switch_break;
    case_62: /* CIL Label */ 
#line 1833
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1835
      token->type = (re_token_type_t )12;
#line 1836
      token->opr.ctx_type = (re_context_type )9;
    }
#line 1838
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1840
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1842
      token->type = (re_token_type_t )12;
#line 1843
      token->opr.ctx_type = (re_context_type )256;
    }
#line 1845
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1847
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1849
      token->type = (re_token_type_t )12;
#line 1850
      token->opr.ctx_type = (re_context_type )512;
    }
#line 1852
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1854
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1855
      token->type = (re_token_type_t )32;
    }
#line 1856
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1858
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1859
      token->type = (re_token_type_t )33;
    }
#line 1860
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1862
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1863
      token->type = (re_token_type_t )34;
    }
#line 1864
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1866
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1867
      token->type = (re_token_type_t )35;
    }
#line 1868
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1870
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1872
      token->type = (re_token_type_t )12;
#line 1873
      token->opr.ctx_type = (re_context_type )64;
    }
#line 1875
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1877
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1879
      token->type = (re_token_type_t )12;
#line 1880
      token->opr.ctx_type = (re_context_type )128;
    }
#line 1882
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1884
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1885
      token->type = (re_token_type_t )8;
    }
#line 1886
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1888
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1889
      token->type = (re_token_type_t )9;
    }
#line 1890
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1892
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1892
      if (syntax & (1UL << 1)) {
#line 1893
        token->type = (re_token_type_t )18;
      }
    }
#line 1894
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1896
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1896
      if (syntax & (1UL << 1)) {
#line 1897
        token->type = (re_token_type_t )19;
      }
    }
#line 1898
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1900
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1900
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1901
        token->type = (re_token_type_t )23;
      }
    }
#line 1902
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1904
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1904
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1905
        token->type = (re_token_type_t )24;
      }
    }
#line 1906
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1908
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1910
    return (2);
  }
#line 1913
  token->type = (re_token_type_t )1;
#line 1915
  if (input->mb_cur_max > 1) {
    {
#line 1917
    tmp___5 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1917
    wc___0 = (wint_t )tmp___5;
#line 1918
    tmp___6 = iswalnum(wc___0);
    }
#line 1918
    if (tmp___6) {
#line 1918
      tmp___7 = 1;
    } else
#line 1918
    if (wc___0 == 95U) {
#line 1918
      tmp___7 = 1;
    } else {
#line 1918
      tmp___7 = 0;
    }
#line 1918
    token->word_char = (unsigned int )(tmp___7 != 0);
  } else {
    {
#line 1922
    tmp___8 = __ctype_b_loc();
    }
#line 1922
    if ((int const   )*(*tmp___8 + (int )token->opr.c) & 8) {
#line 1922
      tmp___9 = 1;
    } else
#line 1922
    if ((int )token->opr.c == 95) {
#line 1922
      tmp___9 = 1;
    } else {
#line 1922
      tmp___9 = 0;
    }
#line 1922
    token->word_char = (unsigned int )tmp___9;
  }
  {
#line 1926
  if ((int )c == 10) {
#line 1926
    goto case_10;
  }
#line 1930
  if ((int )c == 124) {
#line 1930
    goto case_124___0;
  }
#line 1934
  if ((int )c == 42) {
#line 1934
    goto case_42;
  }
#line 1937
  if ((int )c == 43) {
#line 1937
    goto case_43___0;
  }
#line 1941
  if ((int )c == 63) {
#line 1941
    goto case_63___0;
  }
#line 1945
  if ((int )c == 123) {
#line 1945
    goto case_123___0;
  }
#line 1949
  if ((int )c == 125) {
#line 1949
    goto case_125___0;
  }
#line 1953
  if ((int )c == 40) {
#line 1953
    goto case_40___0;
  }
#line 1957
  if ((int )c == 41) {
#line 1957
    goto case_41___0;
  }
#line 1961
  if ((int )c == 91) {
#line 1961
    goto case_91;
  }
#line 1964
  if ((int )c == 46) {
#line 1964
    goto case_46;
  }
#line 1967
  if ((int )c == 94) {
#line 1967
    goto case_94;
  }
#line 1978
  if ((int )c == 36) {
#line 1978
    goto case_36;
  }
#line 1992
  goto switch_default___0;
  case_10: /* CIL Label */ 
#line 1927
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1928
    token->type = (re_token_type_t )10;
  }
#line 1929
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
#line 1931
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1931
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1932
      token->type = (re_token_type_t )10;
    }
  }
#line 1933
  goto switch_break___0;
  case_42: /* CIL Label */ 
#line 1935
  token->type = (re_token_type_t )11;
#line 1936
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
#line 1938
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1938
    if (! (syntax & (1UL << 1))) {
#line 1939
      token->type = (re_token_type_t )18;
    }
  }
#line 1940
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
#line 1942
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1942
    if (! (syntax & (1UL << 1))) {
#line 1943
      token->type = (re_token_type_t )19;
    }
  }
#line 1944
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
#line 1946
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1946
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1947
      token->type = (re_token_type_t )23;
    }
  }
#line 1948
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 1950
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1950
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1951
      token->type = (re_token_type_t )24;
    }
  }
#line 1952
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
#line 1954
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1955
    token->type = (re_token_type_t )8;
  }
#line 1956
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
#line 1958
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1959
    token->type = (re_token_type_t )9;
  }
#line 1960
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 1962
  token->type = (re_token_type_t )20;
#line 1963
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 1965
  token->type = (re_token_type_t )5;
#line 1966
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 1968
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1968
    if (input->cur_idx != 0UL) {
#line 1971
      prev = (char )*(input->mbs + (input->cur_idx + 0xffffffffffffffffUL));
#line 1972
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1973
        goto switch_break___0;
      } else
#line 1972
      if ((int )prev != 10) {
#line 1973
        goto switch_break___0;
      }
    }
  }
#line 1975
  token->type = (re_token_type_t )12;
#line 1976
  token->opr.ctx_type = (re_context_type )16;
#line 1977
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 1979
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 1979
    if (input->cur_idx + 1UL != input->len) {
      {
#line 1983
      (input->cur_idx) ++;
#line 1984
      peek_token(& next, input, syntax);
#line 1985
      (input->cur_idx) --;
      }
#line 1986
      if ((unsigned int )next.type != 10U) {
#line 1986
        if ((unsigned int )next.type != 9U) {
#line 1987
          goto switch_break___0;
        }
      }
    }
  }
#line 1989
  token->type = (re_token_type_t )12;
#line 1990
  token->opr.ctx_type = (re_context_type )32;
#line 1991
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1993
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1995
  return (1);
}
}
#line 2001 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 2006
  if (input->stop <= input->cur_idx) {
#line 2008
    token->type = (re_token_type_t )2;
#line 2009
    return (0);
  }
#line 2011
  c = *(input->mbs + input->cur_idx);
#line 2012
  token->opr.c = c;
#line 2015
  if (input->mb_cur_max > 1) {
#line 2015
    if (! (input->cur_idx == input->valid_len)) {
#line 2015
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 2018
        token->type = (re_token_type_t )1;
#line 2019
        return (1);
      }
    }
  }
#line 2023
  if ((int )c == 92) {
#line 2023
    if (syntax & 1UL) {
#line 2023
      if (input->cur_idx + 1UL < input->len) {
#line 2028
        (input->cur_idx) ++;
#line 2029
        c2 = *(input->mbs + input->cur_idx);
#line 2030
        token->opr.c = c2;
#line 2031
        token->type = (re_token_type_t )1;
#line 2032
        return (1);
      }
    }
  }
#line 2034
  if ((int )c == 91) {
#line 2038
    if (input->cur_idx + 1UL < input->len) {
#line 2039
      c2___0 = *(input->mbs + (input->cur_idx + 1UL));
    } else {
#line 2041
      c2___0 = (unsigned char)0;
    }
#line 2042
    token->opr.c = c2___0;
#line 2043
    token_len = 2;
    {
#line 2046
    if ((int )c2___0 == 46) {
#line 2046
      goto case_46;
    }
#line 2049
    if ((int )c2___0 == 61) {
#line 2049
      goto case_61;
    }
#line 2052
    if ((int )c2___0 == 58) {
#line 2052
      goto case_58;
    }
#line 2059
    goto switch_default;
    case_46: /* CIL Label */ 
#line 2047
    token->type = (re_token_type_t )26;
#line 2048
    goto switch_break;
    case_61: /* CIL Label */ 
#line 2050
    token->type = (re_token_type_t )28;
#line 2051
    goto switch_break;
    case_58: /* CIL Label */ 
#line 2053
    if (syntax & ((1UL << 1) << 1)) {
#line 2055
      token->type = (re_token_type_t )30;
#line 2056
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 2060
    token->type = (re_token_type_t )1;
#line 2061
    token->opr.c = c;
#line 2062
    token_len = 1;
#line 2063
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2065
    return (token_len);
  }
  {
#line 2069
  if ((int )c == 45) {
#line 2069
    goto case_45;
  }
#line 2072
  if ((int )c == 93) {
#line 2072
    goto case_93;
  }
#line 2075
  if ((int )c == 94) {
#line 2075
    goto case_94;
  }
#line 2078
  goto switch_default___0;
  case_45: /* CIL Label */ 
#line 2070
  token->type = (re_token_type_t )22;
#line 2071
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 2073
  token->type = (re_token_type_t )21;
#line 2074
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 2076
  token->type = (re_token_type_t )25;
#line 2077
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2079
  token->type = (re_token_type_t )1;
  switch_break___0: /* CIL Label */ ;
  }
#line 2081
  return (1);
}
}
#line 2098 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2102
  dfa = (re_dfa_t *)preg->buffer;
#line 2105
  dfa->syntax = syntax;
#line 2106
  fetch_token(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2107
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, (Idx )0, err);
  }
#line 2108
  if ((int )*err != 0) {
#line 2108
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2108
      tmp = 1;
    } else {
#line 2108
      tmp = 0;
    }
  } else {
#line 2108
    tmp = 0;
  }
  {
#line 2108
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2108
  if (tmp___0) {
#line 2109
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2110
  eor = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )2);
  }
#line 2111
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
#line 2112
    root = create_tree(dfa, tree, eor, (re_token_type_t )16);
    }
  } else {
#line 2114
    root = eor;
  }
#line 2115
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 2115
    tmp___1 = 1;
  } else
#line 2115
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 2115
    tmp___1 = 1;
  } else {
#line 2115
    tmp___1 = 0;
  }
  {
#line 2115
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2115
  if (tmp___2) {
#line 2117
    *err = (reg_errcode_t )12;
#line 2118
    return ((bin_tree_t *)((void *)0));
  }
#line 2120
  return (root);
}
}
#line 2132 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2136
  dfa = (re_dfa_t *)preg->buffer;
#line 2137
  branch = (bin_tree_t *)((void *)0);
#line 2138
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
  }
#line 2139
  if ((int )*err != 0) {
#line 2139
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2139
      tmp = 1;
    } else {
#line 2139
      tmp = 0;
    }
  } else {
#line 2139
    tmp = 0;
  }
  {
#line 2139
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2139
  if (tmp___0) {
#line 2140
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2142
    if (! ((unsigned int )token->type == 10U)) {
#line 2142
      goto while_break;
    }
    {
#line 2144
    fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
#line 2145
    if ((unsigned int )token->type != 10U) {
#line 2145
      if ((unsigned int )token->type != 2U) {
#line 2145
        if (nest == 0UL) {
#line 2145
          goto _L;
        } else
#line 2145
        if ((unsigned int )token->type != 9U) {
          _L: /* CIL Label */ 
          {
#line 2148
          branch = parse_branch(regexp, preg, token, syntax, nest, err);
          }
#line 2149
          if ((int )*err != 0) {
#line 2149
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
#line 2149
              tmp___1 = 1;
            } else {
#line 2149
              tmp___1 = 0;
            }
          } else {
#line 2149
            tmp___1 = 0;
          }
          {
#line 2149
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
          }
#line 2149
          if (tmp___2) {
#line 2150
            return ((bin_tree_t *)((void *)0));
          }
        } else {
#line 2153
          branch = (bin_tree_t *)((void *)0);
        }
      } else {
#line 2153
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
#line 2153
      branch = (bin_tree_t *)((void *)0);
    }
    {
#line 2154
    tree = create_tree(dfa, tree, branch, (re_token_type_t )10);
#line 2155
    tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 2155
    if (tmp___3) {
#line 2157
      *err = (reg_errcode_t )12;
#line 2158
      return ((bin_tree_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2161
  return (tree);
}
}
#line 2173 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *expr ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2178
  dfa = (re_dfa_t *)preg->buffer;
#line 2179
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
  }
#line 2180
  if ((int )*err != 0) {
#line 2180
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2180
      tmp = 1;
    } else {
#line 2180
      tmp = 0;
    }
  } else {
#line 2180
    tmp = 0;
  }
  {
#line 2180
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2180
  if (tmp___0) {
#line 2181
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2183
    if ((unsigned int )token->type != 10U) {
#line 2183
      if ((unsigned int )token->type != 2U) {
#line 2183
        if (! (nest == 0UL)) {
#line 2183
          if (! ((unsigned int )token->type != 9U)) {
#line 2183
            goto while_break;
          }
        }
      } else {
#line 2183
        goto while_break;
      }
    } else {
#line 2183
      goto while_break;
    }
    {
#line 2186
    expr = parse_expression(regexp, preg, token, syntax, nest, err);
    }
#line 2187
    if ((int )*err != 0) {
#line 2187
      if ((unsigned long )expr == (unsigned long )((void *)0)) {
#line 2187
        tmp___1 = 1;
      } else {
#line 2187
        tmp___1 = 0;
      }
    } else {
#line 2187
      tmp___1 = 0;
    }
    {
#line 2187
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2187
    if (tmp___2) {
#line 2189
      return ((bin_tree_t *)((void *)0));
    }
#line 2191
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2191
      if ((unsigned long )expr != (unsigned long )((void *)0)) {
        {
#line 2193
        tree = create_tree(dfa, tree, expr, (re_token_type_t )16);
        }
#line 2194
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2196
          *err = (reg_errcode_t )12;
#line 2197
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2191
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2200
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2201
      tree = expr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2204
  return (tree);
}
}
#line 2213 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  long tmp ;
  bin_tree_t *mbc_remain ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bin_tree_t *tmp___8 ;
  long tmp___9 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;

  {
#line 2217
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 2221
  if ((unsigned int )token->type == 1U) {
#line 2221
    goto case_1;
  }
#line 2247
  if ((unsigned int )token->type == 8U) {
#line 2247
    goto case_8;
  }
#line 2252
  if ((unsigned int )token->type == 20U) {
#line 2252
    goto case_20;
  }
#line 2257
  if ((unsigned int )token->type == 4U) {
#line 2257
    goto case_4;
  }
#line 2273
  if ((unsigned int )token->type == 23U) {
#line 2273
    goto case_23;
  }
#line 2282
  if ((unsigned int )token->type == 19U) {
#line 2282
    goto case_19;
  }
#line 2282
  if ((unsigned int )token->type == 18U) {
#line 2282
    goto case_19;
  }
#line 2282
  if ((unsigned int )token->type == 11U) {
#line 2282
    goto case_19;
  }
#line 2294
  if ((unsigned int )token->type == 9U) {
#line 2294
    goto case_9;
  }
#line 2302
  if ((unsigned int )token->type == 24U) {
#line 2302
    goto case_24;
  }
#line 2316
  if ((unsigned int )token->type == 12U) {
#line 2316
    goto case_12;
  }
#line 2360
  if ((unsigned int )token->type == 5U) {
#line 2360
    goto case_5;
  }
#line 2371
  if ((unsigned int )token->type == 33U) {
#line 2371
    goto case_33;
  }
#line 2371
  if ((unsigned int )token->type == 32U) {
#line 2371
    goto case_33;
  }
#line 2380
  if ((unsigned int )token->type == 35U) {
#line 2380
    goto case_35;
  }
#line 2380
  if ((unsigned int )token->type == 34U) {
#line 2380
    goto case_35;
  }
#line 2389
  if ((unsigned int )token->type == 2U) {
#line 2389
    goto case_2;
  }
#line 2389
  if ((unsigned int )token->type == 10U) {
#line 2389
    goto case_2;
  }
#line 2391
  if ((unsigned int )token->type == 36U) {
#line 2391
    goto case_36;
  }
#line 2394
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2222
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2223
  tmp = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                         0L);
  }
#line 2223
  if (tmp) {
#line 2225
    *err = (reg_errcode_t )12;
#line 2226
    return ((bin_tree_t *)((void *)0));
  }
#line 2229
  if (dfa->mb_cur_max > 1) {
    {
#line 2231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2231
      if (! (regexp->stop <= regexp->cur_idx)) {
#line 2231
        if (regexp->cur_idx == regexp->valid_len) {
#line 2231
          goto while_break;
        } else
#line 2231
        if (*(regexp->wcs + regexp->cur_idx) != 4294967295U) {
#line 2231
          goto while_break;
        }
      } else {
#line 2231
        goto while_break;
      }
      {
#line 2235
      fetch_token(token, regexp, syntax);
#line 2236
      mbc_remain = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2237
      tree = create_tree(dfa, tree, mbc_remain, (re_token_type_t )16);
      }
#line 2238
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 2238
        tmp___0 = 1;
      } else
#line 2238
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2238
        tmp___0 = 1;
      } else {
#line 2238
        tmp___0 = 0;
      }
      {
#line 2238
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
      }
#line 2238
      if (tmp___1) {
#line 2240
        *err = (reg_errcode_t )12;
#line 2241
        return ((bin_tree_t *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2246
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2248
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1UL, err);
  }
#line 2249
  if ((int )*err != 0) {
#line 2249
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2249
      tmp___2 = 1;
    } else {
#line 2249
      tmp___2 = 0;
    }
  } else {
#line 2249
    tmp___2 = 0;
  }
  {
#line 2249
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 2249
  if (tmp___3) {
#line 2250
    return ((bin_tree_t *)((void *)0));
  }
#line 2251
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2253
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
  }
#line 2254
  if ((int )*err != 0) {
#line 2254
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2254
      tmp___4 = 1;
    } else {
#line 2254
      tmp___4 = 0;
    }
  } else {
#line 2254
    tmp___4 = 0;
  }
  {
#line 2254
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 2254
  if (tmp___5) {
#line 2255
    return ((bin_tree_t *)((void *)0));
  }
#line 2256
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2258
  tmp___6 = __builtin_expect((long )(dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
  }
#line 2258
  if (! tmp___6) {
#line 2260
    *err = (reg_errcode_t )6;
#line 2261
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2263
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2264
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2265
  tmp___7 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2265
  if (tmp___7) {
#line 2267
    *err = (reg_errcode_t )12;
#line 2268
    return ((bin_tree_t *)((void *)0));
  }
#line 2270
  (dfa->nbackref) ++;
#line 2271
  dfa->has_mb_node = 1U;
#line 2272
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2274
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2276
    *err = (reg_errcode_t )13;
#line 2277
    return ((bin_tree_t *)((void *)0));
  }
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 2283
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2285
    *err = (reg_errcode_t )13;
#line 2286
    return ((bin_tree_t *)((void *)0));
  } else
#line 2288
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
#line 2290
    fetch_token(token, regexp, syntax);
#line 2291
    tmp___8 = parse_expression(regexp, preg, token, syntax, nest, err);
    }
#line 2291
    return (tmp___8);
  }
  case_9: /* CIL Label */ 
#line 2295
  if ((unsigned int )token->type == 9U) {
#line 2295
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2298
      *err = (reg_errcode_t )16;
#line 2299
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_24: /* CIL Label */ 
  {
#line 2306
  token->type = (re_token_type_t )1;
#line 2309
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2310
  tmp___9 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2310
  if (tmp___9) {
#line 2312
    *err = (reg_errcode_t )12;
#line 2313
    return ((bin_tree_t *)((void *)0));
  }
#line 2315
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2317
  if ((unsigned int )token->opr.ctx_type & 783U) {
#line 2317
    if (dfa->word_ops_used == 0U) {
      {
#line 2320
      init_word_char(dfa);
      }
    }
  }
#line 2321
  if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2321
    goto _L;
  } else
#line 2321
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: /* CIL Label */ 
#line 2325
    if ((unsigned int )token->opr.ctx_type == 256U) {
      {
#line 2327
      token->opr.ctx_type = (re_context_type )6;
#line 2328
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2329
      token->opr.ctx_type = (re_context_type )9;
      }
    } else {
      {
#line 2333
      token->opr.ctx_type = (re_context_type )5;
#line 2334
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2335
      token->opr.ctx_type = (re_context_type )10;
      }
    }
    {
#line 2337
    tree_last = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
#line 2338
    tree = create_tree(dfa, tree_first, tree_last, (re_token_type_t )10);
    }
#line 2339
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else
#line 2339
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else
#line 2339
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else {
#line 2339
      tmp___10 = 0;
    }
    {
#line 2339
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 2339
    if (tmp___11) {
#line 2341
      *err = (reg_errcode_t )12;
#line 2342
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
#line 2347
    tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
#line 2348
    tmp___12 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2348
    if (tmp___12) {
#line 2350
      *err = (reg_errcode_t )12;
#line 2351
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
#line 2358
  fetch_token(token, regexp, syntax);
  }
#line 2359
  return (tree);
  case_5: /* CIL Label */ 
  {
#line 2361
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2362
  tmp___13 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2362
  if (tmp___13) {
#line 2364
    *err = (reg_errcode_t )12;
#line 2365
    return ((bin_tree_t *)((void *)0));
  }
#line 2367
  if (dfa->mb_cur_max > 1) {
#line 2368
    dfa->has_mb_node = 1U;
  }
#line 2369
  goto switch_break;
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2372
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", (_Bool )((unsigned int )token->type == 33U),
                            err);
  }
#line 2376
  if ((int )*err != 0) {
#line 2376
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2376
      tmp___14 = 1;
    } else {
#line 2376
      tmp___14 = 0;
    }
  } else {
#line 2376
    tmp___14 = 0;
  }
  {
#line 2376
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
#line 2376
  if (tmp___15) {
#line 2377
    return ((bin_tree_t *)((void *)0));
  }
#line 2378
  goto switch_break;
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  {
#line 2381
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", (_Bool )((unsigned int )token->type == 35U),
                            err);
  }
#line 2385
  if ((int )*err != 0) {
#line 2385
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2385
      tmp___16 = 1;
    } else {
#line 2385
      tmp___16 = 0;
    }
  } else {
#line 2385
    tmp___16 = 0;
  }
  {
#line 2385
  tmp___17 = __builtin_expect((long )tmp___16, 0L);
  }
#line 2385
  if (tmp___17) {
#line 2386
    return ((bin_tree_t *)((void *)0));
  }
#line 2387
  goto switch_break;
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 2390
  return ((bin_tree_t *)((void *)0));
  case_36: /* CIL Label */ 
#line 2392
  *err = (reg_errcode_t )5;
#line 2393
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
#line 2399
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 2401
  fetch_token(token, regexp, syntax);
  }
  {
#line 2403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2403
    if (! ((unsigned int )token->type == 11U)) {
#line 2403
      if (! ((unsigned int )token->type == 18U)) {
#line 2403
        if (! ((unsigned int )token->type == 19U)) {
#line 2403
          if (! ((unsigned int )token->type == 23U)) {
#line 2403
            goto while_break___0;
          }
        }
      }
    }
    {
#line 2406
    tree = parse_dup_op(tree, regexp, dfa, token, syntax, err);
    }
#line 2407
    if ((int )*err != 0) {
#line 2407
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2407
        tmp___18 = 1;
      } else {
#line 2407
        tmp___18 = 0;
      }
    } else {
#line 2407
      tmp___18 = 0;
    }
    {
#line 2407
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
    }
#line 2407
    if (tmp___19) {
#line 2408
      return ((bin_tree_t *)((void *)0));
    }
#line 2410
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2410
      if ((unsigned int )token->type == 11U) {
#line 2414
        *err = (reg_errcode_t )13;
#line 2415
        return ((bin_tree_t *)((void *)0));
      } else
#line 2410
      if ((unsigned int )token->type == 23U) {
#line 2414
        *err = (reg_errcode_t )13;
#line 2415
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2419
  return (tree);
}
}
#line 2429 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2433
  dfa = (re_dfa_t *)preg->buffer;
#line 2436
  tmp = preg->re_nsub;
#line 2436
  (preg->re_nsub) ++;
#line 2436
  cur_nsub = tmp;
#line 2438
  fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 2441
  if ((unsigned int )token->type == 9U) {
#line 2442
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
#line 2445
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
    }
#line 2446
    if ((int )*err == 0) {
#line 2446
      if ((unsigned int )token->type != 9U) {
#line 2446
        tmp___0 = 1;
      } else {
#line 2446
        tmp___0 = 0;
      }
    } else {
#line 2446
      tmp___0 = 0;
    }
    {
#line 2446
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 2446
    if (tmp___1) {
#line 2447
      *err = (reg_errcode_t )8;
    }
    {
#line 2448
    tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2448
    if (tmp___2) {
#line 2449
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2452
  if (cur_nsub <= 8UL) {
#line 2453
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
  {
#line 2455
  tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
#line 2456
  tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2456
  if (tmp___3) {
#line 2458
    *err = (reg_errcode_t )12;
#line 2459
    return ((bin_tree_t *)((void *)0));
  }
#line 2461
  tree->token.opr.idx = cur_nsub;
#line 2462
  return (tree);
}
}
#line 2467 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  Idx i ;
  Idx start ;
  Idx end ;
  Idx start_idx ;
  re_token_t start_token ;
  Idx tmp ;
  Idx tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;

  {
#line 2471
  tree = (bin_tree_t *)((void *)0);
#line 2471
  old_tree = (bin_tree_t *)((void *)0);
#line 2472
  start_idx = regexp->cur_idx;
#line 2473
  start_token = *token;
#line 2475
  if ((unsigned int )token->type == 23U) {
    {
#line 2477
    end = (Idx )0;
#line 2478
    start = fetch_number(regexp, token, syntax);
    }
#line 2479
    if (start == 0xffffffffffffffffUL) {
#line 2481
      if ((unsigned int )token->type == 1U) {
#line 2481
        if ((int )token->opr.c == 44) {
#line 2482
          start = (Idx )0;
        } else {
#line 2485
          *err = (reg_errcode_t )10;
#line 2486
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2485
        *err = (reg_errcode_t )10;
#line 2486
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
#line 2489
    tmp___1 = __builtin_expect((long )(start != 0xfffffffffffffffeUL), 1L);
    }
#line 2489
    if (tmp___1) {
#line 2492
      if ((unsigned int )token->type == 24U) {
#line 2492
        end = start;
      } else {
#line 2492
        if ((unsigned int )token->type == 1U) {
#line 2492
          if ((int )token->opr.c == 44) {
            {
#line 2492
            tmp = fetch_number(regexp, token, syntax);
#line 2492
            tmp___0 = tmp;
            }
          } else {
#line 2492
            tmp___0 = (Idx )-2;
          }
        } else {
#line 2492
          tmp___0 = (Idx )-2;
        }
#line 2492
        end = tmp___0;
      }
    }
#line 2496
    if (start == 0xfffffffffffffffeUL) {
#line 2496
      tmp___3 = 1;
    } else
#line 2496
    if (end == 0xfffffffffffffffeUL) {
#line 2496
      tmp___3 = 1;
    } else {
#line 2496
      tmp___3 = 0;
    }
    {
#line 2496
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 2496
    if (tmp___4) {
      {
#line 2499
      tmp___2 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
      }
#line 2499
      if (tmp___2) {
#line 2501
        if ((unsigned int )token->type == 2U) {
#line 2502
          *err = (reg_errcode_t )9;
        } else {
#line 2504
          *err = (reg_errcode_t )10;
        }
#line 2506
        return ((bin_tree_t *)((void *)0));
      }
#line 2510
      regexp->cur_idx = start_idx;
#line 2511
      *token = start_token;
#line 2512
      token->type = (re_token_type_t )1;
#line 2515
      return (elem);
    }
#line 2518
    if (end != 0xffffffffffffffffUL) {
#line 2518
      if (start > end) {
#line 2518
        tmp___5 = 1;
      } else {
#line 2518
        tmp___5 = 0;
      }
    } else {
#line 2518
      tmp___5 = 0;
    }
    {
#line 2518
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 2518
    if (tmp___6) {
#line 2521
      *err = (reg_errcode_t )10;
#line 2522
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2527
    if ((unsigned int )token->type == 18U) {
#line 2527
      start = (Idx )1;
    } else {
#line 2527
      start = (Idx )0;
    }
#line 2528
    if ((unsigned int )token->type == 19U) {
#line 2528
      end = (Idx )1;
    } else {
#line 2528
      end = (Idx )-1;
    }
  }
  {
#line 2531
  fetch_token(token, regexp, syntax);
#line 2533
  tmp___7 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
  }
#line 2533
  if (tmp___7) {
#line 2534
    return ((bin_tree_t *)((void *)0));
  }
#line 2535
  if (start == 0UL) {
#line 2535
    if (end == 0UL) {
#line 2535
      tmp___8 = 1;
    } else {
#line 2535
      tmp___8 = 0;
    }
  } else {
#line 2535
    tmp___8 = 0;
  }
  {
#line 2535
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2535
  if (tmp___9) {
    {
#line 2537
    postorder(elem, & free_tree, (void *)0);
    }
#line 2538
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2542
  tmp___12 = __builtin_expect((long )(start > 0UL), 0L);
  }
#line 2542
  if (tmp___12) {
#line 2544
    tree = elem;
#line 2545
    i = (Idx )2;
    {
#line 2545
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2545
      if (! (i <= start)) {
#line 2545
        goto while_break;
      }
      {
#line 2547
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2548
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
      }
#line 2549
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2549
        tmp___10 = 1;
      } else
#line 2549
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2549
        tmp___10 = 1;
      } else {
#line 2549
        tmp___10 = 0;
      }
      {
#line 2549
      tmp___11 = __builtin_expect((long )tmp___10, 0L);
      }
#line 2549
      if (tmp___11) {
#line 2550
        goto parse_dup_op_espace;
      }
#line 2545
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2553
    if (start == end) {
#line 2554
      return (tree);
    }
    {
#line 2557
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2558
    old_tree = tree;
    }
  } else {
#line 2561
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2563
  if ((unsigned int )elem->token.type == 17U) {
    {
#line 2564
    postorder(elem, & mark_opt_subexp, (void *)((long )elem->token.opr.idx));
    }
  }
#line 2566
  if (end == 0xffffffffffffffffUL) {
#line 2566
    tmp___13 = 11;
  } else {
#line 2566
    tmp___13 = 10;
  }
  {
#line 2566
  tree = create_tree(dfa, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___13);
#line 2568
  tmp___14 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2568
  if (tmp___14) {
#line 2569
    goto parse_dup_op_espace;
  }
#line 2574
  if (end != 0xffffffffffffffffUL) {
#line 2575
    i = start + 2UL;
    {
#line 2575
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2575
      if (! (i <= end)) {
#line 2575
        goto while_break___0;
      }
      {
#line 2577
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2578
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
      }
#line 2579
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2579
        tmp___15 = 1;
      } else
#line 2579
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2579
        tmp___15 = 1;
      } else {
#line 2579
        tmp___15 = 0;
      }
      {
#line 2579
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
      }
#line 2579
      if (tmp___16) {
#line 2580
        goto parse_dup_op_espace;
      }
      {
#line 2582
      tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
#line 2583
      tmp___17 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2583
      if (tmp___17) {
#line 2584
        goto parse_dup_op_espace;
      }
#line 2575
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2587
  if (old_tree) {
    {
#line 2588
    tree = create_tree(dfa, old_tree, tree, (re_token_type_t )16);
    }
  }
#line 2590
  return (tree);
  parse_dup_op_espace: 
#line 2593
  *err = (reg_errcode_t )12;
#line 2594
  return ((bin_tree_t *)((void *)0));
}
}
#line 2609 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_range_exp(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                     Idx *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  wchar_t cmp_buf[6] ;
  int tmp___5 ;
  int tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  Idx new_nranges ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  Idx tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 2621
  if ((unsigned int )start_elem->type == 2U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )start_elem->type == 4U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )end_elem->type == 2U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )end_elem->type == 4U) {
#line 2621
    tmp = 1;
  } else {
#line 2621
    tmp = 0;
  }
  {
#line 2621
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2621
  if (tmp___0) {
#line 2624
    return ((reg_errcode_t )11);
  }
#line 2628
  if ((unsigned int )start_elem->type == 3U) {
    {
#line 2628
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
    }
#line 2628
    if (tmp___1 > 1UL) {
#line 2628
      tmp___3 = 1;
    } else {
#line 2628
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2628
  if ((unsigned int )end_elem->type == 3U) {
    {
#line 2628
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
    }
#line 2628
    if (tmp___2 > 1UL) {
#line 2628
      tmp___3 = 1;
    } else {
#line 2628
      tmp___3 = 0;
    }
  } else {
#line 2628
    tmp___3 = 0;
  }
  {
#line 2628
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 2628
  if (tmp___4) {
#line 2632
    return ((reg_errcode_t )3);
  }
#line 2639
  cmp_buf[0] = 0;
#line 2639
  cmp_buf[1] = 0;
#line 2639
  cmp_buf[2] = 0;
#line 2639
  cmp_buf[3] = 0;
#line 2639
  cmp_buf[4] = 0;
#line 2639
  cmp_buf[5] = 0;
#line 2641
  if ((unsigned int )start_elem->type == 0U) {
#line 2641
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2641
    if ((unsigned int )start_elem->type == 3U) {
#line 2641
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2641
      tmp___5 = 0;
    }
#line 2641
    start_ch = (unsigned int )tmp___5;
  }
#line 2644
  if ((unsigned int )end_elem->type == 0U) {
#line 2644
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2644
    if ((unsigned int )end_elem->type == 3U) {
#line 2644
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2644
      tmp___6 = 0;
    }
#line 2644
    end_ch = (unsigned int )tmp___6;
  }
#line 2647
  if ((unsigned int )start_elem->type == 0U) {
    {
#line 2647
    tmp___7 = btowc((int )start_ch);
#line 2647
    start_wc = tmp___7;
    }
  } else
#line 2647
  if ((unsigned int )start_elem->type == 3U) {
    {
#line 2647
    tmp___7 = btowc((int )start_ch);
#line 2647
    start_wc = tmp___7;
    }
  } else {
#line 2647
    start_wc = (wint_t )start_elem->opr.wch;
  }
#line 2649
  if ((unsigned int )end_elem->type == 0U) {
    {
#line 2649
    tmp___8 = btowc((int )end_ch);
#line 2649
    end_wc = tmp___8;
    }
  } else
#line 2649
  if ((unsigned int )end_elem->type == 3U) {
    {
#line 2649
    tmp___8 = btowc((int )end_ch);
#line 2649
    end_wc = tmp___8;
    }
  } else {
#line 2649
    end_wc = (wint_t )end_elem->opr.wch;
  }
#line 2651
  if (start_wc == 4294967295U) {
#line 2652
    return ((reg_errcode_t )3);
  } else
#line 2651
  if (end_wc == 4294967295U) {
#line 2652
    return ((reg_errcode_t )3);
  }
  {
#line 2653
  cmp_buf[0] = (wchar_t )start_wc;
#line 2654
  cmp_buf[4] = (wchar_t )end_wc;
#line 2655
  tmp___9 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 4));
  }
#line 2655
  if (tmp___9 > 0) {
#line 2656
    return ((reg_errcode_t )11);
  }
#line 2663
  if (mbcset) {
    {
#line 2666
    tmp___14 = __builtin_expect((long )(*range_alloc == mbcset->nranges), 0L);
    }
#line 2666
    if (tmp___14) {
      {
#line 2673
      new_nranges = 2UL * mbcset->nranges + 1UL;
#line 2676
      tmp___10 = realloc((void *)mbcset->range_starts, new_nranges * sizeof(wchar_t ));
#line 2676
      new_array_start = (wchar_t *)tmp___10;
#line 2678
      tmp___11 = realloc((void *)mbcset->range_ends, new_nranges * sizeof(wchar_t ));
#line 2678
      new_array_end = (wchar_t *)tmp___11;
      }
#line 2681
      if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2681
        tmp___12 = 1;
      } else
#line 2681
      if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2681
        tmp___12 = 1;
      } else {
#line 2681
        tmp___12 = 0;
      }
      {
#line 2681
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
      }
#line 2681
      if (tmp___13) {
#line 2682
        return ((reg_errcode_t )12);
      }
#line 2684
      mbcset->range_starts = new_array_start;
#line 2685
      mbcset->range_ends = new_array_end;
#line 2686
      *range_alloc = new_nranges;
    }
#line 2689
    *(mbcset->range_starts + mbcset->nranges) = (wchar_t )start_wc;
#line 2690
    tmp___15 = mbcset->nranges;
#line 2690
    (mbcset->nranges) ++;
#line 2690
    *(mbcset->range_ends + tmp___15) = (wchar_t )end_wc;
  }
#line 2694
  wc = 0;
  {
#line 2694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2694
    if (! (wc < 256)) {
#line 2694
      goto while_break;
    }
    {
#line 2696
    cmp_buf[2] = wc;
#line 2697
    tmp___16 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
    }
#line 2697
    if (tmp___16 <= 0) {
      {
#line 2697
      tmp___17 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
      }
#line 2697
      if (tmp___17 <= 0) {
        {
#line 2699
        bitset_set(sbcset, (Idx )wc);
        }
      }
    }
#line 2694
    wc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2719
  return ((reg_errcode_t )0);
}
}
#line 2730 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                            Idx *coll_sym_alloc , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 2738
  tmp = strlen((char const   *)name);
#line 2738
  name_len = tmp;
#line 2739
  tmp___0 = __builtin_expect((long )(name_len != 1UL), 0L);
  }
#line 2739
  if (tmp___0) {
#line 2740
    return ((reg_errcode_t )3);
  } else {
    {
#line 2743
    bitset_set(sbcset, (Idx )*(name + 0));
    }
#line 2744
    return ((reg_errcode_t )0);
  }
}
}
#line 2752 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx coll_sym_alloc ;
  Idx range_alloc ;
  Idx mbchar_alloc ;
  Idx equiv_class_alloc ;
  Idx char_class_alloc ;
  _Bool non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  _Bool first_round ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  _Bool is_range_exp ;
  re_token_t token2 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  re_charset_t *tmp___9 ;
  long tmp___10 ;
  wchar_t *new_mbchars ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  Idx tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
  {
#line 3023
  coll_sym_alloc = (Idx )0;
#line 3023
  range_alloc = (Idx )0;
#line 3023
  mbchar_alloc = (Idx )0;
#line 3024
  equiv_class_alloc = (Idx )0;
#line 3024
  char_class_alloc = (Idx )0;
#line 3026
  non_match = (_Bool)0;
#line 3029
  first_round = (_Bool)1;
#line 3047
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3047
  sbcset = (re_bitset_ptr_t )tmp;
#line 3049
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3049
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3052
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3052
    tmp___1 = 1;
  } else
#line 3052
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3052
    tmp___1 = 1;
  } else {
#line 3052
    tmp___1 = 0;
  }
  {
#line 3052
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 3052
  if (tmp___2) {
#line 3057
    *err = (reg_errcode_t )12;
#line 3058
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3061
  token_len = peek_token_bracket(token, regexp, syntax);
#line 3062
  tmp___3 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
  }
#line 3062
  if (tmp___3) {
#line 3064
    *err = (reg_errcode_t )2;
#line 3065
    goto parse_bracket_exp_free_return;
  }
#line 3067
  if ((unsigned int )token->type == 25U) {
#line 3070
    mbcset->non_match = 1U;
#line 3072
    non_match = (_Bool)1;
#line 3073
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 3074
      bitset_set((bitset_word_t *)sbcset, (Idx )'\n');
      }
    }
    {
#line 3075
    regexp->cur_idx += (Idx )token_len;
#line 3076
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3077
    tmp___4 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3077
    if (tmp___4) {
#line 3079
      *err = (reg_errcode_t )2;
#line 3080
      goto parse_bracket_exp_free_return;
    }
  }
#line 3085
  if ((unsigned int )token->type == 21U) {
#line 3086
    token->type = (re_token_type_t )1;
  }
  {
#line 3088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3094
    token_len2 = 0;
#line 3095
    is_range_exp = (_Bool)0;
#line 3098
    start_elem.opr.name = start_name_buf;
#line 3099
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax,
                                first_round);
#line 3101
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 3101
    if (tmp___5) {
#line 3103
      *err = ret;
#line 3104
      goto parse_bracket_exp_free_return;
    }
    {
#line 3106
    first_round = (_Bool)0;
#line 3109
    token_len = peek_token_bracket(token, regexp, syntax);
    }
#line 3112
    if ((unsigned int )start_elem.type != 4U) {
#line 3112
      if ((unsigned int )start_elem.type != 2U) {
        {
#line 3114
        tmp___6 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
        }
#line 3114
        if (tmp___6) {
#line 3116
          *err = (reg_errcode_t )7;
#line 3117
          goto parse_bracket_exp_free_return;
        }
#line 3119
        if ((unsigned int )token->type == 22U) {
          {
#line 3121
          regexp->cur_idx += (Idx )token_len;
#line 3122
          token_len2 = peek_token_bracket(& token2, regexp, syntax);
#line 3123
          tmp___7 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
          }
#line 3123
          if (tmp___7) {
#line 3125
            *err = (reg_errcode_t )7;
#line 3126
            goto parse_bracket_exp_free_return;
          }
#line 3128
          if ((unsigned int )token2.type == 21U) {
#line 3131
            regexp->cur_idx += (Idx )(- token_len);
#line 3132
            token->type = (re_token_type_t )1;
          } else {
#line 3135
            is_range_exp = (_Bool)1;
          }
        }
      }
    }
#line 3139
    if ((int )is_range_exp == 1) {
      {
#line 3141
      end_elem.opr.name = end_name_buf;
#line 3142
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax,
                                  (_Bool)1);
#line 3144
      tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 3144
      if (tmp___8) {
#line 3146
        *err = ret;
#line 3147
        goto parse_bracket_exp_free_return;
      }
      {
#line 3150
      token_len = peek_token_bracket(token, regexp, syntax);
      }
#line 3157
      if (dfa->mb_cur_max > 1) {
#line 3157
        tmp___9 = mbcset;
      } else {
#line 3157
        tmp___9 = (re_charset_t *)((void *)0);
      }
      {
#line 3157
      *err = build_range_exp((bitset_word_t *)sbcset, tmp___9, & range_alloc, & start_elem,
                             & end_elem);
#line 3164
      tmp___10 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3164
      if (tmp___10) {
#line 3165
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
#line 3171
      if ((unsigned int )start_elem.type == 0U) {
#line 3171
        goto case_0;
      }
#line 3175
      if ((unsigned int )start_elem.type == 1U) {
#line 3175
        goto case_1;
      }
#line 3193
      if ((unsigned int )start_elem.type == 2U) {
#line 3193
        goto case_2;
      }
#line 3202
      if ((unsigned int )start_elem.type == 3U) {
#line 3202
        goto case_3;
      }
#line 3211
      if ((unsigned int )start_elem.type == 4U) {
#line 3211
        goto case_4;
      }
#line 3220
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3172
      bitset_set((bitset_word_t *)sbcset, (Idx )start_elem.opr.ch);
      }
#line 3173
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3177
      tmp___13 = __builtin_expect((long )(mbchar_alloc == mbcset->nmbchars), 0L);
      }
#line 3177
      if (tmp___13) {
        {
#line 3182
        mbchar_alloc = 2UL * mbcset->nmbchars + 1UL;
#line 3184
        tmp___11 = realloc((void *)mbcset->mbchars, mbchar_alloc * sizeof(wchar_t ));
#line 3184
        new_mbchars = (wchar_t *)tmp___11;
#line 3186
        tmp___12 = __builtin_expect((long )((unsigned long )new_mbchars == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3186
        if (tmp___12) {
#line 3187
          goto parse_bracket_exp_espace;
        }
#line 3188
        mbcset->mbchars = new_mbchars;
      }
#line 3190
      tmp___14 = mbcset->nmbchars;
#line 3190
      (mbcset->nmbchars) ++;
#line 3190
      *(mbcset->mbchars + tmp___14) = start_elem.opr.wch;
#line 3191
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3194
      *err = build_equiv_class((bitset_word_t *)sbcset, mbcset, & equiv_class_alloc,
                               (unsigned char const   *)start_elem.opr.name);
#line 3199
      tmp___15 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3199
      if (tmp___15) {
#line 3200
        goto parse_bracket_exp_free_return;
      }
#line 3201
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 3203
      *err = build_collating_symbol((bitset_word_t *)sbcset, mbcset, & coll_sym_alloc,
                                    (unsigned char const   *)start_elem.opr.name);
#line 3208
      tmp___16 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3208
      if (tmp___16) {
#line 3209
        goto parse_bracket_exp_free_return;
      }
#line 3210
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 3212
      *err = build_charclass(regexp->trans, (bitset_word_t *)sbcset, mbcset, & char_class_alloc,
                             (unsigned char const   *)start_elem.opr.name, syntax);
#line 3217
      tmp___17 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3217
      if (tmp___17) {
#line 3218
        goto parse_bracket_exp_free_return;
      }
#line 3219
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3221
      __assert_fail("0", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                    3221U, "parse_bracket_exp");
      }
#line 3222
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3225
    tmp___18 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3225
    if (tmp___18) {
#line 3227
      *err = (reg_errcode_t )7;
#line 3228
      goto parse_bracket_exp_free_return;
    }
#line 3230
    if ((unsigned int )token->type == 21U) {
#line 3231
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3234
  regexp->cur_idx += (Idx )token_len;
#line 3237
  if (non_match) {
    {
#line 3238
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3242
  if (dfa->mb_cur_max > 1) {
    {
#line 3243
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
#line 3245
  if (mbcset->nmbchars) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->ncoll_syms) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->nequiv_classes) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->nranges) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (dfa->mb_cur_max > 1) {
#line 3245
    if (mbcset->nchar_classes) {
#line 3245
      goto _L___1;
    } else
#line 3245
    if (mbcset->non_match) {
      _L___1: /* CIL Label */ 
      {
#line 3252
      dfa->has_mb_node = 1U;
#line 3253
      br_token.type = (re_token_type_t )6;
#line 3254
      br_token.opr.mbcset = mbcset;
#line 3255
      mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                   (re_token_t const   *)(& br_token));
#line 3256
      tmp___19 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 3256
      if (tmp___19) {
#line 3257
        goto parse_bracket_exp_espace;
      }
#line 3258
      sbc_idx = 0;
      {
#line 3258
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3258
        if (! (sbc_idx < 4)) {
#line 3258
          goto while_break___0;
        }
#line 3259
        if (*(sbcset + sbc_idx)) {
#line 3260
          goto while_break___0;
        }
#line 3258
        sbc_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3263
      if (sbc_idx < 4) {
        {
#line 3266
        br_token.type = (re_token_type_t )3;
#line 3267
        br_token.opr.sbcset = sbcset;
#line 3268
        work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)(& br_token));
#line 3269
        tmp___20 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3269
        if (tmp___20) {
#line 3270
          goto parse_bracket_exp_espace;
        }
        {
#line 3273
        work_tree = create_tree(dfa, work_tree, mbc_tree, (re_token_type_t )10);
#line 3274
        tmp___21 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3274
        if (tmp___21) {
#line 3275
          goto parse_bracket_exp_espace;
        }
      } else {
        {
#line 3279
        free((void *)sbcset);
#line 3280
        work_tree = mbc_tree;
        }
      }
    } else {
#line 3245
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3287
    free_charset(mbcset);
#line 3290
    br_token.type = (re_token_type_t )3;
#line 3291
    br_token.opr.sbcset = sbcset;
#line 3292
    work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)(& br_token));
#line 3293
    tmp___22 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 3293
    if (tmp___22) {
#line 3294
      goto parse_bracket_exp_espace;
    }
  }
#line 3296
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3299
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
#line 3301
  free((void *)sbcset);
#line 3303
  free_charset(mbcset);
  }
#line 3305
  return ((bin_tree_t *)((void *)0));
}
}
#line 3310 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) 
{ 
  int cur_char_size ;
  int __attribute__((__pure__))  tmp ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  re_token_t token2 ;
  long tmp___2 ;

  {
  {
#line 3317
  tmp = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3317
  cur_char_size = (int )tmp;
  }
#line 3318
  if (cur_char_size > 1) {
    {
#line 3320
    elem->type = (bracket_elem_type )1;
#line 3321
    tmp___0 = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3321
    elem->opr.wch = (wchar_t )tmp___0;
#line 3322
    regexp->cur_idx += (Idx )cur_char_size;
    }
#line 3323
    return ((reg_errcode_t )0);
  }
#line 3326
  regexp->cur_idx += (Idx )token_len;
#line 3327
  if ((unsigned int )token->type == 26U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  } else
#line 3327
  if ((unsigned int )token->type == 30U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  } else
#line 3327
  if ((unsigned int )token->type == 28U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  }
  {
#line 3330
  tmp___2 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
  }
#line 3330
  if (tmp___2) {
#line 3330
    if (! accept_hyphen) {
      {
#line 3335
      peek_token_bracket(& token2, regexp, syntax);
      }
#line 3336
      if ((unsigned int )token2.type != 21U) {
#line 3339
        return ((reg_errcode_t )11);
      }
    }
  }
#line 3341
  elem->type = (bracket_elem_type )0;
#line 3342
  elem->opr.ch = token->opr.c;
#line 3343
  return ((reg_errcode_t )0);
}
}
#line 3350 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  unsigned char __attribute__((__pure__))  tmp ;
  Idx tmp___0 ;

  {
#line 3354
  delim = token->opr.c;
#line 3355
  i = 0;
#line 3356
  if (regexp->stop <= regexp->cur_idx) {
#line 3357
    return ((reg_errcode_t )7);
  }
  {
#line 3358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3360
    if (i >= 32) {
#line 3361
      return ((reg_errcode_t )7);
    }
#line 3362
    if ((unsigned int )token->type == 30U) {
      {
#line 3363
      tmp = re_string_fetch_byte_case(regexp);
#line 3363
      ch = (unsigned char )tmp;
      }
    } else {
#line 3365
      tmp___0 = regexp->cur_idx;
#line 3365
      (regexp->cur_idx) ++;
#line 3365
      ch = *(regexp->mbs + tmp___0);
    }
#line 3366
    if (regexp->stop <= regexp->cur_idx) {
#line 3367
      return ((reg_errcode_t )7);
    }
#line 3368
    if ((int )ch == (int )delim) {
#line 3368
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3369
        goto while_break;
      }
    }
#line 3370
    *(elem->opr.name + i) = ch;
#line 3358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3372
  (regexp->cur_idx) ++;
#line 3373
  *(elem->opr.name + i) = (unsigned char )'\000';
  {
#line 3376
  if ((unsigned int )token->type == 26U) {
#line 3376
    goto case_26;
  }
#line 3379
  if ((unsigned int )token->type == 28U) {
#line 3379
    goto case_28;
  }
#line 3382
  if ((unsigned int )token->type == 30U) {
#line 3382
    goto case_30;
  }
#line 3385
  goto switch_default;
  case_26: /* CIL Label */ 
#line 3377
  elem->type = (bracket_elem_type )3;
#line 3378
  goto switch_break;
  case_28: /* CIL Label */ 
#line 3380
  elem->type = (bracket_elem_type )2;
#line 3381
  goto switch_break;
  case_30: /* CIL Label */ 
#line 3383
  elem->type = (bracket_elem_type )4;
#line 3384
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3386
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3388
  return ((reg_errcode_t )0);
}
}
#line 3397 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 3476
  tmp = strlen((char const   *)name);
#line 3476
  tmp___0 = __builtin_expect((long )(tmp != 1UL), 0L);
  }
#line 3476
  if (tmp___0) {
#line 3477
    return ((reg_errcode_t )3);
  }
  {
#line 3478
  bitset_set(sbcset, (Idx )*name);
  }
#line 3480
  return ((reg_errcode_t )0);
}
}
#line 3489 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  Idx new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  long tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  long tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  long tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  long tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  long tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  long tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  long tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  long tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  long tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  long tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;

  {
#line 3500
  name = (char const   *)class_name;
#line 3504
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 3504
    tmp = strcmp(name, "upper");
    }
#line 3504
    if (tmp == 0) {
#line 3506
      name = "alpha";
    } else {
      {
#line 3504
      tmp___0 = strcmp(name, "lower");
      }
#line 3504
      if (tmp___0 == 0) {
#line 3506
        name = "alpha";
      }
    }
  }
  {
#line 3510
  tmp___3 = __builtin_expect((long )(*char_class_alloc == mbcset->nchar_classes),
                             0L);
  }
#line 3510
  if (tmp___3) {
    {
#line 3514
    new_char_class_alloc = 2UL * mbcset->nchar_classes + 1UL;
#line 3516
    tmp___1 = realloc((void *)mbcset->char_classes, new_char_class_alloc * sizeof(wctype_t ));
#line 3516
    new_char_classes = (wctype_t *)tmp___1;
#line 3518
    tmp___2 = __builtin_expect((long )((unsigned long )new_char_classes == (unsigned long )((void *)0)),
                               0L);
    }
#line 3518
    if (tmp___2) {
#line 3519
      return ((reg_errcode_t )12);
    }
#line 3520
    mbcset->char_classes = new_char_classes;
#line 3521
    *char_class_alloc = new_char_class_alloc;
  }
  {
#line 3523
  tmp___4 = mbcset->nchar_classes;
#line 3523
  (mbcset->nchar_classes) ++;
#line 3523
  *(mbcset->char_classes + tmp___4) = wctype(name);
#line 3542
  tmp___52 = strcmp(name, "alnum");
  }
#line 3542
  if (tmp___52 == 0) {
    {
#line 3543
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3543
      tmp___7 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 3543
      if (tmp___7) {
#line 3543
        i = 0;
        {
#line 3543
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3543
          if (! (i < 256)) {
#line 3543
            goto while_break___0;
          }
          {
#line 3543
          tmp___5 = __ctype_b_loc();
          }
#line 3543
          if ((int const   )*(*tmp___5 + i) & 8) {
            {
#line 3543
            bitset_set(sbcset, (Idx )*(trans + i));
            }
          }
#line 3543
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 3543
        i = 0;
        {
#line 3543
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3543
          if (! (i < 256)) {
#line 3543
            goto while_break___1;
          }
          {
#line 3543
          tmp___6 = __ctype_b_loc();
          }
#line 3543
          if ((int const   )*(*tmp___6 + i) & 8) {
            {
#line 3543
            bitset_set(sbcset, (Idx )i);
            }
          }
#line 3543
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 3543
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 3544
    tmp___51 = strcmp(name, "cntrl");
    }
#line 3544
    if (tmp___51 == 0) {
      {
#line 3545
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 3545
        tmp___10 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 3545
        if (tmp___10) {
#line 3545
          i = 0;
          {
#line 3545
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3545
            if (! (i < 256)) {
#line 3545
              goto while_break___3;
            }
            {
#line 3545
            tmp___8 = __ctype_b_loc();
            }
#line 3545
            if ((int const   )*(*tmp___8 + i) & 2) {
              {
#line 3545
              bitset_set(sbcset, (Idx )*(trans + i));
              }
            }
#line 3545
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 3545
          i = 0;
          {
#line 3545
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3545
            if (! (i < 256)) {
#line 3545
              goto while_break___4;
            }
            {
#line 3545
            tmp___9 = __ctype_b_loc();
            }
#line 3545
            if ((int const   )*(*tmp___9 + i) & 2) {
              {
#line 3545
              bitset_set(sbcset, (Idx )i);
              }
            }
#line 3545
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 3545
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3546
      tmp___50 = strcmp(name, "lower");
      }
#line 3546
      if (tmp___50 == 0) {
        {
#line 3547
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3547
          tmp___13 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 3547
          if (tmp___13) {
#line 3547
            i = 0;
            {
#line 3547
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3547
              if (! (i < 256)) {
#line 3547
                goto while_break___6;
              }
              {
#line 3547
              tmp___11 = __ctype_b_loc();
              }
#line 3547
              if ((int const   )*(*tmp___11 + i) & 512) {
                {
#line 3547
                bitset_set(sbcset, (Idx )*(trans + i));
                }
              }
#line 3547
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 3547
            i = 0;
            {
#line 3547
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 3547
              if (! (i < 256)) {
#line 3547
                goto while_break___7;
              }
              {
#line 3547
              tmp___12 = __ctype_b_loc();
              }
#line 3547
              if ((int const   )*(*tmp___12 + i) & 512) {
                {
#line 3547
                bitset_set(sbcset, (Idx )i);
                }
              }
#line 3547
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 3547
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 3548
        tmp___49 = strcmp(name, "space");
        }
#line 3548
        if (tmp___49 == 0) {
          {
#line 3549
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 3549
            tmp___16 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
            }
#line 3549
            if (tmp___16) {
#line 3549
              i = 0;
              {
#line 3549
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 3549
                if (! (i < 256)) {
#line 3549
                  goto while_break___9;
                }
                {
#line 3549
                tmp___14 = __ctype_b_loc();
                }
#line 3549
                if ((int const   )*(*tmp___14 + i) & 8192) {
                  {
#line 3549
                  bitset_set(sbcset, (Idx )*(trans + i));
                  }
                }
#line 3549
                i ++;
              }
              while_break___9: /* CIL Label */ ;
              }
            } else {
#line 3549
              i = 0;
              {
#line 3549
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 3549
                if (! (i < 256)) {
#line 3549
                  goto while_break___10;
                }
                {
#line 3549
                tmp___15 = __ctype_b_loc();
                }
#line 3549
                if ((int const   )*(*tmp___15 + i) & 8192) {
                  {
#line 3549
                  bitset_set(sbcset, (Idx )i);
                  }
                }
#line 3549
                i ++;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
#line 3549
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
#line 3550
          tmp___48 = strcmp(name, "alpha");
          }
#line 3550
          if (tmp___48 == 0) {
            {
#line 3551
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
#line 3551
              tmp___19 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
              }
#line 3551
              if (tmp___19) {
#line 3551
                i = 0;
                {
#line 3551
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 3551
                  if (! (i < 256)) {
#line 3551
                    goto while_break___12;
                  }
                  {
#line 3551
                  tmp___17 = __ctype_b_loc();
                  }
#line 3551
                  if ((int const   )*(*tmp___17 + i) & 1024) {
                    {
#line 3551
                    bitset_set(sbcset, (Idx )*(trans + i));
                    }
                  }
#line 3551
                  i ++;
                }
                while_break___12: /* CIL Label */ ;
                }
              } else {
#line 3551
                i = 0;
                {
#line 3551
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 3551
                  if (! (i < 256)) {
#line 3551
                    goto while_break___13;
                  }
                  {
#line 3551
                  tmp___18 = __ctype_b_loc();
                  }
#line 3551
                  if ((int const   )*(*tmp___18 + i) & 1024) {
                    {
#line 3551
                    bitset_set(sbcset, (Idx )i);
                    }
                  }
#line 3551
                  i ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
#line 3551
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
#line 3552
            tmp___47 = strcmp(name, "digit");
            }
#line 3552
            if (tmp___47 == 0) {
              {
#line 3553
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 3553
                tmp___22 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
                }
#line 3553
                if (tmp___22) {
#line 3553
                  i = 0;
                  {
#line 3553
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 3553
                    if (! (i < 256)) {
#line 3553
                      goto while_break___15;
                    }
                    {
#line 3553
                    tmp___20 = __ctype_b_loc();
                    }
#line 3553
                    if ((int const   )*(*tmp___20 + i) & 2048) {
                      {
#line 3553
                      bitset_set(sbcset, (Idx )*(trans + i));
                      }
                    }
#line 3553
                    i ++;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                } else {
#line 3553
                  i = 0;
                  {
#line 3553
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 3553
                    if (! (i < 256)) {
#line 3553
                      goto while_break___16;
                    }
                    {
#line 3553
                    tmp___21 = __ctype_b_loc();
                    }
#line 3553
                    if ((int const   )*(*tmp___21 + i) & 2048) {
                      {
#line 3553
                      bitset_set(sbcset, (Idx )i);
                      }
                    }
#line 3553
                    i ++;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
#line 3553
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
            } else {
              {
#line 3554
              tmp___46 = strcmp(name, "print");
              }
#line 3554
              if (tmp___46 == 0) {
                {
#line 3555
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 3555
                  tmp___25 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
                  }
#line 3555
                  if (tmp___25) {
#line 3555
                    i = 0;
                    {
#line 3555
                    while (1) {
                      while_continue___18: /* CIL Label */ ;
#line 3555
                      if (! (i < 256)) {
#line 3555
                        goto while_break___18;
                      }
                      {
#line 3555
                      tmp___23 = __ctype_b_loc();
                      }
#line 3555
                      if ((int const   )*(*tmp___23 + i) & 16384) {
                        {
#line 3555
                        bitset_set(sbcset, (Idx )*(trans + i));
                        }
                      }
#line 3555
                      i ++;
                    }
                    while_break___18: /* CIL Label */ ;
                    }
                  } else {
#line 3555
                    i = 0;
                    {
#line 3555
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
#line 3555
                      if (! (i < 256)) {
#line 3555
                        goto while_break___19;
                      }
                      {
#line 3555
                      tmp___24 = __ctype_b_loc();
                      }
#line 3555
                      if ((int const   )*(*tmp___24 + i) & 16384) {
                        {
#line 3555
                        bitset_set(sbcset, (Idx )i);
                        }
                      }
#line 3555
                      i ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                  }
#line 3555
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              } else {
                {
#line 3556
                tmp___45 = strcmp(name, "upper");
                }
#line 3556
                if (tmp___45 == 0) {
                  {
#line 3557
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
                    {
#line 3557
                    tmp___28 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
                    }
#line 3557
                    if (tmp___28) {
#line 3557
                      i = 0;
                      {
#line 3557
                      while (1) {
                        while_continue___21: /* CIL Label */ ;
#line 3557
                        if (! (i < 256)) {
#line 3557
                          goto while_break___21;
                        }
                        {
#line 3557
                        tmp___26 = __ctype_b_loc();
                        }
#line 3557
                        if ((int const   )*(*tmp___26 + i) & 256) {
                          {
#line 3557
                          bitset_set(sbcset, (Idx )*(trans + i));
                          }
                        }
#line 3557
                        i ++;
                      }
                      while_break___21: /* CIL Label */ ;
                      }
                    } else {
#line 3557
                      i = 0;
                      {
#line 3557
                      while (1) {
                        while_continue___22: /* CIL Label */ ;
#line 3557
                        if (! (i < 256)) {
#line 3557
                          goto while_break___22;
                        }
                        {
#line 3557
                        tmp___27 = __ctype_b_loc();
                        }
#line 3557
                        if ((int const   )*(*tmp___27 + i) & 256) {
                          {
#line 3557
                          bitset_set(sbcset, (Idx )i);
                          }
                        }
#line 3557
                        i ++;
                      }
                      while_break___22: /* CIL Label */ ;
                      }
                    }
#line 3557
                    goto while_break___20;
                  }
                  while_break___20: /* CIL Label */ ;
                  }
                } else {
                  {
#line 3558
                  tmp___44 = strcmp(name, "blank");
                  }
#line 3558
                  if (tmp___44 == 0) {
                    {
#line 3559
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
                      {
#line 3559
                      tmp___31 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
                      }
#line 3559
                      if (tmp___31) {
#line 3559
                        i = 0;
                        {
#line 3559
                        while (1) {
                          while_continue___24: /* CIL Label */ ;
#line 3559
                          if (! (i < 256)) {
#line 3559
                            goto while_break___24;
                          }
                          {
#line 3559
                          tmp___29 = __ctype_b_loc();
                          }
#line 3559
                          if ((int const   )*(*tmp___29 + i) & 1) {
                            {
#line 3559
                            bitset_set(sbcset, (Idx )*(trans + i));
                            }
                          }
#line 3559
                          i ++;
                        }
                        while_break___24: /* CIL Label */ ;
                        }
                      } else {
#line 3559
                        i = 0;
                        {
#line 3559
                        while (1) {
                          while_continue___25: /* CIL Label */ ;
#line 3559
                          if (! (i < 256)) {
#line 3559
                            goto while_break___25;
                          }
                          {
#line 3559
                          tmp___30 = __ctype_b_loc();
                          }
#line 3559
                          if ((int const   )*(*tmp___30 + i) & 1) {
                            {
#line 3559
                            bitset_set(sbcset, (Idx )i);
                            }
                          }
#line 3559
                          i ++;
                        }
                        while_break___25: /* CIL Label */ ;
                        }
                      }
#line 3559
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 3560
                    tmp___43 = strcmp(name, "graph");
                    }
#line 3560
                    if (tmp___43 == 0) {
                      {
#line 3561
                      while (1) {
                        while_continue___26: /* CIL Label */ ;
                        {
#line 3561
                        tmp___34 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
                        }
#line 3561
                        if (tmp___34) {
#line 3561
                          i = 0;
                          {
#line 3561
                          while (1) {
                            while_continue___27: /* CIL Label */ ;
#line 3561
                            if (! (i < 256)) {
#line 3561
                              goto while_break___27;
                            }
                            {
#line 3561
                            tmp___32 = __ctype_b_loc();
                            }
#line 3561
                            if ((int const   )*(*tmp___32 + i) & 32768) {
                              {
#line 3561
                              bitset_set(sbcset, (Idx )*(trans + i));
                              }
                            }
#line 3561
                            i ++;
                          }
                          while_break___27: /* CIL Label */ ;
                          }
                        } else {
#line 3561
                          i = 0;
                          {
#line 3561
                          while (1) {
                            while_continue___28: /* CIL Label */ ;
#line 3561
                            if (! (i < 256)) {
#line 3561
                              goto while_break___28;
                            }
                            {
#line 3561
                            tmp___33 = __ctype_b_loc();
                            }
#line 3561
                            if ((int const   )*(*tmp___33 + i) & 32768) {
                              {
#line 3561
                              bitset_set(sbcset, (Idx )i);
                              }
                            }
#line 3561
                            i ++;
                          }
                          while_break___28: /* CIL Label */ ;
                          }
                        }
#line 3561
                        goto while_break___26;
                      }
                      while_break___26: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 3562
                      tmp___42 = strcmp(name, "punct");
                      }
#line 3562
                      if (tmp___42 == 0) {
                        {
#line 3563
                        while (1) {
                          while_continue___29: /* CIL Label */ ;
                          {
#line 3563
                          tmp___37 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
                          }
#line 3563
                          if (tmp___37) {
#line 3563
                            i = 0;
                            {
#line 3563
                            while (1) {
                              while_continue___30: /* CIL Label */ ;
#line 3563
                              if (! (i < 256)) {
#line 3563
                                goto while_break___30;
                              }
                              {
#line 3563
                              tmp___35 = __ctype_b_loc();
                              }
#line 3563
                              if ((int const   )*(*tmp___35 + i) & 4) {
                                {
#line 3563
                                bitset_set(sbcset, (Idx )*(trans + i));
                                }
                              }
#line 3563
                              i ++;
                            }
                            while_break___30: /* CIL Label */ ;
                            }
                          } else {
#line 3563
                            i = 0;
                            {
#line 3563
                            while (1) {
                              while_continue___31: /* CIL Label */ ;
#line 3563
                              if (! (i < 256)) {
#line 3563
                                goto while_break___31;
                              }
                              {
#line 3563
                              tmp___36 = __ctype_b_loc();
                              }
#line 3563
                              if ((int const   )*(*tmp___36 + i) & 4) {
                                {
#line 3563
                                bitset_set(sbcset, (Idx )i);
                                }
                              }
#line 3563
                              i ++;
                            }
                            while_break___31: /* CIL Label */ ;
                            }
                          }
#line 3563
                          goto while_break___29;
                        }
                        while_break___29: /* CIL Label */ ;
                        }
                      } else {
                        {
#line 3564
                        tmp___41 = strcmp(name, "xdigit");
                        }
#line 3564
                        if (tmp___41 == 0) {
                          {
#line 3565
                          while (1) {
                            while_continue___32: /* CIL Label */ ;
                            {
#line 3565
                            tmp___40 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
                            }
#line 3565
                            if (tmp___40) {
#line 3565
                              i = 0;
                              {
#line 3565
                              while (1) {
                                while_continue___33: /* CIL Label */ ;
#line 3565
                                if (! (i < 256)) {
#line 3565
                                  goto while_break___33;
                                }
                                {
#line 3565
                                tmp___38 = __ctype_b_loc();
                                }
#line 3565
                                if ((int const   )*(*tmp___38 + i) & 4096) {
                                  {
#line 3565
                                  bitset_set(sbcset, (Idx )*(trans + i));
                                  }
                                }
#line 3565
                                i ++;
                              }
                              while_break___33: /* CIL Label */ ;
                              }
                            } else {
#line 3565
                              i = 0;
                              {
#line 3565
                              while (1) {
                                while_continue___34: /* CIL Label */ ;
#line 3565
                                if (! (i < 256)) {
#line 3565
                                  goto while_break___34;
                                }
                                {
#line 3565
                                tmp___39 = __ctype_b_loc();
                                }
#line 3565
                                if ((int const   )*(*tmp___39 + i) & 4096) {
                                  {
#line 3565
                                  bitset_set(sbcset, (Idx )i);
                                  }
                                }
#line 3565
                                i ++;
                              }
                              while_break___34: /* CIL Label */ ;
                              }
                            }
#line 3565
                            goto while_break___32;
                          }
                          while_break___32: /* CIL Label */ ;
                          }
                        } else {
#line 3567
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3569
  return ((reg_errcode_t )0);
}
}
#line 3572 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bin_tree_t *mbc_tree ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 3581
  alloc = (Idx )0;
#line 3587
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3587
  sbcset = (re_bitset_ptr_t )tmp;
#line 3589
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3589
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3593
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3593
    tmp___1 = 1;
  } else
#line 3593
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3593
    tmp___1 = 1;
  } else {
#line 3593
    tmp___1 = 0;
  }
  {
#line 3593
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 3593
  if (tmp___2) {
#line 3598
    *err = (reg_errcode_t )12;
#line 3599
    return ((bin_tree_t *)((void *)0));
  }
#line 3602
  if (non_match) {
#line 3605
    mbcset->non_match = 1U;
  }
  {
#line 3610
  ret = build_charclass(trans, (bitset_word_t *)sbcset, mbcset, & alloc, class_name,
                        (reg_syntax_t )0);
#line 3616
  tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 3616
  if (tmp___3) {
    {
#line 3618
    free((void *)sbcset);
#line 3620
    free_charset(mbcset);
#line 3622
    *err = ret;
    }
#line 3623
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3626
    if (! *extra) {
#line 3626
      goto while_break;
    }
    {
#line 3627
    bitset_set((bitset_word_t *)sbcset, (Idx )*extra);
#line 3626
    extra ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3630
  if (non_match) {
    {
#line 3631
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3635
  if (dfa->mb_cur_max > 1) {
    {
#line 3636
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
  {
#line 3640
  br_token.type = (re_token_type_t )3;
#line 3641
  br_token.opr.sbcset = sbcset;
#line 3642
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
#line 3643
  tmp___4 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 3643
  if (tmp___4) {
#line 3644
    goto build_word_op_espace;
  }
#line 3647
  if (dfa->mb_cur_max > 1) {
    {
#line 3651
    br_token.type = (re_token_type_t )6;
#line 3652
    br_token.opr.mbcset = mbcset;
#line 3653
    dfa->has_mb_node = 1U;
#line 3654
    mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3655
    tmp___5 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 3655
    if (tmp___5) {
#line 3656
      goto build_word_op_espace;
    }
    {
#line 3658
    tree = create_tree(dfa, tree, mbc_tree, (re_token_type_t )10);
#line 3659
    tmp___6 = __builtin_expect((long )((unsigned long )mbc_tree != (unsigned long )((void *)0)),
                               1L);
    }
#line 3659
    if (tmp___6) {
#line 3660
      return (tree);
    }
  } else {
    {
#line 3664
    free_charset(mbcset);
    }
#line 3665
    return (tree);
  }
  build_word_op_espace: 
  {
#line 3672
  free((void *)sbcset);
#line 3674
  free_charset(mbcset);
#line 3676
  *err = (reg_errcode_t )12;
  }
#line 3677
  return ((bin_tree_t *)((void *)0));
}
}
#line 3685 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  Idx num ;
  unsigned char c ;
  long tmp ;
  Idx tmp___0 ;

  {
#line 3688
  num = (Idx )-1;
  {
#line 3690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3692
    fetch_token(token, input, syntax);
#line 3693
    c = token->opr.c;
#line 3694
    tmp = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3694
    if (tmp) {
#line 3695
      return ((Idx )-2);
    }
#line 3696
    if ((unsigned int )token->type == 24U) {
#line 3697
      goto while_break;
    } else
#line 3696
    if ((int )c == 44) {
#line 3697
      goto while_break;
    }
#line 3698
    if ((unsigned int )token->type != 1U) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if ((int )c < 48) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if (57 < (int )c) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if (num == 0xfffffffffffffffeUL) {
#line 3698
      num = (Idx )-2;
    } else {
#line 3698
      if (num == 0xffffffffffffffffUL) {
#line 3698
        tmp___0 = (Idx )((int )c - 48);
      } else {
#line 3698
        tmp___0 = (num * 10UL + (Idx )c) - 48UL;
      }
#line 3698
      num = tmp___0;
    }
#line 3702
    if (num > 32767UL) {
#line 3702
      num = (Idx )-2;
    } else {
#line 3702
      num = num;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3704
  return (num);
}
}
#line 3708 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 


  {
  {
#line 3711
  free((void *)cset->mbchars);
#line 3718
  free((void *)cset->char_classes);
#line 3719
  free((void *)cset);
  }
#line 3720
  return;
}
}
#line 3727 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp ;

  {
  {
#line 3732
  t.type = type;
#line 3733
  tmp = create_token_tree(dfa, left, right, (re_token_t const   *)(& t));
  }
#line 3733
  return (tmp);
}
}
#line 3736 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3741
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
  }
#line 3741
  if (tmp___0) {
    {
#line 3743
    tmp = malloc(sizeof(bin_tree_storage_t ));
#line 3743
    storage = (bin_tree_storage_t *)tmp;
    }
#line 3745
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
#line 3746
      return ((bin_tree_t *)((void *)0));
    }
#line 3747
    storage->next = dfa->str_tree_storage;
#line 3748
    dfa->str_tree_storage = storage;
#line 3749
    dfa->str_tree_storage_idx = 0;
  }
#line 3751
  tmp___1 = dfa->str_tree_storage_idx;
#line 3751
  (dfa->str_tree_storage_idx) ++;
#line 3751
  tree = & (dfa->str_tree_storage)->data[tmp___1];
#line 3753
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3754
  tree->left = left;
#line 3755
  tree->right = right;
#line 3756
  tree->token = (re_token_t )*token;
#line 3757
  tree->token.duplicated = 0U;
#line 3758
  tree->token.opt_subexp = 0U;
#line 3759
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3760
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3761
  tree->node_idx = (Idx )-1;
#line 3763
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3764
    left->parent = tree;
  }
#line 3765
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3766
    right->parent = tree;
  }
#line 3767
  return (tree);
}
}
#line 3773 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ 
  Idx idx ;

  {
#line 3776
  idx = (Idx )((long )extra);
#line 3777
  if ((unsigned int )node->token.type == 17U) {
#line 3777
    if (node->token.opr.idx == idx) {
#line 3778
      node->token.opt_subexp = 1U;
    }
  }
#line 3780
  return ((reg_errcode_t )0);
}
}
#line 3785 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_token(re_token_t *node ) 
{ 


  {
#line 3789
  if ((unsigned int )node->type == 6U) {
#line 3789
    if (node->duplicated == 0U) {
      {
#line 3790
      free_charset(node->opr.mbcset);
      }
    } else {
#line 3789
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3793
  if ((unsigned int )node->type == 3U) {
#line 3793
    if (node->duplicated == 0U) {
      {
#line 3794
      free((void *)node->opr.sbcset);
      }
    }
  }
#line 3795
  return;
}
}
#line 3800 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 3803
  free_token(& node->token);
  }
#line 3804
  return ((reg_errcode_t )0);
}
}
#line 3813 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3818
  p_new = & dup_root;
#line 3818
  dup_node = (bin_tree_t *)root->parent;
#line 3820
  node = root;
  {
#line 3820
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3823
    *p_new = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
    }
#line 3824
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
#line 3825
      return ((bin_tree_t *)((void *)0));
    }
#line 3826
    (*p_new)->parent = dup_node;
#line 3827
    (*p_new)->token.duplicated = 1U;
#line 3828
    dup_node = *p_new;
#line 3831
    if (node->left) {
#line 3833
      node = (bin_tree_t const   *)node->left;
#line 3834
      p_new = & dup_node->left;
    } else {
#line 3838
      prev = (bin_tree_t const   *)((void *)0);
      {
#line 3839
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3839
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 3839
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 3839
            goto while_break___0;
          }
        }
#line 3841
        prev = node;
#line 3842
        node = (bin_tree_t const   *)node->parent;
#line 3843
        dup_node = dup_node->parent;
#line 3844
        if (! node) {
#line 3845
          return (dup_root);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3847
      node = (bin_tree_t const   *)node->right;
#line 3848
      p_new = & dup_node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) ;
#line 23
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 24
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 25
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) ;
#line 28
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) ;
#line 30
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) ;
#line 32
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) ;
#line 35
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) ;
#line 39
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) ;
#line 44
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) ;
#line 50
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) ;
#line 55
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) ;
#line 58
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) ;
#line 60
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) ;
#line 62
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state___0 ,
                                    Idx idx ) ;
#line 65
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) ;
#line 68
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) ;
#line 73
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) ;
#line 77
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 81
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) ;
#line 86
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 89
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) ;
#line 93
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) ;
#line 98
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 102
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) ;
#line 106
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) ;
#line 110
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) ;
#line 114
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) ;
#line 120
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) ;
#line 124
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) ;
#line 128
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) ;
#line 130
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state___0 ) ;
#line 133
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) ;
#line 137
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) ;
#line 147
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 151
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 154
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) ;
#line 157
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) ;
#line 162
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) ;
#line 164
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) ;
#line 168
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 173
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) ;
#line 177
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) ;
#line 181
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) ;
#line 185
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state___0 ) ;
#line 188
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) ;
#line 197
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state___0 ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 201
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) ;
#line 204
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) ;
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  Idx start ;
  Idx length ;

  {
#line 237
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
#line 238
    return (2);
  }
#line 240
  if (eflags & (1 << 2)) {
#line 242
    start = (Idx )(pmatch + 0)->rm_so;
#line 243
    length = (Idx )(pmatch + 0)->rm_eo;
  } else {
    {
#line 247
    start = (Idx )0;
#line 248
    length = strlen((char const   *)string);
    }
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (preg->no_sub) {
    {
#line 253
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, (size_t )0, (regmatch_t *)((void *)0),
                             eflags);
    }
  } else {
    {
#line 256
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, nmatch, (regmatch_t *)pmatch,
                             eflags);
    }
  }
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  return ((int )err != 0);
}
}
#line 311 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
  {
#line 318
  tmp = re_search_stub(bufp, string, length, start, (regoff_t )0, length, regs, (_Bool)1);
  }
#line 318
  return (tmp);
}
}
#line 324 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
  {
#line 332
  tmp = re_search_stub(bufp, string, length, start, range, length, regs, (_Bool)0);
  }
#line 332
  return (tmp);
}
}
#line 339 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) 
{ 
  regoff_t tmp ;

  {
  {
#line 346
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, (regoff_t )0,
                         regs, stop, (_Bool)1);
  }
#line 346
  return (tmp);
}
}
#line 353 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) 
{ 
  regoff_t tmp ;

  {
  {
#line 361
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range, regs,
                         stop, (_Bool)0);
  }
#line 361
  return (tmp);
}
}
#line 368 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) 
{ 
  char const   *str ;
  regoff_t rval ;
  Idx len ;
  char *s ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 378
  len = length1 + length2;
#line 379
  s = (char *)((void *)0);
#line 381
  if (length1 < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (length2 < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (stop < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (len < length1) {
#line 381
    tmp = 1;
  } else {
#line 381
    tmp = 0;
  }
  {
#line 381
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 381
  if (tmp___0) {
#line 382
    return ((regoff_t )-2);
  }
#line 385
  if (length2 > 0UL) {
#line 386
    if (length1 > 0UL) {
      {
#line 388
      tmp___1 = malloc(len * sizeof(char ));
#line 388
      s = (char *)tmp___1;
#line 390
      tmp___2 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
      }
#line 390
      if (tmp___2) {
#line 391
        return ((regoff_t )-2);
      }
      {
#line 395
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string1,
             length1);
#line 396
      memcpy((void */* __restrict  */)(s + length1), (void const   */* __restrict  */)string2,
             length2);
#line 398
      str = (char const   *)s;
      }
    } else {
#line 401
      str = string2;
    }
  } else {
#line 403
    str = string1;
  }
  {
#line 405
  rval = re_search_stub(bufp, str, len, start, range, stop, regs, ret_len);
#line 407
  free((void *)s);
  }
#line 408
  return (rval);
}
}
#line 416 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  Idx nregs ;
  regoff_t rval ;
  int eflags ;
  Idx last_start ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___15 ;

  {
#line 427
  eflags = 0;
#line 431
  last_start = start + (Idx )range;
#line 434
  if (start < 0UL) {
#line 434
    tmp = 1;
  } else
#line 434
  if (start > length) {
#line 434
    tmp = 1;
  } else {
#line 434
    tmp = 0;
  }
  {
#line 434
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 434
  if (tmp___0) {
#line 435
    return ((regoff_t )-1);
  }
#line 436
  if (length < last_start) {
#line 436
    tmp___3 = 1;
  } else
#line 436
  if (0L <= range) {
#line 436
    if (last_start < start) {
#line 436
      tmp___3 = 1;
    } else {
#line 436
      tmp___3 = 0;
    }
  } else {
#line 436
    tmp___3 = 0;
  }
  {
#line 436
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 436
  if (tmp___4) {
#line 437
    last_start = length;
  } else {
#line 438
    if (last_start < 0UL) {
#line 438
      tmp___1 = 1;
    } else
#line 438
    if (range < 0L) {
#line 438
      if (start <= last_start) {
#line 438
        tmp___1 = 1;
      } else {
#line 438
        tmp___1 = 0;
      }
    } else {
#line 438
      tmp___1 = 0;
    }
    {
#line 438
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 438
    if (tmp___2) {
#line 439
      last_start = (Idx )0;
    }
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (bufp->not_bol) {
#line 443
    tmp___5 = 1;
  } else {
#line 443
    tmp___5 = 0;
  }
#line 443
  eflags |= tmp___5;
#line 444
  if (bufp->not_eol) {
#line 444
    tmp___6 = 1 << 1;
  } else {
#line 444
    tmp___6 = 0;
  }
#line 444
  eflags |= tmp___6;
#line 447
  if (start < last_start) {
#line 447
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 447
      if (! bufp->fastmap_accurate) {
        {
#line 448
        rpl_re_compile_fastmap(bufp);
        }
      }
    }
  }
  {
#line 450
  tmp___7 = __builtin_expect((long )bufp->no_sub, 0L);
  }
#line 450
  if (tmp___7) {
#line 451
    regs = (struct re_registers *)((void *)0);
  }
#line 454
  if ((unsigned long )regs == (unsigned long )((void *)0)) {
#line 455
    nregs = (Idx )1;
  } else {
#line 456
    if (bufp->regs_allocated == 2U) {
#line 456
      if (regs->num_regs <= bufp->re_nsub) {
#line 456
        tmp___9 = 1;
      } else {
#line 456
        tmp___9 = 0;
      }
    } else {
#line 456
      tmp___9 = 0;
    }
    {
#line 456
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 456
    if (tmp___10) {
      {
#line 459
      nregs = regs->num_regs;
#line 460
      tmp___8 = __builtin_expect((long )(nregs < 1UL), 0L);
      }
#line 460
      if (tmp___8) {
#line 463
        regs = (struct re_registers *)((void *)0);
#line 464
        nregs = (Idx )1;
      }
    } else {
#line 468
      nregs = bufp->re_nsub + 1UL;
    }
  }
  {
#line 469
  tmp___11 = malloc(nregs * sizeof(regmatch_t ));
#line 469
  pmatch = (regmatch_t *)tmp___11;
#line 470
  tmp___12 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
#line 470
  if (tmp___12) {
#line 472
    rval = (regoff_t )-2;
#line 473
    goto out;
  }
  {
#line 476
  result = re_search_internal((regex_t const   *)bufp, string, length, start, last_start,
                              stop, nregs, pmatch, eflags);
#line 479
  rval = (regoff_t )0;
  }
#line 482
  if ((int )result != 0) {
#line 483
    rval = (regoff_t )-1;
  } else
#line 484
  if ((unsigned long )regs != (unsigned long )((void *)0)) {
    {
#line 487
    bufp->regs_allocated = re_copy_regs(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 489
    tmp___13 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
#line 489
    if (tmp___13) {
#line 490
      rval = (regoff_t )-2;
    }
  }
  {
#line 493
  tmp___15 = __builtin_expect((long )(rval == 0L), 1L);
  }
#line 493
  if (tmp___15) {
#line 495
    if (ret_len) {
#line 497
      if (! ((Idx )(pmatch + 0)->rm_so == start)) {
        {
#line 497
        __assert_fail("pmatch[0].rm_so == start", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                      497U, "re_search_stub");
        }
      }
#line 498
      rval = (regoff_t )((Idx )(pmatch + 0)->rm_eo - start);
    } else {
#line 501
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
#line 503
  free((void *)pmatch);
  }
  out: 
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 505
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  return (rval);
}
}
#line 509 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) 
{ 
  int rval ;
  Idx i ;
  Idx need_regs ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  regoff_t *new_start ;
  void *tmp___3 ;
  regoff_t *new_end ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  regoff_t tmp___10 ;

  {
#line 514
  rval = 1;
#line 516
  need_regs = nregs + 1UL;
#line 521
  if (regs_allocated == 0) {
    {
#line 523
    tmp = malloc(need_regs * sizeof(regoff_t ));
#line 523
    regs->start = (regoff_t *)tmp;
#line 524
    tmp___0 = __builtin_expect((long )((unsigned long )regs->start == (unsigned long )((void *)0)),
                               0L);
    }
#line 524
    if (tmp___0) {
#line 525
      return (0U);
    }
    {
#line 526
    tmp___1 = malloc(need_regs * sizeof(regoff_t ));
#line 526
    regs->end = (regoff_t *)tmp___1;
#line 527
    tmp___2 = __builtin_expect((long )((unsigned long )regs->end == (unsigned long )((void *)0)),
                               0L);
    }
#line 527
    if (tmp___2) {
      {
#line 529
      free((void *)regs->start);
      }
#line 530
      return (0U);
    }
#line 532
    regs->num_regs = need_regs;
  } else
#line 534
  if (regs_allocated == 1) {
    {
#line 538
    tmp___7 = __builtin_expect((long )(need_regs > regs->num_regs), 0L);
    }
#line 538
    if (tmp___7) {
      {
#line 540
      tmp___3 = realloc((void *)regs->start, need_regs * sizeof(regoff_t ));
#line 540
      new_start = (regoff_t *)tmp___3;
#line 542
      tmp___4 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
      }
#line 542
      if (tmp___4) {
#line 543
        return (0U);
      }
      {
#line 544
      tmp___5 = realloc((void *)regs->end, need_regs * sizeof(regoff_t ));
#line 544
      new_end = (regoff_t *)tmp___5;
#line 545
      tmp___6 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                 0L);
      }
#line 545
      if (tmp___6) {
        {
#line 547
        free((void *)new_start);
        }
#line 548
        return (0U);
      }
#line 550
      regs->start = new_start;
#line 551
      regs->end = new_end;
#line 552
      regs->num_regs = need_regs;
    }
  } else {
#line 557
    if (! (regs_allocated == 2)) {
      {
#line 557
      __assert_fail("regs_allocated == REGS_FIXED", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    557U, "re_copy_regs");
      }
    }
#line 559
    if (! (regs->num_regs >= nregs)) {
      {
#line 559
      __assert_fail("regs->num_regs >= nregs", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    559U, "re_copy_regs");
      }
    }
#line 560
    rval = 2;
  }
#line 564
  i = (Idx )0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < nregs)) {
#line 564
      goto while_break;
    }
#line 566
    *(regs->start + i) = (pmatch + i)->rm_so;
#line 567
    *(regs->end + i) = (pmatch + i)->rm_eo;
#line 564
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 569
    if (! (i < regs->num_regs)) {
#line 569
      goto while_break___0;
    }
#line 570
    tmp___10 = (regoff_t )-1;
#line 570
    *(regs->end + i) = tmp___10;
#line 570
    *(regs->start + i) = tmp___10;
#line 569
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 572
  return ((unsigned int )rval);
}
}
#line 588 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
#line 595
  if (num_regs) {
#line 597
    bufp->regs_allocated = 1U;
#line 598
    regs->num_regs = num_regs;
#line 599
    regs->start = starts;
#line 600
    regs->end = ends;
  } else {
#line 604
    bufp->regs_allocated = 0U;
#line 605
    regs->num_regs = (__re_size_t )0;
#line 606
    tmp = (regoff_t *)((void *)0);
#line 606
    regs->end = tmp;
#line 606
    regs->start = tmp;
  }
#line 608
  return;
}
}
#line 639 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  Idx left_lim ;
  Idx right_lim ;
  int incr ;
  _Bool fl_longest_match ;
  int match_kind ;
  Idx match_first ;
  Idx match_last ;
  Idx extra_nmatch ;
  _Bool sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  unsigned char *t ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  __re_size_t offset ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  Idx *tmp___19 ;
  re_dfastate_t *pstate ;
  long tmp___20 ;
  long tmp___21 ;
  Idx reg_idx ;
  regoff_t tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;

  {
#line 648
  dfa = (re_dfa_t const   *)preg->buffer;
#line 654
  match_last = (Idx )-1;
#line 659
  mctx.input.raw_mbs = (unsigned char const   *)0;
#line 659
  mctx.input.mbs = (unsigned char *)0;
#line 659
  mctx.input.wcs = (wint_t *)0;
#line 659
  mctx.input.offsets = (Idx *)0;
#line 659
  mctx.input.cur_state.__count = 0;
#line 659
  mctx.input.cur_state.__value.__wch = 0U;
#line 659
  mctx.input.raw_mbs_idx = 0UL;
#line 659
  mctx.input.valid_len = 0UL;
#line 659
  mctx.input.valid_raw_len = 0UL;
#line 659
  mctx.input.bufs_len = 0UL;
#line 659
  mctx.input.cur_idx = 0UL;
#line 659
  mctx.input.raw_len = 0UL;
#line 659
  mctx.input.len = 0UL;
#line 659
  mctx.input.raw_stop = 0UL;
#line 659
  mctx.input.stop = 0UL;
#line 659
  mctx.input.tip_context = 0U;
#line 659
  mctx.input.trans = (unsigned char *)0;
#line 659
  mctx.input.word_char = (bitset_word_t const   *)0;
#line 659
  mctx.input.icase = (unsigned char)0;
#line 659
  mctx.input.is_utf8 = (unsigned char)0;
#line 659
  mctx.input.map_notascii = (unsigned char)0;
#line 659
  mctx.input.mbs_allocated = (unsigned char)0;
#line 659
  mctx.input.offsets_needed = (unsigned char)0;
#line 659
  mctx.input.newline_anchor = (unsigned char)0;
#line 659
  mctx.input.word_ops_used = (unsigned char)0;
#line 659
  mctx.input.mb_cur_max = 0;
#line 659
  mctx.dfa = dfa;
#line 659
  mctx.eflags = 0;
#line 659
  mctx.match_last = 0UL;
#line 659
  mctx.last_node = 0UL;
#line 659
  mctx.state_log = (re_dfastate_t **)0;
#line 659
  mctx.state_log_top = 0UL;
#line 659
  mctx.nbkref_ents = 0UL;
#line 659
  mctx.abkref_ents = 0UL;
#line 659
  mctx.bkref_ents = (struct re_backref_cache_entry *)0;
#line 659
  mctx.max_mb_elem_len = 0;
#line 659
  mctx.nsub_tops = 0UL;
#line 659
  mctx.asub_tops = 0UL;
#line 659
  mctx.sub_tops = (re_sub_match_top_t **)0;
#line 663
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 663
    if (preg->fastmap_accurate) {
#line 663
      if (start != last_start) {
#line 663
        if (! preg->can_be_null) {
#line 663
          tmp = preg->fastmap;
        } else {
#line 663
          tmp = (char */* const  */)((void *)0);
        }
      } else {
#line 663
        tmp = (char */* const  */)((void *)0);
      }
    } else {
#line 663
      tmp = (char */* const  */)((void *)0);
    }
  } else {
#line 663
    tmp = (char */* const  */)((void *)0);
  }
#line 663
  fastmap = (char *)tmp;
#line 666
  t = (unsigned char *)preg->translate;
#line 673
  if (nmatch > (size_t )preg->re_nsub) {
#line 673
    extra_nmatch = nmatch - (size_t )(preg->re_nsub + 1UL);
  } else {
#line 673
    extra_nmatch = (Idx )0;
  }
#line 674
  nmatch -= extra_nmatch;
#line 677
  if (preg->used == 0UL) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else {
#line 677
    tmp___0 = 0;
  }
  {
#line 677
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 677
  if (tmp___1) {
#line 680
    return ((reg_errcode_t )1);
  }
#line 690
  if ((dfa->init_state)->nodes.nelem == 0UL) {
#line 690
    if ((dfa->init_state_word)->nodes.nelem == 0UL) {
#line 690
      if ((dfa->init_state_nl)->nodes.nelem == 0UL) {
#line 690
        goto _L;
      } else
#line 690
      if (! preg->newline_anchor) {
        _L: /* CIL Label */ 
#line 695
        if (start != 0UL) {
#line 695
          if (last_start != 0UL) {
#line 696
            return ((reg_errcode_t )1);
          }
        }
#line 697
        last_start = (Idx )0;
#line 697
        start = last_start;
      }
    }
  }
#line 701
  if (nmatch != 0UL) {
#line 701
    tmp___2 = 1;
  } else
#line 701
  if (dfa->nbackref) {
#line 701
    tmp___2 = 1;
  } else {
#line 701
    tmp___2 = 0;
  }
  {
#line 701
  fl_longest_match = (_Bool )tmp___2;
#line 703
  err = re_string_allocate(& mctx.input, string, length, (Idx )(dfa->nodes_len + 1UL),
                           (unsigned char *)preg->translate, (_Bool )((preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                           dfa);
#line 706
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 706
  if (tmp___3) {
#line 707
    goto free_return;
  }
  {
#line 708
  mctx.input.stop = stop;
#line 709
  mctx.input.raw_stop = stop;
#line 710
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 712
  err = match_ctx_init(& mctx, eflags, (Idx )(dfa->nbackref * 2UL));
#line 713
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 713
  if (tmp___4) {
#line 714
    goto free_return;
  }
#line 720
  if (nmatch > 1UL) {
#line 720
    goto _L___0;
  } else
#line 720
  if (dfa->has_mb_node) {
    _L___0: /* CIL Label */ 
    {
#line 723
    tmp___5 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= mctx.input.bufs_len),
                               0L);
    }
#line 723
    if (tmp___5) {
#line 725
      err = (reg_errcode_t )12;
#line 726
      goto free_return;
    }
    {
#line 729
    tmp___6 = malloc((mctx.input.bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 729
    mctx.state_log = (re_dfastate_t **)tmp___6;
#line 730
    tmp___7 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
#line 730
    if (tmp___7) {
#line 732
      err = (reg_errcode_t )12;
#line 733
      goto free_return;
    }
  } else {
#line 737
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 739
  match_first = start;
#line 740
  if (eflags & 1) {
#line 740
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 740
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 744
  if (last_start < start) {
#line 744
    incr = -1;
  } else {
#line 744
    incr = 1;
  }
#line 745
  if (last_start < start) {
#line 745
    left_lim = last_start;
  } else {
#line 745
    left_lim = start;
  }
#line 746
  if (last_start < start) {
#line 746
    right_lim = start;
  } else {
#line 746
    right_lim = last_start;
  }
#line 747
  sb = (_Bool )(dfa->mb_cur_max == 1);
#line 748
  if (fastmap) {
#line 748
    if (sb) {
#line 748
      tmp___8 = 4;
    } else
#line 748
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 748
      tmp___8 = 0;
    } else
#line 748
    if (t) {
#line 748
      tmp___8 = 0;
    } else {
#line 748
      tmp___8 = 4;
    }
#line 748
    if (start <= last_start) {
#line 748
      tmp___9 = 2;
    } else {
#line 748
      tmp___9 = 0;
    }
#line 748
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 748
      tmp___10 = 1;
    } else {
#line 748
      tmp___10 = 0;
    }
#line 748
    match_kind = (tmp___8 | tmp___9) | tmp___10;
  } else {
#line 748
    match_kind = 8;
  }
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    err = (reg_errcode_t )1;
#line 758
    if (match_first < left_lim) {
#line 759
      goto free_return;
    } else
#line 758
    if (right_lim < match_first) {
#line 759
      goto free_return;
    }
    {
#line 768
    if (match_kind == 8) {
#line 768
      goto case_8;
    }
#line 772
    if (match_kind == 7) {
#line 772
      goto case_7;
    }
#line 779
    if (match_kind == 6) {
#line 779
      goto case_6;
    }
#line 796
    if (match_kind == 5) {
#line 796
      goto case_5;
    }
#line 796
    if (match_kind == 4) {
#line 796
      goto case_5;
    }
#line 810
    goto switch_default;
    case_8: /* CIL Label */ 
#line 770
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 774
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 774
      tmp___11 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 774
      if (tmp___11) {
#line 774
        if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 774
          goto while_break___0;
        }
      } else {
#line 774
        goto while_break___0;
      }
#line 776
      match_first ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 777
    goto forward_match_found_start_or_reached_end;
    case_6: /* CIL Label */ 
    {
#line 781
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 781
      tmp___12 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 781
      if (tmp___12) {
#line 781
        if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 781
          goto while_break___1;
        }
      } else {
#line 781
        goto while_break___1;
      }
#line 783
      match_first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    forward_match_found_start_or_reached_end: 
    {
#line 786
    tmp___14 = __builtin_expect((long )(match_first == right_lim), 0L);
    }
#line 786
    if (tmp___14) {
#line 788
      if (match_first >= length) {
#line 788
        ch = 0;
      } else {
#line 788
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 790
      if (t) {
#line 790
        tmp___13 = (int )*(t + ch);
      } else {
#line 790
        tmp___13 = ch;
      }
#line 790
      if (! *(fastmap + tmp___13)) {
#line 791
        goto free_return;
      }
    }
#line 793
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 798
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 798
      if (! (match_first >= left_lim)) {
#line 798
        goto while_break___2;
      }
#line 800
      if (match_first >= length) {
#line 800
        ch = 0;
      } else {
#line 800
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 802
      if (t) {
#line 802
        tmp___15 = (int )*(t + ch);
      } else {
#line 802
        tmp___15 = ch;
      }
#line 802
      if (*(fastmap + tmp___15)) {
#line 803
        goto while_break___2;
      }
#line 804
      match_first --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 806
    if (match_first < left_lim) {
#line 807
      goto free_return;
    }
#line 808
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 814
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 818
      offset = match_first - mctx.input.raw_mbs_idx;
#line 819
      tmp___17 = __builtin_expect((long )(offset >= mctx.input.valid_raw_len), 0L);
      }
#line 819
      if (tmp___17) {
        {
#line 821
        err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 823
        tmp___16 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 823
        if (tmp___16) {
#line 824
          goto free_return;
        }
#line 826
        offset = match_first - mctx.input.raw_mbs_idx;
      }
#line 830
      if (match_first >= length) {
#line 830
        ch = 0;
      } else {
#line 830
        ch = (int )*(mctx.input.mbs + offset);
      }
#line 832
      if (*(fastmap + ch)) {
#line 833
        goto while_break___3;
      }
#line 834
      match_first += (Idx )incr;
#line 835
      if (match_first < left_lim) {
#line 837
        err = (reg_errcode_t )1;
#line 838
        goto free_return;
      } else
#line 835
      if (match_first > right_lim) {
#line 837
        err = (reg_errcode_t )1;
#line 838
        goto free_return;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 841
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 846
    err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 847
    tmp___18 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 847
    if (tmp___18) {
#line 848
      goto free_return;
    }
#line 853
    if (! sb) {
#line 853
      if (! (0UL == mctx.input.valid_len)) {
#line 853
        if (! (*(mctx.input.wcs + 0) != 4294967295U)) {
#line 854
          goto __Cont;
        }
      }
    }
#line 859
    mctx.max_mb_elem_len = 0;
#line 859
    mctx.nbkref_ents = (Idx )mctx.max_mb_elem_len;
#line 859
    mctx.state_log_top = mctx.nbkref_ents;
#line 860
    if (start <= last_start) {
#line 860
      tmp___19 = & match_first;
    } else {
#line 860
      tmp___19 = (Idx *)((void *)0);
    }
    {
#line 860
    match_last = check_matching(& mctx, fl_longest_match, tmp___19);
    }
#line 862
    if (match_last != 0xffffffffffffffffUL) {
      {
#line 864
      tmp___21 = __builtin_expect((long )(match_last == 0xfffffffffffffffeUL), 0L);
      }
#line 864
      if (tmp___21) {
#line 866
        err = (reg_errcode_t )12;
#line 867
        goto free_return;
      } else {
#line 871
        mctx.match_last = match_last;
#line 872
        if (! preg->no_sub) {
#line 872
          if (nmatch > 1UL) {
            {
#line 874
            pstate = *(mctx.state_log + match_last);
#line 875
            mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                      (re_dfastate_t const   *)pstate,
                                                      match_last);
            }
          } else {
#line 872
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 872
        if (dfa->nbackref) {
          {
#line 874
          pstate = *(mctx.state_log + match_last);
#line 875
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
          }
        }
#line 878
        if (! preg->no_sub) {
#line 878
          if (nmatch > 1UL) {
#line 878
            if (dfa->has_plural_match) {
#line 878
              goto _L___2;
            } else {
#line 878
              goto _L___4;
            }
          } else {
#line 878
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 878
        if (dfa->nbackref) {
          _L___2: /* CIL Label */ 
          {
#line 881
          err = prune_impossible_nodes(& mctx);
          }
#line 882
          if ((int )err == 0) {
#line 883
            goto while_break;
          }
          {
#line 884
          tmp___20 = __builtin_expect((long )((int )err != 1), 0L);
          }
#line 884
          if (tmp___20) {
#line 885
            goto free_return;
          }
#line 886
          match_last = (Idx )-1;
        } else {
#line 889
          goto while_break;
        }
      }
    }
    {
#line 893
    match_ctx_clean(& mctx);
    }
    __Cont: /* CIL Label */ 
#line 755
    match_first += (Idx )incr;
  }
  while_break: /* CIL Label */ ;
  }
#line 902
  if (nmatch > 0UL) {
#line 907
    reg_idx = (Idx )1;
    {
#line 907
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 907
      if (! (reg_idx < nmatch)) {
#line 907
        goto while_break___4;
      }
#line 908
      tmp___22 = (regoff_t )-1;
#line 908
      (pmatch + reg_idx)->rm_eo = tmp___22;
#line 908
      (pmatch + reg_idx)->rm_so = tmp___22;
#line 907
      reg_idx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 911
    (pmatch + 0)->rm_so = (regoff_t )0;
#line 912
    (pmatch + 0)->rm_eo = (regoff_t )mctx.match_last;
#line 917
    if (! preg->no_sub) {
#line 917
      if (nmatch > 1UL) {
#line 919
        if (dfa->has_plural_match) {
#line 919
          if (dfa->nbackref > 0UL) {
#line 919
            tmp___23 = 1;
          } else {
#line 919
            tmp___23 = 0;
          }
        } else {
#line 919
          tmp___23 = 0;
        }
        {
#line 919
        err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                       (_Bool )tmp___23);
#line 921
        tmp___24 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 921
        if (tmp___24) {
#line 922
          goto free_return;
        }
      }
    }
#line 928
    reg_idx = (Idx )0;
    {
#line 928
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 928
      if (! (reg_idx < nmatch)) {
#line 928
        goto while_break___5;
      }
#line 929
      if ((pmatch + reg_idx)->rm_so != -1L) {
        {
#line 932
        tmp___25 = __builtin_expect((long )((int )mctx.input.offsets_needed != 0),
                                    0L);
        }
#line 932
        if (tmp___25) {
#line 934
          if ((Idx )(pmatch + reg_idx)->rm_so == mctx.input.valid_len) {
#line 934
            (pmatch + reg_idx)->rm_so = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 934
            (pmatch + reg_idx)->rm_so = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_so);
          }
#line 938
          if ((Idx )(pmatch + reg_idx)->rm_eo == mctx.input.valid_len) {
#line 938
            (pmatch + reg_idx)->rm_eo = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 938
            (pmatch + reg_idx)->rm_eo = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_eo);
          }
        }
#line 946
        (pmatch + reg_idx)->rm_so = (regoff_t )((Idx )(pmatch + reg_idx)->rm_so + match_first);
#line 947
        (pmatch + reg_idx)->rm_eo = (regoff_t )((Idx )(pmatch + reg_idx)->rm_eo + match_first);
      }
#line 928
      reg_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 949
    reg_idx = (Idx )0;
    {
#line 949
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 949
      if (! (reg_idx < extra_nmatch)) {
#line 949
        goto while_break___6;
      }
#line 951
      (pmatch + (nmatch + reg_idx))->rm_so = (regoff_t )-1;
#line 952
      (pmatch + (nmatch + reg_idx))->rm_eo = (regoff_t )-1;
#line 949
      reg_idx ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 955
    if (dfa->subexp_map) {
#line 956
      reg_idx = (Idx )0;
      {
#line 956
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 956
        if (! (reg_idx + 1UL < nmatch)) {
#line 956
          goto while_break___7;
        }
#line 957
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
#line 959
          (pmatch + (reg_idx + 1UL))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_so;
#line 961
          (pmatch + (reg_idx + 1UL))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_eo;
        }
#line 956
        reg_idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  free_return: 
  {
#line 967
  free((void *)mctx.state_log);
  }
#line 968
  if (dfa->nbackref) {
    {
#line 969
    match_ctx_free(& mctx);
    }
  }
  {
#line 970
  re_string_destruct(& mctx.input);
  }
#line 971
  return (err);
}
}
#line 974 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx halt_node ;
  Idx match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 978
  dfa = mctx->dfa;
#line 982
  lim_states = (re_dfastate_t **)((void *)0);
#line 987
  match_last = mctx->match_last;
#line 988
  halt_node = mctx->last_node;
#line 991
  tmp = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= match_last),
                         0L);
  }
#line 991
  if (tmp) {
#line 992
    return ((reg_errcode_t )12);
  }
  {
#line 994
  tmp___0 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 994
  sifted_states = (re_dfastate_t **)tmp___0;
#line 995
  tmp___1 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
#line 995
  if (tmp___1) {
#line 997
    ret = (reg_errcode_t )12;
#line 998
    goto free_return;
  }
#line 1000
  if (dfa->nbackref) {
    {
#line 1002
    tmp___2 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 1002
    lim_states = (re_dfastate_t **)tmp___2;
#line 1003
    tmp___3 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 1003
    if (tmp___3) {
#line 1005
      ret = (reg_errcode_t )12;
#line 1006
      goto free_return;
    }
    {
#line 1008
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1010
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (match_last + 1UL));
#line 1012
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1014
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1015
      free((void *)sctx.limits.elems);
#line 1016
      tmp___4 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 1016
      if (tmp___4) {
#line 1017
        goto free_return;
      }
#line 1018
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 1019
        goto while_break;
      } else
#line 1018
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 1019
        goto while_break;
      }
      {
#line 1020
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1022
        match_last --;
#line 1023
        if (! (match_last < 0xfffffffffffffffeUL)) {
#line 1025
          ret = (reg_errcode_t )1;
#line 1026
          goto free_return;
        }
#line 1020
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
#line 1020
          if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 1020
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1030
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1034
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1UL);
#line 1036
    free((void *)lim_states);
#line 1037
    lim_states = (re_dfastate_t **)((void *)0);
#line 1038
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1038
    if (tmp___5) {
#line 1039
      goto free_return;
    }
  } else {
    {
#line 1043
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1044
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1045
    free((void *)sctx.limits.elems);
#line 1046
    tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1046
    if (tmp___6) {
#line 1047
      goto free_return;
    }
#line 1048
    if ((unsigned long )*(sifted_states + 0) == (unsigned long )((void *)0)) {
#line 1050
      ret = (reg_errcode_t )1;
#line 1051
      goto free_return;
    }
  }
  {
#line 1054
  free((void *)mctx->state_log);
#line 1055
  mctx->state_log = sifted_states;
#line 1056
  sifted_states = (re_dfastate_t **)((void *)0);
#line 1057
  mctx->last_node = halt_node;
#line 1058
  mctx->match_last = match_last;
#line 1059
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
#line 1061
  free((void *)sifted_states);
#line 1062
  free((void *)lim_states);
  }
#line 1063
  return (ret);
}
}
#line 1070 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context)(reg_errcode_t *err ,
                                                                                                re_match_context_t const   *mctx ,
                                                                                                Idx idx ) 
{ 
  re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
#line 1075
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1076
  if ((dfa->init_state)->has_constraint) {
    {
#line 1079
    context = re_string_context_at(& mctx->input, idx - 1UL, (int )mctx->eflags);
    }
#line 1080
    if (context & 1U) {
#line 1081
      return ((re_dfastate_t *)dfa->init_state_word);
    } else
#line 1082
    if (context == 0U) {
#line 1083
      return ((re_dfastate_t *)dfa->init_state);
    } else
#line 1084
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1084
      if (context & (unsigned int )(1 << 1)) {
#line 1085
        return ((re_dfastate_t *)dfa->init_state_begbuf);
      } else {
#line 1084
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1086
    if (context & (unsigned int )(1 << 1)) {
#line 1087
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else
#line 1088
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
#line 1091
      tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                     context);
      }
#line 1091
      return (tmp);
    } else {
#line 1097
      return ((re_dfastate_t *)dfa->init_state);
    }
  } else {
#line 1100
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
#line 1112 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx match ;
  Idx match_last ;
  Idx cur_str_idx ;
  re_dfastate_t *cur_state ;
  _Bool at_init_state ;
  Idx next_start_idx ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  long tmp___5 ;
  re_dfastate_t *old_state ;
  Idx next_char_idx ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  Idx tmp___12 ;

  {
  {
#line 1117
  dfa = mctx->dfa;
#line 1119
  match = (Idx )0;
#line 1120
  match_last = (Idx )-1;
#line 1121
  cur_str_idx = mctx->input.cur_idx;
#line 1123
  at_init_state = (_Bool )((unsigned long )p_match_first != (unsigned long )((void *)0));
#line 1124
  next_start_idx = cur_str_idx;
#line 1126
  err = (reg_errcode_t )0;
#line 1127
  cur_state = acquire_init_state_context(& err, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
#line 1129
  tmp___0 = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1129
  if (tmp___0) {
#line 1131
    if (! ((int )err == 12)) {
      {
#line 1131
      __assert_fail("err == REG_ESPACE", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    1131U, "check_matching");
      }
    }
#line 1132
    return ((Idx )-2);
  }
#line 1135
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 1137
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1141
    tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
    }
#line 1141
    if (tmp___3) {
      {
#line 1143
      at_init_state = (_Bool)0;
#line 1144
      err = check_subexp_matching_top(mctx, & cur_state->nodes, (Idx )0);
#line 1145
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1145
      if (tmp___1) {
#line 1146
        return ((Idx )err);
      }
#line 1148
      if (cur_state->has_backref) {
        {
#line 1150
        err = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1151
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1151
        if (tmp___2) {
#line 1152
          return ((Idx )err);
        }
      }
    }
  }
  {
#line 1158
  tmp___5 = __builtin_expect((long )cur_state->halt, 0L);
  }
#line 1158
  if (tmp___5) {
#line 1160
    if (! cur_state->has_constraint) {
#line 1160
      goto _L;
    } else {
      {
#line 1160
      tmp___4 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                         cur_str_idx);
      }
#line 1160
      if (tmp___4) {
        _L: /* CIL Label */ 
#line 1163
        if (! fl_longest_match) {
#line 1164
          return (cur_str_idx);
        } else {
#line 1167
          match_last = cur_str_idx;
#line 1168
          match = (Idx )1;
        }
      }
    }
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (! (mctx->input.stop <= mctx->input.cur_idx))) {
#line 1173
      goto while_break;
    }
    {
#line 1175
    old_state = cur_state;
#line 1176
    next_char_idx = mctx->input.cur_idx + 1UL;
#line 1178
    tmp___8 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
    }
#line 1178
    if (tmp___8) {
#line 1178
      goto _L___0;
    } else {
      {
#line 1178
      tmp___9 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
      }
#line 1178
      if (tmp___9) {
#line 1178
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: /* CIL Label */ 
          {
#line 1182
          err = extend_buffers(mctx);
#line 1183
          tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 1183
          if (tmp___7) {
#line 1185
            if (! ((int )err == 12)) {
              {
#line 1185
              __assert_fail("err == REG_ESPACE", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                            1185U, "check_matching");
              }
            }
#line 1186
            return ((Idx )-2);
          }
        }
      }
    }
    {
#line 1190
    cur_state = transit_state(& err, mctx, cur_state);
    }
#line 1191
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
      {
#line 1192
      cur_state = merge_state_with_log(& err, mctx, cur_state);
      }
    }
#line 1194
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
#line 1199
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1199
      if (tmp___10) {
#line 1200
        return ((Idx )-2);
      }
#line 1202
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1205
        goto while_break;
      } else
#line 1202
      if (match) {
#line 1202
        if (! fl_longest_match) {
#line 1205
          goto while_break;
        } else {
#line 1202
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1202
        cur_state = find_recover_state(& err, mctx);
        }
#line 1202
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1205
          goto while_break;
        }
      }
    }
    {
#line 1208
    tmp___11 = __builtin_expect((long )at_init_state, 0L);
    }
#line 1208
    if (tmp___11) {
#line 1210
      if ((unsigned long )old_state == (unsigned long )cur_state) {
#line 1211
        next_start_idx = next_char_idx;
      } else {
#line 1213
        at_init_state = (_Bool)0;
      }
    }
#line 1216
    if (cur_state->halt) {
#line 1220
      if (! cur_state->has_constraint) {
#line 1220
        goto _L___2;
      } else {
        {
#line 1220
        tmp___12 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                            mctx->input.cur_idx);
        }
#line 1220
        if (tmp___12) {
          _L___2: /* CIL Label */ 
#line 1225
          match_last = mctx->input.cur_idx;
#line 1226
          match = (Idx )1;
#line 1229
          p_match_first = (Idx *)((void *)0);
#line 1230
          if (! fl_longest_match) {
#line 1231
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  if (p_match_first) {
#line 1237
    *p_match_first += next_start_idx;
  }
#line 1239
  return (match_last);
}
}
#line 1244 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_halt_node_context(re_dfa_t const   *dfa , Idx node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1248
  type = (dfa->nodes + node)->type;
#line 1249
  constraint = (dfa->nodes + node)->constraint;
#line 1250
  if ((unsigned int )type != 2U) {
#line 1251
    return ((_Bool)0);
  }
#line 1252
  if (! constraint) {
#line 1253
    return ((_Bool)1);
  }
#line 1254
  if (constraint & 4U) {
#line 1254
    if (! (context & 1U)) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1254
  if (constraint & 8U) {
#line 1254
    if (context & 1U) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1254
  if (constraint & 32U) {
#line 1254
    if (! (context & (unsigned int )(1 << 1))) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1254
  if (constraint & 128U) {
#line 1254
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1255
      return ((_Bool)0);
    }
  }
#line 1256
  return ((_Bool)1);
}
}
#line 1263 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state___0 ,
                                    Idx idx ) 
{ 
  Idx i ;
  unsigned int context ;
  _Bool tmp ;

  {
  {
#line 1273
  context = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 1274
  i = (Idx )0;
  }
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1274
    if (! (i < (Idx )state___0->nodes.nelem)) {
#line 1274
      goto while_break;
    }
    {
#line 1275
    tmp = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state___0->nodes.elems + i),
                                  context);
    }
#line 1275
    if (tmp) {
#line 1276
      return (*(state___0->nodes.elems + i));
    }
#line 1274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return ((Idx )0);
}
}
#line 1285 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx proceed_next_node(re_match_context_t const   *mctx , Idx nregs , regmatch_t *regs ,
                             Idx *pidx , Idx node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa ;
  Idx i ;
  _Bool ok ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  Idx dest_node ;
  long tmp ;
  Idx candidate ;
  Idx __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx naccepted ;
  re_token_type_t type ;
  int tmp___3 ;
  Idx subexp_idx ;
  char *buf___1 ;
  int tmp___4 ;
  Idx dest_node___0 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  Idx dest_node___1 ;
  Idx __attribute__((__pure__))  tmp___7 ;
  _Bool tmp___8 ;

  {
#line 1291
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1294
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
    {
#line 1296
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1297
    edests = dfa->edests + node;
#line 1299
    ok = re_node_set_insert(eps_via_nodes, node);
#line 1300
    tmp = __builtin_expect((long )(! ok), 0L);
    }
#line 1300
    if (tmp) {
#line 1301
      return ((Idx )-2);
    }
#line 1304
    dest_node = (Idx )-1;
#line 1304
    i = (Idx )0;
    {
#line 1304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1304
      if (! (i < edests->nelem)) {
#line 1304
        goto while_break;
      }
      {
#line 1306
      candidate = *(edests->elems + i);
#line 1307
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
      }
#line 1307
      if (! tmp___0) {
#line 1308
        goto __Cont;
      }
#line 1309
      if (dest_node == 0xffffffffffffffffUL) {
#line 1310
        dest_node = candidate;
      } else {
        {
#line 1316
        tmp___2 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_node);
        }
#line 1316
        if (tmp___2) {
#line 1317
          return (candidate);
        } else
#line 1320
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
          {
#line 1320
          tmp___1 = push_fail_stack(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
          }
#line 1320
          if (tmp___1) {
#line 1323
            return ((Idx )-2);
          }
        }
#line 1326
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 1304
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1329
    return (dest_node);
  } else {
#line 1333
    naccepted = (Idx )0;
#line 1334
    type = (dfa->nodes + node)->type;
#line 1337
    if ((dfa->nodes + node)->accept_mb) {
      {
#line 1338
      tmp___3 = check_node_accept_bytes(dfa, node, & mctx->input, *pidx);
#line 1338
      naccepted = (Idx )tmp___3;
      }
    } else
#line 1341
    if ((unsigned int )type == 4U) {
#line 1343
      subexp_idx = (dfa->nodes + node)->opr.idx + 1UL;
#line 1344
      naccepted = (Idx )((regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so);
#line 1345
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1347
        if ((regs + subexp_idx)->rm_so == -1L) {
#line 1348
          return ((Idx )-1);
        } else
#line 1347
        if ((regs + subexp_idx)->rm_eo == -1L) {
#line 1348
          return ((Idx )-1);
        } else
#line 1349
        if (naccepted) {
          {
#line 1351
          buf___1 = (char *)mctx->input.mbs;
#line 1352
          tmp___4 = memcmp((void const   *)(buf___1 + (regs + subexp_idx)->rm_so),
                           (void const   *)(buf___1 + *pidx), naccepted);
          }
#line 1352
          if (tmp___4 != 0) {
#line 1354
            return ((Idx )-1);
          }
        }
      }
#line 1358
      if (naccepted == 0UL) {
        {
#line 1361
        ok = re_node_set_insert(eps_via_nodes, node);
#line 1362
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1362
        if (tmp___5) {
#line 1363
          return ((Idx )-2);
        }
        {
#line 1364
        dest_node___0 = *((dfa->edests + node)->elems + 0);
#line 1365
        tmp___6 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node___0);
        }
#line 1365
        if (tmp___6) {
#line 1367
          return (dest_node___0);
        }
      }
    }
#line 1371
    if (naccepted != 0UL) {
#line 1371
      goto _L;
    } else {
      {
#line 1371
      tmp___8 = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + node),
                                  *pidx);
      }
#line 1371
      if (tmp___8) {
        _L: /* CIL Label */ 
#line 1374
        dest_node___1 = *(dfa->nexts + node);
#line 1375
        if (naccepted == 0UL) {
#line 1375
          (*pidx) ++;
        } else {
#line 1375
          *pidx += naccepted;
        }
#line 1376
        if (fs) {
#line 1376
          if (*pidx > (Idx )mctx->match_last) {
#line 1379
            return ((Idx )-1);
          } else
#line 1376
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1379
            return ((Idx )-1);
          } else {
            {
#line 1376
            tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___1);
            }
#line 1376
            if (! tmp___7) {
#line 1379
              return ((Idx )-1);
            }
          }
        }
#line 1380
        eps_via_nodes->nelem = (Idx )0;
#line 1381
        return (dest_node___1);
      }
    }
  }
#line 1384
  return ((Idx )-1);
}
}
#line 1387 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  Idx num ;
  Idx tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1393
  tmp = fs->num;
#line 1393
  (fs->num) ++;
#line 1393
  num = tmp;
#line 1394
  if (fs->num == fs->alloc) {
    {
#line 1397
    tmp___0 = realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * fs->alloc) * 2UL);
#line 1397
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
    }
#line 1399
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1400
      return ((reg_errcode_t )12);
    }
#line 1401
    fs->alloc *= 2UL;
#line 1402
    fs->stack = new_array;
  }
  {
#line 1404
  (fs->stack + num)->idx = str_idx;
#line 1405
  (fs->stack + num)->node = dest_node;
#line 1406
  tmp___1 = malloc(nregs * sizeof(regmatch_t ));
#line 1406
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
  }
#line 1407
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
#line 1408
    return ((reg_errcode_t )12);
  }
  {
#line 1409
  memcpy((void */* __restrict  */)(fs->stack + num)->regs, (void const   */* __restrict  */)regs,
         sizeof(regmatch_t ) * nregs);
#line 1410
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
#line 1411
  return (err);
}
}
#line 1414 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx pop_fail_stack(struct re_fail_stack_t *fs , Idx *pidx , Idx nregs , regmatch_t *regs ,
                          re_node_set *eps_via_nodes ) 
{ 
  Idx num ;

  {
#line 1419
  (fs->num) --;
#line 1419
  num = fs->num;
#line 1420
  if (! (num < 0xfffffffffffffffeUL)) {
    {
#line 1420
    __assert_fail("REG_VALID_INDEX (num)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                  1420U, "pop_fail_stack");
    }
  }
  {
#line 1421
  *pidx = (fs->stack + num)->idx;
#line 1422
  memcpy((void */* __restrict  */)regs, (void const   */* __restrict  */)(fs->stack + num)->regs,
         sizeof(regmatch_t ) * nregs);
#line 1423
  free((void *)eps_via_nodes->elems);
#line 1424
  free((void *)(fs->stack + num)->regs);
#line 1425
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
#line 1426
  return ((fs->stack + num)->node);
}
}
#line 1434 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) 
{ 
  re_dfa_t const   *dfa ;
  Idx idx ;
  Idx cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  _Bool prev_idx_match_malloced ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Idx reg_idx ;
  reg_errcode_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
#line 1439
  dfa = (re_dfa_t const   *)preg->buffer;
#line 1443
  fs_body.num = (Idx )0;
#line 1443
  fs_body.alloc = (Idx )2;
#line 1443
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1445
  prev_idx_match_malloced = (_Bool)0;
#line 1451
  if (fl_backtrack) {
    {
#line 1453
    fs = & fs_body;
#line 1454
    tmp = malloc(fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1454
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
    }
#line 1455
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
#line 1456
      return ((reg_errcode_t )12);
    }
  } else {
#line 1459
    fs = (struct re_fail_stack_t *)((void *)0);
  }
  {
#line 1461
  cur_node = (Idx )dfa->init_node;
#line 1462
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
  }
#line 1464
  if (nmatch * sizeof(regmatch_t ) < 4032UL) {
    {
#line 1465
    tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
#line 1465
    prev_idx_match = (regmatch_t *)tmp___0;
    }
  } else {
    {
#line 1468
    tmp___1 = malloc(nmatch * sizeof(regmatch_t ));
#line 1468
    prev_idx_match = (regmatch_t *)tmp___1;
    }
#line 1469
    if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
      {
#line 1471
      free_fail_stack_return(fs);
      }
#line 1472
      return ((reg_errcode_t )12);
    }
#line 1474
    prev_idx_match_malloced = (_Bool)1;
  }
  {
#line 1476
  memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
         sizeof(regmatch_t ) * nmatch);
#line 1478
  idx = (Idx )(pmatch + 0)->rm_so;
  }
  {
#line 1478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1478
    if (! (idx <= (Idx )(pmatch + 0)->rm_eo)) {
#line 1478
      goto while_break;
    }
    {
#line 1480
    update_regs(dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);
    }
#line 1482
    if (idx == (Idx )(pmatch + 0)->rm_eo) {
#line 1482
      if (cur_node == (Idx )mctx->last_node) {
#line 1485
        if (fs) {
#line 1487
          reg_idx = (Idx )0;
          {
#line 1487
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1487
            if (! (reg_idx < nmatch)) {
#line 1487
              goto while_break___0;
            }
#line 1488
            if ((pmatch + reg_idx)->rm_so > -1L) {
#line 1488
              if ((pmatch + reg_idx)->rm_eo == -1L) {
#line 1489
                goto while_break___0;
              }
            }
#line 1487
            reg_idx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1490
          if (reg_idx == nmatch) {
            {
#line 1492
            free((void *)eps_via_nodes.elems);
            }
#line 1493
            if (prev_idx_match_malloced) {
              {
#line 1494
              free((void *)prev_idx_match);
              }
            }
            {
#line 1495
            tmp___2 = free_fail_stack_return(fs);
            }
#line 1495
            return (tmp___2);
          }
          {
#line 1497
          cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
          }
        } else {
          {
#line 1502
          free((void *)eps_via_nodes.elems);
          }
#line 1503
          if (prev_idx_match_malloced) {
            {
#line 1504
            free((void *)prev_idx_match);
            }
          }
#line 1505
          return ((reg_errcode_t )0);
        }
      }
    }
    {
#line 1510
    cur_node = proceed_next_node(mctx, nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                 fs);
#line 1513
    tmp___4 = __builtin_expect((long )(! (cur_node < 0xfffffffffffffffeUL)), 0L);
    }
#line 1513
    if (tmp___4) {
      {
#line 1515
      tmp___3 = __builtin_expect((long )(cur_node == 0xfffffffffffffffeUL), 0L);
      }
#line 1515
      if (tmp___3) {
        {
#line 1517
        free((void *)eps_via_nodes.elems);
        }
#line 1518
        if (prev_idx_match_malloced) {
          {
#line 1519
          free((void *)prev_idx_match);
          }
        }
        {
#line 1520
        free_fail_stack_return(fs);
        }
#line 1521
        return ((reg_errcode_t )12);
      }
#line 1523
      if (fs) {
        {
#line 1524
        cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
        }
      } else {
        {
#line 1528
        free((void *)eps_via_nodes.elems);
        }
#line 1529
        if (prev_idx_match_malloced) {
          {
#line 1530
          free((void *)prev_idx_match);
          }
        }
#line 1531
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1535
  free((void *)eps_via_nodes.elems);
  }
#line 1536
  if (prev_idx_match_malloced) {
    {
#line 1537
    free((void *)prev_idx_match);
    }
  }
  {
#line 1538
  tmp___5 = free_fail_stack_return(fs);
  }
#line 1538
  return (tmp___5);
}
}
#line 1541 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  Idx fs_idx ;

  {
#line 1545
  if (fs) {
#line 1548
    fs_idx = (Idx )0;
    {
#line 1548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1548
      if (! (fs_idx < fs->num)) {
#line 1548
        goto while_break;
      }
      {
#line 1550
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1551
      free((void *)(fs->stack + fs_idx)->regs);
#line 1548
      fs_idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1553
    free((void *)fs->stack);
    }
  }
#line 1555
  return ((reg_errcode_t )0);
}
}
#line 1558 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) 
{ 
  int type ;
  Idx reg_num ;
  Idx reg_num___0 ;

  {
#line 1563
  type = (int )(dfa->nodes + cur_node)->type;
#line 1564
  if (type == 8) {
#line 1566
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1569
    if (reg_num < nmatch) {
#line 1571
      (pmatch + reg_num)->rm_so = (regoff_t )cur_idx;
#line 1572
      (pmatch + reg_num)->rm_eo = (regoff_t )-1;
    }
  } else
#line 1575
  if (type == 9) {
#line 1577
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1578
    if (reg_num___0 < nmatch) {
#line 1581
      if ((Idx )(pmatch + reg_num___0)->rm_so < cur_idx) {
        {
#line 1583
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
#line 1586
        memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
               sizeof(regmatch_t ) * nmatch);
        }
      } else
#line 1590
      if ((dfa->nodes + cur_node)->opt_subexp) {
#line 1590
        if ((prev_idx_match + reg_num___0)->rm_so != -1L) {
          {
#line 1597
          memcpy((void */* __restrict  */)pmatch, (void const   */* __restrict  */)prev_idx_match,
                 sizeof(regmatch_t ) * nmatch);
          }
        } else {
#line 1601
          (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
        }
      } else {
#line 1601
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
      }
    }
  }
#line 1605
  return;
}
}
#line 1630 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  int null_cnt ;
  Idx str_idx ;
  re_node_set cur_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1635
  null_cnt = 0;
#line 1636
  str_idx = sctx->last_str_idx;
#line 1645
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
#line 1646
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1646
  if (tmp) {
#line 1647
    return (err);
  }
  {
#line 1648
  err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1649
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1649
  if (tmp___0) {
#line 1650
    goto free_return;
  }
  {
#line 1653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1653
    if (! (str_idx > 0UL)) {
#line 1653
      goto while_break;
    }
#line 1656
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1656
      null_cnt ++;
    } else {
#line 1656
      null_cnt = 0;
    }
#line 1657
    if (null_cnt > (int )mctx->max_mb_elem_len) {
      {
#line 1659
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * str_idx);
#line 1661
      free((void *)cur_dest.elems);
      }
#line 1662
      return ((reg_errcode_t )0);
    }
#line 1664
    cur_dest.nelem = (Idx )0;
#line 1665
    str_idx --;
#line 1667
    if (*(mctx->state_log + str_idx)) {
      {
#line 1669
      err = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
#line 1670
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1670
      if (tmp___1) {
#line 1671
        goto free_return;
      }
    }
    {
#line 1678
    err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1679
    tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1679
    if (tmp___2) {
#line 1680
      goto free_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1682
  err = (reg_errcode_t )0;
  free_return: 
  {
#line 1684
  free((void *)cur_dest.elems);
  }
#line 1685
  return (err);
}
}
#line 1688 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  Idx i ;
  Idx prev_node ;
  int naccepted ;
  _Bool ok ;
  _Bool tmp ;
  Idx __attribute__((__pure__))  tmp___0 ;
  Idx to_idx ;
  _Bool tmp___1 ;
  long tmp___2 ;

  {
#line 1693
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1694
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1704
  i = (Idx )0;
  {
#line 1704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1704
    if (! (i < (Idx )cur_src->nelem)) {
#line 1704
      goto while_break;
    }
#line 1706
    prev_node = *(cur_src->elems + i);
#line 1707
    naccepted = 0;
#line 1716
    if ((dfa->nodes + prev_node)->accept_mb) {
      {
#line 1717
      naccepted = sift_states_iter_mb(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
      }
    }
#line 1723
    if (! naccepted) {
      {
#line 1723
      tmp = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                              str_idx);
      }
#line 1723
      if (tmp) {
#line 1723
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1UL)) != (unsigned long )((void *)0)) {
          {
#line 1723
          tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1UL)))->nodes),
                                         *(dfa->nexts + prev_node));
          }
#line 1723
          if (tmp___0) {
#line 1727
            naccepted = 1;
          }
        }
      }
    }
#line 1729
    if (naccepted == 0) {
#line 1730
      goto __Cont;
    }
#line 1732
    if (sctx->limits.nelem) {
      {
#line 1734
      to_idx = str_idx + (Idx )naccepted;
#line 1735
      tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits), *(dfa->nexts + prev_node),
                                 to_idx, prev_node, str_idx);
      }
#line 1735
      if (tmp___1) {
#line 1738
        goto __Cont;
      }
    }
    {
#line 1740
    ok = re_node_set_insert(cur_dest, prev_node);
#line 1741
    tmp___2 = __builtin_expect((long )(! ok), 0L);
    }
#line 1741
    if (tmp___2) {
#line 1742
      return ((reg_errcode_t )12);
    }
    __Cont: /* CIL Label */ 
#line 1704
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  return ((reg_errcode_t )0);
}
}
#line 1750 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , Idx next_state_log_idx ) 
{ 
  Idx top ;
  reg_errcode_t err ;
  long tmp ;

  {
#line 1754
  top = mctx->state_log_top;
#line 1756
  if (next_state_log_idx >= mctx->input.bufs_len) {
#line 1756
    goto _L;
  } else
#line 1756
  if (next_state_log_idx >= mctx->input.valid_len) {
#line 1756
    if (mctx->input.valid_len < mctx->input.len) {
      _L: /* CIL Label */ 
      {
#line 1761
      err = extend_buffers(mctx);
#line 1762
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1762
      if (tmp) {
#line 1763
        return (err);
      }
    }
  }
#line 1766
  if (top < next_state_log_idx) {
    {
#line 1768
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (next_state_log_idx - top));
#line 1770
    mctx->state_log_top = next_state_log_idx;
    }
  }
#line 1772
  return ((reg_errcode_t )0);
}
}
#line 1775 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) 
{ 
  Idx st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
#line 1782
  st_idx = (Idx )0;
  {
#line 1782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1782
    if (! (st_idx < num)) {
#line 1782
      goto while_break;
    }
#line 1784
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1785
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1786
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
#line 1789
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1791
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1791
      if (tmp) {
#line 1792
        return (err);
      }
      {
#line 1793
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
#line 1794
      free((void *)merged_set.elems);
#line 1795
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1795
      if (tmp___0) {
#line 1796
        return (err);
      }
    }
#line 1782
    st_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1799
  return ((reg_errcode_t )0);
}
}
#line 1802 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1808
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1809
  err = (reg_errcode_t )0;
#line 1811
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1811
    candidates = (re_node_set const   *)((void *)0);
  } else {
#line 1811
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1814
  if (dest_nodes->nelem == 0UL) {
#line 1815
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1818
    if (candidates) {
      {
#line 1822
      err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
#line 1823
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1823
      if (tmp) {
#line 1824
        return (err);
      }
#line 1827
      if (sctx->limits.nelem) {
        {
#line 1829
        err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, (struct re_backref_cache_entry *)mctx->bkref_ents,
                                  str_idx);
#line 1831
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1831
        if (tmp___0) {
#line 1832
          return (err);
        }
      }
    }
    {
#line 1836
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1837
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1837
    if (tmp___1) {
#line 1838
      return (err);
    }
  }
#line 1841
  if (candidates) {
#line 1841
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
#line 1843
      err = sift_states_bkref(mctx, sctx, str_idx, candidates);
#line 1844
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1844
      if (tmp___2) {
#line 1845
        return (err);
      }
    }
  }
#line 1847
  return ((reg_errcode_t )0);
}
}
#line 1850 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  re_dfastate_t *state___0 ;
  re_dfastate_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
  {
#line 1855
  err = (reg_errcode_t )0;
#line 1858
  tmp = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1858
  state___0 = tmp;
#line 1859
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1859
  if (tmp___0) {
#line 1860
    return (err);
  }
#line 1862
  if (! state___0->inveclosure.alloc) {
    {
#line 1864
    err = re_node_set_alloc(& state___0->inveclosure, dest_nodes->nelem);
#line 1865
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1865
    if (tmp___1) {
#line 1866
      return ((reg_errcode_t )12);
    }
#line 1867
    i = (Idx )0;
    {
#line 1867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1867
      if (! (i < dest_nodes->nelem)) {
#line 1867
        goto while_break;
      }
      {
#line 1868
      re_node_set_merge(& state___0->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
#line 1867
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1871
  tmp___2 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state___0->inveclosure));
  }
#line 1871
  return (tmp___2);
}
}
#line 1875 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa , Idx node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  Idx ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  Idx cur_node ;
  Idx edst1 ;
  Idx edst2 ;
  Idx tmp ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx __attribute__((__pure__))  tmp___3 ;
  Idx __attribute__((__pure__))  tmp___4 ;
  Idx cur_node___0 ;
  Idx idx ;
  Idx __attribute__((__pure__))  tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;

  {
  {
#line 1882
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
#line 1884
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1885
  ecl_idx = (Idx )0;
  }
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1885
      goto while_break;
    }
#line 1887
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1888
    if (cur_node == node) {
#line 1889
      goto __Cont;
    }
#line 1890
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
#line 1892
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1893
      if ((dfa->edests + cur_node)->nelem > 1UL) {
#line 1893
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
#line 1893
        tmp = (Idx )-1;
      }
      {
#line 1893
      edst2 = tmp;
#line 1895
      tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
      }
#line 1895
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 1895
        if (edst2 - 1UL < 0xfffffffffffffffdUL) {
          {
#line 1895
          tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
          }
#line 1895
          if (! tmp___3) {
            {
#line 1895
            tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
            }
#line 1895
            if (tmp___4) {
              _L: /* CIL Label */ 
              {
#line 1901
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
#line 1903
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 1903
              if (tmp___0) {
                {
#line 1905
                free((void *)except_nodes.elems);
                }
#line 1906
                return (err);
              }
            }
          }
        }
      } else {
        {
#line 1895
        tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
        }
#line 1895
        if (tmp___2) {
#line 1895
          goto _L;
        } else {
#line 1895
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1885
    ecl_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1911
  ecl_idx = (Idx )0;
  {
#line 1911
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1911
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1911
      goto while_break___0;
    }
    {
#line 1913
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1914
    tmp___6 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
    }
#line 1914
    if (! tmp___6) {
      {
#line 1916
      tmp___5 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
#line 1916
      idx = (Idx )(tmp___5 - (Idx __attribute__((__pure__))  )1);
#line 1917
      re_node_set_remove_at(dest_nodes, idx);
      }
    }
#line 1911
    ecl_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1920
  free((void *)except_nodes.elems);
  }
#line 1921
  return ((reg_errcode_t )0);
}
}
#line 1924 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx lim_idx ;
  Idx src_pos ;
  Idx dst_pos ;
  Idx dst_bkref_idx ;
  Idx tmp ;
  Idx src_bkref_idx ;
  Idx tmp___0 ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1929
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1932
  tmp = search_cur_bkref_entry(mctx, dst_idx);
#line 1932
  dst_bkref_idx = tmp;
#line 1933
  tmp___0 = search_cur_bkref_entry(mctx, src_idx);
#line 1933
  src_bkref_idx = tmp___0;
#line 1934
  lim_idx = (Idx )0;
  }
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1934
    if (! (lim_idx < (Idx )limits->nelem)) {
#line 1934
      goto while_break;
    }
    {
#line 1938
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1939
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 1941
    tmp___1 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        dst_node, dst_idx, dst_bkref_idx);
#line 1941
    dst_pos = (Idx )tmp___1;
#line 1944
    tmp___2 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        src_node, src_idx, src_bkref_idx);
#line 1944
    src_pos = (Idx )tmp___2;
    }
#line 1952
    if (! (src_pos == dst_pos)) {
#line 1955
      return ((_Bool)1);
    }
#line 1934
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1957
  return ((_Bool)0);
}
}
#line 1960 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  Idx node_idx ;
  Idx node ;
  struct re_backref_cache_entry *ent ;
  Idx dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp ;
  int tmp___0 ;

  {
#line 1965
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1966
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
#line 1971
  node_idx = (Idx )0;
  {
#line 1971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1971
    if (! (node_idx < (Idx )eclosures->nelem)) {
#line 1971
      goto while_break;
    }
#line 1973
    node = *(eclosures->elems + node_idx);
    {
#line 1976
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1976
      goto case_4;
    }
#line 2024
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2024
      goto case_8;
    }
#line 2029
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 2029
      goto case_9;
    }
#line 2034
    goto switch_default;
    case_4: /* CIL Label */ 
#line 1977
    if (bkref_idx != 0xffffffffffffffffUL) {
#line 1979
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
      {
#line 1980
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1985
        if (ent->node != node) {
#line 1986
          goto __Cont;
        }
#line 1988
        if (subexp_idx < 64UL) {
#line 1988
          if (! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1991
            goto __Cont;
          }
        }
#line 1999
        dst = *((dfa->edests + node)->elems + 0);
#line 2000
        if (dst == from_node) {
#line 2002
          if (boundaries & 1) {
#line 2003
            return (-1);
          } else {
#line 2005
            return (0);
          }
        }
        {
#line 2008
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
        }
#line 2011
        if (cpos == -1) {
#line 2012
          return (-1);
        }
#line 2013
        if (cpos == 0) {
#line 2013
          if (boundaries & 2) {
#line 2014
            return (0);
          }
        }
#line 2016
        if (subexp_idx < 64UL) {
#line 2017
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: /* CIL Label */ 
#line 1980
        tmp = ent;
#line 1980
        ent ++;
#line 1980
        if (! tmp->more) {
#line 1980
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2022
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2025
    if (boundaries & 1) {
#line 2025
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2026
        return (-1);
      }
    }
#line 2027
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2030
    if (boundaries & 2) {
#line 2030
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2031
        return (0);
      }
    }
#line 2032
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2035
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1971
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2039
  if (boundaries & 2) {
#line 2039
    tmp___0 = 1;
  } else {
#line 2039
    tmp___0 = 0;
  }
#line 2039
  return (tmp___0);
}
}
#line 2042 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp ;

  {
#line 2048
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 2052
  if (str_idx < lim->subexp_from) {
#line 2053
    return (-1);
  }
#line 2055
  if (lim->subexp_to < str_idx) {
#line 2056
    return (1);
  }
#line 2059
  boundaries = str_idx == lim->subexp_from;
#line 2060
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 2061
  if (boundaries == 0) {
#line 2062
    return (0);
  }
  {
#line 2065
  tmp = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node, bkref_idx);
  }
#line 2065
  return (tmp);
}
}
#line 2072 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) 
{ 
  reg_errcode_t err ;
  Idx node_idx ;
  Idx lim_idx ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  Idx ops_node ;
  Idx cls_node ;
  Idx node ;
  re_token_type_t type ;
  long tmp ;
  Idx node___0 ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
#line 2081
  lim_idx = (Idx )0;
  {
#line 2081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2081
    if (! (lim_idx < limits->nelem)) {
#line 2081
      goto while_break;
    }
#line 2085
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2087
    if (str_idx <= ent->subexp_from) {
#line 2088
      goto __Cont;
    } else
#line 2087
    if (ent->str_idx < str_idx) {
#line 2088
      goto __Cont;
    }
#line 2090
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 2091
    if (ent->subexp_to == str_idx) {
#line 2093
      ops_node = (Idx )-1;
#line 2094
      cls_node = (Idx )-1;
#line 2095
      node_idx = (Idx )0;
      {
#line 2095
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2095
        if (! (node_idx < dest_nodes->nelem)) {
#line 2095
          goto while_break___0;
        }
#line 2097
        node = *(dest_nodes->elems + node_idx);
#line 2098
        type = (dfa->nodes + node)->type;
#line 2099
        if ((unsigned int )type == 8U) {
#line 2099
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2101
            ops_node = node;
          } else {
#line 2099
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2102
        if ((unsigned int )type == 9U) {
#line 2102
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2104
            cls_node = node;
          }
        }
#line 2095
        node_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2109
      if (ops_node < 0xfffffffffffffffeUL) {
        {
#line 2111
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
#line 2113
        tmp = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2113
        if (tmp) {
#line 2114
          return (err);
        }
      }
#line 2118
      if (cls_node < 0xfffffffffffffffeUL) {
#line 2119
        node_idx = (Idx )0;
        {
#line 2119
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2119
          if (! (node_idx < dest_nodes->nelem)) {
#line 2119
            goto while_break___1;
          }
          {
#line 2121
          node___0 = *(dest_nodes->elems + node_idx);
#line 2122
          tmp___1 = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                         cls_node);
          }
#line 2122
          if (! tmp___1) {
            {
#line 2122
            tmp___2 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                           cls_node);
            }
#line 2122
            if (! tmp___2) {
              {
#line 2129
              err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
#line 2131
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 2131
              if (tmp___0) {
#line 2132
                return (err);
              }
#line 2133
              node_idx --;
            }
          }
#line 2119
          node_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 2139
      node_idx = (Idx )0;
      {
#line 2139
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2139
        if (! (node_idx < dest_nodes->nelem)) {
#line 2139
          goto while_break___2;
        }
#line 2141
        node___1 = *(dest_nodes->elems + node_idx);
#line 2142
        type___0 = (dfa->nodes + node___1)->type;
#line 2143
        if ((unsigned int )type___0 == 9U) {
#line 2143
          goto _L___0;
        } else
#line 2143
        if ((unsigned int )type___0 == 8U) {
          _L___0: /* CIL Label */ 
#line 2145
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 2146
            goto __Cont___0;
          }
          {
#line 2149
          err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
#line 2151
          tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2151
          if (tmp___3) {
#line 2152
            return (err);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 2139
        node_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2081
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2157
  return ((reg_errcode_t )0);
}
}
#line 2160 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx node_idx ;
  Idx node ;
  re_sift_context_t local_sctx ;
  Idx first_idx ;
  Idx tmp ;
  Idx enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  Idx subexp_len ;
  Idx to_idx ;
  Idx dst_node ;
  _Bool ok ;
  re_dfastate_t *cur_state ;
  Idx __attribute__((__pure__))  tmp___0 ;
  _Bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  struct re_backref_cache_entry *tmp___7 ;

  {
  {
#line 2165
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2169
  tmp = search_cur_bkref_entry(mctx, str_idx);
#line 2169
  first_idx = tmp;
  }
#line 2171
  if (first_idx == 0xffffffffffffffffUL) {
#line 2172
    return ((reg_errcode_t )0);
  }
#line 2174
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2176
  node_idx = (Idx )0;
  {
#line 2176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2176
    if (! (node_idx < (Idx )candidates->nelem)) {
#line 2176
      goto while_break;
    }
#line 2181
    node = *(candidates->elems + node_idx);
#line 2182
    type = (dfa->nodes + node)->type;
#line 2184
    if (node == sctx->last_node) {
#line 2184
      if (str_idx == sctx->last_str_idx) {
#line 2185
        goto __Cont;
      }
    }
#line 2186
    if ((unsigned int )type != 4U) {
#line 2187
      goto __Cont;
    }
#line 2189
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2190
    enabled_idx = first_idx;
    {
#line 2191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2199
      if (entry->node != node) {
#line 2200
        goto __Cont___0;
      }
#line 2201
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2202
      to_idx = str_idx + subexp_len;
#line 2203
      if (subexp_len) {
#line 2203
        dst_node = *(dfa->nexts + node);
      } else {
#line 2203
        dst_node = *((dfa->edests + node)->elems + 0);
      }
#line 2206
      if (to_idx > sctx->last_str_idx) {
#line 2211
        goto __Cont___0;
      } else
#line 2206
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 2211
        goto __Cont___0;
      } else
#line 2206
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
        {
#line 2206
        tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                       dst_node);
        }
#line 2206
        if (tmp___0) {
          {
#line 2206
          tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits),
                                     node, str_idx, dst_node, to_idx);
          }
#line 2206
          if (tmp___1) {
#line 2211
            goto __Cont___0;
          }
        } else {
#line 2211
          goto __Cont___0;
        }
      } else {
#line 2211
        goto __Cont___0;
      }
#line 2213
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
        {
#line 2215
        local_sctx = *sctx;
#line 2216
        err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2217
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2217
        if (tmp___2) {
#line 2218
          goto free_return;
        }
      }
      {
#line 2220
      local_sctx.last_node = node;
#line 2221
      local_sctx.last_str_idx = str_idx;
#line 2222
      ok = re_node_set_insert(& local_sctx.limits, enabled_idx);
#line 2223
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 2223
      if (tmp___3) {
#line 2225
        err = (reg_errcode_t )12;
#line 2226
        goto free_return;
      }
      {
#line 2228
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2229
      err = sift_states_backward(mctx, & local_sctx);
#line 2230
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2230
      if (tmp___4) {
#line 2231
        goto free_return;
      }
#line 2232
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
        {
#line 2234
        err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                str_idx + 1UL);
#line 2237
        tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2237
        if (tmp___5) {
#line 2238
          goto free_return;
        }
      }
      {
#line 2240
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2241
      tmp___6 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                     enabled_idx);
#line 2241
      re_node_set_remove_at(& local_sctx.limits, (Idx )(tmp___6 - (Idx __attribute__((__pure__))  )1));
#line 2244
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      }
      __Cont___0: /* CIL Label */ 
#line 2191
      enabled_idx ++;
#line 2191
      tmp___7 = entry;
#line 2191
      entry ++;
#line 2191
      if (! tmp___7->more) {
#line 2191
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2176
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2248
  err = (reg_errcode_t )0;
  free_return: 
#line 2250
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
#line 2252
    free((void *)local_sctx.limits.elems);
    }
  }
#line 2255
  return (err);
}
}
#line 2260 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int naccepted ;
  Idx __attribute__((__pure__))  tmp ;

  {
  {
#line 2265
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2268
  naccepted = check_node_accept_bytes(dfa, node_idx, & mctx->input, str_idx);
  }
#line 2269
  if (naccepted > 0) {
#line 2269
    if (str_idx + (Idx )naccepted <= max_str_idx) {
#line 2269
      if ((unsigned long )*(sctx->sifted_states + (str_idx + (Idx )naccepted)) != (unsigned long )((void *)0)) {
        {
#line 2269
        tmp = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + (Idx )naccepted)))->nodes),
                                   *(dfa->nexts + node_idx));
        }
#line 2269
        if (! tmp) {
#line 2275
          naccepted = 0;
        }
      } else {
#line 2275
        naccepted = 0;
      }
    }
  }
#line 2278
  return (naccepted);
}
}
#line 2290 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state___0 ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  long tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  long tmp___2 ;
  unsigned int context ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 2300
  tmp___0 = __builtin_expect((long )state___0->accept_mb, 0L);
  }
#line 2300
  if (tmp___0) {
    {
#line 2302
    *err = transit_state_mb(mctx, state___0);
#line 2303
    tmp = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2303
    if (tmp) {
#line 2304
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2316
  tmp___1 = mctx->input.cur_idx;
#line 2316
  (mctx->input.cur_idx) ++;
#line 2316
  ch = *(mctx->input.mbs + tmp___1);
  {
#line 2317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2319
    trtable = state___0->trtable;
#line 2320
    tmp___2 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2320
    if (tmp___2) {
#line 2321
      return (*(trtable + ch));
    }
    {
#line 2323
    trtable = state___0->word_trtable;
#line 2324
    tmp___3 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2324
    if (tmp___3) {
      {
#line 2327
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                     mctx->eflags);
      }
#line 2331
      if (context & 1U) {
#line 2332
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2334
        return (*(trtable + ch));
      }
    }
    {
#line 2337
    tmp___4 = build_trtable(mctx->dfa, state___0);
    }
#line 2337
    if (! tmp___4) {
#line 2339
      *err = (reg_errcode_t )12;
#line 2340
      return ((re_dfastate_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2348 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa ;
  Idx cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp ;
  re_dfastate_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2353
  dfa = mctx->dfa;
#line 2354
  cur_idx = mctx->input.cur_idx;
#line 2356
  if (cur_idx > mctx->state_log_top) {
#line 2358
    *(mctx->state_log + cur_idx) = next_state;
#line 2359
    mctx->state_log_top = cur_idx;
  } else
#line 2361
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2363
    *(mctx->state_log + cur_idx) = next_state;
  } else {
#line 2369
    table_nodes = (re_node_set *)((void *)0);
#line 2374
    pstate = *(mctx->state_log + cur_idx);
#line 2375
    log_nodes = pstate->entrance_nodes;
#line 2376
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2378
      table_nodes = next_state->entrance_nodes;
#line 2379
      *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                    (re_node_set const   *)log_nodes);
#line 2381
      tmp = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2381
      if (tmp) {
#line 2382
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2385
      next_nodes = *log_nodes;
    }
    {
#line 2389
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                   mctx->eflags);
#line 2392
    tmp___0 = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                       context);
#line 2392
    *(mctx->state_log + cur_idx) = tmp___0;
#line 2392
    next_state = tmp___0;
    }
#line 2397
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
      {
#line 2398
      free((void *)next_nodes.elems);
      }
    }
  }
  {
#line 2401
  tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
  }
#line 2401
  if (tmp___3) {
#line 2401
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2406
      *err = check_subexp_matching_top(mctx, & next_state->nodes, cur_idx);
#line 2408
      tmp___1 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2408
      if (tmp___1) {
#line 2409
        return ((re_dfastate_t *)((void *)0));
      }
#line 2412
      if (next_state->has_backref) {
        {
#line 2414
        *err = transit_state_bkref(mctx, (re_node_set const   *)(& next_state->nodes));
#line 2415
        tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
        }
#line 2415
        if (tmp___2) {
#line 2416
          return ((re_dfastate_t *)((void *)0));
        }
#line 2417
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
#line 2421
  return (next_state);
}
}
#line 2427 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  Idx max ;
  Idx cur_str_idx ;

  {
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2434
    max = mctx->state_log_top;
#line 2435
    cur_str_idx = mctx->input.cur_idx;
    {
#line 2437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2439
      cur_str_idx ++;
#line 2439
      if (cur_str_idx > max) {
#line 2440
        return ((re_dfastate_t *)((void *)0));
      }
#line 2441
      (mctx->input.cur_idx) ++;
#line 2437
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
#line 2437
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2445
    cur_state = merge_state_with_log(err, mctx, (re_dfastate_t *)((void *)0));
    }
#line 2432
    if ((int )*err == 0) {
#line 2432
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
#line 2432
        goto while_break;
      }
    } else {
#line 2432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2448
  return (cur_state);
}
}
#line 2458 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx node_idx ;
  reg_errcode_t err ;
  Idx node ;
  long tmp ;

  {
#line 2463
  dfa = mctx->dfa;
#line 2472
  node_idx = (Idx )0;
  {
#line 2472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2472
    if (! (node_idx < cur_nodes->nelem)) {
#line 2472
      goto while_break;
    }
#line 2474
    node = *(cur_nodes->elems + node_idx);
#line 2475
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2475
      if ((dfa->nodes + node)->opr.idx < 64UL) {
#line 2475
        if (dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
          {
#line 2480
          err = match_ctx_add_subtop(mctx, node, str_idx);
#line 2481
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2481
          if (tmp) {
#line 2482
            return (err);
          }
        }
      }
    }
#line 2472
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2485
  return ((reg_errcode_t )0);
}
}
#line 2531 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  Idx cur_node_idx ;
  int naccepted ;
  Idx dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2535
  dfa = mctx->dfa;
#line 2539
  i = (Idx )0;
  {
#line 2539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2539
    if (! (i < pstate->nodes.nelem)) {
#line 2539
      goto while_break;
    }
#line 2542
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2548
    if (! (dfa->nodes + cur_node_idx)->accept_mb) {
#line 2549
      goto __Cont;
    }
#line 2551
    if ((dfa->nodes + cur_node_idx)->constraint) {
      {
#line 2553
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                     mctx->eflags);
      }
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 4U) {
#line 2556
        if (! (context & 1U)) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 8U) {
#line 2556
        if (context & 1U) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 32U) {
#line 2556
        if (! (context & (unsigned int )(1 << 1))) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 128U) {
#line 2556
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2558
          goto __Cont;
        }
      }
    }
    {
#line 2562
    naccepted = check_node_accept_bytes(dfa, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                        mctx->input.cur_idx);
    }
#line 2564
    if (naccepted == 0) {
#line 2565
      goto __Cont;
    }
#line 2568
    dest_idx = mctx->input.cur_idx + (Idx )naccepted;
#line 2569
    if (mctx->max_mb_elem_len < naccepted) {
#line 2569
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2569
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
    {
#line 2571
    err = clean_state_log_if_needed(mctx, dest_idx);
#line 2572
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2572
    if (tmp) {
#line 2573
      return (err);
    }
#line 2577
    new_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + cur_node_idx));
#line 2579
    dest_state = *(mctx->state_log + dest_idx);
#line 2580
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2581
      dest_nodes = *new_nodes;
    } else {
      {
#line 2584
      err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                   (re_node_set const   *)new_nodes);
#line 2586
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2586
      if (tmp___0) {
#line 2587
        return (err);
      }
    }
    {
#line 2589
    context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_idx - 1UL,
                                   mctx->eflags);
#line 2591
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                             context);
    }
#line 2593
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
      {
#line 2594
      free((void *)dest_nodes.elems);
      }
    }
#line 2595
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2595
      if ((int )err != 0) {
#line 2595
        tmp___1 = 1;
      } else {
#line 2595
        tmp___1 = 0;
      }
    } else {
#line 2595
      tmp___1 = 0;
    }
    {
#line 2595
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2595
    if (tmp___2) {
#line 2596
      return (err);
    }
    __Cont: /* CIL Label */ 
#line 2539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2598
  return ((reg_errcode_t )0);
}
}
#line 2602 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  Idx cur_str_idx ;
  Idx dest_str_idx ;
  Idx prev_nelem ;
  Idx bkc_idx ;
  Idx node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  Idx subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2606
  dfa = mctx->dfa;
#line 2609
  cur_str_idx = mctx->input.cur_idx;
#line 2611
  i = (Idx )0;
  {
#line 2611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2611
    if (! (i < (Idx )nodes->nelem)) {
#line 2611
      goto while_break;
    }
#line 2614
    node_idx = *(nodes->elems + i);
#line 2616
    node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 2620
    if ((unsigned int const   )node->type != 4U) {
#line 2621
      goto __Cont;
    }
#line 2623
    if (node->constraint) {
      {
#line 2625
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
      }
#line 2627
      if (node->constraint & 4U) {
#line 2627
        if (! (context & 1U)) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2627
      if (node->constraint & 8U) {
#line 2627
        if (context & 1U) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2627
      if (node->constraint & 32U) {
#line 2627
        if (! (context & (unsigned int )(1 << 1))) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2627
      if (node->constraint & 128U) {
#line 2627
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2628
          goto __Cont;
        }
      }
    }
    {
#line 2633
    bkc_idx = mctx->nbkref_ents;
#line 2634
    err = get_subexp(mctx, node_idx, cur_str_idx);
#line 2635
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2635
    if (tmp) {
#line 2636
      goto free_return;
    }
    {
#line 2643
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2643
      if (! (bkc_idx < mctx->nbkref_ents)) {
#line 2643
        goto while_break___0;
      }
#line 2648
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2649
      if (bkref_ent->node != node_idx) {
#line 2650
        goto __Cont___0;
      } else
#line 2649
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2650
        goto __Cont___0;
      }
#line 2651
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2652
      if (subexp_len == 0UL) {
#line 2652
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *((dfa->edests + node_idx)->elems + 0));
      } else {
#line 2652
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + node_idx));
      }
      {
#line 2655
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2657
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1UL,
                                     mctx->eflags);
#line 2659
      dest_state = *(mctx->state_log + dest_str_idx);
      }
#line 2660
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2660
        prev_nelem = (Idx )0;
      } else {
#line 2660
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2663
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
#line 2665
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
        }
#line 2668
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2668
          if ((int )err != 0) {
#line 2668
            tmp___0 = 1;
          } else {
#line 2668
            tmp___0 = 0;
          }
        } else {
#line 2668
          tmp___0 = 0;
        }
        {
#line 2668
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        }
#line 2668
        if (tmp___1) {
#line 2670
          goto free_return;
        }
      } else {
        {
#line 2675
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
#line 2678
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2678
        if (tmp___2) {
          {
#line 2680
          free((void *)dest_nodes.elems);
          }
#line 2681
          goto free_return;
        }
        {
#line 2683
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
#line 2685
        free((void *)dest_nodes.elems);
        }
#line 2686
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2686
          if ((int )err != 0) {
#line 2686
            tmp___3 = 1;
          } else {
#line 2686
            tmp___3 = 0;
          }
        } else {
#line 2686
          tmp___3 = 0;
        }
        {
#line 2686
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
#line 2686
        if (tmp___4) {
#line 2688
          goto free_return;
        }
      }
#line 2692
      if (subexp_len == 0UL) {
#line 2692
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
#line 2695
          err = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
#line 2697
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2697
          if (tmp___5) {
#line 2698
            goto free_return;
          }
          {
#line 2699
          err = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
#line 2700
          tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2700
          if (tmp___6) {
#line 2701
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2643
      bkc_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2705
  err = (reg_errcode_t )0;
  free_return: 
#line 2707
  return (err);
}
}
#line 2716 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx subexp_num ;
  Idx sub_top_idx ;
  char const   *buf___1 ;
  Idx cache_idx ;
  Idx tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  Idx sub_last_idx ;
  Idx sl_str ;
  Idx bkref_str_off ;
  regoff_t sl_str_diff ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  Idx cls_node ;
  regoff_t sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___5 ;
  long tmp___6 ;
  Idx tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 2720
  dfa = mctx->dfa;
#line 2722
  buf___1 = (char const   *)mctx->input.mbs;
#line 2724
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2724
  cache_idx = tmp;
  }
#line 2725
  if (cache_idx != 0xffffffffffffffffUL) {
#line 2727
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
    {
#line 2729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2730
      if (entry->node == (Idx const   )bkref_node) {
#line 2731
        return ((reg_errcode_t )0);
      }
#line 2729
      tmp___0 = entry;
#line 2729
      entry ++;
#line 2729
      if (! tmp___0->more) {
#line 2729
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2735
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
#line 2738
  sub_top_idx = (Idx )0;
  {
#line 2738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2738
    if (! (sub_top_idx < mctx->nsub_tops)) {
#line 2738
      goto while_break___0;
    }
#line 2741
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2745
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2746
      goto __Cont;
    }
#line 2748
    sl_str = sub_top->str_idx;
#line 2749
    bkref_str_off = bkref_str_idx;
#line 2752
    sub_last_idx = (Idx )0;
    {
#line 2752
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2752
      if (! (sub_last_idx < sub_top->nlasts)) {
#line 2752
        goto while_break___1;
      }
#line 2755
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2756
      sl_str_diff = (regoff_t )(sub_last->str_idx - sl_str);
#line 2759
      if (sl_str_diff > 0L) {
        {
#line 2761
        tmp___2 = __builtin_expect((long )(bkref_str_off + (Idx )sl_str_diff > mctx->input.valid_len),
                                   0L);
        }
#line 2761
        if (tmp___2) {
#line 2764
          if (bkref_str_off + (Idx )sl_str_diff > mctx->input.len) {
#line 2765
            goto while_break___1;
          }
          {
#line 2767
          err = clean_state_log_if_needed(mctx, bkref_str_off + (Idx )sl_str_diff);
#line 2770
          tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2770
          if (tmp___1) {
#line 2771
            return (err);
          }
#line 2772
          buf___1 = (char const   *)mctx->input.mbs;
        }
        {
#line 2774
        tmp___3 = memcmp((void const   *)(buf___1 + bkref_str_off), (void const   *)(buf___1 + sl_str),
                         (size_t )sl_str_diff);
        }
#line 2774
        if (tmp___3 != 0) {
#line 2776
          goto while_break___1;
        }
      }
      {
#line 2778
      bkref_str_off += (Idx )sl_str_diff;
#line 2779
      sl_str += (Idx )sl_str_diff;
#line 2780
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2785
      buf___1 = (char const   *)mctx->input.mbs;
      }
#line 2787
      if ((int )err == 1) {
#line 2788
        goto __Cont___0;
      }
      {
#line 2789
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2789
      if (tmp___4) {
#line 2790
        return (err);
      }
      __Cont___0: /* CIL Label */ 
#line 2752
      sub_last_idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2793
    if (sub_last_idx < sub_top->nlasts) {
#line 2794
      goto __Cont;
    }
#line 2795
    if (sub_last_idx > 0UL) {
#line 2796
      sl_str ++;
    }
    {
#line 2798
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2798
      if (! (sl_str <= bkref_str_idx)) {
#line 2798
        goto while_break___2;
      }
#line 2803
      sl_str_off = (regoff_t )(sl_str - sub_top->str_idx);
#line 2806
      if (sl_str_off > 0L) {
        {
#line 2808
        tmp___6 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
        }
#line 2808
        if (tmp___6) {
#line 2811
          if (bkref_str_off >= mctx->input.len) {
#line 2812
            goto while_break___2;
          }
          {
#line 2814
          err = extend_buffers(mctx);
#line 2815
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2815
          if (tmp___5) {
#line 2816
            return (err);
          }
#line 2818
          buf___1 = (char const   *)mctx->input.mbs;
        }
#line 2820
        tmp___7 = bkref_str_off;
#line 2820
        bkref_str_off ++;
#line 2820
        if ((int const   )*(buf___1 + tmp___7) != (int const   )*(buf___1 + (sl_str - 1UL))) {
#line 2821
          goto while_break___2;
        }
      }
#line 2824
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2825
        goto __Cont___1;
      }
      {
#line 2827
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2828
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 9);
      }
#line 2830
      if (cls_node == 0xffffffffffffffffUL) {
#line 2831
        goto __Cont___1;
      }
#line 2832
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
#line 2834
        tmp___8 = calloc(sizeof(state_array_t ), (sl_str - sub_top->str_idx) + 1UL);
#line 2834
        sub_top->path = (state_array_t *)tmp___8;
        }
#line 2836
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2837
          return ((reg_errcode_t )12);
        }
      }
      {
#line 2841
      err = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx, cls_node,
                          sl_str, 9);
      }
#line 2844
      if ((int )err == 1) {
#line 2845
        goto __Cont___1;
      }
      {
#line 2846
      tmp___9 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2846
      if (tmp___9) {
#line 2847
        return (err);
      }
      {
#line 2848
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
#line 2849
      tmp___10 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2849
      if (tmp___10) {
#line 2850
        return ((reg_errcode_t )12);
      }
      {
#line 2851
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
      }
#line 2853
      if ((int )err == 1) {

      }
      __Cont___1: /* CIL Label */ 
#line 2798
      sl_str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2738
    sub_top_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2857
  return ((reg_errcode_t )0);
}
}
#line 2866 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) 
{ 
  reg_errcode_t err ;
  Idx to_idx ;
  long tmp ;
  reg_errcode_t tmp___0 ;

  {
  {
#line 2874
  err = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx, bkref_node,
                      bkref_str, 8);
  }
#line 2877
  if ((int )err != 0) {
#line 2878
    return (err);
  }
  {
#line 2879
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, (Idx )sub_top->str_idx, sub_last->str_idx);
#line 2881
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 2881
  if (tmp) {
#line 2882
    return (err);
  }
  {
#line 2883
  to_idx = (bkref_str + sub_last->str_idx) - (Idx )sub_top->str_idx;
#line 2884
  tmp___0 = clean_state_log_if_needed(mctx, to_idx);
  }
#line 2884
  return (tmp___0);
}
}
#line 2895 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) 
{ 
  Idx cls_idx ;
  Idx cls_node ;
  re_token_t const   *node ;

  {
#line 2901
  cls_idx = (Idx )0;
  {
#line 2901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2901
    if (! (cls_idx < (Idx )nodes->nelem)) {
#line 2901
      goto while_break;
    }
#line 2903
    cls_node = *(nodes->elems + cls_idx);
#line 2904
    node = (re_token_t const   *)(dfa->nodes + cls_node);
#line 2905
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
#line 2905
      if (node->opr.idx == (Idx const   )subexp_idx) {
#line 2907
        return (cls_node);
      }
    }
#line 2901
    cls_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2909
  return ((Idx )-1);
}
}
#line 2917 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx subexp_num ;
  Idx backup_cur_idx ;
  Idx str_idx ;
  Idx null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  Idx old_alloc ;
  Idx new_alloc ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  Idx __attribute__((__pure__))  tmp___16 ;

  {
  {
#line 2922
  dfa = mctx->dfa;
#line 2923
  err = (reg_errcode_t )0;
#line 2925
  cur_state = (re_dfastate_t *)((void *)0);
#line 2930
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2932
  tmp___3 = __builtin_expect((long )(path->alloc < (last_str + (Idx )mctx->max_mb_elem_len) + 1UL),
                             0L);
  }
#line 2932
  if (tmp___3) {
    {
#line 2935
    old_alloc = path->alloc;
#line 2936
    new_alloc = ((old_alloc + last_str) + (Idx )mctx->max_mb_elem_len) + 1UL;
#line 2937
    tmp = __builtin_expect((long )(new_alloc < old_alloc), 0L);
    }
#line 2937
    if (tmp) {
#line 2939
      return ((reg_errcode_t )12);
    } else {
      {
#line 2937
      tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) < new_alloc),
                                 0L);
      }
#line 2937
      if (tmp___0) {
#line 2939
        return ((reg_errcode_t )12);
      }
    }
    {
#line 2940
    tmp___1 = realloc((void *)path->array, new_alloc * sizeof(re_dfastate_t *));
#line 2940
    new_array = (re_dfastate_t **)tmp___1;
#line 2941
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 2941
    if (tmp___2) {
#line 2942
      return ((reg_errcode_t )12);
    }
    {
#line 2943
    path->array = new_array;
#line 2944
    path->alloc = new_alloc;
#line 2945
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (path->alloc - old_alloc));
    }
  }
#line 2949
  if (path->next_idx) {
#line 2949
    str_idx = path->next_idx;
  } else {
#line 2949
    str_idx = top_str;
  }
  {
#line 2952
  backup_state_log = mctx->state_log;
#line 2953
  backup_cur_idx = mctx->input.cur_idx;
#line 2954
  mctx->state_log = path->array;
#line 2955
  mctx->input.cur_idx = str_idx;
#line 2958
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                 mctx->eflags);
  }
#line 2959
  if (str_idx == top_str) {
    {
#line 2961
    err = re_node_set_init_1(& next_nodes, top_node);
#line 2962
    tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2962
    if (tmp___4) {
#line 2963
      return (err);
    }
    {
#line 2964
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 2965
    tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2965
    if (tmp___5) {
      {
#line 2967
      free((void *)next_nodes.elems);
      }
#line 2968
      return (err);
    }
  } else {
#line 2973
    cur_state = *(mctx->state_log + str_idx);
#line 2974
    if (cur_state) {
#line 2974
      if (cur_state->has_backref) {
        {
#line 2976
        err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2977
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2977
        if (tmp___6) {
#line 2978
          return (err);
        }
      } else {
        {
#line 2981
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 2981
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    }
  }
#line 2983
  if (str_idx == top_str) {
#line 2983
    goto _L;
  } else
#line 2983
  if (cur_state) {
#line 2983
    if (cur_state->has_backref) {
      _L: /* CIL Label */ 
#line 2985
      if (next_nodes.nelem) {
        {
#line 2987
        err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2989
        tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2989
        if (tmp___7) {
          {
#line 2991
          free((void *)next_nodes.elems);
          }
#line 2992
          return (err);
        }
      }
      {
#line 2995
      cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
      }
#line 2996
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2996
        if ((int )err != 0) {
#line 2996
          tmp___8 = 1;
        } else {
#line 2996
          tmp___8 = 0;
        }
      } else {
#line 2996
        tmp___8 = 0;
      }
      {
#line 2996
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
#line 2996
      if (tmp___9) {
        {
#line 2998
        free((void *)next_nodes.elems);
        }
#line 2999
        return (err);
      }
#line 3001
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 3004
  null_cnt = (Idx )0;
  {
#line 3004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3004
    if (str_idx < last_str) {
#line 3004
      if (! (null_cnt <= (Idx )mctx->max_mb_elem_len)) {
#line 3004
        goto while_break;
      }
    } else {
#line 3004
      goto while_break;
    }
#line 3006
    next_nodes.nelem = (Idx )0;
#line 3007
    if (*(mctx->state_log + (str_idx + 1UL))) {
      {
#line 3009
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1UL)))->nodes));
#line 3011
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3011
      if (tmp___10) {
        {
#line 3013
        free((void *)next_nodes.elems);
        }
#line 3014
        return (err);
      }
    }
#line 3017
    if (cur_state) {
      {
#line 3019
      err = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                         & next_nodes);
#line 3022
      tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3022
      if (tmp___11) {
        {
#line 3024
        free((void *)next_nodes.elems);
        }
#line 3025
        return (err);
      }
    }
#line 3028
    str_idx ++;
#line 3029
    if (next_nodes.nelem) {
      {
#line 3031
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 3032
      tmp___12 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3032
      if (tmp___12) {
        {
#line 3034
        free((void *)next_nodes.elems);
        }
#line 3035
        return (err);
      }
      {
#line 3037
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 3039
      tmp___13 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3039
      if (tmp___13) {
        {
#line 3041
        free((void *)next_nodes.elems);
        }
#line 3042
        return (err);
      }
    }
    {
#line 3045
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                   mctx->eflags);
#line 3046
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
    }
#line 3047
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3047
      if ((int )err != 0) {
#line 3047
        tmp___14 = 1;
      } else {
#line 3047
        tmp___14 = 0;
      }
    } else {
#line 3047
      tmp___14 = 0;
    }
    {
#line 3047
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
    }
#line 3047
    if (tmp___15) {
      {
#line 3049
      free((void *)next_nodes.elems);
      }
#line 3050
      return (err);
    }
#line 3052
    *(mctx->state_log + str_idx) = cur_state;
#line 3053
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3053
      null_cnt ++;
    } else {
#line 3053
      null_cnt = (Idx )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3055
  free((void *)next_nodes.elems);
  }
#line 3056
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 3056
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 3056
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 3058
  path->next_idx = str_idx;
#line 3061
  mctx->state_log = backup_state_log;
#line 3062
  mctx->input.cur_idx = backup_cur_idx;
#line 3065
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
    {
#line 3065
    tmp___16 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
    }
#line 3065
    if (tmp___16) {
#line 3066
      return ((reg_errcode_t )0);
    }
  }
#line 3068
  return ((reg_errcode_t )1);
}
}
#line 3079 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  _Bool ok ;
  Idx cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  Idx cur_node ;
  re_dfastate_t *dest_state ;
  Idx next_node ;
  Idx next_idx ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 3084
  dfa = mctx->dfa;
#line 3088
  err = (reg_errcode_t )0;
#line 3091
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3092
  cur_idx = (Idx )0;
  }
  {
#line 3092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3092
    if (! (cur_idx < cur_nodes->nelem)) {
#line 3092
      goto while_break;
    }
#line 3094
    naccepted = 0;
#line 3095
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3102
    if ((dfa->nodes + cur_node)->accept_mb) {
      {
#line 3104
      naccepted = check_node_accept_bytes(dfa, cur_node, (re_string_t const   *)(& mctx->input),
                                          str_idx);
      }
#line 3106
      if (naccepted > 1) {
#line 3109
        next_node = *(dfa->nexts + cur_node);
#line 3110
        next_idx = str_idx + (Idx )naccepted;
#line 3111
        dest_state = *(mctx->state_log + next_idx);
#line 3112
        union_set.nelem = (Idx )0;
#line 3113
        if (dest_state) {
          {
#line 3115
          err = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3116
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 3116
          if (tmp) {
            {
#line 3118
            free((void *)union_set.elems);
            }
#line 3119
            return (err);
          }
        }
        {
#line 3122
        ok = re_node_set_insert(& union_set, next_node);
#line 3123
        tmp___0 = __builtin_expect((long )(! ok), 0L);
        }
#line 3123
        if (tmp___0) {
          {
#line 3125
          free((void *)union_set.elems);
          }
#line 3126
          return ((reg_errcode_t )12);
        }
        {
#line 3128
        *(mctx->state_log + next_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
        }
#line 3130
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 3130
          if ((int )err != 0) {
#line 3130
            tmp___1 = 1;
          } else {
#line 3130
            tmp___1 = 0;
          }
        } else {
#line 3130
          tmp___1 = 0;
        }
        {
#line 3130
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
        }
#line 3130
        if (tmp___2) {
          {
#line 3133
          free((void *)union_set.elems);
          }
#line 3134
          return (err);
        }
      }
    }
#line 3139
    if (naccepted) {
#line 3139
      goto _L;
    } else {
      {
#line 3139
      tmp___4 = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                  str_idx);
      }
#line 3139
      if (tmp___4) {
        _L: /* CIL Label */ 
        {
#line 3142
        ok = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
#line 3143
        tmp___3 = __builtin_expect((long )(! ok), 0L);
        }
#line 3143
        if (tmp___3) {
          {
#line 3145
          free((void *)union_set.elems);
          }
#line 3146
          return ((reg_errcode_t )12);
        }
      }
    }
#line 3092
    cur_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3150
  free((void *)union_set.elems);
  }
#line 3151
  return ((reg_errcode_t )0);
}
}
#line 3160 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) 
{ 
  reg_errcode_t err ;
  Idx idx ;
  Idx outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  Idx cur_node ;
  re_node_set const   *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 3171
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
#line 3172
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3172
  if (tmp) {
#line 3173
    return (err);
  }
#line 3177
  idx = (Idx )0;
  {
#line 3177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3177
    if (! (idx < cur_nodes->nelem)) {
#line 3177
      goto while_break;
    }
    {
#line 3179
    cur_node = *(cur_nodes->elems + idx);
#line 3180
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
#line 3181
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, type);
    }
#line 3182
    if (outside_node == 0xffffffffffffffffUL) {
      {
#line 3185
      err = re_node_set_merge(& new_nodes, eclosure);
#line 3186
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3186
      if (tmp___0) {
        {
#line 3188
        free((void *)new_nodes.elems);
        }
#line 3189
        return (err);
      }
    } else {
      {
#line 3195
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, type);
#line 3197
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3197
      if (tmp___1) {
        {
#line 3199
        free((void *)new_nodes.elems);
        }
#line 3200
        return (err);
      }
    }
#line 3177
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3204
  free((void *)cur_nodes->elems);
#line 3205
  *cur_nodes = new_nodes;
  }
#line 3206
  return ((reg_errcode_t )0);
}
}
#line 3213 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) 
{ 
  Idx cur_node ;
  _Bool ok ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t err ;
  long tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;

  {
#line 3219
  cur_node = target;
  {
#line 3219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3219
    tmp___2 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
    }
#line 3219
    if (tmp___2) {
#line 3219
      goto while_break;
    }
#line 3223
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type) {
#line 3223
      if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3226
        if (type == 9) {
          {
#line 3228
          ok = re_node_set_insert(dst_nodes, cur_node);
#line 3229
          tmp = __builtin_expect((long )(! ok), 0L);
          }
#line 3229
          if (tmp) {
#line 3230
            return ((reg_errcode_t )12);
          }
        }
#line 3232
        goto while_break;
      }
    }
    {
#line 3234
    ok = re_node_set_insert(dst_nodes, cur_node);
#line 3235
    tmp___0 = __builtin_expect((long )(! ok), 0L);
    }
#line 3235
    if (tmp___0) {
#line 3236
      return ((reg_errcode_t )12);
    }
#line 3237
    if ((dfa->edests + cur_node)->nelem == 0UL) {
#line 3238
      goto while_break;
    }
#line 3239
    if ((dfa->edests + cur_node)->nelem == 2UL) {
      {
#line 3242
      err = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                         ex_subexp, type);
#line 3245
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3245
      if (tmp___1) {
#line 3246
        return (err);
      }
    }
#line 3248
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 3250
  return ((reg_errcode_t )0);
}
}
#line 3258 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx cache_idx_start ;
  Idx tmp ;
  struct re_backref_cache_entry *ent ;
  Idx to_idx ;
  Idx next_node ;
  Idx __attribute__((__pure__))  tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_node_set union_set ;
  _Bool ok ;
  Idx __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  struct re_backref_cache_entry *tmp___11 ;

  {
  {
#line 3263
  dfa = mctx->dfa;
#line 3265
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
#line 3265
  cache_idx_start = tmp;
  }
#line 3268
  if (cache_idx_start == 0xffffffffffffffffUL) {
#line 3269
    return ((reg_errcode_t )0);
  }
  restart: 
#line 3272
  ent = mctx->bkref_ents + cache_idx_start;
  {
#line 3273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3278
    tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
    }
#line 3278
    if (! tmp___0) {
#line 3279
      goto __Cont;
    }
#line 3281
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3284
    if (to_idx == cur_str) {
      {
#line 3290
      next_node = *((dfa->edests + ent->node)->elems + 0);
#line 3291
      tmp___1 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
      }
#line 3291
      if (tmp___1) {
#line 3292
        goto __Cont;
      }
      {
#line 3293
      err = re_node_set_init_1(& new_dests, next_node);
#line 3294
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, type);
#line 3295
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3296
      free((void *)new_dests.elems);
      }
#line 3297
      if ((int )err != 0) {
#line 3297
        tmp___3 = 1;
      } else
#line 3297
      if ((int )err2 != 0) {
#line 3297
        tmp___3 = 1;
      } else
#line 3297
      if ((int )err3 != 0) {
#line 3297
        tmp___3 = 1;
      } else {
#line 3297
        tmp___3 = 0;
      }
      {
#line 3297
      tmp___4 = __builtin_expect((long )tmp___3, 0L);
      }
#line 3297
      if (tmp___4) {
#line 3300
        if ((int )err != 0) {
#line 3300
          err = err;
        } else {
#line 3300
          if ((int )err2 != 0) {
#line 3300
            tmp___2 = (int )err2;
          } else {
#line 3300
            tmp___2 = (int )err3;
          }
#line 3300
          err = (reg_errcode_t )tmp___2;
        }
#line 3302
        return (err);
      }
#line 3305
      goto restart;
    } else {
#line 3310
      next_node = *(dfa->nexts + ent->node);
#line 3311
      if (*(mctx->state_log + to_idx)) {
        {
#line 3314
        tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
        }
#line 3314
        if (tmp___5) {
#line 3316
          goto __Cont;
        }
        {
#line 3317
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3319
        ok = re_node_set_insert(& union_set, next_node);
        }
#line 3320
        if ((int )err != 0) {
#line 3320
          tmp___6 = 1;
        } else
#line 3320
        if (! ok) {
#line 3320
          tmp___6 = 1;
        } else {
#line 3320
          tmp___6 = 0;
        }
        {
#line 3320
        tmp___7 = __builtin_expect((long )tmp___6, 0L);
        }
#line 3320
        if (tmp___7) {
          {
#line 3322
          free((void *)union_set.elems);
          }
#line 3323
          if ((int )err != 0) {
#line 3323
            err = err;
          } else {
#line 3323
            err = (reg_errcode_t )12;
          }
#line 3324
          return (err);
        }
      } else {
        {
#line 3329
        err = re_node_set_init_1(& union_set, next_node);
#line 3330
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3330
        if (tmp___8) {
#line 3331
          return (err);
        }
      }
      {
#line 3333
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3334
      free((void *)union_set.elems);
      }
#line 3335
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3335
        if ((int )err != 0) {
#line 3335
          tmp___9 = 1;
        } else {
#line 3335
          tmp___9 = 0;
        }
      } else {
#line 3335
        tmp___9 = 0;
      }
      {
#line 3335
      tmp___10 = __builtin_expect((long )tmp___9, 0L);
      }
#line 3335
      if (tmp___10) {
#line 3337
        return (err);
      }
    }
    __Cont: /* CIL Label */ 
#line 3273
    tmp___11 = ent;
#line 3273
    ent ++;
#line 3273
    if (! tmp___11->more) {
#line 3273
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3341
  return ((reg_errcode_t )0);
}
}
#line 3347 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state___0 ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  Idx j ;
  int ch ;
  _Bool need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  Idx ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct re_dfastate_t **tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  Idx next_node ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  struct re_dfastate_t **tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  struct re_dfastate_t **tmp___21 ;
  void *tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;

  {
#line 3354
  need_word_trtable = (_Bool)0;
#line 3356
  dests_node_malloced = (_Bool)0;
#line 3357
  dest_states_malloced = (_Bool)0;
#line 3360
  dest_states = (re_dfastate_t **)((void *)0);
#line 3375
  if (sizeof(struct dests_alloc ) < 4032UL) {
    {
#line 3376
    tmp = __builtin_alloca(sizeof(struct dests_alloc ));
#line 3376
    dests_alloc = (struct dests_alloc *)tmp;
    }
  } else {
    {
#line 3379
    tmp___0 = malloc(sizeof(struct dests_alloc ));
#line 3379
    dests_alloc = (struct dests_alloc *)tmp___0;
#line 3380
    tmp___1 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                               0L);
    }
#line 3380
    if (tmp___1) {
#line 3381
      return ((_Bool)0);
    }
#line 3382
    dests_node_malloced = (_Bool)1;
  }
  {
#line 3384
  dests_node = dests_alloc->dests_node;
#line 3385
  dests_ch = dests_alloc->dests_ch;
#line 3388
  tmp___2 = (struct re_dfastate_t **)((void *)0);
#line 3388
  state___0->trtable = tmp___2;
#line 3388
  state___0->word_trtable = tmp___2;
#line 3392
  ndests = group_nodes_into_DFAstates(dfa, (re_dfastate_t const   *)state___0, dests_node,
                                      dests_ch);
#line 3393
  tmp___4 = __builtin_expect((long )(! (ndests - 1UL < 0xfffffffffffffffdUL)), 0L);
  }
#line 3393
  if (tmp___4) {
#line 3395
    if (dests_node_malloced) {
      {
#line 3396
      free((void *)dests_alloc);
      }
    }
#line 3397
    if (ndests == 0UL) {
      {
#line 3399
      tmp___3 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3399
      state___0->trtable = (re_dfastate_t **)tmp___3;
      }
#line 3401
      return ((_Bool)1);
    }
#line 3403
    return ((_Bool)0);
  }
  {
#line 3406
  err = re_node_set_alloc(& follows, ndests + 1UL);
#line 3407
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3407
  if (tmp___5) {
#line 3408
    goto out_free;
  }
  {
#line 3411
  tmp___6 = __builtin_expect((long )((0xffffffffffffffffUL - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL) / (3UL * sizeof(re_dfastate_t *)) < ndests),
                             0L);
  }
#line 3411
  if (tmp___6) {
#line 3415
    goto out_free;
  }
#line 3417
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL + (ndests * 3UL) * sizeof(re_dfastate_t *) < 4032UL) {
    {
#line 3419
    tmp___7 = __builtin_alloca((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3419
    dest_states = (re_dfastate_t **)tmp___7;
    }
  } else {
    {
#line 3423
    tmp___8 = malloc((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3423
    dest_states = (re_dfastate_t **)tmp___8;
#line 3425
    tmp___9 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 3425
    if (tmp___9) {
      out_free: 
#line 3428
      if (dest_states_malloced) {
        {
#line 3429
        free((void *)dest_states);
        }
      }
      {
#line 3430
      free((void *)follows.elems);
#line 3431
      i = (Idx )0;
      }
      {
#line 3431
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3431
        if (! (i < ndests)) {
#line 3431
          goto while_break;
        }
        {
#line 3432
        free((void *)(dests_node + i)->elems);
#line 3431
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3433
      if (dests_node_malloced) {
        {
#line 3434
        free((void *)dests_alloc);
        }
      }
#line 3435
      return ((_Bool)0);
    }
#line 3437
    dest_states_malloced = (_Bool)1;
  }
  {
#line 3439
  dest_states_word = dest_states + ndests;
#line 3440
  dest_states_nl = dest_states_word + ndests;
#line 3441
  bitset_empty((bitset_word_t *)(acceptable));
#line 3444
  i = (Idx )0;
  }
  {
#line 3444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3444
    if (! (i < ndests)) {
#line 3444
      goto while_break___0;
    }
#line 3447
    follows.nelem = (Idx )0;
#line 3449
    j = (Idx )0;
    {
#line 3449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3449
      if (! (j < (dests_node + i)->nelem)) {
#line 3449
        goto while_break___1;
      }
#line 3451
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3452
      if (next_node != 0xffffffffffffffffUL) {
        {
#line 3454
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
#line 3455
        tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3455
        if (tmp___10) {
#line 3456
          goto out_free;
        }
      }
#line 3449
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3459
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
    }
#line 3460
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
#line 3460
      if ((int )err != 0) {
#line 3460
        tmp___11 = 1;
      } else {
#line 3460
        tmp___11 = 0;
      }
    } else {
#line 3460
      tmp___11 = 0;
    }
    {
#line 3460
    tmp___12 = __builtin_expect((long )tmp___11, 0L);
    }
#line 3460
    if (tmp___12) {
#line 3461
      goto out_free;
    }
#line 3464
    if ((*(dest_states + i))->has_constraint) {
      {
#line 3466
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
      }
#line 3468
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
#line 3468
        if ((int )err != 0) {
#line 3468
          tmp___13 = 1;
        } else {
#line 3468
          tmp___13 = 0;
        }
      } else {
#line 3468
        tmp___13 = 0;
      }
      {
#line 3468
      tmp___14 = __builtin_expect((long )tmp___13, 0L);
      }
#line 3468
      if (tmp___14) {
#line 3469
        goto out_free;
      }
#line 3471
      if ((unsigned long )*(dest_states + i) != (unsigned long )*(dest_states_word + i)) {
#line 3471
        if (dfa->mb_cur_max > 1) {
#line 3472
          need_word_trtable = (_Bool)1;
        }
      }
      {
#line 3474
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
      }
#line 3476
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
#line 3476
        if ((int )err != 0) {
#line 3476
          tmp___15 = 1;
        } else {
#line 3476
          tmp___15 = 0;
        }
      } else {
#line 3476
        tmp___15 = 0;
      }
      {
#line 3476
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
      }
#line 3476
      if (tmp___16) {
#line 3477
        goto out_free;
      }
    } else {
#line 3481
      *(dest_states_word + i) = *(dest_states + i);
#line 3482
      *(dest_states_nl + i) = *(dest_states + i);
    }
    {
#line 3484
    bitset_merge((bitset_word_t *)(acceptable), (bitset_word_t */* const  */)(*(dests_ch + i)));
#line 3444
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3487
  tmp___25 = __builtin_expect((long )need_word_trtable, 0L);
  }
#line 3487
  if (tmp___25) {
    {
#line 3524
    tmp___22 = calloc(sizeof(re_dfastate_t *), (size_t )512);
#line 3524
    tmp___21 = (re_dfastate_t **)tmp___22;
#line 3524
    state___0->word_trtable = tmp___21;
#line 3524
    trtable = tmp___21;
#line 3526
    tmp___23 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3526
    if (tmp___23) {
#line 3527
      goto out_free;
    }
#line 3530
    i = (Idx )0;
    {
#line 3530
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3530
      if (! (i < 4UL)) {
#line 3530
        goto while_break___2;
      }
#line 3531
      ch = (int )(i * 64UL);
#line 3531
      elem = acceptable[i];
#line 3531
      mask = (bitset_word_t )1;
      {
#line 3531
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3531
        if (! elem) {
#line 3531
          goto while_break___3;
        }
        {
#line 3534
        tmp___24 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3534
        if (tmp___24) {
#line 3538
          j = (Idx )0;
          {
#line 3538
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3538
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3538
              goto while_break___4;
            }
#line 3538
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3542
          *(trtable + ch) = *(dest_states + j);
#line 3543
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3531
        mask <<= 1;
#line 3531
        elem >>= 1;
#line 3531
        ch ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3530
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 3493
    tmp___18 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3493
    tmp___17 = (re_dfastate_t **)tmp___18;
#line 3493
    state___0->trtable = tmp___17;
#line 3493
    trtable = tmp___17;
#line 3495
    tmp___19 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3495
    if (tmp___19) {
#line 3496
      goto out_free;
    }
#line 3499
    i = (Idx )0;
    {
#line 3499
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3499
      if (! (i < 4UL)) {
#line 3499
        goto while_break___5;
      }
#line 3500
      ch = (int )(i * 64UL);
#line 3500
      elem = acceptable[i];
#line 3500
      mask = (bitset_word_t )1;
      {
#line 3500
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3500
        if (! elem) {
#line 3500
          goto while_break___6;
        }
        {
#line 3503
        tmp___20 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3503
        if (tmp___20) {
#line 3507
          j = (Idx )0;
          {
#line 3507
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3507
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3507
              goto while_break___7;
            }
#line 3507
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3511
          if (dfa->word_char[i] & mask) {
#line 3512
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3514
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3500
        mask <<= 1;
#line 3500
        elem >>= 1;
#line 3500
        ch ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3499
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 3548
  tmp___27 = bitset_contain((bitset_word_t */* const  */)(acceptable), (Idx )'\n');
  }
#line 3548
  if (tmp___27) {
#line 3551
    j = (Idx )0;
    {
#line 3551
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3551
      if (! (j < ndests)) {
#line 3551
        goto while_break___8;
      }
      {
#line 3552
      tmp___26 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )'\n');
      }
#line 3552
      if (tmp___26) {
#line 3555
        *(trtable + '\n') = *(dest_states_nl + j);
#line 3556
        if (need_word_trtable) {
#line 3557
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3560
        goto while_break___8;
      }
#line 3551
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 3564
  if (dest_states_malloced) {
    {
#line 3565
    free((void *)dest_states);
    }
  }
  {
#line 3567
  free((void *)follows.elems);
#line 3568
  i = (Idx )0;
  }
  {
#line 3568
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3568
    if (! (i < ndests)) {
#line 3568
      goto while_break___9;
    }
    {
#line 3569
    free((void *)(dests_node + i)->elems);
#line 3568
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3571
  if (dests_node_malloced) {
    {
#line 3572
    free((void *)dests_alloc);
    }
  }
#line 3574
  return ((_Bool)1);
}
}
#line 3582 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state___0 ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err ;
  _Bool ok ;
  Idx i ;
  Idx j ;
  Idx k ;
  Idx ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  _Bool tmp ;
  bitset_word_t any_set ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  _Bool tmp___4 ;
  bitset_word_t tmp___5 ;
  bitset_word_t tmp___6 ;
  bitset_word_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 3592
  cur_nodes = & state___0->nodes;
#line 3593
  bitset_empty((bitset_word_t *)(accepts));
#line 3594
  ndests = (Idx )0;
#line 3597
  i = (Idx )0;
  }
  {
#line 3597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3597
    if (! (i < (Idx )cur_nodes->nelem)) {
#line 3597
      goto while_break;
    }
#line 3599
    node = dfa->nodes + *(cur_nodes->elems + i);
#line 3600
    type = node->type;
#line 3601
    constraint = node->constraint;
#line 3604
    if ((unsigned int )type == 1U) {
      {
#line 3605
      bitset_set((bitset_word_t *)(accepts), (Idx )node->opr.c);
      }
    } else
#line 3606
    if ((unsigned int )type == 3U) {
      {
#line 3608
      bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)node->opr.sbcset);
      }
    } else
#line 3610
    if ((unsigned int )type == 5U) {
#line 3613
      if (dfa->mb_cur_max > 1) {
        {
#line 3614
        bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)dfa->sb_char);
        }
      } else {
        {
#line 3617
        bitset_set_all((bitset_word_t *)(accepts));
        }
      }
#line 3618
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3619
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3620
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3621
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else
#line 3624
    if ((unsigned int )type == 7U) {
      {
#line 3627
      memset((void *)(accepts), -1, (size_t )16);
      }
#line 3630
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3631
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3632
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3633
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else {
#line 3637
      goto __Cont;
    }
#line 3641
    if (constraint) {
#line 3643
      if (constraint & 32U) {
        {
#line 3645
        tmp = bitset_contain((bitset_word_t */* const  */)(accepts), (Idx )'\n');
#line 3645
        accepts_newline = tmp;
#line 3646
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3647
        if (accepts_newline) {
          {
#line 3648
          bitset_set((bitset_word_t *)(accepts), (Idx )'\n');
          }
        } else {
#line 3650
          goto __Cont;
        }
      }
#line 3652
      if (constraint & 128U) {
        {
#line 3654
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3655
        goto __Cont;
      }
#line 3658
      if (constraint & 4U) {
#line 3660
        any_set = (bitset_word_t )0;
#line 3661
        if ((unsigned int )type == 1U) {
#line 3661
          if (! node->word_char) {
            {
#line 3663
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3664
            goto __Cont;
          }
        }
#line 3667
        if (dfa->mb_cur_max > 1) {
#line 3668
          j = (Idx )0;
          {
#line 3668
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3668
            if (! (j < 4UL)) {
#line 3668
              goto while_break___0;
            }
#line 3669
            tmp___0 = accepts[j] & (dfa->word_char[j] | ~ *(dfa->sb_char + j));
#line 3669
            accepts[j] = tmp___0;
#line 3669
            any_set |= tmp___0;
#line 3668
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 3672
          j = (Idx )0;
          {
#line 3672
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3672
            if (! (j < 4UL)) {
#line 3672
              goto while_break___1;
            }
#line 3673
            tmp___1 = accepts[j] & dfa->word_char[j];
#line 3673
            accepts[j] = tmp___1;
#line 3673
            any_set |= tmp___1;
#line 3672
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 3674
        if (! any_set) {
#line 3675
          goto __Cont;
        }
      }
#line 3677
      if (constraint & 8U) {
#line 3679
        any_set___0 = (bitset_word_t )0;
#line 3680
        if ((unsigned int )type == 1U) {
#line 3680
          if (node->word_char) {
            {
#line 3682
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3683
            goto __Cont;
          }
        }
#line 3686
        if (dfa->mb_cur_max > 1) {
#line 3687
          j = (Idx )0;
          {
#line 3687
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3687
            if (! (j < 4UL)) {
#line 3687
              goto while_break___2;
            }
#line 3688
            tmp___2 = accepts[j] & ~ (dfa->word_char[j] & *(dfa->sb_char + j));
#line 3688
            accepts[j] = tmp___2;
#line 3688
            any_set___0 |= tmp___2;
#line 3687
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 3691
          j = (Idx )0;
          {
#line 3691
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3691
            if (! (j < 4UL)) {
#line 3691
              goto while_break___3;
            }
#line 3692
            tmp___3 = accepts[j] & ~ dfa->word_char[j];
#line 3692
            accepts[j] = tmp___3;
#line 3692
            any_set___0 |= tmp___3;
#line 3691
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3693
        if (! any_set___0) {
#line 3694
          goto __Cont;
        }
      }
    }
#line 3700
    j = (Idx )0;
    {
#line 3700
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3700
      if (! (j < ndests)) {
#line 3700
        goto while_break___4;
      }
#line 3708
      if ((unsigned int )type == 1U) {
        {
#line 3708
        tmp___4 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )node->opr.c);
        }
#line 3708
        if (! tmp___4) {
#line 3709
          goto __Cont___0;
        }
      }
#line 3712
      has_intersec = (bitset_word_t )0;
#line 3713
      k = (Idx )0;
      {
#line 3713
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3713
        if (! (k < 4UL)) {
#line 3713
          goto while_break___5;
        }
#line 3714
        tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3714
        intersec[k] = tmp___5;
#line 3714
        has_intersec |= tmp___5;
#line 3713
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3716
      if (! has_intersec) {
#line 3717
        goto __Cont___0;
      }
#line 3720
      not_consumed = (bitset_word_t )0;
#line 3720
      not_subset = not_consumed;
#line 3721
      k = (Idx )0;
      {
#line 3721
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3721
        if (! (k < 4UL)) {
#line 3721
          goto while_break___6;
        }
#line 3723
        tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3723
        remains[k] = tmp___6;
#line 3723
        not_subset |= tmp___6;
#line 3724
        tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3724
        accepts[k] = tmp___7;
#line 3724
        not_consumed |= tmp___7;
#line 3721
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3729
      if (not_subset) {
        {
#line 3731
        bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(remains));
#line 3732
        bitset_copy((bitset_word_t *)(*(dests_ch + j)), (bitset_word_t */* const  */)(intersec));
#line 3733
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3734
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3734
        if (tmp___8) {
#line 3735
          goto error_return;
        }
#line 3736
        ndests ++;
      }
      {
#line 3740
      ok = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
#line 3741
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 3741
      if (tmp___9) {
#line 3742
        goto error_return;
      }
#line 3745
      if (! not_consumed) {
#line 3746
        goto while_break___4;
      }
      __Cont___0: /* CIL Label */ 
#line 3700
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3749
    if (j == ndests) {
      {
#line 3751
      bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(accepts));
#line 3752
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
#line 3753
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3753
      if (tmp___10) {
#line 3754
        goto error_return;
      }
      {
#line 3755
      ndests ++;
#line 3756
      bitset_empty((bitset_word_t *)(accepts));
      }
    }
    __Cont: /* CIL Label */ 
#line 3597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3759
  return (ndests);
  error_return: 
#line 3761
  j = (Idx )0;
  {
#line 3761
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3761
    if (! (j < ndests)) {
#line 3761
      goto while_break___7;
    }
    {
#line 3762
    free((void *)(dests_node + j)->elems);
#line 3761
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3763
  return ((Idx )-1);
}
}
#line 3775 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) 
{ 
  re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  Idx i ;
  unsigned char c ;
  unsigned char d ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t __attribute__((__pure__))  tmp___4 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  wctype_t wt ;
  int tmp___6 ;
  wchar_t cmp_buf[6] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 3780
  node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 3784
  tmp___1 = __builtin_expect((long )((unsigned int const   )node->type == 7U), 0L);
  }
#line 3784
  if (tmp___1) {
    {
#line 3786
    c = *(input->mbs + str_idx);
#line 3787
    tmp = __builtin_expect((long )((int )c < 194), 1L);
    }
#line 3787
    if (tmp) {
#line 3788
      return (0);
    }
#line 3790
    if (str_idx + 2UL > (Idx )input->len) {
#line 3791
      return (0);
    }
#line 3793
    d = *(input->mbs + (str_idx + 1UL));
#line 3794
    if ((int )c < 224) {
#line 3795
      if ((int )d < 128) {
#line 3795
        tmp___0 = 0;
      } else
#line 3795
      if ((int )d > 191) {
#line 3795
        tmp___0 = 0;
      } else {
#line 3795
        tmp___0 = 2;
      }
#line 3795
      return (tmp___0);
    } else
#line 3796
    if ((int )c < 240) {
#line 3798
      char_len = 3;
#line 3799
      if ((int )c == 224) {
#line 3799
        if ((int )d < 160) {
#line 3800
          return (0);
        }
      }
    } else
#line 3802
    if ((int )c < 248) {
#line 3804
      char_len = 4;
#line 3805
      if ((int )c == 240) {
#line 3805
        if ((int )d < 144) {
#line 3806
          return (0);
        }
      }
    } else
#line 3808
    if ((int )c < 252) {
#line 3810
      char_len = 5;
#line 3811
      if ((int )c == 248) {
#line 3811
        if ((int )d < 136) {
#line 3812
          return (0);
        }
      }
    } else
#line 3814
    if ((int )c < 254) {
#line 3816
      char_len = 6;
#line 3817
      if ((int )c == 252) {
#line 3817
        if ((int )d < 132) {
#line 3818
          return (0);
        }
      }
    } else {
#line 3821
      return (0);
    }
#line 3823
    if (str_idx + (Idx )char_len > (Idx )input->len) {
#line 3824
      return (0);
    }
#line 3826
    i = (Idx )1;
    {
#line 3826
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3826
      if (! (i < (Idx )char_len)) {
#line 3826
        goto while_break;
      }
#line 3828
      d = *(input->mbs + (str_idx + i));
#line 3829
      if ((int )d < 128) {
#line 3830
        return (0);
      } else
#line 3829
      if ((int )d > 191) {
#line 3830
        return (0);
      }
#line 3826
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3832
    return (char_len);
  }
  {
#line 3835
  tmp___2 = re_string_char_size_at(input, str_idx);
#line 3835
  char_len = (int )tmp___2;
  }
#line 3836
  if ((unsigned int const   )node->type == 5U) {
#line 3838
    if (char_len <= 1) {
#line 3839
      return (0);
    }
#line 3843
    if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3843
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3847
        return (0);
      } else {
#line 3843
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3843
    if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3843
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3847
        return (0);
      }
    }
#line 3848
    return (char_len);
  }
  {
#line 3851
  tmp___3 = re_string_elem_size_at(input, str_idx);
#line 3851
  elem_len = (int )tmp___3;
  }
#line 3852
  if (elem_len <= 1) {
#line 3852
    if (char_len <= 1) {
#line 3853
      return (0);
    } else {
#line 3852
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3852
  if (char_len == 0) {
#line 3853
    return (0);
  }
#line 3855
  if ((unsigned int const   )node->type == 6U) {
#line 3857
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3864
    match_len = 0;
#line 3865
    if (cset->nranges) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else
#line 3865
    if (cset->nchar_classes) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else
#line 3865
    if (cset->nmbchars) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else {
#line 3865
      tmp___5 = (wint_t __attribute__((__pure__))  )0;
    }
#line 3865
    wc = (wchar_t )tmp___5;
#line 3869
    i = (Idx )0;
    {
#line 3869
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3869
      if (! (i < (Idx )cset->nmbchars)) {
#line 3869
        goto while_break___0;
      }
#line 3870
      if (wc == *(cset->mbchars + i)) {
#line 3872
        match_len = char_len;
#line 3873
        goto check_node_accept_bytes_match;
      }
#line 3869
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3876
    i = (Idx )0;
    {
#line 3876
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3876
      if (! (i < (Idx )cset->nchar_classes)) {
#line 3876
        goto while_break___1;
      }
      {
#line 3878
      wt = *(cset->char_classes + i);
#line 3879
      tmp___6 = iswctype((wint_t )wc, wt);
      }
#line 3879
      if (tmp___6) {
#line 3881
        match_len = char_len;
#line 3882
        goto check_node_accept_bytes_match;
      }
#line 3876
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3979
    cmp_buf[0] = 0;
#line 3979
    cmp_buf[1] = 0;
#line 3979
    cmp_buf[2] = wc;
#line 3979
    cmp_buf[3] = 0;
#line 3979
    cmp_buf[4] = 0;
#line 3979
    cmp_buf[5] = 0;
#line 3984
    i = (Idx )0;
    {
#line 3984
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3984
      if (! (i < (Idx )cset->nranges)) {
#line 3984
        goto while_break___2;
      }
      {
#line 3986
      cmp_buf[0] = *(cset->range_starts + i);
#line 3987
      cmp_buf[4] = *(cset->range_ends + i);
#line 3988
      tmp___7 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
      }
#line 3988
      if (tmp___7 <= 0) {
        {
#line 3988
        tmp___8 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
        }
#line 3988
        if (tmp___8 <= 0) {
#line 3991
          match_len = char_len;
#line 3992
          goto check_node_accept_bytes_match;
        }
      }
#line 3984
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    check_node_accept_bytes_match: 
#line 3997
    if (! cset->non_match) {
#line 3998
      return (match_len);
    } else
#line 4001
    if (match_len > 0) {
#line 4002
      return (0);
    } else {
#line 4004
      if (elem_len > char_len) {
#line 4004
        tmp___9 = elem_len;
      } else {
#line 4004
        tmp___9 = char_len;
      }
#line 4004
      return (tmp___9);
    }
  }
#line 4007
  return (0);
}
}
#line 4075 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) 
{ 
  unsigned char ch ;
  _Bool tmp ;
  unsigned int context ;
  unsigned int tmp___0 ;

  {
#line 4081
  ch = *(mctx->input.mbs + idx);
  {
#line 4084
  if ((unsigned int const   )node->type == 1U) {
#line 4084
    goto case_1;
  }
#line 4089
  if ((unsigned int const   )node->type == 3U) {
#line 4089
    goto case_3;
  }
#line 4095
  if ((unsigned int const   )node->type == 7U) {
#line 4095
    goto case_7;
  }
#line 4100
  if ((unsigned int const   )node->type == 5U) {
#line 4100
    goto case_5;
  }
#line 4106
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4085
  if ((int const   )node->opr.c != (int const   )ch) {
#line 4086
    return ((_Bool)0);
  }
#line 4087
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4090
  tmp = bitset_contain((bitset_word_t */* const  */)node->opr.sbcset, (Idx )ch);
  }
#line 4090
  if (! tmp) {
#line 4091
    return ((_Bool)0);
  }
#line 4092
  goto switch_break;
  case_7: /* CIL Label */ 
#line 4096
  if ((int )ch >= 128) {
#line 4097
    return ((_Bool)0);
  }
  case_5: /* CIL Label */ 
#line 4101
  if ((int )ch == 10) {
#line 4101
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4103
      return ((_Bool)0);
    } else {
#line 4101
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4101
  if ((int )ch == 0) {
#line 4101
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4103
      return ((_Bool)0);
    }
  }
#line 4104
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4107
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
#line 4110
  if (node->constraint) {
    {
#line 4114
    tmp___0 = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 4114
    context = tmp___0;
    }
#line 4116
    if (node->constraint & 4U) {
#line 4116
      if (! (context & 1U)) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 4116
    if (node->constraint & 8U) {
#line 4116
      if (context & 1U) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4116
    if (node->constraint & 32U) {
#line 4116
      if (! (context & (unsigned int )(1 << 1))) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4116
    if (node->constraint & 128U) {
#line 4116
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 4117
        return ((_Bool)0);
      }
    }
  }
#line 4120
  return ((_Bool)1);
}
}
#line 4125 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  long tmp ;
  long tmp___0 ;
  re_dfastate_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 4130
  pstr = & mctx->input;
#line 4133
  tmp = __builtin_expect((long )(9223372036854775807UL / sizeof(re_dfastate_t *) <= pstr->bufs_len),
                         0L);
  }
#line 4133
  if (tmp) {
#line 4134
    return ((reg_errcode_t )12);
  }
  {
#line 4137
  ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2UL);
#line 4138
  tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 4138
  if (tmp___0) {
#line 4139
    return (ret);
  }
#line 4141
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 4147
    tmp___1 = realloc((void *)mctx->state_log, (pstr->bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 4147
    new_array = (re_dfastate_t **)tmp___1;
#line 4149
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4149
    if (tmp___2) {
#line 4150
      return ((reg_errcode_t )12);
    }
#line 4151
    mctx->state_log = new_array;
  }
#line 4155
  if (pstr->icase) {
#line 4158
    if (pstr->mb_cur_max > 1) {
      {
#line 4160
      ret = build_wcs_upper_buffer(pstr);
#line 4161
      tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 4161
      if (tmp___3) {
#line 4162
        return (ret);
      }
    } else {
      {
#line 4166
      build_upper_buffer(pstr);
      }
    }
  } else
#line 4171
  if (pstr->mb_cur_max > 1) {
    {
#line 4172
    build_wcs_buffer(pstr);
    }
  } else
#line 4176
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
#line 4177
    re_string_translate_buffer(pstr);
    }
  }
#line 4180
  return ((reg_errcode_t )0);
}
}
#line 4188 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) 
{ 
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 4192
  mctx->eflags = eflags;
#line 4193
  mctx->match_last = (Idx )-1;
#line 4194
  if (n > 0UL) {
#line 4197
    if (sizeof(struct re_backref_cache_entry ) < sizeof(re_sub_match_top_t *)) {
#line 4197
      tmp = sizeof(re_sub_match_top_t *);
    } else {
#line 4197
      tmp = sizeof(struct re_backref_cache_entry );
    }
    {
#line 4197
    max_object_size = tmp;
#line 4200
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < n),
                               0L);
    }
#line 4200
    if (tmp___0) {
#line 4201
      return ((reg_errcode_t )12);
    }
    {
#line 4203
    tmp___1 = malloc(n * sizeof(struct re_backref_cache_entry ));
#line 4203
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp___1;
#line 4204
    tmp___2 = malloc(n * sizeof(re_sub_match_top_t *));
#line 4204
    mctx->sub_tops = (re_sub_match_top_t **)tmp___2;
    }
#line 4205
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 4205
      tmp___3 = 1;
    } else
#line 4205
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 4205
      tmp___3 = 1;
    } else {
#line 4205
      tmp___3 = 0;
    }
    {
#line 4205
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 4205
    if (tmp___4) {
#line 4206
      return ((reg_errcode_t )12);
    }
  }
#line 4213
  mctx->abkref_ents = n;
#line 4214
  mctx->max_mb_elem_len = 1;
#line 4215
  mctx->asub_tops = n;
#line 4216
  return ((reg_errcode_t )0);
}
}
#line 4223 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 
  Idx st_idx ;
  Idx sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4228
  st_idx = (Idx )0;
  {
#line 4228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4228
    if (! (st_idx < mctx->nsub_tops)) {
#line 4228
      goto while_break;
    }
#line 4231
    top = *(mctx->sub_tops + st_idx);
#line 4232
    sl_idx = (Idx )0;
    {
#line 4232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4232
      if (! (sl_idx < top->nlasts)) {
#line 4232
        goto while_break___0;
      }
      {
#line 4234
      last = *(top->lasts + sl_idx);
#line 4235
      free((void *)last->path.array);
#line 4236
      free((void *)last);
#line 4232
      sl_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4238
    free((void *)top->lasts);
    }
#line 4239
    if (top->path) {
      {
#line 4241
      free((void *)(top->path)->array);
#line 4242
      free((void *)top->path);
      }
    }
    {
#line 4244
    free((void *)top);
#line 4228
    st_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4247
  mctx->nsub_tops = (Idx )0;
#line 4248
  mctx->nbkref_ents = (Idx )0;
#line 4249
  return;
}
}
#line 4253 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
  {
#line 4258
  match_ctx_clean(mctx);
#line 4259
  free((void *)mctx->sub_tops);
#line 4260
  free((void *)mctx->bkref_ents);
  }
#line 4261
  return;
}
}
#line 4268 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 4273
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
#line 4276
    tmp = realloc((void *)mctx->bkref_ents, (mctx->abkref_ents * 2UL) * sizeof(struct re_backref_cache_entry ));
#line 4276
    new_entry = (struct re_backref_cache_entry *)tmp;
#line 4278
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
#line 4278
    if (tmp___0) {
      {
#line 4280
      free((void *)mctx->bkref_ents);
      }
#line 4281
      return ((reg_errcode_t )12);
    }
    {
#line 4283
    mctx->bkref_ents = new_entry;
#line 4284
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * mctx->abkref_ents);
#line 4286
    mctx->abkref_ents *= 2UL;
    }
  }
#line 4288
  if (mctx->nbkref_ents > 0UL) {
#line 4288
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->str_idx == str_idx) {
#line 4290
      (mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->more = (char)1;
    }
  }
#line 4292
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4293
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4294
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4295
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4305
  if (from == to) {
#line 4305
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)65535;
  } else {
#line 4305
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)0;
  }
#line 4308
  tmp___1 = mctx->nbkref_ents;
#line 4308
  (mctx->nbkref_ents) ++;
#line 4308
  (mctx->bkref_ents + tmp___1)->more = (char)0;
#line 4309
  if ((Idx )mctx->max_mb_elem_len < to - from) {
#line 4310
    mctx->max_mb_elem_len = (int )(to - from);
  }
#line 4311
  return ((reg_errcode_t )0);
}
}
#line 4317 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) 
{ 
  Idx left ;
  Idx right ;
  Idx mid ;
  Idx last ;

  {
#line 4322
  right = (Idx )mctx->nbkref_ents;
#line 4322
  last = right;
#line 4323
  left = (Idx )0;
  {
#line 4323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4323
    if (! (left < right)) {
#line 4323
      goto while_break;
    }
#line 4325
    mid = (left + right) / 2UL;
#line 4326
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4327
      left = mid + 1UL;
    } else {
#line 4329
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4331
  if (left < last) {
#line 4331
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4332
      return (left);
    } else {
#line 4334
      return ((Idx )-1);
    }
  } else {
#line 4334
    return ((Idx )-1);
  }
}
}
#line 4340 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) 
{ 
  Idx new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 4348
  tmp___1 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
  }
#line 4348
  if (tmp___1) {
    {
#line 4350
    new_asub_tops = mctx->asub_tops * 2UL;
#line 4351
    tmp = realloc((void *)mctx->sub_tops, new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4351
    new_array = (re_sub_match_top_t **)tmp;
#line 4354
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4354
    if (tmp___0) {
#line 4355
      return ((reg_errcode_t )12);
    }
#line 4356
    mctx->sub_tops = new_array;
#line 4357
    mctx->asub_tops = new_asub_tops;
  }
  {
#line 4359
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
#line 4359
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___2;
#line 4360
  tmp___3 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
  }
#line 4360
  if (tmp___3) {
#line 4361
    return ((reg_errcode_t )12);
  }
#line 4362
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4363
  tmp___4 = mctx->nsub_tops;
#line 4363
  (mctx->nsub_tops) ++;
#line 4363
  (*(mctx->sub_tops + tmp___4))->str_idx = str_idx;
#line 4364
  return ((reg_errcode_t )0);
}
}
#line 4370 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  Idx new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 4375
  tmp___1 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
  }
#line 4375
  if (tmp___1) {
    {
#line 4377
    new_alasts = 2UL * subtop->alasts + 1UL;
#line 4378
    tmp = realloc((void *)subtop->lasts, new_alasts * sizeof(re_sub_match_last_t *));
#line 4378
    new_array = (re_sub_match_last_t **)tmp;
#line 4381
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4381
    if (tmp___0) {
#line 4382
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4383
    subtop->lasts = new_array;
#line 4384
    subtop->alasts = new_alasts;
  }
  {
#line 4386
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
#line 4386
  new_entry = (re_sub_match_last_t *)tmp___2;
#line 4387
  tmp___3 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
  }
#line 4387
  if (tmp___3) {
#line 4389
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4390
    new_entry->node = node;
#line 4391
    new_entry->str_idx = str_idx;
#line 4392
    (subtop->nlasts) ++;
  }
#line 4394
  return (new_entry);
}
}
#line 4397 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) 
{ 


  {
  {
#line 4402
  sctx->sifted_states = sifted_sts;
#line 4403
  sctx->limited_states = limited_sts;
#line 4404
  sctx->last_node = last_node;
#line 4405
  sctx->last_str_idx = last_str_idx;
#line 4406
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
  }
#line 4407
  return;
}
}
#line 53 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 59
extern void endutxent(void) ;
#line 65
extern struct utmpx *getutxent(void) ;
#line 93
extern int utmpxname(char const   *__file ) ;
#line 212 "/home/khheo/project/benchmark/coreutils-7.1/lib/readutmp.h"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) ;
#line 213
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/readutmp.c"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) 
{ 
  char *p ;
  char *trimmed_name ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 53
  tmp = xmalloc(sizeof(ut->ut_user) + 1UL);
#line 53
  trimmed_name = (char *)tmp;
#line 54
  strncpy((char */* __restrict  */)trimmed_name, (char const   */* __restrict  */)(ut->ut_user),
          sizeof(ut->ut_user));
#line 58
  *(trimmed_name + sizeof(ut->ut_user)) = (char )'\000';
#line 59
  tmp___0 = strlen((char const   *)trimmed_name);
#line 59
  p = trimmed_name + tmp___0;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if ((unsigned long )trimmed_name < (unsigned long )p) {
#line 59
      if (! ((int )*(p + -1) == 32)) {
#line 59
        goto while_break;
      }
    } else {
#line 59
      goto while_break;
    }
#line 62
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 59
    p --;
#line 59
    *p = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (trimmed_name);
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/readutmp.c"
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const   *u , int options ) 
{ 
  _Bool user_proc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 71
  if (u->ut_user[0]) {
#line 71
    if ((int const   )u->ut_type == 7) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  user_proc = (_Bool )tmp;
#line 72
  if (options & 2) {
#line 72
    if (! user_proc) {
#line 73
      return ((_Bool)0);
    }
  }
#line 74
  if (options & 1) {
#line 74
    if (user_proc) {
#line 74
      if (u->ut_pid <= 0) {
#line 78
        return ((_Bool)0);
      } else {
        {
#line 74
        tmp___0 = kill((__pid_t )u->ut_pid, 0);
        }
#line 74
        if (tmp___0 < 0) {
          {
#line 74
          tmp___1 = __errno_location();
          }
#line 74
          if (*tmp___1 == 3) {
#line 78
            return ((_Bool)0);
          }
        }
      }
    }
  }
#line 79
  return ((_Bool)1);
}
}
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/readutmp.c"
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) 
{ 
  size_t n_read ;
  size_t n_alloc ;
  STRUCT_UTMP *utmp ;
  STRUCT_UTMP *u ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 95
  n_read = (size_t )0;
#line 96
  n_alloc = (size_t )0;
#line 97
  utmp = (STRUCT_UTMP *)((void *)0);
#line 104
  utmpxname(file);
#line 106
  setutxent();
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    u = getutxent();
    }
#line 108
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 108
      goto while_break;
    }
    {
#line 109
    tmp___1 = desirable_utmp_entry((STRUCT_UTMP const   *)u, options);
    }
#line 109
    if (tmp___1) {
#line 111
      if (n_read == n_alloc) {
        {
#line 112
        tmp = x2nrealloc((void *)utmp, & n_alloc, sizeof(*utmp));
#line 112
        utmp = (STRUCT_UTMP *)tmp;
        }
      }
#line 114
      tmp___0 = n_read;
#line 114
      n_read ++;
#line 114
      *(utmp + tmp___0) = *u;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  endutxent();
#line 119
  *n_entries = n_read;
#line 120
  *utmp_buf = utmp;
  }
#line 122
  return (0);
}
}
#line 180 "/home/khheo/project/benchmark/coreutils-7.1/lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.h"
void readtokens0_init(struct Tokens *t ) ;
#line 39
void readtokens0_free(struct Tokens *t ) ;
#line 40
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
#line 29 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.c"
void readtokens0_init(struct Tokens *t ) 
{ 


  {
  {
#line 32
  t->n_tok = (size_t )0;
#line 33
  t->tok = (char **)((void *)0);
#line 34
  t->tok_len = (size_t *)((void *)0);
#line 35
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 36
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 37
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
  }
#line 38
  return;
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.c"
void readtokens0_free(struct Tokens *t ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___1 ;

  {
#line 43
  __o = & t->o_data;
#line 43
  __obj = (void *)0;
#line 43
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 43
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 43
      tmp = (char *)__obj;
#line 43
      __o->object_base = tmp;
#line 43
      __o->next_free = tmp;
    } else {
      {
#line 43
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 43
    obstack_free(__o, __obj);
    }
  }
#line 44
  __o___0 = & t->o_tok;
#line 44
  __obj___0 = (void *)0;
#line 44
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 44
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 44
      tmp___0 = (char *)__obj___0;
#line 44
      __o___0->object_base = tmp___0;
#line 44
      __o___0->next_free = tmp___0;
    } else {
      {
#line 44
      obstack_free(__o___0, __obj___0);
      }
    }
  } else {
    {
#line 44
    obstack_free(__o___0, __obj___0);
    }
  }
#line 45
  __o___1 = & t->o_tok_len;
#line 45
  __obj___1 = (void *)0;
#line 45
  if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
#line 45
    if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 45
      tmp___1 = (char *)__obj___1;
#line 45
      __o___1->object_base = tmp___1;
#line 45
      __o___1->next_free = tmp___1;
    } else {
      {
#line 45
      obstack_free(__o___1, __obj___1);
      }
    }
  } else {
    {
#line 45
    obstack_free(__o___1, __obj___1);
    }
  }
#line 46
  return;
}
}
#line 50 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.c"
static void save_token(struct Tokens *t ) 
{ 
  size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
#line 54
  __o = (struct obstack  const  *)(& t->o_data);
#line 54
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
#line 55
  __o1 = & t->o_data;
#line 55
  __value = (void *)__o1->object_base;
#line 55
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 55
    __o1->maybe_empty_object = 1U;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp = __o1->object_base;
  } else {
#line 55
    tmp = (char *)0;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp___0 = __o1->object_base;
  } else {
#line 55
    tmp___0 = (char *)0;
  }
#line 55
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 55
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 55
    __o1->next_free = __o1->chunk_limit;
  }
#line 55
  __o1->object_base = __o1->next_free;
#line 55
  s = (char const   *)__value;
#line 56
  __o___0 = & t->o_tok;
#line 56
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
    {
#line 56
    _obstack_newchunk(__o___0, (int )sizeof(void *));
    }
  }
#line 56
  __o1___0 = __o___0;
#line 56
  *((void const   **)__o1___0->next_free) = (void const   *)s;
#line 56
  __o1___0->next_free += sizeof(void const   *);
#line 57
  __o___1 = & t->o_tok_len;
#line 57
  __len = (int )sizeof(len);
#line 57
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
    {
#line 57
    _obstack_newchunk(__o___1, __len);
    }
  }
  {
#line 57
  memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(& len),
         (size_t )__len);
#line 57
  __o___1->next_free += __len;
#line 58
  (t->n_tok) ++;
  }
#line 59
  return;
}
}
#line 65 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.c"
_Bool readtokens0(FILE *in , struct Tokens *t ) 
{ 
  int c ;
  int tmp ;
  size_t len ;
  struct obstack  const  *__o ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    tmp = fgetc(in);
#line 71
    c = tmp;
    }
#line 72
    if (c == -1) {
#line 74
      __o = (struct obstack  const  *)(& t->o_data);
#line 74
      len = (size_t )((unsigned int )(__o->next_free - __o->object_base));
#line 78
      if (len) {
#line 80
        __o___0 = & t->o_data;
#line 80
        if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
          {
#line 80
          _obstack_newchunk(__o___0, 1);
          }
        }
        {
#line 80
        tmp___0 = __o___0->next_free;
#line 80
        (__o___0->next_free) ++;
#line 80
        *tmp___0 = (char )'\000';
#line 81
        save_token(t);
        }
      }
#line 84
      goto while_break;
    }
#line 87
    __o___1 = & t->o_data;
#line 87
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 87
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 87
    tmp___1 = __o___1->next_free;
#line 87
    (__o___1->next_free) ++;
#line 87
    *tmp___1 = (char )c;
#line 88
    if (c == 0) {
      {
#line 89
      save_token(t);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  __o___2 = & t->o_tok;
#line 94
  if ((unsigned long )(__o___2->next_free + sizeof(void *)) > (unsigned long )__o___2->chunk_limit) {
    {
#line 94
    _obstack_newchunk(__o___2, (int )sizeof(void *));
    }
  }
#line 94
  __o1 = __o___2;
#line 94
  *((void const   **)__o1->next_free) = (void const   *)((void *)0);
#line 94
  __o1->next_free += sizeof(void const   *);
#line 96
  __o1___0 = & t->o_tok;
#line 96
  __value = (void *)__o1___0->object_base;
#line 96
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 96
    __o1___0->maybe_empty_object = 1U;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___2 = __o1___0->object_base;
  } else {
#line 96
    tmp___2 = (char *)0;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___3 = __o1___0->object_base;
  } else {
#line 96
    tmp___3 = (char *)0;
  }
#line 96
  __o1___0->next_free = tmp___2 + (((__o1___0->next_free - tmp___3) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 96
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 96
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 96
  __o1___0->object_base = __o1___0->next_free;
#line 96
  t->tok = (char **)__value;
#line 97
  __o1___1 = & t->o_tok_len;
#line 97
  __value___0 = (void *)__o1___1->object_base;
#line 97
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___0) {
#line 97
    __o1___1->maybe_empty_object = 1U;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___4 = __o1___1->object_base;
  } else {
#line 97
    tmp___4 = (char *)0;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___5 = __o1___1->object_base;
  } else {
#line 97
    tmp___5 = (char *)0;
  }
#line 97
  __o1___1->next_free = tmp___4 + (((__o1___1->next_free - tmp___5) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 97
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 97
    __o1___1->next_free = __o1___1->chunk_limit;
  }
  {
#line 97
  __o1___1->object_base = __o1___1->next_free;
#line 97
  t->tok_len = (size_t *)__value___0;
#line 98
  tmp___6 = ferror(in);
  }
#line 98
  if (tmp___6) {
#line 98
    tmp___7 = 0;
  } else {
#line 98
    tmp___7 = 1;
  }
#line 98
  return ((_Bool )tmp___7);
}
}
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.h"
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
#line 34
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
#line 37
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
void init_tokenbuffer(token_buffer *tokenbuffer ) 
{ 


  {
#line 47
  tokenbuffer->size = (size_t )0;
#line 48
  tokenbuffer->buffer = (char *)((void *)0);
#line 49
  return;
}
}
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
static char const   *saved_delim  =    (char const   *)((void *)0);
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
static char isdelim[256]  ;
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) 
{ 
  char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 77
  if ((unsigned long )delim == (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )saved_delim == (unsigned long )((void *)0)) {
      {
#line 78
      abort();
      }
    }
  }
#line 80
  same_delimiters = (_Bool)0;
#line 81
  if ((unsigned long )delim != (unsigned long )saved_delim) {
#line 81
    if ((unsigned long )saved_delim != (unsigned long )((void *)0)) {
#line 83
      same_delimiters = (_Bool)1;
#line 84
      i = (size_t )0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;
#line 84
        if (! (i < n_delim)) {
#line 84
          goto while_break;
        }
#line 86
        if ((int const   )*(delim + i) != (int const   )*(saved_delim + i)) {
#line 88
          same_delimiters = (_Bool)0;
#line 89
          goto while_break;
        }
#line 84
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 94
  if (! same_delimiters) {
    {
#line 97
    saved_delim = delim;
#line 98
    memset((void *)(isdelim), 0, sizeof(isdelim));
#line 99
    j = (size_t )0;
    }
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (j < n_delim)) {
#line 99
        goto while_break___0;
      }
#line 101
      ch = (unsigned char )*(delim + j);
#line 102
      isdelim[ch] = (char)1;
#line 99
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 108
  c = getc_unlocked(stream);
  }
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 108
    if (c >= 0) {
#line 108
      if (! isdelim[c]) {
#line 108
        goto while_break___1;
      }
    } else {
#line 108
      goto while_break___1;
    }
    {
#line 108
    c = getc_unlocked(stream);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 113
  p = tokenbuffer->buffer;
#line 114
  n = tokenbuffer->size;
#line 115
  i = (size_t )0;
  {
#line 116
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 118
    if (c < 0) {
#line 118
      if (i == 0UL) {
#line 119
        return ((size_t )-1);
      }
    }
#line 121
    if (i == n) {
      {
#line 122
      tmp = x2nrealloc((void *)p, & n, sizeof(*p));
#line 122
      p = (char *)tmp;
      }
    }
#line 124
    if (c < 0) {
#line 126
      *(p + i) = (char)0;
#line 127
      goto while_break___2;
    }
#line 129
    if (isdelim[c]) {
#line 131
      *(p + i) = (char)0;
#line 132
      goto while_break___2;
    }
    {
#line 134
    tmp___0 = i;
#line 134
    i ++;
#line 134
    *(p + tmp___0) = (char )c;
#line 135
    c = getc_unlocked(stream);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 138
  tokenbuffer->buffer = p;
#line 139
  tokenbuffer->size = n;
#line 140
  return (i);
}
}
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) 
{ 
  token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t token_length ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 158
  token = & tb;
#line 164
  if (projected_n_tokens == 0UL) {
#line 165
    projected_n_tokens = (size_t )64;
  } else {
#line 167
    projected_n_tokens ++;
  }
  {
#line 169
  sz = projected_n_tokens;
#line 170
  tmp = xnmalloc(sz, sizeof(*tokens));
#line 170
  tokens = (char **)tmp;
#line 171
  tmp___0 = xnmalloc(sz, sizeof(*lengths));
#line 171
  lengths = (size_t *)tmp___0;
#line 173
  n_tokens = (size_t )0;
#line 174
  init_tokenbuffer(token);
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    tmp___2 = readtoken(stream, delim, n_delim, token);
#line 178
    token_length = tmp___2;
    }
#line 179
    if (n_tokens >= sz) {
      {
#line 181
      tmp___3 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
#line 181
      tokens = (char **)tmp___3;
#line 182
      tmp___4 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
#line 182
      lengths = (size_t *)tmp___4;
      }
    }
#line 185
    if (token_length == 0xffffffffffffffffUL) {
#line 188
      *(tokens + n_tokens) = (char *)((void *)0);
#line 189
      *(lengths + n_tokens) = (size_t )0;
#line 190
      goto while_break;
    }
    {
#line 192
    tmp___5 = xnmalloc(token_length + 1UL, sizeof(*tmp___1));
#line 192
    tmp___1 = (char *)tmp___5;
#line 193
    *(lengths + n_tokens) = token_length;
#line 194
    tmp___6 = memcpy((void */* __restrict  */)tmp___1, (void const   */* __restrict  */)token->buffer,
                     token_length + 1UL);
#line 194
    *(tokens + n_tokens) = (char *)tmp___6;
#line 195
    n_tokens ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  free((void *)token->buffer);
#line 199
  *tokens_out = tokens;
  }
#line 200
  if ((unsigned long )token_lengths != (unsigned long )((void *)0)) {
#line 201
    *token_lengths = lengths;
  }
#line 202
  return (n_tokens);
}
}
#line 27 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.h"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) ;
#line 28
void randread(struct randread_source *s , void *buf___1 , size_t size ) ;
#line 29
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) ;
#line 30
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) ;
#line 31
int randread_free(struct randread_source *s ) ;
#line 294 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.h"
void isaac_seed(struct isaac_state *s ) ;
#line 41
void isaac_refill(struct isaac_state *s , uint32_t *r ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void randread_error(void const   *file_name___3 ) 
{ 
  char *tmp ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 122
  if (file_name___3) {
    {
#line 123
    tmp = quotearg_colon((char const   *)file_name___3);
#line 123
    tmp___2 = __errno_location();
    }
#line 123
    if (*tmp___2 == 0) {
#line 123
      tmp___1 = "%s: end of file";
    } else {
#line 123
      tmp___1 = "%s: read error";
    }
    {
#line 123
    tmp___3 = gettext(tmp___1);
#line 123
    tmp___4 = __errno_location();
#line 123
    error((int )exit_failure, *tmp___4, (char const   *)tmp___3, tmp);
    }
  }
  {
#line 126
  abort();
  }
}
}
#line 132 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static struct randread_source *simple_new(FILE *source , void const   *handler_arg ) 
{ 
  struct randread_source *s ;
  void *tmp ;

  {
  {
#line 135
  tmp = xmalloc(sizeof(*s));
#line 135
  s = (struct randread_source *)tmp;
#line 136
  s->source = source;
#line 137
  s->handler = & randread_error;
#line 138
  s->handler_arg = handler_arg;
  }
#line 139
  return (s);
}
}
#line 153 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) 
{ 
  struct randread_source *tmp ;
  char const   *file_name___3 ;
  char const   *tmp___0 ;
  FILE *source ;
  FILE *tmp___1 ;
  struct randread_source *s ;
  unsigned long tmp___2 ;

  {
#line 156
  if (bytes_bound == 0UL) {
    {
#line 157
    tmp = simple_new((FILE *)((void *)0), (void const   *)((void *)0));
    }
#line 157
    return (tmp);
  } else {
#line 160
    if (name) {
#line 160
      tmp___0 = name;
    } else {
#line 160
      tmp___0 = "/dev/urandom";
    }
    {
#line 160
    file_name___3 = tmp___0;
#line 161
    tmp___1 = fopen_safer(file_name___3, "rb");
#line 161
    source = tmp___1;
    }
#line 164
    if (! source) {
#line 166
      if (name) {
#line 167
        return ((struct randread_source *)((void *)0));
      }
#line 168
      file_name___3 = (char const   *)((void *)0);
    }
    {
#line 171
    s = simple_new(source, (void const   *)file_name___3);
    }
#line 173
    if (source) {
#line 174
      if (sizeof(s->buf.c) < bytes_bound) {
#line 174
        tmp___2 = sizeof(s->buf.c);
      } else {
#line 174
        tmp___2 = bytes_bound;
      }
      {
#line 174
      setvbuf((FILE */* __restrict  */)source, (char */* __restrict  */)(s->buf.c),
              0, tmp___2);
      }
    } else {
      {
#line 177
      s->buf.isaac.buffered = (size_t )0;
#line 178
      isaac_seed(& s->buf.isaac.state);
      }
    }
#line 181
    return (s);
  }
}
}
#line 193 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) 
{ 


  {
#line 196
  s->handler = handler;
#line 197
  return;
}
}
#line 199 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) 
{ 


  {
#line 202
  s->handler_arg = handler_arg;
#line 203
  return;
}
}
#line 209 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  size_t tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    tmp = fread_unlocked((void */* __restrict  */)p, sizeof(*p), size, (FILE */* __restrict  */)s->source);
#line 214
    inbytes = tmp;
#line 215
    tmp___0 = __errno_location();
#line 215
    fread_errno = *tmp___0;
#line 216
    p += inbytes;
#line 217
    size -= inbytes;
    }
#line 218
    if (size == 0UL) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___1 = __errno_location();
#line 220
    tmp___3 = ferror_unlocked(s->source);
    }
#line 220
    if (tmp___3) {
#line 220
      *tmp___1 = fread_errno;
    } else {
#line 220
      *tmp___1 = 0;
    }
    {
#line 221
    (*(s->handler))(s->handler_arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 229 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  uint32_t *wp ;

  {
#line 232
  inbytes = isaac->buffered;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (size <= inbytes) {
      {
#line 238
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
             size);
#line 239
      isaac->buffered = inbytes - size;
      }
#line 240
      return;
    }
    {
#line 243
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
           inbytes);
#line 244
    p += inbytes;
#line 245
    size -= inbytes;
    }
#line 249
    if ((size_t )p % (unsigned long )(& ((struct __anonstruct_833865290___1 *)0)->x) == 0UL) {
#line 251
      wp = (uint32_t *)p;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 252
        if (! ((unsigned long )(1 << 8) * sizeof(uint32_t ) <= size)) {
#line 252
          goto while_break___0;
        }
        {
#line 254
        isaac_refill(& isaac->state, (uint32_t *)wp);
#line 255
        wp += 1 << 8;
#line 256
        size -= (unsigned long )(1 << 8) * sizeof(uint32_t );
        }
#line 257
        if (size == 0UL) {
#line 259
          isaac->buffered = (size_t )0;
#line 260
          return;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 263
      p = (unsigned char *)wp;
    }
    {
#line 266
    isaac_refill(& isaac->state, (uint32_t *)(isaac->data.w));
#line 267
    inbytes = (unsigned long )(1 << 8) * sizeof(uint32_t );
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 275 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
void randread(struct randread_source *s , void *buf___1 , size_t size ) 
{ 


  {
#line 278
  if (s->source) {
    {
#line 279
    readsource(s, (unsigned char *)buf___1, size);
    }
  } else {
    {
#line 281
    readisaac(& s->buf.isaac, (unsigned char *)buf___1, size);
    }
  }
#line 282
  return;
}
}
#line 290 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
int randread_free(struct randread_source *s ) 
{ 
  FILE *source ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 293
  source = s->source;
#line 294
  memset((void *)s, 0, sizeof(*s));
#line 295
  free((void *)s);
  }
#line 296
  if (source) {
    {
#line 296
    tmp = fclose(source);
#line 296
    tmp___0 = tmp;
    }
  } else {
#line 296
    tmp___0 = 0;
  }
#line 296
  return (tmp___0);
}
}
#line 42 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.h"
__inline static randint randint_choose(struct randint_source *s , randint choices ) 
{ 
  randint tmp ;

  {
  {
#line 45
  tmp = randint_genmax(s, choices - 1UL);
  }
#line 45
  return (tmp);
}
}
#line 3 "/home/khheo/project/benchmark/coreutils-7.1/lib/randperm.h"
size_t randperm_bound(size_t h , size_t n ) ;
#line 4
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/randperm.c"
static size_t ceil_lg(size_t n ) 
{ 
  size_t b ;

  {
#line 34
  b = (size_t )0;
#line 35
  n --;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (n != 0UL)) {
#line 35
      goto while_break;
    }
#line 36
    b ++;
#line 35
    n /= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (b);
}
}
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/randperm.c"
size_t randperm_bound(size_t h , size_t n ) 
{ 
  size_t lg_n ;
  size_t tmp ;
  size_t ar ;
  size_t bound ;

  {
  {
#line 49
  tmp = ceil_lg(n);
#line 49
  lg_n = tmp;
#line 52
  ar = lg_n * h;
#line 55
  bound = ((ar + 8UL) - 1UL) / 8UL;
  }
#line 57
  return (bound);
}
}
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/randperm.c"
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) 
{ 
  size_t *v ;
  void *tmp ;
  size_t i ;
  void *tmp___0 ;
  size_t j ;
  randint tmp___1 ;
  size_t t ;
  void *tmp___2 ;

  {
  {
#line 71
  if (h == 0UL) {
#line 71
    goto case_0;
  }
#line 75
  if (h == 1UL) {
#line 75
    goto case_1;
  }
#line 80
  goto switch_default;
  case_0: /* CIL Label */ 
#line 72
  v = (size_t *)((void *)0);
#line 73
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 76
  tmp = xmalloc(sizeof(*v));
#line 76
  v = (size_t *)tmp;
#line 77
  *(v + 0) = randint_choose(r, n);
  }
#line 78
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 84
  tmp___0 = xnmalloc(n, sizeof(*v));
#line 84
  v = (size_t *)tmp___0;
#line 85
  i = (size_t )0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < n)) {
#line 85
      goto while_break;
    }
#line 86
    *(v + i) = i;
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  i = (size_t )0;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < h)) {
#line 88
      goto while_break___0;
    }
    {
#line 90
    tmp___1 = randint_choose(r, n - i);
#line 90
    j = i + tmp___1;
#line 91
    t = *(v + i);
#line 92
    *(v + i) = *(v + j);
#line 93
    *(v + j) = t;
#line 88
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  tmp___2 = xnrealloc((void *)v, h, sizeof(*v));
#line 96
  v = (size_t *)tmp___2;
  }
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 101
  return (v);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.h"
struct randint_source *randint_new(struct randread_source *source ) ;
#line 37
struct randread_source *randint_get_source(struct randint_source  const  *s ) ;
#line 48
void randint_free(struct randint_source *s ) ;
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
struct randint_source *randint_new(struct randread_source *source ) 
{ 
  struct randint_source *s ;
  void *tmp ;
  randint tmp___0 ;

  {
  {
#line 77
  tmp = xmalloc(sizeof(*s));
#line 77
  s = (struct randint_source *)tmp;
#line 78
  s->source = source;
#line 79
  tmp___0 = (randint )0;
#line 79
  s->randmax = tmp___0;
#line 79
  s->randnum = tmp___0;
  }
#line 80
  return (s);
}
}
#line 87 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) 
{ 
  struct randread_source *source ;
  struct randread_source *tmp ;
  struct randint_source *tmp___0 ;
  struct randint_source *tmp___1 ;

  {
  {
#line 90
  tmp = randread_new(name, bytes_bound);
#line 90
  source = tmp;
  }
#line 91
  if (source) {
    {
#line 91
    tmp___0 = randint_new(source);
#line 91
    tmp___1 = tmp___0;
    }
  } else {
#line 91
    tmp___1 = (struct randint_source *)((void *)0);
  }
#line 91
  return (tmp___1);
}
}
#line 96 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
struct randread_source *randint_get_source(struct randint_source  const  *s ) 
{ 


  {
#line 99
  return ((struct randread_source *)s->source);
}
}
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
__inline static randint shift_left(randint x ) 
{ 


  {
#line 110
  return (x << 8);
}
}
#line 124 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
randint randint_genmax(struct randint_source *s , randint genmax ) 
{ 
  struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___1[sizeof(randnum)] ;
  randint tmp ;
  randint tmp___0 ;
  randint tmp___1 ;
  randint tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;

  {
#line 127
  source = s->source;
#line 128
  randnum = s->randnum;
#line 129
  randmax = s->randmax;
#line 130
  choices = genmax + 1UL;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (randmax < genmax) {
#line 139
      i = (size_t )0;
#line 140
      rmax = randmax;
      {
#line 143
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 145
        tmp = shift_left(rmax);
#line 145
        rmax = tmp + 255UL;
#line 146
        i ++;
        }
#line 143
        if (! (rmax < genmax)) {
#line 143
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      randread(source, (void *)(buf___1), i);
#line 159
      i = (size_t )0;
      }
      {
#line 161
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 163
        tmp___0 = shift_left(randnum);
#line 163
        randnum = tmp___0 + (randint )buf___1[i];
#line 164
        tmp___1 = shift_left(randmax);
#line 164
        randmax = tmp___1 + 255UL;
#line 165
        i ++;
        }
#line 161
        if (! (randmax < genmax)) {
#line 161
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 170
    if (randmax == genmax) {
#line 172
      tmp___2 = (randint )0;
#line 172
      s->randmax = tmp___2;
#line 172
      s->randnum = tmp___2;
#line 173
      return (randnum);
    } else {
#line 187
      excess_choices = randmax - genmax;
#line 188
      unusable_choices = excess_choices % choices;
#line 189
      last_usable_choice = randmax - unusable_choices;
#line 190
      reduced_randnum = randnum % choices;
#line 192
      if (randnum <= last_usable_choice) {
#line 194
        s->randnum = randnum / choices;
#line 195
        s->randmax = excess_choices / choices;
#line 196
        return (reduced_randnum);
      }
#line 201
      randnum = reduced_randnum;
#line 202
      randmax = unusable_choices - 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 209 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
void randint_free(struct randint_source *s ) 
{ 


  {
  {
#line 212
  memset((void *)s, 0, sizeof(*s));
#line 213
  free((void *)s);
  }
#line 214
  return;
}
}
#line 219 "/home/khheo/project/benchmark/coreutils-7.1/lib/randint.c"
int randint_all_free(struct randint_source *s ) 
{ 
  int r ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 222
  tmp = randread_free(s->source);
#line 222
  r = tmp;
#line 223
  tmp___0 = __errno_location();
#line 223
  e = *tmp___0;
#line 224
  randint_free(s);
#line 225
  tmp___1 = __errno_location();
#line 225
  *tmp___1 = e;
  }
#line 226
  return (r);
}
}
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
void isaac_refill(struct isaac_state *s , uint32_t *r ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t x ;
  uint32_t y ;
  uint32_t *m ;

  {
#line 68
  m = s->mm;
#line 70
  a = s->a;
#line 71
  (s->c) ++;
#line 71
  b = s->b + s->c;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    a = (a ^ (a << 13)) + *(m + (1 << 8) / 2);
#line 75
    x = *m;
#line 75
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 75
    *m = y;
#line 75
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 75
    *r = b;
#line 76
    a = (a ^ (a >> 6)) + *((m + 1) + (1 << 8) / 2);
#line 76
    x = *(m + 1);
#line 76
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 76
    *(m + 1) = y;
#line 76
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 76
    *(r + 1) = b;
#line 77
    a = (a ^ (a << 2)) + *((m + 2) + (1 << 8) / 2);
#line 77
    x = *(m + 2);
#line 77
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 77
    *(m + 2) = y;
#line 77
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 77
    *(r + 2) = b;
#line 78
    a = (a ^ (a >> 16)) + *((m + 3) + (1 << 8) / 2);
#line 78
    x = *(m + 3);
#line 78
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 78
    *(m + 3) = y;
#line 78
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 78
    *(r + 3) = b;
#line 79
    r += 4;
#line 73
    m += 4;
#line 73
    if (! ((unsigned long )m < (unsigned long )(s->mm + (1 << 8) / 2))) {
#line 73
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    a = (a ^ (a << 13)) + *(m + - (1 << 8) / 2);
#line 84
    x = *m;
#line 84
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 84
    *m = y;
#line 84
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 84
    *r = b;
#line 85
    a = (a ^ (a >> 6)) + *((m + 1) + - (1 << 8) / 2);
#line 85
    x = *(m + 1);
#line 85
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 85
    *(m + 1) = y;
#line 85
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 85
    *(r + 1) = b;
#line 86
    a = (a ^ (a << 2)) + *((m + 2) + - (1 << 8) / 2);
#line 86
    x = *(m + 2);
#line 86
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 86
    *(m + 2) = y;
#line 86
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 86
    *(r + 2) = b;
#line 87
    a = (a ^ (a >> 16)) + *((m + 3) + - (1 << 8) / 2);
#line 87
    x = *(m + 3);
#line 87
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 87
    *(m + 3) = y;
#line 87
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 87
    *(r + 3) = b;
#line 88
    r += 4;
#line 82
    m += 4;
#line 82
    if (! ((unsigned long )m < (unsigned long )(s->mm + (1 << 8)))) {
#line 82
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  s->a = a;
#line 92
  s->b = b;
#line 93
  return;
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_mix(struct isaac_state *s , uint32_t const   *seed ) 
{ 
  int i ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;

  {
#line 115
  a = s->iv[0];
#line 116
  b = s->iv[1];
#line 117
  c = s->iv[2];
#line 118
  d = s->iv[3];
#line 119
  e = s->iv[4];
#line 120
  f = s->iv[5];
#line 121
  g = s->iv[6];
#line 122
  h = s->iv[7];
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 1 << 8)) {
#line 124
      goto while_break;
    }
#line 126
    a += (uint32_t )*(seed + i);
#line 127
    b += (uint32_t )*(seed + (i + 1));
#line 128
    c += (uint32_t )*(seed + (i + 2));
#line 129
    d += (uint32_t )*(seed + (i + 3));
#line 130
    e += (uint32_t )*(seed + (i + 4));
#line 131
    f += (uint32_t )*(seed + (i + 5));
#line 132
    g += (uint32_t )*(seed + (i + 6));
#line 133
    h += (uint32_t )*(seed + (i + 7));
#line 135
    a ^= b << 11;
#line 135
    d += a;
#line 135
    b += c;
#line 135
    b ^= c >> 2;
#line 135
    e += b;
#line 135
    c += d;
#line 135
    c ^= d << 8;
#line 135
    f += c;
#line 135
    d += e;
#line 135
    d ^= e >> 16;
#line 135
    g += d;
#line 135
    e += f;
#line 135
    e ^= f << 10;
#line 135
    h += e;
#line 135
    f += g;
#line 135
    f ^= g >> 4;
#line 135
    a += f;
#line 135
    g += h;
#line 135
    g ^= h << 8;
#line 135
    b += g;
#line 135
    h += a;
#line 135
    h ^= a >> 9;
#line 135
    c += h;
#line 135
    a += b;
#line 137
    s->mm[i] = a;
#line 138
    s->mm[i + 1] = b;
#line 139
    s->mm[i + 2] = c;
#line 140
    s->mm[i + 3] = d;
#line 141
    s->mm[i + 4] = e;
#line 142
    s->mm[i + 5] = f;
#line 143
    s->mm[i + 6] = g;
#line 144
    s->mm[i + 7] = h;
#line 124
    i += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  s->iv[0] = a;
#line 148
  s->iv[1] = b;
#line 149
  s->iv[2] = c;
#line 150
  s->iv[3] = d;
#line 151
  s->iv[4] = e;
#line 152
  s->iv[5] = f;
#line 153
  s->iv[6] = g;
#line 154
  s->iv[7] = h;
#line 155
  return;
}
}
#line 217
static void isaac_seed_start(struct isaac_state *s ) ;
#line 217 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static uint32_t const   iv[8]  = 
#line 217
  {      (uint32_t const   )325574490,      (uint32_t const   )2514026585U,      (uint32_t const   )3273014859U,      (uint32_t const   )255990488, 
        (uint32_t const   )3643427448U,      (uint32_t const   )2769960009U,      (uint32_t const   )3304057371U,      (uint32_t const   )811634969};
#line 214 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_start(struct isaac_state *s ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 232
  memset((void *)(s->mm), 0, sizeof(s->mm));
#line 233
  memcpy((void */* __restrict  */)(s->iv), (void const   */* __restrict  */)(iv),
         sizeof(s->iv));
#line 236
  tmp___0 = (uint32_t )0;
#line 236
  s->c = tmp___0;
#line 236
  tmp = tmp___0;
#line 236
  s->b = tmp;
#line 236
  s->a = tmp;
  }
#line 237
  return;
}
}
#line 240 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_data(struct isaac_state *s , void const   *buffer , size_t size ) 
{ 
  unsigned char const   *buf___1 ;
  unsigned char *p ;
  size_t avail ;
  size_t i ;

  {
#line 243
  buf___1 = (unsigned char const   *)buffer;
#line 248
  avail = sizeof(s->mm) - (unsigned long )s->c;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (size > avail)) {
#line 251
      goto while_break;
    }
#line 253
    p = (unsigned char *)(s->mm) + s->c;
#line 254
    i = (size_t )0;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (i < avail)) {
#line 254
        goto while_break___0;
      }
#line 255
      *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___1 + i));
#line 254
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 256
    buf___1 += avail;
#line 257
    size -= avail;
#line 258
    isaac_mix(s, (uint32_t const   *)(s->mm));
#line 259
    s->c = (uint32_t )0;
#line 260
    avail = sizeof(s->mm);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  p = (unsigned char *)(s->mm) + s->c;
#line 265
  i = (size_t )0;
  {
#line 265
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 265
    if (! (i < size)) {
#line 265
      goto while_break___1;
    }
#line 266
    *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___1 + i));
#line 265
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 267
  s->c = (uint32_t )size;
#line 268
  return;
}
}
#line 272 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_finish(struct isaac_state *s ) 
{ 


  {
  {
#line 275
  isaac_mix(s, (uint32_t const   *)(s->mm));
#line 276
  isaac_mix(s, (uint32_t const   *)(s->mm));
#line 278
  s->c = (uint32_t )0;
  }
#line 279
  return;
}
}
#line 284 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
void isaac_seed(struct isaac_state *s ) 
{ 
  pid_t t ;
  __pid_t tmp ;
  pid_t t___0 ;
  __pid_t tmp___0 ;
  uid_t t___1 ;
  __uid_t tmp___1 ;
  gid_t t___2 ;
  __gid_t tmp___2 ;
  xtime_t t___3 ;
  xtime_t tmp___3 ;

  {
  {
#line 287
  isaac_seed_start(s);
#line 289
  tmp = getpid();
#line 289
  t = tmp;
#line 289
  isaac_seed_data(s, (void const   *)(& t), sizeof(t));
#line 290
  tmp___0 = getppid();
#line 290
  t___0 = tmp___0;
#line 290
  isaac_seed_data(s, (void const   *)(& t___0), sizeof(t___0));
#line 291
  tmp___1 = getuid();
#line 291
  t___1 = tmp___1;
#line 291
  isaac_seed_data(s, (void const   *)(& t___1), sizeof(t___1));
#line 292
  tmp___2 = getgid();
#line 292
  t___2 = tmp___2;
#line 292
  isaac_seed_data(s, (void const   *)(& t___2), sizeof(t___2));
#line 295
  tmp___3 = gethrxtime();
#line 295
  t___3 = tmp___3;
#line 296
  isaac_seed_data(s, (void const   *)(& t___3), sizeof(t___3));
#line 299
  isaac_seed_finish(s);
  }
#line 300
  return;
}
}
#line 189 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 190
enum quoting_style  const  quoting_style_vals[8] ;
#line 200
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 203
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 207
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 214
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 220
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 233
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 240
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 249
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 259
char *quotearg_n(int n , char const   *arg ) ;
#line 262
char *quotearg(char const   *arg ) ;
#line 267
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 270
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 284
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 287
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 291
char *quotearg_char(char const   *arg , char ch ) ;
#line 294
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 300
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 303
void quotearg_free(void) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 231
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 235
  if (sizeof(char ) == 1UL) {
    {
#line 235
    tmp = xmalloc(n);
#line 235
    tmp___1 = tmp;
    }
  } else {
    {
#line 235
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 235
    tmp___1 = tmp___0;
    }
  }
#line 235
  return ((char *)tmp___1);
}
}
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 74
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 87 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 92 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 95
  tmp = __errno_location();
#line 95
  e = *tmp;
  }
#line 96
  if (o) {
#line 96
    tmp___0 = o;
  } else {
#line 96
    tmp___0 = & default_quoting_options;
  }
  {
#line 96
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 96
  p = (struct quoting_options *)tmp___1;
#line 98
  tmp___2 = __errno_location();
#line 98
  *tmp___2 = e;
  }
#line 99
  return (p);
}
}
#line 103 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 106
  if (o) {
#line 106
    tmp = o;
  } else {
#line 106
    tmp = & default_quoting_options;
  }
#line 106
  return (tmp->style);
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 114
  if (o) {
#line 114
    tmp = o;
  } else {
#line 114
    tmp = & default_quoting_options;
  }
#line 114
  tmp->style = s;
#line 115
  return;
}
}
#line 122 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 125
  uc = (unsigned char )c;
#line 126
  if (o) {
#line 126
    tmp = o;
  } else {
#line 126
    tmp = & default_quoting_options;
  }
#line 126
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 128
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 129
  r = (int )((*p >> shift) & 1U);
#line 130
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 131
  return (r);
}
}
#line 138 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 142
  if (! o) {
#line 143
    o = & default_quoting_options;
  }
#line 144
  r = o->flags;
#line 145
  o->flags = i;
#line 146
  return (r);
}
}
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
  {
#line 154
  o.style = style;
#line 155
  o.flags = 0;
#line 156
  memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
  }
#line 157
  return (o);
}
}
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;

  {
  {
#line 165
  tmp = gettext(msgid);
#line 165
  translation = (char const   *)tmp;
  }
#line 166
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 166
    if ((unsigned int )s == 7U) {
#line 167
      translation = "\"";
    }
  }
#line 168
  return (translation);
}
}
#line 184 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  int tmp___3 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___4 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___5 ;
  size_t j ;
  int tmp___6 ;
  int tmp___7 ;
  size_t ilim ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 191
  len = (size_t )0;
#line 192
  quote_string = (char const   *)0;
#line 193
  quote_string_len = (size_t )0;
#line 194
  backslash_escapes = (_Bool)0;
#line 195
  tmp = __ctype_get_mb_cur_max();
#line 195
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 196
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 209
  if ((unsigned int )quoting_style == 4U) {
#line 209
    goto case_4;
  }
#line 213
  if ((unsigned int )quoting_style == 3U) {
#line 213
    goto case_3;
  }
#line 221
  if ((unsigned int )quoting_style == 5U) {
#line 221
    goto case_5;
  }
#line 227
  if ((unsigned int )quoting_style == 7U) {
#line 227
    goto case_7;
  }
#line 227
  if ((unsigned int )quoting_style == 6U) {
#line 227
    goto case_7;
  }
#line 260
  if ((unsigned int )quoting_style == 1U) {
#line 260
    goto case_1;
  }
#line 264
  if ((unsigned int )quoting_style == 2U) {
#line 264
    goto case_2;
  }
#line 271
  if ((unsigned int )quoting_style == 0U) {
#line 271
    goto case_0;
  }
#line 275
  goto switch_default;
  case_4: /* CIL Label */ 
#line 210
  quoting_style = (enum quoting_style )3;
#line 211
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 214
  if (! elide_outer_quotes) {
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 215
      if (len < buffersize) {
#line 215
        *(buffer + len) = (char )'\"';
      }
#line 215
      len ++;
#line 215
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 216
  backslash_escapes = (_Bool)1;
#line 217
  quote_string = "\"";
#line 218
  quote_string_len = (size_t )1;
#line 219
  goto switch_break;
  case_5: /* CIL Label */ 
#line 222
  backslash_escapes = (_Bool)1;
#line 223
  elide_outer_quotes = (_Bool)0;
#line 224
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 249
  tmp___0 = gettext_quote("`", quoting_style);
#line 249
  left = tmp___0;
#line 250
  tmp___1 = gettext_quote("\'", quoting_style);
#line 250
  right = tmp___1;
  }
#line 251
  if (! elide_outer_quotes) {
#line 252
    quote_string = left;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! *quote_string) {
#line 252
        goto while_break___0;
      }
      {
#line 253
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 253
        if (len < buffersize) {
#line 253
          *(buffer + len) = (char )*quote_string;
        }
#line 253
        len ++;
#line 253
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 252
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 254
  backslash_escapes = (_Bool)1;
#line 255
  quote_string = right;
#line 256
  quote_string_len = strlen(quote_string);
  }
#line 258
  goto switch_break;
  case_1: /* CIL Label */ 
#line 261
  quoting_style = (enum quoting_style )2;
#line 262
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 265
  if (! elide_outer_quotes) {
    {
#line 266
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 266
      if (len < buffersize) {
#line 266
        *(buffer + len) = (char )'\'';
      }
#line 266
      len ++;
#line 266
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 267
  quote_string = "\'";
#line 268
  quote_string_len = (size_t )1;
#line 269
  goto switch_break;
  case_0: /* CIL Label */ 
#line 272
  elide_outer_quotes = (_Bool)0;
#line 273
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 276
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 279
  i = (size_t )0;
  {
#line 279
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 279
    if (argsize == 0xffffffffffffffffUL) {
#line 279
      tmp___8 = (int const   )*(arg + i) == 0;
    } else {
#line 279
      tmp___8 = i == argsize;
    }
#line 279
    if (tmp___8) {
#line 279
      goto while_break___3;
    }
#line 284
    if (backslash_escapes) {
#line 284
      if (quote_string_len) {
#line 284
        if (i + quote_string_len <= argsize) {
          {
#line 284
          tmp___2 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 284
          if (tmp___2 == 0) {
#line 289
            if (elide_outer_quotes) {
#line 290
              goto force_outer_quoting_style;
            }
            {
#line 291
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 291
              if (len < buffersize) {
#line 291
                *(buffer + len) = (char )'\\';
              }
#line 291
              len ++;
#line 291
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 294
    c = (unsigned char )*(arg + i);
    {
#line 297
    if ((int )c == 0) {
#line 297
      goto case_0___0;
    }
#line 314
    if ((int )c == 63) {
#line 314
      goto case_63;
    }
#line 352
    if ((int )c == 7) {
#line 352
      goto case_7___0;
    }
#line 353
    if ((int )c == 8) {
#line 353
      goto case_8;
    }
#line 354
    if ((int )c == 12) {
#line 354
      goto case_12;
    }
#line 355
    if ((int )c == 10) {
#line 355
      goto case_10;
    }
#line 356
    if ((int )c == 13) {
#line 356
      goto case_13;
    }
#line 357
    if ((int )c == 9) {
#line 357
      goto case_9;
    }
#line 358
    if ((int )c == 11) {
#line 358
      goto case_11;
    }
#line 359
    if ((int )c == 92) {
#line 359
      goto case_92;
    }
#line 378
    if ((int )c == 125) {
#line 378
      goto case_125;
    }
#line 378
    if ((int )c == 123) {
#line 378
      goto case_125;
    }
#line 382
    if ((int )c == 126) {
#line 382
      goto case_126;
    }
#line 382
    if ((int )c == 35) {
#line 382
      goto case_126;
    }
#line 394
    if ((int )c == 124) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 96) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 94) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 91) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 62) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 61) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 60) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 59) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 42) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 41) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 40) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 38) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 36) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 34) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 33) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 32) {
#line 394
      goto case_124;
    }
#line 404
    if ((int )c == 39) {
#line 404
      goto case_39___0;
    }
#line 426
    if ((int )c == 122) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 121) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 120) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 119) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 118) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 117) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 116) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 115) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 114) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 113) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 112) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 111) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 110) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 109) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 108) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 107) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 106) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 105) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 104) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 103) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 102) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 101) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 100) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 99) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 98) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 97) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 95) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 93) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 90) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 89) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 88) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 87) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 86) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 85) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 84) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 83) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 82) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 81) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 80) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 79) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 78) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 77) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 76) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 75) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 74) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 73) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 72) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 71) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 70) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 69) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 68) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 67) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 66) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 65) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 58) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 57) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 56) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 55) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 54) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 53) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 52) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 51) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 50) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 49) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 48) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 47) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 46) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 45) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 44) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 43) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 37) {
#line 426
      goto case_122;
    }
#line 431
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 298
    if (backslash_escapes) {
#line 300
      if (elide_outer_quotes) {
#line 301
        goto force_outer_quoting_style;
      }
      {
#line 302
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 302
        if (len < buffersize) {
#line 302
          *(buffer + len) = (char )'\\';
        }
#line 302
        len ++;
#line 302
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 303
      if (i + 1UL < argsize) {
#line 303
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 303
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 305
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 305
              if (len < buffersize) {
#line 305
                *(buffer + len) = (char )'0';
              }
#line 305
              len ++;
#line 305
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 306
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 306
              if (len < buffersize) {
#line 306
                *(buffer + len) = (char )'0';
              }
#line 306
              len ++;
#line 306
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 308
      c = (unsigned char )'0';
    } else
#line 310
    if (flags & 1) {
#line 311
      goto __Cont;
    }
#line 312
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 317
    if ((unsigned int )quoting_style == 2U) {
#line 317
      goto case_2___0;
    }
#line 322
    if ((unsigned int )quoting_style == 3U) {
#line 322
      goto case_3___0;
    }
#line 347
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 318
    if (elide_outer_quotes) {
#line 319
      goto force_outer_quoting_style;
    }
#line 320
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 323
    if (flags & 4) {
#line 323
      if (i + 2UL < argsize) {
#line 323
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 329
            goto case_62;
          }
#line 342
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 332
          if (elide_outer_quotes) {
#line 333
            goto force_outer_quoting_style;
          }
#line 334
          c = (unsigned char )*(arg + (i + 2UL));
#line 335
          i += 2UL;
          {
#line 336
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 336
            if (len < buffersize) {
#line 336
              *(buffer + len) = (char )'?';
            }
#line 336
            len ++;
#line 336
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 337
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 337
            if (len < buffersize) {
#line 337
              *(buffer + len) = (char )'\"';
            }
#line 337
            len ++;
#line 337
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 338
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 338
            if (len < buffersize) {
#line 338
              *(buffer + len) = (char )'\"';
            }
#line 338
            len ++;
#line 338
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 339
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 339
            if (len < buffersize) {
#line 339
              *(buffer + len) = (char )'?';
            }
#line 339
            len ++;
#line 339
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 340
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 343
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 345
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 348
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 350
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 352
    esc = (unsigned char )'a';
#line 352
    goto c_escape;
    case_8: /* CIL Label */ 
#line 353
    esc = (unsigned char )'b';
#line 353
    goto c_escape;
    case_12: /* CIL Label */ 
#line 354
    esc = (unsigned char )'f';
#line 354
    goto c_escape;
    case_10: /* CIL Label */ 
#line 355
    esc = (unsigned char )'n';
#line 355
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 356
    esc = (unsigned char )'r';
#line 356
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 357
    esc = (unsigned char )'t';
#line 357
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 358
    esc = (unsigned char )'v';
#line 358
    goto c_escape;
    case_92: /* CIL Label */ 
#line 359
    esc = c;
#line 362
    if (backslash_escapes) {
#line 362
      if (elide_outer_quotes) {
#line 362
        if (quote_string_len) {
#line 363
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 366
    if ((unsigned int )quoting_style == 2U) {
#line 366
      if (elide_outer_quotes) {
#line 368
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 371
    if (backslash_escapes) {
#line 373
      c = esc;
#line 374
      goto store_escape;
    }
#line 376
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 379
    if (argsize == 0xffffffffffffffffUL) {
#line 379
      tmp___3 = (int const   )*(arg + 1) == 0;
    } else {
#line 379
      tmp___3 = argsize == 1UL;
    }
#line 379
    if (! tmp___3) {
#line 380
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 383
    if (i != 0UL) {
#line 384
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 399
    if ((unsigned int )quoting_style == 2U) {
#line 399
      if (elide_outer_quotes) {
#line 401
        goto force_outer_quoting_style;
      }
    }
#line 402
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 405
    if ((unsigned int )quoting_style == 2U) {
#line 407
      if (elide_outer_quotes) {
#line 408
        goto force_outer_quoting_style;
      }
      {
#line 409
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 409
        if (len < buffersize) {
#line 409
          *(buffer + len) = (char )'\'';
        }
#line 409
        len ++;
#line 409
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 410
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 410
        if (len < buffersize) {
#line 410
          *(buffer + len) = (char )'\\';
        }
#line 410
        len ++;
#line 410
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 411
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 411
        if (len < buffersize) {
#line 411
          *(buffer + len) = (char )'\'';
        }
#line 411
        len ++;
#line 411
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 413
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 429
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 443
    if (unibyte_locale) {
      {
#line 445
      m = (size_t )1;
#line 446
      tmp___4 = __ctype_b_loc();
#line 446
      printable = (_Bool )(((int const   )*(*tmp___4 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 451
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 453
      m = (size_t )0;
#line 454
      printable = (_Bool)1;
      }
#line 455
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 456
        argsize = strlen(arg);
        }
      }
      {
#line 458
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 461
        tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 461
        bytes = tmp___5;
        }
#line 463
        if (bytes == 0UL) {
#line 464
          goto while_break___15;
        } else
#line 465
        if (bytes == 0xffffffffffffffffUL) {
#line 467
          printable = (_Bool)0;
#line 468
          goto while_break___15;
        } else
#line 470
        if (bytes == 0xfffffffffffffffeUL) {
#line 472
          printable = (_Bool)0;
          {
#line 473
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 473
            if (i + m < argsize) {
#line 473
              if (! *(arg + (i + m))) {
#line 473
                goto while_break___16;
              }
            } else {
#line 473
              goto while_break___16;
            }
#line 474
            m ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 475
          goto while_break___15;
        } else {
#line 483
          if (elide_outer_quotes) {
#line 483
            if ((unsigned int )quoting_style == 2U) {
#line 487
              j = (size_t )1;
              {
#line 487
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 487
                if (! (j < bytes)) {
#line 487
                  goto while_break___17;
                }
                {
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 491
                  goto case_124___0;
                }
#line 494
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 492
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 495
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 487
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            }
          }
          {
#line 499
          tmp___6 = iswprint((wint_t )w);
          }
#line 499
          if (! tmp___6) {
#line 500
            printable = (_Bool)0;
          }
#line 501
          m += bytes;
        }
        {
#line 458
        tmp___7 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 458
        if (tmp___7) {
#line 458
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 507
    if (1UL < m) {
#line 507
      goto _L;
    } else
#line 507
    if (backslash_escapes) {
#line 507
      if (! printable) {
        _L: /* CIL Label */ 
#line 511
        ilim = i + m;
        {
#line 513
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 515
          if (backslash_escapes) {
#line 515
            if (! printable) {
#line 517
              if (elide_outer_quotes) {
#line 518
                goto force_outer_quoting_style;
              }
              {
#line 519
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 519
                if (len < buffersize) {
#line 519
                  *(buffer + len) = (char )'\\';
                }
#line 519
                len ++;
#line 519
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 520
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 520
                if (len < buffersize) {
#line 520
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 520
                len ++;
#line 520
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 521
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 521
                if (len < buffersize) {
#line 521
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 521
                len ++;
#line 521
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 522
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 524
          if (ilim <= i + 1UL) {
#line 525
            goto while_break___18;
          }
          {
#line 526
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 526
            if (len < buffersize) {
#line 526
              *(buffer + len) = (char )c;
            }
#line 526
            len ++;
#line 526
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 527
          i ++;
#line 527
          c = (unsigned char )*(arg + i);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 530
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 535
    if (backslash_escapes) {
#line 535
      goto _L___0;
    } else
#line 535
    if (elide_outer_quotes) {
      _L___0: /* CIL Label */ 
#line 535
      if (quote_these_too) {
#line 535
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 538
          goto store_c;
        }
      } else {
#line 538
        goto store_c;
      }
    } else {
#line 538
      goto store_c;
    }
    store_escape: 
#line 541
    if (elide_outer_quotes) {
#line 542
      goto force_outer_quoting_style;
    }
    {
#line 543
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 543
      if (len < buffersize) {
#line 543
        *(buffer + len) = (char )'\\';
      }
#line 543
      len ++;
#line 543
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 546
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 546
      if (len < buffersize) {
#line 546
        *(buffer + len) = (char )c;
      }
#line 546
      len ++;
#line 546
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 279
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 549
  if (len == 0UL) {
#line 549
    if ((unsigned int )quoting_style == 2U) {
#line 549
      if (elide_outer_quotes) {
#line 551
        goto force_outer_quoting_style;
      }
    }
  }
#line 553
  if (quote_string) {
#line 553
    if (! elide_outer_quotes) {
      {
#line 554
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 554
        if (! *quote_string) {
#line 554
          goto while_break___25;
        }
        {
#line 555
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 555
          if (len < buffersize) {
#line 555
            *(buffer + len) = (char )*quote_string;
          }
#line 555
          len ++;
#line 555
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 554
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 557
  if (len < buffersize) {
#line 558
    *(buffer + len) = (char )'\000';
  }
#line 559
  return (len);
  force_outer_quoting_style: 
  {
#line 564
  tmp___9 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0));
  }
#line 564
  return (tmp___9);
}
}
#line 578 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 583
  if (o) {
#line 583
    tmp = o;
  } else {
#line 583
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 583
  p = tmp;
#line 584
  tmp___0 = __errno_location();
#line 584
  e = *tmp___0;
#line 585
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too));
#line 585
  r = tmp___1;
#line 587
  tmp___2 = __errno_location();
#line 587
  *tmp___2 = e;
  }
#line 588
  return (r);
}
}
#line 592 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 596
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 596
  return (tmp);
}
}
#line 605 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___1 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 609
  if (o) {
#line 609
    tmp = o;
  } else {
#line 609
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 609
  p = tmp;
#line 610
  tmp___0 = __errno_location();
#line 610
  e = *tmp___0;
  }
#line 612
  if (size) {
#line 612
    tmp___1 = 0;
  } else {
#line 612
    tmp___1 = 1;
  }
  {
#line 612
  flags = (int )(p->flags | (int const   )tmp___1);
#line 613
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too));
#line 613
  bufsize___1 = tmp___2 + 1UL;
#line 615
  tmp___3 = xcharalloc(bufsize___1);
#line 615
  buf___1 = tmp___3;
#line 616
  quotearg_buffer_restyled(buf___1, bufsize___1, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too));
#line 618
  tmp___4 = __errno_location();
#line 618
  *tmp___4 = e;
  }
#line 619
  if (size) {
#line 620
    *size = bufsize___1 - 1UL;
  }
#line 621
  return (buf___1);
}
}
#line 633 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char slot0[256]  ;
#line 634 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 635 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 636 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 638 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 641
  sv = slotvec;
#line 643
  i = 1U;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (i < nslots)) {
#line 643
      goto while_break;
    }
    {
#line 644
    free((void *)(sv + i)->val);
#line 643
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 647
    free((void *)(sv + 0)->val);
#line 648
    slotvec0.size = sizeof(slot0);
#line 649
    slotvec0.val = slot0;
    }
  }
#line 651
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 653
    free((void *)sv);
#line 654
    slotvec = & slotvec0;
    }
  }
#line 656
  nslots = 1U;
#line 657
  return;
}
}
#line 667 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 671
  tmp = __errno_location();
#line 671
  e = *tmp;
#line 673
  n0 = (unsigned int )n;
#line 674
  sv = slotvec;
  }
#line 676
  if (n < 0) {
    {
#line 677
    abort();
    }
  }
#line 679
  if (nslots <= n0) {
#line 686
    n1 = (size_t )(n0 + 1U);
#line 687
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 689
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 689
      tmp___0 = -1;
    } else {
#line 689
      tmp___0 = -2;
    }
#line 689
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 690
      xalloc_die();
      }
    }
#line 692
    if (preallocated) {
#line 692
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 692
      tmp___1 = sv;
    }
    {
#line 692
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 692
    sv = (struct slotvec *)tmp___2;
#line 692
    slotvec = sv;
    }
#line 693
    if (preallocated) {
#line 694
      *sv = slotvec0;
    }
    {
#line 695
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 696
    nslots = (unsigned int )n1;
    }
  }
  {
#line 700
  size = (sv + n)->size;
#line 701
  val = (sv + n)->val;
#line 703
  flags = (int )(options->flags | 1);
#line 704
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too));
#line 704
  qsize = tmp___3;
  }
#line 708
  if (size <= qsize) {
#line 710
    size = qsize + 1UL;
#line 710
    (sv + n)->size = size;
#line 711
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 712
      free((void *)val);
      }
    }
    {
#line 713
    val = xcharalloc(size);
#line 713
    (sv + n)->val = val;
#line 714
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too));
    }
  }
  {
#line 718
  tmp___4 = __errno_location();
#line 718
  *tmp___4 = e;
  }
#line 719
  return (val);
}
}
#line 723 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 726
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 726
  return (tmp);
}
}
#line 729 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 732
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 732
  return (tmp);
}
}
#line 735 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 738
  tmp = quotearg_n(0, arg);
  }
#line 738
  return (tmp);
}
}
#line 741 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 744
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 744
  return (tmp);
}
}
#line 747 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 750
  tmp = quoting_options_from_style(s);
#line 750
  o = tmp;
#line 751
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 751
  return (tmp___0);
}
}
#line 754 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 758
  tmp = quoting_options_from_style(s);
#line 758
  o = tmp;
#line 759
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 759
  return (tmp___0);
}
}
#line 762 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 765
  tmp = quotearg_n_style(0, s, arg);
  }
#line 765
  return (tmp);
}
}
#line 768 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 771
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 771
  return (tmp);
}
}
#line 774 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 778
  options = default_quoting_options;
#line 779
  set_char_quoting(& options, ch, 1);
#line 780
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 780
  return (tmp);
}
}
#line 783 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 786
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 786
  return (tmp);
}
}
#line 789 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 792
  tmp = quotearg_char(arg, (char )':');
  }
#line 792
  return (tmp);
}
}
#line 795 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 798
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 798
  return (tmp);
}
}
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 39
  tmp = quote_n(0, name);
  }
#line 39
  return (tmp);
}
}
#line 92 "/home/khheo/project/benchmark/coreutils-7.1/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 51
  tmp = trim2(sub, 2);
#line 51
  tsub = tmp;
#line 52
  found = (_Bool)0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((int const   )*string != 0)) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 56
    tsub_in_string = (char const   *)tmp___0;
    }
#line 57
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 58
      goto while_break;
    } else {
      {
#line 61
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 61
      if (tmp___11 > 1UL) {
        {
#line 67
        string_iter.cur.ptr = string;
#line 67
        string_iter.in_shift = (_Bool)0;
#line 67
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 67
        string_iter.next_done = (_Bool)0;
#line 68
        word_boundary_before = (_Bool)1;
        }
#line 69
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 72
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 74
            mbuiter_multi_next(& string_iter);
            }
#line 74
            if (string_iter.cur.wc_valid) {
#line 74
              if (string_iter.cur.wc == 0) {
#line 74
                tmp___1 = 0;
              } else {
#line 74
                tmp___1 = 1;
              }
            } else {
#line 74
              tmp___1 = 1;
            }
#line 74
            if (! tmp___1) {
              {
#line 75
              abort();
              }
            }
#line 76
            last_char_before_tsub = string_iter.cur;
#line 77
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 77
            string_iter.next_done = (_Bool)0;
#line 72
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 72
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 80
          if (last_char_before_tsub.wc_valid) {
            {
#line 80
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 80
            if (tmp___2) {
#line 81
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 84
        string_iter.cur.ptr = tsub_in_string;
#line 84
        string_iter.in_shift = (_Bool)0;
#line 84
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 84
        string_iter.next_done = (_Bool)0;
#line 88
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 88
        tsub_iter.in_shift = (_Bool)0;
#line 88
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 88
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 88
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 88
          mbuiter_multi_next(& tsub_iter);
          }
#line 88
          if (tsub_iter.cur.wc_valid) {
#line 88
            if (tsub_iter.cur.wc == 0) {
#line 88
              tmp___4 = 0;
            } else {
#line 88
              tmp___4 = 1;
            }
          } else {
#line 88
            tmp___4 = 1;
          }
#line 88
          if (! tmp___4) {
#line 88
            goto while_break___1;
          }
          {
#line 92
          mbuiter_multi_next(& string_iter);
          }
#line 92
          if (string_iter.cur.wc_valid) {
#line 92
            if (string_iter.cur.wc == 0) {
#line 92
              tmp___3 = 0;
            } else {
#line 92
              tmp___3 = 1;
            }
          } else {
#line 92
            tmp___3 = 1;
          }
#line 92
          if (! tmp___3) {
            {
#line 93
            abort();
            }
          }
#line 94
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 94
          string_iter.next_done = (_Bool)0;
#line 88
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 88
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 97
        word_boundary_after = (_Bool)1;
#line 98
        mbuiter_multi_next(& string_iter);
        }
#line 98
        if (string_iter.cur.wc_valid) {
#line 98
          if (string_iter.cur.wc == 0) {
#line 98
            tmp___6 = 0;
          } else {
#line 98
            tmp___6 = 1;
          }
        } else {
#line 98
          tmp___6 = 1;
        }
#line 98
        if (tmp___6) {
#line 100
          first_char_after_tsub = string_iter.cur;
#line 101
          if (first_char_after_tsub.wc_valid) {
            {
#line 101
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 101
            if (tmp___5) {
#line 102
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 105
        if (word_boundary_before) {
#line 105
          if (word_boundary_after) {
#line 107
            found = (_Bool)1;
#line 108
            goto while_break;
          }
        }
        {
#line 111
        string_iter.cur.ptr = tsub_in_string;
#line 111
        string_iter.in_shift = (_Bool)0;
#line 111
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 111
        string_iter.next_done = (_Bool)0;
#line 112
        mbuiter_multi_next(& string_iter);
        }
#line 112
        if (string_iter.cur.wc_valid) {
#line 112
          if (string_iter.cur.wc == 0) {
#line 112
            tmp___7 = 0;
          } else {
#line 112
            tmp___7 = 1;
          }
        } else {
#line 112
          tmp___7 = 1;
        }
#line 112
        if (! tmp___7) {
#line 113
          goto while_break;
        }
#line 114
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 122
        word_boundary_before___0 = (_Bool)1;
#line 123
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 124
          tmp___8 = __ctype_b_loc();
          }
#line 124
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 125
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 127
        tmp___9 = strlen((char const   *)tsub);
#line 127
        p = tsub_in_string + tmp___9;
#line 128
        word_boundary_after___0 = (_Bool)1;
        }
#line 129
        if ((int const   )*p != 0) {
          {
#line 130
          tmp___10 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 131
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 133
        if (word_boundary_before___0) {
#line 133
          if (word_boundary_after___0) {
#line 135
            found = (_Bool)1;
#line 136
            goto while_break;
          }
        }
#line 139
        if ((int const   )*tsub_in_string == 0) {
#line 140
          goto while_break;
        }
#line 141
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  free((void *)tsub);
  }
#line 146
  return (found);
}
}
#line 151 "/home/khheo/project/benchmark/coreutils-7.1/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 155
  tmp = gettext(name);
#line 155
  translation = (char const   *)tmp;
  }
#line 157
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 160
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 160
    if (tmp___7) {
#line 161
      return (translation);
    } else {
#line 165
      if (sizeof(char ) == 1UL) {
        {
#line 165
        tmp___0 = strlen(translation);
#line 165
        tmp___1 = strlen(name);
#line 165
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 165
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 165
        tmp___3 = strlen(translation);
#line 165
        tmp___4 = strlen(name);
#line 165
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 165
        tmp___6 = tmp___5;
        }
      }
      {
#line 165
      result = (char *)tmp___6;
#line 168
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 169
      return ((char const   *)result);
    }
  } else {
#line 173
    return (name);
  }
}
}
#line 181 "/home/khheo/project/benchmark/coreutils-7.1/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;

  {
  {
#line 185
  tmp = gettext(name_ascii);
#line 185
  translation = (char const   *)tmp;
#line 188
  tmp___0 = locale_charset();
#line 188
  locale_code = tmp___0;
#line 189
  alloc_name_converted = (char *)((void *)0);
#line 190
  alloc_name_converted_translit = (char *)((void *)0);
#line 191
  name_converted = (char const   *)((void *)0);
#line 192
  name_converted_translit = (char const   *)((void *)0);
#line 195
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 195
  if (tmp___6 != 0) {
    {
#line 198
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 198
    name_converted = (char const   *)alloc_name_converted;
#line 206
    tmp___1 = strlen(locale_code);
#line 206
    len = tmp___1;
    }
#line 207
    if (sizeof(char ) == 1UL) {
      {
#line 207
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 207
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 207
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 207
      tmp___4 = tmp___3;
      }
    }
    {
#line 207
    locale_code_translit = (char *)tmp___4;
#line 208
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 209
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 211
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 214
    free((void *)locale_code_translit);
    }
#line 216
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 223
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 223
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 224
        free((void *)converted_translit);
        }
      } else {
#line 227
        alloc_name_converted_translit = converted_translit;
#line 227
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 236
    name_converted = name_utf8;
#line 237
    name_converted_translit = name_utf8;
  }
#line 241
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 241
    name = name_converted;
  } else {
#line 241
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 241
      tmp___7 = name_converted_translit;
    } else {
#line 241
      tmp___7 = name_ascii;
    }
#line 241
    name = tmp___7;
  }
#line 245
  if ((unsigned long )translation != (unsigned long )name_ascii) {
    {
#line 248
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 248
    if (tmp___15) {
#line 248
      goto _L;
    } else
#line 248
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 248
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 248
      if (tmp___16) {
#line 248
        goto _L;
      } else {
#line 248
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 248
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 248
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 248
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 254
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 255
          free((void *)alloc_name_converted);
          }
        }
#line 256
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 257
          free((void *)alloc_name_converted_translit);
          }
        }
#line 258
        return (translation);
      } else {
#line 248
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 263
      if (sizeof(char ) == 1UL) {
        {
#line 263
        tmp___8 = strlen(translation);
#line 263
        tmp___9 = strlen(name);
#line 263
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 263
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 263
        tmp___11 = strlen(translation);
#line 263
        tmp___12 = strlen(name);
#line 263
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 263
        tmp___14 = tmp___13;
        }
      }
      {
#line 263
      result = (char *)tmp___14;
#line 266
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 268
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 269
        free((void *)alloc_name_converted);
        }
      }
#line 270
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 271
        free((void *)alloc_name_converted_translit);
        }
      }
#line 272
      return ((char const   *)result);
    }
  } else {
#line 277
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 277
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 278
        free((void *)alloc_name_converted);
        }
      }
    }
#line 279
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 279
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 281
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 282
    return (name);
  }
}
}
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/progname.h"
char const   *program_name ;
#line 35
void set_program_name(char const   *argv0 ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 44
  tmp = strrchr(argv0, '/');
#line 44
  slash = (char const   *)tmp;
  }
#line 45
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 45
    base = slash + 1;
  } else {
#line 45
    base = argv0;
  }
#line 46
  if (base - argv0 >= 7L) {
    {
#line 46
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 46
    if (tmp___1 == 0) {
      {
#line 48
      argv0 = base;
#line 49
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 49
      if (tmp___0 == 0) {
#line 50
        argv0 = base + 3;
      }
    }
  }
#line 62
  program_name = argv0;
#line 63
  return;
}
}
#line 80 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;

  {
  {
#line 83
  cp = format;
#line 84
  arg_posn = (size_t )0;
#line 87
  max_width_length = (size_t )0;
#line 88
  max_precision_length = (size_t )0;
#line 90
  d->count = (size_t )0;
#line 91
  d_allocated = (size_t )1;
#line 92
  tmp = malloc(d_allocated * sizeof(char_directive ));
#line 92
  d->dir = (char_directive *)tmp;
  }
#line 93
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 95
    goto out_of_memory_1;
  }
#line 97
  a->count = (size_t )0;
#line 98
  a_allocated = (size_t )0;
#line 99
  a->arg = (argument *)((void *)0);
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((int const   )*cp != 0)) {
#line 133
      goto while_break;
    }
#line 135
    tmp___0 = cp;
#line 135
    cp ++;
#line 135
    c = (char )*tmp___0;
#line 136
    if ((int )c == 37) {
#line 138
      arg_index = ~ ((size_t )0);
#line 139
      dp = d->dir + d->count;
#line 142
      dp->dir_start = cp - 1;
#line 143
      dp->flags = 0;
#line 144
      dp->width_start = (char const   *)((void *)0);
#line 145
      dp->width_end = (char const   *)((void *)0);
#line 146
      dp->width_arg_index = ~ ((size_t )0);
#line 147
      dp->precision_start = (char const   *)((void *)0);
#line 148
      dp->precision_end = (char const   *)((void *)0);
#line 149
      dp->precision_arg_index = ~ ((size_t )0);
#line 150
      dp->arg_index = ~ ((size_t )0);
#line 153
      if ((int const   )*cp >= 48) {
#line 153
        if ((int const   )*cp <= 57) {
#line 157
          np = cp;
          {
#line 157
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 157
            if ((int const   )*np >= 48) {
#line 157
              if (! ((int const   )*np <= 57)) {
#line 157
                goto while_break___0;
              }
            } else {
#line 157
              goto while_break___0;
            }
#line 157
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 159
          if ((int const   )*np == 36) {
#line 161
            n = (size_t )0;
#line 163
            np = cp;
            {
#line 163
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 163
              if ((int const   )*np >= 48) {
#line 163
                if (! ((int const   )*np <= 57)) {
#line 163
                  goto while_break___1;
                }
              } else {
#line 163
                goto while_break___1;
              }
#line 164
              if (n <= 1844674407370955161UL) {
#line 164
                tmp___1 = n * 10UL;
              } else {
#line 164
                tmp___1 = 0xffffffffffffffffUL;
              }
              {
#line 164
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 164
              n = (size_t )tmp___2;
#line 163
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 165
            if (n == 0UL) {
#line 167
              goto error;
            }
#line 168
            if (n == 0xffffffffffffffffUL) {
#line 170
              goto error;
            }
#line 171
            arg_index = n - 1UL;
#line 172
            cp = np + 1;
          }
        }
      }
      {
#line 177
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 179
        if ((int const   )*cp == 39) {
#line 181
          dp->flags |= 1;
#line 182
          cp ++;
        } else
#line 184
        if ((int const   )*cp == 45) {
#line 186
          dp->flags |= 2;
#line 187
          cp ++;
        } else
#line 189
        if ((int const   )*cp == 43) {
#line 191
          dp->flags |= 4;
#line 192
          cp ++;
        } else
#line 194
        if ((int const   )*cp == 32) {
#line 196
          dp->flags |= 8;
#line 197
          cp ++;
        } else
#line 199
        if ((int const   )*cp == 35) {
#line 201
          dp->flags |= 16;
#line 202
          cp ++;
        } else
#line 204
        if ((int const   )*cp == 48) {
#line 206
          dp->flags |= 32;
#line 207
          cp ++;
        } else {
#line 210
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 214
      if ((int const   )*cp == 42) {
#line 216
        dp->width_start = cp;
#line 217
        cp ++;
#line 218
        dp->width_end = cp;
#line 219
        if (max_width_length < 1UL) {
#line 220
          max_width_length = (size_t )1;
        }
#line 223
        if ((int const   )*cp >= 48) {
#line 223
          if ((int const   )*cp <= 57) {
#line 227
            np___0 = cp;
            {
#line 227
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 227
              if ((int const   )*np___0 >= 48) {
#line 227
                if (! ((int const   )*np___0 <= 57)) {
#line 227
                  goto while_break___3;
                }
              } else {
#line 227
                goto while_break___3;
              }
#line 227
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 229
            if ((int const   )*np___0 == 36) {
#line 231
              n___0 = (size_t )0;
#line 233
              np___0 = cp;
              {
#line 233
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 233
                if ((int const   )*np___0 >= 48) {
#line 233
                  if (! ((int const   )*np___0 <= 57)) {
#line 233
                    goto while_break___4;
                  }
                } else {
#line 233
                  goto while_break___4;
                }
#line 234
                if (n___0 <= 1844674407370955161UL) {
#line 234
                  tmp___3 = n___0 * 10UL;
                } else {
#line 234
                  tmp___3 = 0xffffffffffffffffUL;
                }
                {
#line 234
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 234
                n___0 = (size_t )tmp___4;
#line 233
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 235
              if (n___0 == 0UL) {
#line 237
                goto error;
              }
#line 238
              if (n___0 == 0xffffffffffffffffUL) {
#line 240
                goto error;
              }
#line 241
              dp->width_arg_index = n___0 - 1UL;
#line 242
              cp = np___0 + 1;
            }
          }
        }
#line 245
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 247
          tmp___5 = arg_posn;
#line 247
          arg_posn ++;
#line 247
          dp->width_arg_index = tmp___5;
#line 248
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 250
            goto error;
          }
        }
#line 252
        n___1 = dp->width_arg_index;
#line 252
        if (n___1 >= a_allocated) {
#line 252
          if (a_allocated <= 9223372036854775807UL) {
#line 252
            a_allocated *= 2UL;
          } else {
#line 252
            a_allocated = 0xffffffffffffffffUL;
          }
#line 252
          if (a_allocated <= n___1) {
            {
#line 252
            tmp___6 = xsum(n___1, (size_t )1);
#line 252
            a_allocated = (size_t )tmp___6;
            }
          }
#line 252
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 252
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 252
            memory_size = 0xffffffffffffffffUL;
          }
#line 252
          if (memory_size == 0xffffffffffffffffUL) {
#line 252
            goto out_of_memory;
          }
#line 252
          if (a->arg) {
            {
#line 252
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 252
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 252
            tmp___8 = malloc(memory_size);
#line 252
            tmp___9 = tmp___8;
            }
          }
#line 252
          memory = (argument *)tmp___9;
#line 252
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 252
            goto out_of_memory;
          }
#line 252
          a->arg = memory;
        }
        {
#line 252
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 252
          if (! (a->count <= n___1)) {
#line 252
            goto while_break___5;
          }
#line 252
          tmp___10 = a->count;
#line 252
          (a->count) ++;
#line 252
          (a->arg + tmp___10)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 252
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 252
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 252
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 252
          goto error;
        }
      } else
#line 254
      if ((int const   )*cp >= 48) {
#line 254
        if ((int const   )*cp <= 57) {
#line 258
          dp->width_start = cp;
          {
#line 259
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 259
            if ((int const   )*cp >= 48) {
#line 259
              if (! ((int const   )*cp <= 57)) {
#line 259
                goto while_break___6;
              }
            } else {
#line 259
              goto while_break___6;
            }
#line 259
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 261
          dp->width_end = cp;
#line 262
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 263
          if (max_width_length < width_length) {
#line 264
            max_width_length = width_length;
          }
        }
      }
#line 268
      if ((int const   )*cp == 46) {
#line 270
        cp ++;
#line 271
        if ((int const   )*cp == 42) {
#line 273
          dp->precision_start = cp - 1;
#line 274
          cp ++;
#line 275
          dp->precision_end = cp;
#line 276
          if (max_precision_length < 2UL) {
#line 277
            max_precision_length = (size_t )2;
          }
#line 280
          if ((int const   )*cp >= 48) {
#line 280
            if ((int const   )*cp <= 57) {
#line 284
              np___1 = cp;
              {
#line 284
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 284
                if ((int const   )*np___1 >= 48) {
#line 284
                  if (! ((int const   )*np___1 <= 57)) {
#line 284
                    goto while_break___7;
                  }
                } else {
#line 284
                  goto while_break___7;
                }
#line 284
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 286
              if ((int const   )*np___1 == 36) {
#line 288
                n___2 = (size_t )0;
#line 290
                np___1 = cp;
                {
#line 290
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 290
                  if ((int const   )*np___1 >= 48) {
#line 290
                    if (! ((int const   )*np___1 <= 57)) {
#line 290
                      goto while_break___8;
                    }
                  } else {
#line 290
                    goto while_break___8;
                  }
#line 291
                  if (n___2 <= 1844674407370955161UL) {
#line 291
                    tmp___11 = n___2 * 10UL;
                  } else {
#line 291
                    tmp___11 = 0xffffffffffffffffUL;
                  }
                  {
#line 291
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 291
                  n___2 = (size_t )tmp___12;
#line 290
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 292
                if (n___2 == 0UL) {
#line 294
                  goto error;
                }
#line 295
                if (n___2 == 0xffffffffffffffffUL) {
#line 298
                  goto error;
                }
#line 299
                dp->precision_arg_index = n___2 - 1UL;
#line 300
                cp = np___1 + 1;
              }
            }
          }
#line 303
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 305
            tmp___13 = arg_posn;
#line 305
            arg_posn ++;
#line 305
            dp->precision_arg_index = tmp___13;
#line 306
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 308
              goto error;
            }
          }
#line 310
          n___3 = dp->precision_arg_index;
#line 310
          if (n___3 >= a_allocated) {
#line 310
            if (a_allocated <= 9223372036854775807UL) {
#line 310
              a_allocated *= 2UL;
            } else {
#line 310
              a_allocated = 0xffffffffffffffffUL;
            }
#line 310
            if (a_allocated <= n___3) {
              {
#line 310
              tmp___14 = xsum(n___3, (size_t )1);
#line 310
              a_allocated = (size_t )tmp___14;
              }
            }
#line 310
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 310
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 310
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 310
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 310
              goto out_of_memory;
            }
#line 310
            if (a->arg) {
              {
#line 310
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 310
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 310
              tmp___16 = malloc(memory_size___0);
#line 310
              tmp___17 = tmp___16;
              }
            }
#line 310
            memory___0 = (argument *)tmp___17;
#line 310
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 310
              goto out_of_memory;
            }
#line 310
            a->arg = memory___0;
          }
          {
#line 310
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 310
            if (! (a->count <= n___3)) {
#line 310
              goto while_break___9;
            }
#line 310
            tmp___18 = a->count;
#line 310
            (a->count) ++;
#line 310
            (a->arg + tmp___18)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 310
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 310
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 310
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 310
            goto error;
          }
        } else {
#line 316
          dp->precision_start = cp - 1;
          {
#line 317
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 317
            if ((int const   )*cp >= 48) {
#line 317
              if (! ((int const   )*cp <= 57)) {
#line 317
                goto while_break___10;
              }
            } else {
#line 317
              goto while_break___10;
            }
#line 317
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 319
          dp->precision_end = cp;
#line 320
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 321
          if (max_precision_length < precision_length) {
#line 322
            max_precision_length = precision_length;
          }
        }
      }
#line 331
      flags = 0;
      {
#line 333
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 335
        if ((int const   )*cp == 104) {
#line 337
          flags |= 1 << (flags & 1);
#line 338
          cp ++;
        } else
#line 340
        if ((int const   )*cp == 76) {
#line 342
          flags |= 4;
#line 343
          cp ++;
        } else
#line 345
        if ((int const   )*cp == 108) {
#line 347
          flags += 8;
#line 348
          cp ++;
        } else
#line 350
        if ((int const   )*cp == 106) {
#line 352
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 355
            flags += 16;
          } else
#line 357
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 360
            flags += 8;
          }
#line 362
          cp ++;
        } else
#line 364
        if ((int const   )*cp == 122) {
#line 364
          goto _L;
        } else
#line 364
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 369
          if (sizeof(size_t ) > sizeof(long )) {
#line 372
            flags += 16;
          } else
#line 374
          if (sizeof(size_t ) > sizeof(int )) {
#line 377
            flags += 8;
          }
#line 379
          cp ++;
        } else
#line 381
        if ((int const   )*cp == 116) {
#line 383
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 386
            flags += 16;
          } else
#line 388
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 391
            flags += 8;
          }
#line 393
          cp ++;
        } else {
#line 434
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 438
      tmp___19 = cp;
#line 438
      cp ++;
#line 438
      c = (char )*tmp___19;
      {
#line 441
      if ((int )c == 105) {
#line 441
        goto case_105;
      }
#line 441
      if ((int )c == 100) {
#line 441
        goto case_105;
      }
#line 459
      if ((int )c == 88) {
#line 459
        goto case_88;
      }
#line 459
      if ((int )c == 120) {
#line 459
        goto case_88;
      }
#line 459
      if ((int )c == 117) {
#line 459
        goto case_88;
      }
#line 459
      if ((int )c == 111) {
#line 459
        goto case_88;
      }
#line 478
      if ((int )c == 65) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 97) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 71) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 103) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 69) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 101) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 70) {
#line 478
        goto case_65;
      }
#line 478
      if ((int )c == 102) {
#line 478
        goto case_65;
      }
#line 484
      if ((int )c == 99) {
#line 484
        goto case_99;
      }
#line 495
      if ((int )c == 67) {
#line 495
        goto case_67;
      }
#line 500
      if ((int )c == 115) {
#line 500
        goto case_115;
      }
#line 511
      if ((int )c == 83) {
#line 511
        goto case_83;
      }
#line 516
      if ((int )c == 112) {
#line 516
        goto case_112;
      }
#line 519
      if ((int )c == 110) {
#line 519
        goto case_110;
      }
#line 548
      if ((int )c == 37) {
#line 548
        goto case_37;
      }
#line 551
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 444
      if (flags >= 16) {
#line 445
        type = (arg_type )9;
      } else
#line 444
      if (flags & 4) {
#line 445
        type = (arg_type )9;
      } else
#line 450
      if (flags >= 8) {
#line 451
        type = (arg_type )7;
      } else
#line 452
      if (flags & 2) {
#line 453
        type = (arg_type )1;
      } else
#line 454
      if (flags & 1) {
#line 455
        type = (arg_type )3;
      } else {
#line 457
        type = (arg_type )5;
      }
#line 458
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 462
      if (flags >= 16) {
#line 463
        type = (arg_type )10;
      } else
#line 462
      if (flags & 4) {
#line 463
        type = (arg_type )10;
      } else
#line 468
      if (flags >= 8) {
#line 469
        type = (arg_type )8;
      } else
#line 470
      if (flags & 2) {
#line 471
        type = (arg_type )2;
      } else
#line 472
      if (flags & 1) {
#line 473
        type = (arg_type )4;
      } else {
#line 475
        type = (arg_type )6;
      }
#line 476
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 479
      if (flags >= 16) {
#line 480
        type = (arg_type )12;
      } else
#line 479
      if (flags & 4) {
#line 480
        type = (arg_type )12;
      } else {
#line 482
        type = (arg_type )11;
      }
#line 483
      goto switch_break;
      case_99: /* CIL Label */ 
#line 485
      if (flags >= 8) {
#line 487
        type = (arg_type )14;
      } else {
#line 492
        type = (arg_type )13;
      }
#line 493
      goto switch_break;
      case_67: /* CIL Label */ 
#line 496
      type = (arg_type )14;
#line 497
      c = (char )'c';
#line 498
      goto switch_break;
      case_115: /* CIL Label */ 
#line 501
      if (flags >= 8) {
#line 503
        type = (arg_type )16;
      } else {
#line 508
        type = (arg_type )15;
      }
#line 509
      goto switch_break;
      case_83: /* CIL Label */ 
#line 512
      type = (arg_type )16;
#line 513
      c = (char )'s';
#line 514
      goto switch_break;
      case_112: /* CIL Label */ 
#line 517
      type = (arg_type )17;
#line 518
      goto switch_break;
      case_110: /* CIL Label */ 
#line 522
      if (flags >= 16) {
#line 523
        type = (arg_type )22;
      } else
#line 522
      if (flags & 4) {
#line 523
        type = (arg_type )22;
      } else
#line 528
      if (flags >= 8) {
#line 529
        type = (arg_type )21;
      } else
#line 530
      if (flags & 2) {
#line 531
        type = (arg_type )18;
      } else
#line 532
      if (flags & 1) {
#line 533
        type = (arg_type )19;
      } else {
#line 535
        type = (arg_type )20;
      }
#line 536
      goto switch_break;
      case_37: /* CIL Label */ 
#line 549
      type = (arg_type )0;
#line 550
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 553
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 557
      if ((unsigned int )type != 0U) {
#line 559
        dp->arg_index = arg_index;
#line 560
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 562
          tmp___20 = arg_posn;
#line 562
          arg_posn ++;
#line 562
          dp->arg_index = tmp___20;
#line 563
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 565
            goto error;
          }
        }
#line 567
        n___4 = dp->arg_index;
#line 567
        if (n___4 >= a_allocated) {
#line 567
          if (a_allocated <= 9223372036854775807UL) {
#line 567
            a_allocated *= 2UL;
          } else {
#line 567
            a_allocated = 0xffffffffffffffffUL;
          }
#line 567
          if (a_allocated <= n___4) {
            {
#line 567
            tmp___21 = xsum(n___4, (size_t )1);
#line 567
            a_allocated = (size_t )tmp___21;
            }
          }
#line 567
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 567
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 567
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 567
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 567
            goto out_of_memory;
          }
#line 567
          if (a->arg) {
            {
#line 567
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 567
            tmp___24 = tmp___22;
            }
          } else {
            {
#line 567
            tmp___23 = malloc(memory_size___1);
#line 567
            tmp___24 = tmp___23;
            }
          }
#line 567
          memory___1 = (argument *)tmp___24;
#line 567
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 567
            goto out_of_memory;
          }
#line 567
          a->arg = memory___1;
        }
        {
#line 567
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 567
          if (! (a->count <= n___4)) {
#line 567
            goto while_break___12;
          }
#line 567
          tmp___25 = a->count;
#line 567
          (a->count) ++;
#line 567
          (a->arg + tmp___25)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 567
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 567
          (a->arg + n___4)->type = type;
        } else
#line 567
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 567
          goto error;
        }
      }
#line 569
      dp->conversion = c;
#line 570
      dp->dir_end = cp;
#line 573
      (d->count) ++;
#line 574
      if (d->count >= d_allocated) {
#line 579
        if (d_allocated <= 9223372036854775807UL) {
#line 579
          d_allocated *= 2UL;
        } else {
#line 579
          d_allocated = 0xffffffffffffffffUL;
        }
#line 580
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 580
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 580
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 581
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 583
          goto out_of_memory;
        }
        {
#line 584
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 584
        memory___2 = (char_directive *)tmp___26;
        }
#line 585
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 587
          goto out_of_memory;
        }
#line 588
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  (d->dir + d->count)->dir_start = cp;
#line 601
  d->max_width_length = max_width_length;
#line 602
  d->max_precision_length = max_precision_length;
#line 603
  return (0);
  error: 
#line 606
  if (a->arg) {
    {
#line 607
    free((void *)a->arg);
    }
  }
#line 608
  if (d->dir) {
    {
#line 609
    free((void *)d->dir);
    }
  }
  {
#line 610
  tmp___27 = __errno_location();
#line 610
  *tmp___27 = 22;
  }
#line 611
  return (-1);
  out_of_memory: 
#line 614
  if (a->arg) {
    {
#line 615
    free((void *)a->arg);
    }
  }
#line 616
  if (d->dir) {
    {
#line 617
    free((void *)d->dir);
    }
  }
  out_of_memory_1: 
  {
#line 619
  tmp___28 = __errno_location();
#line 619
  *tmp___28 = 12;
  }
#line 620
  return (-1);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) frexpl)(long double __x ,
                                                                                     int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) ldexpl)(long double __x ,
                                                                                     int __exponent ) ;
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ 
  int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
  {
#line 70
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 70
  oldcw = _cw;
#line 70
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 70
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 74
  x = frexpl(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
  }
#line 79
  if (exponent < -16382) {
    {
#line 81
    x = ldexpl(x, exponent - -16382);
#line 82
    exponent = -16382;
    }
  }
#line 184
  _ncw___0 = oldcw;
#line 184
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 64 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ 
  int exponent ;

  {
  {
#line 74
  x = frexp(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
  }
#line 79
  if (exponent < -1022) {
    {
#line 81
    x = ldexp(x, exponent - -1022);
#line 82
    exponent = -1022;
    }
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 112 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;

  {
#line 41
  i = (size_t )0;
#line 41
  ap = a->arg + 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < a->count)) {
#line 41
      goto while_break;
    }
    {
#line 44
    if ((unsigned int )ap->type == 1U) {
#line 44
      goto case_1;
    }
#line 47
    if ((unsigned int )ap->type == 2U) {
#line 47
      goto case_2;
    }
#line 50
    if ((unsigned int )ap->type == 3U) {
#line 50
      goto case_3;
    }
#line 53
    if ((unsigned int )ap->type == 4U) {
#line 53
      goto case_4;
    }
#line 56
    if ((unsigned int )ap->type == 5U) {
#line 56
      goto case_5;
    }
#line 59
    if ((unsigned int )ap->type == 6U) {
#line 59
      goto case_6;
    }
#line 62
    if ((unsigned int )ap->type == 7U) {
#line 62
      goto case_7;
    }
#line 65
    if ((unsigned int )ap->type == 8U) {
#line 65
      goto case_8;
    }
#line 69
    if ((unsigned int )ap->type == 9U) {
#line 69
      goto case_9;
    }
#line 72
    if ((unsigned int )ap->type == 10U) {
#line 72
      goto case_10;
    }
#line 76
    if ((unsigned int )ap->type == 11U) {
#line 76
      goto case_11;
    }
#line 79
    if ((unsigned int )ap->type == 12U) {
#line 79
      goto case_12;
    }
#line 82
    if ((unsigned int )ap->type == 13U) {
#line 82
      goto case_13;
    }
#line 86
    if ((unsigned int )ap->type == 14U) {
#line 86
      goto case_14;
    }
#line 96
    if ((unsigned int )ap->type == 15U) {
#line 96
      goto case_15;
    }
#line 105
    if ((unsigned int )ap->type == 16U) {
#line 105
      goto case_16;
    }
#line 123
    if ((unsigned int )ap->type == 17U) {
#line 123
      goto case_17;
    }
#line 126
    if ((unsigned int )ap->type == 18U) {
#line 126
      goto case_18;
    }
#line 129
    if ((unsigned int )ap->type == 19U) {
#line 129
      goto case_19;
    }
#line 132
    if ((unsigned int )ap->type == 20U) {
#line 132
      goto case_20;
    }
#line 135
    if ((unsigned int )ap->type == 21U) {
#line 135
      goto case_21;
    }
#line 139
    if ((unsigned int )ap->type == 22U) {
#line 139
      goto case_22;
    }
#line 182
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 45
    tmp = __builtin_va_arg(args, int );
#line 45
    ap->a.a_schar = tmp;
    }
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 48
    tmp___0 = __builtin_va_arg(args, int );
#line 48
    ap->a.a_uchar = tmp___0;
    }
#line 49
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 51
    tmp___1 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_short = tmp___1;
    }
#line 52
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 54
    tmp___2 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_ushort = tmp___2;
    }
#line 55
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 57
    tmp___3 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_int = tmp___3;
    }
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 60
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 60
    ap->a.a_uint = tmp___4;
    }
#line 61
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 63
    tmp___5 = __builtin_va_arg(args, long );
#line 63
    ap->a.a_longint = tmp___5;
    }
#line 64
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 66
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 66
    ap->a.a_ulongint = tmp___6;
    }
#line 67
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 70
    tmp___7 = __builtin_va_arg(args, long long );
#line 70
    ap->a.a_longlongint = tmp___7;
    }
#line 71
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 73
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 73
    ap->a.a_ulonglongint = tmp___8;
    }
#line 74
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 77
    tmp___9 = __builtin_va_arg(args, double );
#line 77
    ap->a.a_double = tmp___9;
    }
#line 78
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 80
    tmp___10 = __builtin_va_arg(args, long double );
#line 80
    ap->a.a_longdouble = tmp___10;
    }
#line 81
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 83
    tmp___11 = __builtin_va_arg(args, int );
#line 83
    ap->a.a_char = tmp___11;
    }
#line 84
    goto switch_break;
    case_14: /* CIL Label */ 
#line 90
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 90
      tmp___13 = __builtin_va_arg(args, int );
#line 90
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 90
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 90
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 94
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 97
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 97
    ap->a.a_string = tmp___16;
    }
#line 101
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 102
      ap->a.a_string = "(NULL)";
    }
#line 103
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 106
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 106
    ap->a.a_wide_string = tmp___17;
    }
#line 110
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 119
      ap->a.a_wide_string = wide_null_string;
    }
#line 121
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 124
    tmp___18 = __builtin_va_arg(args, void *);
#line 124
    ap->a.a_pointer = tmp___18;
    }
#line 125
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 127
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 127
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 128
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 130
    tmp___20 = __builtin_va_arg(args, short *);
#line 130
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 131
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 133
    tmp___21 = __builtin_va_arg(args, int *);
#line 133
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 134
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 136
    tmp___22 = __builtin_va_arg(args, long *);
#line 136
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 137
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 140
    tmp___23 = __builtin_va_arg(args, long long *);
#line 140
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 141
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 41
    i ++;
#line 41
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (0);
}
}
#line 1 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixver.h"
int posix2_version(void) ;
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixver.c"
int posix2_version(void) 
{ 
  long v ;
  char const   *s ;
  char *tmp ;
  char *e ;
  long i ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 43
  v = 200809L;
#line 44
  tmp = getenv("_POSIX2_VERSION");
#line 44
  s = (char const   *)tmp;
  }
#line 46
  if (s) {
#line 46
    if (*s) {
      {
#line 49
      tmp___0 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& e),
                       10);
#line 49
      i = tmp___0;
      }
#line 50
      if (! *e) {
#line 51
        v = i;
      }
    }
  }
#line 54
  if (v < (-0x7FFFFFFF-1)) {
#line 54
    tmp___2 = (-0x7FFFFFFF-1);
  } else {
#line 54
    if (v < 2147483647L) {
#line 54
      tmp___1 = v;
    } else {
#line 54
      tmp___1 = 2147483647L;
    }
#line 54
    tmp___2 = tmp___1;
  }
#line 54
  return ((int )tmp___2);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 34 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.h"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) ;
#line 61 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.c"
static int year(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ 
  time_t now ;
  struct tm *tmp ;

  {
  {
#line 66
  if (n == 1UL) {
#line 66
    goto case_1;
  }
#line 79
  if (n == 2UL) {
#line 79
    goto case_2;
  }
#line 85
  if (n == 0UL) {
#line 85
    goto case_0;
  }
#line 99
  goto switch_default;
  case_1: /* CIL Label */ 
#line 67
  tm->tm_year = (int )*digit_pair;
#line 71
  if (*(digit_pair + 0) <= 68) {
#line 73
    if (syntax_bits & 16U) {
#line 74
      return (1);
    }
#line 75
    tm->tm_year += 100;
  }
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  if (! (syntax_bits & 4U)) {
#line 81
    return (1);
  }
#line 82
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
#line 83
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 91
  time(& now);
#line 92
  tmp = localtime((time_t const   *)(& now));
  }
#line 93
  if (! tmp) {
#line 94
    return (1);
  }
#line 95
  tm->tm_year = tmp->tm_year;
#line 97
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 100
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 103
  return (0);
}
}
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.c"
static int posix_time_parse(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ 
  char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int seconds ;

  {
  {
#line 109
  dot = (char const   *)((void *)0);
#line 114
  tmp = strlen(s);
#line 114
  s_len = tmp;
  }
#line 115
  if (syntax_bits & 8U) {
    {
#line 115
    tmp___2 = strchr(s, '.');
#line 115
    dot = (char const   *)tmp___2;
    }
#line 115
    if (dot) {
#line 115
      tmp___1 = (size_t )(dot - s);
    } else {
#line 115
      tmp___1 = s_len;
    }
  } else {
#line 115
    tmp___1 = s_len;
  }
#line 115
  len = tmp___1;
#line 119
  if (len != 8UL) {
#line 119
    if (len != 10UL) {
#line 119
      if (len != 12UL) {
#line 120
        return (1);
      }
    }
  }
#line 122
  if (dot) {
#line 124
    if (! (syntax_bits & 8U)) {
#line 125
      return (1);
    }
#line 127
    if (s_len - len != 3UL) {
#line 128
      return (1);
    }
  }
#line 131
  i = (size_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < len)) {
#line 131
      goto while_break;
    }
#line 132
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
#line 133
      return (1);
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  len /= 2UL;
#line 136
  i = (size_t )0;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < len)) {
#line 136
      goto while_break___0;
    }
#line 137
    pair[i] = (10 * (int )((int const   )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  p = pair;
#line 140
  if (syntax_bits & 1U) {
    {
#line 142
    tmp___3 = year(tm, (int const   *)p, len - 4UL, syntax_bits);
    }
#line 142
    if (tmp___3) {
#line 143
      return (1);
    }
#line 144
    p += len - 4UL;
#line 145
    len = (size_t )4;
  }
#line 149
  tmp___4 = p;
#line 149
  p ++;
#line 149
  tm->tm_mon = *tmp___4 - 1;
#line 150
  tmp___5 = p;
#line 150
  p ++;
#line 150
  tm->tm_mday = *tmp___5;
#line 151
  tmp___6 = p;
#line 151
  p ++;
#line 151
  tm->tm_hour = *tmp___6;
#line 152
  tmp___7 = p;
#line 152
  p ++;
#line 152
  tm->tm_min = *tmp___7;
#line 153
  len -= 4UL;
#line 156
  if (syntax_bits & 2U) {
    {
#line 158
    tmp___8 = year(tm, (int const   *)p, len, syntax_bits);
    }
#line 158
    if (tmp___8) {
#line 159
      return (1);
    }
  }
#line 163
  if (! dot) {
#line 165
    tm->tm_sec = 0;
  } else {
#line 171
    dot ++;
#line 172
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
#line 173
      return (1);
    } else
#line 172
    if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
#line 173
      return (1);
    }
#line 174
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
#line 176
    tm->tm_sec = seconds;
  }
#line 179
  return (0);
}
}
#line 184 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.c"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) 
{ 
  struct tm tm0 ;
  struct tm tm1 ;
  struct tm  const  *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 192
  tmp = posix_time_parse(& tm0, s, syntax_bits);
  }
#line 192
  if (tmp) {
#line 193
    return ((_Bool)0);
  }
  {
#line 195
  tm1 = tm0;
#line 196
  tm1.tm_isdst = -1;
#line 197
  t = mktime(& tm1);
  }
#line 199
  if (t != -1L) {
#line 200
    tm = (struct tm  const  *)(& tm1);
  } else {
    {
#line 205
    tmp___0 = localtime((time_t const   *)(& t));
#line 205
    tm = (struct tm  const  *)tmp___0;
    }
#line 206
    if (! tm) {
#line 207
      return ((_Bool)0);
    }
  }
#line 211
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
#line 217
    return ((_Bool)0);
  }
#line 219
  *p = t;
#line 220
  return ((_Bool)1);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 23 "/home/khheo/project/benchmark/coreutils-7.1/lib/physmem.h"
double physmem_total(void) ;
#line 24
double physmem_available(void) ;
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 81 "/home/khheo/project/benchmark/coreutils-7.1/lib/physmem.c"
double physmem_total(void) 
{ 
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;

  {
  {
#line 86
  tmp = sysconf(85);
#line 86
  pages = (double )tmp;
#line 87
  tmp___0 = sysconf(30);
#line 87
  pagesize = (double )tmp___0;
  }
#line 88
  if ((double )0 <= pages) {
#line 88
    if ((double )0 <= pagesize) {
#line 89
      return (pages * pagesize);
    }
  }
#line 181
  return ((double )67108864);
}
}
#line 185 "/home/khheo/project/benchmark/coreutils-7.1/lib/physmem.c"
double physmem_available(void) 
{ 
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  double tmp___1 ;

  {
  {
#line 190
  tmp = sysconf(86);
#line 190
  pages = (double )tmp;
#line 191
  tmp___0 = sysconf(30);
#line 191
  pagesize = (double )tmp___0;
  }
#line 192
  if ((double )0 <= pages) {
#line 192
    if ((double )0 <= pagesize) {
#line 193
      return (pages * pagesize);
    }
  }
  {
#line 282
  tmp___1 = physmem_total();
  }
#line 282
  return (tmp___1 / (double )4);
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-proc.c"
static int proc_status  =    0;
#line 52 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-proc.c"
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) 
{ 
  int proc_self_fd ;
  int tmp ;
  struct stat proc_self_fd_dotdot_st ;
  struct stat proc_self_st ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + (sizeof("..") - 1UL)) + 1UL] ;
  int tmp___2 ;
  int tmp___3 ;
  size_t bufsize___1 ;
  size_t tmp___4 ;
  char *result ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 57
  if (! proc_status) {
    {
#line 67
    tmp = open("/proc/self/fd", 0);
#line 67
    proc_self_fd = tmp;
    }
#line 68
    if (proc_self_fd < 0) {
#line 69
      proc_status = -1;
    } else {
      {
#line 75
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
              proc_self_fd, "..");
#line 76
      tmp___2 = stat((char const   */* __restrict  */)(dotdot_buf), (struct stat */* __restrict  */)(& proc_self_fd_dotdot_st));
      }
#line 76
      if (tmp___2 == 0) {
        {
#line 76
        tmp___3 = stat((char const   */* __restrict  */)"/proc/self", (struct stat */* __restrict  */)(& proc_self_st));
        }
#line 76
        if (tmp___3 == 0) {
#line 76
          if (proc_self_fd_dotdot_st.st_ino == proc_self_st.st_ino) {
#line 76
            if (proc_self_fd_dotdot_st.st_dev == proc_self_st.st_dev) {
#line 76
              proc_status = 1;
            } else {
#line 76
              proc_status = -1;
            }
          } else {
#line 76
            proc_status = -1;
          }
        } else {
#line 76
          proc_status = -1;
        }
      } else {
#line 76
        proc_status = -1;
      }
      {
#line 81
      close(proc_self_fd);
      }
    }
  }
#line 85
  if (proc_status < 0) {
#line 86
    return ((char *)((void *)0));
  } else {
    {
#line 89
    tmp___4 = strlen(file);
#line 89
    bufsize___1 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + tmp___4) + 1UL;
    }
#line 90
    if (bufsize___1 < 512UL) {
#line 90
      tmp___6 = buf___1;
    } else {
      {
#line 90
      tmp___5 = xmalloc(bufsize___1);
#line 90
      tmp___6 = (char *)tmp___5;
      }
    }
    {
#line 90
    result = (char *)tmp___6;
#line 91
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
            fd, file);
    }
#line 92
    return (result);
  }
}
}
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-die.c"
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("unable to record current working directory");
#line 34
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 41
  abort();
  }
}
}
#line 44
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 47
  tmp = gettext("failed to return to initial working directory");
#line 47
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 51
  abort();
  }
}
}
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  mode_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
    {
#line 36
    __builtin_va_start(ap, flags);
    }
#line 41
    if (sizeof(mode_t ) < sizeof(int )) {
      {
#line 42
      tmp = __builtin_va_arg(ap, int );
#line 42
      mode = tmp;
      }
    } else {
      {
#line 44
      tmp___0 = __builtin_va_arg(ap, mode_t );
#line 44
      mode = tmp___0;
      }
    }
    {
#line 46
    __builtin_va_end(ap);
    }
  }
  {
#line 49
  tmp___1 = open(file, flags, mode);
#line 49
  tmp___2 = fd_safer(tmp___1);
  }
#line 49
  return (tmp___2);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 43 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___1 + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 211 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/nanosleep.c"
static void getnow(struct timespec *t ) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = clock_gettime(1, t);
  }
#line 49
  if (tmp == 0) {
#line 50
    return;
  }
  {
#line 52
  gettime(t);
  }
#line 53
  return;
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/nanosleep.c"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) 
{ 
  struct timespec delay ;
  struct timespec t0 ;
  int r ;
  int tmp ;
  time_t secs_sofar ;
  struct timespec now ;

  {
  {
#line 63
  delay = *requested_delay;
#line 65
  getnow(& t0);
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp = nanosleep((struct timespec  const  *)(& delay), remaining_delay);
#line 69
    r = tmp;
    }
#line 70
    if (r == 0) {
      {
#line 74
      getnow(& now);
#line 76
      secs_sofar = now.tv_sec - t0.tv_sec;
      }
#line 77
      if (requested_delay->tv_sec < (__time_t const   )secs_sofar) {
#line 78
        return (0);
      }
#line 79
      delay.tv_sec = (__time_t )(requested_delay->tv_sec - (__time_t const   )secs_sofar);
#line 80
      delay.tv_nsec = (__syscall_slong_t )(requested_delay->tv_nsec - (__syscall_slong_t const   )(now.tv_nsec - t0.tv_nsec));
#line 81
      if (delay.tv_nsec < 0L) {
#line 83
        if (delay.tv_sec == 0L) {
#line 84
          return (0);
        }
#line 85
        delay.tv_nsec += 1000000000L;
#line 86
        (delay.tv_sec) --;
      } else
#line 88
      if (1000000000L <= delay.tv_nsec) {
#line 90
        delay.tv_nsec -= 1000000000L;
#line 91
        (delay.tv_sec) ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.h"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_into_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ 
  size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  tmp___0 ;
  void const   ** __restrict  tmp___1 ;
  int tmp___2 ;

  {
  {
#line 41
  n1 = n / 2UL;
#line 42
  n2 = n - n1;
#line 43
  a = (size_t )0;
#line 44
  alim = n1;
#line 45
  b = n1;
#line 46
  blim = n;
#line 50
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 51
  mpsort_with_tmp(base, n1, tmp, cmp);
#line 53
  ba = *(base + a);
#line 54
  bb = *(base + b);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___2 = (*cmp)(ba, bb);
    }
#line 57
    if (tmp___2 <= 0) {
#line 59
      tmp___0 = tmp;
#line 59
      tmp ++;
#line 59
      *tmp___0 = ba;
#line 60
      a ++;
#line 61
      if (a == alim) {
#line 63
        a = b;
#line 64
        alim = blim;
#line 65
        goto while_break;
      }
#line 67
      ba = *(base + a);
    } else {
#line 71
      tmp___1 = tmp;
#line 71
      tmp ++;
#line 71
      *tmp___1 = bb;
#line 72
      b ++;
#line 73
      if (b == blim) {
#line 74
        goto while_break;
      }
#line 75
      bb = *(base + b);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(base + a),
         (alim - a) * sizeof(*base));
  }
#line 79
  return;
}
}
#line 85 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ 
  void const   *p0 ;
  void const   *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 90
  if (n <= 2UL) {
#line 92
    if (n == 2UL) {
      {
#line 94
      p0 = *(base + 0);
#line 95
      p1 = *(base + 1);
#line 96
      tmp___0 = (*cmp)(p0, p1);
      }
#line 96
      if (! (tmp___0 <= 0)) {
#line 98
        *(base + 0) = p1;
#line 99
        *(base + 1) = p0;
      }
    }
  } else {
    {
#line 105
    n1 = n / 2UL;
#line 106
    n2 = n - n1;
#line 108
    t = (size_t )0;
#line 109
    tlim = n1;
#line 110
    b = n1;
#line 111
    blim = n;
#line 115
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
    }
#line 117
    if (n1 < 2UL) {
#line 118
      *(tmp + 0) = *(base + 0);
    } else {
      {
#line 120
      mpsort_into_tmp(base, n1, tmp, cmp);
      }
    }
#line 122
    tt = *(tmp + t);
#line 123
    bb = *(base + b);
#line 125
    i = (size_t )0;
    {
#line 125
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 126
      tmp___3 = (*cmp)(tt, bb);
      }
#line 126
      if (tmp___3 <= 0) {
#line 128
        tmp___1 = i;
#line 128
        i ++;
#line 128
        *(base + tmp___1) = tt;
#line 129
        t ++;
#line 130
        if (t == tlim) {
#line 131
          goto while_break;
        }
#line 132
        tt = *(tmp + t);
      } else {
#line 136
        tmp___2 = i;
#line 136
        i ++;
#line 136
        *(base + tmp___2) = bb;
#line 137
        b ++;
#line 138
        if (b == blim) {
          {
#line 140
          memcpy((void */* __restrict  */)(base + i), (void const   */* __restrict  */)(tmp + t),
                 (tlim - t) * sizeof(*base));
          }
#line 141
          goto while_break;
        }
#line 143
        bb = *(base + b);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 152 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) 
{ 


  {
  {
#line 155
  mpsort_with_tmp((void const   **/* __restrict  */)base, n, (void const   **/* __restrict  */)(base + n),
                  cmp);
  }
#line 156
  return;
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/mountlist.h"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
#line 64 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 69
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 85
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 302 "/home/khheo/project/benchmark/coreutils-7.1/lib/mountlist.c"
static dev_t dev_from_mount_options(char const   *mount_options ) 
{ 


  {
#line 329
  return ((dev_t )-1);
}
}
#line 339 "/home/khheo/project/benchmark/coreutils-7.1/lib/mountlist.c"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) 
{ 
  struct mount_entry *mount_list ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char const   *table ;
  FILE *fp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int saved_errno ;
  int *tmp___12 ;
  int *tmp___13 ;

  {
  {
#line 344
  mtail = & mount_list;
#line 380
  table = "/etc/mtab";
#line 383
  fp = setmntent(table, "r");
  }
#line 384
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 385
    return ((struct mount_entry *)((void *)0));
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 387
    mnt = getmntent(fp);
    }
#line 387
    if (! mnt) {
#line 387
      goto while_break;
    }
    {
#line 389
    tmp = xmalloc(sizeof(*me));
#line 389
    me = (struct mount_entry *)tmp;
#line 390
    me->me_devname = xstrdup((char const   *)mnt->mnt_fsname);
#line 391
    me->me_mountdir = xstrdup((char const   *)mnt->mnt_dir);
#line 392
    me->me_type = xstrdup((char const   *)mnt->mnt_type);
#line 393
    me->me_type_malloced = 1U;
#line 394
    tmp___0 = strcmp((char const   *)me->me_type, "autofs");
    }
#line 394
    if (tmp___0 == 0) {
#line 394
      tmp___6 = 1;
    } else {
      {
#line 394
      tmp___1 = strcmp((char const   *)me->me_type, "none");
      }
#line 394
      if (tmp___1 == 0) {
#line 394
        tmp___6 = 1;
      } else {
        {
#line 394
        tmp___2 = strcmp((char const   *)me->me_type, "proc");
        }
#line 394
        if (tmp___2 == 0) {
#line 394
          tmp___6 = 1;
        } else {
          {
#line 394
          tmp___3 = strcmp((char const   *)me->me_type, "subfs");
          }
#line 394
          if (tmp___3 == 0) {
#line 394
            tmp___6 = 1;
          } else {
            {
#line 394
            tmp___4 = strcmp((char const   *)me->me_type, "kernfs");
            }
#line 394
            if (tmp___4 == 0) {
#line 394
              tmp___6 = 1;
            } else {
              {
#line 394
              tmp___5 = strcmp((char const   *)me->me_type, "ignore");
              }
#line 394
              if (tmp___5 == 0) {
#line 394
                tmp___6 = 1;
              } else {
#line 394
                tmp___6 = 0;
              }
            }
          }
        }
      }
    }
    {
#line 394
    me->me_dummy = (unsigned int )tmp___6;
#line 395
    tmp___7 = strchr((char const   *)me->me_devname, ':');
    }
#line 395
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 395
      tmp___10 = 1;
    } else
#line 395
    if ((int )*(me->me_devname + 0) == 47) {
#line 395
      if ((int )*(me->me_devname + 1) == 47) {
        {
#line 395
        tmp___8 = strcmp((char const   *)me->me_type, "smbfs");
        }
#line 395
        if (tmp___8 == 0) {
#line 395
          tmp___10 = 1;
        } else {
          {
#line 395
          tmp___9 = strcmp((char const   *)me->me_type, "cifs");
          }
#line 395
          if (tmp___9 == 0) {
#line 395
            tmp___10 = 1;
          } else {
#line 395
            tmp___10 = 0;
          }
        }
      } else {
#line 395
        tmp___10 = 0;
      }
    } else {
#line 395
      tmp___10 = 0;
    }
    {
#line 395
    me->me_remote = (unsigned int )tmp___10;
#line 396
    me->me_dev = dev_from_mount_options((char const   *)mnt->mnt_opts);
#line 399
    *mtail = me;
#line 400
    mtail = & me->me_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 403
  tmp___11 = endmntent(fp);
  }
#line 403
  if (tmp___11 == 0) {
#line 404
    goto free_then_fail;
  }
#line 860
  *mtail = (struct mount_entry *)((void *)0);
#line 861
  return (mount_list);
  free_then_fail: 
  {
#line 866
  tmp___12 = __errno_location();
#line 866
  saved_errno = *tmp___12;
#line 867
  *mtail = (struct mount_entry *)((void *)0);
  }
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 869
    if (! mount_list) {
#line 869
      goto while_break___0;
    }
    {
#line 871
    me = mount_list->me_next;
#line 872
    free((void *)mount_list->me_devname);
#line 873
    free((void *)mount_list->me_mountdir);
    }
#line 874
    if (mount_list->me_type_malloced) {
      {
#line 875
      free((void *)mount_list->me_type);
      }
    }
    {
#line 876
    free((void *)mount_list);
#line 877
    mount_list = me;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 880
  tmp___13 = __errno_location();
#line 880
  *tmp___13 = saved_errno;
  }
#line 881
  return ((struct mount_entry *)((void *)0));
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.h"
struct mode_change *mode_compile(char const   *mode_string ) ;
#line 26
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 27
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
static mode_t octal_to_mode(unsigned int octal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 58
  if (256 >> 3 == 32) {
#line 58
    if (128 >> 3 == 16) {
#line 58
      if (64 >> 3 == 8) {
#line 58
        if ((256 >> 3) >> 3 == 4) {
#line 58
          if ((128 >> 3) >> 3 == 2) {
#line 58
            if ((64 >> 3) >> 3 == 1) {
#line 58
              tmp___11 = octal;
            } else {
#line 58
              goto _L___3;
            }
          } else {
#line 58
            goto _L___3;
          }
        } else {
#line 58
          goto _L___3;
        }
      } else {
#line 58
        goto _L___3;
      }
    } else {
#line 58
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 58
    if (octal & 2048U) {
#line 58
      tmp = 2048;
    } else {
#line 58
      tmp = 0;
    }
#line 58
    if (octal & 1024U) {
#line 58
      tmp___0 = 1024;
    } else {
#line 58
      tmp___0 = 0;
    }
#line 58
    if (octal & 512U) {
#line 58
      tmp___1 = 512;
    } else {
#line 58
      tmp___1 = 0;
    }
#line 58
    if (octal & 256U) {
#line 58
      tmp___2 = 256;
    } else {
#line 58
      tmp___2 = 0;
    }
#line 58
    if (octal & 128U) {
#line 58
      tmp___3 = 128;
    } else {
#line 58
      tmp___3 = 0;
    }
#line 58
    if (octal & 64U) {
#line 58
      tmp___4 = 64;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (octal & 32U) {
#line 58
      tmp___5 = 256 >> 3;
    } else {
#line 58
      tmp___5 = 0;
    }
#line 58
    if (octal & 16U) {
#line 58
      tmp___6 = 128 >> 3;
    } else {
#line 58
      tmp___6 = 0;
    }
#line 58
    if (octal & 8U) {
#line 58
      tmp___7 = 64 >> 3;
    } else {
#line 58
      tmp___7 = 0;
    }
#line 58
    if (octal & 4U) {
#line 58
      tmp___8 = (256 >> 3) >> 3;
    } else {
#line 58
      tmp___8 = 0;
    }
#line 58
    if (octal & 2U) {
#line 58
      tmp___9 = (128 >> 3) >> 3;
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    if (octal & 1U) {
#line 58
      tmp___10 = (64 >> 3) >> 3;
    } else {
#line 58
      tmp___10 = 0;
    }
#line 58
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
#line 58
  return (tmp___11);
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ 
  struct mode_change *p ;
  void *tmp ;

  {
  {
#line 114
  tmp = xmalloc(2UL * sizeof(*p));
#line 114
  p = (struct mode_change *)tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 118
  p->value = new_mode;
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
  }
#line 121
  return (p);
}
}
#line 133 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
struct mode_change *mode_compile(char const   *mode_string ) 
{ 
  struct mode_change *mc ;
  size_t used___0 ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  char const   *p ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const   *tmp___3 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const   *tmp___4 ;
  size_t tmp___5 ;

  {
#line 138
  used___0 = (size_t )0;
#line 140
  if (48 <= (int )*mode_string) {
#line 140
    if ((int const   )*mode_string < 56) {
#line 142
      octal_mode = 0U;
      {
#line 146
      while (1) {
        while_continue: /* CIL Label */ ;
#line 148
        tmp = mode_string;
#line 148
        mode_string ++;
#line 148
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
#line 149
        if (4095U < octal_mode) {
#line 150
          return ((struct mode_change *)((void *)0));
        }
#line 146
        if (48 <= (int )*mode_string) {
#line 146
          if (! ((int const   )*mode_string < 56)) {
#line 146
            goto while_break;
          }
        } else {
#line 146
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 154
      if (*mode_string) {
#line 155
        return ((struct mode_change *)((void *)0));
      }
      {
#line 157
      mode = octal_to_mode(octal_mode);
#line 158
      mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 159
      tmp___0 = make_node_op_equals(mode, mentioned);
      }
#line 159
      return (tmp___0);
    }
  }
#line 164
  needed = (size_t )1;
#line 166
  p = mode_string;
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! *p) {
#line 166
      goto while_break___0;
    }
#line 167
    if ((int const   )*p == 61) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 43) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 45) {
#line 167
      tmp___1 = 1;
    } else {
#line 167
      tmp___1 = 0;
    }
#line 167
    needed += (size_t )tmp___1;
#line 166
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 168
  tmp___2 = xnmalloc(needed, sizeof(*mc));
#line 168
  mc = (struct mode_change *)tmp___2;
  }
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    affected = (mode_t )0;
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 183
      if ((int const   )*mode_string == 117) {
#line 183
        goto case_117;
      }
#line 186
      if ((int const   )*mode_string == 103) {
#line 186
        goto case_103;
      }
#line 189
      if ((int const   )*mode_string == 111) {
#line 189
        goto case_111;
      }
#line 192
      if ((int const   )*mode_string == 97) {
#line 192
        goto case_97;
      }
#line 195
      if ((int const   )*mode_string == 45) {
#line 195
        goto case_45;
      }
#line 195
      if ((int const   )*mode_string == 43) {
#line 195
        goto case_45;
      }
#line 195
      if ((int const   )*mode_string == 61) {
#line 195
        goto case_45;
      }
#line 181
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 182
      goto invalid;
      case_117: /* CIL Label */ 
#line 184
      affected |= 2496U;
#line 185
      goto switch_break;
      case_103: /* CIL Label */ 
#line 187
      affected |= (unsigned int )(1024 | (448 >> 3));
#line 188
      goto switch_break;
      case_111: /* CIL Label */ 
#line 190
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
#line 191
      goto switch_break;
      case_97: /* CIL Label */ 
#line 193
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 194
      goto switch_break;
      case_45: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_61: /* CIL Label */ 
#line 196
      goto no_more_affected;
      switch_break: /* CIL Label */ ;
      }
#line 178
      mode_string ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    no_more_affected: ;
    {
#line 200
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 202
      tmp___3 = mode_string;
#line 202
      mode_string ++;
#line 202
      op = (char )*tmp___3;
#line 204
      flag = (char)3;
#line 207
      tmp___4 = mode_string;
#line 207
      mode_string ++;
      {
#line 209
      if ((int const   )*tmp___4 == 117) {
#line 209
        goto case_117___0;
      }
#line 214
      if ((int const   )*tmp___4 == 103) {
#line 214
        goto case_103___0;
      }
#line 219
      if ((int const   )*tmp___4 == 111) {
#line 219
        goto case_111___0;
      }
#line 225
      goto switch_default___0;
      case_117___0: /* CIL Label */ 
#line 212
      value = (mode_t )448;
#line 213
      goto switch_break___0;
      case_103___0: /* CIL Label */ 
#line 217
      value = (mode_t )(448 >> 3);
#line 218
      goto switch_break___0;
      case_111___0: /* CIL Label */ 
#line 222
      value = (mode_t )((448 >> 3) >> 3);
#line 223
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 226
      value = (mode_t )0;
#line 227
      flag = (char)1;
#line 229
      mode_string --;
      {
#line 229
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 232
        if ((int const   )*mode_string == 114) {
#line 232
          goto case_114;
        }
#line 235
        if ((int const   )*mode_string == 119) {
#line 235
          goto case_119;
        }
#line 238
        if ((int const   )*mode_string == 120) {
#line 238
          goto case_120;
        }
#line 241
        if ((int const   )*mode_string == 88) {
#line 241
          goto case_88;
        }
#line 244
        if ((int const   )*mode_string == 115) {
#line 244
          goto case_115;
        }
#line 248
        if ((int const   )*mode_string == 116) {
#line 248
          goto case_116;
        }
#line 252
        goto switch_default___1;
        case_114: /* CIL Label */ 
#line 233
        value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 234
        goto switch_break___1;
        case_119: /* CIL Label */ 
#line 236
        value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
#line 237
        goto switch_break___1;
        case_120: /* CIL Label */ 
#line 239
        value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
#line 240
        goto switch_break___1;
        case_88: /* CIL Label */ 
#line 242
        flag = (char)2;
#line 243
        goto switch_break___1;
        case_115: /* CIL Label */ 
#line 246
        value |= 3072U;
#line 247
        goto switch_break___1;
        case_116: /* CIL Label */ 
#line 250
        value |= 512U;
#line 251
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 253
        goto no_more_values;
        switch_break___1: /* CIL Label */ ;
        }
#line 229
        mode_string ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      no_more_values: ;
      switch_break___0: /* CIL Label */ ;
      }
#line 258
      tmp___5 = used___0;
#line 258
      used___0 ++;
#line 258
      change = mc + tmp___5;
#line 259
      change->op = op;
#line 260
      change->flag = flag;
#line 261
      change->affected = affected;
#line 262
      change->value = value;
#line 263
      if (affected) {
#line 263
        change->mentioned = affected & value;
      } else {
#line 263
        change->mentioned = value;
      }
#line 200
      if (! ((int const   )*mode_string == 61)) {
#line 200
        if (! ((int const   )*mode_string == 43)) {
#line 200
          if (! ((int const   )*mode_string == 45)) {
#line 200
            goto while_break___3;
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 268
    if ((int const   )*mode_string != 44) {
#line 269
      goto while_break___1;
    }
#line 172
    mode_string ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 272
  if ((int const   )*mode_string == 0) {
#line 274
    (mc + used___0)->flag = (char)0;
#line 275
    return (mc);
  }
  invalid: 
  {
#line 279
  free((void *)mc);
  }
#line 280
  return ((struct mode_change *)((void *)0));
}
}
#line 286 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ 
  struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;

  {
  {
#line 291
  tmp = stat((char const   */* __restrict  */)ref_file, (struct stat */* __restrict  */)(& ref_stats));
  }
#line 291
  if (tmp != 0) {
#line 292
    return ((struct mode_change *)((void *)0));
  }
  {
#line 293
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
  }
#line 293
  return (tmp___0);
}
}
#line 309 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ 
  mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;

  {
#line 314
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 317
  mode_bits = (mode_t )0;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((int const   )changes->flag != 0)) {
#line 319
      goto while_break;
    }
#line 321
    affected = (mode_t )changes->affected;
#line 322
    if (dir) {
#line 322
      tmp = 3072;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    omit_change = (mode_t )((unsigned int const   )tmp & ~ changes->mentioned);
#line 324
    value = (mode_t )changes->value;
    {
#line 328
    if ((int const   )changes->flag == 1) {
#line 328
      goto case_1;
    }
#line 331
    if ((int const   )changes->flag == 3) {
#line 331
      goto case_3;
    }
#line 344
    if ((int const   )changes->flag == 2) {
#line 344
      goto case_2;
    }
#line 326
    goto switch_break;
    case_1: /* CIL Label */ 
#line 329
    goto switch_break;
    case_3: /* CIL Label */ 
#line 333
    value &= newmode;
#line 336
    if (value & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
#line 336
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
    } else {
#line 336
      tmp___0 = 0;
    }
#line 336
    if (value & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
#line 336
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
    } else {
#line 336
      tmp___1 = 0;
    }
#line 336
    if (value & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 336
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
    } else {
#line 336
      tmp___2 = 0;
    }
#line 336
    value |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
#line 342
    goto switch_break;
    case_2: /* CIL Label */ 
#line 347
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
#line 348
      value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
    }
#line 349
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 355
    if (affected) {
#line 355
      tmp___3 = affected;
    } else {
#line 355
      tmp___3 = ~ umask_value;
    }
#line 355
    value &= tmp___3 & ~ omit_change;
    {
#line 359
    if ((int const   )changes->op == 61) {
#line 359
      goto case_61;
    }
#line 370
    if ((int const   )changes->op == 43) {
#line 370
      goto case_43;
    }
#line 375
    if ((int const   )changes->op == 45) {
#line 375
      goto case_45;
    }
#line 357
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 364
    if (affected) {
#line 364
      tmp___4 = ~ affected;
    } else {
#line 364
      tmp___4 = (mode_t )0;
    }
#line 364
    preserved = tmp___4 | omit_change;
#line 365
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
#line 366
    newmode = (newmode & preserved) | value;
#line 367
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 371
    mode_bits |= value;
#line 372
    newmode |= value;
#line 373
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 376
    mode_bits |= value;
#line 377
    newmode &= ~ value;
#line 378
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 319
    changes ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (pmode_bits) {
#line 383
    *pmode_bits = mode_bits;
  }
#line 384
  return (newmode);
}
}
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/stdlib-safer.h"
int mkstemp_safer(char *templ ) ;
#line 685 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/mkstemp-safer.c"
int mkstemp_safer(char *templ ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  tmp = mkstemp(templ);
#line 33
  tmp___0 = fd_safer(tmp);
  }
#line 33
  return (tmp___0);
}
}
#line 25 "/home/khheo/project/benchmark/coreutils-7.1/lib/mkdir-p.h"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
#line 3 "/home/khheo/project/benchmark/coreutils-7.1/lib/mkancesdirs.h"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
#line 120 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.h"
__inline static int savewd_errno(struct savewd  const  *wd ) 
{ 
  int tmp ;

  {
#line 123
  if ((unsigned int const   )wd->state == 4U) {
#line 123
    tmp = wd->val.errnum;
  } else {
#line 123
    tmp = (int const   )0;
  }
#line 123
  return ((int )tmp);
}
}
#line 85 "/home/khheo/project/benchmark/coreutils-7.1/lib/mkdir-p.c"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) 
{ 
  int mkdir_errno ;
  int tmp ;
  int tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *tmp___1 ;
  _Bool keep_owner ;
  int tmp___2 ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int open_result[2] ;
  int chdir_result ;
  int tmp___7 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *tmp___8 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  int tmp___9 ;
  char const   *subdir ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
#line 97
  if ((int )*(dir + 0) == 47) {
#line 97
    tmp___0 = 0;
  } else {
    {
#line 97
    tmp = savewd_errno((struct savewd  const  *)wd);
#line 97
    tmp___0 = tmp;
    }
  }
#line 97
  mkdir_errno = tmp___0;
#line 99
  if (mkdir_errno == 0) {
#line 101
    prefix_len = (ptrdiff_t )0;
#line 102
    savewd_chdir_options = 4;
#line 104
    if (make_ancestor) {
      {
#line 106
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
      }
#line 107
      if (prefix_len < 0L) {
#line 109
        if (prefix_len < -1L) {
#line 110
          return ((_Bool)1);
        }
        {
#line 111
        tmp___1 = __errno_location();
#line 111
        mkdir_errno = *tmp___1;
        }
      }
    }
#line 115
    if (0L <= prefix_len) {
#line 122
      if (owner == 4294967295U) {
#line 122
        if (group == 4294967295U) {
#line 122
          tmp___2 = 1;
        } else {
#line 122
          tmp___2 = 0;
        }
      } else {
#line 122
        tmp___2 = 0;
      }
#line 122
      keep_owner = (_Bool )tmp___2;
#line 123
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
#line 125
      mkdir_mode = mode;
#line 126
      if (! keep_owner) {
#line 127
        mkdir_mode &= (unsigned int )(~ ((448 >> 3) | ((448 >> 3) >> 3)));
      } else
#line 128
      if (! keep_special_mode_bits) {
#line 129
        mkdir_mode &= (unsigned int )(~ ((128 >> 3) | ((128 >> 3) >> 3)));
      }
      {
#line 131
      tmp___5 = mkdir((char const   *)(dir + prefix_len), mkdir_mode);
      }
#line 131
      if (tmp___5 == 0) {
        {
#line 133
        (*announce)((char const   *)dir, options);
#line 134
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
        }
#line 135
        if (mode & 256U) {
#line 135
          tmp___3 = 2;
        } else {
#line 135
          tmp___3 = 0;
        }
#line 135
        savewd_chdir_options |= 1 | tmp___3;
      } else {
        {
#line 141
        tmp___4 = __errno_location();
#line 141
        mkdir_errno = *tmp___4;
#line 142
        mkdir_mode = (mode_t )-1;
        }
      }
#line 145
      if (preserve_existing) {
#line 148
        if (mkdir_errno == 0) {
#line 152
          return ((_Bool)1);
        } else
#line 148
        if (mkdir_errno != 2) {
#line 148
          if (make_ancestor) {
            {
#line 148
            tmp___6 = stat((char const   */* __restrict  */)(dir + prefix_len), (struct stat */* __restrict  */)(& st));
            }
#line 148
            if (tmp___6 == 0) {
#line 148
              if ((st.st_mode & 61440U) == 16384U) {
#line 152
                return ((_Bool)1);
              }
            }
          }
        }
      } else {
        {
#line 157
        tmp___7 = savewd_chdir(wd, (char const   *)(dir + prefix_len), savewd_chdir_options,
                               (int *)(open_result));
#line 157
        chdir_result = tmp___7;
        }
#line 160
        if (chdir_result < -1) {
#line 161
          return ((_Bool)1);
        } else {
          {
#line 164
          chdir_ok = (_Bool )(chdir_result == 0);
#line 165
          tmp___8 = __errno_location();
#line 165
          chdir_errno = *tmp___8;
#line 166
          fd = open_result[0];
          }
#line 167
          if (mkdir_errno == 0) {
#line 167
            if (! chdir_ok) {
#line 167
              if (mode & 64U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 167
            if (fd < 0) {
#line 167
              if (mode & 256U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                tmp___9 = 0;
              }
            } else {
#line 167
              tmp___9 = 0;
            }
          } else {
#line 167
            tmp___9 = 0;
          }
#line 167
          chdir_failed_unexpectedly = (_Bool )tmp___9;
#line 172
          if (chdir_failed_unexpectedly) {
#line 175
            if (0 <= fd) {
              {
#line 176
              close(fd);
              }
            }
          } else {
#line 180
            if (chdir_ok) {
#line 180
              tmp___10 = ".";
            } else {
#line 180
              tmp___10 = (char const   *)(dir + prefix_len);
            }
            {
#line 180
            subdir = tmp___10;
#line 181
            tmp___11 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode, mode_bits);
            }
#line 181
            if (tmp___11 == 0) {
#line 184
              return ((_Bool)1);
            }
          }
#line 187
          if (mkdir_errno == 0) {
#line 187
            goto _L___0;
          } else
#line 187
          if (mkdir_errno != 2) {
#line 187
            if (make_ancestor) {
              {
#line 187
              tmp___18 = __errno_location();
              }
#line 187
              if (*tmp___18 != 20) {
                _L___0: /* CIL Label */ 
                {
#line 191
                tmp___12 = quote((char const   *)dir);
                }
#line 191
                if (keep_owner) {
#line 191
                  tmp___13 = "cannot change permissions of %s";
                } else {
#line 191
                  tmp___13 = "cannot change owner and permissions of %s";
                }
                {
#line 191
                tmp___14 = gettext(tmp___13);
                }
#line 191
                if (! chdir_failed_unexpectedly) {
                  {
#line 191
                  tmp___15 = __errno_location();
#line 191
                  tmp___17 = *tmp___15;
                  }
                } else {
#line 191
                  if (! chdir_ok) {
#line 191
                    if (mode & 64U) {
#line 191
                      tmp___16 = chdir_errno;
                    } else {
#line 191
                      tmp___16 = open_result[1];
                    }
                  } else {
#line 191
                    tmp___16 = open_result[1];
                  }
#line 191
                  tmp___17 = tmp___16;
                }
                {
#line 191
                error(0, tmp___17, (char const   *)tmp___14, tmp___12);
                }
#line 199
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
  }
  {
#line 206
  tmp___19 = quote((char const   *)dir);
#line 206
  tmp___20 = gettext("cannot create directory %s");
#line 206
  error(0, mkdir_errno, (char const   *)tmp___20, tmp___19);
  }
#line 207
  return ((_Bool)0);
}
}
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/mkancesdirs.c"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) 
{ 
  char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 74
  sep = (char *)((void *)0);
#line 78
  component = file;
#line 80
  p = file + 0;
#line 82
  made_dir = (_Bool)0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    tmp___3 = p;
#line 90
    p ++;
#line 90
    c = *tmp___3;
#line 90
    if (! c) {
#line 90
      goto while_break;
    }
#line 91
    if ((int )*p == 47) {
#line 93
      if (! ((int )c == 47)) {
#line 94
        sep = p;
      }
    } else
#line 96
    if ((int )c == 47) {
#line 96
      if (*p) {
#line 96
        if (sep) {
#line 100
          if (sep - component == 1L) {
#line 100
            if (! ((int )*(component + 0) == 46)) {
#line 100
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 102
            make_dir_errno = 0;
#line 103
            savewd_chdir_options = 0;
#line 108
            *sep = (char )'\000';
#line 112
            if (sep - component == 2L) {
#line 112
              if ((int )*(component + 0) == 46) {
#line 112
                if ((int )*(component + 1) == 46) {
#line 114
                  made_dir = (_Bool)0;
                } else {
#line 112
                  goto _L___0;
                }
              } else {
#line 112
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 116
              tmp = (*make_dir)((char const   *)file, (char const   *)component, make_dir_arg);
              }
              {
#line 118
              if (tmp == -1) {
#line 118
                goto case_neg_1;
              }
#line 122
              if (tmp == 0) {
#line 122
                goto case_0;
              }
#line 125
              if (tmp == 1) {
#line 125
                goto case_1;
              }
#line 116
              goto switch_break;
              case_neg_1: /* CIL Label */ 
              {
#line 119
              tmp___0 = __errno_location();
#line 119
              make_dir_errno = *tmp___0;
              }
#line 120
              goto switch_break;
              case_0: /* CIL Label */ 
#line 123
              savewd_chdir_options |= 2;
              case_1: /* CIL Label */ 
#line 126
              made_dir = (_Bool)1;
#line 127
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
            }
#line 130
            if (made_dir) {
#line 131
              savewd_chdir_options |= 1;
            }
            {
#line 133
            chdir_result = savewd_chdir(wd, (char const   *)component, savewd_chdir_options,
                                        (int *)((void *)0));
            }
#line 138
            if (chdir_result != -1) {
#line 139
              *sep = (char )'/';
            }
#line 141
            if (chdir_result != 0) {
#line 143
              if (make_dir_errno != 0) {
                {
#line 143
                tmp___2 = __errno_location();
                }
#line 143
                if (*tmp___2 == 2) {
                  {
#line 144
                  tmp___1 = __errno_location();
#line 144
                  *tmp___1 = make_dir_errno;
                  }
                }
              }
#line 145
              return ((ptrdiff_t )chdir_result);
            }
          }
#line 149
          component = p;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (component - file);
}
}
#line 19 "/home/khheo/project/benchmark/coreutils-7.1/lib/mgetgroups.h"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 186 "/usr/include/grp.h"
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/mgetgroups.c"
static gid_t *realloc_groupbuf(gid_t *g , size_t num ) 
{ 
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 39
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 39
    tmp___0 = -1;
  } else {
#line 39
    tmp___0 = -2;
  }
#line 39
  if ((size_t )tmp___0 / sizeof(*g) < num) {
    {
#line 41
    tmp = __errno_location();
#line 41
    *tmp = 12;
    }
#line 42
    return ((gid_t *)((void *)0));
  }
  {
#line 45
  tmp___1 = realloc((void *)g, num * sizeof(*g));
  }
#line 45
  return ((gid_t *)tmp___1);
}
}
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/mgetgroups.c"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ 
  int max_n_groups ;
  int ng ;
  gid_t *g ;
  gid_t *h ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int saved_errno___0 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 72
  if (username) {
    {
#line 75
    max_n_groups = 10;
#line 77
    g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
    }
#line 78
    if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 79
      return (-1);
    }
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 86
      ng = getgrouplist(username, gid, g, & max_n_groups);
#line 88
      h = realloc_groupbuf(g, (size_t )max_n_groups);
      }
#line 88
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
#line 90
        tmp = __errno_location();
#line 90
        saved_errno = *tmp;
#line 91
        free((void *)g);
#line 92
        tmp___0 = __errno_location();
#line 92
        *tmp___0 = saved_errno;
        }
#line 93
        return (-1);
      }
#line 95
      g = h;
#line 97
      if (0 <= ng) {
#line 99
        *groups = g;
#line 100
        return (ng);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 107
  if (username) {
    {
#line 107
    tmp___1 = getugroups(0, (gid_t *)((void *)0), username, gid);
#line 107
    max_n_groups = tmp___1;
    }
  } else {
    {
#line 107
    tmp___2 = getgroups(0, (__gid_t *)((void *)0));
#line 107
    max_n_groups = tmp___2;
    }
  }
#line 113
  if (max_n_groups < 0) {
#line 114
    max_n_groups = 5;
  }
  {
#line 116
  g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
  }
#line 117
  if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 118
    return (-1);
  }
#line 120
  if (username) {
    {
#line 120
    tmp___3 = getugroups(max_n_groups, g, username, gid);
#line 120
    ng = tmp___3;
    }
  } else {
    {
#line 120
    tmp___4 = getgroups(max_n_groups, g);
#line 120
    ng = tmp___4;
    }
  }
#line 124
  if (ng < 0) {
    {
#line 126
    tmp___5 = __errno_location();
#line 126
    saved_errno___0 = *tmp___5;
#line 127
    free((void *)g);
#line 128
    tmp___6 = __errno_location();
#line 128
    *tmp___6 = saved_errno___0;
    }
#line 129
    return (-1);
  }
#line 132
  *groups = g;
#line 133
  return (ng);
}
}
#line 146 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/memxfrm.c"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) 
{ 
  size_t di ;
  size_t si ;
  size_t result ;
  char ch ;
  size_t slen ;
  size_t tmp ;
  size_t result0 ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  size_t bufsize___1 ;
  char stackbuf[4000] ;
  char *buf___1 ;
  void *tmp___4 ;
  int *tmp___5 ;

  {
#line 47
  di = (size_t )0;
#line 48
  si = (size_t )0;
#line 49
  result = (size_t )0;
#line 51
  ch = *(src + srcsize);
#line 52
  *(src + srcsize) = (char )'\000';
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (si < srcsize)) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp = strlen((char const   *)(src + si));
#line 56
    slen = tmp;
#line 58
    result0 = result;
#line 59
    tmp___0 = __errno_location();
#line 59
    *tmp___0 = 0;
#line 60
    tmp___1 = strxfrm(dest + di, (char const   */* __restrict  */)(src + si), destsize - di);
#line 60
    result += tmp___1 + 1UL;
#line 61
    tmp___2 = __errno_location();
    }
#line 61
    if (*tmp___2 != 0) {
#line 62
      goto while_break;
    }
#line 63
    if (result <= result0) {
      {
#line 65
      tmp___3 = __errno_location();
#line 65
      *tmp___3 = 34;
      }
#line 66
      goto while_break;
    }
#line 69
    if (result == destsize + 1UL) {
#line 69
      if (si + slen == srcsize) {
#line 74
        bufsize___1 = (destsize - di) + 1UL;
#line 76
        buf___1 = stackbuf;
#line 77
        if (sizeof(stackbuf) < bufsize___1) {
          {
#line 79
          tmp___4 = malloc(bufsize___1);
#line 79
          buf___1 = (char *)tmp___4;
          }
#line 80
          if (! buf___1) {
#line 81
            goto while_break;
          }
        }
        {
#line 83
        strxfrm((char */* __restrict  */)buf___1, (char const   */* __restrict  */)(src + si),
                bufsize___1);
#line 84
        memcpy((void */* __restrict  */)(dest + di), (void const   */* __restrict  */)buf___1,
               destsize - di);
        }
#line 85
        if (sizeof(stackbuf) < bufsize___1) {
          {
#line 86
          free((void *)buf___1);
          }
        }
        {
#line 87
        tmp___5 = __errno_location();
#line 87
        *tmp___5 = 0;
        }
      }
    }
#line 90
    if (result < destsize) {
#line 90
      di = result;
    } else {
#line 90
      di = destsize;
    }
#line 91
    si += slen + 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  *(src + srcsize) = ch;
#line 95
  return (result - (size_t )(si != srcsize));
}
}
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 32 "/home/khheo/project/benchmark/coreutils-7.1/lib/memcoll.c"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ 
  int diff ;
  int *tmp ;
  char n1 ;
  char n2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t size1 ;
  size_t tmp___2 ;
  size_t size2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 43
  if (s1len == s2len) {
    {
#line 43
    tmp___7 = memcmp((void const   *)s1, (void const   *)s2, s1len);
    }
#line 43
    if (tmp___7 == 0) {
      {
#line 45
      tmp = __errno_location();
#line 45
      *tmp = 0;
#line 46
      diff = 0;
      }
    } else {
#line 43
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 50
    n1 = *(s1 + s1len);
#line 51
    n2 = *(s2 + s2len);
#line 53
    tmp___0 = s1len;
#line 53
    s1len ++;
#line 53
    *(s1 + tmp___0) = (char )'\000';
#line 54
    tmp___1 = s2len;
#line 54
    s2len ++;
#line 54
    *(s2 + tmp___1) = (char )'\000';
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      tmp___4 = __errno_location();
#line 56
      *tmp___4 = 0;
#line 56
      diff = strcoll((char const   *)s1, (char const   *)s2);
      }
#line 56
      if (diff) {
#line 56
        tmp___6 = 1;
      } else {
        {
#line 56
        tmp___5 = __errno_location();
        }
#line 56
        if (*tmp___5) {
#line 56
          tmp___6 = 1;
        } else {
#line 56
          tmp___6 = 0;
        }
      }
#line 56
      if (tmp___6) {
#line 56
        goto while_break;
      }
      {
#line 61
      tmp___2 = strlen((char const   *)s1);
#line 61
      size1 = tmp___2 + 1UL;
#line 62
      tmp___3 = strlen((char const   *)s2);
#line 62
      size2 = tmp___3 + 1UL;
#line 63
      s1 += size1;
#line 64
      s2 += size2;
#line 65
      s1len -= size1;
#line 66
      s2len -= size2;
      }
#line 68
      if (s1len == 0UL) {
#line 70
        if (s2len != 0UL) {
#line 71
          diff = -1;
        }
#line 72
        goto while_break;
      } else
#line 74
      if (s2len == 0UL) {
#line 76
        diff = 1;
#line 77
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    *(s1 + (s1len - 1UL)) = n1;
#line 82
    *(s2 + (s2len - 1UL)) = n2;
  }
#line 94
  return (diff);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ 
  unsigned char const   *char_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 53
  c1 = (unsigned char )c1_in;
#line 54
  c2 = (unsigned char )c2_in;
#line 56
  if ((int )c1 == (int )c2) {
    {
#line 57
    tmp = memchr(s, (int )c1, n);
    }
#line 57
    return (tmp);
  }
#line 61
  char_ptr = (unsigned char const   *)s;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (n > 0UL) {
#line 61
      if (! ((size_t )char_ptr % sizeof(longword ) != 0UL)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 64
    if ((int const   )*char_ptr == (int const   )c1) {
#line 65
      return ((void *)char_ptr);
    } else
#line 64
    if ((int const   )*char_ptr == (int const   )c2) {
#line 65
      return ((void *)char_ptr);
    }
#line 61
    n --;
#line 61
    char_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  longword_ptr = (longword const   *)char_ptr;
#line 76
  repeated_one = (longword )16843009;
#line 77
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 78
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 79
  repeated_c1 |= repeated_c1 << 16;
#line 80
  repeated_c2 |= repeated_c2 << 16;
#line 83
  repeated_one |= (repeated_one << 31) << 1;
#line 84
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 85
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 86
  if (8UL < sizeof(longword )) {
#line 90
    i = (size_t )64;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (! (i < sizeof(longword ) * 8UL)) {
#line 90
        goto while_break___0;
      }
#line 92
      repeated_one |= repeated_one << i;
#line 93
      repeated_c1 |= repeated_c1 << i;
#line 94
      repeated_c2 |= repeated_c2 << i;
#line 90
      i *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 135
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 135
    if (! (n >= sizeof(longword ))) {
#line 135
      goto while_break___1;
    }
#line 137
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 138
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 140
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 143
      goto while_break___1;
    }
#line 144
    longword_ptr ++;
#line 145
    n -= sizeof(longword );
  }
  while_break___1: /* CIL Label */ ;
  }
#line 148
  char_ptr = (unsigned char const   *)longword_ptr;
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 157
    if (! (n > 0UL)) {
#line 157
      goto while_break___2;
    }
#line 159
    if ((int const   )*char_ptr == (int const   )c1) {
#line 160
      return ((void *)char_ptr);
    } else
#line 159
    if ((int const   )*char_ptr == (int const   )c2) {
#line 160
      return ((void *)char_ptr);
    }
#line 157
    n --;
#line 157
    char_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 163
  return ((void *)0);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/memcasecmp.h"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) ;
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/memcasecmp.c"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) 
{ 
  size_t i ;
  char const   *s1 ;
  char const   *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  int tmp ;
  int U2 ;
  int tmp___0 ;
  int diff ;

  {
#line 34
  s1 = (char const   *)vs1;
#line 35
  s2 = (char const   *)vs2;
#line 36
  i = (size_t )0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < n)) {
#line 36
      goto while_break;
    }
    {
#line 38
    u1 = (unsigned char )*(s1 + i);
#line 39
    u2 = (unsigned char )*(s2 + i);
#line 40
    tmp = toupper((int )u1);
#line 40
    U1 = tmp;
#line 41
    tmp___0 = toupper((int )u2);
#line 41
    U2 = tmp___0;
#line 42
    diff = U1 - U2;
    }
#line 44
    if (diff) {
#line 45
      return (diff);
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0);
}
}
#line 77 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.h"
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) ;
#line 83
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 90
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 97
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx ,
                                                                                void *resbuf ) ;
#line 103
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx ,
                                                                              void *resbuf ) ;
#line 109
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) md5_stream)(FILE *stream ,
                                                                          void *resblock ) ;
#line 115
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer ,
                                                                            size_t len ,
                                                                            void *resblock ) ;
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
static unsigned char const   fillbuf___2[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 71
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) ;
#line 71 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 74
  ctx->A = (uint32_t )1732584193;
#line 75
  ctx->B = 4023233417U;
#line 76
  ctx->C = 2562383102U;
#line 77
  ctx->D = (uint32_t )271733878;
#line 79
  tmp = (uint32_t )0;
#line 79
  ctx->total[1] = tmp;
#line 79
  ctx->total[0] = tmp;
#line 80
  ctx->buflen = (uint32_t )0;
#line 81
  return;
}
}
#line 94
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx ,
                                                                              void *resbuf ) ;
#line 94 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
  {
#line 97
  r = (char *)resbuf;
#line 98
  set_uint32(r + 0UL, (uint32_t )ctx->A);
#line 99
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
#line 100
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
#line 101
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
  }
#line 103
  return (resbuf);
}
}
#line 108
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx ,
                                                                                void *resbuf ) ;
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 112
  bytes = ctx->buflen;
#line 113
  if (bytes < 56U) {
#line 113
    tmp = 16;
  } else {
#line 113
    tmp = 32;
  }
#line 113
  size = (size_t )tmp;
#line 116
  ctx->total[0] += bytes;
#line 117
  if (ctx->total[0] < bytes) {
#line 118
    (ctx->total[1]) ++;
  }
  {
#line 121
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
#line 122
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 124
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf___2),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 127
  md5_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 129
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 129
  return (tmp___0);
}
}
#line 135
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) md5_stream)(FILE *stream ,
                                                                          void *resblock ) ;
#line 135 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
int ( __attribute__((__leaf__)) md5_stream)(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 143
  md5_init_ctx(& ctx);
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    sum = (size_t )0;
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 157
      n = fread_unlocked((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                         (FILE */* __restrict  */)stream);
#line 159
      sum += n;
      }
#line 161
      if (sum == 4096UL) {
#line 162
        goto while_break___0;
      }
#line 164
      if (n == 0UL) {
        {
#line 169
        tmp = ferror_unlocked(stream);
        }
#line 169
        if (tmp) {
#line 170
          return (1);
        }
#line 171
        goto process_partial_block;
      }
      {
#line 177
      tmp___0 = feof_unlocked(stream);
      }
#line 177
      if (tmp___0) {
#line 178
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 184
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: 
#line 190
  if (sum > 0UL) {
    {
#line 191
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 194
  md5_finish_ctx(& ctx, resblock);
  }
#line 195
  return (0);
}
}
#line 202
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer ,
                                                                            size_t len ,
                                                                            void *resblock ) ;
#line 202 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer , size_t len ,
                                              void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 208
  md5_init_ctx(& ctx);
#line 211
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 214
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 214
  return (tmp);
}
}
#line 218
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 218 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer , size_t len ,
                                                    struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 223
  if (ctx->buflen != 0U) {
#line 225
    left_over = (size_t )ctx->buflen;
#line 226
    if (128UL - left_over > len) {
#line 226
      tmp = len;
    } else {
#line 226
      tmp = 128UL - left_over;
    }
    {
#line 226
    add = tmp;
#line 228
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 229
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
#line 231
    if (ctx->buflen > 64U) {
      {
#line 233
      md5_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
#line 235
      ctx->buflen &= 63U;
#line 237
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 242
    buffer = (void const   *)((char const   *)buffer + add);
#line 243
    len -= add;
  }
#line 247
  if (len >= 64UL) {
#line 252
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290___2 *)0)->x) != 0UL) {
      {
#line 253
      while (1) {
        while_continue: /* CIL Label */ ;
#line 253
        if (! (len > 64UL)) {
#line 253
          goto while_break;
        }
        {
#line 255
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 255
        md5_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 256
        buffer = (void const   *)((char const   *)buffer + 64);
#line 257
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 262
      md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 263
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 264
      len &= 63UL;
      }
    }
  }
#line 269
  if (len > 0UL) {
    {
#line 271
    left_over___0 = (size_t )ctx->buflen;
#line 273
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 274
    left_over___0 += len;
    }
#line 275
    if (left_over___0 >= 64UL) {
      {
#line 277
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 278
      left_over___0 -= 64UL;
#line 279
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 281
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 283
  return;
}
}
#line 298
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 298 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer , size_t len ,
                                                    struct md5_ctx *ctx ) 
{ 
  uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;

  {
#line 302
  words = (uint32_t const   *)buffer;
#line 303
  nwords = len / sizeof(uint32_t );
#line 304
  endp = words + nwords;
#line 305
  A = ctx->A;
#line 306
  B = ctx->B;
#line 307
  C = ctx->C;
#line 308
  D = ctx->D;
#line 313
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 314
  if ((size_t )ctx->total[0] < len) {
#line 315
    (ctx->total[1]) ++;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 319
      goto while_break;
    }
#line 321
    cwp = correct_words;
#line 322
    A_save = A;
#line 323
    B_save = B;
#line 324
    C_save = C;
#line 325
    D_save = D;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      tmp = cwp;
#line 359
      cwp ++;
#line 359
      tmp___0 = (uint32_t )*words;
#line 359
      *tmp = tmp___0;
#line 359
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 359
      words ++;
#line 359
      A = (A << 7) | (A >> 25);
#line 359
      A += B;
#line 359
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 360
      tmp___1 = cwp;
#line 360
      cwp ++;
#line 360
      tmp___2 = (uint32_t )*words;
#line 360
      *tmp___1 = tmp___2;
#line 360
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 360
      words ++;
#line 360
      D = (D << 12) | (D >> 20);
#line 360
      D += A;
#line 360
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 361
      tmp___3 = cwp;
#line 361
      cwp ++;
#line 361
      tmp___4 = (uint32_t )*words;
#line 361
      *tmp___3 = tmp___4;
#line 361
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 361
      words ++;
#line 361
      C = (C << 17) | (C >> 15);
#line 361
      C += D;
#line 361
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 362
      tmp___5 = cwp;
#line 362
      cwp ++;
#line 362
      tmp___6 = (uint32_t )*words;
#line 362
      *tmp___5 = tmp___6;
#line 362
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 362
      words ++;
#line 362
      B = (B << 22) | (B >> 10);
#line 362
      B += C;
#line 362
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 363
      tmp___7 = cwp;
#line 363
      cwp ++;
#line 363
      tmp___8 = (uint32_t )*words;
#line 363
      *tmp___7 = tmp___8;
#line 363
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 363
      words ++;
#line 363
      A = (A << 7) | (A >> 25);
#line 363
      A += B;
#line 363
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 364
      tmp___9 = cwp;
#line 364
      cwp ++;
#line 364
      tmp___10 = (uint32_t )*words;
#line 364
      *tmp___9 = tmp___10;
#line 364
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 364
      words ++;
#line 364
      D = (D << 12) | (D >> 20);
#line 364
      D += A;
#line 364
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 365
      tmp___11 = cwp;
#line 365
      cwp ++;
#line 365
      tmp___12 = (uint32_t )*words;
#line 365
      *tmp___11 = tmp___12;
#line 365
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 365
      words ++;
#line 365
      C = (C << 17) | (C >> 15);
#line 365
      C += D;
#line 365
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 366
      tmp___13 = cwp;
#line 366
      cwp ++;
#line 366
      tmp___14 = (uint32_t )*words;
#line 366
      *tmp___13 = tmp___14;
#line 366
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 366
      words ++;
#line 366
      B = (B << 22) | (B >> 10);
#line 366
      B += C;
#line 366
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 367
      tmp___15 = cwp;
#line 367
      cwp ++;
#line 367
      tmp___16 = (uint32_t )*words;
#line 367
      *tmp___15 = tmp___16;
#line 367
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 367
      words ++;
#line 367
      A = (A << 7) | (A >> 25);
#line 367
      A += B;
#line 367
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 368
      tmp___17 = cwp;
#line 368
      cwp ++;
#line 368
      tmp___18 = (uint32_t )*words;
#line 368
      *tmp___17 = tmp___18;
#line 368
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 368
      words ++;
#line 368
      D = (D << 12) | (D >> 20);
#line 368
      D += A;
#line 368
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 369
      tmp___19 = cwp;
#line 369
      cwp ++;
#line 369
      tmp___20 = (uint32_t )*words;
#line 369
      *tmp___19 = tmp___20;
#line 369
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 369
      words ++;
#line 369
      C = (C << 17) | (C >> 15);
#line 369
      C += D;
#line 369
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 370
      tmp___21 = cwp;
#line 370
      cwp ++;
#line 370
      tmp___22 = (uint32_t )*words;
#line 370
      *tmp___21 = tmp___22;
#line 370
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 370
      words ++;
#line 370
      B = (B << 22) | (B >> 10);
#line 370
      B += C;
#line 370
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 371
      tmp___23 = cwp;
#line 371
      cwp ++;
#line 371
      tmp___24 = (uint32_t )*words;
#line 371
      *tmp___23 = tmp___24;
#line 371
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 371
      words ++;
#line 371
      A = (A << 7) | (A >> 25);
#line 371
      A += B;
#line 371
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 372
      tmp___25 = cwp;
#line 372
      cwp ++;
#line 372
      tmp___26 = (uint32_t )*words;
#line 372
      *tmp___25 = tmp___26;
#line 372
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 372
      words ++;
#line 372
      D = (D << 12) | (D >> 20);
#line 372
      D += A;
#line 372
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 373
      tmp___27 = cwp;
#line 373
      cwp ++;
#line 373
      tmp___28 = (uint32_t )*words;
#line 373
      *tmp___27 = tmp___28;
#line 373
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 373
      words ++;
#line 373
      C = (C << 17) | (C >> 15);
#line 373
      C += D;
#line 373
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 374
      tmp___29 = cwp;
#line 374
      cwp ++;
#line 374
      tmp___30 = (uint32_t )*words;
#line 374
      *tmp___29 = tmp___30;
#line 374
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 374
      words ++;
#line 374
      B = (B << 22) | (B >> 10);
#line 374
      B += C;
#line 374
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 390
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 390
      A = (A << 5) | (A >> 27);
#line 390
      A += B;
#line 390
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 391
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 391
      D = (D << 9) | (D >> 23);
#line 391
      D += A;
#line 391
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 392
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 392
      C = (C << 14) | (C >> 18);
#line 392
      C += D;
#line 392
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 393
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 393
      B = (B << 20) | (B >> 12);
#line 393
      B += C;
#line 393
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 394
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 394
      A = (A << 5) | (A >> 27);
#line 394
      A += B;
#line 394
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 395
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 395
      D = (D << 9) | (D >> 23);
#line 395
      D += A;
#line 395
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 396
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 396
      C = (C << 14) | (C >> 18);
#line 396
      C += D;
#line 396
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 397
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 397
      B = (B << 20) | (B >> 12);
#line 397
      B += C;
#line 397
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 398
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 398
      A = (A << 5) | (A >> 27);
#line 398
      A += B;
#line 398
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 399
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 399
      D = (D << 9) | (D >> 23);
#line 399
      D += A;
#line 399
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 400
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 400
      C = (C << 14) | (C >> 18);
#line 400
      C += D;
#line 400
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 401
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 401
      B = (B << 20) | (B >> 12);
#line 401
      B += C;
#line 401
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 402
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 402
      A = (A << 5) | (A >> 27);
#line 402
      A += B;
#line 402
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 403
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 403
      D = (D << 9) | (D >> 23);
#line 403
      D += A;
#line 403
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 404
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 404
      C = (C << 14) | (C >> 18);
#line 404
      C += D;
#line 404
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 405
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 405
      B = (B << 20) | (B >> 12);
#line 405
      B += C;
#line 405
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 408
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 408
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 408
      A = (A << 4) | (A >> 28);
#line 408
      A += B;
#line 408
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 409
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 409
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 409
      D = (D << 11) | (D >> 21);
#line 409
      D += A;
#line 409
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 410
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 410
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 410
      C = (C << 16) | (C >> 16);
#line 410
      C += D;
#line 410
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 411
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 411
      B = (B << 23) | (B >> 9);
#line 411
      B += C;
#line 411
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 412
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 412
      A = (A << 4) | (A >> 28);
#line 412
      A += B;
#line 412
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 413
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 413
      D = (D << 11) | (D >> 21);
#line 413
      D += A;
#line 413
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 414
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 414
      C = (C << 16) | (C >> 16);
#line 414
      C += D;
#line 414
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 415
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 415
      B = (B << 23) | (B >> 9);
#line 415
      B += C;
#line 415
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 416
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 416
      A = (A << 4) | (A >> 28);
#line 416
      A += B;
#line 416
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 417
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 417
      D = (D << 11) | (D >> 21);
#line 417
      D += A;
#line 417
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 418
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 418
      C = (C << 16) | (C >> 16);
#line 418
      C += D;
#line 418
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 419
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 419
      B = (B << 23) | (B >> 9);
#line 419
      B += C;
#line 419
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 420
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 420
      A = (A << 4) | (A >> 28);
#line 420
      A += B;
#line 420
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 421
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 421
      D = (D << 11) | (D >> 21);
#line 421
      D += A;
#line 421
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 422
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 422
      C = (C << 16) | (C >> 16);
#line 422
      C += D;
#line 422
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 423
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 423
      B = (B << 23) | (B >> 9);
#line 423
      B += C;
#line 423
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 426
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 426
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 426
      A = (A << 6) | (A >> 26);
#line 426
      A += B;
#line 426
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 427
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 427
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 427
      D = (D << 10) | (D >> 22);
#line 427
      D += A;
#line 427
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 428
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 428
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 428
      C = (C << 15) | (C >> 17);
#line 428
      C += D;
#line 428
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 429
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 429
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 429
      B = (B << 21) | (B >> 11);
#line 429
      B += C;
#line 429
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 430
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 430
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 430
      A = (A << 6) | (A >> 26);
#line 430
      A += B;
#line 430
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 431
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 431
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 431
      D = (D << 10) | (D >> 22);
#line 431
      D += A;
#line 431
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 432
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 432
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 432
      C = (C << 15) | (C >> 17);
#line 432
      C += D;
#line 432
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 433
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 433
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 433
      B = (B << 21) | (B >> 11);
#line 433
      B += C;
#line 433
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 434
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 434
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 434
      A = (A << 6) | (A >> 26);
#line 434
      A += B;
#line 434
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 435
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 435
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 435
      D = (D << 10) | (D >> 22);
#line 435
      D += A;
#line 435
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 436
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 436
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 436
      C = (C << 15) | (C >> 17);
#line 436
      C += D;
#line 436
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 437
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 437
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 437
      B = (B << 21) | (B >> 11);
#line 437
      B += C;
#line 437
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 438
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 438
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 438
      A = (A << 6) | (A >> 26);
#line 438
      A += B;
#line 438
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 439
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 439
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 439
      D = (D << 10) | (D >> 22);
#line 439
      D += A;
#line 439
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 440
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 440
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 440
      C = (C << 15) | (C >> 17);
#line 440
      C += D;
#line 440
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 441
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 441
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 441
      B = (B << 21) | (B >> 11);
#line 441
      B += C;
#line 441
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 444
    A += A_save;
#line 445
    B += B_save;
#line 446
    C += C_save;
#line 447
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  ctx->A = A;
#line 452
  ctx->B = B;
#line 453
  ctx->C = C;
#line 454
  ctx->D = D;
#line 455
  return;
}
}
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 367 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 47
  tmp = strlen(string);
#line 47
  tmp___0 = mbsnwidth(string, tmp, flags);
  }
#line 47
  return (tmp___0);
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ 
  char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned char c ;
  char const   *tmp___4 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  {
#line 58
  p = string;
#line 59
  plimit = p + nbytes;
#line 62
  width = 0;
#line 63
  tmp___3 = __ctype_get_mb_cur_max();
  }
#line 63
  if (tmp___3 > 1UL) {
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 65
        goto while_break;
      }
      {
#line 87
      if ((int const   )*p == 126) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 125) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 124) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 123) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 122) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 121) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 120) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 119) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 118) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 117) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 116) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 115) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 114) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 113) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 112) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 111) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 110) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 109) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 108) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 107) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 106) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 105) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 104) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 103) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 102) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 101) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 100) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 99) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 98) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 97) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 95) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 94) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 93) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 92) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 91) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 90) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 89) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 88) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 87) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 86) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 85) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 84) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 83) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 82) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 81) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 80) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 79) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 78) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 77) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 76) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 75) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 74) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 73) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 72) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 71) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 70) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 69) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 68) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 67) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 66) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 65) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 63) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 62) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 61) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 60) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 59) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 58) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 57) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 56) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 55) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 54) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 53) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 52) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 51) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 50) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 49) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 48) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 47) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 46) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 45) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 44) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 43) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 42) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 41) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 40) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 39) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 38) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 37) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 35) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 34) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 33) {
#line 87
        goto case_126;
      }
#line 87
      if ((int const   )*p == 32) {
#line 87
        goto case_126;
      }
#line 92
      goto switch_default;
      case_126: /* CIL Label */ 
      case_125: /* CIL Label */ 
      case_124: /* CIL Label */ 
      case_123: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_121: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_119: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_112: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_109: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_107: /* CIL Label */ 
      case_106: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_104: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_93: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_90: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_85: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_80: /* CIL Label */ 
      case_79: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_77: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_74: /* CIL Label */ 
      case_73: /* CIL Label */ 
      case_72: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_63: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_47: /* CIL Label */ 
      case_46: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_42: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_40: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_38: /* CIL Label */ 
      case_37: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_34: /* CIL Label */ 
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 89
      p ++;
#line 90
      width ++;
#line 91
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 96
      memset((void *)(& mbstate), 0, sizeof(mbstate));
      }
      {
#line 97
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 103
        bytes = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                        (size_t )(plimit - p), (mbstate_t */* __restrict  */)(& mbstate));
        }
#line 105
        if (bytes == 0xffffffffffffffffUL) {
#line 108
          if (! (flags & 1)) {
#line 110
            p ++;
#line 111
            width ++;
#line 112
            goto while_break___0;
          } else {
#line 115
            return (-1);
          }
        }
#line 118
        if (bytes == 0xfffffffffffffffeUL) {
#line 121
          if (! (flags & 1)) {
#line 123
            p = plimit;
#line 124
            width ++;
#line 125
            goto while_break___0;
          } else {
#line 128
            return (-1);
          }
        }
#line 131
        if (bytes == 0UL) {
#line 133
          bytes = (size_t )1;
        }
        {
#line 135
        w = wcwidth(wc);
        }
#line 136
        if (w >= 0) {
#line 138
          width += w;
        } else
#line 141
        if (! (flags & 2)) {
          {
#line 142
          tmp___1 = iswcntrl((wint_t )wc);
          }
#line 142
          if (tmp___1) {
#line 142
            tmp___0 = 0;
          } else {
#line 142
            tmp___0 = 1;
          }
#line 142
          width += tmp___0;
        } else {
#line 144
          return (-1);
        }
        {
#line 146
        p += bytes;
#line 97
        tmp___2 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 97
        if (tmp___2) {
#line 97
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 150
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 152
    return (width);
  }
  {
#line 155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 155
      goto while_break___1;
    }
    {
#line 157
    tmp___4 = p;
#line 157
    p ++;
#line 157
    c = (unsigned char )*tmp___4;
#line 159
    tmp___8 = __ctype_b_loc();
    }
#line 159
    if ((int const   )*(*tmp___8 + (int )c) & 16384) {
#line 160
      width ++;
    } else
#line 161
    if (! (flags & 2)) {
      {
#line 162
      tmp___7 = __ctype_b_loc();
      }
#line 162
      if ((int const   )*(*tmp___7 + (int )c) & 2) {
#line 162
        tmp___6 = 0;
      } else {
#line 162
        tmp___6 = 1;
      }
#line 162
      width += tmp___6;
    } else {
#line 164
      return (-1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 166
  return (width);
}
}
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/str-kmp.h"
static _Bool knuth_morris_pratt_unibyte___0(char const   *haystack , char const   *needle ,
                                            char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  size_t *table ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  char const   *rhaystack ;
  char const   *phaystack ;

  {
  {
#line 35
  tmp = strlen(needle);
#line 35
  m = tmp;
  }
#line 38
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 38
    tmp___5 = -1;
  } else {
#line 38
    tmp___5 = -2;
  }
#line 38
  if (m > (size_t )tmp___5 / sizeof(size_t )) {
#line 38
    tmp___4 = (void *)0;
  } else {
#line 38
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 38
      tmp___1 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 38
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 38
      tmp___2 = mmalloca(m * sizeof(size_t ));
#line 38
      tmp___3 = tmp___2;
      }
    }
#line 38
    tmp___4 = tmp___3;
  }
#line 38
  table = (size_t *)tmp___4;
#line 39
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 40
    return ((_Bool)0);
  }
#line 60
  *(table + 1) = (size_t )1;
#line 61
  j = (size_t )0;
#line 63
  i = (size_t )2;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < m)) {
#line 63
      goto while_break;
    }
#line 69
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if ((int )b == (int )((unsigned char )*(needle + j))) {
#line 79
        j ++;
#line 79
        *(table + i) = i - j;
#line 80
        goto while_break___0;
      }
#line 85
      if (j == 0UL) {
#line 88
        *(table + i) = i;
#line 89
        goto while_break___0;
      }
#line 102
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  *resultp = (char const   *)((void *)0);
#line 115
  j___0 = (size_t )0;
#line 116
  rhaystack = haystack;
#line 117
  phaystack = haystack;
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    if (! ((int const   )*phaystack != 0)) {
#line 119
      goto while_break___1;
    }
#line 120
    if ((int )((unsigned char )*(needle + j___0)) == (int )((unsigned char )*phaystack)) {
#line 123
      j___0 ++;
#line 124
      phaystack ++;
#line 125
      if (j___0 == m) {
#line 128
        *resultp = rhaystack;
#line 129
        goto while_break___1;
      }
    } else
#line 132
    if (j___0 > 0UL) {
#line 135
      rhaystack += *(table + j___0);
#line 136
      j___0 -= *(table + j___0);
    } else {
#line 141
      rhaystack ++;
#line 142
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 146
  freea((void *)table);
  }
#line 147
  return ((_Bool)1);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte___0(char const   *haystack , char const   *needle ,
                                              char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 42
  tmp = mbslen(needle);
#line 42
  m = tmp;
  }
#line 47
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 47
    tmp___5 = -1;
  } else {
#line 47
    tmp___5 = -2;
  }
#line 47
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 47
    tmp___4 = (void *)0;
  } else {
#line 47
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 47
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 47
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 47
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 47
      tmp___3 = tmp___2;
      }
    }
#line 47
    tmp___4 = tmp___3;
  }
#line 47
  memory = (char *)tmp___4;
#line 48
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 49
    return ((_Bool)0);
  }
  {
#line 50
  needle_mbchars = (mbchar_t *)memory;
#line 51
  table = (size_t *)(memory + m * sizeof(mbchar_t ));
#line 58
  j = (size_t )0;
#line 59
  iter.cur.ptr = needle;
#line 59
  iter.in_shift = (_Bool)0;
#line 59
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 59
  iter.next_done = (_Bool)0;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    mbuiter_multi_next(& iter);
    }
#line 59
    if (iter.cur.wc_valid) {
#line 59
      if (iter.cur.wc == 0) {
#line 59
        tmp___6 = 0;
      } else {
#line 59
        tmp___6 = 1;
      }
    } else {
#line 59
      tmp___6 = 1;
    }
#line 59
    if (! tmp___6) {
#line 59
      goto while_break;
    }
    {
#line 60
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 59
    iter.cur.ptr += iter.cur.bytes;
#line 59
    iter.next_done = (_Bool)0;
#line 59
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  *(table + 1) = (size_t )1;
#line 83
  j___0 = (size_t )0;
#line 85
  i = (size_t )2;
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (i < m)) {
#line 85
      goto while_break___0;
    }
#line 91
    b = needle_mbchars + (i - 1UL);
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 98
      if (b->wc_valid) {
#line 98
        if ((needle_mbchars + j___0)->wc_valid) {
#line 98
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 98
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 98
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 98
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 98
          if (tmp___7 == 0) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            tmp___8 = 0;
          }
        } else {
#line 98
          tmp___8 = 0;
        }
#line 98
        tmp___9 = tmp___8;
      }
#line 98
      if (tmp___9) {
#line 101
        j___0 ++;
#line 101
        *(table + i) = i - j___0;
#line 102
        goto while_break___1;
      }
#line 107
      if (j___0 == 0UL) {
#line 110
        *(table + i) = i;
#line 111
        goto while_break___1;
      }
#line 124
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 85
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  *resultp = (char const   *)((void *)0);
#line 137
  j___1 = (size_t )0;
#line 138
  rhaystack.cur.ptr = haystack;
#line 138
  rhaystack.in_shift = (_Bool)0;
#line 138
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 138
  rhaystack.next_done = (_Bool)0;
#line 139
  phaystack.cur.ptr = haystack;
#line 139
  phaystack.in_shift = (_Bool)0;
#line 139
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 139
  phaystack.next_done = (_Bool)0;
  }
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 141
    mbuiter_multi_next(& phaystack);
    }
#line 141
    if (phaystack.cur.wc_valid) {
#line 141
      if (phaystack.cur.wc == 0) {
#line 141
        tmp___15 = 0;
      } else {
#line 141
        tmp___15 = 1;
      }
    } else {
#line 141
      tmp___15 = 1;
    }
#line 141
    if (! tmp___15) {
#line 141
      goto while_break___2;
    }
#line 142
    if ((needle_mbchars + j___1)->wc_valid) {
#line 142
      if (phaystack.cur.wc_valid) {
#line 142
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 142
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 142
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 142
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 142
        if (tmp___12 == 0) {
#line 142
          tmp___13 = 1;
        } else {
#line 142
          tmp___13 = 0;
        }
      } else {
#line 142
        tmp___13 = 0;
      }
#line 142
      tmp___14 = tmp___13;
    }
#line 142
    if (tmp___14) {
#line 144
      j___1 ++;
#line 145
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 145
      phaystack.next_done = (_Bool)0;
#line 146
      if (j___1 == m) {
#line 149
        *resultp = rhaystack.cur.ptr;
#line 150
        goto while_break___2;
      }
    } else
#line 153
    if (j___1 > 0UL) {
#line 156
      count = *(table + j___1);
#line 157
      j___1 -= count;
      {
#line 158
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 158
        if (! (count > 0UL)) {
#line 158
          goto while_break___3;
        }
        {
#line 160
        mbuiter_multi_next(& rhaystack);
        }
#line 160
        if (rhaystack.cur.wc_valid) {
#line 160
          if (rhaystack.cur.wc == 0) {
#line 160
            tmp___10 = 0;
          } else {
#line 160
            tmp___10 = 1;
          }
        } else {
#line 160
          tmp___10 = 1;
        }
#line 160
        if (! tmp___10) {
          {
#line 161
          abort();
          }
        }
#line 162
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 162
        rhaystack.next_done = (_Bool)0;
#line 158
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 168
      mbuiter_multi_next(& rhaystack);
      }
#line 168
      if (rhaystack.cur.wc_valid) {
#line 168
        if (rhaystack.cur.wc == 0) {
#line 168
          tmp___11 = 0;
        } else {
#line 168
          tmp___11 = 1;
        }
      } else {
#line 168
        tmp___11 = 1;
      }
#line 168
      if (! tmp___11) {
        {
#line 169
        abort();
        }
      }
#line 170
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 170
      rhaystack.next_done = (_Bool)0;
#line 171
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 171
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 175
  freea((void *)memory);
  }
#line 176
  return ((_Bool)1);
}
}
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/malloca.c"
static void *mmalloca_results___0[257]  ;
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/long-options.c"
static struct option  const  long_options___0[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.c"
static char const   * volatile  charset_aliases___0  ;
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/localcharset.c"
static char const   *get_charset_aliases___0(void) 
{ 
  char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___3 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 116
  cp = (char const   *)charset_aliases___0;
#line 117
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 122
    base = "charset.alias";
#line 127
    tmp = getenv("CHARSETALIASDIR");
#line 127
    dir = (char const   *)tmp;
    }
#line 128
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 129
      dir = "/usr/local/lib";
    } else
#line 128
    if ((int const   )*(dir + 0) == 0) {
#line 129
      dir = "/usr/local/lib";
    }
    {
#line 133
    tmp___0 = strlen(dir);
#line 133
    dir_len___0 = tmp___0;
#line 134
    tmp___1 = strlen(base);
#line 134
    base_len___0 = tmp___1;
    }
#line 135
    if (dir_len___0 > 0UL) {
#line 135
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 135
        tmp___2 = 1;
      } else {
#line 135
        tmp___2 = 0;
      }
    } else {
#line 135
      tmp___2 = 0;
    }
    {
#line 135
    add_slash = tmp___2;
#line 136
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 136
    file_name___3 = (char *)tmp___3;
    }
#line 137
    if ((unsigned long )file_name___3 != (unsigned long )((void *)0)) {
      {
#line 139
      memcpy((void */* __restrict  */)file_name___3, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 140
      if (add_slash) {
#line 141
        *(file_name___3 + dir_len___0) = (char )'/';
      }
      {
#line 142
      memcpy((void */* __restrict  */)((file_name___3 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 146
    if ((unsigned long )file_name___3 == (unsigned long )((void *)0)) {
#line 148
      cp = "";
    } else {
      {
#line 146
      fp = fopen((char const   */* __restrict  */)file_name___3, (char const   */* __restrict  */)"r");
      }
#line 146
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 148
        cp = "";
      } else {
#line 152
        res_ptr = (char *)((void *)0);
#line 153
        res_size = (size_t )0;
        {
#line 155
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 163
          c = getc_unlocked(fp);
          }
#line 164
          if (c == -1) {
#line 165
            goto while_break;
          }
#line 166
          if (c == 10) {
#line 167
            goto __Cont;
          } else
#line 166
          if (c == 32) {
#line 167
            goto __Cont;
          } else
#line 166
          if (c == 9) {
#line 167
            goto __Cont;
          }
#line 168
          if (c == 35) {
            {
#line 171
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 172
              c = getc_unlocked(fp);
              }
#line 171
              if (c == -1) {
#line 171
                goto while_break___0;
              } else
#line 171
              if (c == 10) {
#line 171
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 174
            if (c == -1) {
#line 175
              goto while_break;
            }
#line 176
            goto __Cont;
          }
          {
#line 178
          ungetc(c, fp);
#line 179
          tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                           buf1, buf2);
          }
#line 179
          if (tmp___4 < 2) {
#line 180
            goto while_break;
          }
          {
#line 181
          l1 = strlen((char const   *)(buf1));
#line 182
          l2 = strlen((char const   *)(buf2));
#line 183
          old_res_ptr = res_ptr;
          }
#line 184
          if (res_size == 0UL) {
            {
#line 186
            res_size = ((l1 + 1UL) + l2) + 1UL;
#line 187
            tmp___5 = malloc(res_size + 1UL);
#line 187
            res_ptr = (char *)tmp___5;
            }
          } else {
            {
#line 191
            res_size += ((l1 + 1UL) + l2) + 1UL;
#line 192
            tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 192
            res_ptr = (char *)tmp___6;
            }
          }
#line 194
          if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 197
            res_size = (size_t )0;
#line 198
            if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
              {
#line 199
              free((void *)old_res_ptr);
              }
            }
#line 200
            goto while_break;
          }
          {
#line 202
          strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                 (char const   */* __restrict  */)(buf1));
#line 203
          strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
          }
          __Cont: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 205
        fclose(fp);
        }
#line 206
        if (res_size == 0UL) {
#line 207
          cp = "";
        } else {
#line 210
          *(res_ptr + res_size) = (char )'\000';
#line 211
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 215
    if ((unsigned long )file_name___3 != (unsigned long )((void *)0)) {
      {
#line 216
      free((void *)file_name___3);
      }
    }
#line 309
    charset_aliases___0 = (char const   */* volatile  */)cp;
  }
#line 312
  return (cp);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *user_alist___0  ;
#line 57 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *nouser_alist___0  ;
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *group_alist___0  ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/idcache.c"
static struct userid *nogroup_alist___0  ;
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char const   power_letter___0[9]  = 
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 54 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static long double adjust_value___0(int inexact_style , long double value ) 
{ 
  uintmax_t u ;
  int tmp ;

  {
#line 61
  if (inexact_style != 1) {
#line 61
    if (value < (long double )0xffffffffffffffffUL) {
#line 63
      u = (uintmax_t )value;
#line 64
      if (inexact_style == 0) {
#line 64
        if ((long double )u != value) {
#line 64
          tmp = 1;
        } else {
#line 64
          tmp = 0;
        }
      } else {
#line 64
        tmp = 0;
      }
#line 64
      value = (long double )(u + (uintmax_t )tmp);
    }
  }
#line 67
  return (value);
}
}
#line 79 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char *group_number___0(char *number , size_t numberlen , char const   *grouping ,
                              char const   *thousands_sep___0 ) 
{ 
  register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___1[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  unsigned char g ;

  {
  {
#line 84
  grouplen = 0xffffffffffffffffUL;
#line 85
  tmp = strlen(thousands_sep___0);
#line 85
  thousands_seplen = tmp;
#line 86
  i = numberlen;
#line 92
  memcpy((void */* __restrict  */)(buf___1), (void const   */* __restrict  */)number,
         numberlen);
#line 93
  d = number + numberlen;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    g = (unsigned char )*grouping;
#line 99
    if (g) {
#line 101
      if ((int )g < 127) {
#line 101
        grouplen = (size_t )g;
      } else {
#line 101
        grouplen = i;
      }
#line 102
      grouping ++;
    }
#line 105
    if (i < grouplen) {
#line 106
      grouplen = i;
    }
    {
#line 108
    d -= grouplen;
#line 109
    i -= grouplen;
#line 110
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)(buf___1 + i),
           grouplen);
    }
#line 111
    if (i == 0UL) {
#line 112
      return (d);
    }
    {
#line 114
    d -= thousands_seplen;
#line 115
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)thousands_sep___0,
           thousands_seplen);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 398 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static char const   * const  block_size_args___0[3]  = {      (char const   */* const  */)"human-readable",      (char const   */* const  */)"si",      (char const   */* const  */)0};
#line 399 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static int const   block_size_opts___0[2]  = {      (int const   )176,      (int const   )144};
#line 405 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static uintmax_t default_block_size___0(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 408
  tmp___1 = getenv("POSIXLY_CORRECT");
  }
#line 408
  if (tmp___1) {
#line 408
    tmp___0 = 512;
  } else {
#line 408
    tmp___0 = 1024;
  }
#line 408
  return ((uintmax_t )tmp___0);
}
}
#line 411 "/home/khheo/project/benchmark/coreutils-7.1/lib/human.c"
static strtol_error humblock___0(char const   *spec , uintmax_t *block_size , int *options ) 
{ 
  int i ;
  int opts___0 ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 415
  opts___0 = 0;
#line 417
  if (! spec) {
    {
#line 417
    tmp___1 = getenv("BLOCK_SIZE");
#line 417
    spec = (char const   *)tmp___1;
    }
#line 417
    if (spec) {
#line 417
      goto _L___0;
    } else {
      {
#line 417
      tmp___2 = getenv("BLOCKSIZE");
#line 417
      spec = (char const   *)tmp___2;
      }
#line 417
      if (spec) {
#line 417
        goto _L___0;
      } else {
        {
#line 420
        *block_size = default_block_size___0();
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 423
    if ((int const   )*spec == 39) {
#line 425
      opts___0 |= 4;
#line 426
      spec ++;
    }
    {
#line 429
    tmp___0 = argmatch(spec, block_size_args___0, (char const   *)(block_size_opts___0),
                       sizeof(block_size_opts___0[0]));
#line 429
    i = (int )tmp___0;
    }
#line 429
    if (0 <= i) {
#line 431
      opts___0 |= (int )block_size_opts___0[i];
#line 432
      *block_size = (uintmax_t )1;
    } else {
      {
#line 437
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 437
      e = tmp;
      }
#line 439
      if ((unsigned int )e != 0U) {
#line 441
        *options = 0;
#line 442
        return (e);
      }
      {
#line 444
      while (1) {
        while_continue: /* CIL Label */ ;
#line 444
        if (48 <= (int )*spec) {
#line 444
          if ((int const   )*spec <= 57) {
#line 444
            goto while_break;
          }
        }
#line 445
        if ((unsigned long )spec == (unsigned long )ptr) {
#line 447
          opts___0 |= 128;
#line 448
          if ((int )*(ptr + -1) == 66) {
#line 449
            opts___0 |= 256;
          }
#line 450
          if ((int )*(ptr + -1) != 66) {
#line 451
            opts___0 |= 32;
          } else
#line 450
          if ((int )*(ptr + -2) == 105) {
#line 451
            opts___0 |= 32;
          }
#line 452
          goto while_break;
        }
#line 444
        spec ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 457
  *options = opts___0;
#line 458
  return ((strtol_error )0);
}
}
#line 127 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static struct hash_tuning  const  default_tuning___0  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 433 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static _Bool is_prime___0(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 436
  divisor = (size_t )3;
#line 437
  square = divisor * divisor;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (square < candidate) {
#line 439
      if (! (candidate % divisor)) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
#line 441
    divisor ++;
#line 442
    square += 4UL * divisor;
#line 443
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  if (candidate % divisor) {
#line 446
    tmp = 1;
  } else {
#line 446
    tmp = 0;
  }
#line 446
  return ((_Bool )tmp);
}
}
#line 452 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static size_t next_prime___0(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 456
  if (candidate < 10UL) {
#line 457
    candidate = (size_t )10;
  }
#line 460
  candidate |= 1UL;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 462
    tmp = is_prime___0(candidate);
    }
#line 462
    if (tmp) {
#line 462
      goto while_break;
    }
#line 463
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (candidate);
}
}
#line 480 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static _Bool check_tuning___0(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 483
  tuning = table->tuning;
#line 490
  epsilon = 0.1f;
#line 492
  if (epsilon < (float )tuning->growth_threshold) {
#line 492
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 492
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 492
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 492
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 492
            if (tuning->shrink_factor <= (float const   )1) {
#line 492
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 499
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 501
  table->tuning = & default_tuning___0;
#line 502
  return ((_Bool)0);
}
}
#line 703 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static struct hash_entry *allocate_entry___0(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 708
  if (table->free_entry_list) {
#line 710
    new = table->free_entry_list;
#line 711
    table->free_entry_list = new->next;
  } else {
    {
#line 718
    tmp = malloc(sizeof(*new));
#line 718
    new = (struct hash_entry *)tmp;
    }
  }
#line 722
  return (new);
}
}
#line 728 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static void free_entry___0(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 731
  entry->data = (void *)0;
#line 732
  entry->next = table->free_entry_list;
#line 733
  table->free_entry_list = entry;
#line 734
  return;
}
}
#line 742 "/home/khheo/project/benchmark/coreutils-7.1/lib/hash.c"
static void *hash_find_entry___0(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                                 _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 746
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 746
  bucket = table->bucket + tmp;
  }
#line 750
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 751
    abort();
    }
  }
#line 753
  *bucket_head = bucket;
#line 756
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 757
    return ((void *)0);
  }
  {
#line 760
  tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
  }
#line 760
  if (tmp___0) {
#line 762
    data = bucket->data;
#line 764
    if (delete) {
#line 766
      if (bucket->next) {
        {
#line 768
        next = bucket->next;
#line 772
        *bucket = *next;
#line 773
        free_entry___0(table, next);
        }
      } else {
#line 777
        bucket->data = (void *)0;
      }
    }
#line 781
    return (data);
  }
#line 785
  cursor = bucket;
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! cursor->next) {
#line 785
      goto while_break;
    }
    {
#line 787
    tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
    }
#line 787
    if (tmp___1) {
#line 789
      data___0 = (cursor->next)->data;
#line 791
      if (delete) {
        {
#line 793
        next___0 = cursor->next;
#line 797
        cursor->next = next___0->next;
#line 798
        free_entry___0(table, next___0);
        }
      }
#line 801
      return (data___0);
    }
#line 785
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  return ((void *)0);
}
}
#line 78 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static void call_fclose___0(void *arg ) 
{ 


  {
#line 81
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 82
    fclose((FILE *)arg);
    }
  }
#line 83
  return;
}
}
#line 92 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static char *buf___0  ;
#line 93 "/home/khheo/project/benchmark/coreutils-7.1/lib/getpass.c"
static size_t bufsize___0  ;
#line 206 "getdate.y"
static int yylex___0(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 207
static int yyerror___0(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 208
static long time_zone_hhmm___0(parser_control *pc , textint s , long mm ) ;
#line 213 "getdate.y"
static void digits_to_date_time___0(parser_control *pc , textint text_int ) 
{ 


  {
#line 216
  if (pc->dates_seen) {
#line 216
    if (! pc->year.digits) {
#line 216
      if (! pc->rels_seen) {
#line 216
        if (pc->times_seen) {
#line 218
          pc->year = text_int;
        } else
#line 216
        if (2UL < text_int.digits) {
#line 218
          pc->year = text_int;
        } else {
#line 216
          goto _L___1;
        }
      } else {
#line 216
        goto _L___1;
      }
    } else {
#line 216
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 221
  if (4UL < text_int.digits) {
#line 223
    (pc->dates_seen) ++;
#line 224
    pc->day = text_int.value % 100L;
#line 225
    pc->month = (text_int.value / 100L) % 100L;
#line 226
    pc->year.value = text_int.value / 10000L;
#line 227
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 231
    (pc->times_seen) ++;
#line 232
    if (text_int.digits <= 2UL) {
#line 234
      pc->hour = text_int.value;
#line 235
      pc->minutes = 0L;
    } else {
#line 239
      pc->hour = text_int.value / 100L;
#line 240
      pc->minutes = text_int.value % 100L;
    }
#line 242
    pc->seconds.tv_sec = (__time_t )0;
#line 243
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 244
    pc->meridian = 2;
  }
#line 247
  return;
}
}
#line 250 "getdate.y"
static void apply_relative_time___0(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 253
  pc->rel.ns += (long )factor * rel.ns;
#line 254
  pc->rel.seconds += (long )factor * rel.seconds;
#line 255
  pc->rel.minutes += (long )factor * rel.minutes;
#line 256
  pc->rel.hour += (long )factor * rel.hour;
#line 257
  pc->rel.day += (long )factor * rel.day;
#line 258
  pc->rel.month += (long )factor * rel.month;
#line 259
  pc->rel.year += (long )factor * rel.year;
#line 260
  pc->rels_seen = (_Bool)1;
#line 261
  return;
}
}
#line 264 "getdate.y"
static void set_hhmmss___0(parser_control *pc , long hour , long minutes , time_t sec ,
                           long nsec ) 
{ 


  {
#line 268
  pc->hour = hour;
#line 269
  pc->minutes = minutes;
#line 270
  pc->seconds.tv_sec = sec;
#line 271
  pc->seconds.tv_nsec = nsec;
#line 272
  return;
}
}
#line 683 "getdate.c"
static yytype_uint8 const   yytranslate___0[278]  = 
#line 683 "getdate.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 804 "getdate.c"
static yytype_uint8 const   yyr1___0[83]  = 
#line 804
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47};
#line 818 "getdate.c"
static yytype_uint8 const   yyr2___0[83]  = 
#line 818
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 834 "getdate.c"
static yytype_uint8 const   yydefact___0[100]  = 
#line 834
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )74,      (yytype_uint8 const   )76,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )45,      (yytype_uint8 const   )48,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )62,      (yytype_uint8 const   )51,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )41,      (yytype_uint8 const   )63,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )28,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )43,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )26,      (yytype_uint8 const   )79,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )66,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )34,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )79,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19};
#line 849 "getdate.c"
static yytype_int8 const   yydefgoto___0[21]  = 
#line 849
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33, 
        (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37, 
        (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )40,      (yytype_int8 const   )41,      (yytype_int8 const   )81, 
        (yytype_int8 const   )92};
#line 859 "getdate.c"
static yytype_int8 const   yypact___0[100]  = 
#line 859
  {      (yytype_int8 const   )-17,      (yytype_int8 const   )56,      (yytype_int8 const   )15,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )26,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-82,      (yytype_int8 const   )68,      (yytype_int8 const   )10, 
        (yytype_int8 const   )50,      (yytype_int8 const   )9,      (yytype_int8 const   )59,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )72,      (yytype_int8 const   )73,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )80,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )65,      (yytype_int8 const   )61,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )17,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )60,      (yytype_int8 const   )44, 
        (yytype_int8 const   )67,      (yytype_int8 const   )69,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-7,      (yytype_int8 const   )62,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )75,      (yytype_int8 const   )-82,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82};
#line 874 "getdate.c"
static yytype_int8 const   yypgoto___0[21]  = 
#line 874
  {      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-6,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-81, 
        (yytype_int8 const   )-3};
#line 886 "getdate.c"
static yytype_uint8 const   yytable___0[99]  = 
#line 886
  {      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )1,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )94,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )91,      (yytype_uint8 const   )6,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )73,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )42,      (yytype_uint8 const   )52,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )89,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )74,      (yytype_uint8 const   )97,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )95,      (yytype_uint8 const   )79,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )80};
#line 900 "getdate.c"
static yytype_int8 const   yycheck___0[99]  = 
#line 900
  {      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )23,      (yytype_int8 const   )12, 
        (yytype_int8 const   )15,      (yytype_int8 const   )90,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )19,      (yytype_int8 const   )4,      (yytype_int8 const   )19,      (yytype_int8 const   )0, 
        (yytype_int8 const   )97,      (yytype_int8 const   )24,      (yytype_int8 const   )20,      (yytype_int8 const   )24, 
        (yytype_int8 const   )22,      (yytype_int8 const   )26,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )24,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )12,      (yytype_int8 const   )19, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )15,      (yytype_int8 const   )25, 
        (yytype_int8 const   )4,      (yytype_int8 const   )27,      (yytype_int8 const   )19,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )3, 
        (yytype_int8 const   )19,      (yytype_int8 const   )91,      (yytype_int8 const   )25,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )20, 
        (yytype_int8 const   )95,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )24};
#line 916 "getdate.c"
static yytype_uint8 const   yystos___0[100]  = 
#line 916
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )25,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )39,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )46,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )26,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )19,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46};
#line 1424 "getdate.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ,
                           parser_control *pc ) 
{ 


  {
#line 1438
  if (! yymsg) {
#line 1439
    yymsg = "Deleting";
  }
  {
#line 1445
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1446
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 618 "getdate.y"
static table const   meridian_table___0[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 627 "getdate.y"
static table const   dst_table___0[1]  = {      {"DST", 259, 0}};
#line 632 "getdate.y"
static table const   month_and_day_table___0[25]  = 
#line 632
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 661 "getdate.y"
static table const   time_units_table___0[11]  = 
#line 661
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 677 "getdate.y"
static table const   relative_time_table___0[20]  = 
#line 677
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 705 "getdate.y"
static table const   universal_time_zone_table___0[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 718 "getdate.y"
static table const   time_zone_table___0[48]  = 
#line 718
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 771 "getdate.y"
static table const   military_table___0[26]  = 
#line 771
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 273, 420}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 810 "getdate.y"
static long time_zone_hhmm___0(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 817
  if (s.digits <= 2UL) {
#line 817
    if (mm < 0L) {
#line 818
      s.value *= 100L;
    }
  }
#line 820
  if (mm < 0L) {
#line 821
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 823
    if (s.negative) {
#line 823
      tmp = - mm;
    } else {
#line 823
      tmp = mm;
    }
#line 823
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 828
  tmp___0 = abs((int )n_minutes);
  }
#line 828
  if (1440 < tmp___0) {
#line 829
    (pc->zones_seen) ++;
  }
#line 831
  return (n_minutes);
}
}
#line 834 "getdate.y"
static int to_hour___0(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 842
  if (meridian == 0) {
#line 842
    goto case_0;
  }
#line 844
  if (meridian == 1) {
#line 844
    goto case_1;
  }
#line 839
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 841
  if (0L <= hours) {
#line 841
    if (hours < 24L) {
#line 841
      tmp = hours;
    } else {
#line 841
      tmp = -1L;
    }
  } else {
#line 841
    tmp = -1L;
  }
#line 841
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 843
  if (0L < hours) {
#line 843
    if (hours < 12L) {
#line 843
      tmp___1 = hours;
    } else {
#line 843
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 843
    if (hours == 12L) {
#line 843
      tmp___0 = 0;
    } else {
#line 843
      tmp___0 = -1;
    }
#line 843
    tmp___1 = (long )tmp___0;
  }
#line 843
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 845
  if (0L < hours) {
#line 845
    if (hours < 12L) {
#line 845
      tmp___3 = hours + 12L;
    } else {
#line 845
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 845
    if (hours == 12L) {
#line 845
      tmp___2 = 12;
    } else {
#line 845
      tmp___2 = -1;
    }
#line 845
    tmp___3 = (long )tmp___2;
  }
#line 845
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 849 "getdate.y"
static long to_year___0(textint textyear ) 
{ 
  long year___1 ;
  int tmp ;

  {
#line 852
  year___1 = textyear.value;
#line 854
  if (year___1 < 0L) {
#line 855
    year___1 = - year___1;
  } else
#line 859
  if (textyear.digits == 2UL) {
#line 860
    if (year___1 < 69L) {
#line 860
      tmp = 2000;
    } else {
#line 860
      tmp = 1900;
    }
#line 860
    year___1 += (long )tmp;
  }
#line 862
  return (year___1);
}
}
#line 865 "getdate.y"
static table const   *lookup_zone___0(parser_control const   *pc , char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 870
  tp = universal_time_zone_table___0;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! tp->name) {
#line 870
      goto while_break;
    }
    {
#line 871
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 871
    if (tmp == 0) {
#line 872
      return (tp);
    }
#line 870
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 876
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 876
    if (! tp->name) {
#line 876
      goto while_break___0;
    }
    {
#line 877
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 877
    if (tmp___0 == 0) {
#line 878
      return (tp);
    }
#line 876
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 880
  tp = time_zone_table___0;
  {
#line 880
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 880
    if (! tp->name) {
#line 880
      goto while_break___1;
    }
    {
#line 881
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 881
    if (tmp___1 == 0) {
#line 882
      return (tp);
    }
#line 880
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 884
  return ((table const   *)((void *)0));
}
}
#line 914 "getdate.y"
static table const   *lookup_word___0(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;

  {
#line 925
  p = word;
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! *p) {
#line 925
      goto while_break;
    }
    {
#line 927
    ch = (unsigned char )*p;
#line 928
    tmp = c_toupper((int )ch);
#line 928
    *p = (char )tmp;
#line 925
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  tp = meridian_table___0;
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 931
    if (! tp->name) {
#line 931
      goto while_break___0;
    }
    {
#line 932
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 932
    if (tmp___0 == 0) {
#line 933
      return (tp);
    }
#line 931
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 936
  wordlen = strlen((char const   *)word);
  }
#line 937
  if (wordlen == 3UL) {
#line 937
    tmp___1 = 1;
  } else
#line 937
  if (wordlen == 4UL) {
#line 937
    if ((int )*(word + 3) == 46) {
#line 937
      tmp___1 = 1;
    } else {
#line 937
      tmp___1 = 0;
    }
  } else {
#line 937
    tmp___1 = 0;
  }
#line 937
  abbrev = (_Bool )tmp___1;
#line 939
  tp = month_and_day_table___0;
  {
#line 939
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 939
    if (! tp->name) {
#line 939
      goto while_break___1;
    }
#line 940
    if (abbrev) {
      {
#line 940
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 940
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 940
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 940
      tmp___4 = tmp___3;
      }
    }
#line 940
    if (tmp___4 == 0) {
#line 941
      return (tp);
    }
#line 939
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 943
  tp = lookup_zone___0(pc, (char const   *)word);
  }
#line 943
  if (tp) {
#line 944
    return (tp);
  }
  {
#line 946
  tmp___5 = strcmp((char const   *)word, (char const   *)dst_table___0[0].name);
  }
#line 946
  if (tmp___5 == 0) {
#line 947
    return (dst_table___0);
  }
#line 949
  tp = time_units_table___0;
  {
#line 949
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 949
    if (! tp->name) {
#line 949
      goto while_break___2;
    }
    {
#line 950
    tmp___6 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 950
    if (tmp___6 == 0) {
#line 951
      return (tp);
    }
#line 949
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 954
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 956
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 957
    tp = time_units_table___0;
    {
#line 957
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 957
      if (! tp->name) {
#line 957
        goto while_break___3;
      }
      {
#line 958
      tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 958
      if (tmp___7 == 0) {
#line 959
        return (tp);
      }
#line 957
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 960
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 963
  tp = relative_time_table___0;
  {
#line 963
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 963
    if (! tp->name) {
#line 963
      goto while_break___4;
    }
    {
#line 964
    tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 964
    if (tmp___8 == 0) {
#line 965
      return (tp);
    }
#line 963
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 968
  if (wordlen == 1UL) {
#line 969
    tp = military_table___0;
    {
#line 969
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 969
      if (! tp->name) {
#line 969
        goto while_break___5;
      }
#line 970
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 971
        return (tp);
      }
#line 969
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 974
  period_found = (_Bool)0;
#line 974
  q = word;
#line 974
  p = q;
  {
#line 974
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 974
    tmp___9 = *q;
#line 974
    *p = tmp___9;
#line 974
    if (! tmp___9) {
#line 974
      goto while_break___6;
    }
#line 975
    if ((int )*q == 46) {
#line 976
      period_found = (_Bool)1;
    } else {
#line 978
      p ++;
    }
#line 974
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 979
  if (period_found) {
    {
#line 979
    tp = lookup_zone___0(pc, (char const   *)word);
    }
#line 979
    if (tp) {
#line 980
      return (tp);
    }
  }
#line 982
  return ((table const   *)((void *)0));
}
}
#line 985 "getdate.y"
static int yylex___0(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 993
      c = (unsigned char )*(pc->input);
#line 993
      tmp = c_isspace((int )c);
      }
#line 993
      if (! tmp) {
#line 993
        goto while_break___0;
      }
#line 994
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    if ((unsigned int )c - 48U <= 9U) {
#line 996
      goto _L___2;
    } else
#line 996
    if ((int )c == 45) {
#line 996
      goto _L___2;
    } else
#line 996
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1001
      if ((int )c == 45) {
#line 1001
        goto _L;
      } else
#line 1001
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1003
        if ((int )c == 45) {
#line 1003
          sign = -1;
        } else {
#line 1003
          sign = 1;
        }
        {
#line 1004
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1004
          (pc->input) ++;
#line 1004
          c = (unsigned char )*(pc->input);
#line 1004
          tmp___0 = c_isspace((int )c);
          }
#line 1004
          if (! tmp___0) {
#line 1004
            goto while_break___1;
          }
#line 1005
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1006
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1008
          goto __Cont;
        }
      } else {
#line 1011
        sign = 0;
      }
#line 1012
      p = pc->input;
#line 1013
      value = 0UL;
      {
#line 1013
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1015
        value1 = value + (unsigned long )((int )c - 48);
#line 1016
        if (value1 < value) {
#line 1017
          return ('?');
        }
#line 1018
        value = value1;
#line 1019
        p ++;
#line 1019
        c = (unsigned char )*p;
#line 1020
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1021
          goto while_break___2;
        }
#line 1022
        if (1844674407370955161UL < value) {
#line 1023
          return ('?');
        }
#line 1013
        value *= 10UL;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1025
      if ((int )c == 46) {
#line 1025
        goto _L___1;
      } else
#line 1025
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1025
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1033
          if (sign < 0) {
#line 1035
            s = (time_t )(- value);
#line 1036
            if (0L < s) {
#line 1037
              return ('?');
            }
#line 1038
            value1___0 = (unsigned long )(- s);
          } else {
#line 1042
            s = (time_t )value;
#line 1043
            if (s < 0L) {
#line 1044
              return ('?');
            }
#line 1045
            value1___0 = (unsigned long )s;
          }
#line 1047
          if (value != value1___0) {
#line 1048
            return ('?');
          }
#line 1051
          p ++;
#line 1052
          tmp___1 = p;
#line 1052
          p ++;
#line 1052
          ns = (int )((int const   )*tmp___1 - 48);
#line 1053
          digits = 2;
          {
#line 1053
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1053
            if (! (digits <= 9)) {
#line 1053
              goto while_break___3;
            }
#line 1055
            ns *= 10;
#line 1056
            if ((unsigned int )*p - 48U <= 9U) {
#line 1057
              tmp___2 = p;
#line 1057
              p ++;
#line 1057
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1053
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1061
          if (sign < 0) {
            {
#line 1062
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1062
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1062
                goto while_break___4;
              }
#line 1063
              if ((int const   )*p != 48) {
#line 1065
                ns ++;
#line 1066
                goto while_break___4;
              }
#line 1062
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1068
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1068
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1068
              goto while_break___5;
            }
#line 1069
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1074
          if (sign < 0) {
#line 1074
            if (ns) {
#line 1076
              s --;
#line 1077
              if (! (s < 0L)) {
#line 1078
                return ('?');
              }
#line 1079
              ns = 1000000000 - ns;
            }
          }
#line 1082
          lvalp->timespec.tv_sec = s;
#line 1083
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1084
          pc->input = p;
#line 1085
          if (sign) {
#line 1085
            tmp___3 = 276;
          } else {
#line 1085
            tmp___3 = 277;
          }
#line 1085
          return (tmp___3);
        } else {
#line 1025
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1089
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1090
        if (sign < 0) {
#line 1092
          lvalp->textintval.value = (long )(- value);
#line 1093
          if (0L < lvalp->textintval.value) {
#line 1094
            return ('?');
          }
        } else {
#line 1098
          lvalp->textintval.value = (long )value;
#line 1099
          if (lvalp->textintval.value < 0L) {
#line 1100
            return ('?');
          }
        }
#line 1102
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1103
        pc->input = p;
#line 1104
        if (sign) {
#line 1104
          tmp___4 = 274;
        } else {
#line 1104
          tmp___4 = 275;
        }
#line 1104
        return (tmp___4);
      }
    }
    {
#line 1108
    tmp___7 = c_isalpha((int )c);
    }
#line 1108
    if (tmp___7) {
#line 1111
      p___0 = buff;
      {
#line 1114
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1116
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1117
          tmp___5 = p___0;
#line 1117
          p___0 ++;
#line 1117
          *tmp___5 = (char )c;
        }
        {
#line 1118
        (pc->input) ++;
#line 1118
        c = (unsigned char )*(pc->input);
#line 1114
        tmp___6 = c_isalpha((int )c);
        }
#line 1114
        if (! tmp___6) {
#line 1114
          if (! ((int )c == 46)) {
#line 1114
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1122
      *p___0 = (char )'\000';
#line 1123
      tp = lookup_word___0((parser_control const   *)pc, buff);
      }
#line 1124
      if (! tp) {
#line 1125
        return ('?');
      }
#line 1126
      lvalp->intval = (long )tp->value;
#line 1127
      return ((int )tp->type);
    }
#line 1130
    if ((int )c != 40) {
#line 1131
      tmp___8 = pc->input;
#line 1131
      (pc->input) ++;
#line 1131
      return ((int )*tmp___8);
    }
#line 1132
    count = (size_t )0;
    {
#line 1133
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1135
      tmp___9 = pc->input;
#line 1135
      (pc->input) ++;
#line 1135
      c = (unsigned char )*tmp___9;
#line 1136
      if ((int )c == 0) {
#line 1137
        return ((int )c);
      }
#line 1138
      if ((int )c == 40) {
#line 1139
        count ++;
      } else
#line 1140
      if ((int )c == 41) {
#line 1141
        count --;
      }
#line 1133
      if (! (count != 0UL)) {
#line 1133
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1148 "getdate.y"
static int yyerror___0(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1152
  return (0);
}
}
#line 1159 "getdate.y"
static _Bool mktime_ok___0(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1162
  if (t == -1L) {
    {
#line 1167
    tmp = localtime((time_t const   *)(& t));
#line 1167
    tm1 = (struct tm  const  *)tmp;
    }
#line 1168
    if (! tm1) {
#line 1169
      return ((_Bool)0);
    }
  }
#line 1172
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1186 "getdate.y"
static char *get_tz___0(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1189
  tmp = getenv("TZ");
#line 1189
  tz = tmp;
  }
#line 1190
  if (tz) {
    {
#line 1192
    tmp___0 = strlen((char const   *)tz);
#line 1192
    tzsize = tmp___0 + 1UL;
    }
#line 1193
    if (tzsize <= 100UL) {
      {
#line 1193
      tmp___1 = memcpy((void */* __restrict  */)tzbuf, (void const   */* __restrict  */)tz,
                       tzsize);
#line 1193
      tz = (char *)tmp___1;
      }
    } else {
      {
#line 1193
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1193
      tz = (char *)tmp___2;
      }
    }
  }
#line 1197
  return (tz);
}
}
#line 202 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) ;
#line 203
static FTSENT *fts_build___0(FTS *sp , int type ) ;
#line 204
static void fts_lfree___0(FTSENT *head ) ;
#line 205
static void fts_load___0(FTS *sp , FTSENT *p ) ;
#line 206
static size_t fts_maxarglen___0(char * const  *argv ) ;
#line 207
static void fts_padjust___0(FTS *sp , FTSENT *head ) ;
#line 208
static _Bool fts_palloc___0(FTS *sp , size_t more ) ;
#line 209
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 210
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 211
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool AD_compare___0(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static size_t AD_hash___0(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool setup_dir___0(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
    {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash___0, & AD_compare___0, (void (*)(void * ))(& free));
    }
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
    {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    }
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
    {
#line 65
    cycle_check_init(fts->fts_cycle.state);
    }
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static _Bool enter_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
    {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
    }
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
    {
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
    }
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      {
#line 96
      free((void *)ad);
      }
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
    {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    }
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static void leave_dir___0(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
    {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    }
#line 135
    if (! found) {
      {
#line 136
      abort();
      }
    }
    {
#line 137
    free(found);
    }
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
        {
#line 143
        while (1) {
          while_continue: /* CIL Label */ ;
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            {
#line 143
            abort();
            }
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts-cycle.c"
static void free_dir___0(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
      {
#line 156
      hash_free(sp->fts_cycle.ht);
      }
    }
  } else {
    {
#line 159
    free((void *)sp->fts_cycle.state);
    }
  }
#line 160
  return;
}
}
#line 283 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fd_ring_clear___0(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    }
#line 286
    if (tmp___0) {
#line 286
      goto while_break;
    }
    {
#line 288
    tmp = i_ring_pop(fd_ring);
#line 288
    fd = tmp;
    }
#line 289
    if (0 <= fd) {
      {
#line 290
      close(fd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 297 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_set_stat_required___0(FTSENT *p , _Bool required ) 
{ 


  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((int )p->fts_info == 11)) {
      {
#line 300
      abort();
      }
    }
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (required) {
#line 301
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 301
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 304
  return;
}
}
#line 332 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void cwd_advance_fd___0(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 336
  old = sp->fts_cwd_fd;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (old != fd)) {
#line 337
      if (! (old == -100)) {
        {
#line 337
        abort();
        }
      }
    }
#line 337
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  if (chdir_down_one) {
    {
#line 343
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 343
    prev_fd_in_slot = tmp;
    }
#line 345
    if (0 <= prev_fd_in_slot) {
      {
#line 346
      close(prev_fd_in_slot);
      }
    }
  } else
#line 348
  if (! (sp->fts_options & 4)) {
#line 350
    if (0 <= old) {
      {
#line 351
      close(old);
      }
    }
  }
#line 354
  sp->fts_cwd_fd = fd;
#line 355
  return;
}
}
#line 556 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_load___0(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 570
  tmp = p->fts_namelen;
#line 570
  p->fts_pathlen = tmp;
#line 570
  len = tmp;
#line 571
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 572
  cp = strrchr((char const   *)(p->fts_name), '/');
  }
#line 572
  if (cp) {
#line 572
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      {
#line 573
      cp ++;
#line 573
      len = strlen((char const   *)cp);
#line 574
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 575
      p->fts_namelen = len;
      }
    } else
#line 572
    if (*(cp + 1)) {
      {
#line 573
      cp ++;
#line 573
      len = strlen((char const   *)cp);
#line 574
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 575
      p->fts_namelen = len;
      }
    }
  }
#line 577
  tmp___0 = sp->fts_path;
#line 577
  p->fts_path = tmp___0;
#line 577
  p->fts_accpath = tmp___0;
#line 578
  return;
}
}
#line 655 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 666
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 666
  if (tmp != 0) {
#line 667
    return ((_Bool)1);
  }
  {
#line 674
  if (fs_buf.f_type == 26985L) {
#line 674
    goto case_26985;
  }
#line 674
  if (fs_buf.f_type == 16914836L) {
#line 674
    goto case_26985;
  }
#line 679
  goto switch_default;
  case_26985: /* CIL Label */ 
  case_16914836: /* CIL Label */ 
#line 677
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 680
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 687 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool leaf_optimization_applies___0(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
  {
#line 693
  tmp = fstatfs(dir_fd, & fs_buf);
  }
#line 693
  if (tmp != 0) {
#line 694
    return ((_Bool)0);
  }
  {
#line 703
  if (fs_buf.f_type == 1382369651L) {
#line 703
    goto case_1382369651;
  }
#line 712
  goto switch_default;
  case_1382369651: /* CIL Label */ 
#line 704
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 713
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 736 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static size_t LCO_hash___0(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 739
  ax = (struct LCO_ent  const  *)x;
#line 740
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 743 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool LCO_compare___0(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 746
  ax = (struct LCO_ent  const  *)x;
#line 747
  ay = (struct LCO_ent  const  *)y;
#line 748
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 754 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool link_count_optimize_ok___0(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 757
  sp = (FTS *)p->fts_fts;
#line 758
  h = sp->fts_leaf_optimization_works_ht;
#line 766
  if (! (sp->fts_options & 512)) {
#line 767
    return ((_Bool)0);
  }
#line 770
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 772
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash___0,
                              & LCO_compare___0, (void (*)(void * ))(& free));
#line 772
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 772
    h = tmp___0;
    }
#line 775
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 776
      return ((_Bool)0);
    }
  }
  {
#line 778
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 779
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 779
  ent = (struct LCO_ent *)tmp___1;
  }
#line 780
  if (ent) {
#line 781
    return (ent->opt_ok);
  }
  {
#line 784
  tmp___2 = malloc(sizeof(*t2));
#line 784
  t2 = (struct LCO_ent *)tmp___2;
  }
#line 785
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 786
    return ((_Bool)0);
  }
  {
#line 789
  opt_ok = leaf_optimization_applies___0(sp->fts_cwd_fd);
#line 790
  t2->opt_ok = opt_ok;
#line 791
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 793
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 793
  ent = (struct LCO_ent *)tmp___3;
  }
#line 794
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 797
    free((void *)t2);
    }
#line 798
    return ((_Bool)0);
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      {
#line 800
      abort();
      }
    }
#line 800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  return (opt_ok);
}
}
#line 1161 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_compare_ino___0(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1164
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1164
    tmp___0 = -1;
  } else {
#line 1164
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1164
      tmp = 1;
    } else {
#line 1164
      tmp = 0;
    }
#line 1164
    tmp___0 = tmp;
  }
#line 1164
  return (tmp___0);
}
}
#line 1170 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void set_stat_type___0(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
  {
#line 1176
  if (dtype == 6U) {
#line 1176
    goto case_6;
  }
#line 1179
  if (dtype == 2U) {
#line 1179
    goto case_2;
  }
#line 1182
  if (dtype == 4U) {
#line 1182
    goto case_4;
  }
#line 1185
  if (dtype == 1U) {
#line 1185
    goto case_1;
  }
#line 1188
  if (dtype == 10U) {
#line 1188
    goto case_10;
  }
#line 1191
  if (dtype == 8U) {
#line 1191
    goto case_8;
  }
#line 1194
  if (dtype == 12U) {
#line 1194
    goto case_12;
  }
#line 1197
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1177
  type = (mode_t )24576;
#line 1178
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1180
  type = (mode_t )8192;
#line 1181
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1183
  type = (mode_t )16384;
#line 1184
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1186
  type = (mode_t )4096;
#line 1187
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1189
  type = (mode_t )40960;
#line 1190
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1192
  type = (mode_t )32768;
#line 1193
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1195
  type = (mode_t )49152;
#line 1196
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1198
  type = (mode_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 1200
  st->st_mode = type;
#line 1201
  return;
}
}
#line 1217 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_build___0(FTS *sp , int type ) 
{ 
  register struct dirent *dp ;
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *cur ;
  FTSENT *tail ;
  DIR *dirp ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int *tmp ;
  DIR *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int dir_fd ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  _Bool is_dir ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  size_t tmp___10 ;
  _Bool tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  _Bool skip_stat ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
#line 1237
  cur = sp->fts_cur;
#line 1254
  if (! (sp->fts_options & 4)) {
#line 1254
    if (sp->fts_options & 512) {
      {
#line 1254
      tmp___0 = opendirat(sp->fts_cwd_fd, (char const   *)cur->fts_accpath);
#line 1254
      dirp = tmp___0;
      }
    } else {
      {
#line 1254
      tmp___1 = opendir((char const   *)cur->fts_accpath);
#line 1254
      dirp = tmp___1;
      }
    }
  } else {
    {
#line 1254
    tmp___1 = opendir((char const   *)cur->fts_accpath);
#line 1254
    dirp = tmp___1;
    }
  }
#line 1254
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 1255
    if (type == 3) {
      {
#line 1256
      cur->fts_info = (unsigned short)4;
#line 1257
      tmp = __errno_location();
#line 1257
      cur->fts_errno = *tmp;
      }
    }
#line 1259
    return ((FTSENT *)((void *)0));
  }
#line 1264
  if ((int )cur->fts_info == 11) {
    {
#line 1265
    cur->fts_info = fts_stat___0(sp, cur, (_Bool)0);
    }
  }
#line 1272
  if (type == 2) {
#line 1273
    nlinks = (nlink_t )0;
#line 1275
    nostat = (_Bool)0;
  } else
#line 1276
  if (sp->fts_options & 8) {
#line 1276
    if (sp->fts_options & 16) {
#line 1277
      if (sp->fts_options & 32) {
#line 1277
        tmp___2 = 0;
      } else {
#line 1277
        tmp___2 = 2;
      }
#line 1277
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___2;
#line 1279
      nostat = (_Bool)1;
    } else {
#line 1281
      nlinks = (nlink_t )-1;
#line 1282
      nostat = (_Bool)0;
    }
  } else {
#line 1281
    nlinks = (nlink_t )-1;
#line 1282
    nostat = (_Bool)0;
  }
#line 1300
  if (nlinks) {
#line 1300
    goto _L___0;
  } else
#line 1300
  if (type == 3) {
    _L___0: /* CIL Label */ 
    {
#line 1301
    tmp___3 = dirfd(dirp);
#line 1301
    dir_fd = tmp___3;
    }
#line 1302
    if (sp->fts_options & 512) {
#line 1302
      if (0 <= dir_fd) {
        {
#line 1303
        dir_fd = dup_safer(dir_fd);
        }
      }
    }
#line 1304
    if (dir_fd < 0) {
#line 1304
      goto _L;
    } else {
      {
#line 1304
      tmp___5 = fts_safe_changedir___0(sp, cur, dir_fd, (char const   *)((void *)0));
      }
#line 1304
      if (tmp___5) {
        _L: /* CIL Label */ 
#line 1305
        if (nlinks) {
#line 1305
          if (type == 3) {
            {
#line 1306
            tmp___4 = __errno_location();
#line 1306
            cur->fts_errno = *tmp___4;
            }
          }
        }
        {
#line 1307
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1308
        descend = (_Bool)0;
#line 1309
        closedir(dirp);
        }
#line 1310
        if (sp->fts_options & 512) {
#line 1310
          if (0 <= dir_fd) {
            {
#line 1311
            close(dir_fd);
            }
          }
        }
#line 1312
        dirp = (DIR *)((void *)0);
      } else {
#line 1314
        descend = (_Bool)1;
      }
    }
  } else {
#line 1316
    descend = (_Bool)0;
  }
#line 1328
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1328
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1328
    len = cur->fts_pathlen;
  }
#line 1329
  if (sp->fts_options & 4) {
#line 1330
    cp = sp->fts_path + len;
#line 1331
    tmp___6 = cp;
#line 1331
    cp ++;
#line 1331
    *tmp___6 = (char )'/';
  } else {
#line 1334
    cp = (char *)((void *)0);
  }
#line 1336
  len ++;
#line 1337
  maxlen = sp->fts_pathlen - len;
#line 1339
  level = cur->fts_level + 1L;
#line 1342
  doadjust = (_Bool)0;
#line 1343
  tail = (FTSENT *)((void *)0);
#line 1343
  head = tail;
#line 1343
  nitems = (size_t )0;
  {
#line 1343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1343
    if (dirp) {
      {
#line 1343
      dp = readdir(dirp);
      }
#line 1343
      if (! dp) {
#line 1343
        goto while_break;
      }
    } else {
#line 1343
      goto while_break;
    }
#line 1346
    if (! (sp->fts_options & 32)) {
#line 1346
      if ((int )dp->d_name[0] == 46) {
#line 1346
        if (! dp->d_name[1]) {
#line 1347
          goto __Cont;
        } else
#line 1346
        if ((int )dp->d_name[1] == 46) {
#line 1346
          if (! dp->d_name[2]) {
#line 1347
            goto __Cont;
          }
        }
      }
    }
    {
#line 1349
    tmp___7 = strlen((char const   *)(dp->d_name));
#line 1349
    p = fts_alloc___0(sp, (char const   *)(dp->d_name), tmp___7);
    }
#line 1349
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1351
      goto mem1;
    }
    {
#line 1352
    tmp___12 = strlen((char const   *)(dp->d_name));
    }
#line 1352
    if (tmp___12 >= maxlen) {
      {
#line 1354
      oldaddr = (void *)sp->fts_path;
#line 1355
      tmp___10 = strlen((char const   *)(dp->d_name));
#line 1355
      tmp___11 = fts_palloc___0(sp, (tmp___10 + len) + 1UL);
      }
#line 1355
      if (! tmp___11) {
        mem1: 
        {
#line 1361
        tmp___8 = __errno_location();
#line 1361
        saved_errno = *tmp___8;
#line 1362
        free((void *)p);
#line 1363
        fts_lfree___0(head);
#line 1364
        closedir(dirp);
#line 1365
        cur->fts_info = (unsigned short)7;
#line 1366
        sp->fts_options |= 8192;
#line 1367
        tmp___9 = __errno_location();
#line 1367
        *tmp___9 = saved_errno;
        }
#line 1368
        return ((FTSENT *)((void *)0));
      }
#line 1371
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1372
        doadjust = (_Bool)1;
#line 1373
        if (sp->fts_options & 4) {
#line 1374
          cp = sp->fts_path + len;
        }
      }
#line 1376
      maxlen = sp->fts_pathlen - len;
    }
    {
#line 1379
    tmp___13 = strlen((char const   *)(dp->d_name));
#line 1379
    new_len = len + tmp___13;
    }
#line 1380
    if (new_len < len) {
      {
#line 1387
      free((void *)p);
#line 1388
      fts_lfree___0(head);
#line 1389
      closedir(dirp);
#line 1390
      cur->fts_info = (unsigned short)7;
#line 1391
      sp->fts_options |= 8192;
#line 1392
      tmp___14 = __errno_location();
#line 1392
      *tmp___14 = 36;
      }
#line 1393
      return ((FTSENT *)((void *)0));
    }
#line 1395
    p->fts_level = level;
#line 1396
    p->fts_parent = sp->fts_cur;
#line 1397
    p->fts_pathlen = new_len;
#line 1405
    p->fts_statp[0].st_ino = dp->d_ino;
#line 1408
    if (sp->fts_options & 4) {
      {
#line 1409
      p->fts_accpath = p->fts_path;
#line 1410
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
      }
    } else {
#line 1412
      p->fts_accpath = p->fts_name;
    }
#line 1414
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1414
      goto _L___1;
    } else
#line 1414
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1427
      if (sp->fts_options & 16) {
#line 1427
        if (sp->fts_options & 8) {
#line 1427
          if ((int )dp->d_type != 0) {
#line 1427
            if (! ((int )dp->d_type == 4)) {
#line 1427
              tmp___15 = 1;
            } else {
#line 1427
              tmp___15 = 0;
            }
          } else {
#line 1427
            tmp___15 = 0;
          }
        } else {
#line 1427
          tmp___15 = 0;
        }
      } else {
#line 1427
        tmp___15 = 0;
      }
      {
#line 1427
      skip_stat = (_Bool )tmp___15;
#line 1431
      p->fts_info = (unsigned short)11;
#line 1434
      set_stat_type___0(p->fts_statp, (unsigned int )dp->d_type);
#line 1435
      fts_set_stat_required___0(p, (_Bool )(! skip_stat));
      }
#line 1436
      if (sp->fts_options & 16) {
#line 1436
        if ((int )dp->d_type == 4) {
#line 1436
          tmp___16 = 1;
        } else {
#line 1436
          tmp___16 = 0;
        }
      } else {
#line 1436
        tmp___16 = 0;
      }
#line 1436
      is_dir = (_Bool )tmp___16;
    } else {
      {
#line 1439
      p->fts_info = fts_stat___0(sp, p, (_Bool)0);
      }
#line 1440
      if ((int )p->fts_info == 1) {
#line 1440
        tmp___17 = 1;
      } else
#line 1440
      if ((int )p->fts_info == 2) {
#line 1440
        tmp___17 = 1;
      } else
#line 1440
      if ((int )p->fts_info == 5) {
#line 1440
        tmp___17 = 1;
      } else {
#line 1440
        tmp___17 = 0;
      }
#line 1440
      is_dir = (_Bool )tmp___17;
    }
#line 1446
    if (nlinks > 0UL) {
#line 1446
      if (is_dir) {
#line 1447
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1450
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1451
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1452
      tail = p;
#line 1452
      head = tail;
    } else {
#line 1454
      tail->fts_link = p;
#line 1455
      tail = p;
    }
#line 1457
    nitems ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1459
  if (dirp) {
    {
#line 1460
    closedir(dirp);
    }
  }
#line 1466
  if (doadjust) {
    {
#line 1467
    fts_padjust___0(sp, head);
    }
  }
#line 1473
  if (sp->fts_options & 4) {
#line 1474
    if (len == sp->fts_pathlen) {
#line 1475
      cp --;
    } else
#line 1474
    if (nitems == 0UL) {
#line 1475
      cp --;
    }
#line 1476
    *cp = (char )'\000';
  }
#line 1486
  if (descend) {
#line 1486
    if (type == 1) {
#line 1486
      goto _L___2;
    } else
#line 1486
    if (! nitems) {
      _L___2: /* CIL Label */ 
#line 1486
      if (cur->fts_level == 0L) {
        {
#line 1486
        fd_ring_clear___0(& sp->fts_fd_ring);
        }
#line 1486
        if (! (sp->fts_options & 4)) {
#line 1486
          if (sp->fts_options & 512) {
#line 1486
            if (sp->fts_options & 512) {
#line 1486
              tmp___18 = -100;
            } else {
#line 1486
              tmp___18 = sp->fts_rfd;
            }
            {
#line 1486
            cwd_advance_fd___0(sp, tmp___18, (_Bool)1);
#line 1486
            tmp___21 = 0;
            }
          } else {
#line 1486
            if (sp->fts_options & 512) {
#line 1486
              tmp___19 = -100;
            } else {
#line 1486
              tmp___19 = sp->fts_rfd;
            }
            {
#line 1486
            tmp___20 = fchdir(tmp___19);
#line 1486
            tmp___21 = tmp___20;
            }
          }
#line 1486
          if (tmp___21) {
#line 1486
            tmp___22 = 1;
          } else {
#line 1486
            tmp___22 = 0;
          }
        } else {
#line 1486
          tmp___22 = 0;
        }
#line 1486
        tmp___24 = tmp___22;
      } else {
        {
#line 1486
        tmp___23 = fts_safe_changedir___0(sp, cur->fts_parent, -1, "..");
#line 1486
        tmp___24 = tmp___23;
        }
      }
#line 1486
      if (tmp___24) {
        {
#line 1490
        cur->fts_info = (unsigned short)7;
#line 1491
        sp->fts_options |= 8192;
#line 1492
        fts_lfree___0(head);
        }
#line 1493
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1497
  if (! nitems) {
#line 1498
    if (type == 3) {
#line 1499
      cur->fts_info = (unsigned short)6;
    }
    {
#line 1500
    fts_lfree___0(head);
    }
#line 1501
    return ((FTSENT *)((void *)0));
  }
#line 1508
  if (nitems > 10000UL) {
#line 1508
    if (! sp->fts_compar) {
#line 1508
      if (sp->fts_options & 512) {
        {
#line 1508
        tmp___25 = dirent_inode_sort_may_be_useful___0(sp->fts_cwd_fd);
        }
#line 1508
        if (tmp___25) {
          {
#line 1512
          sp->fts_compar = & fts_compare_ino___0;
#line 1513
          head = fts_sort___0(sp, head, nitems);
#line 1514
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
          }
        }
      }
    }
  }
#line 1518
  if (sp->fts_compar) {
#line 1518
    if (nitems > 1UL) {
      {
#line 1519
      head = fts_sort___0(sp, head, nitems);
      }
    }
  }
#line 1520
  return (head);
}
}
#line 1667 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static unsigned short fts_stat___0(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1671
  sbp = p->fts_statp;
#line 1674
  if (p->fts_level == 0L) {
#line 1674
    if (sp->fts_options & 1) {
#line 1675
      follow = (_Bool)1;
    }
  }
#line 1691
  if (sp->fts_options & 2) {
#line 1691
    goto _L;
  } else
#line 1691
  if (follow) {
    _L: /* CIL Label */ 
    {
#line 1692
    tmp___3 = stat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
    }
#line 1692
    if (tmp___3) {
      {
#line 1693
      tmp = __errno_location();
#line 1693
      saved_errno = *tmp;
#line 1694
      tmp___1 = __errno_location();
      }
#line 1694
      if (*tmp___1 == 2) {
        {
#line 1694
        tmp___2 = lstat((char const   */* __restrict  */)p->fts_accpath, (struct stat */* __restrict  */)sbp);
        }
#line 1694
        if (tmp___2 == 0) {
          {
#line 1696
          tmp___0 = __errno_location();
#line 1696
          *tmp___0 = 0;
          }
#line 1697
          return ((unsigned short)13);
        }
      }
#line 1699
      p->fts_errno = saved_errno;
#line 1700
      goto err;
    }
  } else {
    {
#line 1702
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   */* __restrict  */)p->fts_accpath,
                      (struct stat */* __restrict  */)sbp, 256);
    }
#line 1702
    if (tmp___5) {
      {
#line 1704
      tmp___4 = __errno_location();
#line 1704
      p->fts_errno = *tmp___4;
      }
      err: 
      {
#line 1705
      memset((void *)sbp, 0, sizeof(struct stat ));
      }
#line 1706
      return ((unsigned short)10);
    }
  }
#line 1709
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1710
    if (sp->fts_options & 32) {
#line 1710
      tmp___6 = 0;
    } else {
#line 1710
      tmp___6 = 2;
    }
#line 1710
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1712
    if ((int )p->fts_name[0] == 46) {
#line 1712
      if (! p->fts_name[1]) {
#line 1712
        goto _L___0;
      } else
#line 1712
      if ((int )p->fts_name[1] == 46) {
#line 1712
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1714
          if (p->fts_level == 0L) {
#line 1714
            tmp___7 = 1;
          } else {
#line 1714
            tmp___7 = 5;
          }
#line 1714
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1738
    return ((unsigned short)1);
  }
#line 1740
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1741
    return ((unsigned short)12);
  }
#line 1742
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1743
    return ((unsigned short)8);
  }
#line 1744
  return ((unsigned short)3);
}
}
#line 1747 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_compar___0(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  {
#line 1755
  pa = (FTSENT const   **)a;
#line 1756
  pb = (FTSENT const   **)b;
#line 1757
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  }
#line 1757
  return (tmp);
}
}
#line 1760 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_sort___0(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare___0)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1774
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1774
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1774
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1774
      tmp = & fts_compar___0;
    }
  } else {
#line 1774
    tmp = & fts_compar___0;
  }
#line 1774
  compare___0 = tmp;
#line 1787
  if (nitems > sp->fts_nitems) {
#line 1790
    sp->fts_nitems = nitems + 40UL;
#line 1791
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      {
#line 1794
      free((void *)sp->fts_array);
#line 1795
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1796
      sp->fts_nitems = (size_t )0;
      }
#line 1797
      return (head);
    } else {
      {
#line 1791
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1791
      a = (FTSENT **)tmp___0;
      }
#line 1791
      if (! a) {
        {
#line 1794
        free((void *)sp->fts_array);
#line 1795
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1796
        sp->fts_nitems = (size_t )0;
        }
#line 1797
        return (head);
      }
    }
#line 1799
    sp->fts_array = a;
  }
#line 1801
  ap = sp->fts_array;
#line 1801
  p = head;
  {
#line 1801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1801
    if (! p) {
#line 1801
      goto while_break;
    }
#line 1802
    tmp___1 = ap;
#line 1802
    ap ++;
#line 1802
    *tmp___1 = p;
#line 1801
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1803
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare___0);
#line 1804
  ap = sp->fts_array;
#line 1804
  head = *ap;
  }
  {
#line 1804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1804
    nitems --;
#line 1804
    if (! nitems) {
#line 1804
      goto while_break___0;
    }
#line 1805
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1804
    ap ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1806
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1807
  return (head);
}
}
#line 1810 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static FTSENT *fts_alloc___0(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  {
#line 1821
  len = sizeof(FTSENT ) + namelen;
#line 1822
  tmp = malloc(len);
#line 1822
  p = (FTSENT *)tmp;
  }
#line 1822
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1823
    return ((FTSENT *)((void *)0));
  }
  {
#line 1826
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
#line 1827
  p->fts_name[namelen] = (char )'\000';
#line 1829
  p->fts_namelen = namelen;
#line 1830
  p->fts_fts = sp;
#line 1831
  p->fts_path = sp->fts_path;
#line 1832
  p->fts_errno = 0;
#line 1833
  p->fts_flags = (unsigned short)0;
#line 1834
  p->fts_instr = (unsigned short)3;
#line 1835
  p->fts_number = 0L;
#line 1836
  p->fts_pointer = (void *)0;
  }
#line 1837
  return (p);
}
}
#line 1840 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_lfree___0(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
  {
#line 1847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1847
    p = head;
#line 1847
    if (! p) {
#line 1847
      goto while_break;
    }
    {
#line 1848
    head = head->fts_link;
#line 1849
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1851
  return;
}
}
#line 1860 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static _Bool fts_palloc___0(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1865
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1870
  if (new_len < sp->fts_pathlen) {
    {
#line 1871
    free((void *)sp->fts_path);
#line 1872
    sp->fts_path = (char *)((void *)0);
#line 1873
    tmp = __errno_location();
#line 1873
    *tmp = 36;
    }
#line 1874
    return ((_Bool)0);
  }
  {
#line 1876
  sp->fts_pathlen = new_len;
#line 1877
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1877
  p = (char *)tmp___0;
  }
#line 1878
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1879
    free((void *)sp->fts_path);
#line 1880
    sp->fts_path = (char *)((void *)0);
    }
#line 1881
    return ((_Bool)0);
  }
#line 1883
  sp->fts_path = p;
#line 1884
  return ((_Bool)1);
}
}
#line 1891 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static void fts_padjust___0(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 1896
  addr = sp->fts_path;
#line 1906
  p = sp->fts_child;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    if (! p) {
#line 1906
      goto while_break;
    }
    {
#line 1907
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1907
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1907
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1907
      p->fts_path = addr;
#line 1907
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1906
    p = p->fts_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1910
  p = head;
  {
#line 1910
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1910
    if (! (p->fts_level >= 0L)) {
#line 1910
      goto while_break___1;
    }
    {
#line 1911
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1911
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1911
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1911
      p->fts_path = addr;
#line 1911
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1912
    if (p->fts_link) {
#line 1912
      p = p->fts_link;
    } else {
#line 1912
      p = p->fts_parent;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1914
  return;
}
}
#line 1916 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static size_t fts_maxarglen___0(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 1922
  max = (size_t )0;
  {
#line 1922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1922
    if (! *argv) {
#line 1922
      goto while_break;
    }
    {
#line 1923
    len = strlen((char const   *)*argv);
    }
#line 1923
    if (len > max) {
#line 1924
      max = len;
    }
#line 1922
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1925
  return (max + 1UL);
}
}
#line 1937 "/home/khheo/project/benchmark/coreutils-7.1/lib/fts.c"
static int fts_safe_changedir___0(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 1942
  if (dir) {
    {
#line 1942
    tmp = strcmp(dir, "..");
    }
#line 1942
    if (tmp == 0) {
#line 1942
      tmp___0 = 1;
    } else {
#line 1942
      tmp___0 = 0;
    }
  } else {
#line 1942
    tmp___0 = 0;
  }
#line 1942
  is_dotdot = (_Bool )tmp___0;
#line 1949
  if (sp->fts_options & 4) {
#line 1951
    if (sp->fts_options & 512) {
#line 1951
      if (0 <= fd) {
        {
#line 1952
        close(fd);
        }
      }
    }
#line 1953
    return (0);
  }
#line 1956
  if (fd < 0) {
#line 1956
    if (is_dotdot) {
#line 1956
      if (sp->fts_options & 512) {
        {
#line 1963
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        }
#line 1963
        if (! tmp___1) {
          {
#line 1967
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 1968
          is_dotdot = (_Bool)1;
          }
#line 1969
          if (0 <= parent_fd) {
#line 1971
            fd = parent_fd;
#line 1972
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 1977
  newfd = fd;
#line 1978
  if (fd < 0) {
    {
#line 1978
    newfd = diropen((FTS const   *)sp, dir);
    }
#line 1978
    if (newfd < 0) {
#line 1979
      return (-1);
    }
  }
#line 1988
  if (sp->fts_options & 2) {
#line 1988
    goto _L;
  } else
#line 1988
  if (dir) {
    {
#line 1988
    tmp___4 = strcmp(dir, "..");
    }
#line 1988
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      {
#line 1992
      tmp___2 = fstat(newfd, & sb);
      }
#line 1992
      if (tmp___2) {
#line 1994
        ret = -1;
#line 1995
        goto bail;
      }
#line 1997
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        {
#line 2000
        tmp___3 = __errno_location();
#line 2000
        *tmp___3 = 2;
#line 2001
        ret = -1;
        }
#line 2002
        goto bail;
      } else
#line 1997
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        {
#line 2000
        tmp___3 = __errno_location();
#line 2000
        *tmp___3 = 2;
#line 2001
        ret = -1;
        }
#line 2002
        goto bail;
      }
    }
  }
#line 2006
  if (sp->fts_options & 512) {
    {
#line 2008
    cwd_advance_fd___0(sp, newfd, (_Bool )(! is_dotdot));
    }
#line 2009
    return (0);
  }
  {
#line 2012
  ret = fchdir(newfd);
  }
  bail: 
#line 2014
  if (fd < 0) {
    {
#line 2016
    tmp___5 = __errno_location();
#line 2016
    oerrno = *tmp___5;
#line 2017
    close(newfd);
#line 2018
    tmp___6 = __errno_location();
#line 2018
    *tmp___6 = oerrno;
    }
  }
#line 2020
  return (ret);
}
}
#line 282 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static void fwrite_lowcase___0(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    tmp___0 = len;
#line 285
    len --;
#line 285
    if (! (tmp___0 > 0UL)) {
#line 285
      goto while_break;
    }
    {
#line 287
    tmp = tolower((int )((unsigned char )*src));
#line 287
    fputc(tmp, fp);
#line 288
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 292 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static void fwrite_uppcase___0(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    tmp___0 = len;
#line 295
    len --;
#line 295
    if (! (tmp___0 > 0UL)) {
#line 295
      goto while_break;
    }
    {
#line 297
    tmp = toupper((int )((unsigned char )*src));
#line 297
    fputc(tmp, fp);
#line 298
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 406 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static size_t strftime_case____1(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                                 int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___1 ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  size_t _i___25 ;
  size_t _i___26 ;

  {
#line 416
  maxsize = (size_t )-1;
#line 419
  hour12 = (int )tp->tm_hour;
#line 444
  i = (size_t )0;
#line 445
  p = s;
#line 460
  zone = (char const   *)((void *)0);
#line 468
  zone = (char const   *)tp->tm_zone;
#line 486
  if (hour12 > 12) {
#line 487
    hour12 -= 12;
  } else
#line 489
  if (hour12 == 0) {
#line 490
    hour12 = 12;
  }
#line 492
  f = format;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((int const   )*f != 0)) {
#line 492
      goto while_break;
    }
#line 494
    pad = 0;
#line 496
    digits = 0;
#line 510
    width = -1;
#line 511
    to_lowcase = (_Bool)0;
#line 512
    to_uppcase = upcase;
#line 514
    change_case = (_Bool)0;
#line 597
    if ((int const   )*f != 37) {
      {
#line 599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 599
        _n = 1;
#line 599
        _delta = width - _n;
#line 599
        if (_delta > 0) {
#line 599
          tmp = _delta;
        } else {
#line 599
          tmp = 0;
        }
#line 599
        _incr = _n + tmp;
#line 599
        if ((size_t )_incr >= maxsize - i) {
#line 599
          return ((size_t )0);
        }
#line 599
        if (p) {
#line 599
          if (digits == 0) {
#line 599
            if (_delta > 0) {
#line 599
              if (pad == 48) {
                {
#line 599
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 599
                  _i = (size_t )0;
                  {
#line 599
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 599
                    if (! (_i < (size_t )_delta)) {
#line 599
                      goto while_break___2;
                    }
                    {
#line 599
                    fputc('0', p);
#line 599
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 599
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 599
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 599
                  _i___0 = (size_t )0;
                  {
#line 599
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 599
                    if (! (_i___0 < (size_t )_delta)) {
#line 599
                      goto while_break___4;
                    }
                    {
#line 599
                    fputc(' ', p);
#line 599
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 599
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 599
          fputc((int )*f, p);
          }
        }
#line 599
        i += (size_t )_incr;
#line 599
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 600
      goto __Cont;
    }
    {
#line 606
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 608
      f ++;
      {
#line 613
      if ((int const   )*f == 48) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 45) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 95) {
#line 613
        goto case_48;
      }
#line 618
      if ((int const   )*f == 94) {
#line 618
        goto case_94;
      }
#line 621
      if ((int const   )*f == 35) {
#line 621
        goto case_35;
      }
#line 625
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 614
      pad = (int )*f;
#line 615
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 619
      to_uppcase = (_Bool)1;
#line 620
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 622
      change_case = (_Bool)1;
#line 623
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 626
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 628
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 632
    if ((unsigned int )*f - 48U <= 9U) {
#line 634
      width = 0;
      {
#line 635
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 637
        if (width > 214748364) {
#line 640
          width = 2147483647;
        } else
#line 637
        if (width == 214748364) {
#line 637
          if ((int const   )*f - 48 > 7) {
#line 640
            width = 2147483647;
          } else {
#line 643
            width *= 10;
#line 644
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 643
          width *= 10;
#line 644
          width += (int )((int const   )*f - 48);
        }
#line 646
        f ++;
#line 635
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 635
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 655
    if ((int const   )*f == 79) {
#line 655
      goto case_79;
    }
#line 655
    if ((int const   )*f == 69) {
#line 655
      goto case_79;
    }
#line 659
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 656
    tmp___0 = f;
#line 656
    f ++;
#line 656
    modifier = (int )*tmp___0;
#line 657
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 660
    modifier = 0;
#line 661
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 665
    format_char = (int )*f;
    {
#line 688
    if (format_char == 37) {
#line 688
      goto case_37;
    }
#line 694
    if (format_char == 97) {
#line 694
      goto case_97;
    }
#line 709
    if (format_char == 65) {
#line 709
      goto case_65;
    }
#line 725
    if (format_char == 104) {
#line 725
      goto case_104;
    }
#line 725
    if (format_char == 98) {
#line 725
      goto case_104;
    }
#line 740
    if (format_char == 66) {
#line 740
      goto case_66;
    }
#line 755
    if (format_char == 99) {
#line 755
      goto case_99;
    }
#line 814
    if (format_char == 67) {
#line 814
      goto case_67;
    }
#line 843
    if (format_char == 120) {
#line 843
      goto case_120;
    }
#line 856
    if (format_char == 68) {
#line 856
      goto case_68;
    }
#line 862
    if (format_char == 100) {
#line 862
      goto case_100;
    }
#line 868
    if (format_char == 101) {
#line 868
      goto case_101;
    }
#line 994
    if (format_char == 70) {
#line 994
      goto case_70;
    }
#line 1000
    if (format_char == 72) {
#line 1000
      goto case_72;
    }
#line 1006
    if (format_char == 73) {
#line 1006
      goto case_73;
    }
#line 1012
    if (format_char == 107) {
#line 1012
      goto case_107;
    }
#line 1018
    if (format_char == 108) {
#line 1018
      goto case_108;
    }
#line 1024
    if (format_char == 106) {
#line 1024
      goto case_106;
    }
#line 1030
    if (format_char == 77) {
#line 1030
      goto case_77;
    }
#line 1036
    if (format_char == 109) {
#line 1036
      goto case_109;
    }
#line 1043
    if (format_char == 78) {
#line 1043
      goto case_78;
    }
#line 1061
    if (format_char == 110) {
#line 1061
      goto case_110;
    }
#line 1065
    if (format_char == 80) {
#line 1065
      goto case_80;
    }
#line 1072
    if (format_char == 112) {
#line 1072
      goto case_112;
    }
#line 1085
    if (format_char == 82) {
#line 1085
      goto case_82;
    }
#line 1089
    if (format_char == 114) {
#line 1089
      goto case_114;
    }
#line 1100
    if (format_char == 83) {
#line 1100
      goto case_83;
    }
#line 1106
    if (format_char == 115) {
#line 1106
      goto case_115;
    }
#line 1133
    if (format_char == 88) {
#line 1133
      goto case_88;
    }
#line 1146
    if (format_char == 84) {
#line 1146
      goto case_84;
    }
#line 1150
    if (format_char == 116) {
#line 1150
      goto case_116;
    }
#line 1154
    if (format_char == 117) {
#line 1154
      goto case_117;
    }
#line 1157
    if (format_char == 85) {
#line 1157
      goto case_85;
    }
#line 1165
    if (format_char == 71) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 103) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 86) {
#line 1165
      goto case_71;
    }
#line 1221
    if (format_char == 87) {
#line 1221
      goto case_87;
    }
#line 1227
    if (format_char == 119) {
#line 1227
      goto case_119;
    }
#line 1233
    if (format_char == 89) {
#line 1233
      goto case_89;
    }
#line 1257
    if (format_char == 121) {
#line 1257
      goto case_121;
    }
#line 1280
    if (format_char == 90) {
#line 1280
      goto case_90;
    }
#line 1309
    if (format_char == 58) {
#line 1309
      goto case_58;
    }
#line 1319
    if (format_char == 122) {
#line 1319
      goto case_122;
    }
#line 1397
    if (format_char == 0) {
#line 1397
      goto case_0___0;
    }
#line 1400
    goto bad_format;
    case_37: /* CIL Label */ 
#line 689
    if (modifier != 0) {
#line 690
      goto bad_format;
    }
    {
#line 691
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 691
      _n___0 = 1;
#line 691
      _delta___0 = width - _n___0;
#line 691
      if (_delta___0 > 0) {
#line 691
        tmp___1 = _delta___0;
      } else {
#line 691
        tmp___1 = 0;
      }
#line 691
      _incr___0 = _n___0 + tmp___1;
#line 691
      if ((size_t )_incr___0 >= maxsize - i) {
#line 691
        return ((size_t )0);
      }
#line 691
      if (p) {
#line 691
        if (digits == 0) {
#line 691
          if (_delta___0 > 0) {
#line 691
            if (pad == 48) {
              {
#line 691
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 691
                _i___1 = (size_t )0;
                {
#line 691
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 691
                  if (! (_i___1 < (size_t )_delta___0)) {
#line 691
                    goto while_break___9;
                  }
                  {
#line 691
                  fputc('0', p);
#line 691
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 691
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 691
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 691
                _i___2 = (size_t )0;
                {
#line 691
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 691
                  if (! (_i___2 < (size_t )_delta___0)) {
#line 691
                    goto while_break___11;
                  }
                  {
#line 691
                  fputc(' ', p);
#line 691
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 691
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 691
        fputc((int )*f, p);
        }
      }
#line 691
      i += (size_t )_incr___0;
#line 691
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 692
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 695
    if (modifier != 0) {
#line 696
      goto bad_format;
    }
#line 697
    if (change_case) {
#line 699
      to_uppcase = (_Bool)1;
#line 700
      to_lowcase = (_Bool)0;
    }
#line 706
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 710
    if (modifier != 0) {
#line 711
      goto bad_format;
    }
#line 712
    if (change_case) {
#line 714
      to_uppcase = (_Bool)1;
#line 715
      to_lowcase = (_Bool)0;
    }
#line 721
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 731
    if (modifier != 0) {
#line 732
      goto bad_format;
    }
#line 737
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 741
    if (modifier != 0) {
#line 742
      goto bad_format;
    }
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 752
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 756
    if (modifier == 79) {
#line 757
      goto bad_format;
    }
#line 766
    goto underlying_strftime;
    subformat: 
    {
#line 771
    tmp___2 = strftime_case____1(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut,
                                 ns);
#line 771
    len = tmp___2;
    }
    {
#line 775
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 775
      _n___1 = (int )len;
#line 775
      _delta___1 = width - _n___1;
#line 775
      if (_delta___1 > 0) {
#line 775
        tmp___3 = _delta___1;
      } else {
#line 775
        tmp___3 = 0;
      }
#line 775
      _incr___1 = _n___1 + tmp___3;
#line 775
      if ((size_t )_incr___1 >= maxsize - i) {
#line 775
        return ((size_t )0);
      }
#line 775
      if (p) {
#line 775
        if (digits == 0) {
#line 775
          if (_delta___1 > 0) {
#line 775
            if (pad == 48) {
              {
#line 775
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 775
                _i___3 = (size_t )0;
                {
#line 775
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 775
                  if (! (_i___3 < (size_t )_delta___1)) {
#line 775
                    goto while_break___14;
                  }
                  {
#line 775
                  fputc('0', p);
#line 775
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 775
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 775
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 775
                _i___4 = (size_t )0;
                {
#line 775
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 775
                  if (! (_i___4 < (size_t )_delta___1)) {
#line 775
                    goto while_break___16;
                  }
                  {
#line 775
                  fputc(' ', p);
#line 775
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 775
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 775
        strftime_case____1(to_uppcase, p, subfmt, tp, ut, ns);
        }
      }
#line 775
      i += (size_t )_incr___1;
#line 775
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 780
    goto switch_break___1;
    underlying_strftime: 
#line 788
    u = ufmt;
#line 801
    tmp___4 = u;
#line 801
    u ++;
#line 801
    *tmp___4 = (char )' ';
#line 802
    tmp___5 = u;
#line 802
    u ++;
#line 802
    *tmp___5 = (char )'%';
#line 803
    if (modifier != 0) {
#line 804
      tmp___6 = u;
#line 804
      u ++;
#line 804
      *tmp___6 = (char )modifier;
    }
    {
#line 805
    tmp___7 = u;
#line 805
    u ++;
#line 805
    *tmp___7 = (char )format_char;
#line 806
    *u = (char )'\000';
#line 807
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 808
    if (len___0 != 0UL) {
      {
#line 809
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 809
        _n___2 = (int )(len___0 - 1UL);
#line 809
        _delta___2 = width - _n___2;
#line 809
        if (_delta___2 > 0) {
#line 809
          tmp___8 = _delta___2;
        } else {
#line 809
          tmp___8 = 0;
        }
#line 809
        _incr___2 = _n___2 + tmp___8;
#line 809
        if ((size_t )_incr___2 >= maxsize - i) {
#line 809
          return ((size_t )0);
        }
#line 809
        if (p) {
#line 809
          if (digits == 0) {
#line 809
            if (_delta___2 > 0) {
#line 809
              if (pad == 48) {
                {
#line 809
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 809
                  _i___5 = (size_t )0;
                  {
#line 809
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 809
                    if (! (_i___5 < (size_t )_delta___2)) {
#line 809
                      goto while_break___19;
                    }
                    {
#line 809
                    fputc('0', p);
#line 809
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 809
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 809
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 809
                  _i___6 = (size_t )0;
                  {
#line 809
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 809
                    if (! (_i___6 < (size_t )_delta___2)) {
#line 809
                      goto while_break___21;
                    }
                    {
#line 809
                    fputc(' ', p);
#line 809
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 809
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
#line 809
          if (to_lowcase) {
            {
#line 809
            fwrite_lowcase___0(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 809
          if (to_uppcase) {
            {
#line 809
            fwrite_uppcase___0(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 809
            fwrite((void const   */* __restrict  */)(ubuf + 1), (size_t )_n___2, (size_t )1,
                   (FILE */* __restrict  */)p);
            }
          }
        }
#line 809
        i += (size_t )_incr___2;
#line 809
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 811
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 815
    if (modifier == 79) {
#line 816
      goto bad_format;
    }
#line 817
    if (modifier == 69) {
#line 833
      goto underlying_strftime;
    }
#line 838
    century = (int )(tp->tm_year / 100 + 19);
#line 839
    if (tp->tm_year % 100 < 0) {
#line 839
      if (0 < century) {
#line 839
        tmp___9 = 1;
      } else {
#line 839
        tmp___9 = 0;
      }
    } else {
#line 839
      tmp___9 = 0;
    }
#line 839
    century -= tmp___9;
#line 840
    digits = 2;
#line 840
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 840
    u_number_value = (unsigned int )century;
#line 840
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 844
    if (modifier == 79) {
#line 845
      goto bad_format;
    }
#line 854
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 857
    if (modifier != 0) {
#line 858
      goto bad_format;
    }
#line 859
    subfmt = "%m/%d/%y";
#line 860
    goto subformat;
    case_100: /* CIL Label */ 
#line 863
    if (modifier == 69) {
#line 864
      goto bad_format;
    }
#line 866
    digits = 2;
#line 866
    number_value = (int )tp->tm_mday;
#line 866
    goto do_number;
    case_101: /* CIL Label */ 
#line 869
    if (modifier == 69) {
#line 870
      goto bad_format;
    }
#line 872
    digits = 2;
#line 872
    number_value = (int )tp->tm_mday;
#line 872
    goto do_number_spacepad;
    do_tz_offset: 
#line 878
    always_output_a_sign = (_Bool)1;
#line 879
    goto do_number_body;
    do_number_spacepad: 
#line 883
    if (pad != 48) {
#line 883
      if (pad != 45) {
#line 884
        pad = '_';
      }
    }
    do_number: 
#line 888
    negative_number = (_Bool )(number_value < 0);
#line 889
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 892
    always_output_a_sign = (_Bool)0;
#line 893
    tz_colon_mask = 0;
    do_number_body: 
#line 901
    if (modifier == 79) {
#line 901
      if (! negative_number) {
#line 919
        goto underlying_strftime;
      }
    }
#line 923
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 925
    if (negative_number) {
#line 926
      u_number_value = - u_number_value;
    }
    {
#line 928
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 930
      if (tz_colon_mask & 1) {
#line 931
        bufp --;
#line 931
        *bufp = (char )':';
      }
#line 932
      tz_colon_mask >>= 1;
#line 933
      bufp --;
#line 933
      *bufp = (char )(u_number_value % 10U + 48U);
#line 934
      u_number_value /= 10U;
#line 928
      if (! (u_number_value != 0U)) {
#line 928
        if (! (tz_colon_mask != 0)) {
#line 928
          goto while_break___22;
        }
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 939
    if (digits < width) {
#line 940
      digits = width;
    }
#line 942
    if (negative_number) {
#line 942
      sign_char = (char )'-';
    } else {
#line 942
      if (always_output_a_sign) {
#line 942
        tmp___10 = '+';
      } else {
#line 942
        tmp___10 = 0;
      }
#line 942
      sign_char = (char )tmp___10;
    }
#line 946
    if (pad == 45) {
#line 948
      if (sign_char) {
        {
#line 949
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 949
          _n___3 = 1;
#line 949
          _delta___3 = width - _n___3;
#line 949
          if (_delta___3 > 0) {
#line 949
            tmp___11 = _delta___3;
          } else {
#line 949
            tmp___11 = 0;
          }
#line 949
          _incr___3 = _n___3 + tmp___11;
#line 949
          if ((size_t )_incr___3 >= maxsize - i) {
#line 949
            return ((size_t )0);
          }
#line 949
          if (p) {
#line 949
            if (digits == 0) {
#line 949
              if (_delta___3 > 0) {
#line 949
                if (pad == 48) {
                  {
#line 949
                  while (1) {
                    while_continue___24: /* CIL Label */ ;
#line 949
                    _i___7 = (size_t )0;
                    {
#line 949
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 949
                      if (! (_i___7 < (size_t )_delta___3)) {
#line 949
                        goto while_break___25;
                      }
                      {
#line 949
                      fputc('0', p);
#line 949
                      _i___7 ++;
                      }
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 949
                    goto while_break___24;
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                } else {
                  {
#line 949
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 949
                    _i___8 = (size_t )0;
                    {
#line 949
                    while (1) {
                      while_continue___27: /* CIL Label */ ;
#line 949
                      if (! (_i___8 < (size_t )_delta___3)) {
#line 949
                        goto while_break___27;
                      }
                      {
#line 949
                      fputc(' ', p);
#line 949
                      _i___8 ++;
                      }
                    }
                    while_break___27: /* CIL Label */ ;
                    }
#line 949
                    goto while_break___26;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 949
            fputc((int )sign_char, p);
            }
          }
#line 949
          i += (size_t )_incr___3;
#line 949
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    } else {
#line 953
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 956
      if (padding > 0) {
#line 958
        if (pad == 95) {
#line 960
          if ((size_t )padding >= maxsize - i) {
#line 961
            return ((size_t )0);
          }
#line 963
          if (p) {
            {
#line 964
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 964
              _i___9 = (size_t )0;
              {
#line 964
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 964
                if (! (_i___9 < (size_t )padding)) {
#line 964
                  goto while_break___29;
                }
                {
#line 964
                fputc(' ', p);
#line 964
                _i___9 ++;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
#line 964
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 965
          i += (size_t )padding;
#line 966
          if (width > padding) {
#line 966
            width -= padding;
          } else {
#line 966
            width = 0;
          }
#line 967
          if (sign_char) {
            {
#line 968
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 968
              _n___4 = 1;
#line 968
              _delta___4 = width - _n___4;
#line 968
              if (_delta___4 > 0) {
#line 968
                tmp___12 = _delta___4;
              } else {
#line 968
                tmp___12 = 0;
              }
#line 968
              _incr___4 = _n___4 + tmp___12;
#line 968
              if ((size_t )_incr___4 >= maxsize - i) {
#line 968
                return ((size_t )0);
              }
#line 968
              if (p) {
#line 968
                if (digits == 0) {
#line 968
                  if (_delta___4 > 0) {
#line 968
                    if (pad == 48) {
                      {
#line 968
                      while (1) {
                        while_continue___31: /* CIL Label */ ;
#line 968
                        _i___10 = (size_t )0;
                        {
#line 968
                        while (1) {
                          while_continue___32: /* CIL Label */ ;
#line 968
                          if (! (_i___10 < (size_t )_delta___4)) {
#line 968
                            goto while_break___32;
                          }
                          {
#line 968
                          fputc('0', p);
#line 968
                          _i___10 ++;
                          }
                        }
                        while_break___32: /* CIL Label */ ;
                        }
#line 968
                        goto while_break___31;
                      }
                      while_break___31: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 968
                      while (1) {
                        while_continue___33: /* CIL Label */ ;
#line 968
                        _i___11 = (size_t )0;
                        {
#line 968
                        while (1) {
                          while_continue___34: /* CIL Label */ ;
#line 968
                          if (! (_i___11 < (size_t )_delta___4)) {
#line 968
                            goto while_break___34;
                          }
                          {
#line 968
                          fputc(' ', p);
#line 968
                          _i___11 ++;
                          }
                        }
                        while_break___34: /* CIL Label */ ;
                        }
#line 968
                        goto while_break___33;
                      }
                      while_break___33: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 968
                fputc((int )sign_char, p);
                }
              }
#line 968
              i += (size_t )_incr___4;
#line 968
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        } else {
#line 972
          if ((size_t )digits >= maxsize - i) {
#line 973
            return ((size_t )0);
          }
#line 975
          if (sign_char) {
            {
#line 976
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 976
              _n___5 = 1;
#line 976
              _delta___5 = width - _n___5;
#line 976
              if (_delta___5 > 0) {
#line 976
                tmp___13 = _delta___5;
              } else {
#line 976
                tmp___13 = 0;
              }
#line 976
              _incr___5 = _n___5 + tmp___13;
#line 976
              if ((size_t )_incr___5 >= maxsize - i) {
#line 976
                return ((size_t )0);
              }
#line 976
              if (p) {
#line 976
                if (digits == 0) {
#line 976
                  if (_delta___5 > 0) {
#line 976
                    if (pad == 48) {
                      {
#line 976
                      while (1) {
                        while_continue___36: /* CIL Label */ ;
#line 976
                        _i___12 = (size_t )0;
                        {
#line 976
                        while (1) {
                          while_continue___37: /* CIL Label */ ;
#line 976
                          if (! (_i___12 < (size_t )_delta___5)) {
#line 976
                            goto while_break___37;
                          }
                          {
#line 976
                          fputc('0', p);
#line 976
                          _i___12 ++;
                          }
                        }
                        while_break___37: /* CIL Label */ ;
                        }
#line 976
                        goto while_break___36;
                      }
                      while_break___36: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 976
                      while (1) {
                        while_continue___38: /* CIL Label */ ;
#line 976
                        _i___13 = (size_t )0;
                        {
#line 976
                        while (1) {
                          while_continue___39: /* CIL Label */ ;
#line 976
                          if (! (_i___13 < (size_t )_delta___5)) {
#line 976
                            goto while_break___39;
                          }
                          {
#line 976
                          fputc(' ', p);
#line 976
                          _i___13 ++;
                          }
                        }
                        while_break___39: /* CIL Label */ ;
                        }
#line 976
                        goto while_break___38;
                      }
                      while_break___38: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 976
                fputc((int )sign_char, p);
                }
              }
#line 976
              i += (size_t )_incr___5;
#line 976
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
          }
#line 978
          if (p) {
            {
#line 979
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 979
              _i___14 = (size_t )0;
              {
#line 979
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 979
                if (! (_i___14 < (size_t )padding)) {
#line 979
                  goto while_break___41;
                }
                {
#line 979
                fputc('0', p);
#line 979
                _i___14 ++;
                }
              }
              while_break___41: /* CIL Label */ ;
              }
#line 979
              goto while_break___40;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
#line 980
          i += (size_t )padding;
#line 981
          width = 0;
        }
      } else
#line 986
      if (sign_char) {
        {
#line 987
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 987
          _n___6 = 1;
#line 987
          _delta___6 = width - _n___6;
#line 987
          if (_delta___6 > 0) {
#line 987
            tmp___14 = _delta___6;
          } else {
#line 987
            tmp___14 = 0;
          }
#line 987
          _incr___6 = _n___6 + tmp___14;
#line 987
          if ((size_t )_incr___6 >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 987
          if (p) {
#line 987
            if (digits == 0) {
#line 987
              if (_delta___6 > 0) {
#line 987
                if (pad == 48) {
                  {
#line 987
                  while (1) {
                    while_continue___43: /* CIL Label */ ;
#line 987
                    _i___15 = (size_t )0;
                    {
#line 987
                    while (1) {
                      while_continue___44: /* CIL Label */ ;
#line 987
                      if (! (_i___15 < (size_t )_delta___6)) {
#line 987
                        goto while_break___44;
                      }
                      {
#line 987
                      fputc('0', p);
#line 987
                      _i___15 ++;
                      }
                    }
                    while_break___44: /* CIL Label */ ;
                    }
#line 987
                    goto while_break___43;
                  }
                  while_break___43: /* CIL Label */ ;
                  }
                } else {
                  {
#line 987
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 987
                    _i___16 = (size_t )0;
                    {
#line 987
                    while (1) {
                      while_continue___46: /* CIL Label */ ;
#line 987
                      if (! (_i___16 < (size_t )_delta___6)) {
#line 987
                        goto while_break___46;
                      }
                      {
#line 987
                      fputc(' ', p);
#line 987
                      _i___16 ++;
                      }
                    }
                    while_break___46: /* CIL Label */ ;
                    }
#line 987
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 987
            fputc((int )sign_char, p);
            }
          }
#line 987
          i += (size_t )_incr___6;
#line 987
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
    }
    {
#line 991
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 991
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 991
      _delta___7 = width - _n___7;
#line 991
      if (_delta___7 > 0) {
#line 991
        tmp___15 = _delta___7;
      } else {
#line 991
        tmp___15 = 0;
      }
#line 991
      _incr___7 = _n___7 + tmp___15;
#line 991
      if ((size_t )_incr___7 >= maxsize - i) {
#line 991
        return ((size_t )0);
      }
#line 991
      if (p) {
#line 991
        if (digits == 0) {
#line 991
          if (_delta___7 > 0) {
#line 991
            if (pad == 48) {
              {
#line 991
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 991
                _i___17 = (size_t )0;
                {
#line 991
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 991
                  if (! (_i___17 < (size_t )_delta___7)) {
#line 991
                    goto while_break___49;
                  }
                  {
#line 991
                  fputc('0', p);
#line 991
                  _i___17 ++;
                  }
                }
                while_break___49: /* CIL Label */ ;
                }
#line 991
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
            } else {
              {
#line 991
              while (1) {
                while_continue___50: /* CIL Label */ ;
#line 991
                _i___18 = (size_t )0;
                {
#line 991
                while (1) {
                  while_continue___51: /* CIL Label */ ;
#line 991
                  if (! (_i___18 < (size_t )_delta___7)) {
#line 991
                    goto while_break___51;
                  }
                  {
#line 991
                  fputc(' ', p);
#line 991
                  _i___18 ++;
                  }
                }
                while_break___51: /* CIL Label */ ;
                }
#line 991
                goto while_break___50;
              }
              while_break___50: /* CIL Label */ ;
              }
            }
          }
        }
#line 991
        if (to_lowcase) {
          {
#line 991
          fwrite_lowcase___0(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 991
        if (to_uppcase) {
          {
#line 991
          fwrite_uppcase___0(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 991
          fwrite((void const   */* __restrict  */)bufp, (size_t )_n___7, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 991
      i += (size_t )_incr___7;
#line 991
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
#line 992
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 995
    if (modifier != 0) {
#line 996
      goto bad_format;
    }
#line 997
    subfmt = "%Y-%m-%d";
#line 998
    goto subformat;
    case_72: /* CIL Label */ 
#line 1001
    if (modifier == 69) {
#line 1002
      goto bad_format;
    }
#line 1004
    digits = 2;
#line 1004
    number_value = (int )tp->tm_hour;
#line 1004
    goto do_number;
    case_73: /* CIL Label */ 
#line 1007
    if (modifier == 69) {
#line 1008
      goto bad_format;
    }
#line 1010
    digits = 2;
#line 1010
    number_value = hour12;
#line 1010
    goto do_number;
    case_107: /* CIL Label */ 
#line 1013
    if (modifier == 69) {
#line 1014
      goto bad_format;
    }
#line 1016
    digits = 2;
#line 1016
    number_value = (int )tp->tm_hour;
#line 1016
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1019
    if (modifier == 69) {
#line 1020
      goto bad_format;
    }
#line 1022
    digits = 2;
#line 1022
    number_value = hour12;
#line 1022
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1025
    if (modifier == 69) {
#line 1026
      goto bad_format;
    }
#line 1028
    digits = 3;
#line 1028
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1028
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1028
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1031
    if (modifier == 69) {
#line 1032
      goto bad_format;
    }
#line 1034
    digits = 2;
#line 1034
    number_value = (int )tp->tm_min;
#line 1034
    goto do_number;
    case_109: /* CIL Label */ 
#line 1037
    if (modifier == 69) {
#line 1038
      goto bad_format;
    }
#line 1040
    digits = 2;
#line 1040
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1040
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1040
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1044
    if (modifier == 69) {
#line 1045
      goto bad_format;
    }
#line 1047
    number_value = ns;
#line 1048
    if (width == -1) {
#line 1049
      width = 9;
    } else {
#line 1054
      j = width;
      {
#line 1054
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1054
        if (! (j < 9)) {
#line 1054
          goto while_break___52;
        }
#line 1055
        number_value /= 10;
#line 1054
        j ++;
      }
      while_break___52: /* CIL Label */ ;
      }
    }
#line 1058
    digits = width;
#line 1058
    number_value = number_value;
#line 1058
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1062
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1062
      _n___8 = 1;
#line 1062
      _delta___8 = width - _n___8;
#line 1062
      if (_delta___8 > 0) {
#line 1062
        tmp___16 = _delta___8;
      } else {
#line 1062
        tmp___16 = 0;
      }
#line 1062
      _incr___8 = _n___8 + tmp___16;
#line 1062
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1062
        return ((size_t )0);
      }
#line 1062
      if (p) {
#line 1062
        if (digits == 0) {
#line 1062
          if (_delta___8 > 0) {
#line 1062
            if (pad == 48) {
              {
#line 1062
              while (1) {
                while_continue___54: /* CIL Label */ ;
#line 1062
                _i___19 = (size_t )0;
                {
#line 1062
                while (1) {
                  while_continue___55: /* CIL Label */ ;
#line 1062
                  if (! (_i___19 < (size_t )_delta___8)) {
#line 1062
                    goto while_break___55;
                  }
                  {
#line 1062
                  fputc('0', p);
#line 1062
                  _i___19 ++;
                  }
                }
                while_break___55: /* CIL Label */ ;
                }
#line 1062
                goto while_break___54;
              }
              while_break___54: /* CIL Label */ ;
              }
            } else {
              {
#line 1062
              while (1) {
                while_continue___56: /* CIL Label */ ;
#line 1062
                _i___20 = (size_t )0;
                {
#line 1062
                while (1) {
                  while_continue___57: /* CIL Label */ ;
#line 1062
                  if (! (_i___20 < (size_t )_delta___8)) {
#line 1062
                    goto while_break___57;
                  }
                  {
#line 1062
                  fputc(' ', p);
#line 1062
                  _i___20 ++;
                  }
                }
                while_break___57: /* CIL Label */ ;
                }
#line 1062
                goto while_break___56;
              }
              while_break___56: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1062
        fputc('\n', p);
        }
      }
#line 1062
      i += (size_t )_incr___8;
#line 1062
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 1063
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1066
    to_lowcase = (_Bool)1;
#line 1068
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1073
    if (change_case) {
#line 1075
      to_uppcase = (_Bool)0;
#line 1076
      to_lowcase = (_Bool)1;
    }
#line 1082
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1086
    subfmt = "%H:%M";
#line 1087
    goto subformat;
    case_114: /* CIL Label */ 
#line 1097
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1101
    if (modifier == 69) {
#line 1102
      goto bad_format;
    }
#line 1104
    digits = 2;
#line 1104
    number_value = (int )tp->tm_sec;
#line 1104
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1111
    ltm = (struct tm )*tp;
#line 1112
    t = mktime(& ltm);
#line 1117
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1118
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1120
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1122
      d = (int )(t % 10L);
#line 1123
      t /= 10L;
#line 1124
      bufp --;
#line 1124
      if (negative_number) {
#line 1124
        tmp___17 = - d;
      } else {
#line 1124
        tmp___17 = d;
      }
#line 1124
      *bufp = (char )(tmp___17 + 48);
#line 1120
      if (! (t != 0L)) {
#line 1120
        goto while_break___58;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
#line 1128
    digits = 1;
#line 1129
    always_output_a_sign = (_Bool)0;
#line 1130
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1134
    if (modifier == 79) {
#line 1135
      goto bad_format;
    }
#line 1144
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1147
    subfmt = "%H:%M:%S";
#line 1148
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1151
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1151
      _n___9 = 1;
#line 1151
      _delta___9 = width - _n___9;
#line 1151
      if (_delta___9 > 0) {
#line 1151
        tmp___18 = _delta___9;
      } else {
#line 1151
        tmp___18 = 0;
      }
#line 1151
      _incr___9 = _n___9 + tmp___18;
#line 1151
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1151
        return ((size_t )0);
      }
#line 1151
      if (p) {
#line 1151
        if (digits == 0) {
#line 1151
          if (_delta___9 > 0) {
#line 1151
            if (pad == 48) {
              {
#line 1151
              while (1) {
                while_continue___60: /* CIL Label */ ;
#line 1151
                _i___21 = (size_t )0;
                {
#line 1151
                while (1) {
                  while_continue___61: /* CIL Label */ ;
#line 1151
                  if (! (_i___21 < (size_t )_delta___9)) {
#line 1151
                    goto while_break___61;
                  }
                  {
#line 1151
                  fputc('0', p);
#line 1151
                  _i___21 ++;
                  }
                }
                while_break___61: /* CIL Label */ ;
                }
#line 1151
                goto while_break___60;
              }
              while_break___60: /* CIL Label */ ;
              }
            } else {
              {
#line 1151
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1151
                _i___22 = (size_t )0;
                {
#line 1151
                while (1) {
                  while_continue___63: /* CIL Label */ ;
#line 1151
                  if (! (_i___22 < (size_t )_delta___9)) {
#line 1151
                    goto while_break___63;
                  }
                  {
#line 1151
                  fputc(' ', p);
#line 1151
                  _i___22 ++;
                  }
                }
                while_break___63: /* CIL Label */ ;
                }
#line 1151
                goto while_break___62;
              }
              while_break___62: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1151
        fputc('\t', p);
        }
      }
#line 1151
      i += (size_t )_incr___9;
#line 1151
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 1152
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1155
    digits = 1;
#line 1155
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1155
    goto do_number;
    case_85: /* CIL Label */ 
#line 1158
    if (modifier == 69) {
#line 1159
      goto bad_format;
    }
#line 1161
    digits = 2;
#line 1161
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1161
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1166
    if (modifier == 69) {
#line 1167
      goto bad_format;
    }
#line 1173
    if (tp->tm_year < 0) {
#line 1173
      tmp___19 = 300;
    } else {
#line 1173
      tmp___19 = -100;
    }
    {
#line 1173
    year___1 = (int )(tp->tm_year + (int const   )tmp___19);
#line 1177
    year_adjust = 0;
#line 1178
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1178
    days = tmp___20;
    }
#line 1180
    if (days < 0) {
#line 1183
      year_adjust = -1;
#line 1184
      if ((year___1 - 1) % 4 == 0) {
#line 1184
        if ((year___1 - 1) % 100 != 0) {
#line 1184
          tmp___21 = 1;
        } else
#line 1184
        if ((year___1 - 1) % 400 == 0) {
#line 1184
          tmp___21 = 1;
        } else {
#line 1184
          tmp___21 = 0;
        }
      } else {
#line 1184
        tmp___21 = 0;
      }
      {
#line 1184
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1189
      if (year___1 % 4 == 0) {
#line 1189
        if (year___1 % 100 != 0) {
#line 1189
          tmp___22 = 1;
        } else
#line 1189
        if (year___1 % 400 == 0) {
#line 1189
          tmp___22 = 1;
        } else {
#line 1189
          tmp___22 = 0;
        }
      } else {
#line 1189
        tmp___22 = 0;
      }
      {
#line 1189
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1189
      d___0 = tmp___23;
      }
#line 1191
      if (0 <= d___0) {
#line 1194
        year_adjust = 1;
#line 1195
        days = d___0;
      }
    }
    {
#line 1201
    if ((int const   )*f == 103) {
#line 1201
      goto case_103___0;
    }
#line 1211
    if ((int const   )*f == 71) {
#line 1211
      goto case_71___0;
    }
#line 1216
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1203
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1204
    digits = 2;
#line 1204
    if (0 <= yy) {
#line 1204
      number_value = yy;
    } else {
#line 1204
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1204
        tmp___24 = - yy;
      } else {
#line 1204
        tmp___24 = yy + 100;
      }
#line 1204
      number_value = tmp___24;
    }
#line 1204
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1212
    digits = 4;
#line 1212
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1212
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1212
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1217
    digits = 2;
#line 1217
    number_value = days / 7 + 1;
#line 1217
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1222
    if (modifier == 69) {
#line 1223
      goto bad_format;
    }
#line 1225
    digits = 2;
#line 1225
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1225
    goto do_number;
    case_119: /* CIL Label */ 
#line 1228
    if (modifier == 69) {
#line 1229
      goto bad_format;
    }
#line 1231
    digits = 1;
#line 1231
    number_value = (int )tp->tm_wday;
#line 1231
    goto do_number;
    case_89: /* CIL Label */ 
#line 1234
    if (modifier == 69) {
#line 1248
      goto underlying_strftime;
    }
#line 1251
    if (modifier == 79) {
#line 1252
      goto bad_format;
    } else {
#line 1254
      digits = 4;
    }
#line 1254
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1254
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1254
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1258
    if (modifier == 69) {
#line 1269
      goto underlying_strftime;
    }
#line 1274
    yy___0 = (int )(tp->tm_year % 100);
#line 1275
    if (yy___0 < 0) {
#line 1276
      if (tp->tm_year < -1900) {
#line 1276
        yy___0 = - yy___0;
      } else {
#line 1276
        yy___0 += 100;
      }
    }
#line 1277
    digits = 2;
#line 1277
    number_value = yy___0;
#line 1277
    goto do_number;
    case_90: /* CIL Label */ 
#line 1281
    if (change_case) {
#line 1283
      to_uppcase = (_Bool)0;
#line 1284
      to_lowcase = (_Bool)1;
    }
#line 1292
    if (! zone) {
#line 1293
      zone = "";
    }
    {
#line 1305
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 1305
      tmp___25 = strlen(zone);
#line 1305
      _n___10 = (int )tmp___25;
#line 1305
      _delta___10 = width - _n___10;
      }
#line 1305
      if (_delta___10 > 0) {
#line 1305
        tmp___26 = _delta___10;
      } else {
#line 1305
        tmp___26 = 0;
      }
#line 1305
      _incr___10 = _n___10 + tmp___26;
#line 1305
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1305
        return ((size_t )0);
      }
#line 1305
      if (p) {
#line 1305
        if (digits == 0) {
#line 1305
          if (_delta___10 > 0) {
#line 1305
            if (pad == 48) {
              {
#line 1305
              while (1) {
                while_continue___65: /* CIL Label */ ;
#line 1305
                _i___23 = (size_t )0;
                {
#line 1305
                while (1) {
                  while_continue___66: /* CIL Label */ ;
#line 1305
                  if (! (_i___23 < (size_t )_delta___10)) {
#line 1305
                    goto while_break___66;
                  }
                  {
#line 1305
                  fputc('0', p);
#line 1305
                  _i___23 ++;
                  }
                }
                while_break___66: /* CIL Label */ ;
                }
#line 1305
                goto while_break___65;
              }
              while_break___65: /* CIL Label */ ;
              }
            } else {
              {
#line 1305
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1305
                _i___24 = (size_t )0;
                {
#line 1305
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1305
                  if (! (_i___24 < (size_t )_delta___10)) {
#line 1305
                    goto while_break___68;
                  }
                  {
#line 1305
                  fputc(' ', p);
#line 1305
                  _i___24 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1305
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            }
          }
        }
#line 1305
        if (to_lowcase) {
          {
#line 1305
          fwrite_lowcase___0(p, zone, (size_t )_n___10);
          }
        } else
#line 1305
        if (to_uppcase) {
          {
#line 1305
          fwrite_uppcase___0(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1305
          fwrite((void const   */* __restrict  */)zone, (size_t )_n___10, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 1305
      i += (size_t )_incr___10;
#line 1305
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 1307
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1312
    colons = (size_t )1;
    {
#line 1312
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1312
      if (! ((int const   )*(f + colons) == 58)) {
#line 1312
        goto while_break___69;
      }
#line 1313
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1312
      colons ++;
    }
    while_break___69: /* CIL Label */ ;
    }
#line 1314
    if ((int const   )*(f + colons) != 122) {
#line 1315
      goto bad_format;
    }
#line 1316
    f += colons;
#line 1317
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1320
    colons = (size_t )0;
    do_z_conversion: 
#line 1323
    if (tp->tm_isdst < 0) {
#line 1324
      goto switch_break___1;
    }
#line 1332
    diff = (int )tp->tm_gmtoff;
#line 1369
    hour_diff = (diff / 60) / 60;
#line 1370
    min_diff = (diff / 60) % 60;
#line 1371
    sec_diff = diff % 60;
    {
#line 1375
    if (colons == 0UL) {
#line 1375
      goto case_0;
    }
#line 1378
    if (colons == 1UL) {
#line 1378
      goto tz_hh_mm;
    }
#line 1381
    if (colons == 2UL) {
#line 1381
      goto tz_hh_mm_ss;
    }
#line 1385
    if (colons == 3UL) {
#line 1385
      goto case_3;
    }
#line 1392
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1376
    digits = 5;
#line 1376
    negative_number = (_Bool )(diff < 0);
#line 1376
    tz_colon_mask = 0;
#line 1376
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1376
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1379
    digits = 6;
#line 1379
    negative_number = (_Bool )(diff < 0);
#line 1379
    tz_colon_mask = 4;
#line 1379
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1379
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1382
    digits = 9;
#line 1382
    negative_number = (_Bool )(diff < 0);
#line 1382
    tz_colon_mask = 20;
#line 1382
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1382
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1386
    if (sec_diff != 0) {
#line 1387
      goto tz_hh_mm_ss;
    }
#line 1388
    if (min_diff != 0) {
#line 1389
      goto tz_hh_mm;
    }
#line 1390
    digits = 3;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )hour_diff;
#line 1390
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1393
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1398
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1407
    flen = 1;
    {
#line 1407
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 1407
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1407
        goto while_break___70;
      }
#line 1408
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1407
      flen ++;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 1409
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1409
      _n___11 = flen;
#line 1409
      _delta___11 = width - _n___11;
#line 1409
      if (_delta___11 > 0) {
#line 1409
        tmp___27 = _delta___11;
      } else {
#line 1409
        tmp___27 = 0;
      }
#line 1409
      _incr___11 = _n___11 + tmp___27;
#line 1409
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1409
        return ((size_t )0);
      }
#line 1409
      if (p) {
#line 1409
        if (digits == 0) {
#line 1409
          if (_delta___11 > 0) {
#line 1409
            if (pad == 48) {
              {
#line 1409
              while (1) {
                while_continue___72: /* CIL Label */ ;
#line 1409
                _i___25 = (size_t )0;
                {
#line 1409
                while (1) {
                  while_continue___73: /* CIL Label */ ;
#line 1409
                  if (! (_i___25 < (size_t )_delta___11)) {
#line 1409
                    goto while_break___73;
                  }
                  {
#line 1409
                  fputc('0', p);
#line 1409
                  _i___25 ++;
                  }
                }
                while_break___73: /* CIL Label */ ;
                }
#line 1409
                goto while_break___72;
              }
              while_break___72: /* CIL Label */ ;
              }
            } else {
              {
#line 1409
              while (1) {
                while_continue___74: /* CIL Label */ ;
#line 1409
                _i___26 = (size_t )0;
                {
#line 1409
                while (1) {
                  while_continue___75: /* CIL Label */ ;
#line 1409
                  if (! (_i___26 < (size_t )_delta___11)) {
#line 1409
                    goto while_break___75;
                  }
                  {
#line 1409
                  fputc(' ', p);
#line 1409
                  _i___26 ++;
                  }
                }
                while_break___75: /* CIL Label */ ;
                }
#line 1409
                goto while_break___74;
              }
              while_break___74: /* CIL Label */ ;
              }
            }
          }
        }
#line 1409
        if (to_lowcase) {
          {
#line 1409
          fwrite_lowcase___0(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1409
        if (to_uppcase) {
          {
#line 1409
          fwrite_uppcase___0(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1409
          fwrite((void const   */* __restrict  */)(f + (1 - flen)), (size_t )_n___11,
                 (size_t )1, (FILE */* __restrict  */)p);
          }
        }
      }
#line 1409
      i += (size_t )_incr___11;
#line 1409
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 1411
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 492
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return (i);
}
}
#line 33 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
static char const   *match_suffix___0(char const   **str ) 
{ 
  char const   *match ;
  _Bool read_alpha ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 36
  match = (char const   *)((void *)0);
#line 37
  read_alpha = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! *(*str)) {
#line 38
      goto while_break;
    }
#line 40
    if (read_alpha) {
      {
#line 42
      read_alpha = (_Bool)0;
#line 43
      tmp = c_isalpha((int )*(*str));
      }
#line 43
      if (! tmp) {
#line 44
        match = (char const   *)((void *)0);
      }
    } else
#line 46
    if (46 == (int )*(*str)) {
#line 48
      read_alpha = (_Bool)1;
#line 49
      if (! match) {
#line 50
        match = *str;
      }
    } else {
      {
#line 52
      tmp___0 = c_isalnum((int )*(*str));
      }
#line 52
      if (! tmp___0) {
#line 53
        match = (char const   *)((void *)0);
      }
    }
#line 54
    (*str) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (match);
}
}
#line 83 "/home/khheo/project/benchmark/coreutils-7.1/lib/filevercmp.c"
static int verrevcmp___0(char const   *s1 , size_t s1_len , char const   *s2 , size_t s2_len ) 
{ 
  size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
#line 86
  s1_pos = (size_t )0;
#line 87
  s2_pos = (size_t )0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (s1_pos < s1_len)) {
#line 88
      if (! (s2_pos < s2_len)) {
#line 88
        goto while_break;
      }
    }
#line 90
    first_diff = 0;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (s1_pos < s1_len) {
        {
#line 91
        tmp___3 = c_isdigit((int )*(s1 + s1_pos));
        }
#line 91
        if (tmp___3) {
#line 91
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 91
      if (s2_pos < s2_len) {
        {
#line 91
        tmp___4 = c_isdigit((int )*(s2 + s2_pos));
        }
#line 91
        if (tmp___4) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 94
      if (s1_pos == s1_len) {
#line 94
        tmp___0 = 0;
      } else {
        {
#line 94
        tmp = order((unsigned char )*(s1 + s1_pos));
#line 94
        tmp___0 = tmp;
        }
      }
#line 94
      s1_c = tmp___0;
#line 95
      if (s2_pos == s2_len) {
#line 95
        tmp___2 = 0;
      } else {
        {
#line 95
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
#line 95
        tmp___2 = tmp___1;
        }
      }
#line 95
      s2_c = tmp___2;
#line 96
      if (s1_c != s2_c) {
#line 97
        return (s1_c - s2_c);
      }
#line 98
      s1_pos ++;
#line 99
      s2_pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (! ((int const   )*(s1 + s1_pos) == 48)) {
#line 101
        goto while_break___1;
      }
#line 102
      s1_pos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 103
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 103
      if (! ((int const   )*(s2 + s2_pos) == 48)) {
#line 103
        goto while_break___2;
      }
#line 104
      s2_pos ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 105
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 105
      tmp___5 = c_isdigit((int )*(s1 + s1_pos));
      }
#line 105
      if (tmp___5) {
        {
#line 105
        tmp___6 = c_isdigit((int )*(s2 + s2_pos));
        }
#line 105
        if (! tmp___6) {
#line 105
          goto while_break___3;
        }
      } else {
#line 105
        goto while_break___3;
      }
#line 107
      if (! first_diff) {
#line 108
        first_diff = (int )((int const   )*(s1 + s1_pos) - (int const   )*(s2 + s2_pos));
      }
#line 109
      s1_pos ++;
#line 110
      s2_pos ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 112
    tmp___7 = c_isdigit((int )*(s1 + s1_pos));
    }
#line 112
    if (tmp___7) {
#line 113
      return (1);
    }
    {
#line 114
    tmp___8 = c_isdigit((int )*(s2 + s2_pos));
    }
#line 114
    if (tmp___8) {
#line 115
      return (-1);
    }
#line 116
    if (first_diff) {
#line 117
      return (first_diff);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/filenamecat.c"
static char const   *longest_relative_suffix___0(char const   *f ) 
{ 


  {
#line 41
  f += 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int const   )*f == 47)) {
#line 41
      goto while_break;
    }
#line 42
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 41
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (f);
}
}
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/filemode.c"
static char ftypelet___0(mode_t bits ) 
{ 


  {
#line 57
  if ((bits & 61440U) == 32768U) {
#line 58
    return ((char )'-');
  }
#line 59
  if ((bits & 61440U) == 16384U) {
#line 60
    return ((char )'d');
  }
#line 63
  if ((bits & 61440U) == 24576U) {
#line 64
    return ((char )'b');
  }
#line 65
  if ((bits & 61440U) == 8192U) {
#line 66
    return ((char )'c');
  }
#line 67
  if ((bits & 61440U) == 40960U) {
#line 68
    return ((char )'l');
  }
#line 69
  if ((bits & 61440U) == 4096U) {
#line 70
    return ((char )'p');
  }
#line 73
  if ((bits & 61440U) == 49152U) {
#line 74
    return ((char )'s');
  }
#line 90
  return ((char )'?');
}
}
#line 95 "/home/khheo/project/benchmark/coreutils-7.1/lib/exclude.c"
static int fnmatch_no_wildcards___0(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 98
  if (! (options & (1 << 3))) {
#line 99
    if (options & (1 << 4)) {
      {
#line 99
      tmp = mbscasecmp(pattern, f);
#line 99
      tmp___1 = tmp;
      }
    } else {
      {
#line 99
      tmp___0 = strcmp(pattern, f);
#line 99
      tmp___1 = tmp___0;
      }
    }
#line 99
    return (tmp___1);
  } else
#line 102
  if (! (options & (1 << 4))) {
    {
#line 104
    tmp___2 = strlen(pattern);
#line 104
    patlen = tmp___2;
#line 105
    tmp___3 = strncmp(pattern, f, patlen);
#line 105
    r = tmp___3;
    }
#line 106
    if (! r) {
#line 108
      r = (int )*(f + patlen);
#line 109
      if (r == 47) {
#line 110
        r = 0;
      }
    }
#line 112
    return (r);
  } else {
    {
#line 123
    tmp___4 = xstrdup(f);
#line 123
    fcopy = tmp___4;
#line 126
    p = fcopy;
    }
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 128
      p = strchr((char const   *)p, '/');
      }
#line 129
      if (p) {
#line 130
        *p = (char )'\000';
      }
      {
#line 131
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 132
      if (! p) {
#line 133
        goto while_break;
      } else
#line 132
      if (r___0 <= 0) {
#line 133
        goto while_break;
      }
#line 126
      tmp___5 = p;
#line 126
      p ++;
#line 126
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 135
    free((void *)fcopy);
    }
#line 136
    return (r___0);
  }
}
}
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/copy-acl.c"
static int qcopy_acl___0(char const   *src_name , int source_desc , char const   *dst_name ,
                         int dest_desc , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 520
  tmp = qset_acl(dst_name, dest_desc, mode);
  }
#line 520
  return (tmp);
}
}
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
static char const   *file_name___1  ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/closeout.c"
static _Bool ignore_EPIPE___0  ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___3(uintmax_t *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (uintmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___3(uintmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___3(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___4(unsigned long *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___4(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___4(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___5(long *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___5(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___5(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol-error.c"
static void xstrtol_error___0(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___2 ,
                              char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___2 + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
  }
#line 87
  return;
}
}
#line 46 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale___6(intmax_t *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (intmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___6(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___6(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 37 "/home/khheo/project/benchmark/coreutils-7.1/lib/closein.c"
static char const   *file_name___2  ;
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.c"
static _Bool initialized___1  ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/write-any-file.c"
static _Bool can_write___0  ;
#line 20 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/cjk.h"
static int is_cjk_encoding___0(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data___0[1664]  = 
#line 35 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )255, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 271 "/home/khheo/project/benchmark/coreutils-7.1/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind___0[240]  = 
#line 271
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )25,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 222 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.c"
static char decimal_point_char___0(void) 
{ 
  char const   *point ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 231
  tmp = nl_langinfo(65536);
#line 231
  point = (char const   *)tmp;
  }
#line 240
  if ((int const   )*(point + 0) != 0) {
#line 240
    tmp___0 = (int const   )*(point + 0);
  } else {
#line 240
    tmp___0 = (int const   )'.';
  }
#line 240
  return ((char )tmp___0);
}
}
#line 259 "/home/khheo/project/benchmark/coreutils-7.1/lib/vasnprintf.c"
static int is_infinite_or_zerol___0(long double x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp = rpl_isnanl(x);
  }
#line 262
  if (tmp) {
#line 262
    tmp___0 = 1;
  } else
#line 262
  if (x + x == x) {
#line 262
    tmp___0 = 1;
  } else {
#line 262
    tmp___0 = 0;
  }
#line 262
  return (tmp___0);
}
}
#line 75 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static size_t dev_info_hash___0(void const   *x , size_t table_size ) 
{ 
  struct fs_res  const  *p ;

  {
#line 78
  p = (struct fs_res  const  *)x;
#line 87
  return ((size_t )(p->dev % (unsigned long const   )table_size));
}
}
#line 91 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static _Bool dev_info_compare___0(void const   *x , void const   *y ) 
{ 
  struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
#line 94
  a = (struct fs_res  const  *)x;
#line 95
  b = (struct fs_res  const  *)y;
#line 96
  return ((_Bool )(a->dev == b->dev));
}
}
#line 141 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static Hash_table *ht___0  ;
#line 144 "/home/khheo/project/benchmark/coreutils-7.1/lib/utimecmp.c"
static struct fs_res *new_dst_res___0  ;
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *parse_with_separator___0(char const   *spec , char const   *separator ,
                                              uid_t *uid , gid_t *gid , char **username ,
                                              char **groupname ) ;
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_invalid_user___0  =    "invalid user";
#line 107 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_invalid_group___0  =    "invalid group";
#line 108 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *E_bad_spec___0  =    "invalid spec";
#line 101 "/home/khheo/project/benchmark/coreutils-7.1/lib/userspec.c"
static char const   *parse_with_separator___0(char const   *spec , char const   *separator ,
                                              uid_t *uid , gid_t *gid , char **username ,
                                              char **groupname ) 
{ 
  char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;

  {
#line 115
  gname = (char *)((void *)0);
#line 116
  unum = *uid;
#line 117
  gnum = *gid;
#line 119
  error_msg = (char const   *)((void *)0);
#line 120
  tmp = (char *)((void *)0);
#line 120
  *groupname = tmp;
#line 120
  *username = tmp;
#line 126
  u = (char *)((void *)0);
#line 127
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 129
    if (*spec) {
      {
#line 130
      u = xstrdup(spec);
      }
    }
  } else {
#line 134
    ulen = (size_t )(separator - spec);
#line 135
    if (ulen != 0UL) {
      {
#line 137
      tmp___0 = xmemdup((void const   *)spec, ulen + 1UL);
#line 137
      u = (char *)tmp___0;
#line 138
      *(u + ulen) = (char )'\000';
      }
    }
  }
#line 142
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 142
    g = (char const   *)((void *)0);
  } else
#line 142
  if ((int const   )*(separator + 1) == 0) {
#line 142
    g = (char const   *)((void *)0);
  } else {
#line 142
    g = separator + 1;
  }
#line 155
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 158
    if ((int )*u == 43) {
#line 158
      pwd = (struct passwd *)((void *)0);
    } else {
      {
#line 158
      tmp___1 = getpwnam((char const   *)u);
#line 158
      pwd = tmp___1;
      }
    }
#line 159
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 161
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 161
        if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 161
          tmp___2 = 1;
        } else {
#line 161
          tmp___2 = 0;
        }
      } else {
#line 161
        tmp___2 = 0;
      }
#line 161
      use_login_group = (_Bool )tmp___2;
#line 162
      if (use_login_group) {
#line 166
        error_msg = E_bad_spec___0;
      } else {
        {
#line 171
        tmp___4 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp___3,
                           "");
        }
#line 171
        if ((unsigned int )tmp___4 == 0U) {
#line 171
          if (tmp___3 <= 4294967295UL) {
#line 173
            unum = (uid_t )tmp___3;
          } else {
#line 175
            error_msg = E_invalid_user___0;
          }
        } else {
#line 175
          error_msg = E_invalid_user___0;
        }
      }
    } else {
#line 180
      unum = pwd->pw_uid;
#line 181
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 181
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          {
#line 186
          gnum = pwd->pw_gid;
#line 187
          grp = getgrgid(gnum);
          }
#line 188
          if (grp) {
#line 188
            tmp___6 = grp->gr_name;
          } else {
            {
#line 188
            tmp___5 = umaxtostr((uintmax_t )gnum, buf___1);
#line 188
            tmp___6 = tmp___5;
            }
          }
          {
#line 188
          gname = xstrdup((char const   *)tmp___6);
#line 189
          endgrent();
          }
        }
      }
    }
    {
#line 192
    endpwent();
    }
  }
#line 195
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 195
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 199
      if ((int const   )*g == 43) {
#line 199
        grp = (struct group *)((void *)0);
      } else {
        {
#line 199
        tmp___7 = getgrnam(g);
#line 199
        grp = tmp___7;
        }
      }
#line 200
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
        {
#line 203
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, "");
        }
#line 203
        if ((unsigned int )tmp___9 == 0U) {
#line 203
          if (tmp___8 <= 4294967295UL) {
#line 204
            gnum = (gid_t )tmp___8;
          } else {
#line 206
            error_msg = E_invalid_group___0;
          }
        } else {
#line 206
          error_msg = E_invalid_group___0;
        }
      } else {
#line 209
        gnum = grp->gr_gid;
      }
      {
#line 210
      endgrent();
#line 211
      gname = xstrdup(g);
      }
    }
  }
#line 214
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 216
    *uid = unum;
#line 217
    *gid = gnum;
#line 218
    *username = u;
#line 219
    *groupname = gname;
#line 220
    u = (char *)((void *)0);
  } else {
    {
#line 223
    free((void *)gname);
    }
  }
  {
#line 225
  free((void *)u);
#line 226
  tmp___10 = gettext(error_msg);
  }
#line 226
  return ((char const   *)tmp___10);
}
}
#line 71 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static int initialized___2  ;
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static int is_utf8___0  ;
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static iconv_t utf8_to_local___0  ;
#line 170 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static long exit_failure_callback___0(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 174
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
#line 175
    tmp = gettext("cannot convert U+%04X to local character set");
#line 175
    error(1, 0, (char const   *)tmp, code);
    }
  } else {
    {
#line 177
    tmp___0 = gettext(msg);
#line 177
    tmp___1 = gettext("cannot convert U+%04X to local character set: %s");
#line 177
    error(1, 0, (char const   *)tmp___1, code, tmp___0);
    }
  }
#line 179
  return (-1L);
}
}
#line 184 "/home/khheo/project/benchmark/coreutils-7.1/lib/unicodeio.c"
static long fallback_failure_callback___0(unsigned int code , char const   *msg  __attribute__((__unused__)) ,
                                          void *callback_arg ) 
{ 
  FILE *stream ;

  {
#line 189
  stream = (FILE *)callback_arg;
#line 191
  if (code < 65536U) {
    {
#line 192
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\\u%04X",
            code);
    }
  } else {
    {
#line 194
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\\U%08X",
            code);
    }
  }
#line 195
  return (-1L);
}
}
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
static char const   letters___0[63]  = 
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 302 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static char *memcpy_lowcase___0(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    tmp___0 = len;
#line 306
    len --;
#line 306
    if (! (tmp___0 > 0UL)) {
#line 306
      goto while_break;
    }
    {
#line 307
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 307
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (dest);
}
}
#line 311 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static char *memcpy_uppcase___0(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    tmp___0 = len;
#line 315
    len --;
#line 315
    if (! (tmp___0 > 0UL)) {
#line 315
      goto while_break;
    }
    {
#line 316
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 316
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (dest);
}
}
#line 406 "/home/khheo/project/benchmark/coreutils-7.1/lib/strftime.c"
static size_t strftime_case____2(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year___1 ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;

  {
#line 419
  hour12 = (int )tp->tm_hour;
#line 444
  i = (size_t )0;
#line 445
  p = s;
#line 460
  zone = (char const   *)((void *)0);
#line 468
  zone = (char const   *)tp->tm_zone;
#line 486
  if (hour12 > 12) {
#line 487
    hour12 -= 12;
  } else
#line 489
  if (hour12 == 0) {
#line 490
    hour12 = 12;
  }
#line 492
  f = format;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((int const   )*f != 0)) {
#line 492
      goto while_break;
    }
#line 494
    pad = 0;
#line 496
    digits = 0;
#line 510
    width = -1;
#line 511
    to_lowcase = (_Bool)0;
#line 512
    to_uppcase = upcase;
#line 514
    change_case = (_Bool)0;
#line 597
    if ((int const   )*f != 37) {
      {
#line 599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 599
        _n = 1;
#line 599
        _delta = width - _n;
#line 599
        if (_delta > 0) {
#line 599
          tmp = _delta;
        } else {
#line 599
          tmp = 0;
        }
#line 599
        _incr = _n + tmp;
#line 599
        if ((size_t )_incr >= maxsize - i) {
#line 599
          return ((size_t )0);
        }
#line 599
        if (p) {
#line 599
          if (digits == 0) {
#line 599
            if (_delta > 0) {
#line 599
              if (pad == 48) {
                {
#line 599
                memset((void *)p, '0', (size_t )_delta);
#line 599
                p += _delta;
                }
              } else {
                {
#line 599
                memset((void *)p, ' ', (size_t )_delta);
#line 599
                p += _delta;
                }
              }
            }
          }
#line 599
          *p = (char )*f;
#line 599
          p += _n;
        }
#line 599
        i += (size_t )_incr;
#line 599
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 600
      goto __Cont;
    }
    {
#line 606
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 608
      f ++;
      {
#line 613
      if ((int const   )*f == 48) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 45) {
#line 613
        goto case_48;
      }
#line 613
      if ((int const   )*f == 95) {
#line 613
        goto case_48;
      }
#line 618
      if ((int const   )*f == 94) {
#line 618
        goto case_94;
      }
#line 621
      if ((int const   )*f == 35) {
#line 621
        goto case_35;
      }
#line 625
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 614
      pad = (int )*f;
#line 615
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 619
      to_uppcase = (_Bool)1;
#line 620
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 622
      change_case = (_Bool)1;
#line 623
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 626
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 628
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 632
    if ((unsigned int )*f - 48U <= 9U) {
#line 634
      width = 0;
      {
#line 635
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 637
        if (width > 214748364) {
#line 640
          width = 2147483647;
        } else
#line 637
        if (width == 214748364) {
#line 637
          if ((int const   )*f - 48 > 7) {
#line 640
            width = 2147483647;
          } else {
#line 643
            width *= 10;
#line 644
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 643
          width *= 10;
#line 644
          width += (int )((int const   )*f - 48);
        }
#line 646
        f ++;
#line 635
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 635
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 655
    if ((int const   )*f == 79) {
#line 655
      goto case_79;
    }
#line 655
    if ((int const   )*f == 69) {
#line 655
      goto case_79;
    }
#line 659
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 656
    tmp___0 = f;
#line 656
    f ++;
#line 656
    modifier = (int )*tmp___0;
#line 657
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 660
    modifier = 0;
#line 661
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 665
    format_char = (int )*f;
    {
#line 688
    if (format_char == 37) {
#line 688
      goto case_37;
    }
#line 694
    if (format_char == 97) {
#line 694
      goto case_97;
    }
#line 709
    if (format_char == 65) {
#line 709
      goto case_65;
    }
#line 725
    if (format_char == 104) {
#line 725
      goto case_104;
    }
#line 725
    if (format_char == 98) {
#line 725
      goto case_104;
    }
#line 740
    if (format_char == 66) {
#line 740
      goto case_66;
    }
#line 755
    if (format_char == 99) {
#line 755
      goto case_99;
    }
#line 814
    if (format_char == 67) {
#line 814
      goto case_67;
    }
#line 843
    if (format_char == 120) {
#line 843
      goto case_120;
    }
#line 856
    if (format_char == 68) {
#line 856
      goto case_68;
    }
#line 862
    if (format_char == 100) {
#line 862
      goto case_100;
    }
#line 868
    if (format_char == 101) {
#line 868
      goto case_101;
    }
#line 994
    if (format_char == 70) {
#line 994
      goto case_70;
    }
#line 1000
    if (format_char == 72) {
#line 1000
      goto case_72;
    }
#line 1006
    if (format_char == 73) {
#line 1006
      goto case_73;
    }
#line 1012
    if (format_char == 107) {
#line 1012
      goto case_107;
    }
#line 1018
    if (format_char == 108) {
#line 1018
      goto case_108;
    }
#line 1024
    if (format_char == 106) {
#line 1024
      goto case_106;
    }
#line 1030
    if (format_char == 77) {
#line 1030
      goto case_77;
    }
#line 1036
    if (format_char == 109) {
#line 1036
      goto case_109;
    }
#line 1043
    if (format_char == 78) {
#line 1043
      goto case_78;
    }
#line 1061
    if (format_char == 110) {
#line 1061
      goto case_110;
    }
#line 1065
    if (format_char == 80) {
#line 1065
      goto case_80;
    }
#line 1072
    if (format_char == 112) {
#line 1072
      goto case_112;
    }
#line 1085
    if (format_char == 82) {
#line 1085
      goto case_82;
    }
#line 1089
    if (format_char == 114) {
#line 1089
      goto case_114;
    }
#line 1100
    if (format_char == 83) {
#line 1100
      goto case_83;
    }
#line 1106
    if (format_char == 115) {
#line 1106
      goto case_115;
    }
#line 1133
    if (format_char == 88) {
#line 1133
      goto case_88;
    }
#line 1146
    if (format_char == 84) {
#line 1146
      goto case_84;
    }
#line 1150
    if (format_char == 116) {
#line 1150
      goto case_116;
    }
#line 1154
    if (format_char == 117) {
#line 1154
      goto case_117;
    }
#line 1157
    if (format_char == 85) {
#line 1157
      goto case_85;
    }
#line 1165
    if (format_char == 71) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 103) {
#line 1165
      goto case_71;
    }
#line 1165
    if (format_char == 86) {
#line 1165
      goto case_71;
    }
#line 1221
    if (format_char == 87) {
#line 1221
      goto case_87;
    }
#line 1227
    if (format_char == 119) {
#line 1227
      goto case_119;
    }
#line 1233
    if (format_char == 89) {
#line 1233
      goto case_89;
    }
#line 1257
    if (format_char == 121) {
#line 1257
      goto case_121;
    }
#line 1280
    if (format_char == 90) {
#line 1280
      goto case_90;
    }
#line 1309
    if (format_char == 58) {
#line 1309
      goto case_58;
    }
#line 1319
    if (format_char == 122) {
#line 1319
      goto case_122;
    }
#line 1397
    if (format_char == 0) {
#line 1397
      goto case_0___0;
    }
#line 1400
    goto bad_format;
    case_37: /* CIL Label */ 
#line 689
    if (modifier != 0) {
#line 690
      goto bad_format;
    }
    {
#line 691
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 691
      _n___0 = 1;
#line 691
      _delta___0 = width - _n___0;
#line 691
      if (_delta___0 > 0) {
#line 691
        tmp___1 = _delta___0;
      } else {
#line 691
        tmp___1 = 0;
      }
#line 691
      _incr___0 = _n___0 + tmp___1;
#line 691
      if ((size_t )_incr___0 >= maxsize - i) {
#line 691
        return ((size_t )0);
      }
#line 691
      if (p) {
#line 691
        if (digits == 0) {
#line 691
          if (_delta___0 > 0) {
#line 691
            if (pad == 48) {
              {
#line 691
              memset((void *)p, '0', (size_t )_delta___0);
#line 691
              p += _delta___0;
              }
            } else {
              {
#line 691
              memset((void *)p, ' ', (size_t )_delta___0);
#line 691
              p += _delta___0;
              }
            }
          }
        }
#line 691
        *p = (char )*f;
#line 691
        p += _n___0;
      }
#line 691
      i += (size_t )_incr___0;
#line 691
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 692
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 695
    if (modifier != 0) {
#line 696
      goto bad_format;
    }
#line 697
    if (change_case) {
#line 699
      to_uppcase = (_Bool)1;
#line 700
      to_lowcase = (_Bool)0;
    }
#line 706
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 710
    if (modifier != 0) {
#line 711
      goto bad_format;
    }
#line 712
    if (change_case) {
#line 714
      to_uppcase = (_Bool)1;
#line 715
      to_lowcase = (_Bool)0;
    }
#line 721
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 731
    if (modifier != 0) {
#line 732
      goto bad_format;
    }
#line 737
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 741
    if (modifier != 0) {
#line 742
      goto bad_format;
    }
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 752
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 756
    if (modifier == 79) {
#line 757
      goto bad_format;
    }
#line 766
    goto underlying_strftime;
    subformat: 
    {
#line 771
    tmp___2 = strftime_case____2(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
#line 771
    len = tmp___2;
    }
    {
#line 775
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 775
      _n___1 = (int )len;
#line 775
      _delta___1 = width - _n___1;
#line 775
      if (_delta___1 > 0) {
#line 775
        tmp___3 = _delta___1;
      } else {
#line 775
        tmp___3 = 0;
      }
#line 775
      _incr___1 = _n___1 + tmp___3;
#line 775
      if ((size_t )_incr___1 >= maxsize - i) {
#line 775
        return ((size_t )0);
      }
#line 775
      if (p) {
#line 775
        if (digits == 0) {
#line 775
          if (_delta___1 > 0) {
#line 775
            if (pad == 48) {
              {
#line 775
              memset((void *)p, '0', (size_t )_delta___1);
#line 775
              p += _delta___1;
              }
            } else {
              {
#line 775
              memset((void *)p, ' ', (size_t )_delta___1);
#line 775
              p += _delta___1;
              }
            }
          }
        }
        {
#line 775
        strftime_case____2(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 775
        p += _n___1;
        }
      }
#line 775
      i += (size_t )_incr___1;
#line 775
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 780
    goto switch_break___1;
    underlying_strftime: 
#line 788
    u = ufmt;
#line 801
    tmp___4 = u;
#line 801
    u ++;
#line 801
    *tmp___4 = (char )' ';
#line 802
    tmp___5 = u;
#line 802
    u ++;
#line 802
    *tmp___5 = (char )'%';
#line 803
    if (modifier != 0) {
#line 804
      tmp___6 = u;
#line 804
      u ++;
#line 804
      *tmp___6 = (char )modifier;
    }
    {
#line 805
    tmp___7 = u;
#line 805
    u ++;
#line 805
    *tmp___7 = (char )format_char;
#line 806
    *u = (char )'\000';
#line 807
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 808
    if (len___0 != 0UL) {
      {
#line 809
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 809
        _n___2 = (int )(len___0 - 1UL);
#line 809
        _delta___2 = width - _n___2;
#line 809
        if (_delta___2 > 0) {
#line 809
          tmp___8 = _delta___2;
        } else {
#line 809
          tmp___8 = 0;
        }
#line 809
        _incr___2 = _n___2 + tmp___8;
#line 809
        if ((size_t )_incr___2 >= maxsize - i) {
#line 809
          return ((size_t )0);
        }
#line 809
        if (p) {
#line 809
          if (digits == 0) {
#line 809
            if (_delta___2 > 0) {
#line 809
              if (pad == 48) {
                {
#line 809
                memset((void *)p, '0', (size_t )_delta___2);
#line 809
                p += _delta___2;
                }
              } else {
                {
#line 809
                memset((void *)p, ' ', (size_t )_delta___2);
#line 809
                p += _delta___2;
                }
              }
            }
          }
#line 809
          if (to_lowcase) {
            {
#line 809
            memcpy_lowcase___0(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 809
          if (to_uppcase) {
            {
#line 809
            memcpy_uppcase___0(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 809
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
            }
          }
#line 809
          p += _n___2;
        }
#line 809
        i += (size_t )_incr___2;
#line 809
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 811
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 815
    if (modifier == 79) {
#line 816
      goto bad_format;
    }
#line 817
    if (modifier == 69) {
#line 833
      goto underlying_strftime;
    }
#line 838
    century = (int )(tp->tm_year / 100 + 19);
#line 839
    if (tp->tm_year % 100 < 0) {
#line 839
      if (0 < century) {
#line 839
        tmp___9 = 1;
      } else {
#line 839
        tmp___9 = 0;
      }
    } else {
#line 839
      tmp___9 = 0;
    }
#line 839
    century -= tmp___9;
#line 840
    digits = 2;
#line 840
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 840
    u_number_value = (unsigned int )century;
#line 840
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 844
    if (modifier == 79) {
#line 845
      goto bad_format;
    }
#line 854
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 857
    if (modifier != 0) {
#line 858
      goto bad_format;
    }
#line 859
    subfmt = "%m/%d/%y";
#line 860
    goto subformat;
    case_100: /* CIL Label */ 
#line 863
    if (modifier == 69) {
#line 864
      goto bad_format;
    }
#line 866
    digits = 2;
#line 866
    number_value = (int )tp->tm_mday;
#line 866
    goto do_number;
    case_101: /* CIL Label */ 
#line 869
    if (modifier == 69) {
#line 870
      goto bad_format;
    }
#line 872
    digits = 2;
#line 872
    number_value = (int )tp->tm_mday;
#line 872
    goto do_number_spacepad;
    do_tz_offset: 
#line 878
    always_output_a_sign = (_Bool)1;
#line 879
    goto do_number_body;
    do_number_spacepad: 
#line 883
    if (pad != 48) {
#line 883
      if (pad != 45) {
#line 884
        pad = '_';
      }
    }
    do_number: 
#line 888
    negative_number = (_Bool )(number_value < 0);
#line 889
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 892
    always_output_a_sign = (_Bool)0;
#line 893
    tz_colon_mask = 0;
    do_number_body: 
#line 901
    if (modifier == 79) {
#line 901
      if (! negative_number) {
#line 919
        goto underlying_strftime;
      }
    }
#line 923
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 925
    if (negative_number) {
#line 926
      u_number_value = - u_number_value;
    }
    {
#line 928
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 930
      if (tz_colon_mask & 1) {
#line 931
        bufp --;
#line 931
        *bufp = (char )':';
      }
#line 932
      tz_colon_mask >>= 1;
#line 933
      bufp --;
#line 933
      *bufp = (char )(u_number_value % 10U + 48U);
#line 934
      u_number_value /= 10U;
#line 928
      if (! (u_number_value != 0U)) {
#line 928
        if (! (tz_colon_mask != 0)) {
#line 928
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 939
    if (digits < width) {
#line 940
      digits = width;
    }
#line 942
    if (negative_number) {
#line 942
      sign_char = (char )'-';
    } else {
#line 942
      if (always_output_a_sign) {
#line 942
        tmp___10 = '+';
      } else {
#line 942
        tmp___10 = 0;
      }
#line 942
      sign_char = (char )tmp___10;
    }
#line 946
    if (pad == 45) {
#line 948
      if (sign_char) {
        {
#line 949
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 949
          _n___3 = 1;
#line 949
          _delta___3 = width - _n___3;
#line 949
          if (_delta___3 > 0) {
#line 949
            tmp___11 = _delta___3;
          } else {
#line 949
            tmp___11 = 0;
          }
#line 949
          _incr___3 = _n___3 + tmp___11;
#line 949
          if ((size_t )_incr___3 >= maxsize - i) {
#line 949
            return ((size_t )0);
          }
#line 949
          if (p) {
#line 949
            if (digits == 0) {
#line 949
              if (_delta___3 > 0) {
#line 949
                if (pad == 48) {
                  {
#line 949
                  memset((void *)p, '0', (size_t )_delta___3);
#line 949
                  p += _delta___3;
                  }
                } else {
                  {
#line 949
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 949
                  p += _delta___3;
                  }
                }
              }
            }
#line 949
            *p = sign_char;
#line 949
            p += _n___3;
          }
#line 949
          i += (size_t )_incr___3;
#line 949
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 953
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 956
      if (padding > 0) {
#line 958
        if (pad == 95) {
#line 960
          if ((size_t )padding >= maxsize - i) {
#line 961
            return ((size_t )0);
          }
#line 963
          if (p) {
            {
#line 964
            memset((void *)p, ' ', (size_t )padding);
#line 964
            p += padding;
            }
          }
#line 965
          i += (size_t )padding;
#line 966
          if (width > padding) {
#line 966
            width -= padding;
          } else {
#line 966
            width = 0;
          }
#line 967
          if (sign_char) {
            {
#line 968
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 968
              _n___4 = 1;
#line 968
              _delta___4 = width - _n___4;
#line 968
              if (_delta___4 > 0) {
#line 968
                tmp___12 = _delta___4;
              } else {
#line 968
                tmp___12 = 0;
              }
#line 968
              _incr___4 = _n___4 + tmp___12;
#line 968
              if ((size_t )_incr___4 >= maxsize - i) {
#line 968
                return ((size_t )0);
              }
#line 968
              if (p) {
#line 968
                if (digits == 0) {
#line 968
                  if (_delta___4 > 0) {
#line 968
                    if (pad == 48) {
                      {
#line 968
                      memset((void *)p, '0', (size_t )_delta___4);
#line 968
                      p += _delta___4;
                      }
                    } else {
                      {
#line 968
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 968
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 968
                *p = sign_char;
#line 968
                p += _n___4;
              }
#line 968
              i += (size_t )_incr___4;
#line 968
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 972
          if ((size_t )digits >= maxsize - i) {
#line 973
            return ((size_t )0);
          }
#line 975
          if (sign_char) {
            {
#line 976
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 976
              _n___5 = 1;
#line 976
              _delta___5 = width - _n___5;
#line 976
              if (_delta___5 > 0) {
#line 976
                tmp___13 = _delta___5;
              } else {
#line 976
                tmp___13 = 0;
              }
#line 976
              _incr___5 = _n___5 + tmp___13;
#line 976
              if ((size_t )_incr___5 >= maxsize - i) {
#line 976
                return ((size_t )0);
              }
#line 976
              if (p) {
#line 976
                if (digits == 0) {
#line 976
                  if (_delta___5 > 0) {
#line 976
                    if (pad == 48) {
                      {
#line 976
                      memset((void *)p, '0', (size_t )_delta___5);
#line 976
                      p += _delta___5;
                      }
                    } else {
                      {
#line 976
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 976
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 976
                *p = sign_char;
#line 976
                p += _n___5;
              }
#line 976
              i += (size_t )_incr___5;
#line 976
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 978
          if (p) {
            {
#line 979
            memset((void *)p, '0', (size_t )padding);
#line 979
            p += padding;
            }
          }
#line 980
          i += (size_t )padding;
#line 981
          width = 0;
        }
      } else
#line 986
      if (sign_char) {
        {
#line 987
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 987
          _n___6 = 1;
#line 987
          _delta___6 = width - _n___6;
#line 987
          if (_delta___6 > 0) {
#line 987
            tmp___14 = _delta___6;
          } else {
#line 987
            tmp___14 = 0;
          }
#line 987
          _incr___6 = _n___6 + tmp___14;
#line 987
          if ((size_t )_incr___6 >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 987
          if (p) {
#line 987
            if (digits == 0) {
#line 987
              if (_delta___6 > 0) {
#line 987
                if (pad == 48) {
                  {
#line 987
                  memset((void *)p, '0', (size_t )_delta___6);
#line 987
                  p += _delta___6;
                  }
                } else {
                  {
#line 987
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 987
                  p += _delta___6;
                  }
                }
              }
            }
#line 987
            *p = sign_char;
#line 987
            p += _n___6;
          }
#line 987
          i += (size_t )_incr___6;
#line 987
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 991
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 991
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 991
      _delta___7 = width - _n___7;
#line 991
      if (_delta___7 > 0) {
#line 991
        tmp___15 = _delta___7;
      } else {
#line 991
        tmp___15 = 0;
      }
#line 991
      _incr___7 = _n___7 + tmp___15;
#line 991
      if ((size_t )_incr___7 >= maxsize - i) {
#line 991
        return ((size_t )0);
      }
#line 991
      if (p) {
#line 991
        if (digits == 0) {
#line 991
          if (_delta___7 > 0) {
#line 991
            if (pad == 48) {
              {
#line 991
              memset((void *)p, '0', (size_t )_delta___7);
#line 991
              p += _delta___7;
              }
            } else {
              {
#line 991
              memset((void *)p, ' ', (size_t )_delta___7);
#line 991
              p += _delta___7;
              }
            }
          }
        }
#line 991
        if (to_lowcase) {
          {
#line 991
          memcpy_lowcase___0(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 991
        if (to_uppcase) {
          {
#line 991
          memcpy_uppcase___0(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 991
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 (size_t )_n___7);
          }
        }
#line 991
        p += _n___7;
      }
#line 991
      i += (size_t )_incr___7;
#line 991
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 992
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 995
    if (modifier != 0) {
#line 996
      goto bad_format;
    }
#line 997
    subfmt = "%Y-%m-%d";
#line 998
    goto subformat;
    case_72: /* CIL Label */ 
#line 1001
    if (modifier == 69) {
#line 1002
      goto bad_format;
    }
#line 1004
    digits = 2;
#line 1004
    number_value = (int )tp->tm_hour;
#line 1004
    goto do_number;
    case_73: /* CIL Label */ 
#line 1007
    if (modifier == 69) {
#line 1008
      goto bad_format;
    }
#line 1010
    digits = 2;
#line 1010
    number_value = hour12;
#line 1010
    goto do_number;
    case_107: /* CIL Label */ 
#line 1013
    if (modifier == 69) {
#line 1014
      goto bad_format;
    }
#line 1016
    digits = 2;
#line 1016
    number_value = (int )tp->tm_hour;
#line 1016
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1019
    if (modifier == 69) {
#line 1020
      goto bad_format;
    }
#line 1022
    digits = 2;
#line 1022
    number_value = hour12;
#line 1022
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1025
    if (modifier == 69) {
#line 1026
      goto bad_format;
    }
#line 1028
    digits = 3;
#line 1028
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1028
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1028
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1031
    if (modifier == 69) {
#line 1032
      goto bad_format;
    }
#line 1034
    digits = 2;
#line 1034
    number_value = (int )tp->tm_min;
#line 1034
    goto do_number;
    case_109: /* CIL Label */ 
#line 1037
    if (modifier == 69) {
#line 1038
      goto bad_format;
    }
#line 1040
    digits = 2;
#line 1040
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1040
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1040
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1044
    if (modifier == 69) {
#line 1045
      goto bad_format;
    }
#line 1047
    number_value = ns;
#line 1048
    if (width == -1) {
#line 1049
      width = 9;
    } else {
#line 1054
      j = width;
      {
#line 1054
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1054
        if (! (j < 9)) {
#line 1054
          goto while_break___12;
        }
#line 1055
        number_value /= 10;
#line 1054
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1058
    digits = width;
#line 1058
    number_value = number_value;
#line 1058
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1062
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1062
      _n___8 = 1;
#line 1062
      _delta___8 = width - _n___8;
#line 1062
      if (_delta___8 > 0) {
#line 1062
        tmp___16 = _delta___8;
      } else {
#line 1062
        tmp___16 = 0;
      }
#line 1062
      _incr___8 = _n___8 + tmp___16;
#line 1062
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1062
        return ((size_t )0);
      }
#line 1062
      if (p) {
#line 1062
        if (digits == 0) {
#line 1062
          if (_delta___8 > 0) {
#line 1062
            if (pad == 48) {
              {
#line 1062
              memset((void *)p, '0', (size_t )_delta___8);
#line 1062
              p += _delta___8;
              }
            } else {
              {
#line 1062
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1062
              p += _delta___8;
              }
            }
          }
        }
#line 1062
        *p = (char )'\n';
#line 1062
        p += _n___8;
      }
#line 1062
      i += (size_t )_incr___8;
#line 1062
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1063
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1066
    to_lowcase = (_Bool)1;
#line 1068
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1073
    if (change_case) {
#line 1075
      to_uppcase = (_Bool)0;
#line 1076
      to_lowcase = (_Bool)1;
    }
#line 1082
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1086
    subfmt = "%H:%M";
#line 1087
    goto subformat;
    case_114: /* CIL Label */ 
#line 1097
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1101
    if (modifier == 69) {
#line 1102
      goto bad_format;
    }
#line 1104
    digits = 2;
#line 1104
    number_value = (int )tp->tm_sec;
#line 1104
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1111
    ltm = (struct tm )*tp;
#line 1112
    t = mktime(& ltm);
#line 1117
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1118
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1120
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1122
      d = (int )(t % 10L);
#line 1123
      t /= 10L;
#line 1124
      bufp --;
#line 1124
      if (negative_number) {
#line 1124
        tmp___17 = - d;
      } else {
#line 1124
        tmp___17 = d;
      }
#line 1124
      *bufp = (char )(tmp___17 + 48);
#line 1120
      if (! (t != 0L)) {
#line 1120
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1128
    digits = 1;
#line 1129
    always_output_a_sign = (_Bool)0;
#line 1130
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1134
    if (modifier == 79) {
#line 1135
      goto bad_format;
    }
#line 1144
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1147
    subfmt = "%H:%M:%S";
#line 1148
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1151
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1151
      _n___9 = 1;
#line 1151
      _delta___9 = width - _n___9;
#line 1151
      if (_delta___9 > 0) {
#line 1151
        tmp___18 = _delta___9;
      } else {
#line 1151
        tmp___18 = 0;
      }
#line 1151
      _incr___9 = _n___9 + tmp___18;
#line 1151
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1151
        return ((size_t )0);
      }
#line 1151
      if (p) {
#line 1151
        if (digits == 0) {
#line 1151
          if (_delta___9 > 0) {
#line 1151
            if (pad == 48) {
              {
#line 1151
              memset((void *)p, '0', (size_t )_delta___9);
#line 1151
              p += _delta___9;
              }
            } else {
              {
#line 1151
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1151
              p += _delta___9;
              }
            }
          }
        }
#line 1151
        *p = (char )'\t';
#line 1151
        p += _n___9;
      }
#line 1151
      i += (size_t )_incr___9;
#line 1151
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1152
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1155
    digits = 1;
#line 1155
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1155
    goto do_number;
    case_85: /* CIL Label */ 
#line 1158
    if (modifier == 69) {
#line 1159
      goto bad_format;
    }
#line 1161
    digits = 2;
#line 1161
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1161
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1166
    if (modifier == 69) {
#line 1167
      goto bad_format;
    }
#line 1173
    if (tp->tm_year < 0) {
#line 1173
      tmp___19 = 300;
    } else {
#line 1173
      tmp___19 = -100;
    }
    {
#line 1173
    year___1 = (int )(tp->tm_year + (int const   )tmp___19);
#line 1177
    year_adjust = 0;
#line 1178
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1178
    days = tmp___20;
    }
#line 1180
    if (days < 0) {
#line 1183
      year_adjust = -1;
#line 1184
      if ((year___1 - 1) % 4 == 0) {
#line 1184
        if ((year___1 - 1) % 100 != 0) {
#line 1184
          tmp___21 = 1;
        } else
#line 1184
        if ((year___1 - 1) % 400 == 0) {
#line 1184
          tmp___21 = 1;
        } else {
#line 1184
          tmp___21 = 0;
        }
      } else {
#line 1184
        tmp___21 = 0;
      }
      {
#line 1184
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1189
      if (year___1 % 4 == 0) {
#line 1189
        if (year___1 % 100 != 0) {
#line 1189
          tmp___22 = 1;
        } else
#line 1189
        if (year___1 % 400 == 0) {
#line 1189
          tmp___22 = 1;
        } else {
#line 1189
          tmp___22 = 0;
        }
      } else {
#line 1189
        tmp___22 = 0;
      }
      {
#line 1189
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1189
      d___0 = tmp___23;
      }
#line 1191
      if (0 <= d___0) {
#line 1194
        year_adjust = 1;
#line 1195
        days = d___0;
      }
    }
    {
#line 1201
    if ((int const   )*f == 103) {
#line 1201
      goto case_103___0;
    }
#line 1211
    if ((int const   )*f == 71) {
#line 1211
      goto case_71___0;
    }
#line 1216
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1203
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1204
    digits = 2;
#line 1204
    if (0 <= yy) {
#line 1204
      number_value = yy;
    } else {
#line 1204
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1204
        tmp___24 = - yy;
      } else {
#line 1204
        tmp___24 = yy + 100;
      }
#line 1204
      number_value = tmp___24;
    }
#line 1204
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1212
    digits = 4;
#line 1212
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1212
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1212
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1217
    digits = 2;
#line 1217
    number_value = days / 7 + 1;
#line 1217
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1222
    if (modifier == 69) {
#line 1223
      goto bad_format;
    }
#line 1225
    digits = 2;
#line 1225
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1225
    goto do_number;
    case_119: /* CIL Label */ 
#line 1228
    if (modifier == 69) {
#line 1229
      goto bad_format;
    }
#line 1231
    digits = 1;
#line 1231
    number_value = (int )tp->tm_wday;
#line 1231
    goto do_number;
    case_89: /* CIL Label */ 
#line 1234
    if (modifier == 69) {
#line 1248
      goto underlying_strftime;
    }
#line 1251
    if (modifier == 79) {
#line 1252
      goto bad_format;
    } else {
#line 1254
      digits = 4;
    }
#line 1254
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1254
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1254
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1258
    if (modifier == 69) {
#line 1269
      goto underlying_strftime;
    }
#line 1274
    yy___0 = (int )(tp->tm_year % 100);
#line 1275
    if (yy___0 < 0) {
#line 1276
      if (tp->tm_year < -1900) {
#line 1276
        yy___0 = - yy___0;
      } else {
#line 1276
        yy___0 += 100;
      }
    }
#line 1277
    digits = 2;
#line 1277
    number_value = yy___0;
#line 1277
    goto do_number;
    case_90: /* CIL Label */ 
#line 1281
    if (change_case) {
#line 1283
      to_uppcase = (_Bool)0;
#line 1284
      to_lowcase = (_Bool)1;
    }
#line 1292
    if (! zone) {
#line 1293
      zone = "";
    }
    {
#line 1305
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1305
      tmp___25 = strlen(zone);
#line 1305
      _n___10 = (int )tmp___25;
#line 1305
      _delta___10 = width - _n___10;
      }
#line 1305
      if (_delta___10 > 0) {
#line 1305
        tmp___26 = _delta___10;
      } else {
#line 1305
        tmp___26 = 0;
      }
#line 1305
      _incr___10 = _n___10 + tmp___26;
#line 1305
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1305
        return ((size_t )0);
      }
#line 1305
      if (p) {
#line 1305
        if (digits == 0) {
#line 1305
          if (_delta___10 > 0) {
#line 1305
            if (pad == 48) {
              {
#line 1305
              memset((void *)p, '0', (size_t )_delta___10);
#line 1305
              p += _delta___10;
              }
            } else {
              {
#line 1305
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1305
              p += _delta___10;
              }
            }
          }
        }
#line 1305
        if (to_lowcase) {
          {
#line 1305
          memcpy_lowcase___0(p, zone, (size_t )_n___10);
          }
        } else
#line 1305
        if (to_uppcase) {
          {
#line 1305
          memcpy_uppcase___0(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1305
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 (size_t )_n___10);
          }
        }
#line 1305
        p += _n___10;
      }
#line 1305
      i += (size_t )_incr___10;
#line 1305
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1307
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1312
    colons = (size_t )1;
    {
#line 1312
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1312
      if (! ((int const   )*(f + colons) == 58)) {
#line 1312
        goto while_break___17;
      }
#line 1313
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1312
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1314
    if ((int const   )*(f + colons) != 122) {
#line 1315
      goto bad_format;
    }
#line 1316
    f += colons;
#line 1317
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1320
    colons = (size_t )0;
    do_z_conversion: 
#line 1323
    if (tp->tm_isdst < 0) {
#line 1324
      goto switch_break___1;
    }
#line 1332
    diff = (int )tp->tm_gmtoff;
#line 1369
    hour_diff = (diff / 60) / 60;
#line 1370
    min_diff = (diff / 60) % 60;
#line 1371
    sec_diff = diff % 60;
    {
#line 1375
    if (colons == 0UL) {
#line 1375
      goto case_0;
    }
#line 1378
    if (colons == 1UL) {
#line 1378
      goto tz_hh_mm;
    }
#line 1381
    if (colons == 2UL) {
#line 1381
      goto tz_hh_mm_ss;
    }
#line 1385
    if (colons == 3UL) {
#line 1385
      goto case_3;
    }
#line 1392
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1376
    digits = 5;
#line 1376
    negative_number = (_Bool )(diff < 0);
#line 1376
    tz_colon_mask = 0;
#line 1376
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1376
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1379
    digits = 6;
#line 1379
    negative_number = (_Bool )(diff < 0);
#line 1379
    tz_colon_mask = 4;
#line 1379
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1379
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1382
    digits = 9;
#line 1382
    negative_number = (_Bool )(diff < 0);
#line 1382
    tz_colon_mask = 20;
#line 1382
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1382
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1386
    if (sec_diff != 0) {
#line 1387
      goto tz_hh_mm_ss;
    }
#line 1388
    if (min_diff != 0) {
#line 1389
      goto tz_hh_mm;
    }
#line 1390
    digits = 3;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )hour_diff;
#line 1390
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1393
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1398
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1407
    flen = 1;
    {
#line 1407
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1407
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1407
        goto while_break___18;
      }
#line 1408
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1407
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1409
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1409
      _n___11 = flen;
#line 1409
      _delta___11 = width - _n___11;
#line 1409
      if (_delta___11 > 0) {
#line 1409
        tmp___27 = _delta___11;
      } else {
#line 1409
        tmp___27 = 0;
      }
#line 1409
      _incr___11 = _n___11 + tmp___27;
#line 1409
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1409
        return ((size_t )0);
      }
#line 1409
      if (p) {
#line 1409
        if (digits == 0) {
#line 1409
          if (_delta___11 > 0) {
#line 1409
            if (pad == 48) {
              {
#line 1409
              memset((void *)p, '0', (size_t )_delta___11);
#line 1409
              p += _delta___11;
              }
            } else {
              {
#line 1409
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1409
              p += _delta___11;
              }
            }
          }
        }
#line 1409
        if (to_lowcase) {
          {
#line 1409
          memcpy_lowcase___0(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1409
        if (to_uppcase) {
          {
#line 1409
          memcpy_uppcase___0(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1409
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
          }
        }
#line 1409
        p += _n___11;
      }
#line 1409
      i += (size_t )_incr___11;
#line 1409
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1411
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 492
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  if (p) {
#line 1416
    if (maxsize != 0UL) {
#line 1417
      *p = (char )'\000';
    }
  }
#line 1420
  return (i);
}
}
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
static struct numname numname_table___0[35]  = 
#line 41 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000'}}, 
        {2,
      {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000'}}, 
        {3,
      {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
       (char const   )'\000'}}, 
        {4, {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000'}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000'}}, 
        {6, {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
          (char const   )'\000'}}, 
        {8, {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000'}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {7, {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000'}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000'}}, 
        {13, {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
           (char const   )'\000'}}, 
        {14, {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {15, {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {10, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
           (char const   )'\000'}}, 
        {12, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
           (char const   )'\000'}}, 
        {17, {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
           (char const   )'\000'}}, 
        {23, {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000'}}, 
        {19,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000'}}, 
        {20, {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
           (char const   )'\000'}}, 
        {18, {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
           (char const   )'\000'}}, 
        {21, {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
           (char const   )'\000'}}, 
        {22, {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
           (char const   )'\000'}}, 
        {31, {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000'}}, 
        {29,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {26, {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
           (char const   )'R', (char const   )'M', (char const   )'\000'}}, 
        {27, {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
           (char const   )'\000'}}, 
        {24, {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
           (char const   )'\000'}}, 
        {25, {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
           (char const   )'\000'}}, 
        {6, {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000'}}, 
        {17,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000'}}, 
        {30,
      {(char const   )'P', (char const   )'W', (char const   )'R', (char const   )'\000'}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000'}}, 
        {29, {(char const   )'I', (char const   )'O', (char const   )'\000'}}, 
        {16, {(char const   )'S', (char const   )'T', (char const   )'K', (char const   )'F',
           (char const   )'L', (char const   )'T', (char const   )'\000'}}, 
        {0, {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
          (char const   )'\000'}}};
#line 258 "/home/khheo/project/benchmark/coreutils-7.1/lib/sig2str.c"
static int str2signum___0(char const   *signame ) 
{ 
  char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  int tmp___0 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___1 ;
  int rtmax ;
  int tmp___2 ;
  long n___0 ;
  long tmp___3 ;
  long n___1 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 261
  if ((unsigned int )*signame - 48U <= 9U) {
    {
#line 264
    tmp = strtol((char const   */* __restrict  */)signame, (char **/* __restrict  */)(& endp),
                 10);
#line 264
    n = tmp;
    }
#line 265
    if (! *endp) {
#line 265
      if (n <= 64L) {
#line 266
        return ((int )n);
      }
    }
  } else {
#line 271
    i = 0U;
    {
#line 271
    while (1) {
      while_continue: /* CIL Label */ ;
#line 271
      if (! ((unsigned long )i < sizeof(numname_table___0) / sizeof(numname_table___0[0]))) {
#line 271
        goto while_break;
      }
      {
#line 272
      tmp___0 = strcmp(numname_table___0[i].name, signame);
      }
#line 272
      if (tmp___0 == 0) {
#line 273
        return (numname_table___0[i].num);
      }
#line 271
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 277
    tmp___1 = __libc_current_sigrtmin();
#line 277
    rtmin = tmp___1;
#line 278
    tmp___2 = __libc_current_sigrtmax();
#line 278
    rtmax = tmp___2;
    }
#line 280
    if (0 < rtmin) {
      {
#line 280
      tmp___6 = strncmp(signame, "RTMIN", (size_t )5);
      }
#line 280
      if (tmp___6 == 0) {
        {
#line 282
        tmp___3 = strtol((char const   */* __restrict  */)(signame + 5), (char **/* __restrict  */)(& endp___0),
                         10);
#line 282
        n___0 = tmp___3;
        }
#line 283
        if (! *endp___0) {
#line 283
          if (0L <= n___0) {
#line 283
            if (n___0 <= (long )(rtmax - rtmin)) {
#line 284
              return ((int )((long )rtmin + n___0));
            }
          }
        }
      } else {
#line 280
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 286
    if (0 < rtmax) {
      {
#line 286
      tmp___5 = strncmp(signame, "RTMAX", (size_t )5);
      }
#line 286
      if (tmp___5 == 0) {
        {
#line 288
        tmp___4 = strtol((char const   */* __restrict  */)(signame + 5), (char **/* __restrict  */)(& endp___0),
                         10);
#line 288
        n___1 = tmp___4;
        }
#line 289
        if (! *endp___0) {
#line 289
          if ((long )(rtmin - rtmax) <= n___1) {
#line 289
            if (n___1 <= 0L) {
#line 290
              return ((int )((long )rtmax + n___1));
            }
          }
        }
      }
    }
  }
#line 295
  return (-1);
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static unsigned char const   fillbuf___3[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 132 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static void sha512_conclude_ctx___0(struct sha512_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 136
  bytes = ctx->buflen;
#line 137
  if (bytes < 112UL) {
#line 137
    tmp = 16;
  } else {
#line 137
    tmp = 32;
  }
#line 137
  size = (size_t )tmp;
#line 140
  ctx->total[0] += bytes;
#line 141
  if (ctx->total[0] < bytes) {
#line 142
    (ctx->total[1]) ++;
  }
  {
#line 147
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
#line 150
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
#line 153
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf___3),
         (size - 2UL) * 8UL - bytes);
#line 156
  sha512_process_block((void const   *)(ctx->buffer), size * 8UL, ctx);
  }
#line 157
  return;
}
}
#line 408 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha512.c"
static u64 const   sha512_round_constants___0[80]  = 
#line 408
  {      (u64 const   )((1116352408UL << 32) + 3609767458UL),      (u64 const   )((1899447441UL << 32) + 602891725UL),      (u64 const   )((3049323471UL << 32) + 3964484399UL),      (u64 const   )((3921009573UL << 32) + 2173295548UL), 
        (u64 const   )((961987163UL << 32) + 4081628472UL),      (u64 const   )((1508970993UL << 32) + 3053834265UL),      (u64 const   )((2453635748UL << 32) + 2937671579UL),      (u64 const   )((2870763221UL << 32) + 3664609560UL), 
        (u64 const   )((3624381080UL << 32) + 2734883394UL),      (u64 const   )((310598401UL << 32) + 1164996542UL),      (u64 const   )((607225278UL << 32) + 1323610764UL),      (u64 const   )((1426881987UL << 32) + 3590304994UL), 
        (u64 const   )((1925078388UL << 32) + 4068182383UL),      (u64 const   )((2162078206UL << 32) + 991336113UL),      (u64 const   )((2614888103UL << 32) + 633803317UL),      (u64 const   )((3248222580UL << 32) + 3479774868UL), 
        (u64 const   )((3835390401UL << 32) + 2666613458UL),      (u64 const   )((4022224774UL << 32) + 944711139UL),      (u64 const   )((264347078UL << 32) + 2341262773UL),      (u64 const   )((604807628UL << 32) + 2007800933UL), 
        (u64 const   )((770255983UL << 32) + 1495990901UL),      (u64 const   )((1249150122UL << 32) + 1856431235UL),      (u64 const   )((1555081692UL << 32) + 3175218132UL),      (u64 const   )((1996064986UL << 32) + 2198950837UL), 
        (u64 const   )((2554220882UL << 32) + 3999719339UL),      (u64 const   )((2821834349UL << 32) + 766784016UL),      (u64 const   )((2952996808UL << 32) + 2566594879UL),      (u64 const   )((3210313671UL << 32) + 3203337956UL), 
        (u64 const   )((3336571891UL << 32) + 1034457026UL),      (u64 const   )((3584528711UL << 32) + 2466948901UL),      (u64 const   )((113926993UL << 32) + 3758326383UL),      (u64 const   )((338241895UL << 32) + 168717936UL), 
        (u64 const   )((666307205UL << 32) + 1188179964UL),      (u64 const   )((773529912UL << 32) + 1546045734UL),      (u64 const   )((1294757372UL << 32) + 1522805485UL),      (u64 const   )((1396182291UL << 32) + 2643833823UL), 
        (u64 const   )((1695183700UL << 32) + 2343527390UL),      (u64 const   )((1986661051UL << 32) + 1014477480UL),      (u64 const   )((2177026350UL << 32) + 1206759142UL),      (u64 const   )((2456956037UL << 32) + 344077627UL), 
        (u64 const   )((2730485921UL << 32) + 1290863460UL),      (u64 const   )((2820302411UL << 32) + 3158454273UL),      (u64 const   )((3259730800UL << 32) + 3505952657UL),      (u64 const   )((3345764771UL << 32) + 106217008UL), 
        (u64 const   )((3516065817UL << 32) + 3606008344UL),      (u64 const   )((3600352804UL << 32) + 1432725776UL),      (u64 const   )((4094571909UL << 32) + 1467031594UL),      (u64 const   )((275423344UL << 32) + 851169720UL), 
        (u64 const   )((430227734UL << 32) + 3100823752UL),      (u64 const   )((506948616UL << 32) + 1363258195UL),      (u64 const   )((659060556UL << 32) + 3750685593UL),      (u64 const   )((883997877UL << 32) + 3785050280UL), 
        (u64 const   )((958139571UL << 32) + 3318307427UL),      (u64 const   )((1322822218UL << 32) + 3812723403UL),      (u64 const   )((1537002063UL << 32) + 2003034995UL),      (u64 const   )((1747873779UL << 32) + 3602036899UL), 
        (u64 const   )((1955562222UL << 32) + 1575990012UL),      (u64 const   )((2024104815UL << 32) + 1125592928UL),      (u64 const   )((2227730452UL << 32) + 2716904306UL),      (u64 const   )((2361852424UL << 32) + 442776044UL), 
        (u64 const   )((2428436474UL << 32) + 593698344UL),      (u64 const   )((2756734187UL << 32) + 3733110249UL),      (u64 const   )((3204031479UL << 32) + 2999351573UL),      (u64 const   )((3329325298UL << 32) + 3815920427UL), 
        (u64 const   )((3391569614UL << 32) + 3928383900UL),      (u64 const   )((3515267271UL << 32) + 566280711UL),      (u64 const   )((3940187606UL << 32) + 3454069534UL),      (u64 const   )((4118630271UL << 32) + 4000239992UL), 
        (u64 const   )((116418474UL << 32) + 1914138554UL),      (u64 const   )((174292421UL << 32) + 2731055270UL),      (u64 const   )((289380356UL << 32) + 3203993006UL),      (u64 const   )((460393269UL << 32) + 320620315UL), 
        (u64 const   )((685471733UL << 32) + 587496836UL),      (u64 const   )((852142971UL << 32) + 1086792851UL),      (u64 const   )((1017036298UL << 32) + 365543100UL),      (u64 const   )((1126000580UL << 32) + 2618297676UL), 
        (u64 const   )((1288033470UL << 32) + 3409855158UL),      (u64 const   )((1501505948UL << 32) + 4234509866UL),      (u64 const   )((1607167915UL << 32) + 987167468UL),      (u64 const   )((1816402316UL << 32) + 1246189591UL)};
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static unsigned char const   fillbuf___4[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 125 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static void sha256_conclude_ctx___0(struct sha256_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 129
  bytes = ctx->buflen;
#line 130
  if (bytes < 56UL) {
#line 130
    tmp = 16;
  } else {
#line 130
    tmp = 32;
  }
#line 130
  size = (size_t )tmp;
#line 133
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
#line 134
  if ((size_t )ctx->total[0] < bytes) {
#line 135
    (ctx->total[1]) ++;
  }
  {
#line 140
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
#line 142
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
#line 145
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf___4),
         (size - 2UL) * 4UL - bytes);
#line 148
  sha256_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
  }
#line 149
  return;
}
}
#line 400 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha256.c"
static uint32_t const   sha256_round_constants___0[64]  = 
#line 400
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/sha1.c"
static unsigned char const   fillbuf___5[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 44 "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c"
static _Bool savewd_save___0(struct savewd *wd ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 49
  if ((unsigned int )wd->state == 0U) {
#line 49
    goto case_0;
  }
#line 69
  if ((unsigned int )wd->state == 3U) {
#line 69
    goto case_3;
  }
#line 89
  if ((unsigned int )wd->state == 5U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 4U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 2U) {
#line 89
    goto case_5;
  }
#line 89
  if ((unsigned int )wd->state == 1U) {
#line 89
    goto case_5;
  }
#line 92
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 52
  tmp = open_safer(".", 0);
#line 52
  fd = tmp;
  }
#line 53
  if (0 <= fd) {
#line 55
    wd->state = (enum __anonenum_state_467303978 )1;
#line 56
    wd->val.fd = fd;
#line 57
    goto switch_break;
  }
  {
#line 59
  tmp___1 = __errno_location();
  }
#line 59
  if (*tmp___1 != 13) {
    {
#line 59
    tmp___2 = __errno_location();
    }
#line 59
    if (*tmp___2 != 116) {
      {
#line 61
      wd->state = (enum __anonenum_state_467303978 )4;
#line 62
      tmp___0 = __errno_location();
#line 62
      wd->val.errnum = *tmp___0;
      }
#line 63
      goto switch_break;
    }
  }
#line 66
  wd->state = (enum __anonenum_state_467303978 )3;
#line 67
  wd->val.child = -1;
  case_3: /* CIL Label */ 
#line 70
  if (wd->val.child < 0) {
    {
#line 75
    wd->val.child = fork();
    }
#line 76
    if (wd->val.child != 0) {
#line 78
      if (0 < wd->val.child) {
#line 79
        return ((_Bool)1);
      }
      {
#line 80
      wd->state = (enum __anonenum_state_467303978 )4;
#line 81
      tmp___3 = __errno_location();
#line 81
      wd->val.errnum = *tmp___3;
      }
    }
  }
#line 84
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 90
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 93
  __assert_fail("false", "/home/khheo/project/benchmark/coreutils-7.1/lib/savewd.c",
                93U, "savewd_save");
  }
  switch_break: /* CIL Label */ ;
  }
#line 96
  return ((_Bool)0);
}
}
#line 68 "/home/khheo/project/benchmark/coreutils-7.1/lib/chdir-long.c"
static int cdb_advance_fd___0(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 71
  tmp = openat(cdb->fd, dir, 67840);
#line 71
  new_fd = tmp;
  }
#line 73
  if (new_fd < 0) {
#line 74
    return (-1);
  }
  {
#line 76
  cdb_free((struct cd_buf  const  *)cdb);
#line 77
  cdb->fd = new_fd;
  }
#line 79
  return (0);
}
}
#line 56 "/home/khheo/project/benchmark/coreutils-7.1/lib/savedir.c"
static char *savedirstream___0(DIR *dirp ) 
{ 
  char *name_space ;
  size_t allocated___0 ;
  size_t used___0 ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 60
  allocated___0 = (size_t )512;
#line 61
  used___0 = (size_t )0;
#line 64
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 65
    return ((char *)((void *)0));
  }
  {
#line 67
  tmp = xmalloc(allocated___0);
#line 67
  name_space = (char *)tmp;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp___0 = __errno_location();
#line 74
    *tmp___0 = 0;
#line 75
    tmp___1 = readdir(dirp);
#line 75
    dp = (struct dirent  const  *)tmp___1;
    }
#line 76
    if (! dp) {
#line 77
      goto while_break;
    }
#line 81
    entry = (char const   *)(dp->d_name);
#line 82
    if ((int const   )*(entry + 0) != 46) {
#line 82
      tmp___5 = 0;
    } else {
#line 82
      if ((int const   )*(entry + 1) != 46) {
#line 82
        tmp___4 = 1;
      } else {
#line 82
        tmp___4 = 2;
      }
#line 82
      tmp___5 = tmp___4;
    }
#line 82
    if ((int const   )*(entry + tmp___5) != 0) {
      {
#line 84
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 84
      entry_size = tmp___2 + 1UL;
      }
#line 85
      if (used___0 + entry_size < used___0) {
        {
#line 86
        xalloc_die();
        }
      }
#line 87
      if (allocated___0 <= used___0 + entry_size) {
        {
#line 89
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 91
          if (2UL * allocated___0 < allocated___0) {
            {
#line 92
            xalloc_die();
            }
          }
#line 93
          allocated___0 *= 2UL;
#line 89
          if (! (allocated___0 <= used___0 + entry_size)) {
#line 89
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 97
        tmp___3 = xrealloc((void *)name_space, allocated___0);
#line 97
        name_space = (char *)tmp___3;
        }
      }
      {
#line 99
      memcpy((void */* __restrict  */)(name_space + used___0), (void const   */* __restrict  */)entry,
             entry_size);
#line 100
      used___0 += entry_size;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  *(name_space + used___0) = (char )'\000';
#line 104
  tmp___6 = __errno_location();
#line 104
  save_errno = *tmp___6;
#line 105
  tmp___8 = closedir(dirp);
  }
#line 105
  if (tmp___8 != 0) {
    {
#line 106
    tmp___7 = __errno_location();
#line 106
    save_errno = *tmp___7;
    }
  }
#line 107
  if (save_errno != 0) {
    {
#line 109
    free((void *)name_space);
#line 110
    tmp___9 = __errno_location();
#line 110
    *tmp___9 = save_errno;
    }
#line 111
    return ((char *)((void *)0));
  }
#line 113
  return (name_space);
}
}
#line 429 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
static reg_errcode_t re_string_realloc_buffers___0(re_string_t *pstr , Idx new_buf_len ) ;
#line 433
static void build_wcs_buffer___0(re_string_t *pstr ) ;
#line 434
static reg_errcode_t build_wcs_upper_buffer___0(re_string_t *pstr ) ;
#line 437
static void build_upper_buffer___0(re_string_t *pstr ) ;
#line 438
static void re_string_translate_buffer___0(re_string_t *pstr ) ;
#line 439
static unsigned int re_string_context_at___0(re_string_t const   *input , Idx idx ,
                                             int eflags )  __attribute__((__pure__)) ;
#line 827 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.h"
static int __attribute__((__pure__))  re_string_elem_size_at___0(re_string_t const   *pstr ,
                                                                 Idx idx ) 
{ 


  {
#line 851
  return ((int __attribute__((__pure__))  )1);
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_construct_common___0(char const   *str , Idx len , re_string_t *pstr ,
                                           unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) ;
#line 25
static re_dfastate_t *create_ci_newstate___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                             re_hashval_t hash ) ;
#line 28
static re_dfastate_t *create_cd_newstate___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                             unsigned int context , re_hashval_t hash ) ;
#line 38 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_allocate___0(re_string_t *pstr , char const   *str ,
                                            Idx len , Idx init_len , unsigned char *trans ,
                                            _Bool icase , re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  Idx init_buf_len ;
  long tmp ;

  {
#line 47
  if (init_len < (Idx )dfa->mb_cur_max) {
#line 48
    init_len = (Idx )dfa->mb_cur_max;
  }
#line 49
  if (len + 1UL < init_len) {
#line 49
    init_buf_len = len + 1UL;
  } else {
#line 49
    init_buf_len = init_len;
  }
  {
#line 50
  re_string_construct_common___0(str, len, pstr, trans, icase, dfa);
#line 52
  ret = re_string_realloc_buffers___0(pstr, init_buf_len);
#line 53
  tmp = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 53
  if (tmp) {
#line 54
    return (ret);
  }
#line 56
  pstr->word_char = (re_const_bitset_ptr_t )(dfa->word_char);
#line 57
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
#line 58
  if (pstr->mbs_allocated) {
#line 58
    pstr->mbs = pstr->mbs;
  } else {
#line 58
    pstr->mbs = (unsigned char *)str;
  }
#line 59
  if (pstr->mbs_allocated) {
#line 59
    pstr->valid_len = (Idx )0;
  } else
#line 59
  if (dfa->mb_cur_max > 1) {
#line 59
    pstr->valid_len = (Idx )0;
  } else {
#line 59
    pstr->valid_len = len;
  }
#line 60
  pstr->valid_raw_len = pstr->valid_len;
#line 61
  return ((reg_errcode_t )0);
}
}
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_construct___0(re_string_t *pstr , char const   *str ,
                                             Idx len , unsigned char *trans , _Bool icase ,
                                             re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 72
  memset((void *)pstr, '\000', sizeof(re_string_t ));
#line 73
  re_string_construct_common___0(str, len, pstr, trans, icase, dfa);
  }
#line 75
  if (len > 0UL) {
    {
#line 77
    ret = re_string_realloc_buffers___0(pstr, len + 1UL);
#line 78
    tmp = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 78
    if (tmp) {
#line 79
      return (ret);
    }
  }
#line 81
  if (pstr->mbs_allocated) {
#line 81
    pstr->mbs = pstr->mbs;
  } else {
#line 81
    pstr->mbs = (unsigned char *)str;
  }
#line 83
  if (icase) {
#line 86
    if (dfa->mb_cur_max > 1) {
      {
#line 88
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 90
        ret = build_wcs_upper_buffer___0(pstr);
#line 91
        tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 91
        if (tmp___0) {
#line 92
          return (ret);
        }
#line 93
        if (pstr->valid_raw_len >= len) {
#line 94
          goto while_break;
        }
#line 95
        if (pstr->bufs_len > pstr->valid_len + (Idx )dfa->mb_cur_max) {
#line 96
          goto while_break;
        }
        {
#line 97
        ret = re_string_realloc_buffers___0(pstr, pstr->bufs_len * 2UL);
#line 98
        tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 98
        if (tmp___1) {
#line 99
          return (ret);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 104
      build_upper_buffer___0(pstr);
      }
    }
  } else
#line 109
  if (dfa->mb_cur_max > 1) {
    {
#line 110
    build_wcs_buffer___0(pstr);
    }
  } else
#line 114
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
#line 115
    re_string_translate_buffer___0(pstr);
    }
  } else {
#line 118
    pstr->valid_len = pstr->bufs_len;
#line 119
    pstr->valid_raw_len = pstr->bufs_len;
  }
#line 124
  return ((reg_errcode_t )0);
}
}
#line 129 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_realloc_buffers___0(re_string_t *pstr , Idx new_buf_len ) 
{ 
  wint_t *new_wcs ;
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  Idx *new_offsets ;
  void *tmp___3 ;
  long tmp___4 ;
  unsigned char *new_mbs ;
  void *tmp___5 ;
  long tmp___6 ;

  {
#line 134
  if (pstr->mb_cur_max > 1) {
#line 139
    if (sizeof(wint_t ) < sizeof(Idx )) {
#line 139
      tmp = sizeof(Idx );
    } else {
#line 139
      tmp = sizeof(wint_t );
    }
    {
#line 139
    max_object_size = tmp;
#line 140
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < new_buf_len),
                               0L);
    }
#line 140
    if (tmp___0) {
#line 141
      return ((reg_errcode_t )12);
    }
    {
#line 143
    tmp___1 = realloc((void *)pstr->wcs, new_buf_len * sizeof(wint_t ));
#line 143
    new_wcs = (wint_t *)tmp___1;
#line 144
    tmp___2 = __builtin_expect((long )((unsigned long )new_wcs == (unsigned long )((void *)0)),
                               0L);
    }
#line 144
    if (tmp___2) {
#line 145
      return ((reg_errcode_t )12);
    }
#line 146
    pstr->wcs = new_wcs;
#line 147
    if ((unsigned long )pstr->offsets != (unsigned long )((void *)0)) {
      {
#line 149
      tmp___3 = realloc((void *)pstr->offsets, new_buf_len * sizeof(Idx ));
#line 149
      new_offsets = (Idx *)tmp___3;
#line 150
      tmp___4 = __builtin_expect((long )((unsigned long )new_offsets == (unsigned long )((void *)0)),
                                 0L);
      }
#line 150
      if (tmp___4) {
#line 151
        return ((reg_errcode_t )12);
      }
#line 152
      pstr->offsets = new_offsets;
    }
  }
#line 156
  if (pstr->mbs_allocated) {
    {
#line 158
    tmp___5 = realloc((void *)pstr->mbs, new_buf_len * sizeof(unsigned char ));
#line 158
    new_mbs = (unsigned char *)tmp___5;
#line 160
    tmp___6 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
    }
#line 160
    if (tmp___6) {
#line 161
      return ((reg_errcode_t )12);
    }
#line 162
    pstr->mbs = new_mbs;
  }
#line 164
  pstr->bufs_len = new_buf_len;
#line 165
  return ((reg_errcode_t )0);
}
}
#line 169 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_construct_common___0(char const   *str , Idx len , re_string_t *pstr ,
                                           unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  int tmp ;

  {
#line 175
  pstr->raw_mbs = (unsigned char const   *)str;
#line 176
  pstr->len = len;
#line 177
  pstr->raw_len = len;
#line 178
  pstr->trans = trans;
#line 179
  pstr->icase = (unsigned char )icase;
#line 180
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 180
    tmp = 1;
  } else
#line 180
  if (icase) {
#line 180
    tmp = 1;
  } else {
#line 180
    tmp = 0;
  }
#line 180
  pstr->mbs_allocated = (unsigned char )tmp;
#line 181
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
#line 182
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
#line 183
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
#line 184
  pstr->stop = pstr->len;
#line 185
  pstr->raw_stop = pstr->stop;
#line 186
  return;
}
}
#line 201 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void build_wcs_buffer___0(re_string_t *pstr ) 
{ 
  unsigned char buf___1[64] ;
  mbstate_t prev_st ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i ;
  int ch ;
  unsigned char tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 217
  if (pstr->bufs_len > pstr->len) {
#line 217
    end_idx = pstr->len;
  } else {
#line 217
    end_idx = pstr->bufs_len;
  }
#line 218
  byte_idx = pstr->valid_len;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (byte_idx < end_idx)) {
#line 218
      goto while_break;
    }
    {
#line 223
    remain_len = end_idx - byte_idx;
#line 224
    prev_st = pstr->cur_state;
#line 226
    tmp___0 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                               0L);
    }
#line 226
    if (tmp___0) {
#line 230
      i = 0;
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (i < pstr->mb_cur_max) {
#line 230
          if (! ((Idx )i < remain_len)) {
#line 230
            goto while_break___0;
          }
        } else {
#line 230
          goto while_break___0;
        }
#line 232
        ch = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + byte_idx) + (Idx )i));
#line 233
        tmp = *(pstr->trans + ch);
#line 233
        *(pstr->mbs + (byte_idx + (Idx )i)) = tmp;
#line 233
        buf___1[i] = tmp;
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 235
      p = (char const   *)(buf___1);
    } else {
#line 238
      p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx;
    }
    {
#line 239
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                     remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 240
    tmp___4 = __builtin_expect((long )(mbclen == 0xfffffffffffffffeUL), 0L);
    }
#line 240
    if (tmp___4) {
#line 243
      pstr->cur_state = prev_st;
#line 244
      goto while_break;
    } else {
#line 246
      if (mbclen == 0xffffffffffffffffUL) {
#line 246
        tmp___2 = 1;
      } else
#line 246
      if (mbclen == 0UL) {
#line 246
        tmp___2 = 1;
      } else {
#line 246
        tmp___2 = 0;
      }
      {
#line 246
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
      }
#line 246
      if (tmp___3) {
        {
#line 249
        mbclen = (size_t )1;
#line 250
        wc = (wchar_t )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 251
        tmp___1 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                   0L);
        }
#line 251
        if (tmp___1) {
#line 252
          wc = (wchar_t )*(pstr->trans + wc);
        }
#line 253
        pstr->cur_state = prev_st;
      }
    }
#line 257
    tmp___5 = byte_idx;
#line 257
    byte_idx ++;
#line 257
    *(pstr->wcs + tmp___5) = (wint_t )wc;
#line 259
    remain_len = (byte_idx + mbclen) - 1UL;
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      if (! (byte_idx < remain_len)) {
#line 259
        goto while_break___1;
      }
#line 260
      tmp___6 = byte_idx;
#line 260
      byte_idx ++;
#line 260
      *(pstr->wcs + tmp___6) = 4294967295U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  pstr->valid_len = byte_idx;
#line 263
  pstr->valid_raw_len = byte_idx;
#line 264
  return;
}
}
#line 269 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t build_wcs_upper_buffer___0(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  Idx src_idx ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  char buf___1[64] ;
  wchar_t wc ;
  int tmp ;
  int tmp___0 ;
  wchar_t wcu ;
  size_t mbcdlen ;
  wint_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  int ch ;
  Idx tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i ;
  int ch___0 ;
  long tmp___9 ;
  wchar_t wcu___0 ;
  size_t mbcdlen___0 ;
  wint_t tmp___10 ;
  size_t i___0 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  size_t i___1 ;
  long tmp___15 ;
  Idx tmp___16 ;
  Idx tmp___17 ;
  int ch___1 ;
  long tmp___18 ;
  long tmp___19 ;
  Idx tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
#line 283
  byte_idx = pstr->valid_len;
#line 284
  if (pstr->bufs_len > pstr->len) {
#line 284
    end_idx = pstr->len;
  } else {
#line 284
    end_idx = pstr->bufs_len;
  }
#line 288
  if (! pstr->map_notascii) {
#line 288
    if ((unsigned long )pstr->trans == (unsigned long )((void *)0)) {
#line 288
      if (! pstr->offsets_needed) {
        {
#line 290
        while (1) {
          while_continue: /* CIL Label */ ;
#line 290
          if (! (byte_idx < end_idx)) {
#line 290
            goto while_break;
          }
#line 294
          if (((int const   )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)) & -128) == 0) {
            {
#line 294
            tmp___0 = mbsinit((mbstate_t const   *)(& pstr->cur_state));
            }
#line 294
            if (tmp___0) {
              {
#line 298
              tmp = toupper((int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
#line 298
              *(pstr->mbs + byte_idx) = (unsigned char )tmp;
#line 302
              *(pstr->wcs + byte_idx) = (wint_t )((wchar_t )*(pstr->mbs + byte_idx));
#line 303
              byte_idx ++;
              }
#line 304
              goto while_continue;
            }
          }
          {
#line 307
          remain_len = end_idx - byte_idx;
#line 308
          prev_st = pstr->cur_state;
#line 309
          mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                           remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 312
          tmp___8 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
          }
#line 312
          if (tmp___8) {
            {
#line 314
            wcu = wc;
#line 315
            tmp___3 = iswlower((wint_t )wc);
            }
#line 315
            if (tmp___3) {
              {
#line 319
              tmp___1 = towupper((wint_t )wc);
#line 319
              wcu = (wchar_t )tmp___1;
#line 320
              mbcdlen = wcrtomb((char */* __restrict  */)(buf___1), wcu, (mbstate_t */* __restrict  */)(& prev_st));
#line 321
              tmp___2 = __builtin_expect((long )(mbclen == mbcdlen), 1L);
              }
#line 321
              if (tmp___2) {
                {
#line 322
                memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                       mbclen);
                }
              } else {
#line 325
                src_idx = byte_idx;
#line 326
                goto offsets_needed;
              }
            } else {
              {
#line 330
              memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                     mbclen);
              }
            }
#line 332
            tmp___4 = byte_idx;
#line 332
            byte_idx ++;
#line 332
            *(pstr->wcs + tmp___4) = (wint_t )wcu;
#line 334
            remain_len = (byte_idx + mbclen) - 1UL;
            {
#line 334
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 334
              if (! (byte_idx < remain_len)) {
#line 334
                goto while_break___0;
              }
#line 335
              tmp___5 = byte_idx;
#line 335
              byte_idx ++;
#line 335
              *(pstr->wcs + tmp___5) = 4294967295U;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 337
          if (mbclen == 0xffffffffffffffffUL) {
#line 337
            goto _L;
          } else
#line 337
          if (mbclen == 0UL) {
            _L: /* CIL Label */ 
            {
#line 340
            ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 341
            *(pstr->mbs + byte_idx) = (unsigned char )ch;
#line 343
            tmp___6 = byte_idx;
#line 343
            byte_idx ++;
#line 343
            *(pstr->wcs + tmp___6) = (wint_t )ch;
#line 344
            tmp___7 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
            }
#line 344
            if (tmp___7) {
#line 345
              pstr->cur_state = prev_st;
            }
          } else {
#line 350
            pstr->cur_state = prev_st;
#line 351
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 354
        pstr->valid_len = byte_idx;
#line 355
        pstr->valid_raw_len = byte_idx;
#line 356
        return ((reg_errcode_t )0);
      } else {
#line 288
        goto _L___2;
      }
    } else {
#line 288
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 359
    src_idx = pstr->valid_raw_len;
    {
#line 359
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 359
      if (! (byte_idx < end_idx)) {
#line 359
        goto while_break___1;
      }
      offsets_needed: 
      {
#line 364
      remain_len = end_idx - byte_idx;
#line 365
      prev_st = pstr->cur_state;
#line 366
      tmp___9 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 366
      if (tmp___9) {
#line 370
        i = 0;
        {
#line 370
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 370
          if (i < pstr->mb_cur_max) {
#line 370
            if (! ((Idx )i < remain_len)) {
#line 370
              goto while_break___2;
            }
          } else {
#line 370
            goto while_break___2;
          }
#line 372
          ch___0 = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + src_idx) + (Idx )i));
#line 373
          buf___1[i] = (char )*(pstr->trans + ch___0);
#line 370
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 375
        p = (char const   *)(buf___1);
      } else {
#line 378
        p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + src_idx;
      }
      {
#line 379
      mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc___0), (char const   */* __restrict  */)p,
                       remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
#line 380
      tmp___22 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
      }
#line 380
      if (tmp___22) {
        {
#line 382
        wcu___0 = wc___0;
#line 383
        tmp___14 = iswlower((wint_t )wc___0);
        }
#line 383
        if (tmp___14) {
          {
#line 387
          tmp___10 = towupper((wint_t )wc___0);
#line 387
          wcu___0 = (wchar_t )tmp___10;
#line 388
          mbcdlen___0 = wcrtomb((char */* __restrict  */)(buf___1), wcu___0, (mbstate_t */* __restrict  */)(& prev_st));
#line 389
          tmp___13 = __builtin_expect((long )(mbclen == mbcdlen___0), 1L);
          }
#line 389
          if (tmp___13) {
            {
#line 390
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                   mbclen);
            }
          } else
#line 391
          if (mbcdlen___0 != 0xffffffffffffffffUL) {
#line 395
            if (byte_idx + mbcdlen___0 > pstr->bufs_len) {
#line 397
              pstr->cur_state = prev_st;
#line 398
              goto while_break___1;
            }
#line 401
            if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
              {
#line 403
              tmp___11 = malloc(pstr->bufs_len * sizeof(Idx ));
#line 403
              pstr->offsets = (Idx *)tmp___11;
              }
#line 405
              if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
#line 406
                return ((reg_errcode_t )12);
              }
            }
#line 408
            if (! pstr->offsets_needed) {
#line 410
              i___0 = (size_t )0;
              {
#line 410
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 410
                if (! (i___0 < byte_idx)) {
#line 410
                  goto while_break___3;
                }
#line 411
                *(pstr->offsets + i___0) = i___0;
#line 410
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 412
              pstr->offsets_needed = (unsigned char)1;
            }
            {
#line 415
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf___1),
                   mbcdlen___0);
#line 416
            *(pstr->wcs + byte_idx) = (wint_t )wcu___0;
#line 417
            *(pstr->offsets + byte_idx) = src_idx;
#line 418
            i___0 = (size_t )1;
            }
            {
#line 418
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 418
              if (! (i___0 < mbcdlen___0)) {
#line 418
                goto while_break___4;
              }
#line 420
              if (i___0 < mbclen) {
#line 420
                tmp___12 = i___0;
              } else {
#line 420
                tmp___12 = mbclen - 1UL;
              }
#line 420
              *(pstr->offsets + (byte_idx + i___0)) = src_idx + tmp___12;
#line 422
              *(pstr->wcs + (byte_idx + i___0)) = 4294967295U;
#line 418
              i___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 424
            pstr->len += mbcdlen___0 - mbclen;
#line 425
            if (pstr->raw_stop > src_idx) {
#line 426
              pstr->stop += mbcdlen___0 - mbclen;
            }
#line 427
            if (pstr->bufs_len > pstr->len) {
#line 427
              end_idx = pstr->len;
            } else {
#line 427
              end_idx = pstr->bufs_len;
            }
#line 429
            byte_idx += mbcdlen___0;
#line 430
            src_idx += mbclen;
#line 431
            goto __Cont;
          } else {
            {
#line 434
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                   mbclen);
            }
          }
        } else {
          {
#line 437
          memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                 mbclen);
          }
        }
        {
#line 439
        tmp___15 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
        }
#line 439
        if (tmp___15) {
#line 442
          i___1 = (size_t )0;
          {
#line 442
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 442
            if (! (i___1 < mbclen)) {
#line 442
              goto while_break___5;
            }
#line 443
            *(pstr->offsets + (byte_idx + i___1)) = src_idx + i___1;
#line 442
            i___1 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 445
        src_idx += mbclen;
#line 447
        tmp___16 = byte_idx;
#line 447
        byte_idx ++;
#line 447
        *(pstr->wcs + tmp___16) = (wint_t )wcu___0;
#line 449
        remain_len = (byte_idx + mbclen) - 1UL;
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 449
          if (! (byte_idx < remain_len)) {
#line 449
            goto while_break___6;
          }
#line 450
          tmp___17 = byte_idx;
#line 450
          byte_idx ++;
#line 450
          *(pstr->wcs + tmp___17) = 4294967295U;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 452
      if (mbclen == 0xffffffffffffffffUL) {
#line 452
        goto _L___0;
      } else
#line 452
      if (mbclen == 0UL) {
        _L___0: /* CIL Label */ 
        {
#line 455
        ch___1 = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + src_idx));
#line 457
        tmp___18 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 457
        if (tmp___18) {
#line 458
          ch___1 = (int )*(pstr->trans + ch___1);
        }
        {
#line 459
        *(pstr->mbs + byte_idx) = (unsigned char )ch___1;
#line 461
        tmp___19 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
        }
#line 461
        if (tmp___19) {
#line 462
          *(pstr->offsets + byte_idx) = src_idx;
        }
        {
#line 463
        src_idx ++;
#line 466
        tmp___20 = byte_idx;
#line 466
        byte_idx ++;
#line 466
        *(pstr->wcs + tmp___20) = (wint_t )ch___1;
#line 467
        tmp___21 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
        }
#line 467
        if (tmp___21) {
#line 468
          pstr->cur_state = prev_st;
        }
      } else {
#line 473
        pstr->cur_state = prev_st;
#line 474
        goto while_break___1;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 477
  pstr->valid_len = byte_idx;
#line 478
  pstr->valid_raw_len = src_idx;
#line 479
  return ((reg_errcode_t )0);
}
}
#line 485 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx re_string_skip_chars___0(re_string_t *pstr , Idx new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  Idx rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  Idx remain_len ;
  int tmp ;
  long tmp___0 ;

  {
#line 492
  wc = 4294967295U;
#line 495
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (rawbuf_idx < new_raw_idx)) {
#line 495
      goto while_break;
    }
    {
#line 500
    remain_len = pstr->len - rawbuf_idx;
#line 501
    prev_st = pstr->cur_state;
#line 502
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)pstr->raw_mbs + rawbuf_idx),
                     remain_len, (mbstate_t */* __restrict  */)(& pstr->cur_state));
    }
#line 504
    if (mbclen == 0xfffffffffffffffeUL) {
#line 504
      tmp = 1;
    } else
#line 504
    if (mbclen == 0xffffffffffffffffUL) {
#line 504
      tmp = 1;
    } else
#line 504
    if (mbclen == 0UL) {
#line 504
      tmp = 1;
    } else {
#line 504
      tmp = 0;
    }
    {
#line 504
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 504
    if (tmp___0) {
#line 507
      if (mbclen == 0UL) {
#line 508
        wc = (wint_t )0;
      } else
#line 507
      if (remain_len == 0UL) {
#line 508
        wc = (wint_t )0;
      } else {
#line 510
        wc = (wint_t )*((unsigned char *)(pstr->raw_mbs + rawbuf_idx));
      }
#line 511
      mbclen = (size_t )1;
#line 512
      pstr->cur_state = prev_st;
    } else {
#line 515
      wc = (wint_t )wc2;
    }
#line 517
    rawbuf_idx += mbclen;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  *last_wc = wc;
#line 520
  return (rawbuf_idx);
}
}
#line 527 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void build_upper_buffer___0(re_string_t *pstr ) 
{ 
  Idx char_idx ;
  Idx end_idx ;
  int ch ;
  long tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 532
  if (pstr->bufs_len > pstr->len) {
#line 532
    end_idx = pstr->len;
  } else {
#line 532
    end_idx = pstr->bufs_len;
  }
#line 534
  char_idx = pstr->valid_len;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (char_idx < end_idx)) {
#line 534
      goto while_break;
    }
    {
#line 536
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 537
    tmp = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                           0L);
    }
#line 537
    if (tmp) {
#line 538
      ch = (int )*(pstr->trans + ch);
    }
    {
#line 539
    tmp___1 = __ctype_b_loc();
    }
#line 539
    if ((int const   )*(*tmp___1 + ch) & 512) {
      {
#line 540
      tmp___0 = toupper(ch);
#line 540
      *(pstr->mbs + char_idx) = (unsigned char )tmp___0;
      }
    } else {
#line 542
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
#line 534
    char_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  pstr->valid_len = char_idx;
#line 545
  pstr->valid_raw_len = char_idx;
#line 546
  return;
}
}
#line 550 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_translate_buffer___0(re_string_t *pstr ) 
{ 
  Idx buf_idx ;
  Idx end_idx ;
  int ch ;

  {
#line 555
  if (pstr->bufs_len > pstr->len) {
#line 555
    end_idx = pstr->len;
  } else {
#line 555
    end_idx = pstr->bufs_len;
  }
#line 557
  buf_idx = pstr->valid_len;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (buf_idx < end_idx)) {
#line 557
      goto while_break;
    }
#line 559
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 560
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
#line 557
    buf_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  pstr->valid_len = buf_idx;
#line 564
  pstr->valid_raw_len = buf_idx;
#line 565
  return;
}
}
#line 571 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_string_reconstruct___0(re_string_t *pstr , Idx idx , int eflags ) 
{ 
  Idx offset ;
  long tmp ;
  Idx low ;
  Idx high ;
  Idx mid ;
  long tmp___0 ;
  long tmp___1 ;
  Idx prev_valid_len ;
  long tmp___2 ;
  Idx wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  Idx mlen ;
  unsigned char buf___1[6] ;
  size_t mbclen ;
  int i ;
  Idx tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int c ;
  int tmp___13 ;
  _Bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
  {
#line 577
  tmp = __builtin_expect((long )(pstr->raw_mbs_idx <= idx), 0L);
  }
#line 577
  if (tmp) {
#line 578
    offset = idx - pstr->raw_mbs_idx;
  } else {
#line 583
    if (pstr->mb_cur_max > 1) {
      {
#line 584
      memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
      }
    }
#line 586
    pstr->len = pstr->raw_len;
#line 587
    pstr->stop = pstr->raw_stop;
#line 588
    pstr->valid_len = (Idx )0;
#line 589
    pstr->raw_mbs_idx = (Idx )0;
#line 590
    pstr->valid_raw_len = (Idx )0;
#line 591
    pstr->offsets_needed = (unsigned char)0;
#line 592
    if (eflags & 1) {
#line 592
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 592
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 594
    if (! pstr->mbs_allocated) {
#line 595
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
#line 596
    offset = idx;
  }
  {
#line 599
  tmp___17 = __builtin_expect((long )(offset != 0UL), 1L);
  }
#line 599
  if (tmp___17) {
    {
#line 602
    tmp___15 = __builtin_expect((long )(offset < pstr->valid_raw_len), 1L);
    }
#line 602
    if (tmp___15) {
      {
#line 606
      tmp___1 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 606
      if (tmp___1) {
#line 608
        low = (Idx )0;
#line 608
        high = pstr->valid_len;
        {
#line 609
        while (1) {
          while_continue: /* CIL Label */ ;
#line 611
          mid = (high + low) / 2UL;
#line 612
          if (*(pstr->offsets + mid) > offset) {
#line 613
            high = mid;
          } else
#line 614
          if (*(pstr->offsets + mid) < offset) {
#line 615
            low = mid + 1UL;
          } else {
#line 617
            goto while_break;
          }
#line 609
          if (! (low < high)) {
#line 609
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 620
        if (*(pstr->offsets + mid) < offset) {
#line 621
          mid ++;
        }
        {
#line 622
        pstr->tip_context = re_string_context_at___0((re_string_t const   *)pstr,
                                                     mid - 1UL, eflags);
        }
#line 628
        if (pstr->valid_len > offset) {
#line 628
          if (mid == offset) {
#line 628
            if (*(pstr->offsets + mid) == offset) {
              {
#line 631
              memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
#line 633
              memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
#line 634
              pstr->valid_len -= offset;
#line 635
              pstr->valid_raw_len -= offset;
#line 636
              low = (Idx )0;
              }
              {
#line 636
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 636
                if (! (low < pstr->valid_len)) {
#line 636
                  goto while_break___0;
                }
#line 637
                *(pstr->offsets + low) = *(pstr->offsets + (low + offset)) - offset;
#line 636
                low ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
#line 628
              goto _L___0;
            }
          } else {
#line 628
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 643
          pstr->len = (pstr->raw_len - idx) + offset;
#line 644
          pstr->stop = (pstr->raw_stop - idx) + offset;
#line 645
          pstr->offsets_needed = (unsigned char)0;
          {
#line 646
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 646
            if (mid > 0UL) {
#line 646
              if (! (*(pstr->offsets + (mid - 1UL)) == offset)) {
#line 646
                goto while_break___1;
              }
            } else {
#line 646
              goto while_break___1;
            }
#line 647
            mid --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 648
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 648
            if (! (mid < pstr->valid_len)) {
#line 648
              goto while_break___2;
            }
#line 649
            if (*(pstr->wcs + mid) != 4294967295U) {
#line 650
              goto while_break___2;
            } else {
#line 652
              mid ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 653
          if (mid == pstr->valid_len) {
#line 654
            pstr->valid_len = (Idx )0;
          } else {
#line 657
            pstr->valid_len = *(pstr->offsets + mid) - offset;
#line 658
            if (pstr->valid_len) {
#line 660
              low = (Idx )0;
              {
#line 660
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 660
                if (! (low < pstr->valid_len)) {
#line 660
                  goto while_break___3;
                }
#line 661
                *(pstr->wcs + low) = 4294967295U;
#line 660
                low ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 662
              memset((void *)pstr->mbs, 255, pstr->valid_len);
              }
            }
          }
#line 665
          pstr->valid_raw_len = pstr->valid_len;
        }
      } else {
        {
#line 671
        pstr->tip_context = re_string_context_at___0((re_string_t const   *)pstr,
                                                     offset - 1UL, eflags);
        }
#line 674
        if (pstr->mb_cur_max > 1) {
          {
#line 675
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
          }
        }
        {
#line 678
        tmp___0 = __builtin_expect((long )pstr->mbs_allocated, 0L);
        }
#line 678
        if (tmp___0) {
          {
#line 679
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
          }
        }
#line 681
        pstr->valid_len -= offset;
#line 682
        pstr->valid_raw_len -= offset;
      }
    } else {
      {
#line 692
      prev_valid_len = pstr->valid_len;
#line 694
      tmp___2 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 694
      if (tmp___2) {
#line 696
        pstr->len = (pstr->raw_len - idx) + offset;
#line 697
        pstr->stop = (pstr->raw_stop - idx) + offset;
#line 698
        pstr->offsets_needed = (unsigned char)0;
      }
#line 701
      pstr->valid_len = (Idx )0;
#line 703
      if (pstr->mb_cur_max > 1) {
#line 706
        wc = 4294967295U;
#line 708
        if (pstr->is_utf8) {
#line 714
          raw = pstr->raw_mbs + pstr->raw_mbs_idx;
#line 715
          end = raw + (offset - (Idx )pstr->mb_cur_max);
#line 716
          if ((unsigned long )end < (unsigned long )pstr->raw_mbs) {
#line 717
            end = pstr->raw_mbs;
          }
#line 718
          p = (raw + offset) - 1;
          {
#line 730
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 730
            if (! ((unsigned long )p >= (unsigned long )end)) {
#line 730
              goto while_break___4;
            }
#line 731
            if (((int const   )*p & 192) != 128) {
              {
#line 735
              mlen = (Idx )((raw + pstr->len) - p);
#line 739
              tmp___4 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                         0L);
              }
#line 739
              if (tmp___4) {
#line 741
                if (mlen < 6UL) {
#line 741
                  tmp___3 = mlen;
                } else {
#line 741
                  tmp___3 = (Idx )6;
                }
#line 741
                i = (int )tmp___3;
                {
#line 742
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 742
                  i --;
#line 742
                  if (! (i >= 0)) {
#line 742
                    goto while_break___5;
                  }
#line 743
                  buf___1[i] = *(pstr->trans + *(p + i));
                }
                while_break___5: /* CIL Label */ ;
                }
              }
              {
#line 747
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 748
              mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)p),
                               mlen, (mbstate_t */* __restrict  */)(& cur_state));
              }
#line 750
              if ((size_t )((raw + offset) - p) <= mbclen) {
#line 750
                if (mbclen < 0xfffffffffffffffeUL) {
                  {
#line 753
                  memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
#line 755
                  pstr->valid_len = mbclen - (size_t )((raw + offset) - p);
#line 756
                  wc = (wint_t )wc2;
                  }
                }
              }
#line 758
              goto while_break___4;
            }
#line 730
            p --;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 762
        if (wc == 4294967295U) {
          {
#line 763
          tmp___5 = re_string_skip_chars___0(pstr, idx, & wc);
#line 763
          pstr->valid_len = tmp___5 - idx;
          }
        }
#line 764
        if (wc == 4294967295U) {
          {
#line 765
          pstr->tip_context = re_string_context_at___0((re_string_t const   *)pstr,
                                                       prev_valid_len - 1UL, eflags);
          }
        } else {
          {
#line 768
          tmp___9 = __builtin_expect((long )((int )pstr->word_ops_used != 0), 0L);
          }
#line 768
          if (tmp___9) {
            {
#line 768
            tmp___10 = iswalnum(wc);
            }
#line 768
            if (tmp___10) {
#line 768
              pstr->tip_context = 1U;
            } else
#line 768
            if (wc == 95U) {
#line 768
              pstr->tip_context = 1U;
            } else {
#line 768
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 768
            if (wc == 10U) {
#line 768
              if (pstr->newline_anchor) {
#line 768
                tmp___8 = 1 << 1;
              } else {
#line 768
                tmp___8 = 0;
              }
            } else {
#line 768
              tmp___8 = 0;
            }
#line 768
            pstr->tip_context = (unsigned int )tmp___8;
          }
        }
        {
#line 774
        tmp___11 = __builtin_expect((long )pstr->valid_len, 0L);
        }
#line 774
        if (tmp___11) {
#line 776
          wcs_idx = (Idx )0;
          {
#line 776
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 776
            if (! (wcs_idx < pstr->valid_len)) {
#line 776
              goto while_break___6;
            }
#line 777
            *(pstr->wcs + wcs_idx) = 4294967295U;
#line 776
            wcs_idx ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 778
          if (pstr->mbs_allocated) {
            {
#line 779
            memset((void *)pstr->mbs, 255, pstr->valid_len);
            }
          }
        }
#line 781
        pstr->valid_raw_len = pstr->valid_len;
      } else {
#line 786
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1UL));
#line 787
        pstr->valid_raw_len = (Idx )0;
#line 788
        if (pstr->trans) {
#line 789
          c = (int )*(pstr->trans + c);
        }
        {
#line 790
        tmp___14 = bitset_contain((bitset_word_t */* const  */)pstr->word_char, (Idx )c);
        }
#line 790
        if (tmp___14) {
#line 790
          pstr->tip_context = 1U;
        } else {
#line 790
          if (c == 10) {
#line 790
            if (pstr->newline_anchor) {
#line 790
              tmp___13 = 1 << 1;
            } else {
#line 790
              tmp___13 = 0;
            }
          } else {
#line 790
            tmp___13 = 0;
          }
#line 790
          pstr->tip_context = (unsigned int )tmp___13;
        }
      }
    }
    {
#line 796
    tmp___16 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 796
    if (! tmp___16) {
#line 797
      pstr->mbs += offset;
    }
  }
#line 799
  pstr->raw_mbs_idx = idx;
#line 800
  pstr->len -= offset;
#line 801
  pstr->stop -= offset;
#line 805
  if (pstr->mb_cur_max > 1) {
#line 807
    if (pstr->icase) {
      {
#line 809
      tmp___18 = build_wcs_upper_buffer___0(pstr);
#line 809
      ret = tmp___18;
#line 810
      tmp___19 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 810
      if (tmp___19) {
#line 811
        return (ret);
      }
    } else {
      {
#line 814
      build_wcs_buffer___0(pstr);
      }
    }
  } else {
    {
#line 818
    tmp___20 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 818
    if (tmp___20) {
#line 820
      if (pstr->icase) {
        {
#line 821
        build_upper_buffer___0(pstr);
        }
      } else
#line 822
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
        {
#line 823
        re_string_translate_buffer___0(pstr);
        }
      }
    } else {
#line 826
      pstr->valid_len = pstr->len;
    }
  }
#line 828
  pstr->cur_idx = (Idx )0;
#line 829
  return ((reg_errcode_t )0);
}
}
#line 832 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case___0(re_string_t const   *pstr ,
                                                                             Idx idx ) 
{ 
  int ch ;
  Idx off ;
  long tmp ;

  {
  {
#line 840
  tmp = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 840
  if (tmp) {
#line 841
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
  }
#line 844
  if (pstr->mb_cur_max > 1) {
#line 844
    if (*(pstr->wcs + (pstr->cur_idx + (Idx const   )idx)) != 4294967295U) {
#line 844
      if (! (pstr->valid_len == (pstr->cur_idx + (Idx const   )idx) + 1UL)) {
#line 844
        if (! (*(pstr->wcs + ((pstr->cur_idx + (Idx const   )idx) + 1UL)) != 4294967295U)) {
#line 846
          return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
        }
      }
    } else {
#line 846
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 849
  off = (Idx )(pstr->cur_idx + (Idx const   )idx);
#line 851
  if (pstr->offsets_needed) {
#line 852
    off = *(pstr->offsets + off);
  }
#line 855
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (Idx const   )off));
#line 862
  if (pstr->offsets_needed) {
#line 862
    if (! ((ch & -128) == 0)) {
#line 863
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 866
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
#line 869 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_fetch_byte_case___0(re_string_t *pstr ) 
{ 
  Idx tmp ;
  long tmp___0 ;
  Idx off ;
  int ch ;
  Idx tmp___1 ;
  Idx tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 873
  tmp___0 = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 873
  if (tmp___0) {
#line 874
    tmp = pstr->cur_idx;
#line 874
    (pstr->cur_idx) ++;
#line 874
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp));
  }
#line 877
  if (pstr->offsets_needed) {
#line 889
    if (! (pstr->cur_idx == pstr->valid_len)) {
#line 889
      if (! (*(pstr->wcs + pstr->cur_idx) != 4294967295U)) {
#line 890
        tmp___1 = pstr->cur_idx;
#line 890
        (pstr->cur_idx) ++;
#line 890
        return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___1));
      }
    }
#line 892
    off = *(pstr->offsets + pstr->cur_idx);
#line 893
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + off));
#line 895
    if (! ((ch & -128) == 0)) {
#line 896
      tmp___2 = pstr->cur_idx;
#line 896
      (pstr->cur_idx) ++;
#line 896
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___2));
    }
    {
#line 898
    tmp___3 = re_string_char_size_at((re_string_t const   *)pstr, pstr->cur_idx);
#line 898
    pstr->cur_idx += (Idx )tmp___3;
    }
#line 900
    return ((unsigned char __attribute__((__pure__))  )ch);
  }
#line 904
  tmp___4 = pstr->cur_idx;
#line 904
  (pstr->cur_idx) ++;
#line 904
  return ((unsigned char __attribute__((__pure__))  )*(pstr->raw_mbs + (pstr->raw_mbs_idx + tmp___4)));
}
}
#line 907 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_string_destruct___0(re_string_t *pstr ) 
{ 


  {
  {
#line 912
  free((void *)pstr->wcs);
#line 913
  free((void *)pstr->offsets);
  }
#line 915
  if (pstr->mbs_allocated) {
    {
#line 916
    free((void *)pstr->mbs);
    }
  }
#line 917
  return;
}
}
#line 921
static unsigned int re_string_context_at___0(re_string_t const   *input , Idx idx ,
                                             int eflags )  __attribute__((__pure__)) ;
#line 921 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static unsigned int re_string_context_at___0(re_string_t const   *input , Idx idx ,
                                             int eflags ) 
{ 
  int c ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  wint_t wc ;
  Idx wc_idx ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;

  {
  {
#line 926
  tmp = __builtin_expect((long )(! (idx < 0xfffffffffffffffeUL)), 0L);
  }
#line 926
  if (tmp) {
#line 929
    return ((unsigned int )input->tip_context);
  }
  {
#line 930
  tmp___1 = __builtin_expect((long )(idx == (Idx )input->len), 0L);
  }
#line 930
  if (tmp___1) {
#line 931
    if (eflags & (1 << 1)) {
#line 931
      tmp___0 = ((1 << 1) << 1) << 1;
    } else {
#line 931
      tmp___0 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
#line 931
    return ((unsigned int )tmp___0);
  }
#line 934
  if (input->mb_cur_max > 1) {
#line 937
    wc_idx = idx;
    {
#line 938
    while (1) {
      while_continue: /* CIL Label */ ;
#line 938
      if (! (*(input->wcs + wc_idx) == 4294967295U)) {
#line 938
        goto while_break;
      }
#line 944
      wc_idx --;
#line 945
      if (! (wc_idx < 0xfffffffffffffffeUL)) {
#line 946
        return ((unsigned int )input->tip_context);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 948
    wc = *(input->wcs + wc_idx);
#line 949
    tmp___2 = __builtin_expect((long )((int const   )input->word_ops_used != 0), 0L);
    }
#line 949
    if (tmp___2) {
      {
#line 949
      tmp___3 = iswalnum(wc);
      }
#line 949
      if (tmp___3) {
#line 950
        return (1U);
      } else
#line 949
      if (wc == 95U) {
#line 950
        return (1U);
      }
    }
#line 951
    if (wc == 10U) {
#line 951
      if (input->newline_anchor) {
#line 951
        tmp___4 = 1 << 1;
      } else {
#line 951
        tmp___4 = 0;
      }
    } else {
#line 951
      tmp___4 = 0;
    }
#line 951
    return ((unsigned int )tmp___4);
  } else {
    {
#line 957
    c = (int )*(input->mbs + idx);
#line 958
    tmp___5 = bitset_contain((bitset_word_t */* const  */)input->word_char, (Idx )c);
    }
#line 958
    if (tmp___5) {
#line 959
      return (1U);
    }
#line 960
    if (c == 10) {
#line 960
      if (input->newline_anchor) {
#line 960
        tmp___6 = 1 << 1;
      } else {
#line 960
        tmp___6 = 0;
      }
    } else {
#line 960
      tmp___6 = 0;
    }
#line 960
    return ((unsigned int )tmp___6);
  }
}
}
#line 966 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_alloc___0(re_node_set *set , Idx size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 970
  set->alloc = size;
#line 971
  set->nelem = (Idx )0;
#line 972
  tmp = malloc(size * sizeof(Idx ));
#line 972
  set->elems = (Idx *)tmp;
#line 973
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 973
  if (tmp___0) {
#line 974
    return ((reg_errcode_t )12);
  }
#line 975
  return ((reg_errcode_t )0);
}
}
#line 978 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_1___0(re_node_set *set , Idx elem ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
  {
#line 982
  set->alloc = (Idx )1;
#line 983
  set->nelem = (Idx )1;
#line 984
  tmp = malloc(sizeof(Idx ));
#line 984
  set->elems = (Idx *)tmp;
#line 985
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 985
  if (tmp___1) {
#line 987
    tmp___0 = (Idx )0;
#line 987
    set->nelem = tmp___0;
#line 987
    set->alloc = tmp___0;
#line 988
    return ((reg_errcode_t )12);
  }
#line 990
  *(set->elems + 0) = elem;
#line 991
  return ((reg_errcode_t )0);
}
}
#line 994 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_2___0(re_node_set *set , Idx elem1 , Idx elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 998
  set->alloc = (Idx )2;
#line 999
  tmp = malloc(2UL * sizeof(Idx ));
#line 999
  set->elems = (Idx *)tmp;
#line 1000
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 1000
  if (tmp___0) {
#line 1001
    return ((reg_errcode_t )12);
  }
#line 1002
  if (elem1 == elem2) {
#line 1004
    set->nelem = (Idx )1;
#line 1005
    *(set->elems + 0) = elem1;
  } else {
#line 1009
    set->nelem = (Idx )2;
#line 1010
    if (elem1 < elem2) {
#line 1012
      *(set->elems + 0) = elem1;
#line 1013
      *(set->elems + 1) = elem2;
    } else {
#line 1017
      *(set->elems + 0) = elem2;
#line 1018
      *(set->elems + 1) = elem1;
    }
  }
#line 1021
  return ((reg_errcode_t )0);
}
}
#line 1024 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_copy___0(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
#line 1028
  dest->nelem = (Idx )src->nelem;
#line 1029
  if (src->nelem > 0UL) {
    {
#line 1031
    dest->alloc = dest->nelem;
#line 1032
    tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1032
    dest->elems = (Idx *)tmp;
#line 1033
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1033
    if (tmp___1) {
#line 1035
      tmp___0 = (Idx )0;
#line 1035
      dest->nelem = tmp___0;
#line 1035
      dest->alloc = tmp___0;
#line 1036
      return ((reg_errcode_t )12);
    }
    {
#line 1038
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
    }
  } else {
    {
#line 1041
    memset((void *)dest, '\000', sizeof(re_node_set ));
    }
  }
#line 1042
  return ((reg_errcode_t )0);
}
}
#line 1049 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_add_intersect___0(re_node_set *dest , re_node_set const   *src1 ,
                                                   re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx is ;
  Idx id ;
  Idx delta ;
  Idx sbase ;
  Idx new_alloc ;
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  Idx tmp___2 ;

  {
#line 1055
  if (src1->nelem == 0UL) {
#line 1056
    return ((reg_errcode_t )0);
  } else
#line 1055
  if (src2->nelem == 0UL) {
#line 1056
    return ((reg_errcode_t )0);
  }
#line 1060
  if ((src1->nelem + src2->nelem) + (Idx const   )dest->nelem > (Idx const   )dest->alloc) {
    {
#line 1062
    new_alloc = (Idx )((src1->nelem + src2->nelem) + (Idx const   )dest->alloc);
#line 1063
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1063
    new_elems = (Idx *)tmp;
#line 1064
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1064
    if (tmp___0) {
#line 1065
      return ((reg_errcode_t )12);
    }
#line 1066
    dest->elems = new_elems;
#line 1067
    dest->alloc = new_alloc;
  }
#line 1072
  sbase = (dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem;
#line 1073
  i1 = (Idx )(src1->nelem - 1UL);
#line 1074
  i2 = (Idx )(src2->nelem - 1UL);
#line 1075
  id = dest->nelem - 1UL;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
#line 1081
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1081
        if (id < 0xfffffffffffffffeUL) {
#line 1081
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
#line 1081
            goto while_break___0;
          }
        } else {
#line 1081
          goto while_break___0;
        }
#line 1082
        id --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1084
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1085
        sbase --;
#line 1085
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else
#line 1084
      if (*(dest->elems + id) != *(src1->elems + i1)) {
#line 1085
        sbase --;
#line 1085
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1087
      i1 --;
#line 1087
      if (i1 < 0xfffffffffffffffeUL) {
#line 1087
        i2 --;
#line 1087
        if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1088
          goto while_break;
        }
      } else {
#line 1088
        goto while_break;
      }
    } else
#line 1092
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1094
      i2 --;
#line 1094
      if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1095
        goto while_break;
      }
    } else {
#line 1099
      i1 --;
#line 1099
      if (! (i1 < 0xfffffffffffffffeUL)) {
#line 1100
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  id = dest->nelem - 1UL;
#line 1105
  is = ((dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem) - 1UL;
#line 1106
  delta = (is - sbase) + 1UL;
#line 1111
  dest->nelem += delta;
#line 1112
  if (delta > 0UL) {
#line 1112
    if (id < 0xfffffffffffffffeUL) {
      {
#line 1113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1115
        if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1118
          tmp___1 = delta;
#line 1118
          delta --;
#line 1118
          tmp___2 = is;
#line 1118
          is --;
#line 1118
          *(dest->elems + (id + tmp___1)) = *(dest->elems + tmp___2);
#line 1119
          if (delta == 0UL) {
#line 1120
            goto while_break___1;
          }
        } else {
#line 1125
          *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1126
          id --;
#line 1126
          if (! (id < 0xfffffffffffffffeUL)) {
#line 1127
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 1132
  memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
         delta * sizeof(Idx ));
  }
#line 1134
  return ((reg_errcode_t )0);
}
}
#line 1140 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_union___0(re_node_set *dest , re_node_set const   *src1 ,
                                                re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 1146
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1146
    if (src1->nelem > 0UL) {
#line 1146
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1146
        if (src2->nelem > 0UL) {
          {
#line 1148
          dest->alloc = (Idx )(src1->nelem + src2->nelem);
#line 1149
          tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1149
          dest->elems = (Idx *)tmp;
#line 1150
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
#line 1150
          if (tmp___0) {
#line 1151
            return ((reg_errcode_t )12);
          }
        } else {
#line 1146
          goto _L___2;
        }
      } else {
#line 1146
        goto _L___2;
      }
    } else {
#line 1146
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1155
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1155
      if (src1->nelem > 0UL) {
        {
#line 1156
        tmp___1 = re_node_set_init_copy___0(dest, src1);
        }
#line 1156
        return (tmp___1);
      } else {
#line 1155
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1157
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1157
      if (src2->nelem > 0UL) {
        {
#line 1158
        tmp___2 = re_node_set_init_copy___0(dest, src2);
        }
#line 1158
        return (tmp___2);
      } else {
        {
#line 1160
        memset((void *)dest, '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 1160
      memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    }
#line 1161
    return ((reg_errcode_t )0);
  }
#line 1163
  id = (Idx )0;
#line 1163
  i2 = id;
#line 1163
  i1 = i2;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (i1 < (Idx )src1->nelem) {
#line 1163
      if (! (i2 < (Idx )src2->nelem)) {
#line 1163
        goto while_break;
      }
    } else {
#line 1163
      goto while_break;
    }
#line 1165
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1167
      tmp___3 = id;
#line 1167
      id ++;
#line 1167
      tmp___4 = i2;
#line 1167
      i2 ++;
#line 1167
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
#line 1168
      goto __Cont;
    }
#line 1170
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1171
      i2 ++;
    }
#line 1172
    tmp___5 = id;
#line 1172
    id ++;
#line 1172
    tmp___6 = i1;
#line 1172
    i1 ++;
#line 1172
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  if (i1 < (Idx )src1->nelem) {
    {
#line 1176
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src1->elems + i1),
           (size_t )((src1->nelem - (Idx const   )i1) * (Idx const   )sizeof(Idx )));
#line 1178
    id += (Idx )(src1->nelem - (Idx const   )i1);
    }
  } else
#line 1180
  if (i2 < (Idx )src2->nelem) {
    {
#line 1182
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src2->elems + i2),
           (size_t )((src2->nelem - (Idx const   )i2) * (Idx const   )sizeof(Idx )));
#line 1184
    id += (Idx )(src2->nelem - (Idx const   )i2);
    }
  }
#line 1186
  dest->nelem = id;
#line 1187
  return ((reg_errcode_t )0);
}
}
#line 1193 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_merge___0(re_node_set *dest , re_node_set const   *src ) 
{ 
  Idx is ;
  Idx id ;
  Idx sbase ;
  Idx delta ;
  Idx new_alloc ;
  Idx *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;

  {
#line 1198
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1199
    return ((reg_errcode_t )0);
  } else
#line 1198
  if (src->nelem == 0UL) {
#line 1199
    return ((reg_errcode_t )0);
  }
#line 1200
  if (dest->alloc < (Idx )(2UL * src->nelem + (Idx const   )dest->nelem)) {
    {
#line 1202
    new_alloc = (Idx )(2UL * (src->nelem + (Idx const   )dest->alloc));
#line 1203
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1203
    new_buffer = (Idx *)tmp;
#line 1204
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
#line 1204
    if (tmp___0) {
#line 1205
      return ((reg_errcode_t )12);
    }
#line 1206
    dest->elems = new_buffer;
#line 1207
    dest->alloc = new_alloc;
  }
  {
#line 1210
  tmp___1 = __builtin_expect((long )(dest->nelem == 0UL), 0L);
  }
#line 1210
  if (tmp___1) {
    {
#line 1212
    dest->nelem = (Idx )src->nelem;
#line 1213
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
    }
#line 1214
    return ((reg_errcode_t )0);
  }
#line 1219
  sbase = dest->nelem + (Idx )(2UL * src->nelem);
#line 1219
  is = (Idx )(src->nelem - 1UL);
#line 1219
  id = dest->nelem - 1UL;
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1219
    if (is < 0xfffffffffffffffeUL) {
#line 1219
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1219
        goto while_break;
      }
    } else {
#line 1219
      goto while_break;
    }
#line 1223
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1224
      is --;
#line 1224
      id --;
    } else
#line 1225
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1226
      sbase --;
#line 1226
      tmp___2 = is;
#line 1226
      is --;
#line 1226
      *(dest->elems + sbase) = *(src->elems + tmp___2);
    } else {
#line 1228
      id --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  if (is < 0xfffffffffffffffeUL) {
    {
#line 1234
    sbase -= is + 1UL;
#line 1235
    memcpy((void */* __restrict  */)(dest->elems + sbase), (void const   */* __restrict  */)src->elems,
           (is + 1UL) * sizeof(Idx ));
    }
  }
#line 1238
  id = dest->nelem - 1UL;
#line 1239
  is = (dest->nelem + (Idx )(2UL * src->nelem)) - 1UL;
#line 1240
  delta = (is - sbase) + 1UL;
#line 1241
  if (delta == 0UL) {
#line 1242
    return ((reg_errcode_t )0);
  }
#line 1246
  dest->nelem += delta;
  {
#line 1247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1249
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1252
      tmp___3 = delta;
#line 1252
      delta --;
#line 1252
      tmp___4 = is;
#line 1252
      is --;
#line 1252
      *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
#line 1253
      if (delta == 0UL) {
#line 1254
        goto while_break___0;
      }
    } else {
#line 1259
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1260
      id --;
#line 1260
      if (! (id < 0xfffffffffffffffeUL)) {
        {
#line 1263
        memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
               delta * sizeof(Idx ));
        }
#line 1265
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1270
  return ((reg_errcode_t )0);
}
}
#line 1277 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool re_node_set_insert___0(re_node_set *set , Idx elem ) 
{ 
  Idx idx ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx *new_elems ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 1283
  if (set->alloc == 0UL) {
    {
#line 1284
    tmp = re_node_set_init_1___0(set, elem);
#line 1284
    tmp___0 = __builtin_expect((long )((int )tmp == 0), 1L);
    }
#line 1284
    return ((_Bool )tmp___0);
  }
  {
#line 1286
  tmp___1 = __builtin_expect((long )set->nelem, 0L);
  }
#line 1286
  if (tmp___1 == 0L) {
#line 1289
    *(set->elems + 0) = elem;
#line 1290
    (set->nelem) ++;
#line 1291
    return ((_Bool)1);
  }
#line 1295
  if (set->alloc == set->nelem) {
    {
#line 1298
    set->alloc *= 2UL;
#line 1299
    tmp___2 = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1299
    new_elems = (Idx *)tmp___2;
#line 1300
    tmp___3 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1300
    if (tmp___3) {
#line 1301
      return ((_Bool)0);
    }
#line 1302
    set->elems = new_elems;
  }
#line 1307
  if (elem < *(set->elems + 0)) {
#line 1309
    idx = (Idx )0;
#line 1310
    idx = set->nelem;
    {
#line 1310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1310
      if (! (idx > 0UL)) {
#line 1310
        goto while_break;
      }
#line 1311
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1310
      idx --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1315
    idx = set->nelem;
    {
#line 1315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1315
      if (! (*(set->elems + (idx - 1UL)) > elem)) {
#line 1315
        goto while_break___0;
      }
#line 1316
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1315
      idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1320
  *(set->elems + idx) = elem;
#line 1321
  (set->nelem) ++;
#line 1322
  return ((_Bool)1);
}
}
#line 1329 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool re_node_set_insert_last___0(re_node_set *set , Idx elem ) 
{ 
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 1334
  if (set->alloc == set->nelem) {
    {
#line 1337
    set->alloc = (set->alloc + 1UL) * 2UL;
#line 1338
    tmp = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1338
    new_elems = (Idx *)tmp;
#line 1339
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1339
    if (tmp___0) {
#line 1340
      return ((_Bool)0);
    }
#line 1341
    set->elems = new_elems;
  }
#line 1345
  tmp___1 = set->nelem;
#line 1345
  (set->nelem) ++;
#line 1345
  *(set->elems + tmp___1) = elem;
#line 1346
  return ((_Bool)1);
}
}
#line 1352 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static _Bool __attribute__((__pure__))  re_node_set_compare___0(re_node_set const   *set1 ,
                                                                re_node_set const   *set2 ) 
{ 
  Idx i ;

  {
#line 1357
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1357
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1357
  if (set1->nelem != set2->nelem) {
#line 1358
    return ((_Bool __attribute__((__pure__))  )0);
  }
#line 1359
  i = (Idx )set1->nelem;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    i --;
#line 1359
    if (! (i < 0xfffffffffffffffeUL)) {
#line 1359
      goto while_break;
    }
#line 1360
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 1361
      return ((_Bool __attribute__((__pure__))  )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 1367 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx __attribute__((__pure__))  re_node_set_contains___0(re_node_set const   *set ,
                                                               Idx elem ) 
{ 
  __re_size_t idx ;
  __re_size_t right ;
  __re_size_t mid ;
  __re_size_t tmp ;

  {
#line 1372
  if (! ((Idx )(set->nelem - 1UL) < 0xfffffffffffffffdUL)) {
#line 1373
    return ((Idx __attribute__((__pure__))  )0);
  }
#line 1376
  idx = (__re_size_t )0;
#line 1377
  right = (__re_size_t )(set->nelem - 1UL);
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1378
    if (! (idx < right)) {
#line 1378
      goto while_break;
    }
#line 1380
    mid = (idx + right) / 2UL;
#line 1381
    if (*(set->elems + mid) < elem) {
#line 1382
      idx = mid + 1UL;
    } else {
#line 1384
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1386
  if (*(set->elems + idx) == elem) {
#line 1386
    tmp = idx + 1UL;
  } else {
#line 1386
    tmp = (__re_size_t )0;
  }
#line 1386
  return ((Idx __attribute__((__pure__))  )tmp);
}
}
#line 1389 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void re_node_set_remove_at___0(re_node_set *set , Idx idx ) 
{ 


  {
#line 1393
  if (idx < 0UL) {
#line 1394
    return;
  } else
#line 1393
  if (idx >= set->nelem) {
#line 1394
    return;
  }
#line 1395
  (set->nelem) --;
  {
#line 1396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1396
    if (! (idx < set->nelem)) {
#line 1396
      goto while_break;
    }
#line 1397
    *(set->elems + idx) = *(set->elems + (idx + 1UL));
#line 1396
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1404 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static Idx re_dfa_add_node___0(re_dfa_t *dfa , re_token_t token ) 
{ 
  size_t new_nodes_alloc ;
  Idx *new_nexts ;
  Idx *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int type ;
  int tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 1408
  tmp___12 = __builtin_expect((long )(dfa->nodes_len >= dfa->nodes_alloc), 0L);
  }
#line 1408
  if (tmp___12) {
#line 1410
    new_nodes_alloc = dfa->nodes_alloc * 2UL;
#line 1414
    if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1414
      tmp___2 = sizeof(Idx );
    } else {
#line 1414
      tmp___2 = sizeof(re_node_set );
    }
#line 1414
    if (sizeof(re_token_t ) < tmp___2) {
#line 1414
      if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1414
        tmp___0 = sizeof(Idx );
      } else {
#line 1414
        tmp___0 = sizeof(re_node_set );
      }
#line 1414
      tmp___1 = tmp___0;
    } else {
#line 1414
      tmp___1 = sizeof(re_token_t );
    }
    {
#line 1414
    max_object_size = tmp___1;
#line 1420
    tmp___3 = __builtin_expect((long )(9223372036854775807UL / max_object_size < dfa->nodes_alloc),
                               0L);
    }
#line 1420
    if (tmp___3) {
#line 1421
      return ((Idx )-1);
    }
    {
#line 1423
    tmp___4 = realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1423
    new_nodes = (re_token_t *)tmp___4;
#line 1424
    tmp___5 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
    }
#line 1424
    if (tmp___5) {
#line 1425
      return ((Idx )-1);
    }
    {
#line 1426
    dfa->nodes = new_nodes;
#line 1427
    tmp___6 = realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(Idx ));
#line 1427
    new_nexts = (Idx *)tmp___6;
#line 1428
    tmp___7 = realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(Idx ));
#line 1428
    new_indices = (Idx *)tmp___7;
#line 1429
    tmp___8 = realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1429
    new_edests = (re_node_set *)tmp___8;
#line 1430
    tmp___9 = realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1430
    new_eclosures = (re_node_set *)tmp___9;
    }
#line 1431
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else
#line 1431
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 1431
      tmp___10 = 1;
    } else {
#line 1431
      tmp___10 = 0;
    }
    {
#line 1431
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 1431
    if (tmp___11) {
#line 1433
      return ((Idx )-1);
    }
#line 1434
    dfa->nexts = new_nexts;
#line 1435
    dfa->org_indices = new_indices;
#line 1436
    dfa->edests = new_edests;
#line 1437
    dfa->eclosures = new_eclosures;
#line 1438
    dfa->nodes_alloc = new_nodes_alloc;
  }
#line 1440
  *(dfa->nodes + dfa->nodes_len) = token;
#line 1441
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 1444
  type = (int )token.type;
#line 1445
  if (type == 5) {
#line 1445
    if (dfa->mb_cur_max > 1) {
#line 1445
      tmp___13 = 1;
    } else {
#line 1445
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1445
  if (type == 6) {
#line 1445
    tmp___13 = 1;
  } else {
#line 1445
    tmp___13 = 0;
  }
  {
#line 1445
  (dfa->nodes + dfa->nodes_len)->accept_mb = (unsigned int )tmp___13;
#line 1449
  *(dfa->nexts + dfa->nodes_len) = (Idx )-1;
#line 1450
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1451
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1452
  tmp___14 = dfa->nodes_len;
#line 1452
  (dfa->nodes_len) ++;
  }
#line 1452
  return (tmp___14);
}
}
#line 1475 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state___0(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                           re_node_set const   *nodes ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  long tmp ;
  re_dfastate_t *state___0 ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1488
  tmp = __builtin_expect((long )(nodes->nelem == 0UL), 0L);
  }
#line 1488
  if (tmp) {
#line 1490
    *err = (reg_errcode_t )0;
#line 1491
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1493
  hash = calc_state_hash(nodes, 0U);
#line 1494
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1496
  i = (Idx )0;
  }
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! (i < spot->num)) {
#line 1496
      goto while_break;
    }
#line 1498
    state___0 = *(spot->array + i);
#line 1499
    if (hash != state___0->hash) {
#line 1500
      goto __Cont;
    }
    {
#line 1501
    tmp___0 = re_node_set_compare___0((re_node_set const   *)(& state___0->nodes),
                                      nodes);
    }
#line 1501
    if (tmp___0) {
#line 1502
      return (state___0);
    }
    __Cont: /* CIL Label */ 
#line 1496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  new_state = create_ci_newstate___0(dfa, nodes, hash);
#line 1507
  tmp___1 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1507
  if (tmp___1) {
#line 1508
    *err = (reg_errcode_t )12;
  }
#line 1510
  return (new_state);
}
}
#line 1523 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state_context___0(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                                   re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state___0 ;
  _Bool __attribute__((__pure__))  tmp ;
  long tmp___0 ;

  {
#line 1536
  if (nodes->nelem == 0UL) {
#line 1538
    *err = (reg_errcode_t )0;
#line 1539
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1541
  hash = calc_state_hash(nodes, context);
#line 1542
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1544
  i = (Idx )0;
  }
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1544
    if (! (i < spot->num)) {
#line 1544
      goto while_break;
    }
#line 1546
    state___0 = *(spot->array + i);
#line 1547
    if (state___0->hash == hash) {
#line 1547
      if (state___0->context == context) {
        {
#line 1547
        tmp = re_node_set_compare___0((re_node_set const   *)state___0->entrance_nodes,
                                      nodes);
        }
#line 1547
        if (tmp) {
#line 1550
          return (state___0);
        }
      }
    }
#line 1544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1553
  new_state = create_cd_newstate___0(dfa, nodes, context, hash);
#line 1554
  tmp___0 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1554
  if (tmp___0) {
#line 1555
    *err = (reg_errcode_t )12;
  }
#line 1557
  return (new_state);
}
}
#line 1564 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static reg_errcode_t register_state___0(re_dfa_t const   *dfa , re_dfastate_t *newstate ,
                                        re_hashval_t hash ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  Idx i ;
  long tmp ;
  Idx elem ;
  _Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  Idx new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx tmp___6 ;

  {
  {
#line 1572
  newstate->hash = hash;
#line 1573
  err = re_node_set_alloc___0(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1574
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1574
  if (tmp) {
#line 1575
    return ((reg_errcode_t )12);
  }
#line 1576
  i = (Idx )0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1576
    if (! (i < newstate->nodes.nelem)) {
#line 1576
      goto while_break;
    }
#line 1578
    elem = *(newstate->nodes.elems + i);
#line 1579
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
      {
#line 1580
      tmp___0 = re_node_set_insert_last___0(& newstate->non_eps_nodes, elem);
      }
#line 1580
      if (tmp___0) {
#line 1580
        tmp___1 = 0;
      } else {
#line 1580
        tmp___1 = 1;
      }
      {
#line 1580
      tmp___2 = __builtin_expect((long )tmp___1, 0L);
      }
#line 1580
      if (tmp___2) {
#line 1581
        return ((reg_errcode_t )12);
      }
    }
#line 1576
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1584
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1585
  tmp___5 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
  }
#line 1585
  if (tmp___5) {
    {
#line 1587
    new_alloc = 2UL * spot->num + 2UL;
#line 1588
    tmp___3 = realloc((void *)spot->array, new_alloc * sizeof(re_dfastate_t *));
#line 1588
    new_array = (re_dfastate_t **)tmp___3;
#line 1590
    tmp___4 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 1590
    if (tmp___4) {
#line 1591
      return ((reg_errcode_t )12);
    }
#line 1592
    spot->array = new_array;
#line 1593
    spot->alloc = new_alloc;
  }
#line 1595
  tmp___6 = spot->num;
#line 1595
  (spot->num) ++;
#line 1595
  *(spot->array + tmp___6) = newstate;
#line 1596
  return ((reg_errcode_t )0);
}
}
#line 1599 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static void free_state___0(re_dfastate_t *state___0 ) 
{ 


  {
  {
#line 1602
  free((void *)state___0->non_eps_nodes.elems);
#line 1603
  free((void *)state___0->inveclosure.elems);
  }
#line 1604
  if ((unsigned long )state___0->entrance_nodes != (unsigned long )(& state___0->nodes)) {
    {
#line 1606
    free((void *)(state___0->entrance_nodes)->elems);
#line 1607
    free((void *)state___0->entrance_nodes);
    }
  }
  {
#line 1609
  free((void *)state___0->nodes.elems);
#line 1610
  free((void *)state___0->word_trtable);
#line 1611
  free((void *)state___0->trtable);
#line 1612
  free((void *)state___0);
  }
#line 1613
  return;
}
}
#line 1618 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *create_ci_newstate___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                             re_hashval_t hash ) 
{ 
  Idx i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___2 ;

  {
  {
#line 1627
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1627
  newstate = (re_dfastate_t *)tmp;
#line 1628
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1628
  if (tmp___0) {
#line 1629
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1630
  err = re_node_set_init_copy___0(& newstate->nodes, nodes);
#line 1631
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1631
  if (tmp___1) {
    {
#line 1633
    free((void *)newstate);
    }
#line 1634
    return ((re_dfastate_t *)((void *)0));
  }
#line 1637
  newstate->entrance_nodes = & newstate->nodes;
#line 1638
  i = (Idx )0;
  {
#line 1638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1638
    if (! (i < (Idx )nodes->nelem)) {
#line 1638
      goto while_break;
    }
#line 1640
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1641
    type = node->type;
#line 1642
    if ((unsigned int )type == 1U) {
#line 1642
      if (! node->constraint) {
#line 1643
        goto __Cont;
      }
    }
#line 1645
    newstate->accept_mb |= node->accept_mb;
#line 1649
    if ((unsigned int )type == 2U) {
#line 1650
      newstate->halt = 1U;
    } else
#line 1651
    if ((unsigned int )type == 4U) {
#line 1652
      newstate->has_backref = 1U;
    } else
#line 1653
    if ((unsigned int )type == 12U) {
#line 1654
      newstate->has_constraint = 1U;
    } else
#line 1653
    if (node->constraint) {
#line 1654
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1656
  err = register_state___0(dfa, newstate, hash);
#line 1657
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1657
  if (tmp___2) {
    {
#line 1659
    free_state___0(newstate);
#line 1660
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1662
  return (newstate);
}
}
#line 1668 "/home/khheo/project/benchmark/coreutils-7.1/lib/regex_internal.c"
static re_dfastate_t *create_cd_newstate___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                             unsigned int context , re_hashval_t hash ) 
{ 
  Idx i ;
  Idx nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1673
  nctx_nodes = (Idx )0;
#line 1677
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1677
  newstate = (re_dfastate_t *)tmp;
#line 1678
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1678
  if (tmp___0) {
#line 1679
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1680
  err = re_node_set_init_copy___0(& newstate->nodes, nodes);
#line 1681
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1681
  if (tmp___1) {
    {
#line 1683
    free((void *)newstate);
    }
#line 1684
    return ((re_dfastate_t *)((void *)0));
  }
#line 1687
  newstate->context = context;
#line 1688
  newstate->entrance_nodes = & newstate->nodes;
#line 1690
  i = (Idx )0;
  {
#line 1690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1690
    if (! (i < (Idx )nodes->nelem)) {
#line 1690
      goto while_break;
    }
#line 1692
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1693
    type = node->type;
#line 1694
    constraint = node->constraint;
#line 1696
    if ((unsigned int )type == 1U) {
#line 1696
      if (! constraint) {
#line 1697
        goto __Cont;
      }
    }
#line 1699
    newstate->accept_mb |= node->accept_mb;
#line 1703
    if ((unsigned int )type == 2U) {
#line 1704
      newstate->halt = 1U;
    } else
#line 1705
    if ((unsigned int )type == 4U) {
#line 1706
      newstate->has_backref = 1U;
    }
#line 1708
    if (constraint) {
#line 1710
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
#line 1712
        tmp___2 = malloc(sizeof(re_node_set ));
#line 1712
        newstate->entrance_nodes = (re_node_set *)tmp___2;
#line 1713
        tmp___3 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
#line 1713
        if (tmp___3) {
          {
#line 1715
          free_state___0(newstate);
          }
#line 1716
          return ((re_dfastate_t *)((void *)0));
        }
        {
#line 1718
        re_node_set_init_copy___0(newstate->entrance_nodes, nodes);
#line 1719
        nctx_nodes = (Idx )0;
#line 1720
        newstate->has_constraint = 1U;
        }
      }
#line 1723
      if (constraint & 1U) {
#line 1723
        if (! (context & 1U)) {
          {
#line 1725
          re_node_set_remove_at___0(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1723
      if (constraint & 2U) {
#line 1723
        if (context & 1U) {
          {
#line 1725
          re_node_set_remove_at___0(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1723
      if (constraint & 16U) {
#line 1723
        if (! (context & (unsigned int )(1 << 1))) {
          {
#line 1725
          re_node_set_remove_at___0(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        } else {
#line 1723
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1723
      if (constraint & 64U) {
#line 1723
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
#line 1725
          re_node_set_remove_at___0(& newstate->nodes, i - nctx_nodes);
#line 1726
          nctx_nodes ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1690
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1730
  err = register_state___0(dfa, newstate, hash);
#line 1731
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1731
  if (tmp___4) {
    {
#line 1733
    free_state___0(newstate);
#line 1734
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1736
  return (newstate);
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal___0(regex_t *preg , char const   *pattern ,
                                             size_t length , reg_syntax_t syntax ) ;
#line 23
static void re_compile_fastmap_iter___0(regex_t *bufp , re_dfastate_t const   *init_state ,
                                        char *fastmap ) ;
#line 26
static reg_errcode_t init_dfa___0(re_dfa_t *dfa , size_t pat_len ) ;
#line 28
static void free_charset___0(re_charset_t *cset ) ;
#line 30
static void free_workarea_compile___0(regex_t *preg ) ;
#line 31
static reg_errcode_t create_initial_state___0(re_dfa_t *dfa ) ;
#line 33
static void optimize_utf8___0(re_dfa_t *dfa ) ;
#line 35
static reg_errcode_t analyze___0(regex_t *preg ) ;
#line 36
static reg_errcode_t preorder___0(bin_tree_t *root , reg_errcode_t (*fn)(void * ,
                                                                         bin_tree_t * ) ,
                                  void *extra ) ;
#line 39
static reg_errcode_t postorder___0(bin_tree_t *root , reg_errcode_t (*fn)(void * ,
                                                                          bin_tree_t * ) ,
                                   void *extra ) ;
#line 42
static reg_errcode_t optimize_subexps___0(void *extra , bin_tree_t *node ) ;
#line 43
static reg_errcode_t lower_subexps___0(void *extra , bin_tree_t *node ) ;
#line 44
static bin_tree_t *lower_subexp___0(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
#line 46
static reg_errcode_t calc_first___0(void *extra , bin_tree_t *node ) ;
#line 47
static reg_errcode_t calc_next___0(void *extra , bin_tree_t *node ) ;
#line 48
static reg_errcode_t link_nfa_nodes___0(void *extra , bin_tree_t *node ) ;
#line 49
static Idx duplicate_node___0(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) ;
#line 50
static Idx search_duplicated_node___0(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) ;
#line 52
static reg_errcode_t calc_eclosure___0(re_dfa_t *dfa ) ;
#line 53
static reg_errcode_t calc_eclosure_iter___0(re_node_set *new_set , re_dfa_t *dfa ,
                                            Idx node , _Bool root ) ;
#line 55
static reg_errcode_t calc_inveclosure___0(re_dfa_t *dfa ) ;
#line 56
static Idx fetch_number___0(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 58
static int peek_token___0(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 60
static bin_tree_t *parse___0(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                             reg_errcode_t *err ) ;
#line 62
static bin_tree_t *parse_reg_exp___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                     reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 65
static bin_tree_t *parse_branch___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 68
static bin_tree_t *parse_expression___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                        reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 71
static bin_tree_t *parse_sub_exp___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                     reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 74
static bin_tree_t *parse_dup_op___0(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                    re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 77
static bin_tree_t *parse_bracket_exp___0(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                         reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 80
static reg_errcode_t parse_bracket_element___0(bracket_elem_t *elem , re_string_t *regexp ,
                                               re_token_t *token , int token_len ,
                                               re_dfa_t *dfa , reg_syntax_t syntax ,
                                               _Bool accept_hyphen ) ;
#line 86
static reg_errcode_t parse_bracket_symbol___0(bracket_elem_t *elem , re_string_t *regexp ,
                                              re_token_t *token ) ;
#line 90
static reg_errcode_t build_equiv_class___0(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                           Idx *equiv_class_alloc , unsigned char const   *name ) ;
#line 94
static reg_errcode_t build_charclass___0(unsigned char *trans , bitset_word_t *sbcset ,
                                         re_charset_t *mbcset , Idx *char_class_alloc ,
                                         unsigned char const   *class_name , reg_syntax_t syntax ) ;
#line 108
static bin_tree_t *build_charclass_op___0(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                          unsigned char const   *extra , _Bool non_match ,
                                          reg_errcode_t *err ) ;
#line 113
static bin_tree_t *create_tree___0(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                   re_token_type_t type ) ;
#line 116
static bin_tree_t *create_token_tree___0(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                         re_token_t const   *token ) ;
#line 119
static bin_tree_t *duplicate_tree___0(bin_tree_t const   *root , re_dfa_t *dfa ) ;
#line 120
static void free_token___0(re_token_t *node ) ;
#line 121
static reg_errcode_t free_tree___0(void *extra , bin_tree_t *node ) ;
#line 122
static reg_errcode_t mark_opt_subexp___0(void *extra , bin_tree_t *node ) ;
#line 129 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static char const   __re_error_msgid___0[369]  = 
#line 129
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 183 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static size_t const   __re_error_msgid_idx___0[17]  = 
#line 183
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 307 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void re_compile_fastmap_iter___0(regex_t *bufp , re_dfastate_t const   *init_state ,
                                        char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  Idx node_cnt ;
  _Bool icase ;
  int tmp ;
  Idx node ;
  re_token_type_t type ;
  unsigned char buf___1[16] ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  size_t tmp___2 ;
  wint_t tmp___3 ;
  size_t tmp___4 ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;
  re_charset_t *cset ;
  Idx i___0 ;
  unsigned char c ;
  mbstate_t mbs ;
  size_t tmp___5 ;
  char buf___2[256] ;
  mbstate_t state___1 ;
  size_t tmp___6 ;
  wint_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 311
  dfa = (re_dfa_t *)bufp->buffer;
#line 313
  if (dfa->mb_cur_max == 1) {
#line 313
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 313
      tmp = 1;
    } else {
#line 313
      tmp = 0;
    }
  } else {
#line 313
    tmp = 0;
  }
#line 313
  icase = (_Bool )tmp;
#line 314
  node_cnt = (Idx )0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (node_cnt < (Idx )init_state->nodes.nelem)) {
#line 314
      goto while_break;
    }
#line 316
    node = *(init_state->nodes.elems + node_cnt);
#line 317
    type = (dfa->nodes + node)->type;
#line 319
    if ((unsigned int )type == 1U) {
      {
#line 321
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
      }
#line 323
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 323
        if (dfa->mb_cur_max > 1) {
#line 330
          p = buf___1;
#line 331
          tmp___0 = p;
#line 331
          p ++;
#line 331
          *tmp___0 = (dfa->nodes + node)->opr.c;
          {
#line 332
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 332
            node ++;
#line 332
            if (node < dfa->nodes_len) {
#line 332
              if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 332
                if (! (dfa->nodes + node)->mb_partial) {
#line 332
                  goto while_break___0;
                }
              } else {
#line 332
                goto while_break___0;
              }
            } else {
#line 332
              goto while_break___0;
            }
#line 335
            tmp___1 = p;
#line 335
            p ++;
#line 335
            *tmp___1 = (dfa->nodes + node)->opr.c;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 336
          memset((void *)(& state___0), '\000', sizeof(state___0));
#line 337
          tmp___2 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)((char const   *)(buf___1)),
                            (size_t )(p - buf___1), (mbstate_t */* __restrict  */)(& state___0));
          }
#line 337
          if (tmp___2 == (size_t )(p - buf___1)) {
            {
#line 337
            tmp___3 = towlower((wint_t )wc);
#line 337
            tmp___4 = wcrtomb((char */* __restrict  */)((char *)(buf___1)), (wchar_t )tmp___3,
                              (mbstate_t */* __restrict  */)(& state___0));
            }
#line 337
            if (tmp___4 != 0xffffffffffffffffUL) {
              {
#line 341
              re_set_fastmap(fastmap, (_Bool)0, (int )buf___1[0]);
              }
            }
          }
        }
      }
    } else
#line 345
    if ((unsigned int )type == 3U) {
#line 348
      i = 0;
#line 348
      ch = 0;
      {
#line 348
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 348
        if (! (i < 4)) {
#line 348
          goto while_break___1;
        }
#line 351
        w = *((dfa->nodes + node)->opr.sbcset + i);
#line 352
        j = 0;
        {
#line 352
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 352
          if (! (j < 64)) {
#line 352
            goto while_break___2;
          }
#line 353
          if (w & (1UL << j)) {
            {
#line 354
            re_set_fastmap(fastmap, icase, ch);
            }
          }
#line 352
          j ++;
#line 352
          ch ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 348
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 358
    if ((unsigned int )type == 6U) {
#line 360
      cset = (dfa->nodes + node)->opr.mbcset;
#line 385
      if (dfa->mb_cur_max > 1) {
#line 385
        if (cset->nchar_classes) {
#line 385
          goto _L___0;
        } else
#line 385
        if (cset->non_match) {
          _L___0: /* CIL Label */ 
#line 392
          c = (unsigned char)0;
          {
#line 393
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 396
            memset((void *)(& mbs), 0, sizeof(mbs));
#line 397
            tmp___5 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)((char *)(& c)),
                              (size_t )1, (mbstate_t */* __restrict  */)(& mbs));
            }
#line 397
            if (tmp___5 == 0xfffffffffffffffeUL) {
              {
#line 398
              re_set_fastmap(fastmap, (_Bool)0, (int )c);
              }
            }
#line 393
            c = (unsigned char )((int )c + 1);
#line 393
            if (! ((int )c != 0)) {
#line 393
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 385
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 406
        i___0 = (Idx )0;
        {
#line 406
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 406
          if (! (i___0 < cset->nmbchars)) {
#line 406
            goto while_break___4;
          }
          {
#line 410
          memset((void *)(& state___1), '\000', sizeof(state___1));
#line 411
          tmp___6 = wcrtomb((char */* __restrict  */)(buf___2), *(cset->mbchars + i___0),
                            (mbstate_t */* __restrict  */)(& state___1));
          }
#line 411
          if (tmp___6 != 0xffffffffffffffffUL) {
            {
#line 412
            re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___2)));
            }
          }
#line 413
          if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 413
            if (dfa->mb_cur_max > 1) {
              {
#line 415
              tmp___7 = towlower((wint_t )*(cset->mbchars + i___0));
#line 415
              tmp___8 = wcrtomb((char */* __restrict  */)(buf___2), (wchar_t )tmp___7,
                                (mbstate_t */* __restrict  */)(& state___1));
              }
#line 415
              if (tmp___8 != 0xffffffffffffffffUL) {
                {
#line 417
                re_set_fastmap(fastmap, (_Bool)0, (int )*((unsigned char *)(buf___2)));
                }
              }
            }
          }
#line 406
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else
#line 423
    if ((unsigned int )type == 5U) {
#line 423
      goto _L___1;
    } else
#line 423
    if ((unsigned int )type == 7U) {
#line 423
      goto _L___1;
    } else
#line 423
    if ((unsigned int )type == 2U) {
      _L___1: /* CIL Label */ 
      {
#line 429
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
      }
#line 430
      if ((unsigned int )type == 2U) {
#line 431
        bufp->can_be_null = 1U;
      }
#line 432
      return;
    }
#line 314
    node_cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 587 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bitset_word_t utf8_sb_map___0[4]  = {      0xffffffffffffffffUL,      0xffffffffffffffffUL};
#line 607 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_dfa_content___0(re_dfa_t *dfa ) 
{ 
  Idx i ;
  Idx j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state___0 ;

  {
#line 612
  if (dfa->nodes) {
#line 613
    i = (Idx )0;
    {
#line 613
    while (1) {
      while_continue: /* CIL Label */ ;
#line 613
      if (! (i < dfa->nodes_len)) {
#line 613
        goto while_break;
      }
      {
#line 614
      free_token___0(dfa->nodes + i);
#line 613
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 615
  free((void *)dfa->nexts);
#line 616
  i = (Idx )0;
  }
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! (i < dfa->nodes_len)) {
#line 616
      goto while_break___0;
    }
#line 618
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
      {
#line 619
      free((void *)(dfa->eclosures + i)->elems);
      }
    }
#line 620
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
      {
#line 621
      free((void *)(dfa->inveclosures + i)->elems);
      }
    }
#line 622
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
      {
#line 623
      free((void *)(dfa->edests + i)->elems);
      }
    }
#line 616
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 625
  free((void *)dfa->edests);
#line 626
  free((void *)dfa->eclosures);
#line 627
  free((void *)dfa->inveclosures);
#line 628
  free((void *)dfa->nodes);
  }
#line 630
  if (dfa->state_table) {
#line 631
    i = (Idx )0;
    {
#line 631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 631
      if (! (i <= dfa->state_hash_mask)) {
#line 631
        goto while_break___1;
      }
#line 633
      entry = dfa->state_table + i;
#line 634
      j = (Idx )0;
      {
#line 634
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 634
        if (! (j < entry->num)) {
#line 634
          goto while_break___2;
        }
        {
#line 636
        state___0 = *(entry->array + j);
#line 637
        free_state___0(state___0);
#line 634
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 639
      free((void *)entry->array);
#line 631
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 641
  free((void *)dfa->state_table);
  }
#line 643
  if ((unsigned long )dfa->sb_char != (unsigned long )(utf8_sb_map___0)) {
    {
#line 644
    free((void *)dfa->sb_char);
    }
  }
  {
#line 646
  free((void *)dfa->subexp_map);
#line 651
  free((void *)dfa);
  }
#line 652
  return;
}
}
#line 750 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal___0(regex_t *preg , char const   *pattern ,
                                             size_t length , reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 754
  err = (reg_errcode_t )0;
#line 759
  preg->fastmap_accurate = 0U;
#line 760
  preg->syntax = syntax;
#line 761
  tmp = 0U;
#line 761
  preg->not_eol = tmp;
#line 761
  preg->not_bol = tmp;
#line 762
  preg->used = (__re_long_size_t )0;
#line 763
  preg->re_nsub = (size_t )0;
#line 764
  preg->can_be_null = 0U;
#line 765
  preg->regs_allocated = 0U;
#line 768
  dfa = (re_dfa_t *)preg->buffer;
#line 769
  tmp___1 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
  }
#line 769
  if (tmp___1) {
    {
#line 775
    tmp___0 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 775
    dfa = (re_dfa_t *)tmp___0;
    }
#line 776
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
#line 777
      return ((reg_errcode_t )12);
    }
#line 778
    preg->allocated = sizeof(re_dfa_t );
#line 779
    preg->buffer = (unsigned char *)dfa;
  }
  {
#line 781
  preg->used = sizeof(re_dfa_t );
#line 783
  err = init_dfa___0(dfa, length);
#line 784
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 784
  if (tmp___2) {
    {
#line 786
    free_dfa_content___0(dfa);
#line 787
    preg->buffer = (unsigned char *)((void *)0);
#line 788
    preg->allocated = (__re_long_size_t )0;
    }
#line 789
    return (err);
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 799
  err = re_string_construct___0(& regexp, pattern, length, preg->translate, (_Bool )((syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                                (re_dfa_t const   *)dfa);
#line 801
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 801
  if (tmp___3) {
    re_compile_internal_free_return: 
    {
#line 804
    free_workarea_compile___0(preg);
#line 805
    re_string_destruct___0(& regexp);
#line 806
    free_dfa_content___0(dfa);
#line 807
    preg->buffer = (unsigned char *)((void *)0);
#line 808
    preg->allocated = (__re_long_size_t )0;
    }
#line 809
    return (err);
  }
  {
#line 813
  preg->re_nsub = (size_t )0;
#line 814
  dfa->str_tree = parse___0(& regexp, preg, syntax, & err);
#line 815
  tmp___4 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 815
  if (tmp___4) {
#line 816
    goto re_compile_internal_free_return;
  }
  {
#line 819
  err = analyze___0(preg);
#line 820
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 820
  if (tmp___5) {
#line 821
    goto re_compile_internal_free_return;
  }
#line 825
  if (dfa->is_utf8) {
#line 825
    if (! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 825
      if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
        {
#line 826
        optimize_utf8___0(dfa);
        }
      }
    }
  }
  {
#line 830
  err = create_initial_state___0(dfa);
#line 833
  free_workarea_compile___0(preg);
#line 834
  re_string_destruct___0(& regexp);
#line 836
  tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 836
  if (tmp___6) {
    {
#line 838
    free_dfa_content___0(dfa);
#line 839
    preg->buffer = (unsigned char *)((void *)0);
#line 840
    preg->allocated = (__re_long_size_t )0;
    }
  }
#line 843
  return (err);
}
}
#line 849 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t init_dfa___0(re_dfa_t *dfa , size_t pat_len ) 
{ 
  __re_size_t table_size ;
  size_t max_i18n_object_size ;
  unsigned long tmp ;
  size_t max_object_size ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  long tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  size_t tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int i ;
  int j ;
  int ch ;
  void *tmp___46 ;
  long tmp___47 ;
  wint_t wch ;
  wint_t tmp___48 ;
  int tmp___49 ;
  long tmp___50 ;

  {
#line 854
  if (sizeof(wchar_t ) < sizeof(wctype_t )) {
#line 854
    tmp = sizeof(wctype_t );
  } else {
#line 854
    tmp = sizeof(wchar_t );
  }
#line 854
  max_i18n_object_size = tmp;
#line 858
  if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
    tmp___39 = max_i18n_object_size;
  } else {
#line 858
    tmp___39 = sizeof(regmatch_t );
  }
#line 858
  if (sizeof(re_node_set ) < tmp___39) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___37 = max_i18n_object_size;
    } else {
#line 858
      tmp___37 = sizeof(regmatch_t );
    }
#line 858
    tmp___38 = tmp___37;
  } else {
#line 858
    tmp___38 = sizeof(re_node_set );
  }
#line 858
  if (sizeof(re_token_t ) < tmp___38) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___34 = max_i18n_object_size;
    } else {
#line 858
      tmp___34 = sizeof(regmatch_t );
    }
#line 858
    if (sizeof(re_node_set ) < tmp___34) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___32 = max_i18n_object_size;
      } else {
#line 858
        tmp___32 = sizeof(regmatch_t );
      }
#line 858
      tmp___33 = tmp___32;
    } else {
#line 858
      tmp___33 = sizeof(re_node_set );
    }
#line 858
    tmp___35 = tmp___33;
  } else {
#line 858
    tmp___35 = sizeof(re_token_t );
  }
#line 858
  if (sizeof(struct re_state_table_entry ) < tmp___35) {
#line 858
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
      tmp___25 = max_i18n_object_size;
    } else {
#line 858
      tmp___25 = sizeof(regmatch_t );
    }
#line 858
    if (sizeof(re_node_set ) < tmp___25) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___23 = max_i18n_object_size;
      } else {
#line 858
        tmp___23 = sizeof(regmatch_t );
      }
#line 858
      tmp___24 = tmp___23;
    } else {
#line 858
      tmp___24 = sizeof(re_node_set );
    }
#line 858
    if (sizeof(re_token_t ) < tmp___24) {
#line 858
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
        tmp___20 = max_i18n_object_size;
      } else {
#line 858
        tmp___20 = sizeof(regmatch_t );
      }
#line 858
      if (sizeof(re_node_set ) < tmp___20) {
#line 858
        if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 858
          tmp___18 = max_i18n_object_size;
        } else {
#line 858
          tmp___18 = sizeof(regmatch_t );
        }
#line 858
        tmp___19 = tmp___18;
      } else {
#line 858
        tmp___19 = sizeof(re_node_set );
      }
#line 858
      tmp___21 = tmp___19;
    } else {
#line 858
      tmp___21 = sizeof(re_token_t );
    }
#line 858
    tmp___26 = tmp___21;
  } else {
#line 858
    tmp___26 = sizeof(struct re_state_table_entry );
  }
  {
#line 858
  max_object_size = tmp___26;
#line 865
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
#line 868
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 874
  tmp___40 = __builtin_expect((long )((0xffffffffffffffffUL / max_object_size) / 2UL <= pat_len),
                              0L);
  }
#line 874
  if (tmp___40) {
#line 875
    return ((reg_errcode_t )12);
  }
  {
#line 877
  dfa->nodes_alloc = pat_len + 1UL;
#line 878
  tmp___41 = malloc(dfa->nodes_alloc * sizeof(re_token_t ));
#line 878
  dfa->nodes = (re_token_t *)tmp___41;
#line 881
  table_size = (__re_size_t )1;
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (table_size > pat_len) {
#line 883
      goto while_break;
    }
#line 881
    table_size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  tmp___42 = calloc(sizeof(struct re_state_table_entry ), table_size);
#line 885
  dfa->state_table = (struct re_state_table_entry *)tmp___42;
#line 886
  dfa->state_hash_mask = table_size - 1UL;
#line 888
  tmp___43 = __ctype_get_mb_cur_max();
#line 888
  dfa->mb_cur_max = (int )tmp___43;
#line 896
  tmp___44 = locale_charset();
#line 896
  tmp___45 = strcmp(tmp___44, "UTF-8");
  }
#line 896
  if (tmp___45 == 0) {
#line 897
    dfa->is_utf8 = 1U;
  }
#line 901
  dfa->map_notascii = 0U;
#line 905
  if (dfa->mb_cur_max > 1) {
#line 907
    if (dfa->is_utf8) {
#line 908
      dfa->sb_char = (re_bitset_ptr_t )(utf8_sb_map___0);
    } else {
      {
#line 913
      tmp___46 = calloc(sizeof(bitset_t ), (size_t )1);
#line 913
      dfa->sb_char = (re_bitset_ptr_t )tmp___46;
#line 914
      tmp___47 = __builtin_expect((long )((unsigned long )dfa->sb_char == (unsigned long )((void *)0)),
                                  0L);
      }
#line 914
      if (tmp___47) {
#line 915
        return ((reg_errcode_t )12);
      }
#line 918
      i = 0;
#line 918
      ch = 0;
      {
#line 918
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 918
        if (! (i < 4)) {
#line 918
          goto while_break___0;
        }
#line 919
        j = 0;
        {
#line 919
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 919
          if (! (j < 64)) {
#line 919
            goto while_break___1;
          }
          {
#line 921
          tmp___48 = btowc(ch);
#line 921
          wch = tmp___48;
          }
#line 922
          if (wch != 4294967295U) {
#line 923
            *(dfa->sb_char + i) |= 1UL << j;
          }
#line 925
          if ((ch & -128) == 0) {
#line 925
            if (wch != (wint_t )ch) {
#line 926
              dfa->map_notascii = 1U;
            }
          }
#line 919
          j ++;
#line 919
          ch ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 918
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 933
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
#line 933
    tmp___49 = 1;
  } else
#line 933
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
#line 933
    tmp___49 = 1;
  } else {
#line 933
    tmp___49 = 0;
  }
  {
#line 933
  tmp___50 = __builtin_expect((long )tmp___49, 0L);
  }
#line 933
  if (tmp___50) {
#line 934
    return ((reg_errcode_t )12);
  }
#line 935
  return ((reg_errcode_t )0);
}
}
#line 942 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void init_word_char___0(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  unsigned short const   **tmp ;

  {
#line 947
  dfa->word_ops_used = 1U;
#line 948
  i = 0;
#line 948
  ch = 0;
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (i < 4)) {
#line 948
      goto while_break;
    }
#line 949
    j = 0;
    {
#line 949
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 949
      if (! (j < 64)) {
#line 949
        goto while_break___0;
      }
      {
#line 950
      tmp = __ctype_b_loc();
      }
#line 950
      if ((int const   )*(*tmp + ch) & 8) {
#line 951
        dfa->word_char[i] |= 1UL << j;
      } else
#line 950
      if (ch == 95) {
#line 951
        dfa->word_char[i] |= 1UL << j;
      }
#line 949
      j ++;
#line 949
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  return;
}
}
#line 956 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_workarea_compile___0(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 959
  dfa = (re_dfa_t *)preg->buffer;
#line 961
  storage = dfa->str_tree_storage;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! storage) {
#line 961
      goto while_break;
    }
    {
#line 963
    next = storage->next;
#line 964
    free((void *)storage);
#line 961
    storage = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 966
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 967
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 968
  dfa->str_tree = (bin_tree_t *)((void *)0);
#line 969
  free((void *)dfa->org_indices);
#line 970
  dfa->org_indices = (Idx *)((void *)0);
  }
#line 971
  return;
}
}
#line 975 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t create_initial_state___0(re_dfa_t *dfa ) 
{ 
  Idx first ;
  Idx i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  Idx node_idx ;
  re_token_type_t type ;
  Idx clexp_idx ;
  re_token_t *clexp_node ;
  Idx dest_idx ;
  Idx __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_dfastate_t *tmp___4 ;
  re_dfastate_t *tmp___5 ;

  {
  {
#line 984
  first = ((dfa->str_tree)->first)->node_idx;
#line 985
  dfa->init_node = first;
#line 986
  err = re_node_set_init_copy___0(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
#line 987
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 987
  if (tmp) {
#line 988
    return (err);
  }
#line 994
  if (dfa->nbackref > 0UL) {
#line 995
    i = (Idx )0;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i < init_nodes.nelem)) {
#line 995
        goto while_break;
      }
#line 997
      node_idx = *(init_nodes.elems + i);
#line 998
      type = (dfa->nodes + node_idx)->type;
#line 1001
      if ((unsigned int )type != 4U) {
#line 1002
        goto __Cont;
      }
#line 1003
      clexp_idx = (Idx )0;
      {
#line 1003
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1003
        if (! (clexp_idx < init_nodes.nelem)) {
#line 1003
          goto while_break___0;
        }
#line 1006
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 1007
        if ((unsigned int )clexp_node->type == 9U) {
#line 1007
          if (clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
#line 1009
            goto while_break___0;
          }
        }
#line 1003
        clexp_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1011
      if (clexp_idx == init_nodes.nelem) {
#line 1012
        goto __Cont;
      }
#line 1014
      if ((unsigned int )type == 4U) {
        {
#line 1016
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
#line 1017
        tmp___0 = re_node_set_contains___0((re_node_set const   *)(& init_nodes),
                                           dest_idx);
        }
#line 1017
        if (! tmp___0) {
          {
#line 1019
          re_node_set_merge___0(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
#line 1020
          i = (Idx )0;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 995
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1026
  dfa->init_state = re_acquire_state_context___0(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                                 0U);
#line 1028
  tmp___1 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1028
  if (tmp___1) {
#line 1029
    return (err);
  }
#line 1030
  if ((dfa->init_state)->has_constraint) {
    {
#line 1032
    dfa->init_state_word = re_acquire_state_context___0(& err, (re_dfa_t const   *)dfa,
                                                        (re_node_set const   *)(& init_nodes),
                                                        1U);
#line 1034
    dfa->init_state_nl = re_acquire_state_context___0(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )(1 << 1));
#line 1036
    dfa->init_state_begbuf = re_acquire_state_context___0(& err, (re_dfa_t const   *)dfa,
                                                          (re_node_set const   *)(& init_nodes),
                                                          (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
#line 1040
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else
#line 1040
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else
#line 1040
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 1040
      tmp___2 = 1;
    } else {
#line 1040
      tmp___2 = 0;
    }
    {
#line 1040
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    }
#line 1040
    if (tmp___3) {
#line 1042
      return (err);
    }
  } else {
#line 1045
    tmp___5 = dfa->init_state;
#line 1045
    dfa->init_state_begbuf = tmp___5;
#line 1045
    tmp___4 = tmp___5;
#line 1045
    dfa->init_state_nl = tmp___4;
#line 1045
    dfa->init_state_word = tmp___4;
  }
  {
#line 1048
  free((void *)init_nodes.elems);
  }
#line 1049
  return ((reg_errcode_t )0);
}
}
#line 1057 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void optimize_utf8___0(re_dfa_t *dfa ) 
{ 
  Idx node ;
  int i ;
  _Bool mb_chars ;
  _Bool has_period ;
  int rshift ;
  int tmp ;

  {
#line 1062
  mb_chars = (_Bool)0;
#line 1063
  has_period = (_Bool)0;
#line 1065
  node = (Idx )0;
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if (! (node < dfa->nodes_len)) {
#line 1065
      goto while_break;
    }
    {
#line 1068
    if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1068
      goto case_1;
    }
#line 1072
    if ((unsigned int )(dfa->nodes + node)->type == 12U) {
#line 1072
      goto case_12;
    }
#line 1087
    if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1087
      goto case_5;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 11U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 2U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 10U) {
#line 1095
      goto case_9;
    }
#line 1095
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1095
      goto case_9;
    }
#line 1097
    if ((unsigned int )(dfa->nodes + node)->type == 6U) {
#line 1097
      goto case_6;
    }
#line 1099
    if ((unsigned int )(dfa->nodes + node)->type == 3U) {
#line 1099
      goto case_3;
    }
#line 1113
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 1069
    if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1070
      mb_chars = (_Bool)1;
    }
#line 1071
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 128U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 64U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 32U) {
#line 1078
      goto case_128;
    }
#line 1078
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 16U) {
#line 1078
      goto case_128;
    }
#line 1080
    goto switch_default;
    case_128: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 1079
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1084
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 1086
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1088
    has_period = (_Bool)1;
#line 1089
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1096
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1098
    return;
    case_3: /* CIL Label */ 
#line 1102
    rshift = 0;
#line 1105
    i = 2;
    {
#line 1105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1105
      if (! (i < 4)) {
#line 1105
        goto while_break___0;
      }
#line 1107
      if (*((dfa->nodes + node)->opr.sbcset + i) >> rshift != 0UL) {
#line 1108
        return;
      }
#line 1109
      rshift = 0;
#line 1105
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1112
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1114
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1065
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  if (mb_chars) {
#line 1117
    goto _L___0;
  } else
#line 1117
  if (has_period) {
    _L___0: /* CIL Label */ 
#line 1118
    node = (Idx )0;
    {
#line 1118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1118
      if (! (node < dfa->nodes_len)) {
#line 1118
        goto while_break___1;
      }
#line 1120
      if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1120
        if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1122
          (dfa->nodes + node)->mb_partial = 0U;
        } else {
#line 1120
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1123
      if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1124
        (dfa->nodes + node)->type = (re_token_type_t )7;
      }
#line 1118
      node ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1128
  dfa->mb_cur_max = 1;
#line 1129
  dfa->is_utf8 = 0U;
#line 1130
  if (dfa->nbackref > 0UL) {
#line 1130
    tmp = 1;
  } else
#line 1130
  if (has_period) {
#line 1130
    tmp = 1;
  } else {
#line 1130
    tmp = 0;
  }
#line 1130
  dfa->has_mb_node = (unsigned int )tmp;
#line 1131
  return;
}
}
#line 1137 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t analyze___0(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  Idx i ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;

  {
  {
#line 1140
  dfa = (re_dfa_t *)preg->buffer;
#line 1144
  tmp = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1144
  dfa->nexts = (Idx *)tmp;
#line 1145
  tmp___0 = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1145
  dfa->org_indices = (Idx *)tmp___0;
#line 1146
  tmp___1 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1146
  dfa->edests = (re_node_set *)tmp___1;
#line 1147
  tmp___2 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1147
  dfa->eclosures = (re_node_set *)tmp___2;
  }
#line 1148
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else
#line 1148
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
#line 1148
    tmp___3 = 1;
  } else {
#line 1148
    tmp___3 = 0;
  }
  {
#line 1148
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 1148
  if (tmp___4) {
#line 1150
    return ((reg_errcode_t )12);
  }
  {
#line 1152
  tmp___5 = malloc(preg->re_nsub * sizeof(Idx ));
#line 1152
  dfa->subexp_map = (Idx *)tmp___5;
  }
#line 1153
  if ((unsigned long )dfa->subexp_map != (unsigned long )((void *)0)) {
#line 1156
    i = (Idx )0;
    {
#line 1156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1156
      if (! (i < preg->re_nsub)) {
#line 1156
        goto while_break;
      }
#line 1157
      *(dfa->subexp_map + i) = i;
#line 1156
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1158
    preorder___0(dfa->str_tree, & optimize_subexps___0, (void *)dfa);
#line 1159
    i = (Idx )0;
    }
    {
#line 1159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1159
      if (! (i < preg->re_nsub)) {
#line 1159
        goto while_break___0;
      }
#line 1160
      if (*(dfa->subexp_map + i) != i) {
#line 1161
        goto while_break___0;
      }
#line 1159
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1162
    if (i == preg->re_nsub) {
      {
#line 1164
      free((void *)dfa->subexp_map);
#line 1165
      dfa->subexp_map = (Idx *)((void *)0);
      }
    }
  }
  {
#line 1169
  ret = postorder___0(dfa->str_tree, & lower_subexps___0, (void *)preg);
#line 1170
  tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1170
  if (tmp___6) {
#line 1171
    return (ret);
  }
  {
#line 1172
  ret = postorder___0(dfa->str_tree, & calc_first___0, (void *)dfa);
#line 1173
  tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1173
  if (tmp___7) {
#line 1174
    return (ret);
  }
  {
#line 1175
  preorder___0(dfa->str_tree, & calc_next___0, (void *)dfa);
#line 1176
  ret = preorder___0(dfa->str_tree, & link_nfa_nodes___0, (void *)dfa);
#line 1177
  tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1177
  if (tmp___8) {
#line 1178
    return (ret);
  }
  {
#line 1179
  ret = calc_eclosure___0(dfa);
#line 1180
  tmp___9 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1180
  if (tmp___9) {
#line 1181
    return (ret);
  }
#line 1185
  if (! preg->no_sub) {
#line 1185
    if (preg->re_nsub > 0UL) {
#line 1185
      if (dfa->has_plural_match) {
#line 1185
        goto _L;
      } else {
#line 1185
        goto _L___1;
      }
    } else {
#line 1185
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1185
  if (dfa->nbackref) {
    _L: /* CIL Label */ 
    {
#line 1188
    tmp___10 = malloc(dfa->nodes_len * sizeof(re_node_set ));
#line 1188
    dfa->inveclosures = (re_node_set *)tmp___10;
#line 1189
    tmp___11 = __builtin_expect((long )((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)),
                                0L);
    }
#line 1189
    if (tmp___11) {
#line 1190
      return ((reg_errcode_t )12);
    }
    {
#line 1191
    ret = calc_inveclosure___0(dfa);
    }
  }
#line 1194
  return (ret);
}
}
#line 1200 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t postorder___0(bin_tree_t *root , reg_errcode_t (*fn)(void * ,
                                                                          bin_tree_t * ) ,
                                   void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;

  {
#line 1206
  node = root;
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1210
      if (! node->left) {
#line 1210
        if (! node->right) {
#line 1210
          goto while_break___0;
        }
      }
#line 1211
      if (node->left) {
#line 1212
        node = node->left;
      } else {
#line 1214
        node = node->right;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1216
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1218
      tmp = (*fn)(extra, node);
#line 1218
      err = tmp;
#line 1219
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1219
      if (tmp___0) {
#line 1220
        return (err);
      }
#line 1221
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 1222
        return ((reg_errcode_t )0);
      }
#line 1223
      prev = node;
#line 1224
      node = node->parent;
#line 1216
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1216
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1216
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1228
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1232 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t preorder___0(bin_tree_t *root , reg_errcode_t (*fn)(void * ,
                                                                         bin_tree_t * ) ,
                                  void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  bin_tree_t *prev ;

  {
#line 1238
  node = root;
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1240
    tmp = (*fn)(extra, node);
#line 1240
    err = tmp;
#line 1241
    tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1241
    if (tmp___0) {
#line 1242
      return (err);
    }
#line 1245
    if (node->left) {
#line 1246
      node = node->left;
    } else {
#line 1249
      prev = (bin_tree_t *)((void *)0);
      {
#line 1250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1250
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1250
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1250
            goto while_break___0;
          }
        }
#line 1252
        prev = node;
#line 1253
        node = node->parent;
#line 1254
        if (! node) {
#line 1255
          return ((reg_errcode_t )0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1257
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1265 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t optimize_subexps___0(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  Idx other_idx ;

  {
#line 1268
  dfa = (re_dfa_t *)extra;
#line 1270
  if ((unsigned int )node->token.type == 4U) {
#line 1270
    if (dfa->subexp_map) {
#line 1272
      idx = (int )node->token.opr.idx;
#line 1273
      node->token.opr.idx = *(dfa->subexp_map + idx);
#line 1274
      dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
#line 1270
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1277
  if ((unsigned int )node->token.type == 17U) {
#line 1277
    if (node->left) {
#line 1277
      if ((unsigned int )(node->left)->token.type == 17U) {
#line 1280
        other_idx = (node->left)->token.opr.idx;
#line 1282
        node->left = (node->left)->left;
#line 1283
        if (node->left) {
#line 1284
          (node->left)->parent = node;
        }
#line 1286
        *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
#line 1287
        if (other_idx < 64UL) {
#line 1288
          dfa->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
#line 1291
  return ((reg_errcode_t )0);
}
}
#line 1296 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t lower_subexps___0(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err ;

  {
#line 1299
  preg = (regex_t *)extra;
#line 1300
  err = (reg_errcode_t )0;
#line 1302
  if (node->left) {
#line 1302
    if ((unsigned int )(node->left)->token.type == 17U) {
      {
#line 1304
      node->left = lower_subexp___0(& err, preg, node->left);
      }
#line 1305
      if (node->left) {
#line 1306
        (node->left)->parent = node;
      }
    }
  }
#line 1308
  if (node->right) {
#line 1308
    if ((unsigned int )(node->right)->token.type == 17U) {
      {
#line 1310
      node->right = lower_subexp___0(& err, preg, node->right);
      }
#line 1311
      if (node->right) {
#line 1312
        (node->right)->parent = node;
      }
    }
  }
#line 1315
  return (err);
}
}
#line 1318 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *lower_subexp___0(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1321
  dfa = (re_dfa_t *)preg->buffer;
#line 1322
  body = node->left;
#line 1325
  if (preg->no_sub) {
#line 1325
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1325
      if (node->token.opr.idx >= 64UL) {
#line 1334
        return (node->left);
      } else
#line 1325
      if (! (dfa->used_bkref_map & (1UL << node->token.opr.idx))) {
#line 1334
        return (node->left);
      }
    }
  }
  {
#line 1338
  op = create_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                       (re_token_type_t )8);
#line 1339
  cls = create_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                        (re_token_type_t )9);
  }
#line 1340
  if (body) {
    {
#line 1340
    tmp = create_tree___0(dfa, body, cls, (re_token_type_t )16);
#line 1340
    tree1 = tmp;
    }
  } else {
#line 1340
    tree1 = cls;
  }
  {
#line 1341
  tree = create_tree___0(dfa, op, tree1, (re_token_type_t )16);
  }
#line 1342
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else
#line 1342
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
#line 1342
    tmp___0 = 1;
  } else {
#line 1342
    tmp___0 = 0;
  }
  {
#line 1342
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1342
  if (tmp___1) {
#line 1344
    *err = (reg_errcode_t )12;
#line 1345
    return ((bin_tree_t *)((void *)0));
  }
#line 1348
  tmp___2 = node->token.opr.idx;
#line 1348
  cls->token.opr.idx = tmp___2;
#line 1348
  op->token.opr.idx = tmp___2;
#line 1349
  tmp___3 = node->token.opt_subexp;
#line 1349
  cls->token.opt_subexp = tmp___3;
#line 1349
  op->token.opt_subexp = tmp___3;
#line 1350
  return (tree);
}
}
#line 1355 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_first___0(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
#line 1358
  dfa = (re_dfa_t *)extra;
#line 1359
  if ((unsigned int )node->token.type == 16U) {
#line 1361
    node->first = (node->left)->first;
#line 1362
    node->node_idx = (node->left)->node_idx;
  } else {
    {
#line 1366
    node->first = node;
#line 1367
    node->node_idx = re_dfa_add_node___0(dfa, node->token);
#line 1368
    tmp = __builtin_expect((long )(node->node_idx == 0xffffffffffffffffUL), 0L);
    }
#line 1368
    if (tmp) {
#line 1369
      return ((reg_errcode_t )12);
    }
#line 1370
    if ((unsigned int )node->token.type == 12U) {
#line 1371
      (dfa->nodes + node->node_idx)->constraint = (unsigned int )node->token.opr.ctx_type;
    }
  }
#line 1373
  return ((reg_errcode_t )0);
}
}
#line 1377 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_next___0(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 1382
  if ((unsigned int )node->token.type == 11U) {
#line 1382
    goto case_11;
  }
#line 1385
  if ((unsigned int )node->token.type == 16U) {
#line 1385
    goto case_16;
  }
#line 1389
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1383
  (node->left)->next = node;
#line 1384
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1386
  (node->left)->next = (node->right)->first;
#line 1387
  (node->right)->next = node->next;
#line 1388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1390
  if (node->left) {
#line 1391
    (node->left)->next = node->next;
  }
#line 1392
  if (node->right) {
#line 1393
    (node->right)->next = node->next;
  }
#line 1394
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1396
  return ((reg_errcode_t )0);
}
}
#line 1400 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t link_nfa_nodes___0(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  Idx idx ;
  reg_errcode_t err ;
  Idx left ;
  Idx right ;

  {
#line 1403
  dfa = (re_dfa_t *)extra;
#line 1404
  idx = node->node_idx;
#line 1405
  err = (reg_errcode_t )0;
  {
#line 1409
  if ((unsigned int )node->token.type == 16U) {
#line 1409
    goto case_16;
  }
#line 1412
  if ((unsigned int )node->token.type == 2U) {
#line 1412
    goto case_2;
  }
#line 1417
  if ((unsigned int )node->token.type == 10U) {
#line 1417
    goto case_10;
  }
#line 1417
  if ((unsigned int )node->token.type == 11U) {
#line 1417
    goto case_10;
  }
#line 1437
  if ((unsigned int )node->token.type == 9U) {
#line 1437
    goto case_9;
  }
#line 1437
  if ((unsigned int )node->token.type == 8U) {
#line 1437
    goto case_9;
  }
#line 1437
  if ((unsigned int )node->token.type == 12U) {
#line 1437
    goto case_9;
  }
#line 1441
  if ((unsigned int )node->token.type == 4U) {
#line 1441
    goto case_4;
  }
#line 1447
  goto switch_default;
  case_16: /* CIL Label */ 
#line 1410
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1413
  if (! ((unsigned long )node->next == (unsigned long )((void *)0))) {
    {
#line 1413
    __assert_fail("node->next == NULL", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1413U, "link_nfa_nodes");
    }
  }
#line 1414
  goto switch_break;
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 1420
  dfa->has_plural_match = 1U;
#line 1421
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1422
    left = ((node->left)->first)->node_idx;
  } else {
#line 1424
    left = (node->next)->node_idx;
  }
#line 1425
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1426
    right = ((node->right)->first)->node_idx;
  } else {
#line 1428
    right = (node->next)->node_idx;
  }
#line 1429
  if (! (left < 0xfffffffffffffffeUL)) {
    {
#line 1429
    __assert_fail("REG_VALID_INDEX (left)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1429U, "link_nfa_nodes");
    }
  }
#line 1430
  if (! (right < 0xfffffffffffffffeUL)) {
    {
#line 1430
    __assert_fail("REG_VALID_INDEX (right)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1430U, "link_nfa_nodes");
    }
  }
  {
#line 1431
  err = re_node_set_init_2___0(dfa->edests + idx, left, right);
  }
#line 1433
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 1438
  err = re_node_set_init_1___0(dfa->edests + idx, (node->next)->node_idx);
  }
#line 1439
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1442
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1443
  if ((unsigned int )node->token.type == 4U) {
    {
#line 1444
    re_node_set_init_1___0(dfa->edests + idx, *(dfa->nexts + idx));
    }
  }
#line 1445
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1448
  if (! (! ((unsigned int )node->token.type & 8U))) {
    {
#line 1448
    __assert_fail("!IS_EPSILON_NODE (node->token.type)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                  1448U, "link_nfa_nodes");
    }
  }
#line 1449
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1450
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1453
  return (err);
}
}
#line 1460 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t duplicate_node_closure___0(re_dfa_t *dfa , Idx top_org_node ,
                                                Idx top_clone_node , Idx root_node ,
                                                unsigned int init_constraint ) 
{ 
  Idx org_node ;
  Idx clone_node ;
  _Bool ok ;
  unsigned int constraint ;
  Idx org_dest ;
  Idx clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  reg_errcode_t err ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 1467
  constraint = init_constraint;
#line 1468
  org_node = top_org_node;
#line 1468
  clone_node = top_clone_node;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1471
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
      {
#line 1477
      org_dest = *(dfa->nexts + org_node);
#line 1478
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1479
      clone_dest = duplicate_node___0(dfa, org_dest, constraint);
#line 1480
      tmp = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1480
      if (tmp) {
#line 1481
        return ((reg_errcode_t )12);
      }
      {
#line 1482
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1483
      ok = re_node_set_insert___0(dfa->edests + clone_node, clone_dest);
#line 1484
      tmp___0 = __builtin_expect((long )(! ok), 0L);
      }
#line 1484
      if (tmp___0) {
#line 1485
        return ((reg_errcode_t )12);
      }
    } else
#line 1487
    if ((dfa->edests + org_node)->nelem == 0UL) {
#line 1492
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1493
      goto while_break;
    } else
#line 1495
    if ((dfa->edests + org_node)->nelem == 1UL) {
      {
#line 1499
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1500
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1501
      clone_dest = search_duplicated_node___0((re_dfa_t const   *)dfa, org_dest, constraint);
      }
#line 1504
      if (org_node == root_node) {
#line 1504
        if (clone_node != org_node) {
          {
#line 1506
          ok = re_node_set_insert___0(dfa->edests + clone_node, org_dest);
#line 1507
          tmp___1 = __builtin_expect((long )(! ok), 0L);
          }
#line 1507
          if (tmp___1) {
#line 1508
            return ((reg_errcode_t )12);
          }
#line 1509
          goto while_break;
        }
      }
      {
#line 1512
      constraint |= (dfa->nodes + org_node)->constraint;
#line 1513
      clone_dest = duplicate_node___0(dfa, org_dest, constraint);
#line 1514
      tmp___2 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1514
      if (tmp___2) {
#line 1515
        return ((reg_errcode_t )12);
      }
      {
#line 1516
      ok = re_node_set_insert___0(dfa->edests + clone_node, clone_dest);
#line 1517
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 1517
      if (tmp___3) {
#line 1518
        return ((reg_errcode_t )12);
      }
    } else {
      {
#line 1524
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1525
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1527
      clone_dest = search_duplicated_node___0((re_dfa_t const   *)dfa, org_dest, constraint);
      }
#line 1528
      if (clone_dest == 0xffffffffffffffffUL) {
        {
#line 1532
        clone_dest = duplicate_node___0(dfa, org_dest, constraint);
#line 1533
        tmp___4 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
        }
#line 1533
        if (tmp___4) {
#line 1534
          return ((reg_errcode_t )12);
        }
        {
#line 1535
        ok = re_node_set_insert___0(dfa->edests + clone_node, clone_dest);
#line 1536
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1536
        if (tmp___5) {
#line 1537
          return ((reg_errcode_t )12);
        }
        {
#line 1538
        err = duplicate_node_closure___0(dfa, org_dest, clone_dest, root_node, constraint);
#line 1540
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1540
        if (tmp___6) {
#line 1541
          return (err);
        }
      } else {
        {
#line 1547
        ok = re_node_set_insert___0(dfa->edests + clone_node, clone_dest);
#line 1548
        tmp___7 = __builtin_expect((long )(! ok), 0L);
        }
#line 1548
        if (tmp___7) {
#line 1549
          return ((reg_errcode_t )12);
        }
      }
      {
#line 1552
      org_dest = *((dfa->edests + org_node)->elems + 1);
#line 1553
      clone_dest = duplicate_node___0(dfa, org_dest, constraint);
#line 1554
      tmp___8 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
      }
#line 1554
      if (tmp___8) {
#line 1555
        return ((reg_errcode_t )12);
      }
      {
#line 1556
      ok = re_node_set_insert___0(dfa->edests + clone_node, clone_dest);
#line 1557
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 1557
      if (tmp___9) {
#line 1558
        return ((reg_errcode_t )12);
      }
    }
#line 1560
    org_node = org_dest;
#line 1561
    clone_node = clone_dest;
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  return ((reg_errcode_t )0);
}
}
#line 1569 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx search_duplicated_node___0(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) 
{ 
  Idx idx ;

  {
#line 1574
  idx = (Idx )(dfa->nodes_len - 1UL);
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if ((dfa->nodes + idx)->duplicated) {
#line 1574
      if (! (idx > 0UL)) {
#line 1574
        goto while_break;
      }
    } else {
#line 1574
      goto while_break;
    }
#line 1576
    if (org_node == *(dfa->org_indices + idx)) {
#line 1576
      if (constraint == (dfa->nodes + idx)->constraint) {
#line 1578
        return (idx);
      }
    }
#line 1574
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1580
  return ((Idx )-1);
}
}
#line 1587 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx duplicate_node___0(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) 
{ 
  Idx dup_idx ;
  Idx tmp ;
  long tmp___0 ;

  {
  {
#line 1590
  tmp = re_dfa_add_node___0(dfa, *(dfa->nodes + org_idx));
#line 1590
  dup_idx = tmp;
#line 1591
  tmp___0 = __builtin_expect((long )(dup_idx != 0xffffffffffffffffUL), 1L);
  }
#line 1591
  if (tmp___0) {
#line 1593
    (dfa->nodes + dup_idx)->constraint = constraint;
#line 1594
    (dfa->nodes + dup_idx)->constraint |= (dfa->nodes + org_idx)->constraint;
#line 1595
    (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1598
    *(dfa->org_indices + dup_idx) = org_idx;
  }
#line 1600
  return (dup_idx);
}
}
#line 1603 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_inveclosure___0(re_dfa_t *dfa ) 
{ 
  Idx src ;
  Idx idx ;
  _Bool ok ;
  Idx *elems ;
  long tmp ;

  {
#line 1608
  idx = (Idx )0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (idx < dfa->nodes_len)) {
#line 1608
      goto while_break;
    }
    {
#line 1609
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
#line 1608
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  src = (Idx )0;
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (! (src < dfa->nodes_len)) {
#line 1611
      goto while_break___0;
    }
#line 1613
    elems = (dfa->eclosures + src)->elems;
#line 1614
    idx = (Idx )0;
    {
#line 1614
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1614
      if (! (idx < (dfa->eclosures + src)->nelem)) {
#line 1614
        goto while_break___1;
      }
      {
#line 1616
      ok = re_node_set_insert_last___0(dfa->inveclosures + *(elems + idx), src);
#line 1617
      tmp = __builtin_expect((long )(! ok), 0L);
      }
#line 1617
      if (tmp) {
#line 1618
        return ((reg_errcode_t )12);
      }
#line 1614
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1611
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1622
  return ((reg_errcode_t )0);
}
}
#line 1627 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure___0(re_dfa_t *dfa ) 
{ 
  Idx node_idx ;
  _Bool incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
#line 1635
  incomplete = (_Bool)0;
#line 1637
  node_idx = (Idx )0;
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (node_idx == dfa->nodes_len) {
#line 1643
      if (! incomplete) {
#line 1644
        goto while_break;
      }
#line 1645
      incomplete = (_Bool)0;
#line 1646
      node_idx = (Idx )0;
    }
#line 1654
    if ((dfa->eclosures + node_idx)->nelem != 0UL) {
#line 1655
      goto __Cont;
    }
    {
#line 1657
    err = calc_eclosure_iter___0(& eclosure_elem, dfa, node_idx, (_Bool)1);
#line 1658
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1658
    if (tmp) {
#line 1659
      return (err);
    }
#line 1661
    if ((dfa->eclosures + node_idx)->nelem == 0UL) {
      {
#line 1663
      incomplete = (_Bool)1;
#line 1664
      free((void *)eclosure_elem.elems);
      }
    }
    __Cont: /* CIL Label */ 
#line 1637
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1667
  return ((reg_errcode_t )0);
}
}
#line 1672 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure_iter___0(re_node_set *new_set , re_dfa_t *dfa ,
                                            Idx node , _Bool root ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  _Bool incomplete ;
  _Bool ok ;
  re_node_set eclosure ;
  long tmp ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  Idx edest ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1680
  incomplete = (_Bool)0;
#line 1681
  err = re_node_set_alloc___0(& eclosure, (dfa->edests + node)->nelem + 1UL);
#line 1682
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1682
  if (tmp) {
#line 1683
    return (err);
  }
#line 1687
  (dfa->eclosures + node)->nelem = (Idx )-1;
#line 1691
  if ((dfa->nodes + node)->constraint) {
#line 1691
    if ((dfa->edests + node)->nelem) {
#line 1691
      if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
        {
#line 1695
        err = duplicate_node_closure___0(dfa, node, node, node, (dfa->nodes + node)->constraint);
#line 1697
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1697
        if (tmp___0) {
#line 1698
          return (err);
        }
      }
    }
  }
#line 1702
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1703
    i = (Idx )0;
    {
#line 1703
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1703
      if (! (i < (dfa->edests + node)->nelem)) {
#line 1703
        goto while_break;
      }
#line 1706
      edest = *((dfa->edests + node)->elems + i);
#line 1709
      if ((dfa->eclosures + edest)->nelem == 0xffffffffffffffffUL) {
#line 1711
        incomplete = (_Bool)1;
#line 1712
        goto __Cont;
      }
#line 1716
      if ((dfa->eclosures + edest)->nelem == 0UL) {
        {
#line 1718
        err = calc_eclosure_iter___0(& eclosure_elem, dfa, edest, (_Bool)0);
#line 1719
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1719
        if (tmp___1) {
#line 1720
          return (err);
        }
      } else {
#line 1723
        eclosure_elem = *(dfa->eclosures + edest);
      }
      {
#line 1725
      re_node_set_merge___0(& eclosure, (re_node_set const   *)(& eclosure_elem));
      }
#line 1728
      if ((dfa->eclosures + edest)->nelem == 0UL) {
        {
#line 1730
        incomplete = (_Bool)1;
#line 1731
        free((void *)eclosure_elem.elems);
        }
      }
      __Cont: /* CIL Label */ 
#line 1703
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1736
  ok = re_node_set_insert___0(& eclosure, node);
#line 1737
  tmp___2 = __builtin_expect((long )(! ok), 0L);
  }
#line 1737
  if (tmp___2) {
#line 1738
    return ((reg_errcode_t )12);
  }
#line 1739
  if (incomplete) {
#line 1739
    if (! root) {
#line 1740
      (dfa->eclosures + node)->nelem = (Idx )0;
    } else {
#line 1742
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
#line 1742
    *(dfa->eclosures + node) = eclosure;
  }
#line 1743
  *new_set = eclosure;
#line 1744
  return ((reg_errcode_t )0);
}
}
#line 1752 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void fetch_token___0(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp ;

  {
  {
#line 1756
  tmp = peek_token___0(result, input, syntax);
#line 1756
  input->cur_idx += (Idx )tmp;
  }
#line 1757
  return;
}
}
#line 1762 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static int peek_token___0(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp ;
  wint_t wc ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  wint_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char prev ;
  re_token_t next ;

  {
#line 1768
  if (input->stop <= input->cur_idx) {
#line 1770
    token->type = (re_token_type_t )2;
#line 1771
    return (0);
  }
#line 1774
  c = *(input->mbs + input->cur_idx);
#line 1775
  token->opr.c = c;
#line 1777
  token->word_char = 0U;
#line 1779
  token->mb_partial = 0U;
#line 1780
  if (input->mb_cur_max > 1) {
#line 1780
    if (! (input->cur_idx == input->valid_len)) {
#line 1780
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1783
        token->type = (re_token_type_t )1;
#line 1784
        token->mb_partial = 1U;
#line 1785
        return (1);
      }
    }
  }
#line 1788
  if ((int )c == 92) {
#line 1791
    if (input->cur_idx + 1UL >= input->len) {
#line 1793
      token->type = (re_token_type_t )36;
#line 1794
      return (1);
    }
    {
#line 1797
    tmp = re_string_peek_byte_case___0((re_string_t const   *)input, (Idx )1);
#line 1797
    c2 = (unsigned char )tmp;
#line 1798
    token->opr.c = c2;
#line 1799
    token->type = (re_token_type_t )1;
    }
#line 1801
    if (input->mb_cur_max > 1) {
      {
#line 1803
      tmp___0 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1UL);
#line 1803
      wc = (wint_t )tmp___0;
#line 1805
      tmp___1 = iswalnum(wc);
      }
#line 1805
      if (tmp___1) {
#line 1805
        tmp___2 = 1;
      } else
#line 1805
      if (wc == 95U) {
#line 1805
        tmp___2 = 1;
      } else {
#line 1805
        tmp___2 = 0;
      }
#line 1805
      token->word_char = (unsigned int )(tmp___2 != 0);
    } else {
      {
#line 1809
      tmp___3 = __ctype_b_loc();
      }
#line 1809
      if ((int const   )*(*tmp___3 + (int )c2) & 8) {
#line 1809
        tmp___4 = 1;
      } else
#line 1809
      if ((int )c2 == 95) {
#line 1809
        tmp___4 = 1;
      } else {
#line 1809
        tmp___4 = 0;
      }
#line 1809
      token->word_char = (unsigned int )(tmp___4 != 0);
    }
    {
#line 1813
    if ((int )c2 == 124) {
#line 1813
      goto case_124;
    }
#line 1818
    if ((int )c2 == 57) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 56) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 55) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 54) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 53) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 52) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 51) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 50) {
#line 1818
      goto case_57;
    }
#line 1818
    if ((int )c2 == 49) {
#line 1818
      goto case_57;
    }
#line 1825
    if ((int )c2 == 60) {
#line 1825
      goto case_60;
    }
#line 1832
    if ((int )c2 == 62) {
#line 1832
      goto case_62;
    }
#line 1839
    if ((int )c2 == 98) {
#line 1839
      goto case_98;
    }
#line 1846
    if ((int )c2 == 66) {
#line 1846
      goto case_66;
    }
#line 1853
    if ((int )c2 == 119) {
#line 1853
      goto case_119;
    }
#line 1857
    if ((int )c2 == 87) {
#line 1857
      goto case_87;
    }
#line 1861
    if ((int )c2 == 115) {
#line 1861
      goto case_115;
    }
#line 1865
    if ((int )c2 == 83) {
#line 1865
      goto case_83;
    }
#line 1869
    if ((int )c2 == 96) {
#line 1869
      goto case_96;
    }
#line 1876
    if ((int )c2 == 39) {
#line 1876
      goto case_39;
    }
#line 1883
    if ((int )c2 == 40) {
#line 1883
      goto case_40;
    }
#line 1887
    if ((int )c2 == 41) {
#line 1887
      goto case_41;
    }
#line 1891
    if ((int )c2 == 43) {
#line 1891
      goto case_43;
    }
#line 1895
    if ((int )c2 == 63) {
#line 1895
      goto case_63;
    }
#line 1899
    if ((int )c2 == 123) {
#line 1899
      goto case_123;
    }
#line 1903
    if ((int )c2 == 125) {
#line 1903
      goto case_125;
    }
#line 1907
    goto switch_default;
    case_124: /* CIL Label */ 
#line 1814
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1814
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1815
        token->type = (re_token_type_t )10;
      }
    }
#line 1816
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1819
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1821
      token->type = (re_token_type_t )4;
#line 1822
      token->opr.idx = (Idx )((int )c2 - 49);
    }
#line 1824
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1826
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1828
      token->type = (re_token_type_t )12;
#line 1829
      token->opr.ctx_type = (re_context_type )6;
    }
#line 1831
    goto switch_break;
    case_62: /* CIL Label */ 
#line 1833
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1835
      token->type = (re_token_type_t )12;
#line 1836
      token->opr.ctx_type = (re_context_type )9;
    }
#line 1838
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1840
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1842
      token->type = (re_token_type_t )12;
#line 1843
      token->opr.ctx_type = (re_context_type )256;
    }
#line 1845
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1847
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1849
      token->type = (re_token_type_t )12;
#line 1850
      token->opr.ctx_type = (re_context_type )512;
    }
#line 1852
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1854
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1855
      token->type = (re_token_type_t )32;
    }
#line 1856
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1858
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1859
      token->type = (re_token_type_t )33;
    }
#line 1860
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1862
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1863
      token->type = (re_token_type_t )34;
    }
#line 1864
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1866
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1867
      token->type = (re_token_type_t )35;
    }
#line 1868
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1870
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1872
      token->type = (re_token_type_t )12;
#line 1873
      token->opr.ctx_type = (re_context_type )64;
    }
#line 1875
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1877
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1879
      token->type = (re_token_type_t )12;
#line 1880
      token->opr.ctx_type = (re_context_type )128;
    }
#line 1882
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1884
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1885
      token->type = (re_token_type_t )8;
    }
#line 1886
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1888
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1889
      token->type = (re_token_type_t )9;
    }
#line 1890
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1892
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1892
      if (syntax & (1UL << 1)) {
#line 1893
        token->type = (re_token_type_t )18;
      }
    }
#line 1894
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1896
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1896
      if (syntax & (1UL << 1)) {
#line 1897
        token->type = (re_token_type_t )19;
      }
    }
#line 1898
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1900
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1900
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1901
        token->type = (re_token_type_t )23;
      }
    }
#line 1902
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1904
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1904
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1905
        token->type = (re_token_type_t )24;
      }
    }
#line 1906
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1908
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1910
    return (2);
  }
#line 1913
  token->type = (re_token_type_t )1;
#line 1915
  if (input->mb_cur_max > 1) {
    {
#line 1917
    tmp___5 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1917
    wc___0 = (wint_t )tmp___5;
#line 1918
    tmp___6 = iswalnum(wc___0);
    }
#line 1918
    if (tmp___6) {
#line 1918
      tmp___7 = 1;
    } else
#line 1918
    if (wc___0 == 95U) {
#line 1918
      tmp___7 = 1;
    } else {
#line 1918
      tmp___7 = 0;
    }
#line 1918
    token->word_char = (unsigned int )(tmp___7 != 0);
  } else {
    {
#line 1922
    tmp___8 = __ctype_b_loc();
    }
#line 1922
    if ((int const   )*(*tmp___8 + (int )token->opr.c) & 8) {
#line 1922
      tmp___9 = 1;
    } else
#line 1922
    if ((int )token->opr.c == 95) {
#line 1922
      tmp___9 = 1;
    } else {
#line 1922
      tmp___9 = 0;
    }
#line 1922
    token->word_char = (unsigned int )tmp___9;
  }
  {
#line 1926
  if ((int )c == 10) {
#line 1926
    goto case_10;
  }
#line 1930
  if ((int )c == 124) {
#line 1930
    goto case_124___0;
  }
#line 1934
  if ((int )c == 42) {
#line 1934
    goto case_42;
  }
#line 1937
  if ((int )c == 43) {
#line 1937
    goto case_43___0;
  }
#line 1941
  if ((int )c == 63) {
#line 1941
    goto case_63___0;
  }
#line 1945
  if ((int )c == 123) {
#line 1945
    goto case_123___0;
  }
#line 1949
  if ((int )c == 125) {
#line 1949
    goto case_125___0;
  }
#line 1953
  if ((int )c == 40) {
#line 1953
    goto case_40___0;
  }
#line 1957
  if ((int )c == 41) {
#line 1957
    goto case_41___0;
  }
#line 1961
  if ((int )c == 91) {
#line 1961
    goto case_91;
  }
#line 1964
  if ((int )c == 46) {
#line 1964
    goto case_46;
  }
#line 1967
  if ((int )c == 94) {
#line 1967
    goto case_94;
  }
#line 1978
  if ((int )c == 36) {
#line 1978
    goto case_36;
  }
#line 1992
  goto switch_default___0;
  case_10: /* CIL Label */ 
#line 1927
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1928
    token->type = (re_token_type_t )10;
  }
#line 1929
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
#line 1931
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1931
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1932
      token->type = (re_token_type_t )10;
    }
  }
#line 1933
  goto switch_break___0;
  case_42: /* CIL Label */ 
#line 1935
  token->type = (re_token_type_t )11;
#line 1936
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
#line 1938
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1938
    if (! (syntax & (1UL << 1))) {
#line 1939
      token->type = (re_token_type_t )18;
    }
  }
#line 1940
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
#line 1942
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1942
    if (! (syntax & (1UL << 1))) {
#line 1943
      token->type = (re_token_type_t )19;
    }
  }
#line 1944
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
#line 1946
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1946
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1947
      token->type = (re_token_type_t )23;
    }
  }
#line 1948
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 1950
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1950
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1951
      token->type = (re_token_type_t )24;
    }
  }
#line 1952
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
#line 1954
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1955
    token->type = (re_token_type_t )8;
  }
#line 1956
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
#line 1958
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1959
    token->type = (re_token_type_t )9;
  }
#line 1960
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 1962
  token->type = (re_token_type_t )20;
#line 1963
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 1965
  token->type = (re_token_type_t )5;
#line 1966
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 1968
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1968
    if (input->cur_idx != 0UL) {
#line 1971
      prev = (char )*(input->mbs + (input->cur_idx + 0xffffffffffffffffUL));
#line 1972
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1973
        goto switch_break___0;
      } else
#line 1972
      if ((int )prev != 10) {
#line 1973
        goto switch_break___0;
      }
    }
  }
#line 1975
  token->type = (re_token_type_t )12;
#line 1976
  token->opr.ctx_type = (re_context_type )16;
#line 1977
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 1979
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 1979
    if (input->cur_idx + 1UL != input->len) {
      {
#line 1983
      (input->cur_idx) ++;
#line 1984
      peek_token___0(& next, input, syntax);
#line 1985
      (input->cur_idx) --;
      }
#line 1986
      if ((unsigned int )next.type != 10U) {
#line 1986
        if ((unsigned int )next.type != 9U) {
#line 1987
          goto switch_break___0;
        }
      }
    }
  }
#line 1989
  token->type = (re_token_type_t )12;
#line 1990
  token->opr.ctx_type = (re_context_type )32;
#line 1991
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1993
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1995
  return (1);
}
}
#line 2001 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static int peek_token_bracket___0(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 2006
  if (input->stop <= input->cur_idx) {
#line 2008
    token->type = (re_token_type_t )2;
#line 2009
    return (0);
  }
#line 2011
  c = *(input->mbs + input->cur_idx);
#line 2012
  token->opr.c = c;
#line 2015
  if (input->mb_cur_max > 1) {
#line 2015
    if (! (input->cur_idx == input->valid_len)) {
#line 2015
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 2018
        token->type = (re_token_type_t )1;
#line 2019
        return (1);
      }
    }
  }
#line 2023
  if ((int )c == 92) {
#line 2023
    if (syntax & 1UL) {
#line 2023
      if (input->cur_idx + 1UL < input->len) {
#line 2028
        (input->cur_idx) ++;
#line 2029
        c2 = *(input->mbs + input->cur_idx);
#line 2030
        token->opr.c = c2;
#line 2031
        token->type = (re_token_type_t )1;
#line 2032
        return (1);
      }
    }
  }
#line 2034
  if ((int )c == 91) {
#line 2038
    if (input->cur_idx + 1UL < input->len) {
#line 2039
      c2___0 = *(input->mbs + (input->cur_idx + 1UL));
    } else {
#line 2041
      c2___0 = (unsigned char)0;
    }
#line 2042
    token->opr.c = c2___0;
#line 2043
    token_len = 2;
    {
#line 2046
    if ((int )c2___0 == 46) {
#line 2046
      goto case_46;
    }
#line 2049
    if ((int )c2___0 == 61) {
#line 2049
      goto case_61;
    }
#line 2052
    if ((int )c2___0 == 58) {
#line 2052
      goto case_58;
    }
#line 2059
    goto switch_default;
    case_46: /* CIL Label */ 
#line 2047
    token->type = (re_token_type_t )26;
#line 2048
    goto switch_break;
    case_61: /* CIL Label */ 
#line 2050
    token->type = (re_token_type_t )28;
#line 2051
    goto switch_break;
    case_58: /* CIL Label */ 
#line 2053
    if (syntax & ((1UL << 1) << 1)) {
#line 2055
      token->type = (re_token_type_t )30;
#line 2056
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 2060
    token->type = (re_token_type_t )1;
#line 2061
    token->opr.c = c;
#line 2062
    token_len = 1;
#line 2063
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2065
    return (token_len);
  }
  {
#line 2069
  if ((int )c == 45) {
#line 2069
    goto case_45;
  }
#line 2072
  if ((int )c == 93) {
#line 2072
    goto case_93;
  }
#line 2075
  if ((int )c == 94) {
#line 2075
    goto case_94;
  }
#line 2078
  goto switch_default___0;
  case_45: /* CIL Label */ 
#line 2070
  token->type = (re_token_type_t )22;
#line 2071
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 2073
  token->type = (re_token_type_t )21;
#line 2074
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 2076
  token->type = (re_token_type_t )25;
#line 2077
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2079
  token->type = (re_token_type_t )1;
  switch_break___0: /* CIL Label */ ;
  }
#line 2081
  return (1);
}
}
#line 2098 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse___0(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                             reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2102
  dfa = (re_dfa_t *)preg->buffer;
#line 2105
  dfa->syntax = syntax;
#line 2106
  fetch_token___0(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2107
  tree = parse_reg_exp___0(regexp, preg, & current_token, syntax, (Idx )0, err);
  }
#line 2108
  if ((int )*err != 0) {
#line 2108
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2108
      tmp = 1;
    } else {
#line 2108
      tmp = 0;
    }
  } else {
#line 2108
    tmp = 0;
  }
  {
#line 2108
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2108
  if (tmp___0) {
#line 2109
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2110
  eor = create_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                        (re_token_type_t )2);
  }
#line 2111
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
#line 2112
    root = create_tree___0(dfa, tree, eor, (re_token_type_t )16);
    }
  } else {
#line 2114
    root = eor;
  }
#line 2115
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 2115
    tmp___1 = 1;
  } else
#line 2115
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 2115
    tmp___1 = 1;
  } else {
#line 2115
    tmp___1 = 0;
  }
  {
#line 2115
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2115
  if (tmp___2) {
#line 2117
    *err = (reg_errcode_t )12;
#line 2118
    return ((bin_tree_t *)((void *)0));
  }
#line 2120
  return (root);
}
}
#line 2132 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_reg_exp___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                     reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2136
  dfa = (re_dfa_t *)preg->buffer;
#line 2137
  branch = (bin_tree_t *)((void *)0);
#line 2138
  tree = parse_branch___0(regexp, preg, token, syntax, nest, err);
  }
#line 2139
  if ((int )*err != 0) {
#line 2139
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2139
      tmp = 1;
    } else {
#line 2139
      tmp = 0;
    }
  } else {
#line 2139
    tmp = 0;
  }
  {
#line 2139
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2139
  if (tmp___0) {
#line 2140
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2142
    if (! ((unsigned int )token->type == 10U)) {
#line 2142
      goto while_break;
    }
    {
#line 2144
    fetch_token___0(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
#line 2145
    if ((unsigned int )token->type != 10U) {
#line 2145
      if ((unsigned int )token->type != 2U) {
#line 2145
        if (nest == 0UL) {
#line 2145
          goto _L;
        } else
#line 2145
        if ((unsigned int )token->type != 9U) {
          _L: /* CIL Label */ 
          {
#line 2148
          branch = parse_branch___0(regexp, preg, token, syntax, nest, err);
          }
#line 2149
          if ((int )*err != 0) {
#line 2149
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
#line 2149
              tmp___1 = 1;
            } else {
#line 2149
              tmp___1 = 0;
            }
          } else {
#line 2149
            tmp___1 = 0;
          }
          {
#line 2149
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
          }
#line 2149
          if (tmp___2) {
#line 2150
            return ((bin_tree_t *)((void *)0));
          }
        } else {
#line 2153
          branch = (bin_tree_t *)((void *)0);
        }
      } else {
#line 2153
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
#line 2153
      branch = (bin_tree_t *)((void *)0);
    }
    {
#line 2154
    tree = create_tree___0(dfa, tree, branch, (re_token_type_t )10);
#line 2155
    tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 2155
    if (tmp___3) {
#line 2157
      *err = (reg_errcode_t )12;
#line 2158
      return ((bin_tree_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2161
  return (tree);
}
}
#line 2173 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_branch___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *expr ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2178
  dfa = (re_dfa_t *)preg->buffer;
#line 2179
  tree = parse_expression___0(regexp, preg, token, syntax, nest, err);
  }
#line 2180
  if ((int )*err != 0) {
#line 2180
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2180
      tmp = 1;
    } else {
#line 2180
      tmp = 0;
    }
  } else {
#line 2180
    tmp = 0;
  }
  {
#line 2180
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2180
  if (tmp___0) {
#line 2181
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2183
    if ((unsigned int )token->type != 10U) {
#line 2183
      if ((unsigned int )token->type != 2U) {
#line 2183
        if (! (nest == 0UL)) {
#line 2183
          if (! ((unsigned int )token->type != 9U)) {
#line 2183
            goto while_break;
          }
        }
      } else {
#line 2183
        goto while_break;
      }
    } else {
#line 2183
      goto while_break;
    }
    {
#line 2186
    expr = parse_expression___0(regexp, preg, token, syntax, nest, err);
    }
#line 2187
    if ((int )*err != 0) {
#line 2187
      if ((unsigned long )expr == (unsigned long )((void *)0)) {
#line 2187
        tmp___1 = 1;
      } else {
#line 2187
        tmp___1 = 0;
      }
    } else {
#line 2187
      tmp___1 = 0;
    }
    {
#line 2187
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2187
    if (tmp___2) {
#line 2189
      return ((bin_tree_t *)((void *)0));
    }
#line 2191
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2191
      if ((unsigned long )expr != (unsigned long )((void *)0)) {
        {
#line 2193
        tree = create_tree___0(dfa, tree, expr, (re_token_type_t )16);
        }
#line 2194
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2196
          *err = (reg_errcode_t )12;
#line 2197
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2191
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2200
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2201
      tree = expr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2204
  return (tree);
}
}
#line 2213 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_expression___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                        reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  long tmp ;
  bin_tree_t *mbc_remain ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bin_tree_t *tmp___8 ;
  long tmp___9 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;

  {
#line 2217
  dfa = (re_dfa_t *)preg->buffer;
  {
#line 2221
  if ((unsigned int )token->type == 1U) {
#line 2221
    goto case_1;
  }
#line 2247
  if ((unsigned int )token->type == 8U) {
#line 2247
    goto case_8;
  }
#line 2252
  if ((unsigned int )token->type == 20U) {
#line 2252
    goto case_20;
  }
#line 2257
  if ((unsigned int )token->type == 4U) {
#line 2257
    goto case_4;
  }
#line 2273
  if ((unsigned int )token->type == 23U) {
#line 2273
    goto case_23;
  }
#line 2282
  if ((unsigned int )token->type == 19U) {
#line 2282
    goto case_19;
  }
#line 2282
  if ((unsigned int )token->type == 18U) {
#line 2282
    goto case_19;
  }
#line 2282
  if ((unsigned int )token->type == 11U) {
#line 2282
    goto case_19;
  }
#line 2294
  if ((unsigned int )token->type == 9U) {
#line 2294
    goto case_9;
  }
#line 2302
  if ((unsigned int )token->type == 24U) {
#line 2302
    goto case_24;
  }
#line 2316
  if ((unsigned int )token->type == 12U) {
#line 2316
    goto case_12;
  }
#line 2360
  if ((unsigned int )token->type == 5U) {
#line 2360
    goto case_5;
  }
#line 2371
  if ((unsigned int )token->type == 33U) {
#line 2371
    goto case_33;
  }
#line 2371
  if ((unsigned int )token->type == 32U) {
#line 2371
    goto case_33;
  }
#line 2380
  if ((unsigned int )token->type == 35U) {
#line 2380
    goto case_35;
  }
#line 2380
  if ((unsigned int )token->type == 34U) {
#line 2380
    goto case_35;
  }
#line 2389
  if ((unsigned int )token->type == 2U) {
#line 2389
    goto case_2;
  }
#line 2389
  if ((unsigned int )token->type == 10U) {
#line 2389
    goto case_2;
  }
#line 2391
  if ((unsigned int )token->type == 36U) {
#line 2391
    goto case_36;
  }
#line 2394
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2222
  tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_t const   *)token);
#line 2223
  tmp = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                         0L);
  }
#line 2223
  if (tmp) {
#line 2225
    *err = (reg_errcode_t )12;
#line 2226
    return ((bin_tree_t *)((void *)0));
  }
#line 2229
  if (dfa->mb_cur_max > 1) {
    {
#line 2231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2231
      if (! (regexp->stop <= regexp->cur_idx)) {
#line 2231
        if (regexp->cur_idx == regexp->valid_len) {
#line 2231
          goto while_break;
        } else
#line 2231
        if (*(regexp->wcs + regexp->cur_idx) != 4294967295U) {
#line 2231
          goto while_break;
        }
      } else {
#line 2231
        goto while_break;
      }
      {
#line 2235
      fetch_token___0(token, regexp, syntax);
#line 2236
      mbc_remain = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                         (re_token_t const   *)token);
#line 2237
      tree = create_tree___0(dfa, tree, mbc_remain, (re_token_type_t )16);
      }
#line 2238
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 2238
        tmp___0 = 1;
      } else
#line 2238
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2238
        tmp___0 = 1;
      } else {
#line 2238
        tmp___0 = 0;
      }
      {
#line 2238
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
      }
#line 2238
      if (tmp___1) {
#line 2240
        *err = (reg_errcode_t )12;
#line 2241
        return ((bin_tree_t *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2246
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2248
  tree = parse_sub_exp___0(regexp, preg, token, syntax, nest + 1UL, err);
  }
#line 2249
  if ((int )*err != 0) {
#line 2249
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2249
      tmp___2 = 1;
    } else {
#line 2249
      tmp___2 = 0;
    }
  } else {
#line 2249
    tmp___2 = 0;
  }
  {
#line 2249
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 2249
  if (tmp___3) {
#line 2250
    return ((bin_tree_t *)((void *)0));
  }
#line 2251
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2253
  tree = parse_bracket_exp___0(regexp, dfa, token, syntax, err);
  }
#line 2254
  if ((int )*err != 0) {
#line 2254
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2254
      tmp___4 = 1;
    } else {
#line 2254
      tmp___4 = 0;
    }
  } else {
#line 2254
    tmp___4 = 0;
  }
  {
#line 2254
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 2254
  if (tmp___5) {
#line 2255
    return ((bin_tree_t *)((void *)0));
  }
#line 2256
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2258
  tmp___6 = __builtin_expect((long )(dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
  }
#line 2258
  if (! tmp___6) {
#line 2260
    *err = (reg_errcode_t )6;
#line 2261
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2263
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2264
  tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_t const   *)token);
#line 2265
  tmp___7 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2265
  if (tmp___7) {
#line 2267
    *err = (reg_errcode_t )12;
#line 2268
    return ((bin_tree_t *)((void *)0));
  }
#line 2270
  (dfa->nbackref) ++;
#line 2271
  dfa->has_mb_node = 1U;
#line 2272
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2274
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2276
    *err = (reg_errcode_t )13;
#line 2277
    return ((bin_tree_t *)((void *)0));
  }
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 2283
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2285
    *err = (reg_errcode_t )13;
#line 2286
    return ((bin_tree_t *)((void *)0));
  } else
#line 2288
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
#line 2290
    fetch_token___0(token, regexp, syntax);
#line 2291
    tmp___8 = parse_expression___0(regexp, preg, token, syntax, nest, err);
    }
#line 2291
    return (tmp___8);
  }
  case_9: /* CIL Label */ 
#line 2295
  if ((unsigned int )token->type == 9U) {
#line 2295
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2298
      *err = (reg_errcode_t )16;
#line 2299
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_24: /* CIL Label */ 
  {
#line 2306
  token->type = (re_token_type_t )1;
#line 2309
  tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_t const   *)token);
#line 2310
  tmp___9 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2310
  if (tmp___9) {
#line 2312
    *err = (reg_errcode_t )12;
#line 2313
    return ((bin_tree_t *)((void *)0));
  }
#line 2315
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2317
  if ((unsigned int )token->opr.ctx_type & 783U) {
#line 2317
    if (dfa->word_ops_used == 0U) {
      {
#line 2320
      init_word_char___0(dfa);
      }
    }
  }
#line 2321
  if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2321
    goto _L;
  } else
#line 2321
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: /* CIL Label */ 
#line 2325
    if ((unsigned int )token->opr.ctx_type == 256U) {
      {
#line 2327
      token->opr.ctx_type = (re_context_type )6;
#line 2328
      tree_first = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                         (re_token_t const   *)token);
#line 2329
      token->opr.ctx_type = (re_context_type )9;
      }
    } else {
      {
#line 2333
      token->opr.ctx_type = (re_context_type )5;
#line 2334
      tree_first = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                         (re_token_t const   *)token);
#line 2335
      token->opr.ctx_type = (re_context_type )10;
      }
    }
    {
#line 2337
    tree_last = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)token);
#line 2338
    tree = create_tree___0(dfa, tree_first, tree_last, (re_token_type_t )10);
    }
#line 2339
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else
#line 2339
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else
#line 2339
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2339
      tmp___10 = 1;
    } else {
#line 2339
      tmp___10 = 0;
    }
    {
#line 2339
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 2339
    if (tmp___11) {
#line 2341
      *err = (reg_errcode_t )12;
#line 2342
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
#line 2347
    tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)token);
#line 2348
    tmp___12 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2348
    if (tmp___12) {
#line 2350
      *err = (reg_errcode_t )12;
#line 2351
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
#line 2358
  fetch_token___0(token, regexp, syntax);
  }
#line 2359
  return (tree);
  case_5: /* CIL Label */ 
  {
#line 2361
  tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_t const   *)token);
#line 2362
  tmp___13 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2362
  if (tmp___13) {
#line 2364
    *err = (reg_errcode_t )12;
#line 2365
    return ((bin_tree_t *)((void *)0));
  }
#line 2367
  if (dfa->mb_cur_max > 1) {
#line 2368
    dfa->has_mb_node = 1U;
  }
#line 2369
  goto switch_break;
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2372
  tree = build_charclass_op___0(dfa, regexp->trans, (unsigned char const   *)"alnum",
                                (unsigned char const   *)"_", (_Bool )((unsigned int )token->type == 33U),
                                err);
  }
#line 2376
  if ((int )*err != 0) {
#line 2376
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2376
      tmp___14 = 1;
    } else {
#line 2376
      tmp___14 = 0;
    }
  } else {
#line 2376
    tmp___14 = 0;
  }
  {
#line 2376
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
#line 2376
  if (tmp___15) {
#line 2377
    return ((bin_tree_t *)((void *)0));
  }
#line 2378
  goto switch_break;
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  {
#line 2381
  tree = build_charclass_op___0(dfa, regexp->trans, (unsigned char const   *)"space",
                                (unsigned char const   *)"", (_Bool )((unsigned int )token->type == 35U),
                                err);
  }
#line 2385
  if ((int )*err != 0) {
#line 2385
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2385
      tmp___16 = 1;
    } else {
#line 2385
      tmp___16 = 0;
    }
  } else {
#line 2385
    tmp___16 = 0;
  }
  {
#line 2385
  tmp___17 = __builtin_expect((long )tmp___16, 0L);
  }
#line 2385
  if (tmp___17) {
#line 2386
    return ((bin_tree_t *)((void *)0));
  }
#line 2387
  goto switch_break;
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 2390
  return ((bin_tree_t *)((void *)0));
  case_36: /* CIL Label */ 
#line 2392
  *err = (reg_errcode_t )5;
#line 2393
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
#line 2399
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 2401
  fetch_token___0(token, regexp, syntax);
  }
  {
#line 2403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2403
    if (! ((unsigned int )token->type == 11U)) {
#line 2403
      if (! ((unsigned int )token->type == 18U)) {
#line 2403
        if (! ((unsigned int )token->type == 19U)) {
#line 2403
          if (! ((unsigned int )token->type == 23U)) {
#line 2403
            goto while_break___0;
          }
        }
      }
    }
    {
#line 2406
    tree = parse_dup_op___0(tree, regexp, dfa, token, syntax, err);
    }
#line 2407
    if ((int )*err != 0) {
#line 2407
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2407
        tmp___18 = 1;
      } else {
#line 2407
        tmp___18 = 0;
      }
    } else {
#line 2407
      tmp___18 = 0;
    }
    {
#line 2407
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
    }
#line 2407
    if (tmp___19) {
#line 2408
      return ((bin_tree_t *)((void *)0));
    }
#line 2410
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2410
      if ((unsigned int )token->type == 11U) {
#line 2414
        *err = (reg_errcode_t )13;
#line 2415
        return ((bin_tree_t *)((void *)0));
      } else
#line 2410
      if ((unsigned int )token->type == 23U) {
#line 2414
        *err = (reg_errcode_t )13;
#line 2415
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2419
  return (tree);
}
}
#line 2429 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_sub_exp___0(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                     reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2433
  dfa = (re_dfa_t *)preg->buffer;
#line 2436
  tmp = preg->re_nsub;
#line 2436
  (preg->re_nsub) ++;
#line 2436
  cur_nsub = tmp;
#line 2438
  fetch_token___0(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 2441
  if ((unsigned int )token->type == 9U) {
#line 2442
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
#line 2445
    tree = parse_reg_exp___0(regexp, preg, token, syntax, nest, err);
    }
#line 2446
    if ((int )*err == 0) {
#line 2446
      if ((unsigned int )token->type != 9U) {
#line 2446
        tmp___0 = 1;
      } else {
#line 2446
        tmp___0 = 0;
      }
    } else {
#line 2446
      tmp___0 = 0;
    }
    {
#line 2446
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 2446
    if (tmp___1) {
#line 2447
      *err = (reg_errcode_t )8;
    }
    {
#line 2448
    tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2448
    if (tmp___2) {
#line 2449
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2452
  if (cur_nsub <= 8UL) {
#line 2453
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
  {
#line 2455
  tree = create_tree___0(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
#line 2456
  tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2456
  if (tmp___3) {
#line 2458
    *err = (reg_errcode_t )12;
#line 2459
    return ((bin_tree_t *)((void *)0));
  }
#line 2461
  tree->token.opr.idx = cur_nsub;
#line 2462
  return (tree);
}
}
#line 2467 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_dup_op___0(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                    re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  Idx i ;
  Idx start ;
  Idx end ;
  Idx start_idx ;
  re_token_t start_token ;
  Idx tmp ;
  Idx tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;

  {
#line 2471
  tree = (bin_tree_t *)((void *)0);
#line 2471
  old_tree = (bin_tree_t *)((void *)0);
#line 2472
  start_idx = regexp->cur_idx;
#line 2473
  start_token = *token;
#line 2475
  if ((unsigned int )token->type == 23U) {
    {
#line 2477
    end = (Idx )0;
#line 2478
    start = fetch_number___0(regexp, token, syntax);
    }
#line 2479
    if (start == 0xffffffffffffffffUL) {
#line 2481
      if ((unsigned int )token->type == 1U) {
#line 2481
        if ((int )token->opr.c == 44) {
#line 2482
          start = (Idx )0;
        } else {
#line 2485
          *err = (reg_errcode_t )10;
#line 2486
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2485
        *err = (reg_errcode_t )10;
#line 2486
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
#line 2489
    tmp___1 = __builtin_expect((long )(start != 0xfffffffffffffffeUL), 1L);
    }
#line 2489
    if (tmp___1) {
#line 2492
      if ((unsigned int )token->type == 24U) {
#line 2492
        end = start;
      } else {
#line 2492
        if ((unsigned int )token->type == 1U) {
#line 2492
          if ((int )token->opr.c == 44) {
            {
#line 2492
            tmp = fetch_number___0(regexp, token, syntax);
#line 2492
            tmp___0 = tmp;
            }
          } else {
#line 2492
            tmp___0 = (Idx )-2;
          }
        } else {
#line 2492
          tmp___0 = (Idx )-2;
        }
#line 2492
        end = tmp___0;
      }
    }
#line 2496
    if (start == 0xfffffffffffffffeUL) {
#line 2496
      tmp___3 = 1;
    } else
#line 2496
    if (end == 0xfffffffffffffffeUL) {
#line 2496
      tmp___3 = 1;
    } else {
#line 2496
      tmp___3 = 0;
    }
    {
#line 2496
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 2496
    if (tmp___4) {
      {
#line 2499
      tmp___2 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
      }
#line 2499
      if (tmp___2) {
#line 2501
        if ((unsigned int )token->type == 2U) {
#line 2502
          *err = (reg_errcode_t )9;
        } else {
#line 2504
          *err = (reg_errcode_t )10;
        }
#line 2506
        return ((bin_tree_t *)((void *)0));
      }
#line 2510
      regexp->cur_idx = start_idx;
#line 2511
      *token = start_token;
#line 2512
      token->type = (re_token_type_t )1;
#line 2515
      return (elem);
    }
#line 2518
    if (end != 0xffffffffffffffffUL) {
#line 2518
      if (start > end) {
#line 2518
        tmp___5 = 1;
      } else {
#line 2518
        tmp___5 = 0;
      }
    } else {
#line 2518
      tmp___5 = 0;
    }
    {
#line 2518
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 2518
    if (tmp___6) {
#line 2521
      *err = (reg_errcode_t )10;
#line 2522
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2527
    if ((unsigned int )token->type == 18U) {
#line 2527
      start = (Idx )1;
    } else {
#line 2527
      start = (Idx )0;
    }
#line 2528
    if ((unsigned int )token->type == 19U) {
#line 2528
      end = (Idx )1;
    } else {
#line 2528
      end = (Idx )-1;
    }
  }
  {
#line 2531
  fetch_token___0(token, regexp, syntax);
#line 2533
  tmp___7 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
  }
#line 2533
  if (tmp___7) {
#line 2534
    return ((bin_tree_t *)((void *)0));
  }
#line 2535
  if (start == 0UL) {
#line 2535
    if (end == 0UL) {
#line 2535
      tmp___8 = 1;
    } else {
#line 2535
      tmp___8 = 0;
    }
  } else {
#line 2535
    tmp___8 = 0;
  }
  {
#line 2535
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2535
  if (tmp___9) {
    {
#line 2537
    postorder___0(elem, & free_tree___0, (void *)0);
    }
#line 2538
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2542
  tmp___12 = __builtin_expect((long )(start > 0UL), 0L);
  }
#line 2542
  if (tmp___12) {
#line 2544
    tree = elem;
#line 2545
    i = (Idx )2;
    {
#line 2545
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2545
      if (! (i <= start)) {
#line 2545
        goto while_break;
      }
      {
#line 2547
      elem = duplicate_tree___0((bin_tree_t const   *)elem, dfa);
#line 2548
      tree = create_tree___0(dfa, tree, elem, (re_token_type_t )16);
      }
#line 2549
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2549
        tmp___10 = 1;
      } else
#line 2549
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2549
        tmp___10 = 1;
      } else {
#line 2549
        tmp___10 = 0;
      }
      {
#line 2549
      tmp___11 = __builtin_expect((long )tmp___10, 0L);
      }
#line 2549
      if (tmp___11) {
#line 2550
        goto parse_dup_op_espace;
      }
#line 2545
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2553
    if (start == end) {
#line 2554
      return (tree);
    }
    {
#line 2557
    elem = duplicate_tree___0((bin_tree_t const   *)elem, dfa);
#line 2558
    old_tree = tree;
    }
  } else {
#line 2561
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2563
  if ((unsigned int )elem->token.type == 17U) {
    {
#line 2564
    postorder___0(elem, & mark_opt_subexp___0, (void *)((long )elem->token.opr.idx));
    }
  }
#line 2566
  if (end == 0xffffffffffffffffUL) {
#line 2566
    tmp___13 = 11;
  } else {
#line 2566
    tmp___13 = 10;
  }
  {
#line 2566
  tree = create_tree___0(dfa, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___13);
#line 2568
  tmp___14 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2568
  if (tmp___14) {
#line 2569
    goto parse_dup_op_espace;
  }
#line 2574
  if (end != 0xffffffffffffffffUL) {
#line 2575
    i = start + 2UL;
    {
#line 2575
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2575
      if (! (i <= end)) {
#line 2575
        goto while_break___0;
      }
      {
#line 2577
      elem = duplicate_tree___0((bin_tree_t const   *)elem, dfa);
#line 2578
      tree = create_tree___0(dfa, tree, elem, (re_token_type_t )16);
      }
#line 2579
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2579
        tmp___15 = 1;
      } else
#line 2579
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2579
        tmp___15 = 1;
      } else {
#line 2579
        tmp___15 = 0;
      }
      {
#line 2579
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
      }
#line 2579
      if (tmp___16) {
#line 2580
        goto parse_dup_op_espace;
      }
      {
#line 2582
      tree = create_tree___0(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
#line 2583
      tmp___17 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2583
      if (tmp___17) {
#line 2584
        goto parse_dup_op_espace;
      }
#line 2575
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2587
  if (old_tree) {
    {
#line 2588
    tree = create_tree___0(dfa, old_tree, tree, (re_token_type_t )16);
    }
  }
#line 2590
  return (tree);
  parse_dup_op_espace: 
#line 2593
  *err = (reg_errcode_t )12;
#line 2594
  return ((bin_tree_t *)((void *)0));
}
}
#line 2609 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_range_exp___0(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                         Idx *range_alloc , bracket_elem_t *start_elem ,
                                         bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  wchar_t cmp_buf[6] ;
  int tmp___5 ;
  int tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  Idx new_nranges ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  Idx tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 2621
  if ((unsigned int )start_elem->type == 2U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )start_elem->type == 4U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )end_elem->type == 2U) {
#line 2621
    tmp = 1;
  } else
#line 2621
  if ((unsigned int )end_elem->type == 4U) {
#line 2621
    tmp = 1;
  } else {
#line 2621
    tmp = 0;
  }
  {
#line 2621
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2621
  if (tmp___0) {
#line 2624
    return ((reg_errcode_t )11);
  }
#line 2628
  if ((unsigned int )start_elem->type == 3U) {
    {
#line 2628
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
    }
#line 2628
    if (tmp___1 > 1UL) {
#line 2628
      tmp___3 = 1;
    } else {
#line 2628
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2628
  if ((unsigned int )end_elem->type == 3U) {
    {
#line 2628
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
    }
#line 2628
    if (tmp___2 > 1UL) {
#line 2628
      tmp___3 = 1;
    } else {
#line 2628
      tmp___3 = 0;
    }
  } else {
#line 2628
    tmp___3 = 0;
  }
  {
#line 2628
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 2628
  if (tmp___4) {
#line 2632
    return ((reg_errcode_t )3);
  }
#line 2639
  cmp_buf[0] = 0;
#line 2639
  cmp_buf[1] = 0;
#line 2639
  cmp_buf[2] = 0;
#line 2639
  cmp_buf[3] = 0;
#line 2639
  cmp_buf[4] = 0;
#line 2639
  cmp_buf[5] = 0;
#line 2641
  if ((unsigned int )start_elem->type == 0U) {
#line 2641
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2641
    if ((unsigned int )start_elem->type == 3U) {
#line 2641
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2641
      tmp___5 = 0;
    }
#line 2641
    start_ch = (unsigned int )tmp___5;
  }
#line 2644
  if ((unsigned int )end_elem->type == 0U) {
#line 2644
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2644
    if ((unsigned int )end_elem->type == 3U) {
#line 2644
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2644
      tmp___6 = 0;
    }
#line 2644
    end_ch = (unsigned int )tmp___6;
  }
#line 2647
  if ((unsigned int )start_elem->type == 0U) {
    {
#line 2647
    tmp___7 = btowc((int )start_ch);
#line 2647
    start_wc = tmp___7;
    }
  } else
#line 2647
  if ((unsigned int )start_elem->type == 3U) {
    {
#line 2647
    tmp___7 = btowc((int )start_ch);
#line 2647
    start_wc = tmp___7;
    }
  } else {
#line 2647
    start_wc = (wint_t )start_elem->opr.wch;
  }
#line 2649
  if ((unsigned int )end_elem->type == 0U) {
    {
#line 2649
    tmp___8 = btowc((int )end_ch);
#line 2649
    end_wc = tmp___8;
    }
  } else
#line 2649
  if ((unsigned int )end_elem->type == 3U) {
    {
#line 2649
    tmp___8 = btowc((int )end_ch);
#line 2649
    end_wc = tmp___8;
    }
  } else {
#line 2649
    end_wc = (wint_t )end_elem->opr.wch;
  }
#line 2651
  if (start_wc == 4294967295U) {
#line 2652
    return ((reg_errcode_t )3);
  } else
#line 2651
  if (end_wc == 4294967295U) {
#line 2652
    return ((reg_errcode_t )3);
  }
  {
#line 2653
  cmp_buf[0] = (wchar_t )start_wc;
#line 2654
  cmp_buf[4] = (wchar_t )end_wc;
#line 2655
  tmp___9 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 4));
  }
#line 2655
  if (tmp___9 > 0) {
#line 2656
    return ((reg_errcode_t )11);
  }
#line 2663
  if (mbcset) {
    {
#line 2666
    tmp___14 = __builtin_expect((long )(*range_alloc == mbcset->nranges), 0L);
    }
#line 2666
    if (tmp___14) {
      {
#line 2673
      new_nranges = 2UL * mbcset->nranges + 1UL;
#line 2676
      tmp___10 = realloc((void *)mbcset->range_starts, new_nranges * sizeof(wchar_t ));
#line 2676
      new_array_start = (wchar_t *)tmp___10;
#line 2678
      tmp___11 = realloc((void *)mbcset->range_ends, new_nranges * sizeof(wchar_t ));
#line 2678
      new_array_end = (wchar_t *)tmp___11;
      }
#line 2681
      if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2681
        tmp___12 = 1;
      } else
#line 2681
      if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2681
        tmp___12 = 1;
      } else {
#line 2681
        tmp___12 = 0;
      }
      {
#line 2681
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
      }
#line 2681
      if (tmp___13) {
#line 2682
        return ((reg_errcode_t )12);
      }
#line 2684
      mbcset->range_starts = new_array_start;
#line 2685
      mbcset->range_ends = new_array_end;
#line 2686
      *range_alloc = new_nranges;
    }
#line 2689
    *(mbcset->range_starts + mbcset->nranges) = (wchar_t )start_wc;
#line 2690
    tmp___15 = mbcset->nranges;
#line 2690
    (mbcset->nranges) ++;
#line 2690
    *(mbcset->range_ends + tmp___15) = (wchar_t )end_wc;
  }
#line 2694
  wc = 0;
  {
#line 2694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2694
    if (! (wc < 256)) {
#line 2694
      goto while_break;
    }
    {
#line 2696
    cmp_buf[2] = wc;
#line 2697
    tmp___16 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
    }
#line 2697
    if (tmp___16 <= 0) {
      {
#line 2697
      tmp___17 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
      }
#line 2697
      if (tmp___17 <= 0) {
        {
#line 2699
        bitset_set(sbcset, (Idx )wc);
        }
      }
    }
#line 2694
    wc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2719
  return ((reg_errcode_t )0);
}
}
#line 2730 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_collating_symbol___0(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                                Idx *coll_sym_alloc , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 2738
  tmp = strlen((char const   *)name);
#line 2738
  name_len = tmp;
#line 2739
  tmp___0 = __builtin_expect((long )(name_len != 1UL), 0L);
  }
#line 2739
  if (tmp___0) {
#line 2740
    return ((reg_errcode_t )3);
  } else {
    {
#line 2743
    bitset_set(sbcset, (Idx )*(name + 0));
    }
#line 2744
    return ((reg_errcode_t )0);
  }
}
}
#line 2752 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *parse_bracket_exp___0(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                         reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx coll_sym_alloc ;
  Idx range_alloc ;
  Idx mbchar_alloc ;
  Idx equiv_class_alloc ;
  Idx char_class_alloc ;
  _Bool non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  _Bool first_round ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  _Bool is_range_exp ;
  re_token_t token2 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  re_charset_t *tmp___9 ;
  long tmp___10 ;
  wchar_t *new_mbchars ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  Idx tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
  {
#line 3023
  coll_sym_alloc = (Idx )0;
#line 3023
  range_alloc = (Idx )0;
#line 3023
  mbchar_alloc = (Idx )0;
#line 3024
  equiv_class_alloc = (Idx )0;
#line 3024
  char_class_alloc = (Idx )0;
#line 3026
  non_match = (_Bool)0;
#line 3029
  first_round = (_Bool)1;
#line 3047
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3047
  sbcset = (re_bitset_ptr_t )tmp;
#line 3049
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3049
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3052
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3052
    tmp___1 = 1;
  } else
#line 3052
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3052
    tmp___1 = 1;
  } else {
#line 3052
    tmp___1 = 0;
  }
  {
#line 3052
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 3052
  if (tmp___2) {
#line 3057
    *err = (reg_errcode_t )12;
#line 3058
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3061
  token_len = peek_token_bracket___0(token, regexp, syntax);
#line 3062
  tmp___3 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
  }
#line 3062
  if (tmp___3) {
#line 3064
    *err = (reg_errcode_t )2;
#line 3065
    goto parse_bracket_exp_free_return;
  }
#line 3067
  if ((unsigned int )token->type == 25U) {
#line 3070
    mbcset->non_match = 1U;
#line 3072
    non_match = (_Bool)1;
#line 3073
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 3074
      bitset_set((bitset_word_t *)sbcset, (Idx )'\n');
      }
    }
    {
#line 3075
    regexp->cur_idx += (Idx )token_len;
#line 3076
    token_len = peek_token_bracket___0(token, regexp, syntax);
#line 3077
    tmp___4 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3077
    if (tmp___4) {
#line 3079
      *err = (reg_errcode_t )2;
#line 3080
      goto parse_bracket_exp_free_return;
    }
  }
#line 3085
  if ((unsigned int )token->type == 21U) {
#line 3086
    token->type = (re_token_type_t )1;
  }
  {
#line 3088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3094
    token_len2 = 0;
#line 3095
    is_range_exp = (_Bool)0;
#line 3098
    start_elem.opr.name = start_name_buf;
#line 3099
    ret = parse_bracket_element___0(& start_elem, regexp, token, token_len, dfa, syntax,
                                    first_round);
#line 3101
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 3101
    if (tmp___5) {
#line 3103
      *err = ret;
#line 3104
      goto parse_bracket_exp_free_return;
    }
    {
#line 3106
    first_round = (_Bool)0;
#line 3109
    token_len = peek_token_bracket___0(token, regexp, syntax);
    }
#line 3112
    if ((unsigned int )start_elem.type != 4U) {
#line 3112
      if ((unsigned int )start_elem.type != 2U) {
        {
#line 3114
        tmp___6 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
        }
#line 3114
        if (tmp___6) {
#line 3116
          *err = (reg_errcode_t )7;
#line 3117
          goto parse_bracket_exp_free_return;
        }
#line 3119
        if ((unsigned int )token->type == 22U) {
          {
#line 3121
          regexp->cur_idx += (Idx )token_len;
#line 3122
          token_len2 = peek_token_bracket___0(& token2, regexp, syntax);
#line 3123
          tmp___7 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
          }
#line 3123
          if (tmp___7) {
#line 3125
            *err = (reg_errcode_t )7;
#line 3126
            goto parse_bracket_exp_free_return;
          }
#line 3128
          if ((unsigned int )token2.type == 21U) {
#line 3131
            regexp->cur_idx += (Idx )(- token_len);
#line 3132
            token->type = (re_token_type_t )1;
          } else {
#line 3135
            is_range_exp = (_Bool)1;
          }
        }
      }
    }
#line 3139
    if ((int )is_range_exp == 1) {
      {
#line 3141
      end_elem.opr.name = end_name_buf;
#line 3142
      ret = parse_bracket_element___0(& end_elem, regexp, & token2, token_len2, dfa,
                                      syntax, (_Bool)1);
#line 3144
      tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 3144
      if (tmp___8) {
#line 3146
        *err = ret;
#line 3147
        goto parse_bracket_exp_free_return;
      }
      {
#line 3150
      token_len = peek_token_bracket___0(token, regexp, syntax);
      }
#line 3157
      if (dfa->mb_cur_max > 1) {
#line 3157
        tmp___9 = mbcset;
      } else {
#line 3157
        tmp___9 = (re_charset_t *)((void *)0);
      }
      {
#line 3157
      *err = build_range_exp___0((bitset_word_t *)sbcset, tmp___9, & range_alloc,
                                 & start_elem, & end_elem);
#line 3164
      tmp___10 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3164
      if (tmp___10) {
#line 3165
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
#line 3171
      if ((unsigned int )start_elem.type == 0U) {
#line 3171
        goto case_0;
      }
#line 3175
      if ((unsigned int )start_elem.type == 1U) {
#line 3175
        goto case_1;
      }
#line 3193
      if ((unsigned int )start_elem.type == 2U) {
#line 3193
        goto case_2;
      }
#line 3202
      if ((unsigned int )start_elem.type == 3U) {
#line 3202
        goto case_3;
      }
#line 3211
      if ((unsigned int )start_elem.type == 4U) {
#line 3211
        goto case_4;
      }
#line 3220
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3172
      bitset_set((bitset_word_t *)sbcset, (Idx )start_elem.opr.ch);
      }
#line 3173
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3177
      tmp___13 = __builtin_expect((long )(mbchar_alloc == mbcset->nmbchars), 0L);
      }
#line 3177
      if (tmp___13) {
        {
#line 3182
        mbchar_alloc = 2UL * mbcset->nmbchars + 1UL;
#line 3184
        tmp___11 = realloc((void *)mbcset->mbchars, mbchar_alloc * sizeof(wchar_t ));
#line 3184
        new_mbchars = (wchar_t *)tmp___11;
#line 3186
        tmp___12 = __builtin_expect((long )((unsigned long )new_mbchars == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3186
        if (tmp___12) {
#line 3187
          goto parse_bracket_exp_espace;
        }
#line 3188
        mbcset->mbchars = new_mbchars;
      }
#line 3190
      tmp___14 = mbcset->nmbchars;
#line 3190
      (mbcset->nmbchars) ++;
#line 3190
      *(mbcset->mbchars + tmp___14) = start_elem.opr.wch;
#line 3191
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3194
      *err = build_equiv_class___0((bitset_word_t *)sbcset, mbcset, & equiv_class_alloc,
                                   (unsigned char const   *)start_elem.opr.name);
#line 3199
      tmp___15 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3199
      if (tmp___15) {
#line 3200
        goto parse_bracket_exp_free_return;
      }
#line 3201
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 3203
      *err = build_collating_symbol___0((bitset_word_t *)sbcset, mbcset, & coll_sym_alloc,
                                        (unsigned char const   *)start_elem.opr.name);
#line 3208
      tmp___16 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3208
      if (tmp___16) {
#line 3209
        goto parse_bracket_exp_free_return;
      }
#line 3210
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 3212
      *err = build_charclass___0(regexp->trans, (bitset_word_t *)sbcset, mbcset, & char_class_alloc,
                                 (unsigned char const   *)start_elem.opr.name, syntax);
#line 3217
      tmp___17 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3217
      if (tmp___17) {
#line 3218
        goto parse_bracket_exp_free_return;
      }
#line 3219
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3221
      __assert_fail("0", "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c",
                    3221U, "parse_bracket_exp");
      }
#line 3222
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3225
    tmp___18 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3225
    if (tmp___18) {
#line 3227
      *err = (reg_errcode_t )7;
#line 3228
      goto parse_bracket_exp_free_return;
    }
#line 3230
    if ((unsigned int )token->type == 21U) {
#line 3231
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3234
  regexp->cur_idx += (Idx )token_len;
#line 3237
  if (non_match) {
    {
#line 3238
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3242
  if (dfa->mb_cur_max > 1) {
    {
#line 3243
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
#line 3245
  if (mbcset->nmbchars) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->ncoll_syms) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->nequiv_classes) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (mbcset->nranges) {
#line 3245
    goto _L___1;
  } else
#line 3245
  if (dfa->mb_cur_max > 1) {
#line 3245
    if (mbcset->nchar_classes) {
#line 3245
      goto _L___1;
    } else
#line 3245
    if (mbcset->non_match) {
      _L___1: /* CIL Label */ 
      {
#line 3252
      dfa->has_mb_node = 1U;
#line 3253
      br_token.type = (re_token_type_t )6;
#line 3254
      br_token.opr.mbcset = mbcset;
#line 3255
      mbc_tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                       (re_token_t const   *)(& br_token));
#line 3256
      tmp___19 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 3256
      if (tmp___19) {
#line 3257
        goto parse_bracket_exp_espace;
      }
#line 3258
      sbc_idx = 0;
      {
#line 3258
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3258
        if (! (sbc_idx < 4)) {
#line 3258
          goto while_break___0;
        }
#line 3259
        if (*(sbcset + sbc_idx)) {
#line 3260
          goto while_break___0;
        }
#line 3258
        sbc_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3263
      if (sbc_idx < 4) {
        {
#line 3266
        br_token.type = (re_token_type_t )3;
#line 3267
        br_token.opr.sbcset = sbcset;
#line 3268
        work_tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                          (re_token_t const   *)(& br_token));
#line 3269
        tmp___20 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3269
        if (tmp___20) {
#line 3270
          goto parse_bracket_exp_espace;
        }
        {
#line 3273
        work_tree = create_tree___0(dfa, work_tree, mbc_tree, (re_token_type_t )10);
#line 3274
        tmp___21 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3274
        if (tmp___21) {
#line 3275
          goto parse_bracket_exp_espace;
        }
      } else {
        {
#line 3279
        free((void *)sbcset);
#line 3280
        work_tree = mbc_tree;
        }
      }
    } else {
#line 3245
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3287
    free_charset___0(mbcset);
#line 3290
    br_token.type = (re_token_type_t )3;
#line 3291
    br_token.opr.sbcset = sbcset;
#line 3292
    work_tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)(& br_token));
#line 3293
    tmp___22 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 3293
    if (tmp___22) {
#line 3294
      goto parse_bracket_exp_espace;
    }
  }
#line 3296
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3299
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
#line 3301
  free((void *)sbcset);
#line 3303
  free_charset___0(mbcset);
  }
#line 3305
  return ((bin_tree_t *)((void *)0));
}
}
#line 3310 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_element___0(bracket_elem_t *elem , re_string_t *regexp ,
                                               re_token_t *token , int token_len ,
                                               re_dfa_t *dfa , reg_syntax_t syntax ,
                                               _Bool accept_hyphen ) 
{ 
  int cur_char_size ;
  int __attribute__((__pure__))  tmp ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  re_token_t token2 ;
  long tmp___2 ;

  {
  {
#line 3317
  tmp = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3317
  cur_char_size = (int )tmp;
  }
#line 3318
  if (cur_char_size > 1) {
    {
#line 3320
    elem->type = (bracket_elem_type )1;
#line 3321
    tmp___0 = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3321
    elem->opr.wch = (wchar_t )tmp___0;
#line 3322
    regexp->cur_idx += (Idx )cur_char_size;
    }
#line 3323
    return ((reg_errcode_t )0);
  }
#line 3326
  regexp->cur_idx += (Idx )token_len;
#line 3327
  if ((unsigned int )token->type == 26U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol___0(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  } else
#line 3327
  if ((unsigned int )token->type == 30U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol___0(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  } else
#line 3327
  if ((unsigned int )token->type == 28U) {
    {
#line 3329
    tmp___1 = parse_bracket_symbol___0(elem, regexp, token);
    }
#line 3329
    return (tmp___1);
  }
  {
#line 3330
  tmp___2 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
  }
#line 3330
  if (tmp___2) {
#line 3330
    if (! accept_hyphen) {
      {
#line 3335
      peek_token_bracket___0(& token2, regexp, syntax);
      }
#line 3336
      if ((unsigned int )token2.type != 21U) {
#line 3339
        return ((reg_errcode_t )11);
      }
    }
  }
#line 3341
  elem->type = (bracket_elem_type )0;
#line 3342
  elem->opr.ch = token->opr.c;
#line 3343
  return ((reg_errcode_t )0);
}
}
#line 3350 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_symbol___0(bracket_elem_t *elem , re_string_t *regexp ,
                                              re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  unsigned char __attribute__((__pure__))  tmp ;
  Idx tmp___0 ;

  {
#line 3354
  delim = token->opr.c;
#line 3355
  i = 0;
#line 3356
  if (regexp->stop <= regexp->cur_idx) {
#line 3357
    return ((reg_errcode_t )7);
  }
  {
#line 3358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3360
    if (i >= 32) {
#line 3361
      return ((reg_errcode_t )7);
    }
#line 3362
    if ((unsigned int )token->type == 30U) {
      {
#line 3363
      tmp = re_string_fetch_byte_case___0(regexp);
#line 3363
      ch = (unsigned char )tmp;
      }
    } else {
#line 3365
      tmp___0 = regexp->cur_idx;
#line 3365
      (regexp->cur_idx) ++;
#line 3365
      ch = *(regexp->mbs + tmp___0);
    }
#line 3366
    if (regexp->stop <= regexp->cur_idx) {
#line 3367
      return ((reg_errcode_t )7);
    }
#line 3368
    if ((int )ch == (int )delim) {
#line 3368
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3369
        goto while_break;
      }
    }
#line 3370
    *(elem->opr.name + i) = ch;
#line 3358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3372
  (regexp->cur_idx) ++;
#line 3373
  *(elem->opr.name + i) = (unsigned char )'\000';
  {
#line 3376
  if ((unsigned int )token->type == 26U) {
#line 3376
    goto case_26;
  }
#line 3379
  if ((unsigned int )token->type == 28U) {
#line 3379
    goto case_28;
  }
#line 3382
  if ((unsigned int )token->type == 30U) {
#line 3382
    goto case_30;
  }
#line 3385
  goto switch_default;
  case_26: /* CIL Label */ 
#line 3377
  elem->type = (bracket_elem_type )3;
#line 3378
  goto switch_break;
  case_28: /* CIL Label */ 
#line 3380
  elem->type = (bracket_elem_type )2;
#line 3381
  goto switch_break;
  case_30: /* CIL Label */ 
#line 3383
  elem->type = (bracket_elem_type )4;
#line 3384
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3386
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3388
  return ((reg_errcode_t )0);
}
}
#line 3397 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_equiv_class___0(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                           Idx *equiv_class_alloc , unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 3476
  tmp = strlen((char const   *)name);
#line 3476
  tmp___0 = __builtin_expect((long )(tmp != 1UL), 0L);
  }
#line 3476
  if (tmp___0) {
#line 3477
    return ((reg_errcode_t )3);
  }
  {
#line 3478
  bitset_set(sbcset, (Idx )*name);
  }
#line 3480
  return ((reg_errcode_t )0);
}
}
#line 3489 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t build_charclass___0(unsigned char *trans , bitset_word_t *sbcset ,
                                         re_charset_t *mbcset , Idx *char_class_alloc ,
                                         unsigned char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  Idx new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  long tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  long tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  long tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  long tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  long tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  long tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  long tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  long tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  long tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  long tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;

  {
#line 3500
  name = (char const   *)class_name;
#line 3504
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 3504
    tmp = strcmp(name, "upper");
    }
#line 3504
    if (tmp == 0) {
#line 3506
      name = "alpha";
    } else {
      {
#line 3504
      tmp___0 = strcmp(name, "lower");
      }
#line 3504
      if (tmp___0 == 0) {
#line 3506
        name = "alpha";
      }
    }
  }
  {
#line 3510
  tmp___3 = __builtin_expect((long )(*char_class_alloc == mbcset->nchar_classes),
                             0L);
  }
#line 3510
  if (tmp___3) {
    {
#line 3514
    new_char_class_alloc = 2UL * mbcset->nchar_classes + 1UL;
#line 3516
    tmp___1 = realloc((void *)mbcset->char_classes, new_char_class_alloc * sizeof(wctype_t ));
#line 3516
    new_char_classes = (wctype_t *)tmp___1;
#line 3518
    tmp___2 = __builtin_expect((long )((unsigned long )new_char_classes == (unsigned long )((void *)0)),
                               0L);
    }
#line 3518
    if (tmp___2) {
#line 3519
      return ((reg_errcode_t )12);
    }
#line 3520
    mbcset->char_classes = new_char_classes;
#line 3521
    *char_class_alloc = new_char_class_alloc;
  }
  {
#line 3523
  tmp___4 = mbcset->nchar_classes;
#line 3523
  (mbcset->nchar_classes) ++;
#line 3523
  *(mbcset->char_classes + tmp___4) = wctype(name);
#line 3542
  tmp___52 = strcmp(name, "alnum");
  }
#line 3542
  if (tmp___52 == 0) {
    {
#line 3543
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3543
      tmp___7 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 3543
      if (tmp___7) {
#line 3543
        i = 0;
        {
#line 3543
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3543
          if (! (i < 256)) {
#line 3543
            goto while_break___0;
          }
          {
#line 3543
          tmp___5 = __ctype_b_loc();
          }
#line 3543
          if ((int const   )*(*tmp___5 + i) & 8) {
            {
#line 3543
            bitset_set(sbcset, (Idx )*(trans + i));
            }
          }
#line 3543
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 3543
        i = 0;
        {
#line 3543
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3543
          if (! (i < 256)) {
#line 3543
            goto while_break___1;
          }
          {
#line 3543
          tmp___6 = __ctype_b_loc();
          }
#line 3543
          if ((int const   )*(*tmp___6 + i) & 8) {
            {
#line 3543
            bitset_set(sbcset, (Idx )i);
            }
          }
#line 3543
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 3543
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 3544
    tmp___51 = strcmp(name, "cntrl");
    }
#line 3544
    if (tmp___51 == 0) {
      {
#line 3545
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 3545
        tmp___10 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 3545
        if (tmp___10) {
#line 3545
          i = 0;
          {
#line 3545
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3545
            if (! (i < 256)) {
#line 3545
              goto while_break___3;
            }
            {
#line 3545
            tmp___8 = __ctype_b_loc();
            }
#line 3545
            if ((int const   )*(*tmp___8 + i) & 2) {
              {
#line 3545
              bitset_set(sbcset, (Idx )*(trans + i));
              }
            }
#line 3545
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 3545
          i = 0;
          {
#line 3545
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3545
            if (! (i < 256)) {
#line 3545
              goto while_break___4;
            }
            {
#line 3545
            tmp___9 = __ctype_b_loc();
            }
#line 3545
            if ((int const   )*(*tmp___9 + i) & 2) {
              {
#line 3545
              bitset_set(sbcset, (Idx )i);
              }
            }
#line 3545
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 3545
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3546
      tmp___50 = strcmp(name, "lower");
      }
#line 3546
      if (tmp___50 == 0) {
        {
#line 3547
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3547
          tmp___13 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 3547
          if (tmp___13) {
#line 3547
            i = 0;
            {
#line 3547
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3547
              if (! (i < 256)) {
#line 3547
                goto while_break___6;
              }
              {
#line 3547
              tmp___11 = __ctype_b_loc();
              }
#line 3547
              if ((int const   )*(*tmp___11 + i) & 512) {
                {
#line 3547
                bitset_set(sbcset, (Idx )*(trans + i));
                }
              }
#line 3547
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 3547
            i = 0;
            {
#line 3547
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 3547
              if (! (i < 256)) {
#line 3547
                goto while_break___7;
              }
              {
#line 3547
              tmp___12 = __ctype_b_loc();
              }
#line 3547
              if ((int const   )*(*tmp___12 + i) & 512) {
                {
#line 3547
                bitset_set(sbcset, (Idx )i);
                }
              }
#line 3547
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 3547
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 3548
        tmp___49 = strcmp(name, "space");
        }
#line 3548
        if (tmp___49 == 0) {
          {
#line 3549
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 3549
            tmp___16 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
            }
#line 3549
            if (tmp___16) {
#line 3549
              i = 0;
              {
#line 3549
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 3549
                if (! (i < 256)) {
#line 3549
                  goto while_break___9;
                }
                {
#line 3549
                tmp___14 = __ctype_b_loc();
                }
#line 3549
                if ((int const   )*(*tmp___14 + i) & 8192) {
                  {
#line 3549
                  bitset_set(sbcset, (Idx )*(trans + i));
                  }
                }
#line 3549
                i ++;
              }
              while_break___9: /* CIL Label */ ;
              }
            } else {
#line 3549
              i = 0;
              {
#line 3549
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 3549
                if (! (i < 256)) {
#line 3549
                  goto while_break___10;
                }
                {
#line 3549
                tmp___15 = __ctype_b_loc();
                }
#line 3549
                if ((int const   )*(*tmp___15 + i) & 8192) {
                  {
#line 3549
                  bitset_set(sbcset, (Idx )i);
                  }
                }
#line 3549
                i ++;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
#line 3549
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
#line 3550
          tmp___48 = strcmp(name, "alpha");
          }
#line 3550
          if (tmp___48 == 0) {
            {
#line 3551
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
#line 3551
              tmp___19 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
              }
#line 3551
              if (tmp___19) {
#line 3551
                i = 0;
                {
#line 3551
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 3551
                  if (! (i < 256)) {
#line 3551
                    goto while_break___12;
                  }
                  {
#line 3551
                  tmp___17 = __ctype_b_loc();
                  }
#line 3551
                  if ((int const   )*(*tmp___17 + i) & 1024) {
                    {
#line 3551
                    bitset_set(sbcset, (Idx )*(trans + i));
                    }
                  }
#line 3551
                  i ++;
                }
                while_break___12: /* CIL Label */ ;
                }
              } else {
#line 3551
                i = 0;
                {
#line 3551
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 3551
                  if (! (i < 256)) {
#line 3551
                    goto while_break___13;
                  }
                  {
#line 3551
                  tmp___18 = __ctype_b_loc();
                  }
#line 3551
                  if ((int const   )*(*tmp___18 + i) & 1024) {
                    {
#line 3551
                    bitset_set(sbcset, (Idx )i);
                    }
                  }
#line 3551
                  i ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
#line 3551
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
#line 3552
            tmp___47 = strcmp(name, "digit");
            }
#line 3552
            if (tmp___47 == 0) {
              {
#line 3553
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 3553
                tmp___22 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
                }
#line 3553
                if (tmp___22) {
#line 3553
                  i = 0;
                  {
#line 3553
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 3553
                    if (! (i < 256)) {
#line 3553
                      goto while_break___15;
                    }
                    {
#line 3553
                    tmp___20 = __ctype_b_loc();
                    }
#line 3553
                    if ((int const   )*(*tmp___20 + i) & 2048) {
                      {
#line 3553
                      bitset_set(sbcset, (Idx )*(trans + i));
                      }
                    }
#line 3553
                    i ++;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                } else {
#line 3553
                  i = 0;
                  {
#line 3553
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 3553
                    if (! (i < 256)) {
#line 3553
                      goto while_break___16;
                    }
                    {
#line 3553
                    tmp___21 = __ctype_b_loc();
                    }
#line 3553
                    if ((int const   )*(*tmp___21 + i) & 2048) {
                      {
#line 3553
                      bitset_set(sbcset, (Idx )i);
                      }
                    }
#line 3553
                    i ++;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
#line 3553
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
            } else {
              {
#line 3554
              tmp___46 = strcmp(name, "print");
              }
#line 3554
              if (tmp___46 == 0) {
                {
#line 3555
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 3555
                  tmp___25 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
                  }
#line 3555
                  if (tmp___25) {
#line 3555
                    i = 0;
                    {
#line 3555
                    while (1) {
                      while_continue___18: /* CIL Label */ ;
#line 3555
                      if (! (i < 256)) {
#line 3555
                        goto while_break___18;
                      }
                      {
#line 3555
                      tmp___23 = __ctype_b_loc();
                      }
#line 3555
                      if ((int const   )*(*tmp___23 + i) & 16384) {
                        {
#line 3555
                        bitset_set(sbcset, (Idx )*(trans + i));
                        }
                      }
#line 3555
                      i ++;
                    }
                    while_break___18: /* CIL Label */ ;
                    }
                  } else {
#line 3555
                    i = 0;
                    {
#line 3555
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
#line 3555
                      if (! (i < 256)) {
#line 3555
                        goto while_break___19;
                      }
                      {
#line 3555
                      tmp___24 = __ctype_b_loc();
                      }
#line 3555
                      if ((int const   )*(*tmp___24 + i) & 16384) {
                        {
#line 3555
                        bitset_set(sbcset, (Idx )i);
                        }
                      }
#line 3555
                      i ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                  }
#line 3555
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              } else {
                {
#line 3556
                tmp___45 = strcmp(name, "upper");
                }
#line 3556
                if (tmp___45 == 0) {
                  {
#line 3557
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
                    {
#line 3557
                    tmp___28 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
                    }
#line 3557
                    if (tmp___28) {
#line 3557
                      i = 0;
                      {
#line 3557
                      while (1) {
                        while_continue___21: /* CIL Label */ ;
#line 3557
                        if (! (i < 256)) {
#line 3557
                          goto while_break___21;
                        }
                        {
#line 3557
                        tmp___26 = __ctype_b_loc();
                        }
#line 3557
                        if ((int const   )*(*tmp___26 + i) & 256) {
                          {
#line 3557
                          bitset_set(sbcset, (Idx )*(trans + i));
                          }
                        }
#line 3557
                        i ++;
                      }
                      while_break___21: /* CIL Label */ ;
                      }
                    } else {
#line 3557
                      i = 0;
                      {
#line 3557
                      while (1) {
                        while_continue___22: /* CIL Label */ ;
#line 3557
                        if (! (i < 256)) {
#line 3557
                          goto while_break___22;
                        }
                        {
#line 3557
                        tmp___27 = __ctype_b_loc();
                        }
#line 3557
                        if ((int const   )*(*tmp___27 + i) & 256) {
                          {
#line 3557
                          bitset_set(sbcset, (Idx )i);
                          }
                        }
#line 3557
                        i ++;
                      }
                      while_break___22: /* CIL Label */ ;
                      }
                    }
#line 3557
                    goto while_break___20;
                  }
                  while_break___20: /* CIL Label */ ;
                  }
                } else {
                  {
#line 3558
                  tmp___44 = strcmp(name, "blank");
                  }
#line 3558
                  if (tmp___44 == 0) {
                    {
#line 3559
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
                      {
#line 3559
                      tmp___31 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
                      }
#line 3559
                      if (tmp___31) {
#line 3559
                        i = 0;
                        {
#line 3559
                        while (1) {
                          while_continue___24: /* CIL Label */ ;
#line 3559
                          if (! (i < 256)) {
#line 3559
                            goto while_break___24;
                          }
                          {
#line 3559
                          tmp___29 = __ctype_b_loc();
                          }
#line 3559
                          if ((int const   )*(*tmp___29 + i) & 1) {
                            {
#line 3559
                            bitset_set(sbcset, (Idx )*(trans + i));
                            }
                          }
#line 3559
                          i ++;
                        }
                        while_break___24: /* CIL Label */ ;
                        }
                      } else {
#line 3559
                        i = 0;
                        {
#line 3559
                        while (1) {
                          while_continue___25: /* CIL Label */ ;
#line 3559
                          if (! (i < 256)) {
#line 3559
                            goto while_break___25;
                          }
                          {
#line 3559
                          tmp___30 = __ctype_b_loc();
                          }
#line 3559
                          if ((int const   )*(*tmp___30 + i) & 1) {
                            {
#line 3559
                            bitset_set(sbcset, (Idx )i);
                            }
                          }
#line 3559
                          i ++;
                        }
                        while_break___25: /* CIL Label */ ;
                        }
                      }
#line 3559
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 3560
                    tmp___43 = strcmp(name, "graph");
                    }
#line 3560
                    if (tmp___43 == 0) {
                      {
#line 3561
                      while (1) {
                        while_continue___26: /* CIL Label */ ;
                        {
#line 3561
                        tmp___34 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
                        }
#line 3561
                        if (tmp___34) {
#line 3561
                          i = 0;
                          {
#line 3561
                          while (1) {
                            while_continue___27: /* CIL Label */ ;
#line 3561
                            if (! (i < 256)) {
#line 3561
                              goto while_break___27;
                            }
                            {
#line 3561
                            tmp___32 = __ctype_b_loc();
                            }
#line 3561
                            if ((int const   )*(*tmp___32 + i) & 32768) {
                              {
#line 3561
                              bitset_set(sbcset, (Idx )*(trans + i));
                              }
                            }
#line 3561
                            i ++;
                          }
                          while_break___27: /* CIL Label */ ;
                          }
                        } else {
#line 3561
                          i = 0;
                          {
#line 3561
                          while (1) {
                            while_continue___28: /* CIL Label */ ;
#line 3561
                            if (! (i < 256)) {
#line 3561
                              goto while_break___28;
                            }
                            {
#line 3561
                            tmp___33 = __ctype_b_loc();
                            }
#line 3561
                            if ((int const   )*(*tmp___33 + i) & 32768) {
                              {
#line 3561
                              bitset_set(sbcset, (Idx )i);
                              }
                            }
#line 3561
                            i ++;
                          }
                          while_break___28: /* CIL Label */ ;
                          }
                        }
#line 3561
                        goto while_break___26;
                      }
                      while_break___26: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 3562
                      tmp___42 = strcmp(name, "punct");
                      }
#line 3562
                      if (tmp___42 == 0) {
                        {
#line 3563
                        while (1) {
                          while_continue___29: /* CIL Label */ ;
                          {
#line 3563
                          tmp___37 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
                          }
#line 3563
                          if (tmp___37) {
#line 3563
                            i = 0;
                            {
#line 3563
                            while (1) {
                              while_continue___30: /* CIL Label */ ;
#line 3563
                              if (! (i < 256)) {
#line 3563
                                goto while_break___30;
                              }
                              {
#line 3563
                              tmp___35 = __ctype_b_loc();
                              }
#line 3563
                              if ((int const   )*(*tmp___35 + i) & 4) {
                                {
#line 3563
                                bitset_set(sbcset, (Idx )*(trans + i));
                                }
                              }
#line 3563
                              i ++;
                            }
                            while_break___30: /* CIL Label */ ;
                            }
                          } else {
#line 3563
                            i = 0;
                            {
#line 3563
                            while (1) {
                              while_continue___31: /* CIL Label */ ;
#line 3563
                              if (! (i < 256)) {
#line 3563
                                goto while_break___31;
                              }
                              {
#line 3563
                              tmp___36 = __ctype_b_loc();
                              }
#line 3563
                              if ((int const   )*(*tmp___36 + i) & 4) {
                                {
#line 3563
                                bitset_set(sbcset, (Idx )i);
                                }
                              }
#line 3563
                              i ++;
                            }
                            while_break___31: /* CIL Label */ ;
                            }
                          }
#line 3563
                          goto while_break___29;
                        }
                        while_break___29: /* CIL Label */ ;
                        }
                      } else {
                        {
#line 3564
                        tmp___41 = strcmp(name, "xdigit");
                        }
#line 3564
                        if (tmp___41 == 0) {
                          {
#line 3565
                          while (1) {
                            while_continue___32: /* CIL Label */ ;
                            {
#line 3565
                            tmp___40 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
                            }
#line 3565
                            if (tmp___40) {
#line 3565
                              i = 0;
                              {
#line 3565
                              while (1) {
                                while_continue___33: /* CIL Label */ ;
#line 3565
                                if (! (i < 256)) {
#line 3565
                                  goto while_break___33;
                                }
                                {
#line 3565
                                tmp___38 = __ctype_b_loc();
                                }
#line 3565
                                if ((int const   )*(*tmp___38 + i) & 4096) {
                                  {
#line 3565
                                  bitset_set(sbcset, (Idx )*(trans + i));
                                  }
                                }
#line 3565
                                i ++;
                              }
                              while_break___33: /* CIL Label */ ;
                              }
                            } else {
#line 3565
                              i = 0;
                              {
#line 3565
                              while (1) {
                                while_continue___34: /* CIL Label */ ;
#line 3565
                                if (! (i < 256)) {
#line 3565
                                  goto while_break___34;
                                }
                                {
#line 3565
                                tmp___39 = __ctype_b_loc();
                                }
#line 3565
                                if ((int const   )*(*tmp___39 + i) & 4096) {
                                  {
#line 3565
                                  bitset_set(sbcset, (Idx )i);
                                  }
                                }
#line 3565
                                i ++;
                              }
                              while_break___34: /* CIL Label */ ;
                              }
                            }
#line 3565
                            goto while_break___32;
                          }
                          while_break___32: /* CIL Label */ ;
                          }
                        } else {
#line 3567
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3569
  return ((reg_errcode_t )0);
}
}
#line 3572 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *build_charclass_op___0(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                          unsigned char const   *extra , _Bool non_match ,
                                          reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bin_tree_t *mbc_tree ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 3581
  alloc = (Idx )0;
#line 3587
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3587
  sbcset = (re_bitset_ptr_t )tmp;
#line 3589
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3589
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3593
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3593
    tmp___1 = 1;
  } else
#line 3593
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3593
    tmp___1 = 1;
  } else {
#line 3593
    tmp___1 = 0;
  }
  {
#line 3593
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 3593
  if (tmp___2) {
#line 3598
    *err = (reg_errcode_t )12;
#line 3599
    return ((bin_tree_t *)((void *)0));
  }
#line 3602
  if (non_match) {
#line 3605
    mbcset->non_match = 1U;
  }
  {
#line 3610
  ret = build_charclass___0(trans, (bitset_word_t *)sbcset, mbcset, & alloc, class_name,
                            (reg_syntax_t )0);
#line 3616
  tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 3616
  if (tmp___3) {
    {
#line 3618
    free((void *)sbcset);
#line 3620
    free_charset___0(mbcset);
#line 3622
    *err = ret;
    }
#line 3623
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3626
    if (! *extra) {
#line 3626
      goto while_break;
    }
    {
#line 3627
    bitset_set((bitset_word_t *)sbcset, (Idx )*extra);
#line 3626
    extra ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3630
  if (non_match) {
    {
#line 3631
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3635
  if (dfa->mb_cur_max > 1) {
    {
#line 3636
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
  {
#line 3640
  br_token.type = (re_token_type_t )3;
#line 3641
  br_token.opr.sbcset = sbcset;
#line 3642
  tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               (re_token_t const   *)(& br_token));
#line 3643
  tmp___4 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 3643
  if (tmp___4) {
#line 3644
    goto build_word_op_espace;
  }
#line 3647
  if (dfa->mb_cur_max > 1) {
    {
#line 3651
    br_token.type = (re_token_type_t )6;
#line 3652
    br_token.opr.mbcset = mbcset;
#line 3653
    dfa->has_mb_node = 1U;
#line 3654
    mbc_tree = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)(& br_token));
#line 3655
    tmp___5 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 3655
    if (tmp___5) {
#line 3656
      goto build_word_op_espace;
    }
    {
#line 3658
    tree = create_tree___0(dfa, tree, mbc_tree, (re_token_type_t )10);
#line 3659
    tmp___6 = __builtin_expect((long )((unsigned long )mbc_tree != (unsigned long )((void *)0)),
                               1L);
    }
#line 3659
    if (tmp___6) {
#line 3660
      return (tree);
    }
  } else {
    {
#line 3664
    free_charset___0(mbcset);
    }
#line 3665
    return (tree);
  }
  build_word_op_espace: 
  {
#line 3672
  free((void *)sbcset);
#line 3674
  free_charset___0(mbcset);
#line 3676
  *err = (reg_errcode_t )12;
  }
#line 3677
  return ((bin_tree_t *)((void *)0));
}
}
#line 3685 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static Idx fetch_number___0(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  Idx num ;
  unsigned char c ;
  long tmp ;
  Idx tmp___0 ;

  {
#line 3688
  num = (Idx )-1;
  {
#line 3690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3692
    fetch_token___0(token, input, syntax);
#line 3693
    c = token->opr.c;
#line 3694
    tmp = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3694
    if (tmp) {
#line 3695
      return ((Idx )-2);
    }
#line 3696
    if ((unsigned int )token->type == 24U) {
#line 3697
      goto while_break;
    } else
#line 3696
    if ((int )c == 44) {
#line 3697
      goto while_break;
    }
#line 3698
    if ((unsigned int )token->type != 1U) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if ((int )c < 48) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if (57 < (int )c) {
#line 3698
      num = (Idx )-2;
    } else
#line 3698
    if (num == 0xfffffffffffffffeUL) {
#line 3698
      num = (Idx )-2;
    } else {
#line 3698
      if (num == 0xffffffffffffffffUL) {
#line 3698
        tmp___0 = (Idx )((int )c - 48);
      } else {
#line 3698
        tmp___0 = (num * 10UL + (Idx )c) - 48UL;
      }
#line 3698
      num = tmp___0;
    }
#line 3702
    if (num > 32767UL) {
#line 3702
      num = (Idx )-2;
    } else {
#line 3702
      num = num;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3704
  return (num);
}
}
#line 3708 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_charset___0(re_charset_t *cset ) 
{ 


  {
  {
#line 3711
  free((void *)cset->mbchars);
#line 3718
  free((void *)cset->char_classes);
#line 3719
  free((void *)cset);
  }
#line 3720
  return;
}
}
#line 3727 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *create_tree___0(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                   re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp ;

  {
  {
#line 3732
  t.type = type;
#line 3733
  tmp = create_token_tree___0(dfa, left, right, (re_token_t const   *)(& t));
  }
#line 3733
  return (tmp);
}
}
#line 3736 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *create_token_tree___0(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                         re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3741
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
  }
#line 3741
  if (tmp___0) {
    {
#line 3743
    tmp = malloc(sizeof(bin_tree_storage_t ));
#line 3743
    storage = (bin_tree_storage_t *)tmp;
    }
#line 3745
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
#line 3746
      return ((bin_tree_t *)((void *)0));
    }
#line 3747
    storage->next = dfa->str_tree_storage;
#line 3748
    dfa->str_tree_storage = storage;
#line 3749
    dfa->str_tree_storage_idx = 0;
  }
#line 3751
  tmp___1 = dfa->str_tree_storage_idx;
#line 3751
  (dfa->str_tree_storage_idx) ++;
#line 3751
  tree = & (dfa->str_tree_storage)->data[tmp___1];
#line 3753
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3754
  tree->left = left;
#line 3755
  tree->right = right;
#line 3756
  tree->token = (re_token_t )*token;
#line 3757
  tree->token.duplicated = 0U;
#line 3758
  tree->token.opt_subexp = 0U;
#line 3759
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3760
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3761
  tree->node_idx = (Idx )-1;
#line 3763
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3764
    left->parent = tree;
  }
#line 3765
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3766
    right->parent = tree;
  }
#line 3767
  return (tree);
}
}
#line 3773 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t mark_opt_subexp___0(void *extra , bin_tree_t *node ) 
{ 
  Idx idx ;

  {
#line 3776
  idx = (Idx )((long )extra);
#line 3777
  if ((unsigned int )node->token.type == 17U) {
#line 3777
    if (node->token.opr.idx == idx) {
#line 3778
      node->token.opt_subexp = 1U;
    }
  }
#line 3780
  return ((reg_errcode_t )0);
}
}
#line 3785 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static void free_token___0(re_token_t *node ) 
{ 


  {
#line 3789
  if ((unsigned int )node->type == 6U) {
#line 3789
    if (node->duplicated == 0U) {
      {
#line 3790
      free_charset___0(node->opr.mbcset);
      }
    } else {
#line 3789
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3793
  if ((unsigned int )node->type == 3U) {
#line 3793
    if (node->duplicated == 0U) {
      {
#line 3794
      free((void *)node->opr.sbcset);
      }
    }
  }
#line 3795
  return;
}
}
#line 3800 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static reg_errcode_t free_tree___0(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 3803
  free_token___0(& node->token);
  }
#line 3804
  return ((reg_errcode_t )0);
}
}
#line 3813 "/home/khheo/project/benchmark/coreutils-7.1/lib/regcomp.c"
static bin_tree_t *duplicate_tree___0(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3818
  p_new = & dup_root;
#line 3818
  dup_node = (bin_tree_t *)root->parent;
#line 3820
  node = root;
  {
#line 3820
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3823
    *p_new = create_token_tree___0(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                   & node->token);
    }
#line 3824
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
#line 3825
      return ((bin_tree_t *)((void *)0));
    }
#line 3826
    (*p_new)->parent = dup_node;
#line 3827
    (*p_new)->token.duplicated = 1U;
#line 3828
    dup_node = *p_new;
#line 3831
    if (node->left) {
#line 3833
      node = (bin_tree_t const   *)node->left;
#line 3834
      p_new = & dup_node->left;
    } else {
#line 3838
      prev = (bin_tree_t const   *)((void *)0);
      {
#line 3839
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3839
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 3839
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 3839
            goto while_break___0;
          }
        }
#line 3841
        prev = node;
#line 3842
        node = (bin_tree_t const   *)node->parent;
#line 3843
        dup_node = dup_node->parent;
#line 3844
        if (! node) {
#line 3845
          return (dup_root);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3847
      node = (bin_tree_t const   *)node->right;
#line 3848
      p_new = & dup_node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 21 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_init___0(re_match_context_t *mctx , int eflags , Idx n ) ;
#line 23
static void match_ctx_clean___0(re_match_context_t *mctx ) ;
#line 24
static void match_ctx_free___0(re_match_context_t *mctx ) ;
#line 25
static reg_errcode_t match_ctx_add_entry___0(re_match_context_t *mctx , Idx node ,
                                             Idx str_idx , Idx from , Idx to ) ;
#line 28
static Idx search_cur_bkref_entry___0(re_match_context_t const   *mctx , Idx str_idx ) ;
#line 30
static reg_errcode_t match_ctx_add_subtop___0(re_match_context_t *mctx , Idx node ,
                                              Idx str_idx ) ;
#line 32
static re_sub_match_last_t *match_ctx_add_sublast___0(re_sub_match_top_t *subtop ,
                                                      Idx node , Idx str_idx ) ;
#line 35
static void sift_ctx_init___0(re_sift_context_t *sctx , re_dfastate_t **sifted_sts ,
                              re_dfastate_t **limited_sts , Idx last_node , Idx last_str_idx ) ;
#line 39
static reg_errcode_t re_search_internal___0(regex_t const   *preg , char const   *string ,
                                            Idx length , Idx start , Idx last_start ,
                                            Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                            int eflags ) ;
#line 44
static regoff_t re_search_2_stub___0(struct re_pattern_buffer *bufp , char const   *string1 ,
                                     Idx length1 , char const   *string2 , Idx length2 ,
                                     Idx start , regoff_t range , struct re_registers *regs ,
                                     Idx stop , _Bool ret_len ) ;
#line 50
static regoff_t re_search_stub___0(struct re_pattern_buffer *bufp , char const   *string ,
                                   Idx length , Idx start , regoff_t range , Idx stop ,
                                   struct re_registers *regs , _Bool ret_len ) ;
#line 55
static unsigned int re_copy_regs___0(struct re_registers *regs , regmatch_t *pmatch ,
                                     Idx nregs , int regs_allocated ) ;
#line 58
static reg_errcode_t prune_impossible_nodes___0(re_match_context_t *mctx ) ;
#line 60
static Idx check_matching___0(re_match_context_t *mctx , _Bool fl_longest_match ,
                              Idx *p_match_first ) ;
#line 62
static Idx check_halt_state_context___0(re_match_context_t const   *mctx , re_dfastate_t const   *state___0 ,
                                        Idx idx ) ;
#line 65
static void update_regs___0(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                            Idx cur_node , Idx cur_idx , Idx nmatch ) ;
#line 68
static reg_errcode_t push_fail_stack___0(struct re_fail_stack_t *fs , Idx str_idx ,
                                         Idx dest_node , Idx nregs , regmatch_t *regs ,
                                         re_node_set *eps_via_nodes ) ;
#line 73
static reg_errcode_t set_regs___0(regex_t const   *preg , re_match_context_t const   *mctx ,
                                  size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) ;
#line 77
static reg_errcode_t free_fail_stack_return___0(struct re_fail_stack_t *fs ) ;
#line 81
static int sift_states_iter_mb___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                   Idx node_idx , Idx str_idx , Idx max_str_idx ) ;
#line 86
static reg_errcode_t sift_states_backward___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 89
static reg_errcode_t build_sifted_states___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *cur_dest ) ;
#line 93
static reg_errcode_t update_cur_sifted_state___0(re_match_context_t const   *mctx ,
                                                 re_sift_context_t *sctx , Idx str_idx ,
                                                 re_node_set *dest_nodes ) ;
#line 98
static reg_errcode_t add_epsilon_src_nodes___0(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                               re_node_set const   *candidates ) ;
#line 102
static _Bool check_dst_limits___0(re_match_context_t const   *mctx , re_node_set const   *limits ,
                                  Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) ;
#line 106
static int check_dst_limits_calc_pos_1___0(re_match_context_t const   *mctx , int boundaries ,
                                           Idx subexp_idx , Idx from_node , Idx bkref_idx ) ;
#line 110
static int check_dst_limits_calc_pos___0(re_match_context_t const   *mctx , Idx limit ,
                                         Idx subexp_idx , Idx from_node , Idx str_idx ,
                                         Idx bkref_idx ) ;
#line 114
static reg_errcode_t check_subexp_limits___0(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                             re_node_set const   *candidates , re_node_set *limits ,
                                             struct re_backref_cache_entry *bkref_ents ,
                                             Idx str_idx ) ;
#line 120
static reg_errcode_t sift_states_bkref___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                           Idx str_idx , re_node_set const   *candidates ) ;
#line 124
static reg_errcode_t merge_state_array___0(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                           re_dfastate_t **src , Idx num ) ;
#line 128
static re_dfastate_t *find_recover_state___0(reg_errcode_t *err , re_match_context_t *mctx ) ;
#line 130
static re_dfastate_t *transit_state___0(reg_errcode_t *err , re_match_context_t *mctx ,
                                        re_dfastate_t *state___0 ) ;
#line 133
static re_dfastate_t *merge_state_with_log___0(reg_errcode_t *err , re_match_context_t *mctx ,
                                               re_dfastate_t *next_state ) ;
#line 137
static reg_errcode_t check_subexp_matching_top___0(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                                   Idx str_idx ) ;
#line 147
static reg_errcode_t transit_state_mb___0(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 151
static reg_errcode_t transit_state_bkref___0(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 154
static reg_errcode_t get_subexp___0(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) ;
#line 157
static reg_errcode_t get_subexp_sub___0(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                        re_sub_match_last_t *sub_last , Idx bkref_node ,
                                        Idx bkref_str ) ;
#line 162
static Idx find_subexp_node___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                Idx subexp_idx , int type ) ;
#line 164
static reg_errcode_t check_arrival___0(re_match_context_t *mctx , state_array_t *path ,
                                       Idx top_node , Idx top_str , Idx last_node ,
                                       Idx last_str , int type ) ;
#line 168
static reg_errcode_t check_arrival_add_next_nodes___0(re_match_context_t *mctx , Idx str_idx ,
                                                      re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 173
static reg_errcode_t check_arrival_expand_ecl___0(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                                  Idx ex_subexp , int type ) ;
#line 177
static reg_errcode_t check_arrival_expand_ecl_sub___0(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                      Idx target , Idx ex_subexp ,
                                                      int type ) ;
#line 181
static reg_errcode_t expand_bkref_cache___0(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                            Idx cur_str , Idx subexp_num , int type ) ;
#line 185
static _Bool build_trtable___0(re_dfa_t const   *dfa , re_dfastate_t *state___0 ) ;
#line 188
static int check_node_accept_bytes___0(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                       Idx str_idx ) ;
#line 197
static Idx group_nodes_into_DFAstates___0(re_dfa_t const   *dfa , re_dfastate_t const   *state___0 ,
                                          re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 201
static _Bool check_node_accept___0(re_match_context_t const   *mctx , re_token_t const   *node ,
                                   Idx idx ) ;
#line 204
static reg_errcode_t extend_buffers___0(re_match_context_t *mctx ) ;
#line 368 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static regoff_t re_search_2_stub___0(struct re_pattern_buffer *bufp , char const   *string1 ,
                                     Idx length1 , char const   *string2 , Idx length2 ,
                                     Idx start , regoff_t range , struct re_registers *regs ,
                                     Idx stop , _Bool ret_len ) 
{ 
  char const   *str ;
  regoff_t rval ;
  Idx len ;
  char *s ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 378
  len = length1 + length2;
#line 379
  s = (char *)((void *)0);
#line 381
  if (length1 < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (length2 < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (stop < 0UL) {
#line 381
    tmp = 1;
  } else
#line 381
  if (len < length1) {
#line 381
    tmp = 1;
  } else {
#line 381
    tmp = 0;
  }
  {
#line 381
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 381
  if (tmp___0) {
#line 382
    return ((regoff_t )-2);
  }
#line 385
  if (length2 > 0UL) {
#line 386
    if (length1 > 0UL) {
      {
#line 388
      tmp___1 = malloc(len * sizeof(char ));
#line 388
      s = (char *)tmp___1;
#line 390
      tmp___2 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
      }
#line 390
      if (tmp___2) {
#line 391
        return ((regoff_t )-2);
      }
      {
#line 395
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string1,
             length1);
#line 396
      memcpy((void */* __restrict  */)(s + length1), (void const   */* __restrict  */)string2,
             length2);
#line 398
      str = (char const   *)s;
      }
    } else {
#line 401
      str = string2;
    }
  } else {
#line 403
    str = string1;
  }
  {
#line 405
  rval = re_search_stub___0(bufp, str, len, start, range, stop, regs, ret_len);
#line 407
  free((void *)s);
  }
#line 408
  return (rval);
}
}
#line 416 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static regoff_t re_search_stub___0(struct re_pattern_buffer *bufp , char const   *string ,
                                   Idx length , Idx start , regoff_t range , Idx stop ,
                                   struct re_registers *regs , _Bool ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  Idx nregs ;
  regoff_t rval ;
  int eflags ;
  Idx last_start ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___15 ;

  {
#line 427
  eflags = 0;
#line 431
  last_start = start + (Idx )range;
#line 434
  if (start < 0UL) {
#line 434
    tmp = 1;
  } else
#line 434
  if (start > length) {
#line 434
    tmp = 1;
  } else {
#line 434
    tmp = 0;
  }
  {
#line 434
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 434
  if (tmp___0) {
#line 435
    return ((regoff_t )-1);
  }
#line 436
  if (length < last_start) {
#line 436
    tmp___3 = 1;
  } else
#line 436
  if (0L <= range) {
#line 436
    if (last_start < start) {
#line 436
      tmp___3 = 1;
    } else {
#line 436
      tmp___3 = 0;
    }
  } else {
#line 436
    tmp___3 = 0;
  }
  {
#line 436
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 436
  if (tmp___4) {
#line 437
    last_start = length;
  } else {
#line 438
    if (last_start < 0UL) {
#line 438
      tmp___1 = 1;
    } else
#line 438
    if (range < 0L) {
#line 438
      if (start <= last_start) {
#line 438
        tmp___1 = 1;
      } else {
#line 438
        tmp___1 = 0;
      }
    } else {
#line 438
      tmp___1 = 0;
    }
    {
#line 438
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 438
    if (tmp___2) {
#line 439
      last_start = (Idx )0;
    }
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (bufp->not_bol) {
#line 443
    tmp___5 = 1;
  } else {
#line 443
    tmp___5 = 0;
  }
#line 443
  eflags |= tmp___5;
#line 444
  if (bufp->not_eol) {
#line 444
    tmp___6 = 1 << 1;
  } else {
#line 444
    tmp___6 = 0;
  }
#line 444
  eflags |= tmp___6;
#line 447
  if (start < last_start) {
#line 447
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 447
      if (! bufp->fastmap_accurate) {
        {
#line 448
        rpl_re_compile_fastmap(bufp);
        }
      }
    }
  }
  {
#line 450
  tmp___7 = __builtin_expect((long )bufp->no_sub, 0L);
  }
#line 450
  if (tmp___7) {
#line 451
    regs = (struct re_registers *)((void *)0);
  }
#line 454
  if ((unsigned long )regs == (unsigned long )((void *)0)) {
#line 455
    nregs = (Idx )1;
  } else {
#line 456
    if (bufp->regs_allocated == 2U) {
#line 456
      if (regs->num_regs <= bufp->re_nsub) {
#line 456
        tmp___9 = 1;
      } else {
#line 456
        tmp___9 = 0;
      }
    } else {
#line 456
      tmp___9 = 0;
    }
    {
#line 456
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 456
    if (tmp___10) {
      {
#line 459
      nregs = regs->num_regs;
#line 460
      tmp___8 = __builtin_expect((long )(nregs < 1UL), 0L);
      }
#line 460
      if (tmp___8) {
#line 463
        regs = (struct re_registers *)((void *)0);
#line 464
        nregs = (Idx )1;
      }
    } else {
#line 468
      nregs = bufp->re_nsub + 1UL;
    }
  }
  {
#line 469
  tmp___11 = malloc(nregs * sizeof(regmatch_t ));
#line 469
  pmatch = (regmatch_t *)tmp___11;
#line 470
  tmp___12 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
#line 470
  if (tmp___12) {
#line 472
    rval = (regoff_t )-2;
#line 473
    goto out;
  }
  {
#line 476
  result = re_search_internal___0((regex_t const   *)bufp, string, length, start,
                                  last_start, stop, nregs, pmatch, eflags);
#line 479
  rval = (regoff_t )0;
  }
#line 482
  if ((int )result != 0) {
#line 483
    rval = (regoff_t )-1;
  } else
#line 484
  if ((unsigned long )regs != (unsigned long )((void *)0)) {
    {
#line 487
    bufp->regs_allocated = re_copy_regs___0(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 489
    tmp___13 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
#line 489
    if (tmp___13) {
#line 490
      rval = (regoff_t )-2;
    }
  }
  {
#line 493
  tmp___15 = __builtin_expect((long )(rval == 0L), 1L);
  }
#line 493
  if (tmp___15) {
#line 495
    if (ret_len) {
#line 497
      if (! ((Idx )(pmatch + 0)->rm_so == start)) {
        {
#line 497
        __assert_fail("pmatch[0].rm_so == start", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                      497U, "re_search_stub");
        }
      }
#line 498
      rval = (regoff_t )((Idx )(pmatch + 0)->rm_eo - start);
    } else {
#line 501
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
#line 503
  free((void *)pmatch);
  }
  out: 
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 505
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  return (rval);
}
}
#line 509 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static unsigned int re_copy_regs___0(struct re_registers *regs , regmatch_t *pmatch ,
                                     Idx nregs , int regs_allocated ) 
{ 
  int rval ;
  Idx i ;
  Idx need_regs ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  regoff_t *new_start ;
  void *tmp___3 ;
  regoff_t *new_end ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  regoff_t tmp___10 ;

  {
#line 514
  rval = 1;
#line 516
  need_regs = nregs + 1UL;
#line 521
  if (regs_allocated == 0) {
    {
#line 523
    tmp = malloc(need_regs * sizeof(regoff_t ));
#line 523
    regs->start = (regoff_t *)tmp;
#line 524
    tmp___0 = __builtin_expect((long )((unsigned long )regs->start == (unsigned long )((void *)0)),
                               0L);
    }
#line 524
    if (tmp___0) {
#line 525
      return (0U);
    }
    {
#line 526
    tmp___1 = malloc(need_regs * sizeof(regoff_t ));
#line 526
    regs->end = (regoff_t *)tmp___1;
#line 527
    tmp___2 = __builtin_expect((long )((unsigned long )regs->end == (unsigned long )((void *)0)),
                               0L);
    }
#line 527
    if (tmp___2) {
      {
#line 529
      free((void *)regs->start);
      }
#line 530
      return (0U);
    }
#line 532
    regs->num_regs = need_regs;
  } else
#line 534
  if (regs_allocated == 1) {
    {
#line 538
    tmp___7 = __builtin_expect((long )(need_regs > regs->num_regs), 0L);
    }
#line 538
    if (tmp___7) {
      {
#line 540
      tmp___3 = realloc((void *)regs->start, need_regs * sizeof(regoff_t ));
#line 540
      new_start = (regoff_t *)tmp___3;
#line 542
      tmp___4 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
      }
#line 542
      if (tmp___4) {
#line 543
        return (0U);
      }
      {
#line 544
      tmp___5 = realloc((void *)regs->end, need_regs * sizeof(regoff_t ));
#line 544
      new_end = (regoff_t *)tmp___5;
#line 545
      tmp___6 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                 0L);
      }
#line 545
      if (tmp___6) {
        {
#line 547
        free((void *)new_start);
        }
#line 548
        return (0U);
      }
#line 550
      regs->start = new_start;
#line 551
      regs->end = new_end;
#line 552
      regs->num_regs = need_regs;
    }
  } else {
#line 557
    if (! (regs_allocated == 2)) {
      {
#line 557
      __assert_fail("regs_allocated == REGS_FIXED", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    557U, "re_copy_regs");
      }
    }
#line 559
    if (! (regs->num_regs >= nregs)) {
      {
#line 559
      __assert_fail("regs->num_regs >= nregs", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    559U, "re_copy_regs");
      }
    }
#line 560
    rval = 2;
  }
#line 564
  i = (Idx )0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < nregs)) {
#line 564
      goto while_break;
    }
#line 566
    *(regs->start + i) = (pmatch + i)->rm_so;
#line 567
    *(regs->end + i) = (pmatch + i)->rm_eo;
#line 564
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 569
    if (! (i < regs->num_regs)) {
#line 569
      goto while_break___0;
    }
#line 570
    tmp___10 = (regoff_t )-1;
#line 570
    *(regs->end + i) = tmp___10;
#line 570
    *(regs->start + i) = tmp___10;
#line 569
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 572
  return ((unsigned int )rval);
}
}
#line 639 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t re_search_internal___0(regex_t const   *preg , char const   *string ,
                                            Idx length , Idx start , Idx last_start ,
                                            Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                            int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  Idx left_lim ;
  Idx right_lim ;
  int incr ;
  _Bool fl_longest_match ;
  int match_kind ;
  Idx match_first ;
  Idx match_last ;
  Idx extra_nmatch ;
  _Bool sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  unsigned char *t ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  __re_size_t offset ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  Idx *tmp___19 ;
  re_dfastate_t *pstate ;
  long tmp___20 ;
  long tmp___21 ;
  Idx reg_idx ;
  regoff_t tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;

  {
#line 648
  dfa = (re_dfa_t const   *)preg->buffer;
#line 654
  match_last = (Idx )-1;
#line 659
  mctx.input.raw_mbs = (unsigned char const   *)0;
#line 659
  mctx.input.mbs = (unsigned char *)0;
#line 659
  mctx.input.wcs = (wint_t *)0;
#line 659
  mctx.input.offsets = (Idx *)0;
#line 659
  mctx.input.cur_state.__count = 0;
#line 659
  mctx.input.cur_state.__value.__wch = 0U;
#line 659
  mctx.input.raw_mbs_idx = 0UL;
#line 659
  mctx.input.valid_len = 0UL;
#line 659
  mctx.input.valid_raw_len = 0UL;
#line 659
  mctx.input.bufs_len = 0UL;
#line 659
  mctx.input.cur_idx = 0UL;
#line 659
  mctx.input.raw_len = 0UL;
#line 659
  mctx.input.len = 0UL;
#line 659
  mctx.input.raw_stop = 0UL;
#line 659
  mctx.input.stop = 0UL;
#line 659
  mctx.input.tip_context = 0U;
#line 659
  mctx.input.trans = (unsigned char *)0;
#line 659
  mctx.input.word_char = (bitset_word_t const   *)0;
#line 659
  mctx.input.icase = (unsigned char)0;
#line 659
  mctx.input.is_utf8 = (unsigned char)0;
#line 659
  mctx.input.map_notascii = (unsigned char)0;
#line 659
  mctx.input.mbs_allocated = (unsigned char)0;
#line 659
  mctx.input.offsets_needed = (unsigned char)0;
#line 659
  mctx.input.newline_anchor = (unsigned char)0;
#line 659
  mctx.input.word_ops_used = (unsigned char)0;
#line 659
  mctx.input.mb_cur_max = 0;
#line 659
  mctx.dfa = dfa;
#line 659
  mctx.eflags = 0;
#line 659
  mctx.match_last = 0UL;
#line 659
  mctx.last_node = 0UL;
#line 659
  mctx.state_log = (re_dfastate_t **)0;
#line 659
  mctx.state_log_top = 0UL;
#line 659
  mctx.nbkref_ents = 0UL;
#line 659
  mctx.abkref_ents = 0UL;
#line 659
  mctx.bkref_ents = (struct re_backref_cache_entry *)0;
#line 659
  mctx.max_mb_elem_len = 0;
#line 659
  mctx.nsub_tops = 0UL;
#line 659
  mctx.asub_tops = 0UL;
#line 659
  mctx.sub_tops = (re_sub_match_top_t **)0;
#line 663
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 663
    if (preg->fastmap_accurate) {
#line 663
      if (start != last_start) {
#line 663
        if (! preg->can_be_null) {
#line 663
          tmp = preg->fastmap;
        } else {
#line 663
          tmp = (char */* const  */)((void *)0);
        }
      } else {
#line 663
        tmp = (char */* const  */)((void *)0);
      }
    } else {
#line 663
      tmp = (char */* const  */)((void *)0);
    }
  } else {
#line 663
    tmp = (char */* const  */)((void *)0);
  }
#line 663
  fastmap = (char *)tmp;
#line 666
  t = (unsigned char *)preg->translate;
#line 673
  if (nmatch > (size_t )preg->re_nsub) {
#line 673
    extra_nmatch = nmatch - (size_t )(preg->re_nsub + 1UL);
  } else {
#line 673
    extra_nmatch = (Idx )0;
  }
#line 674
  nmatch -= extra_nmatch;
#line 677
  if (preg->used == 0UL) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 677
    tmp___0 = 1;
  } else {
#line 677
    tmp___0 = 0;
  }
  {
#line 677
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 677
  if (tmp___1) {
#line 680
    return ((reg_errcode_t )1);
  }
#line 690
  if ((dfa->init_state)->nodes.nelem == 0UL) {
#line 690
    if ((dfa->init_state_word)->nodes.nelem == 0UL) {
#line 690
      if ((dfa->init_state_nl)->nodes.nelem == 0UL) {
#line 690
        goto _L;
      } else
#line 690
      if (! preg->newline_anchor) {
        _L: /* CIL Label */ 
#line 695
        if (start != 0UL) {
#line 695
          if (last_start != 0UL) {
#line 696
            return ((reg_errcode_t )1);
          }
        }
#line 697
        last_start = (Idx )0;
#line 697
        start = last_start;
      }
    }
  }
#line 701
  if (nmatch != 0UL) {
#line 701
    tmp___2 = 1;
  } else
#line 701
  if (dfa->nbackref) {
#line 701
    tmp___2 = 1;
  } else {
#line 701
    tmp___2 = 0;
  }
  {
#line 701
  fl_longest_match = (_Bool )tmp___2;
#line 703
  err = re_string_allocate___0(& mctx.input, string, length, (Idx )(dfa->nodes_len + 1UL),
                               (unsigned char *)preg->translate, (_Bool )((preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                               dfa);
#line 706
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 706
  if (tmp___3) {
#line 707
    goto free_return;
  }
  {
#line 708
  mctx.input.stop = stop;
#line 709
  mctx.input.raw_stop = stop;
#line 710
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 712
  err = match_ctx_init___0(& mctx, eflags, (Idx )(dfa->nbackref * 2UL));
#line 713
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 713
  if (tmp___4) {
#line 714
    goto free_return;
  }
#line 720
  if (nmatch > 1UL) {
#line 720
    goto _L___0;
  } else
#line 720
  if (dfa->has_mb_node) {
    _L___0: /* CIL Label */ 
    {
#line 723
    tmp___5 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= mctx.input.bufs_len),
                               0L);
    }
#line 723
    if (tmp___5) {
#line 725
      err = (reg_errcode_t )12;
#line 726
      goto free_return;
    }
    {
#line 729
    tmp___6 = malloc((mctx.input.bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 729
    mctx.state_log = (re_dfastate_t **)tmp___6;
#line 730
    tmp___7 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
#line 730
    if (tmp___7) {
#line 732
      err = (reg_errcode_t )12;
#line 733
      goto free_return;
    }
  } else {
#line 737
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 739
  match_first = start;
#line 740
  if (eflags & 1) {
#line 740
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 740
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 744
  if (last_start < start) {
#line 744
    incr = -1;
  } else {
#line 744
    incr = 1;
  }
#line 745
  if (last_start < start) {
#line 745
    left_lim = last_start;
  } else {
#line 745
    left_lim = start;
  }
#line 746
  if (last_start < start) {
#line 746
    right_lim = start;
  } else {
#line 746
    right_lim = last_start;
  }
#line 747
  sb = (_Bool )(dfa->mb_cur_max == 1);
#line 748
  if (fastmap) {
#line 748
    if (sb) {
#line 748
      tmp___8 = 4;
    } else
#line 748
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 748
      tmp___8 = 0;
    } else
#line 748
    if (t) {
#line 748
      tmp___8 = 0;
    } else {
#line 748
      tmp___8 = 4;
    }
#line 748
    if (start <= last_start) {
#line 748
      tmp___9 = 2;
    } else {
#line 748
      tmp___9 = 0;
    }
#line 748
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 748
      tmp___10 = 1;
    } else {
#line 748
      tmp___10 = 0;
    }
#line 748
    match_kind = (tmp___8 | tmp___9) | tmp___10;
  } else {
#line 748
    match_kind = 8;
  }
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    err = (reg_errcode_t )1;
#line 758
    if (match_first < left_lim) {
#line 759
      goto free_return;
    } else
#line 758
    if (right_lim < match_first) {
#line 759
      goto free_return;
    }
    {
#line 768
    if (match_kind == 8) {
#line 768
      goto case_8;
    }
#line 772
    if (match_kind == 7) {
#line 772
      goto case_7;
    }
#line 779
    if (match_kind == 6) {
#line 779
      goto case_6;
    }
#line 796
    if (match_kind == 5) {
#line 796
      goto case_5;
    }
#line 796
    if (match_kind == 4) {
#line 796
      goto case_5;
    }
#line 810
    goto switch_default;
    case_8: /* CIL Label */ 
#line 770
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 774
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 774
      tmp___11 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 774
      if (tmp___11) {
#line 774
        if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 774
          goto while_break___0;
        }
      } else {
#line 774
        goto while_break___0;
      }
#line 776
      match_first ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 777
    goto forward_match_found_start_or_reached_end;
    case_6: /* CIL Label */ 
    {
#line 781
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 781
      tmp___12 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 781
      if (tmp___12) {
#line 781
        if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 781
          goto while_break___1;
        }
      } else {
#line 781
        goto while_break___1;
      }
#line 783
      match_first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    forward_match_found_start_or_reached_end: 
    {
#line 786
    tmp___14 = __builtin_expect((long )(match_first == right_lim), 0L);
    }
#line 786
    if (tmp___14) {
#line 788
      if (match_first >= length) {
#line 788
        ch = 0;
      } else {
#line 788
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 790
      if (t) {
#line 790
        tmp___13 = (int )*(t + ch);
      } else {
#line 790
        tmp___13 = ch;
      }
#line 790
      if (! *(fastmap + tmp___13)) {
#line 791
        goto free_return;
      }
    }
#line 793
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 798
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 798
      if (! (match_first >= left_lim)) {
#line 798
        goto while_break___2;
      }
#line 800
      if (match_first >= length) {
#line 800
        ch = 0;
      } else {
#line 800
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 802
      if (t) {
#line 802
        tmp___15 = (int )*(t + ch);
      } else {
#line 802
        tmp___15 = ch;
      }
#line 802
      if (*(fastmap + tmp___15)) {
#line 803
        goto while_break___2;
      }
#line 804
      match_first --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 806
    if (match_first < left_lim) {
#line 807
      goto free_return;
    }
#line 808
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 814
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 818
      offset = match_first - mctx.input.raw_mbs_idx;
#line 819
      tmp___17 = __builtin_expect((long )(offset >= mctx.input.valid_raw_len), 0L);
      }
#line 819
      if (tmp___17) {
        {
#line 821
        err = re_string_reconstruct___0(& mctx.input, match_first, eflags);
#line 823
        tmp___16 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 823
        if (tmp___16) {
#line 824
          goto free_return;
        }
#line 826
        offset = match_first - mctx.input.raw_mbs_idx;
      }
#line 830
      if (match_first >= length) {
#line 830
        ch = 0;
      } else {
#line 830
        ch = (int )*(mctx.input.mbs + offset);
      }
#line 832
      if (*(fastmap + ch)) {
#line 833
        goto while_break___3;
      }
#line 834
      match_first += (Idx )incr;
#line 835
      if (match_first < left_lim) {
#line 837
        err = (reg_errcode_t )1;
#line 838
        goto free_return;
      } else
#line 835
      if (match_first > right_lim) {
#line 837
        err = (reg_errcode_t )1;
#line 838
        goto free_return;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 841
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 846
    err = re_string_reconstruct___0(& mctx.input, match_first, eflags);
#line 847
    tmp___18 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 847
    if (tmp___18) {
#line 848
      goto free_return;
    }
#line 853
    if (! sb) {
#line 853
      if (! (0UL == mctx.input.valid_len)) {
#line 853
        if (! (*(mctx.input.wcs + 0) != 4294967295U)) {
#line 854
          goto __Cont;
        }
      }
    }
#line 859
    mctx.max_mb_elem_len = 0;
#line 859
    mctx.nbkref_ents = (Idx )mctx.max_mb_elem_len;
#line 859
    mctx.state_log_top = mctx.nbkref_ents;
#line 860
    if (start <= last_start) {
#line 860
      tmp___19 = & match_first;
    } else {
#line 860
      tmp___19 = (Idx *)((void *)0);
    }
    {
#line 860
    match_last = check_matching___0(& mctx, fl_longest_match, tmp___19);
    }
#line 862
    if (match_last != 0xffffffffffffffffUL) {
      {
#line 864
      tmp___21 = __builtin_expect((long )(match_last == 0xfffffffffffffffeUL), 0L);
      }
#line 864
      if (tmp___21) {
#line 866
        err = (reg_errcode_t )12;
#line 867
        goto free_return;
      } else {
#line 871
        mctx.match_last = match_last;
#line 872
        if (! preg->no_sub) {
#line 872
          if (nmatch > 1UL) {
            {
#line 874
            pstate = *(mctx.state_log + match_last);
#line 875
            mctx.last_node = check_halt_state_context___0((re_match_context_t const   *)(& mctx),
                                                          (re_dfastate_t const   *)pstate,
                                                          match_last);
            }
          } else {
#line 872
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 872
        if (dfa->nbackref) {
          {
#line 874
          pstate = *(mctx.state_log + match_last);
#line 875
          mctx.last_node = check_halt_state_context___0((re_match_context_t const   *)(& mctx),
                                                        (re_dfastate_t const   *)pstate,
                                                        match_last);
          }
        }
#line 878
        if (! preg->no_sub) {
#line 878
          if (nmatch > 1UL) {
#line 878
            if (dfa->has_plural_match) {
#line 878
              goto _L___2;
            } else {
#line 878
              goto _L___4;
            }
          } else {
#line 878
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 878
        if (dfa->nbackref) {
          _L___2: /* CIL Label */ 
          {
#line 881
          err = prune_impossible_nodes___0(& mctx);
          }
#line 882
          if ((int )err == 0) {
#line 883
            goto while_break;
          }
          {
#line 884
          tmp___20 = __builtin_expect((long )((int )err != 1), 0L);
          }
#line 884
          if (tmp___20) {
#line 885
            goto free_return;
          }
#line 886
          match_last = (Idx )-1;
        } else {
#line 889
          goto while_break;
        }
      }
    }
    {
#line 893
    match_ctx_clean___0(& mctx);
    }
    __Cont: /* CIL Label */ 
#line 755
    match_first += (Idx )incr;
  }
  while_break: /* CIL Label */ ;
  }
#line 902
  if (nmatch > 0UL) {
#line 907
    reg_idx = (Idx )1;
    {
#line 907
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 907
      if (! (reg_idx < nmatch)) {
#line 907
        goto while_break___4;
      }
#line 908
      tmp___22 = (regoff_t )-1;
#line 908
      (pmatch + reg_idx)->rm_eo = tmp___22;
#line 908
      (pmatch + reg_idx)->rm_so = tmp___22;
#line 907
      reg_idx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 911
    (pmatch + 0)->rm_so = (regoff_t )0;
#line 912
    (pmatch + 0)->rm_eo = (regoff_t )mctx.match_last;
#line 917
    if (! preg->no_sub) {
#line 917
      if (nmatch > 1UL) {
#line 919
        if (dfa->has_plural_match) {
#line 919
          if (dfa->nbackref > 0UL) {
#line 919
            tmp___23 = 1;
          } else {
#line 919
            tmp___23 = 0;
          }
        } else {
#line 919
          tmp___23 = 0;
        }
        {
#line 919
        err = set_regs___0(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                           (_Bool )tmp___23);
#line 921
        tmp___24 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 921
        if (tmp___24) {
#line 922
          goto free_return;
        }
      }
    }
#line 928
    reg_idx = (Idx )0;
    {
#line 928
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 928
      if (! (reg_idx < nmatch)) {
#line 928
        goto while_break___5;
      }
#line 929
      if ((pmatch + reg_idx)->rm_so != -1L) {
        {
#line 932
        tmp___25 = __builtin_expect((long )((int )mctx.input.offsets_needed != 0),
                                    0L);
        }
#line 932
        if (tmp___25) {
#line 934
          if ((Idx )(pmatch + reg_idx)->rm_so == mctx.input.valid_len) {
#line 934
            (pmatch + reg_idx)->rm_so = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 934
            (pmatch + reg_idx)->rm_so = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_so);
          }
#line 938
          if ((Idx )(pmatch + reg_idx)->rm_eo == mctx.input.valid_len) {
#line 938
            (pmatch + reg_idx)->rm_eo = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 938
            (pmatch + reg_idx)->rm_eo = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_eo);
          }
        }
#line 946
        (pmatch + reg_idx)->rm_so = (regoff_t )((Idx )(pmatch + reg_idx)->rm_so + match_first);
#line 947
        (pmatch + reg_idx)->rm_eo = (regoff_t )((Idx )(pmatch + reg_idx)->rm_eo + match_first);
      }
#line 928
      reg_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 949
    reg_idx = (Idx )0;
    {
#line 949
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 949
      if (! (reg_idx < extra_nmatch)) {
#line 949
        goto while_break___6;
      }
#line 951
      (pmatch + (nmatch + reg_idx))->rm_so = (regoff_t )-1;
#line 952
      (pmatch + (nmatch + reg_idx))->rm_eo = (regoff_t )-1;
#line 949
      reg_idx ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 955
    if (dfa->subexp_map) {
#line 956
      reg_idx = (Idx )0;
      {
#line 956
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 956
        if (! (reg_idx + 1UL < nmatch)) {
#line 956
          goto while_break___7;
        }
#line 957
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
#line 959
          (pmatch + (reg_idx + 1UL))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_so;
#line 961
          (pmatch + (reg_idx + 1UL))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_eo;
        }
#line 956
        reg_idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  free_return: 
  {
#line 967
  free((void *)mctx.state_log);
  }
#line 968
  if (dfa->nbackref) {
    {
#line 969
    match_ctx_free___0(& mctx);
    }
  }
  {
#line 970
  re_string_destruct___0(& mctx.input);
  }
#line 971
  return (err);
}
}
#line 974 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t prune_impossible_nodes___0(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx halt_node ;
  Idx match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 978
  dfa = mctx->dfa;
#line 982
  lim_states = (re_dfastate_t **)((void *)0);
#line 987
  match_last = mctx->match_last;
#line 988
  halt_node = mctx->last_node;
#line 991
  tmp = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= match_last),
                         0L);
  }
#line 991
  if (tmp) {
#line 992
    return ((reg_errcode_t )12);
  }
  {
#line 994
  tmp___0 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 994
  sifted_states = (re_dfastate_t **)tmp___0;
#line 995
  tmp___1 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
#line 995
  if (tmp___1) {
#line 997
    ret = (reg_errcode_t )12;
#line 998
    goto free_return;
  }
#line 1000
  if (dfa->nbackref) {
    {
#line 1002
    tmp___2 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 1002
    lim_states = (re_dfastate_t **)tmp___2;
#line 1003
    tmp___3 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 1003
    if (tmp___3) {
#line 1005
      ret = (reg_errcode_t )12;
#line 1006
      goto free_return;
    }
    {
#line 1008
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1010
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (match_last + 1UL));
#line 1012
      sift_ctx_init___0(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1014
      ret = sift_states_backward___0((re_match_context_t const   *)mctx, & sctx);
#line 1015
      free((void *)sctx.limits.elems);
#line 1016
      tmp___4 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 1016
      if (tmp___4) {
#line 1017
        goto free_return;
      }
#line 1018
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 1019
        goto while_break;
      } else
#line 1018
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 1019
        goto while_break;
      }
      {
#line 1020
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1022
        match_last --;
#line 1023
        if (! (match_last < 0xfffffffffffffffeUL)) {
#line 1025
          ret = (reg_errcode_t )1;
#line 1026
          goto free_return;
        }
#line 1020
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
#line 1020
          if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 1020
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1030
      halt_node = check_halt_state_context___0((re_match_context_t const   *)mctx,
                                               (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                               match_last);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1034
    ret = merge_state_array___0(dfa, sifted_states, lim_states, match_last + 1UL);
#line 1036
    free((void *)lim_states);
#line 1037
    lim_states = (re_dfastate_t **)((void *)0);
#line 1038
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1038
    if (tmp___5) {
#line 1039
      goto free_return;
    }
  } else {
    {
#line 1043
    sift_ctx_init___0(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1044
    ret = sift_states_backward___0((re_match_context_t const   *)mctx, & sctx);
#line 1045
    free((void *)sctx.limits.elems);
#line 1046
    tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1046
    if (tmp___6) {
#line 1047
      goto free_return;
    }
#line 1048
    if ((unsigned long )*(sifted_states + 0) == (unsigned long )((void *)0)) {
#line 1050
      ret = (reg_errcode_t )1;
#line 1051
      goto free_return;
    }
  }
  {
#line 1054
  free((void *)mctx->state_log);
#line 1055
  mctx->state_log = sifted_states;
#line 1056
  sifted_states = (re_dfastate_t **)((void *)0);
#line 1057
  mctx->last_node = halt_node;
#line 1058
  mctx->match_last = match_last;
#line 1059
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
#line 1061
  free((void *)sifted_states);
#line 1062
  free((void *)lim_states);
  }
#line 1063
  return (ret);
}
}
#line 1070 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context___0)(reg_errcode_t *err ,
                                                                                                    re_match_context_t const   *mctx ,
                                                                                                    Idx idx ) 
{ 
  re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
#line 1075
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1076
  if ((dfa->init_state)->has_constraint) {
    {
#line 1079
    context = re_string_context_at___0(& mctx->input, idx - 1UL, (int )mctx->eflags);
    }
#line 1080
    if (context & 1U) {
#line 1081
      return ((re_dfastate_t *)dfa->init_state_word);
    } else
#line 1082
    if (context == 0U) {
#line 1083
      return ((re_dfastate_t *)dfa->init_state);
    } else
#line 1084
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1084
      if (context & (unsigned int )(1 << 1)) {
#line 1085
        return ((re_dfastate_t *)dfa->init_state_begbuf);
      } else {
#line 1084
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1086
    if (context & (unsigned int )(1 << 1)) {
#line 1087
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else
#line 1088
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
#line 1091
      tmp = re_acquire_state_context___0(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                         context);
      }
#line 1091
      return (tmp);
    } else {
#line 1097
      return ((re_dfastate_t *)dfa->init_state);
    }
  } else {
#line 1100
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
#line 1112 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx check_matching___0(re_match_context_t *mctx , _Bool fl_longest_match ,
                              Idx *p_match_first ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx match ;
  Idx match_last ;
  Idx cur_str_idx ;
  re_dfastate_t *cur_state ;
  _Bool at_init_state ;
  Idx next_start_idx ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  long tmp___5 ;
  re_dfastate_t *old_state ;
  Idx next_char_idx ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  Idx tmp___12 ;

  {
  {
#line 1117
  dfa = mctx->dfa;
#line 1119
  match = (Idx )0;
#line 1120
  match_last = (Idx )-1;
#line 1121
  cur_str_idx = mctx->input.cur_idx;
#line 1123
  at_init_state = (_Bool )((unsigned long )p_match_first != (unsigned long )((void *)0));
#line 1124
  next_start_idx = cur_str_idx;
#line 1126
  err = (reg_errcode_t )0;
#line 1127
  cur_state = acquire_init_state_context___0(& err, (re_match_context_t const   *)mctx,
                                             cur_str_idx);
#line 1129
  tmp___0 = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1129
  if (tmp___0) {
#line 1131
    if (! ((int )err == 12)) {
      {
#line 1131
      __assert_fail("err == REG_ESPACE", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                    1131U, "check_matching");
      }
    }
#line 1132
    return ((Idx )-2);
  }
#line 1135
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 1137
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1141
    tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
    }
#line 1141
    if (tmp___3) {
      {
#line 1143
      at_init_state = (_Bool)0;
#line 1144
      err = check_subexp_matching_top___0(mctx, & cur_state->nodes, (Idx )0);
#line 1145
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1145
      if (tmp___1) {
#line 1146
        return ((Idx )err);
      }
#line 1148
      if (cur_state->has_backref) {
        {
#line 1150
        err = transit_state_bkref___0(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1151
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1151
        if (tmp___2) {
#line 1152
          return ((Idx )err);
        }
      }
    }
  }
  {
#line 1158
  tmp___5 = __builtin_expect((long )cur_state->halt, 0L);
  }
#line 1158
  if (tmp___5) {
#line 1160
    if (! cur_state->has_constraint) {
#line 1160
      goto _L;
    } else {
      {
#line 1160
      tmp___4 = check_halt_state_context___0((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                             cur_str_idx);
      }
#line 1160
      if (tmp___4) {
        _L: /* CIL Label */ 
#line 1163
        if (! fl_longest_match) {
#line 1164
          return (cur_str_idx);
        } else {
#line 1167
          match_last = cur_str_idx;
#line 1168
          match = (Idx )1;
        }
      }
    }
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (! (mctx->input.stop <= mctx->input.cur_idx))) {
#line 1173
      goto while_break;
    }
    {
#line 1175
    old_state = cur_state;
#line 1176
    next_char_idx = mctx->input.cur_idx + 1UL;
#line 1178
    tmp___8 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
    }
#line 1178
    if (tmp___8) {
#line 1178
      goto _L___0;
    } else {
      {
#line 1178
      tmp___9 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
      }
#line 1178
      if (tmp___9) {
#line 1178
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: /* CIL Label */ 
          {
#line 1182
          err = extend_buffers___0(mctx);
#line 1183
          tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 1183
          if (tmp___7) {
#line 1185
            if (! ((int )err == 12)) {
              {
#line 1185
              __assert_fail("err == REG_ESPACE", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                            1185U, "check_matching");
              }
            }
#line 1186
            return ((Idx )-2);
          }
        }
      }
    }
    {
#line 1190
    cur_state = transit_state___0(& err, mctx, cur_state);
    }
#line 1191
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
      {
#line 1192
      cur_state = merge_state_with_log___0(& err, mctx, cur_state);
      }
    }
#line 1194
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
#line 1199
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1199
      if (tmp___10) {
#line 1200
        return ((Idx )-2);
      }
#line 1202
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1205
        goto while_break;
      } else
#line 1202
      if (match) {
#line 1202
        if (! fl_longest_match) {
#line 1205
          goto while_break;
        } else {
#line 1202
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1202
        cur_state = find_recover_state___0(& err, mctx);
        }
#line 1202
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1205
          goto while_break;
        }
      }
    }
    {
#line 1208
    tmp___11 = __builtin_expect((long )at_init_state, 0L);
    }
#line 1208
    if (tmp___11) {
#line 1210
      if ((unsigned long )old_state == (unsigned long )cur_state) {
#line 1211
        next_start_idx = next_char_idx;
      } else {
#line 1213
        at_init_state = (_Bool)0;
      }
    }
#line 1216
    if (cur_state->halt) {
#line 1220
      if (! cur_state->has_constraint) {
#line 1220
        goto _L___2;
      } else {
        {
#line 1220
        tmp___12 = check_halt_state_context___0((re_match_context_t const   *)mctx,
                                                (re_dfastate_t const   *)cur_state,
                                                mctx->input.cur_idx);
        }
#line 1220
        if (tmp___12) {
          _L___2: /* CIL Label */ 
#line 1225
          match_last = mctx->input.cur_idx;
#line 1226
          match = (Idx )1;
#line 1229
          p_match_first = (Idx *)((void *)0);
#line 1230
          if (! fl_longest_match) {
#line 1231
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  if (p_match_first) {
#line 1237
    *p_match_first += next_start_idx;
  }
#line 1239
  return (match_last);
}
}
#line 1244 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_halt_node_context___0(re_dfa_t const   *dfa , Idx node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1248
  type = (dfa->nodes + node)->type;
#line 1249
  constraint = (dfa->nodes + node)->constraint;
#line 1250
  if ((unsigned int )type != 2U) {
#line 1251
    return ((_Bool)0);
  }
#line 1252
  if (! constraint) {
#line 1253
    return ((_Bool)1);
  }
#line 1254
  if (constraint & 4U) {
#line 1254
    if (! (context & 1U)) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1254
  if (constraint & 8U) {
#line 1254
    if (context & 1U) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1254
  if (constraint & 32U) {
#line 1254
    if (! (context & (unsigned int )(1 << 1))) {
#line 1255
      return ((_Bool)0);
    } else {
#line 1254
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1254
  if (constraint & 128U) {
#line 1254
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1255
      return ((_Bool)0);
    }
  }
#line 1256
  return ((_Bool)1);
}
}
#line 1263 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx check_halt_state_context___0(re_match_context_t const   *mctx , re_dfastate_t const   *state___0 ,
                                        Idx idx ) 
{ 
  Idx i ;
  unsigned int context ;
  _Bool tmp ;

  {
  {
#line 1273
  context = re_string_context_at___0(& mctx->input, idx, (int )mctx->eflags);
#line 1274
  i = (Idx )0;
  }
  {
#line 1274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1274
    if (! (i < (Idx )state___0->nodes.nelem)) {
#line 1274
      goto while_break;
    }
    {
#line 1275
    tmp = check_halt_node_context___0((re_dfa_t const   *)mctx->dfa, *(state___0->nodes.elems + i),
                                      context);
    }
#line 1275
    if (tmp) {
#line 1276
      return (*(state___0->nodes.elems + i));
    }
#line 1274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return ((Idx )0);
}
}
#line 1285 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx proceed_next_node___0(re_match_context_t const   *mctx , Idx nregs , regmatch_t *regs ,
                                 Idx *pidx , Idx node , re_node_set *eps_via_nodes ,
                                 struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa ;
  Idx i ;
  _Bool ok ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  Idx dest_node ;
  long tmp ;
  Idx candidate ;
  Idx __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx naccepted ;
  re_token_type_t type ;
  int tmp___3 ;
  Idx subexp_idx ;
  char *buf___1 ;
  int tmp___4 ;
  Idx dest_node___0 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  Idx dest_node___1 ;
  Idx __attribute__((__pure__))  tmp___7 ;
  _Bool tmp___8 ;

  {
#line 1291
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1294
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
    {
#line 1296
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1297
    edests = dfa->edests + node;
#line 1299
    ok = re_node_set_insert___0(eps_via_nodes, node);
#line 1300
    tmp = __builtin_expect((long )(! ok), 0L);
    }
#line 1300
    if (tmp) {
#line 1301
      return ((Idx )-2);
    }
#line 1304
    dest_node = (Idx )-1;
#line 1304
    i = (Idx )0;
    {
#line 1304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1304
      if (! (i < edests->nelem)) {
#line 1304
        goto while_break;
      }
      {
#line 1306
      candidate = *(edests->elems + i);
#line 1307
      tmp___0 = re_node_set_contains___0((re_node_set const   *)cur_nodes, candidate);
      }
#line 1307
      if (! tmp___0) {
#line 1308
        goto __Cont;
      }
#line 1309
      if (dest_node == 0xffffffffffffffffUL) {
#line 1310
        dest_node = candidate;
      } else {
        {
#line 1316
        tmp___2 = re_node_set_contains___0((re_node_set const   *)eps_via_nodes, dest_node);
        }
#line 1316
        if (tmp___2) {
#line 1317
          return (candidate);
        } else
#line 1320
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
          {
#line 1320
          tmp___1 = push_fail_stack___0(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
          }
#line 1320
          if (tmp___1) {
#line 1323
            return ((Idx )-2);
          }
        }
#line 1326
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 1304
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1329
    return (dest_node);
  } else {
#line 1333
    naccepted = (Idx )0;
#line 1334
    type = (dfa->nodes + node)->type;
#line 1337
    if ((dfa->nodes + node)->accept_mb) {
      {
#line 1338
      tmp___3 = check_node_accept_bytes___0(dfa, node, & mctx->input, *pidx);
#line 1338
      naccepted = (Idx )tmp___3;
      }
    } else
#line 1341
    if ((unsigned int )type == 4U) {
#line 1343
      subexp_idx = (dfa->nodes + node)->opr.idx + 1UL;
#line 1344
      naccepted = (Idx )((regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so);
#line 1345
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1347
        if ((regs + subexp_idx)->rm_so == -1L) {
#line 1348
          return ((Idx )-1);
        } else
#line 1347
        if ((regs + subexp_idx)->rm_eo == -1L) {
#line 1348
          return ((Idx )-1);
        } else
#line 1349
        if (naccepted) {
          {
#line 1351
          buf___1 = (char *)mctx->input.mbs;
#line 1352
          tmp___4 = memcmp((void const   *)(buf___1 + (regs + subexp_idx)->rm_so),
                           (void const   *)(buf___1 + *pidx), naccepted);
          }
#line 1352
          if (tmp___4 != 0) {
#line 1354
            return ((Idx )-1);
          }
        }
      }
#line 1358
      if (naccepted == 0UL) {
        {
#line 1361
        ok = re_node_set_insert___0(eps_via_nodes, node);
#line 1362
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1362
        if (tmp___5) {
#line 1363
          return ((Idx )-2);
        }
        {
#line 1364
        dest_node___0 = *((dfa->edests + node)->elems + 0);
#line 1365
        tmp___6 = re_node_set_contains___0((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___0);
        }
#line 1365
        if (tmp___6) {
#line 1367
          return (dest_node___0);
        }
      }
    }
#line 1371
    if (naccepted != 0UL) {
#line 1371
      goto _L;
    } else {
      {
#line 1371
      tmp___8 = check_node_accept___0(mctx, (re_token_t const   *)(dfa->nodes + node),
                                      *pidx);
      }
#line 1371
      if (tmp___8) {
        _L: /* CIL Label */ 
#line 1374
        dest_node___1 = *(dfa->nexts + node);
#line 1375
        if (naccepted == 0UL) {
#line 1375
          (*pidx) ++;
        } else {
#line 1375
          *pidx += naccepted;
        }
#line 1376
        if (fs) {
#line 1376
          if (*pidx > (Idx )mctx->match_last) {
#line 1379
            return ((Idx )-1);
          } else
#line 1376
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1379
            return ((Idx )-1);
          } else {
            {
#line 1376
            tmp___7 = re_node_set_contains___0((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                               dest_node___1);
            }
#line 1376
            if (! tmp___7) {
#line 1379
              return ((Idx )-1);
            }
          }
        }
#line 1380
        eps_via_nodes->nelem = (Idx )0;
#line 1381
        return (dest_node___1);
      }
    }
  }
#line 1384
  return ((Idx )-1);
}
}
#line 1387 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t push_fail_stack___0(struct re_fail_stack_t *fs , Idx str_idx ,
                                         Idx dest_node , Idx nregs , regmatch_t *regs ,
                                         re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  Idx num ;
  Idx tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1393
  tmp = fs->num;
#line 1393
  (fs->num) ++;
#line 1393
  num = tmp;
#line 1394
  if (fs->num == fs->alloc) {
    {
#line 1397
    tmp___0 = realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * fs->alloc) * 2UL);
#line 1397
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
    }
#line 1399
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1400
      return ((reg_errcode_t )12);
    }
#line 1401
    fs->alloc *= 2UL;
#line 1402
    fs->stack = new_array;
  }
  {
#line 1404
  (fs->stack + num)->idx = str_idx;
#line 1405
  (fs->stack + num)->node = dest_node;
#line 1406
  tmp___1 = malloc(nregs * sizeof(regmatch_t ));
#line 1406
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
  }
#line 1407
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
#line 1408
    return ((reg_errcode_t )12);
  }
  {
#line 1409
  memcpy((void */* __restrict  */)(fs->stack + num)->regs, (void const   */* __restrict  */)regs,
         sizeof(regmatch_t ) * nregs);
#line 1410
  err = re_node_set_init_copy___0(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
#line 1411
  return (err);
}
}
#line 1414 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx pop_fail_stack___0(struct re_fail_stack_t *fs , Idx *pidx , Idx nregs ,
                              regmatch_t *regs , re_node_set *eps_via_nodes ) 
{ 
  Idx num ;

  {
#line 1419
  (fs->num) --;
#line 1419
  num = fs->num;
#line 1420
  if (! (num < 0xfffffffffffffffeUL)) {
    {
#line 1420
    __assert_fail("REG_VALID_INDEX (num)", "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c",
                  1420U, "pop_fail_stack");
    }
  }
  {
#line 1421
  *pidx = (fs->stack + num)->idx;
#line 1422
  memcpy((void */* __restrict  */)regs, (void const   */* __restrict  */)(fs->stack + num)->regs,
         sizeof(regmatch_t ) * nregs);
#line 1423
  free((void *)eps_via_nodes->elems);
#line 1424
  free((void *)(fs->stack + num)->regs);
#line 1425
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
#line 1426
  return ((fs->stack + num)->node);
}
}
#line 1434 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t set_regs___0(regex_t const   *preg , re_match_context_t const   *mctx ,
                                  size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) 
{ 
  re_dfa_t const   *dfa ;
  Idx idx ;
  Idx cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  _Bool prev_idx_match_malloced ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Idx reg_idx ;
  reg_errcode_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
#line 1439
  dfa = (re_dfa_t const   *)preg->buffer;
#line 1443
  fs_body.num = (Idx )0;
#line 1443
  fs_body.alloc = (Idx )2;
#line 1443
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1445
  prev_idx_match_malloced = (_Bool)0;
#line 1451
  if (fl_backtrack) {
    {
#line 1453
    fs = & fs_body;
#line 1454
    tmp = malloc(fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1454
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
    }
#line 1455
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
#line 1456
      return ((reg_errcode_t )12);
    }
  } else {
#line 1459
    fs = (struct re_fail_stack_t *)((void *)0);
  }
  {
#line 1461
  cur_node = (Idx )dfa->init_node;
#line 1462
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
  }
#line 1464
  if (nmatch * sizeof(regmatch_t ) < 4032UL) {
    {
#line 1465
    tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
#line 1465
    prev_idx_match = (regmatch_t *)tmp___0;
    }
  } else {
    {
#line 1468
    tmp___1 = malloc(nmatch * sizeof(regmatch_t ));
#line 1468
    prev_idx_match = (regmatch_t *)tmp___1;
    }
#line 1469
    if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
      {
#line 1471
      free_fail_stack_return___0(fs);
      }
#line 1472
      return ((reg_errcode_t )12);
    }
#line 1474
    prev_idx_match_malloced = (_Bool)1;
  }
  {
#line 1476
  memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
         sizeof(regmatch_t ) * nmatch);
#line 1478
  idx = (Idx )(pmatch + 0)->rm_so;
  }
  {
#line 1478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1478
    if (! (idx <= (Idx )(pmatch + 0)->rm_eo)) {
#line 1478
      goto while_break;
    }
    {
#line 1480
    update_regs___0(dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);
    }
#line 1482
    if (idx == (Idx )(pmatch + 0)->rm_eo) {
#line 1482
      if (cur_node == (Idx )mctx->last_node) {
#line 1485
        if (fs) {
#line 1487
          reg_idx = (Idx )0;
          {
#line 1487
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1487
            if (! (reg_idx < nmatch)) {
#line 1487
              goto while_break___0;
            }
#line 1488
            if ((pmatch + reg_idx)->rm_so > -1L) {
#line 1488
              if ((pmatch + reg_idx)->rm_eo == -1L) {
#line 1489
                goto while_break___0;
              }
            }
#line 1487
            reg_idx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1490
          if (reg_idx == nmatch) {
            {
#line 1492
            free((void *)eps_via_nodes.elems);
            }
#line 1493
            if (prev_idx_match_malloced) {
              {
#line 1494
              free((void *)prev_idx_match);
              }
            }
            {
#line 1495
            tmp___2 = free_fail_stack_return___0(fs);
            }
#line 1495
            return (tmp___2);
          }
          {
#line 1497
          cur_node = pop_fail_stack___0(fs, & idx, nmatch, pmatch, & eps_via_nodes);
          }
        } else {
          {
#line 1502
          free((void *)eps_via_nodes.elems);
          }
#line 1503
          if (prev_idx_match_malloced) {
            {
#line 1504
            free((void *)prev_idx_match);
            }
          }
#line 1505
          return ((reg_errcode_t )0);
        }
      }
    }
    {
#line 1510
    cur_node = proceed_next_node___0(mctx, nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                     fs);
#line 1513
    tmp___4 = __builtin_expect((long )(! (cur_node < 0xfffffffffffffffeUL)), 0L);
    }
#line 1513
    if (tmp___4) {
      {
#line 1515
      tmp___3 = __builtin_expect((long )(cur_node == 0xfffffffffffffffeUL), 0L);
      }
#line 1515
      if (tmp___3) {
        {
#line 1517
        free((void *)eps_via_nodes.elems);
        }
#line 1518
        if (prev_idx_match_malloced) {
          {
#line 1519
          free((void *)prev_idx_match);
          }
        }
        {
#line 1520
        free_fail_stack_return___0(fs);
        }
#line 1521
        return ((reg_errcode_t )12);
      }
#line 1523
      if (fs) {
        {
#line 1524
        cur_node = pop_fail_stack___0(fs, & idx, nmatch, pmatch, & eps_via_nodes);
        }
      } else {
        {
#line 1528
        free((void *)eps_via_nodes.elems);
        }
#line 1529
        if (prev_idx_match_malloced) {
          {
#line 1530
          free((void *)prev_idx_match);
          }
        }
#line 1531
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1535
  free((void *)eps_via_nodes.elems);
  }
#line 1536
  if (prev_idx_match_malloced) {
    {
#line 1537
    free((void *)prev_idx_match);
    }
  }
  {
#line 1538
  tmp___5 = free_fail_stack_return___0(fs);
  }
#line 1538
  return (tmp___5);
}
}
#line 1541 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t free_fail_stack_return___0(struct re_fail_stack_t *fs ) 
{ 
  Idx fs_idx ;

  {
#line 1545
  if (fs) {
#line 1548
    fs_idx = (Idx )0;
    {
#line 1548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1548
      if (! (fs_idx < fs->num)) {
#line 1548
        goto while_break;
      }
      {
#line 1550
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1551
      free((void *)(fs->stack + fs_idx)->regs);
#line 1548
      fs_idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1553
    free((void *)fs->stack);
    }
  }
#line 1555
  return ((reg_errcode_t )0);
}
}
#line 1558 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void update_regs___0(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                            Idx cur_node , Idx cur_idx , Idx nmatch ) 
{ 
  int type ;
  Idx reg_num ;
  Idx reg_num___0 ;

  {
#line 1563
  type = (int )(dfa->nodes + cur_node)->type;
#line 1564
  if (type == 8) {
#line 1566
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1569
    if (reg_num < nmatch) {
#line 1571
      (pmatch + reg_num)->rm_so = (regoff_t )cur_idx;
#line 1572
      (pmatch + reg_num)->rm_eo = (regoff_t )-1;
    }
  } else
#line 1575
  if (type == 9) {
#line 1577
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1578
    if (reg_num___0 < nmatch) {
#line 1581
      if ((Idx )(pmatch + reg_num___0)->rm_so < cur_idx) {
        {
#line 1583
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
#line 1586
        memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
               sizeof(regmatch_t ) * nmatch);
        }
      } else
#line 1590
      if ((dfa->nodes + cur_node)->opt_subexp) {
#line 1590
        if ((prev_idx_match + reg_num___0)->rm_so != -1L) {
          {
#line 1597
          memcpy((void */* __restrict  */)pmatch, (void const   */* __restrict  */)prev_idx_match,
                 sizeof(regmatch_t ) * nmatch);
          }
        } else {
#line 1601
          (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
        }
      } else {
#line 1601
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
      }
    }
  }
#line 1605
  return;
}
}
#line 1630 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sift_states_backward___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  int null_cnt ;
  Idx str_idx ;
  re_node_set cur_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1635
  null_cnt = 0;
#line 1636
  str_idx = sctx->last_str_idx;
#line 1645
  err = re_node_set_init_1___0(& cur_dest, sctx->last_node);
#line 1646
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1646
  if (tmp) {
#line 1647
    return (err);
  }
  {
#line 1648
  err = update_cur_sifted_state___0(mctx, sctx, str_idx, & cur_dest);
#line 1649
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1649
  if (tmp___0) {
#line 1650
    goto free_return;
  }
  {
#line 1653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1653
    if (! (str_idx > 0UL)) {
#line 1653
      goto while_break;
    }
#line 1656
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1656
      null_cnt ++;
    } else {
#line 1656
      null_cnt = 0;
    }
#line 1657
    if (null_cnt > (int )mctx->max_mb_elem_len) {
      {
#line 1659
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * str_idx);
#line 1661
      free((void *)cur_dest.elems);
      }
#line 1662
      return ((reg_errcode_t )0);
    }
#line 1664
    cur_dest.nelem = (Idx )0;
#line 1665
    str_idx --;
#line 1667
    if (*(mctx->state_log + str_idx)) {
      {
#line 1669
      err = build_sifted_states___0(mctx, sctx, str_idx, & cur_dest);
#line 1670
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1670
      if (tmp___1) {
#line 1671
        goto free_return;
      }
    }
    {
#line 1678
    err = update_cur_sifted_state___0(mctx, sctx, str_idx, & cur_dest);
#line 1679
    tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1679
    if (tmp___2) {
#line 1680
      goto free_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1682
  err = (reg_errcode_t )0;
  free_return: 
  {
#line 1684
  free((void *)cur_dest.elems);
  }
#line 1685
  return (err);
}
}
#line 1688 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t build_sifted_states___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  Idx i ;
  Idx prev_node ;
  int naccepted ;
  _Bool ok ;
  _Bool tmp ;
  Idx __attribute__((__pure__))  tmp___0 ;
  Idx to_idx ;
  _Bool tmp___1 ;
  long tmp___2 ;

  {
#line 1693
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1694
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1704
  i = (Idx )0;
  {
#line 1704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1704
    if (! (i < (Idx )cur_src->nelem)) {
#line 1704
      goto while_break;
    }
#line 1706
    prev_node = *(cur_src->elems + i);
#line 1707
    naccepted = 0;
#line 1716
    if ((dfa->nodes + prev_node)->accept_mb) {
      {
#line 1717
      naccepted = sift_states_iter_mb___0(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
      }
    }
#line 1723
    if (! naccepted) {
      {
#line 1723
      tmp = check_node_accept___0(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                                  str_idx);
      }
#line 1723
      if (tmp) {
#line 1723
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1UL)) != (unsigned long )((void *)0)) {
          {
#line 1723
          tmp___0 = re_node_set_contains___0((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1UL)))->nodes),
                                             *(dfa->nexts + prev_node));
          }
#line 1723
          if (tmp___0) {
#line 1727
            naccepted = 1;
          }
        }
      }
    }
#line 1729
    if (naccepted == 0) {
#line 1730
      goto __Cont;
    }
#line 1732
    if (sctx->limits.nelem) {
      {
#line 1734
      to_idx = str_idx + (Idx )naccepted;
#line 1735
      tmp___1 = check_dst_limits___0(mctx, (re_node_set const   *)(& sctx->limits),
                                     *(dfa->nexts + prev_node), to_idx, prev_node,
                                     str_idx);
      }
#line 1735
      if (tmp___1) {
#line 1738
        goto __Cont;
      }
    }
    {
#line 1740
    ok = re_node_set_insert___0(cur_dest, prev_node);
#line 1741
    tmp___2 = __builtin_expect((long )(! ok), 0L);
    }
#line 1741
    if (tmp___2) {
#line 1742
      return ((reg_errcode_t )12);
    }
    __Cont: /* CIL Label */ 
#line 1704
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  return ((reg_errcode_t )0);
}
}
#line 1750 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t clean_state_log_if_needed___0(re_match_context_t *mctx , Idx next_state_log_idx ) 
{ 
  Idx top ;
  reg_errcode_t err ;
  long tmp ;

  {
#line 1754
  top = mctx->state_log_top;
#line 1756
  if (next_state_log_idx >= mctx->input.bufs_len) {
#line 1756
    goto _L;
  } else
#line 1756
  if (next_state_log_idx >= mctx->input.valid_len) {
#line 1756
    if (mctx->input.valid_len < mctx->input.len) {
      _L: /* CIL Label */ 
      {
#line 1761
      err = extend_buffers___0(mctx);
#line 1762
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1762
      if (tmp) {
#line 1763
        return (err);
      }
    }
  }
#line 1766
  if (top < next_state_log_idx) {
    {
#line 1768
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (next_state_log_idx - top));
#line 1770
    mctx->state_log_top = next_state_log_idx;
    }
  }
#line 1772
  return ((reg_errcode_t )0);
}
}
#line 1775 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t merge_state_array___0(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                           re_dfastate_t **src , Idx num ) 
{ 
  Idx st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
#line 1782
  st_idx = (Idx )0;
  {
#line 1782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1782
    if (! (st_idx < num)) {
#line 1782
      goto while_break;
    }
#line 1784
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1785
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1786
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
#line 1789
      err = re_node_set_init_union___0(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                       (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1791
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1791
      if (tmp) {
#line 1792
        return (err);
      }
      {
#line 1793
      *(dst + st_idx) = re_acquire_state___0(& err, dfa, (re_node_set const   *)(& merged_set));
#line 1794
      free((void *)merged_set.elems);
#line 1795
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1795
      if (tmp___0) {
#line 1796
        return (err);
      }
    }
#line 1782
    st_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1799
  return ((reg_errcode_t )0);
}
}
#line 1802 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t update_cur_sifted_state___0(re_match_context_t const   *mctx ,
                                                 re_sift_context_t *sctx , Idx str_idx ,
                                                 re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1808
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1809
  err = (reg_errcode_t )0;
#line 1811
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1811
    candidates = (re_node_set const   *)((void *)0);
  } else {
#line 1811
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1814
  if (dest_nodes->nelem == 0UL) {
#line 1815
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1818
    if (candidates) {
      {
#line 1822
      err = add_epsilon_src_nodes___0(dfa, dest_nodes, candidates);
#line 1823
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1823
      if (tmp) {
#line 1824
        return (err);
      }
#line 1827
      if (sctx->limits.nelem) {
        {
#line 1829
        err = check_subexp_limits___0(dfa, dest_nodes, candidates, & sctx->limits,
                                      (struct re_backref_cache_entry *)mctx->bkref_ents,
                                      str_idx);
#line 1831
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1831
        if (tmp___0) {
#line 1832
          return (err);
        }
      }
    }
    {
#line 1836
    *(sctx->sifted_states + str_idx) = re_acquire_state___0(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1837
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1837
    if (tmp___1) {
#line 1838
      return (err);
    }
  }
#line 1841
  if (candidates) {
#line 1841
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
#line 1843
      err = sift_states_bkref___0(mctx, sctx, str_idx, candidates);
#line 1844
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1844
      if (tmp___2) {
#line 1845
        return (err);
      }
    }
  }
#line 1847
  return ((reg_errcode_t )0);
}
}
#line 1850 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t add_epsilon_src_nodes___0(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                               re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  re_dfastate_t *state___0 ;
  re_dfastate_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
  {
#line 1855
  err = (reg_errcode_t )0;
#line 1858
  tmp = re_acquire_state___0(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1858
  state___0 = tmp;
#line 1859
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1859
  if (tmp___0) {
#line 1860
    return (err);
  }
#line 1862
  if (! state___0->inveclosure.alloc) {
    {
#line 1864
    err = re_node_set_alloc___0(& state___0->inveclosure, dest_nodes->nelem);
#line 1865
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1865
    if (tmp___1) {
#line 1866
      return ((reg_errcode_t )12);
    }
#line 1867
    i = (Idx )0;
    {
#line 1867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1867
      if (! (i < dest_nodes->nelem)) {
#line 1867
        goto while_break;
      }
      {
#line 1868
      re_node_set_merge___0(& state___0->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
#line 1867
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1871
  tmp___2 = re_node_set_add_intersect___0(dest_nodes, candidates, (re_node_set const   *)(& state___0->inveclosure));
  }
#line 1871
  return (tmp___2);
}
}
#line 1875 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sub_epsilon_src_nodes___0(re_dfa_t const   *dfa , Idx node ,
                                               re_node_set *dest_nodes , re_node_set const   *candidates ) 
{ 
  Idx ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  Idx cur_node ;
  Idx edst1 ;
  Idx edst2 ;
  Idx tmp ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx __attribute__((__pure__))  tmp___3 ;
  Idx __attribute__((__pure__))  tmp___4 ;
  Idx cur_node___0 ;
  Idx idx ;
  Idx __attribute__((__pure__))  tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;

  {
  {
#line 1882
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
#line 1884
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1885
  ecl_idx = (Idx )0;
  }
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1885
      goto while_break;
    }
#line 1887
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1888
    if (cur_node == node) {
#line 1889
      goto __Cont;
    }
#line 1890
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
#line 1892
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1893
      if ((dfa->edests + cur_node)->nelem > 1UL) {
#line 1893
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
#line 1893
        tmp = (Idx )-1;
      }
      {
#line 1893
      edst2 = tmp;
#line 1895
      tmp___1 = re_node_set_contains___0((re_node_set const   *)inv_eclosure, edst1);
      }
#line 1895
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 1895
        if (edst2 - 1UL < 0xfffffffffffffffdUL) {
          {
#line 1895
          tmp___3 = re_node_set_contains___0((re_node_set const   *)inv_eclosure,
                                             edst2);
          }
#line 1895
          if (! tmp___3) {
            {
#line 1895
            tmp___4 = re_node_set_contains___0((re_node_set const   *)dest_nodes,
                                               edst2);
            }
#line 1895
            if (tmp___4) {
              _L: /* CIL Label */ 
              {
#line 1901
              err = re_node_set_add_intersect___0(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
#line 1903
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 1903
              if (tmp___0) {
                {
#line 1905
                free((void *)except_nodes.elems);
                }
#line 1906
                return (err);
              }
            }
          }
        }
      } else {
        {
#line 1895
        tmp___2 = re_node_set_contains___0((re_node_set const   *)dest_nodes, edst1);
        }
#line 1895
        if (tmp___2) {
#line 1895
          goto _L;
        } else {
#line 1895
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1885
    ecl_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1911
  ecl_idx = (Idx )0;
  {
#line 1911
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1911
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1911
      goto while_break___0;
    }
    {
#line 1913
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1914
    tmp___6 = re_node_set_contains___0((re_node_set const   *)(& except_nodes), cur_node___0);
    }
#line 1914
    if (! tmp___6) {
      {
#line 1916
      tmp___5 = re_node_set_contains___0((re_node_set const   *)dest_nodes, cur_node___0);
#line 1916
      idx = (Idx )(tmp___5 - (Idx __attribute__((__pure__))  )1);
#line 1917
      re_node_set_remove_at___0(dest_nodes, idx);
      }
    }
#line 1911
    ecl_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1920
  free((void *)except_nodes.elems);
  }
#line 1921
  return ((reg_errcode_t )0);
}
}
#line 1924 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_dst_limits___0(re_match_context_t const   *mctx , re_node_set const   *limits ,
                                  Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx lim_idx ;
  Idx src_pos ;
  Idx dst_pos ;
  Idx dst_bkref_idx ;
  Idx tmp ;
  Idx src_bkref_idx ;
  Idx tmp___0 ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1929
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1932
  tmp = search_cur_bkref_entry___0(mctx, dst_idx);
#line 1932
  dst_bkref_idx = tmp;
#line 1933
  tmp___0 = search_cur_bkref_entry___0(mctx, src_idx);
#line 1933
  src_bkref_idx = tmp___0;
#line 1934
  lim_idx = (Idx )0;
  }
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1934
    if (! (lim_idx < (Idx )limits->nelem)) {
#line 1934
      goto while_break;
    }
    {
#line 1938
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1939
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 1941
    tmp___1 = check_dst_limits_calc_pos___0(mctx, *(limits->elems + lim_idx), subexp_idx,
                                            dst_node, dst_idx, dst_bkref_idx);
#line 1941
    dst_pos = (Idx )tmp___1;
#line 1944
    tmp___2 = check_dst_limits_calc_pos___0(mctx, *(limits->elems + lim_idx), subexp_idx,
                                            src_node, src_idx, src_bkref_idx);
#line 1944
    src_pos = (Idx )tmp___2;
    }
#line 1952
    if (! (src_pos == dst_pos)) {
#line 1955
      return ((_Bool)1);
    }
#line 1934
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1957
  return ((_Bool)0);
}
}
#line 1960 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_dst_limits_calc_pos_1___0(re_match_context_t const   *mctx , int boundaries ,
                                           Idx subexp_idx , Idx from_node , Idx bkref_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  Idx node_idx ;
  Idx node ;
  struct re_backref_cache_entry *ent ;
  Idx dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp ;
  int tmp___0 ;

  {
#line 1965
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1966
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
#line 1971
  node_idx = (Idx )0;
  {
#line 1971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1971
    if (! (node_idx < (Idx )eclosures->nelem)) {
#line 1971
      goto while_break;
    }
#line 1973
    node = *(eclosures->elems + node_idx);
    {
#line 1976
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1976
      goto case_4;
    }
#line 2024
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2024
      goto case_8;
    }
#line 2029
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 2029
      goto case_9;
    }
#line 2034
    goto switch_default;
    case_4: /* CIL Label */ 
#line 1977
    if (bkref_idx != 0xffffffffffffffffUL) {
#line 1979
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
      {
#line 1980
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1985
        if (ent->node != node) {
#line 1986
          goto __Cont;
        }
#line 1988
        if (subexp_idx < 64UL) {
#line 1988
          if (! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1991
            goto __Cont;
          }
        }
#line 1999
        dst = *((dfa->edests + node)->elems + 0);
#line 2000
        if (dst == from_node) {
#line 2002
          if (boundaries & 1) {
#line 2003
            return (-1);
          } else {
#line 2005
            return (0);
          }
        }
        {
#line 2008
        cpos = check_dst_limits_calc_pos_1___0(mctx, boundaries, subexp_idx, dst,
                                               bkref_idx);
        }
#line 2011
        if (cpos == -1) {
#line 2012
          return (-1);
        }
#line 2013
        if (cpos == 0) {
#line 2013
          if (boundaries & 2) {
#line 2014
            return (0);
          }
        }
#line 2016
        if (subexp_idx < 64UL) {
#line 2017
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: /* CIL Label */ 
#line 1980
        tmp = ent;
#line 1980
        ent ++;
#line 1980
        if (! tmp->more) {
#line 1980
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2022
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2025
    if (boundaries & 1) {
#line 2025
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2026
        return (-1);
      }
    }
#line 2027
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2030
    if (boundaries & 2) {
#line 2030
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2031
        return (0);
      }
    }
#line 2032
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2035
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1971
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2039
  if (boundaries & 2) {
#line 2039
    tmp___0 = 1;
  } else {
#line 2039
    tmp___0 = 0;
  }
#line 2039
  return (tmp___0);
}
}
#line 2042 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_dst_limits_calc_pos___0(re_match_context_t const   *mctx , Idx limit ,
                                         Idx subexp_idx , Idx from_node , Idx str_idx ,
                                         Idx bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp ;

  {
#line 2048
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 2052
  if (str_idx < lim->subexp_from) {
#line 2053
    return (-1);
  }
#line 2055
  if (lim->subexp_to < str_idx) {
#line 2056
    return (1);
  }
#line 2059
  boundaries = str_idx == lim->subexp_from;
#line 2060
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 2061
  if (boundaries == 0) {
#line 2062
    return (0);
  }
  {
#line 2065
  tmp = check_dst_limits_calc_pos_1___0(mctx, boundaries, subexp_idx, from_node, bkref_idx);
  }
#line 2065
  return (tmp);
}
}
#line 2072 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_subexp_limits___0(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                             re_node_set const   *candidates , re_node_set *limits ,
                                             struct re_backref_cache_entry *bkref_ents ,
                                             Idx str_idx ) 
{ 
  reg_errcode_t err ;
  Idx node_idx ;
  Idx lim_idx ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  Idx ops_node ;
  Idx cls_node ;
  Idx node ;
  re_token_type_t type ;
  long tmp ;
  Idx node___0 ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
#line 2081
  lim_idx = (Idx )0;
  {
#line 2081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2081
    if (! (lim_idx < limits->nelem)) {
#line 2081
      goto while_break;
    }
#line 2085
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2087
    if (str_idx <= ent->subexp_from) {
#line 2088
      goto __Cont;
    } else
#line 2087
    if (ent->str_idx < str_idx) {
#line 2088
      goto __Cont;
    }
#line 2090
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 2091
    if (ent->subexp_to == str_idx) {
#line 2093
      ops_node = (Idx )-1;
#line 2094
      cls_node = (Idx )-1;
#line 2095
      node_idx = (Idx )0;
      {
#line 2095
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2095
        if (! (node_idx < dest_nodes->nelem)) {
#line 2095
          goto while_break___0;
        }
#line 2097
        node = *(dest_nodes->elems + node_idx);
#line 2098
        type = (dfa->nodes + node)->type;
#line 2099
        if ((unsigned int )type == 8U) {
#line 2099
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2101
            ops_node = node;
          } else {
#line 2099
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2102
        if ((unsigned int )type == 9U) {
#line 2102
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2104
            cls_node = node;
          }
        }
#line 2095
        node_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2109
      if (ops_node < 0xfffffffffffffffeUL) {
        {
#line 2111
        err = sub_epsilon_src_nodes___0(dfa, ops_node, dest_nodes, candidates);
#line 2113
        tmp = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2113
        if (tmp) {
#line 2114
          return (err);
        }
      }
#line 2118
      if (cls_node < 0xfffffffffffffffeUL) {
#line 2119
        node_idx = (Idx )0;
        {
#line 2119
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2119
          if (! (node_idx < dest_nodes->nelem)) {
#line 2119
            goto while_break___1;
          }
          {
#line 2121
          node___0 = *(dest_nodes->elems + node_idx);
#line 2122
          tmp___1 = re_node_set_contains___0((re_node_set const   *)(dfa->inveclosures + node___0),
                                             cls_node);
          }
#line 2122
          if (! tmp___1) {
            {
#line 2122
            tmp___2 = re_node_set_contains___0((re_node_set const   *)(dfa->eclosures + node___0),
                                               cls_node);
            }
#line 2122
            if (! tmp___2) {
              {
#line 2129
              err = sub_epsilon_src_nodes___0(dfa, node___0, dest_nodes, candidates);
#line 2131
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 2131
              if (tmp___0) {
#line 2132
                return (err);
              }
#line 2133
              node_idx --;
            }
          }
#line 2119
          node_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 2139
      node_idx = (Idx )0;
      {
#line 2139
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2139
        if (! (node_idx < dest_nodes->nelem)) {
#line 2139
          goto while_break___2;
        }
#line 2141
        node___1 = *(dest_nodes->elems + node_idx);
#line 2142
        type___0 = (dfa->nodes + node___1)->type;
#line 2143
        if ((unsigned int )type___0 == 9U) {
#line 2143
          goto _L___0;
        } else
#line 2143
        if ((unsigned int )type___0 == 8U) {
          _L___0: /* CIL Label */ 
#line 2145
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 2146
            goto __Cont___0;
          }
          {
#line 2149
          err = sub_epsilon_src_nodes___0(dfa, node___1, dest_nodes, candidates);
#line 2151
          tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2151
          if (tmp___3) {
#line 2152
            return (err);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 2139
        node_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2081
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2157
  return ((reg_errcode_t )0);
}
}
#line 2160 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t sift_states_bkref___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                           Idx str_idx , re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx node_idx ;
  Idx node ;
  re_sift_context_t local_sctx ;
  Idx first_idx ;
  Idx tmp ;
  Idx enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  Idx subexp_len ;
  Idx to_idx ;
  Idx dst_node ;
  _Bool ok ;
  re_dfastate_t *cur_state ;
  Idx __attribute__((__pure__))  tmp___0 ;
  _Bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  struct re_backref_cache_entry *tmp___7 ;

  {
  {
#line 2165
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2169
  tmp = search_cur_bkref_entry___0(mctx, str_idx);
#line 2169
  first_idx = tmp;
  }
#line 2171
  if (first_idx == 0xffffffffffffffffUL) {
#line 2172
    return ((reg_errcode_t )0);
  }
#line 2174
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2176
  node_idx = (Idx )0;
  {
#line 2176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2176
    if (! (node_idx < (Idx )candidates->nelem)) {
#line 2176
      goto while_break;
    }
#line 2181
    node = *(candidates->elems + node_idx);
#line 2182
    type = (dfa->nodes + node)->type;
#line 2184
    if (node == sctx->last_node) {
#line 2184
      if (str_idx == sctx->last_str_idx) {
#line 2185
        goto __Cont;
      }
    }
#line 2186
    if ((unsigned int )type != 4U) {
#line 2187
      goto __Cont;
    }
#line 2189
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2190
    enabled_idx = first_idx;
    {
#line 2191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2199
      if (entry->node != node) {
#line 2200
        goto __Cont___0;
      }
#line 2201
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2202
      to_idx = str_idx + subexp_len;
#line 2203
      if (subexp_len) {
#line 2203
        dst_node = *(dfa->nexts + node);
      } else {
#line 2203
        dst_node = *((dfa->edests + node)->elems + 0);
      }
#line 2206
      if (to_idx > sctx->last_str_idx) {
#line 2211
        goto __Cont___0;
      } else
#line 2206
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 2211
        goto __Cont___0;
      } else
#line 2206
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
        {
#line 2206
        tmp___0 = re_node_set_contains___0((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                           dst_node);
        }
#line 2206
        if (tmp___0) {
          {
#line 2206
          tmp___1 = check_dst_limits___0(mctx, (re_node_set const   *)(& sctx->limits),
                                         node, str_idx, dst_node, to_idx);
          }
#line 2206
          if (tmp___1) {
#line 2211
            goto __Cont___0;
          }
        } else {
#line 2211
          goto __Cont___0;
        }
      } else {
#line 2211
        goto __Cont___0;
      }
#line 2213
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
        {
#line 2215
        local_sctx = *sctx;
#line 2216
        err = re_node_set_init_copy___0(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2217
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2217
        if (tmp___2) {
#line 2218
          goto free_return;
        }
      }
      {
#line 2220
      local_sctx.last_node = node;
#line 2221
      local_sctx.last_str_idx = str_idx;
#line 2222
      ok = re_node_set_insert___0(& local_sctx.limits, enabled_idx);
#line 2223
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 2223
      if (tmp___3) {
#line 2225
        err = (reg_errcode_t )12;
#line 2226
        goto free_return;
      }
      {
#line 2228
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2229
      err = sift_states_backward___0(mctx, & local_sctx);
#line 2230
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2230
      if (tmp___4) {
#line 2231
        goto free_return;
      }
#line 2232
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
        {
#line 2234
        err = merge_state_array___0(dfa, sctx->limited_states, local_sctx.sifted_states,
                                    str_idx + 1UL);
#line 2237
        tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2237
        if (tmp___5) {
#line 2238
          goto free_return;
        }
      }
      {
#line 2240
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2241
      tmp___6 = re_node_set_contains___0((re_node_set const   *)(& local_sctx.limits),
                                         enabled_idx);
#line 2241
      re_node_set_remove_at___0(& local_sctx.limits, (Idx )(tmp___6 - (Idx __attribute__((__pure__))  )1));
#line 2244
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      }
      __Cont___0: /* CIL Label */ 
#line 2191
      enabled_idx ++;
#line 2191
      tmp___7 = entry;
#line 2191
      entry ++;
#line 2191
      if (! tmp___7->more) {
#line 2191
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2176
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2248
  err = (reg_errcode_t )0;
  free_return: 
#line 2250
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
#line 2252
    free((void *)local_sctx.limits.elems);
    }
  }
#line 2255
  return (err);
}
}
#line 2260 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int sift_states_iter_mb___0(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                   Idx node_idx , Idx str_idx , Idx max_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int naccepted ;
  Idx __attribute__((__pure__))  tmp ;

  {
  {
#line 2265
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2268
  naccepted = check_node_accept_bytes___0(dfa, node_idx, & mctx->input, str_idx);
  }
#line 2269
  if (naccepted > 0) {
#line 2269
    if (str_idx + (Idx )naccepted <= max_str_idx) {
#line 2269
      if ((unsigned long )*(sctx->sifted_states + (str_idx + (Idx )naccepted)) != (unsigned long )((void *)0)) {
        {
#line 2269
        tmp = re_node_set_contains___0((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + (Idx )naccepted)))->nodes),
                                       *(dfa->nexts + node_idx));
        }
#line 2269
        if (! tmp) {
#line 2275
          naccepted = 0;
        }
      } else {
#line 2275
        naccepted = 0;
      }
    }
  }
#line 2278
  return (naccepted);
}
}
#line 2290 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *transit_state___0(reg_errcode_t *err , re_match_context_t *mctx ,
                                        re_dfastate_t *state___0 ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  long tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  long tmp___2 ;
  unsigned int context ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 2300
  tmp___0 = __builtin_expect((long )state___0->accept_mb, 0L);
  }
#line 2300
  if (tmp___0) {
    {
#line 2302
    *err = transit_state_mb___0(mctx, state___0);
#line 2303
    tmp = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2303
    if (tmp) {
#line 2304
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2316
  tmp___1 = mctx->input.cur_idx;
#line 2316
  (mctx->input.cur_idx) ++;
#line 2316
  ch = *(mctx->input.mbs + tmp___1);
  {
#line 2317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2319
    trtable = state___0->trtable;
#line 2320
    tmp___2 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2320
    if (tmp___2) {
#line 2321
      return (*(trtable + ch));
    }
    {
#line 2323
    trtable = state___0->word_trtable;
#line 2324
    tmp___3 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2324
    if (tmp___3) {
      {
#line 2327
      context = re_string_context_at___0((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                         mctx->eflags);
      }
#line 2331
      if (context & 1U) {
#line 2332
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2334
        return (*(trtable + ch));
      }
    }
    {
#line 2337
    tmp___4 = build_trtable___0(mctx->dfa, state___0);
    }
#line 2337
    if (! tmp___4) {
#line 2339
      *err = (reg_errcode_t )12;
#line 2340
      return ((re_dfastate_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2348 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *merge_state_with_log___0(reg_errcode_t *err , re_match_context_t *mctx ,
                                               re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa ;
  Idx cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp ;
  re_dfastate_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2353
  dfa = mctx->dfa;
#line 2354
  cur_idx = mctx->input.cur_idx;
#line 2356
  if (cur_idx > mctx->state_log_top) {
#line 2358
    *(mctx->state_log + cur_idx) = next_state;
#line 2359
    mctx->state_log_top = cur_idx;
  } else
#line 2361
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2363
    *(mctx->state_log + cur_idx) = next_state;
  } else {
#line 2369
    table_nodes = (re_node_set *)((void *)0);
#line 2374
    pstate = *(mctx->state_log + cur_idx);
#line 2375
    log_nodes = pstate->entrance_nodes;
#line 2376
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2378
      table_nodes = next_state->entrance_nodes;
#line 2379
      *err = re_node_set_init_union___0(& next_nodes, (re_node_set const   *)table_nodes,
                                        (re_node_set const   *)log_nodes);
#line 2381
      tmp = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2381
      if (tmp) {
#line 2382
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2385
      next_nodes = *log_nodes;
    }
    {
#line 2389
    context = re_string_context_at___0((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                       mctx->eflags);
#line 2392
    tmp___0 = re_acquire_state_context___0(err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
#line 2392
    *(mctx->state_log + cur_idx) = tmp___0;
#line 2392
    next_state = tmp___0;
    }
#line 2397
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
      {
#line 2398
      free((void *)next_nodes.elems);
      }
    }
  }
  {
#line 2401
  tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
  }
#line 2401
  if (tmp___3) {
#line 2401
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2406
      *err = check_subexp_matching_top___0(mctx, & next_state->nodes, cur_idx);
#line 2408
      tmp___1 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2408
      if (tmp___1) {
#line 2409
        return ((re_dfastate_t *)((void *)0));
      }
#line 2412
      if (next_state->has_backref) {
        {
#line 2414
        *err = transit_state_bkref___0(mctx, (re_node_set const   *)(& next_state->nodes));
#line 2415
        tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
        }
#line 2415
        if (tmp___2) {
#line 2416
          return ((re_dfastate_t *)((void *)0));
        }
#line 2417
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
#line 2421
  return (next_state);
}
}
#line 2427 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_dfastate_t *find_recover_state___0(reg_errcode_t *err , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  Idx max ;
  Idx cur_str_idx ;

  {
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2434
    max = mctx->state_log_top;
#line 2435
    cur_str_idx = mctx->input.cur_idx;
    {
#line 2437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2439
      cur_str_idx ++;
#line 2439
      if (cur_str_idx > max) {
#line 2440
        return ((re_dfastate_t *)((void *)0));
      }
#line 2441
      (mctx->input.cur_idx) ++;
#line 2437
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
#line 2437
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2445
    cur_state = merge_state_with_log___0(err, mctx, (re_dfastate_t *)((void *)0));
    }
#line 2432
    if ((int )*err == 0) {
#line 2432
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
#line 2432
        goto while_break;
      }
    } else {
#line 2432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2448
  return (cur_state);
}
}
#line 2458 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_subexp_matching_top___0(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                                   Idx str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx node_idx ;
  reg_errcode_t err ;
  Idx node ;
  long tmp ;

  {
#line 2463
  dfa = mctx->dfa;
#line 2472
  node_idx = (Idx )0;
  {
#line 2472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2472
    if (! (node_idx < cur_nodes->nelem)) {
#line 2472
      goto while_break;
    }
#line 2474
    node = *(cur_nodes->elems + node_idx);
#line 2475
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2475
      if ((dfa->nodes + node)->opr.idx < 64UL) {
#line 2475
        if (dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
          {
#line 2480
          err = match_ctx_add_subtop___0(mctx, node, str_idx);
#line 2481
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2481
          if (tmp) {
#line 2482
            return (err);
          }
        }
      }
    }
#line 2472
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2485
  return ((reg_errcode_t )0);
}
}
#line 2531 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t transit_state_mb___0(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  Idx cur_node_idx ;
  int naccepted ;
  Idx dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2535
  dfa = mctx->dfa;
#line 2539
  i = (Idx )0;
  {
#line 2539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2539
    if (! (i < pstate->nodes.nelem)) {
#line 2539
      goto while_break;
    }
#line 2542
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2548
    if (! (dfa->nodes + cur_node_idx)->accept_mb) {
#line 2549
      goto __Cont;
    }
#line 2551
    if ((dfa->nodes + cur_node_idx)->constraint) {
      {
#line 2553
      context = re_string_context_at___0((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                         mctx->eflags);
      }
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 4U) {
#line 2556
        if (! (context & 1U)) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 8U) {
#line 2556
        if (context & 1U) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 32U) {
#line 2556
        if (! (context & (unsigned int )(1 << 1))) {
#line 2558
          goto __Cont;
        } else {
#line 2556
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2556
      if ((dfa->nodes + cur_node_idx)->constraint & 128U) {
#line 2556
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2558
          goto __Cont;
        }
      }
    }
    {
#line 2562
    naccepted = check_node_accept_bytes___0(dfa, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                            mctx->input.cur_idx);
    }
#line 2564
    if (naccepted == 0) {
#line 2565
      goto __Cont;
    }
#line 2568
    dest_idx = mctx->input.cur_idx + (Idx )naccepted;
#line 2569
    if (mctx->max_mb_elem_len < naccepted) {
#line 2569
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2569
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
    {
#line 2571
    err = clean_state_log_if_needed___0(mctx, dest_idx);
#line 2572
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2572
    if (tmp) {
#line 2573
      return (err);
    }
#line 2577
    new_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + cur_node_idx));
#line 2579
    dest_state = *(mctx->state_log + dest_idx);
#line 2580
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2581
      dest_nodes = *new_nodes;
    } else {
      {
#line 2584
      err = re_node_set_init_union___0(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                       (re_node_set const   *)new_nodes);
#line 2586
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2586
      if (tmp___0) {
#line 2587
        return (err);
      }
    }
    {
#line 2589
    context = re_string_context_at___0((re_string_t const   *)(& mctx->input), dest_idx - 1UL,
                                       mctx->eflags);
#line 2591
    *(mctx->state_log + dest_idx) = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                 context);
    }
#line 2593
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
      {
#line 2594
      free((void *)dest_nodes.elems);
      }
    }
#line 2595
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2595
      if ((int )err != 0) {
#line 2595
        tmp___1 = 1;
      } else {
#line 2595
        tmp___1 = 0;
      }
    } else {
#line 2595
      tmp___1 = 0;
    }
    {
#line 2595
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2595
    if (tmp___2) {
#line 2596
      return (err);
    }
    __Cont: /* CIL Label */ 
#line 2539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2598
  return ((reg_errcode_t )0);
}
}
#line 2602 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t transit_state_bkref___0(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  Idx cur_str_idx ;
  Idx dest_str_idx ;
  Idx prev_nelem ;
  Idx bkc_idx ;
  Idx node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  Idx subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2606
  dfa = mctx->dfa;
#line 2609
  cur_str_idx = mctx->input.cur_idx;
#line 2611
  i = (Idx )0;
  {
#line 2611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2611
    if (! (i < (Idx )nodes->nelem)) {
#line 2611
      goto while_break;
    }
#line 2614
    node_idx = *(nodes->elems + i);
#line 2616
    node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 2620
    if ((unsigned int const   )node->type != 4U) {
#line 2621
      goto __Cont;
    }
#line 2623
    if (node->constraint) {
      {
#line 2625
      context = re_string_context_at___0((re_string_t const   *)(& mctx->input), cur_str_idx,
                                         mctx->eflags);
      }
#line 2627
      if (node->constraint & 4U) {
#line 2627
        if (! (context & 1U)) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2627
      if (node->constraint & 8U) {
#line 2627
        if (context & 1U) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2627
      if (node->constraint & 32U) {
#line 2627
        if (! (context & (unsigned int )(1 << 1))) {
#line 2628
          goto __Cont;
        } else {
#line 2627
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2627
      if (node->constraint & 128U) {
#line 2627
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2628
          goto __Cont;
        }
      }
    }
    {
#line 2633
    bkc_idx = mctx->nbkref_ents;
#line 2634
    err = get_subexp___0(mctx, node_idx, cur_str_idx);
#line 2635
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2635
    if (tmp) {
#line 2636
      goto free_return;
    }
    {
#line 2643
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2643
      if (! (bkc_idx < mctx->nbkref_ents)) {
#line 2643
        goto while_break___0;
      }
#line 2648
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2649
      if (bkref_ent->node != node_idx) {
#line 2650
        goto __Cont___0;
      } else
#line 2649
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2650
        goto __Cont___0;
      }
#line 2651
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2652
      if (subexp_len == 0UL) {
#line 2652
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *((dfa->edests + node_idx)->elems + 0));
      } else {
#line 2652
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + node_idx));
      }
      {
#line 2655
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2657
      context = re_string_context_at___0((re_string_t const   *)(& mctx->input), dest_str_idx - 1UL,
                                         mctx->eflags);
#line 2659
      dest_state = *(mctx->state_log + dest_str_idx);
      }
#line 2660
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2660
        prev_nelem = (Idx )0;
      } else {
#line 2660
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2663
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
#line 2665
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context___0(& err, dfa,
                                                                         (re_node_set const   *)new_dest_nodes,
                                                                         context);
        }
#line 2668
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2668
          if ((int )err != 0) {
#line 2668
            tmp___0 = 1;
          } else {
#line 2668
            tmp___0 = 0;
          }
        } else {
#line 2668
          tmp___0 = 0;
        }
        {
#line 2668
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        }
#line 2668
        if (tmp___1) {
#line 2670
          goto free_return;
        }
      } else {
        {
#line 2675
        err = re_node_set_init_union___0(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                         (re_node_set const   *)new_dest_nodes);
#line 2678
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2678
        if (tmp___2) {
          {
#line 2680
          free((void *)dest_nodes.elems);
          }
#line 2681
          goto free_return;
        }
        {
#line 2683
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context___0(& err, dfa,
                                                                         (re_node_set const   *)(& dest_nodes),
                                                                         context);
#line 2685
        free((void *)dest_nodes.elems);
        }
#line 2686
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2686
          if ((int )err != 0) {
#line 2686
            tmp___3 = 1;
          } else {
#line 2686
            tmp___3 = 0;
          }
        } else {
#line 2686
          tmp___3 = 0;
        }
        {
#line 2686
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
#line 2686
        if (tmp___4) {
#line 2688
          goto free_return;
        }
      }
#line 2692
      if (subexp_len == 0UL) {
#line 2692
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
#line 2695
          err = check_subexp_matching_top___0(mctx, new_dest_nodes, cur_str_idx);
#line 2697
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2697
          if (tmp___5) {
#line 2698
            goto free_return;
          }
          {
#line 2699
          err = transit_state_bkref___0(mctx, (re_node_set const   *)new_dest_nodes);
#line 2700
          tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2700
          if (tmp___6) {
#line 2701
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2643
      bkc_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2705
  err = (reg_errcode_t )0;
  free_return: 
#line 2707
  return (err);
}
}
#line 2716 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t get_subexp___0(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx subexp_num ;
  Idx sub_top_idx ;
  char const   *buf___1 ;
  Idx cache_idx ;
  Idx tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  Idx sub_last_idx ;
  Idx sl_str ;
  Idx bkref_str_off ;
  regoff_t sl_str_diff ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  Idx cls_node ;
  regoff_t sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___5 ;
  long tmp___6 ;
  Idx tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 2720
  dfa = mctx->dfa;
#line 2722
  buf___1 = (char const   *)mctx->input.mbs;
#line 2724
  tmp = search_cur_bkref_entry___0((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2724
  cache_idx = tmp;
  }
#line 2725
  if (cache_idx != 0xffffffffffffffffUL) {
#line 2727
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
    {
#line 2729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2730
      if (entry->node == (Idx const   )bkref_node) {
#line 2731
        return ((reg_errcode_t )0);
      }
#line 2729
      tmp___0 = entry;
#line 2729
      entry ++;
#line 2729
      if (! tmp___0->more) {
#line 2729
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2735
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
#line 2738
  sub_top_idx = (Idx )0;
  {
#line 2738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2738
    if (! (sub_top_idx < mctx->nsub_tops)) {
#line 2738
      goto while_break___0;
    }
#line 2741
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2745
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2746
      goto __Cont;
    }
#line 2748
    sl_str = sub_top->str_idx;
#line 2749
    bkref_str_off = bkref_str_idx;
#line 2752
    sub_last_idx = (Idx )0;
    {
#line 2752
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2752
      if (! (sub_last_idx < sub_top->nlasts)) {
#line 2752
        goto while_break___1;
      }
#line 2755
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2756
      sl_str_diff = (regoff_t )(sub_last->str_idx - sl_str);
#line 2759
      if (sl_str_diff > 0L) {
        {
#line 2761
        tmp___2 = __builtin_expect((long )(bkref_str_off + (Idx )sl_str_diff > mctx->input.valid_len),
                                   0L);
        }
#line 2761
        if (tmp___2) {
#line 2764
          if (bkref_str_off + (Idx )sl_str_diff > mctx->input.len) {
#line 2765
            goto while_break___1;
          }
          {
#line 2767
          err = clean_state_log_if_needed___0(mctx, bkref_str_off + (Idx )sl_str_diff);
#line 2770
          tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2770
          if (tmp___1) {
#line 2771
            return (err);
          }
#line 2772
          buf___1 = (char const   *)mctx->input.mbs;
        }
        {
#line 2774
        tmp___3 = memcmp((void const   *)(buf___1 + bkref_str_off), (void const   *)(buf___1 + sl_str),
                         (size_t )sl_str_diff);
        }
#line 2774
        if (tmp___3 != 0) {
#line 2776
          goto while_break___1;
        }
      }
      {
#line 2778
      bkref_str_off += (Idx )sl_str_diff;
#line 2779
      sl_str += (Idx )sl_str_diff;
#line 2780
      err = get_subexp_sub___0(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                               bkref_node, bkref_str_idx);
#line 2785
      buf___1 = (char const   *)mctx->input.mbs;
      }
#line 2787
      if ((int )err == 1) {
#line 2788
        goto __Cont___0;
      }
      {
#line 2789
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2789
      if (tmp___4) {
#line 2790
        return (err);
      }
      __Cont___0: /* CIL Label */ 
#line 2752
      sub_last_idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2793
    if (sub_last_idx < sub_top->nlasts) {
#line 2794
      goto __Cont;
    }
#line 2795
    if (sub_last_idx > 0UL) {
#line 2796
      sl_str ++;
    }
    {
#line 2798
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2798
      if (! (sl_str <= bkref_str_idx)) {
#line 2798
        goto while_break___2;
      }
#line 2803
      sl_str_off = (regoff_t )(sl_str - sub_top->str_idx);
#line 2806
      if (sl_str_off > 0L) {
        {
#line 2808
        tmp___6 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
        }
#line 2808
        if (tmp___6) {
#line 2811
          if (bkref_str_off >= mctx->input.len) {
#line 2812
            goto while_break___2;
          }
          {
#line 2814
          err = extend_buffers___0(mctx);
#line 2815
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2815
          if (tmp___5) {
#line 2816
            return (err);
          }
#line 2818
          buf___1 = (char const   *)mctx->input.mbs;
        }
#line 2820
        tmp___7 = bkref_str_off;
#line 2820
        bkref_str_off ++;
#line 2820
        if ((int const   )*(buf___1 + tmp___7) != (int const   )*(buf___1 + (sl_str - 1UL))) {
#line 2821
          goto while_break___2;
        }
      }
#line 2824
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2825
        goto __Cont___1;
      }
      {
#line 2827
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2828
      cls_node = find_subexp_node___0(dfa, nodes, subexp_num, 9);
      }
#line 2830
      if (cls_node == 0xffffffffffffffffUL) {
#line 2831
        goto __Cont___1;
      }
#line 2832
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
#line 2834
        tmp___8 = calloc(sizeof(state_array_t ), (sl_str - sub_top->str_idx) + 1UL);
#line 2834
        sub_top->path = (state_array_t *)tmp___8;
        }
#line 2836
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2837
          return ((reg_errcode_t )12);
        }
      }
      {
#line 2841
      err = check_arrival___0(mctx, sub_top->path, sub_top->node, sub_top->str_idx,
                              cls_node, sl_str, 9);
      }
#line 2844
      if ((int )err == 1) {
#line 2845
        goto __Cont___1;
      }
      {
#line 2846
      tmp___9 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2846
      if (tmp___9) {
#line 2847
        return (err);
      }
      {
#line 2848
      sub_last = match_ctx_add_sublast___0(sub_top, cls_node, sl_str);
#line 2849
      tmp___10 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2849
      if (tmp___10) {
#line 2850
        return ((reg_errcode_t )12);
      }
      {
#line 2851
      err = get_subexp_sub___0(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                               bkref_node, bkref_str_idx);
      }
#line 2853
      if ((int )err == 1) {

      }
      __Cont___1: /* CIL Label */ 
#line 2798
      sl_str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2738
    sub_top_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2857
  return ((reg_errcode_t )0);
}
}
#line 2866 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t get_subexp_sub___0(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                        re_sub_match_last_t *sub_last , Idx bkref_node ,
                                        Idx bkref_str ) 
{ 
  reg_errcode_t err ;
  Idx to_idx ;
  long tmp ;
  reg_errcode_t tmp___0 ;

  {
  {
#line 2874
  err = check_arrival___0(mctx, & sub_last->path, sub_last->node, sub_last->str_idx,
                          bkref_node, bkref_str, 8);
  }
#line 2877
  if ((int )err != 0) {
#line 2878
    return (err);
  }
  {
#line 2879
  err = match_ctx_add_entry___0(mctx, bkref_node, bkref_str, (Idx )sub_top->str_idx,
                                sub_last->str_idx);
#line 2881
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 2881
  if (tmp) {
#line 2882
    return (err);
  }
  {
#line 2883
  to_idx = (bkref_str + sub_last->str_idx) - (Idx )sub_top->str_idx;
#line 2884
  tmp___0 = clean_state_log_if_needed___0(mctx, to_idx);
  }
#line 2884
  return (tmp___0);
}
}
#line 2895 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx find_subexp_node___0(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                Idx subexp_idx , int type ) 
{ 
  Idx cls_idx ;
  Idx cls_node ;
  re_token_t const   *node ;

  {
#line 2901
  cls_idx = (Idx )0;
  {
#line 2901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2901
    if (! (cls_idx < (Idx )nodes->nelem)) {
#line 2901
      goto while_break;
    }
#line 2903
    cls_node = *(nodes->elems + cls_idx);
#line 2904
    node = (re_token_t const   *)(dfa->nodes + cls_node);
#line 2905
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
#line 2905
      if (node->opr.idx == (Idx const   )subexp_idx) {
#line 2907
        return (cls_node);
      }
    }
#line 2901
    cls_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2909
  return ((Idx )-1);
}
}
#line 2917 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival___0(re_match_context_t *mctx , state_array_t *path ,
                                       Idx top_node , Idx top_str , Idx last_node ,
                                       Idx last_str , int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx subexp_num ;
  Idx backup_cur_idx ;
  Idx str_idx ;
  Idx null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  Idx old_alloc ;
  Idx new_alloc ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  Idx __attribute__((__pure__))  tmp___16 ;

  {
  {
#line 2922
  dfa = mctx->dfa;
#line 2923
  err = (reg_errcode_t )0;
#line 2925
  cur_state = (re_dfastate_t *)((void *)0);
#line 2930
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2932
  tmp___3 = __builtin_expect((long )(path->alloc < (last_str + (Idx )mctx->max_mb_elem_len) + 1UL),
                             0L);
  }
#line 2932
  if (tmp___3) {
    {
#line 2935
    old_alloc = path->alloc;
#line 2936
    new_alloc = ((old_alloc + last_str) + (Idx )mctx->max_mb_elem_len) + 1UL;
#line 2937
    tmp = __builtin_expect((long )(new_alloc < old_alloc), 0L);
    }
#line 2937
    if (tmp) {
#line 2939
      return ((reg_errcode_t )12);
    } else {
      {
#line 2937
      tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) < new_alloc),
                                 0L);
      }
#line 2937
      if (tmp___0) {
#line 2939
        return ((reg_errcode_t )12);
      }
    }
    {
#line 2940
    tmp___1 = realloc((void *)path->array, new_alloc * sizeof(re_dfastate_t *));
#line 2940
    new_array = (re_dfastate_t **)tmp___1;
#line 2941
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 2941
    if (tmp___2) {
#line 2942
      return ((reg_errcode_t )12);
    }
    {
#line 2943
    path->array = new_array;
#line 2944
    path->alloc = new_alloc;
#line 2945
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (path->alloc - old_alloc));
    }
  }
#line 2949
  if (path->next_idx) {
#line 2949
    str_idx = path->next_idx;
  } else {
#line 2949
    str_idx = top_str;
  }
  {
#line 2952
  backup_state_log = mctx->state_log;
#line 2953
  backup_cur_idx = mctx->input.cur_idx;
#line 2954
  mctx->state_log = path->array;
#line 2955
  mctx->input.cur_idx = str_idx;
#line 2958
  context = re_string_context_at___0((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                     mctx->eflags);
  }
#line 2959
  if (str_idx == top_str) {
    {
#line 2961
    err = re_node_set_init_1___0(& next_nodes, top_node);
#line 2962
    tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2962
    if (tmp___4) {
#line 2963
      return (err);
    }
    {
#line 2964
    err = check_arrival_expand_ecl___0(dfa, & next_nodes, subexp_num, type);
#line 2965
    tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2965
    if (tmp___5) {
      {
#line 2967
      free((void *)next_nodes.elems);
      }
#line 2968
      return (err);
    }
  } else {
#line 2973
    cur_state = *(mctx->state_log + str_idx);
#line 2974
    if (cur_state) {
#line 2974
      if (cur_state->has_backref) {
        {
#line 2976
        err = re_node_set_init_copy___0(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2977
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2977
        if (tmp___6) {
#line 2978
          return (err);
        }
      } else {
        {
#line 2981
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 2981
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    }
  }
#line 2983
  if (str_idx == top_str) {
#line 2983
    goto _L;
  } else
#line 2983
  if (cur_state) {
#line 2983
    if (cur_state->has_backref) {
      _L: /* CIL Label */ 
#line 2985
      if (next_nodes.nelem) {
        {
#line 2987
        err = expand_bkref_cache___0(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2989
        tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2989
        if (tmp___7) {
          {
#line 2991
          free((void *)next_nodes.elems);
          }
#line 2992
          return (err);
        }
      }
      {
#line 2995
      cur_state = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& next_nodes),
                                               context);
      }
#line 2996
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2996
        if ((int )err != 0) {
#line 2996
          tmp___8 = 1;
        } else {
#line 2996
          tmp___8 = 0;
        }
      } else {
#line 2996
        tmp___8 = 0;
      }
      {
#line 2996
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
#line 2996
      if (tmp___9) {
        {
#line 2998
        free((void *)next_nodes.elems);
        }
#line 2999
        return (err);
      }
#line 3001
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 3004
  null_cnt = (Idx )0;
  {
#line 3004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3004
    if (str_idx < last_str) {
#line 3004
      if (! (null_cnt <= (Idx )mctx->max_mb_elem_len)) {
#line 3004
        goto while_break;
      }
    } else {
#line 3004
      goto while_break;
    }
#line 3006
    next_nodes.nelem = (Idx )0;
#line 3007
    if (*(mctx->state_log + (str_idx + 1UL))) {
      {
#line 3009
      err = re_node_set_merge___0(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1UL)))->nodes));
#line 3011
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3011
      if (tmp___10) {
        {
#line 3013
        free((void *)next_nodes.elems);
        }
#line 3014
        return (err);
      }
    }
#line 3017
    if (cur_state) {
      {
#line 3019
      err = check_arrival_add_next_nodes___0(mctx, str_idx, & cur_state->non_eps_nodes,
                                             & next_nodes);
#line 3022
      tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3022
      if (tmp___11) {
        {
#line 3024
        free((void *)next_nodes.elems);
        }
#line 3025
        return (err);
      }
    }
#line 3028
    str_idx ++;
#line 3029
    if (next_nodes.nelem) {
      {
#line 3031
      err = check_arrival_expand_ecl___0(dfa, & next_nodes, subexp_num, type);
#line 3032
      tmp___12 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3032
      if (tmp___12) {
        {
#line 3034
        free((void *)next_nodes.elems);
        }
#line 3035
        return (err);
      }
      {
#line 3037
      err = expand_bkref_cache___0(mctx, & next_nodes, str_idx, subexp_num, type);
#line 3039
      tmp___13 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3039
      if (tmp___13) {
        {
#line 3041
        free((void *)next_nodes.elems);
        }
#line 3042
        return (err);
      }
    }
    {
#line 3045
    context = re_string_context_at___0((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                       mctx->eflags);
#line 3046
    cur_state = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& next_nodes),
                                             context);
    }
#line 3047
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3047
      if ((int )err != 0) {
#line 3047
        tmp___14 = 1;
      } else {
#line 3047
        tmp___14 = 0;
      }
    } else {
#line 3047
      tmp___14 = 0;
    }
    {
#line 3047
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
    }
#line 3047
    if (tmp___15) {
      {
#line 3049
      free((void *)next_nodes.elems);
      }
#line 3050
      return (err);
    }
#line 3052
    *(mctx->state_log + str_idx) = cur_state;
#line 3053
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3053
      null_cnt ++;
    } else {
#line 3053
      null_cnt = (Idx )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3055
  free((void *)next_nodes.elems);
  }
#line 3056
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 3056
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 3056
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 3058
  path->next_idx = str_idx;
#line 3061
  mctx->state_log = backup_state_log;
#line 3062
  mctx->input.cur_idx = backup_cur_idx;
#line 3065
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
    {
#line 3065
    tmp___16 = re_node_set_contains___0((re_node_set const   *)cur_nodes, last_node);
    }
#line 3065
    if (tmp___16) {
#line 3066
      return ((reg_errcode_t )0);
    }
  }
#line 3068
  return ((reg_errcode_t )1);
}
}
#line 3079 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_add_next_nodes___0(re_match_context_t *mctx , Idx str_idx ,
                                                      re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  _Bool ok ;
  Idx cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  Idx cur_node ;
  re_dfastate_t *dest_state ;
  Idx next_node ;
  Idx next_idx ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 3084
  dfa = mctx->dfa;
#line 3088
  err = (reg_errcode_t )0;
#line 3091
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3092
  cur_idx = (Idx )0;
  }
  {
#line 3092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3092
    if (! (cur_idx < cur_nodes->nelem)) {
#line 3092
      goto while_break;
    }
#line 3094
    naccepted = 0;
#line 3095
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3102
    if ((dfa->nodes + cur_node)->accept_mb) {
      {
#line 3104
      naccepted = check_node_accept_bytes___0(dfa, cur_node, (re_string_t const   *)(& mctx->input),
                                              str_idx);
      }
#line 3106
      if (naccepted > 1) {
#line 3109
        next_node = *(dfa->nexts + cur_node);
#line 3110
        next_idx = str_idx + (Idx )naccepted;
#line 3111
        dest_state = *(mctx->state_log + next_idx);
#line 3112
        union_set.nelem = (Idx )0;
#line 3113
        if (dest_state) {
          {
#line 3115
          err = re_node_set_merge___0(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3116
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 3116
          if (tmp) {
            {
#line 3118
            free((void *)union_set.elems);
            }
#line 3119
            return (err);
          }
        }
        {
#line 3122
        ok = re_node_set_insert___0(& union_set, next_node);
#line 3123
        tmp___0 = __builtin_expect((long )(! ok), 0L);
        }
#line 3123
        if (tmp___0) {
          {
#line 3125
          free((void *)union_set.elems);
          }
#line 3126
          return ((reg_errcode_t )12);
        }
        {
#line 3128
        *(mctx->state_log + next_idx) = re_acquire_state___0(& err, dfa, (re_node_set const   *)(& union_set));
        }
#line 3130
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 3130
          if ((int )err != 0) {
#line 3130
            tmp___1 = 1;
          } else {
#line 3130
            tmp___1 = 0;
          }
        } else {
#line 3130
          tmp___1 = 0;
        }
        {
#line 3130
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
        }
#line 3130
        if (tmp___2) {
          {
#line 3133
          free((void *)union_set.elems);
          }
#line 3134
          return (err);
        }
      }
    }
#line 3139
    if (naccepted) {
#line 3139
      goto _L;
    } else {
      {
#line 3139
      tmp___4 = check_node_accept___0((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                      str_idx);
      }
#line 3139
      if (tmp___4) {
        _L: /* CIL Label */ 
        {
#line 3142
        ok = re_node_set_insert___0(next_nodes, *(dfa->nexts + cur_node));
#line 3143
        tmp___3 = __builtin_expect((long )(! ok), 0L);
        }
#line 3143
        if (tmp___3) {
          {
#line 3145
          free((void *)union_set.elems);
          }
#line 3146
          return ((reg_errcode_t )12);
        }
      }
    }
#line 3092
    cur_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3150
  free((void *)union_set.elems);
  }
#line 3151
  return ((reg_errcode_t )0);
}
}
#line 3160 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl___0(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                                  Idx ex_subexp , int type ) 
{ 
  reg_errcode_t err ;
  Idx idx ;
  Idx outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  Idx cur_node ;
  re_node_set const   *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 3171
  err = re_node_set_alloc___0(& new_nodes, cur_nodes->nelem);
#line 3172
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3172
  if (tmp) {
#line 3173
    return (err);
  }
#line 3177
  idx = (Idx )0;
  {
#line 3177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3177
    if (! (idx < cur_nodes->nelem)) {
#line 3177
      goto while_break;
    }
    {
#line 3179
    cur_node = *(cur_nodes->elems + idx);
#line 3180
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
#line 3181
    outside_node = find_subexp_node___0(dfa, eclosure, ex_subexp, type);
    }
#line 3182
    if (outside_node == 0xffffffffffffffffUL) {
      {
#line 3185
      err = re_node_set_merge___0(& new_nodes, eclosure);
#line 3186
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3186
      if (tmp___0) {
        {
#line 3188
        free((void *)new_nodes.elems);
        }
#line 3189
        return (err);
      }
    } else {
      {
#line 3195
      err = check_arrival_expand_ecl_sub___0(dfa, & new_nodes, cur_node, ex_subexp,
                                             type);
#line 3197
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3197
      if (tmp___1) {
        {
#line 3199
        free((void *)new_nodes.elems);
        }
#line 3200
        return (err);
      }
    }
#line 3177
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3204
  free((void *)cur_nodes->elems);
#line 3205
  *cur_nodes = new_nodes;
  }
#line 3206
  return ((reg_errcode_t )0);
}
}
#line 3213 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub___0(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                      Idx target , Idx ex_subexp ,
                                                      int type ) 
{ 
  Idx cur_node ;
  _Bool ok ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t err ;
  long tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;

  {
#line 3219
  cur_node = target;
  {
#line 3219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3219
    tmp___2 = re_node_set_contains___0((re_node_set const   *)dst_nodes, cur_node);
    }
#line 3219
    if (tmp___2) {
#line 3219
      goto while_break;
    }
#line 3223
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type) {
#line 3223
      if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3226
        if (type == 9) {
          {
#line 3228
          ok = re_node_set_insert___0(dst_nodes, cur_node);
#line 3229
          tmp = __builtin_expect((long )(! ok), 0L);
          }
#line 3229
          if (tmp) {
#line 3230
            return ((reg_errcode_t )12);
          }
        }
#line 3232
        goto while_break;
      }
    }
    {
#line 3234
    ok = re_node_set_insert___0(dst_nodes, cur_node);
#line 3235
    tmp___0 = __builtin_expect((long )(! ok), 0L);
    }
#line 3235
    if (tmp___0) {
#line 3236
      return ((reg_errcode_t )12);
    }
#line 3237
    if ((dfa->edests + cur_node)->nelem == 0UL) {
#line 3238
      goto while_break;
    }
#line 3239
    if ((dfa->edests + cur_node)->nelem == 2UL) {
      {
#line 3242
      err = check_arrival_expand_ecl_sub___0(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                             ex_subexp, type);
#line 3245
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3245
      if (tmp___1) {
#line 3246
        return (err);
      }
    }
#line 3248
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 3250
  return ((reg_errcode_t )0);
}
}
#line 3258 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t expand_bkref_cache___0(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                            Idx cur_str , Idx subexp_num , int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx cache_idx_start ;
  Idx tmp ;
  struct re_backref_cache_entry *ent ;
  Idx to_idx ;
  Idx next_node ;
  Idx __attribute__((__pure__))  tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_node_set union_set ;
  _Bool ok ;
  Idx __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  struct re_backref_cache_entry *tmp___11 ;

  {
  {
#line 3263
  dfa = mctx->dfa;
#line 3265
  tmp = search_cur_bkref_entry___0((re_match_context_t const   *)mctx, cur_str);
#line 3265
  cache_idx_start = tmp;
  }
#line 3268
  if (cache_idx_start == 0xffffffffffffffffUL) {
#line 3269
    return ((reg_errcode_t )0);
  }
  restart: 
#line 3272
  ent = mctx->bkref_ents + cache_idx_start;
  {
#line 3273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3278
    tmp___0 = re_node_set_contains___0((re_node_set const   *)cur_nodes, ent->node);
    }
#line 3278
    if (! tmp___0) {
#line 3279
      goto __Cont;
    }
#line 3281
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3284
    if (to_idx == cur_str) {
      {
#line 3290
      next_node = *((dfa->edests + ent->node)->elems + 0);
#line 3291
      tmp___1 = re_node_set_contains___0((re_node_set const   *)cur_nodes, next_node);
      }
#line 3291
      if (tmp___1) {
#line 3292
        goto __Cont;
      }
      {
#line 3293
      err = re_node_set_init_1___0(& new_dests, next_node);
#line 3294
      err2 = check_arrival_expand_ecl___0(dfa, & new_dests, subexp_num, type);
#line 3295
      err3 = re_node_set_merge___0(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3296
      free((void *)new_dests.elems);
      }
#line 3297
      if ((int )err != 0) {
#line 3297
        tmp___3 = 1;
      } else
#line 3297
      if ((int )err2 != 0) {
#line 3297
        tmp___3 = 1;
      } else
#line 3297
      if ((int )err3 != 0) {
#line 3297
        tmp___3 = 1;
      } else {
#line 3297
        tmp___3 = 0;
      }
      {
#line 3297
      tmp___4 = __builtin_expect((long )tmp___3, 0L);
      }
#line 3297
      if (tmp___4) {
#line 3300
        if ((int )err != 0) {
#line 3300
          err = err;
        } else {
#line 3300
          if ((int )err2 != 0) {
#line 3300
            tmp___2 = (int )err2;
          } else {
#line 3300
            tmp___2 = (int )err3;
          }
#line 3300
          err = (reg_errcode_t )tmp___2;
        }
#line 3302
        return (err);
      }
#line 3305
      goto restart;
    } else {
#line 3310
      next_node = *(dfa->nexts + ent->node);
#line 3311
      if (*(mctx->state_log + to_idx)) {
        {
#line 3314
        tmp___5 = re_node_set_contains___0((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                           next_node);
        }
#line 3314
        if (tmp___5) {
#line 3316
          goto __Cont;
        }
        {
#line 3317
        err = re_node_set_init_copy___0(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3319
        ok = re_node_set_insert___0(& union_set, next_node);
        }
#line 3320
        if ((int )err != 0) {
#line 3320
          tmp___6 = 1;
        } else
#line 3320
        if (! ok) {
#line 3320
          tmp___6 = 1;
        } else {
#line 3320
          tmp___6 = 0;
        }
        {
#line 3320
        tmp___7 = __builtin_expect((long )tmp___6, 0L);
        }
#line 3320
        if (tmp___7) {
          {
#line 3322
          free((void *)union_set.elems);
          }
#line 3323
          if ((int )err != 0) {
#line 3323
            err = err;
          } else {
#line 3323
            err = (reg_errcode_t )12;
          }
#line 3324
          return (err);
        }
      } else {
        {
#line 3329
        err = re_node_set_init_1___0(& union_set, next_node);
#line 3330
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3330
        if (tmp___8) {
#line 3331
          return (err);
        }
      }
      {
#line 3333
      *(mctx->state_log + to_idx) = re_acquire_state___0(& err, dfa, (re_node_set const   *)(& union_set));
#line 3334
      free((void *)union_set.elems);
      }
#line 3335
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3335
        if ((int )err != 0) {
#line 3335
          tmp___9 = 1;
        } else {
#line 3335
          tmp___9 = 0;
        }
      } else {
#line 3335
        tmp___9 = 0;
      }
      {
#line 3335
      tmp___10 = __builtin_expect((long )tmp___9, 0L);
      }
#line 3335
      if (tmp___10) {
#line 3337
        return (err);
      }
    }
    __Cont: /* CIL Label */ 
#line 3273
    tmp___11 = ent;
#line 3273
    ent ++;
#line 3273
    if (! tmp___11->more) {
#line 3273
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3341
  return ((reg_errcode_t )0);
}
}
#line 3347 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool build_trtable___0(re_dfa_t const   *dfa , re_dfastate_t *state___0 ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  Idx j ;
  int ch ;
  _Bool need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  Idx ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct re_dfastate_t **tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  Idx next_node ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  struct re_dfastate_t **tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  struct re_dfastate_t **tmp___21 ;
  void *tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;

  {
#line 3354
  need_word_trtable = (_Bool)0;
#line 3356
  dests_node_malloced = (_Bool)0;
#line 3357
  dest_states_malloced = (_Bool)0;
#line 3360
  dest_states = (re_dfastate_t **)((void *)0);
#line 3375
  if (sizeof(struct dests_alloc ) < 4032UL) {
    {
#line 3376
    tmp = __builtin_alloca(sizeof(struct dests_alloc ));
#line 3376
    dests_alloc = (struct dests_alloc *)tmp;
    }
  } else {
    {
#line 3379
    tmp___0 = malloc(sizeof(struct dests_alloc ));
#line 3379
    dests_alloc = (struct dests_alloc *)tmp___0;
#line 3380
    tmp___1 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                               0L);
    }
#line 3380
    if (tmp___1) {
#line 3381
      return ((_Bool)0);
    }
#line 3382
    dests_node_malloced = (_Bool)1;
  }
  {
#line 3384
  dests_node = dests_alloc->dests_node;
#line 3385
  dests_ch = dests_alloc->dests_ch;
#line 3388
  tmp___2 = (struct re_dfastate_t **)((void *)0);
#line 3388
  state___0->trtable = tmp___2;
#line 3388
  state___0->word_trtable = tmp___2;
#line 3392
  ndests = group_nodes_into_DFAstates___0(dfa, (re_dfastate_t const   *)state___0,
                                          dests_node, dests_ch);
#line 3393
  tmp___4 = __builtin_expect((long )(! (ndests - 1UL < 0xfffffffffffffffdUL)), 0L);
  }
#line 3393
  if (tmp___4) {
#line 3395
    if (dests_node_malloced) {
      {
#line 3396
      free((void *)dests_alloc);
      }
    }
#line 3397
    if (ndests == 0UL) {
      {
#line 3399
      tmp___3 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3399
      state___0->trtable = (re_dfastate_t **)tmp___3;
      }
#line 3401
      return ((_Bool)1);
    }
#line 3403
    return ((_Bool)0);
  }
  {
#line 3406
  err = re_node_set_alloc___0(& follows, ndests + 1UL);
#line 3407
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3407
  if (tmp___5) {
#line 3408
    goto out_free;
  }
  {
#line 3411
  tmp___6 = __builtin_expect((long )((0xffffffffffffffffUL - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL) / (3UL * sizeof(re_dfastate_t *)) < ndests),
                             0L);
  }
#line 3411
  if (tmp___6) {
#line 3415
    goto out_free;
  }
#line 3417
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL + (ndests * 3UL) * sizeof(re_dfastate_t *) < 4032UL) {
    {
#line 3419
    tmp___7 = __builtin_alloca((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3419
    dest_states = (re_dfastate_t **)tmp___7;
    }
  } else {
    {
#line 3423
    tmp___8 = malloc((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3423
    dest_states = (re_dfastate_t **)tmp___8;
#line 3425
    tmp___9 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 3425
    if (tmp___9) {
      out_free: 
#line 3428
      if (dest_states_malloced) {
        {
#line 3429
        free((void *)dest_states);
        }
      }
      {
#line 3430
      free((void *)follows.elems);
#line 3431
      i = (Idx )0;
      }
      {
#line 3431
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3431
        if (! (i < ndests)) {
#line 3431
          goto while_break;
        }
        {
#line 3432
        free((void *)(dests_node + i)->elems);
#line 3431
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3433
      if (dests_node_malloced) {
        {
#line 3434
        free((void *)dests_alloc);
        }
      }
#line 3435
      return ((_Bool)0);
    }
#line 3437
    dest_states_malloced = (_Bool)1;
  }
  {
#line 3439
  dest_states_word = dest_states + ndests;
#line 3440
  dest_states_nl = dest_states_word + ndests;
#line 3441
  bitset_empty((bitset_word_t *)(acceptable));
#line 3444
  i = (Idx )0;
  }
  {
#line 3444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3444
    if (! (i < ndests)) {
#line 3444
      goto while_break___0;
    }
#line 3447
    follows.nelem = (Idx )0;
#line 3449
    j = (Idx )0;
    {
#line 3449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3449
      if (! (j < (dests_node + i)->nelem)) {
#line 3449
        goto while_break___1;
      }
#line 3451
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3452
      if (next_node != 0xffffffffffffffffUL) {
        {
#line 3454
        err = re_node_set_merge___0(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
#line 3455
        tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3455
        if (tmp___10) {
#line 3456
          goto out_free;
        }
      }
#line 3449
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3459
    *(dest_states + i) = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& follows),
                                                      0U);
    }
#line 3460
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
#line 3460
      if ((int )err != 0) {
#line 3460
        tmp___11 = 1;
      } else {
#line 3460
        tmp___11 = 0;
      }
    } else {
#line 3460
      tmp___11 = 0;
    }
    {
#line 3460
    tmp___12 = __builtin_expect((long )tmp___11, 0L);
    }
#line 3460
    if (tmp___12) {
#line 3461
      goto out_free;
    }
#line 3464
    if ((*(dest_states + i))->has_constraint) {
      {
#line 3466
      *(dest_states_word + i) = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& follows),
                                                             1U);
      }
#line 3468
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
#line 3468
        if ((int )err != 0) {
#line 3468
          tmp___13 = 1;
        } else {
#line 3468
          tmp___13 = 0;
        }
      } else {
#line 3468
        tmp___13 = 0;
      }
      {
#line 3468
      tmp___14 = __builtin_expect((long )tmp___13, 0L);
      }
#line 3468
      if (tmp___14) {
#line 3469
        goto out_free;
      }
#line 3471
      if ((unsigned long )*(dest_states + i) != (unsigned long )*(dest_states_word + i)) {
#line 3471
        if (dfa->mb_cur_max > 1) {
#line 3472
          need_word_trtable = (_Bool)1;
        }
      }
      {
#line 3474
      *(dest_states_nl + i) = re_acquire_state_context___0(& err, dfa, (re_node_set const   *)(& follows),
                                                           (unsigned int )(1 << 1));
      }
#line 3476
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
#line 3476
        if ((int )err != 0) {
#line 3476
          tmp___15 = 1;
        } else {
#line 3476
          tmp___15 = 0;
        }
      } else {
#line 3476
        tmp___15 = 0;
      }
      {
#line 3476
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
      }
#line 3476
      if (tmp___16) {
#line 3477
        goto out_free;
      }
    } else {
#line 3481
      *(dest_states_word + i) = *(dest_states + i);
#line 3482
      *(dest_states_nl + i) = *(dest_states + i);
    }
    {
#line 3484
    bitset_merge((bitset_word_t *)(acceptable), (bitset_word_t */* const  */)(*(dests_ch + i)));
#line 3444
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3487
  tmp___25 = __builtin_expect((long )need_word_trtable, 0L);
  }
#line 3487
  if (tmp___25) {
    {
#line 3524
    tmp___22 = calloc(sizeof(re_dfastate_t *), (size_t )512);
#line 3524
    tmp___21 = (re_dfastate_t **)tmp___22;
#line 3524
    state___0->word_trtable = tmp___21;
#line 3524
    trtable = tmp___21;
#line 3526
    tmp___23 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3526
    if (tmp___23) {
#line 3527
      goto out_free;
    }
#line 3530
    i = (Idx )0;
    {
#line 3530
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3530
      if (! (i < 4UL)) {
#line 3530
        goto while_break___2;
      }
#line 3531
      ch = (int )(i * 64UL);
#line 3531
      elem = acceptable[i];
#line 3531
      mask = (bitset_word_t )1;
      {
#line 3531
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3531
        if (! elem) {
#line 3531
          goto while_break___3;
        }
        {
#line 3534
        tmp___24 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3534
        if (tmp___24) {
#line 3538
          j = (Idx )0;
          {
#line 3538
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3538
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3538
              goto while_break___4;
            }
#line 3538
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3542
          *(trtable + ch) = *(dest_states + j);
#line 3543
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3531
        mask <<= 1;
#line 3531
        elem >>= 1;
#line 3531
        ch ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3530
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 3493
    tmp___18 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3493
    tmp___17 = (re_dfastate_t **)tmp___18;
#line 3493
    state___0->trtable = tmp___17;
#line 3493
    trtable = tmp___17;
#line 3495
    tmp___19 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3495
    if (tmp___19) {
#line 3496
      goto out_free;
    }
#line 3499
    i = (Idx )0;
    {
#line 3499
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3499
      if (! (i < 4UL)) {
#line 3499
        goto while_break___5;
      }
#line 3500
      ch = (int )(i * 64UL);
#line 3500
      elem = acceptable[i];
#line 3500
      mask = (bitset_word_t )1;
      {
#line 3500
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3500
        if (! elem) {
#line 3500
          goto while_break___6;
        }
        {
#line 3503
        tmp___20 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3503
        if (tmp___20) {
#line 3507
          j = (Idx )0;
          {
#line 3507
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3507
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3507
              goto while_break___7;
            }
#line 3507
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3511
          if (dfa->word_char[i] & mask) {
#line 3512
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3514
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3500
        mask <<= 1;
#line 3500
        elem >>= 1;
#line 3500
        ch ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3499
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 3548
  tmp___27 = bitset_contain((bitset_word_t */* const  */)(acceptable), (Idx )'\n');
  }
#line 3548
  if (tmp___27) {
#line 3551
    j = (Idx )0;
    {
#line 3551
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3551
      if (! (j < ndests)) {
#line 3551
        goto while_break___8;
      }
      {
#line 3552
      tmp___26 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )'\n');
      }
#line 3552
      if (tmp___26) {
#line 3555
        *(trtable + '\n') = *(dest_states_nl + j);
#line 3556
        if (need_word_trtable) {
#line 3557
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3560
        goto while_break___8;
      }
#line 3551
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 3564
  if (dest_states_malloced) {
    {
#line 3565
    free((void *)dest_states);
    }
  }
  {
#line 3567
  free((void *)follows.elems);
#line 3568
  i = (Idx )0;
  }
  {
#line 3568
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3568
    if (! (i < ndests)) {
#line 3568
      goto while_break___9;
    }
    {
#line 3569
    free((void *)(dests_node + i)->elems);
#line 3568
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3571
  if (dests_node_malloced) {
    {
#line 3572
    free((void *)dests_alloc);
    }
  }
#line 3574
  return ((_Bool)1);
}
}
#line 3582 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx group_nodes_into_DFAstates___0(re_dfa_t const   *dfa , re_dfastate_t const   *state___0 ,
                                          re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err ;
  _Bool ok ;
  Idx i ;
  Idx j ;
  Idx k ;
  Idx ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  _Bool tmp ;
  bitset_word_t any_set ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  _Bool tmp___4 ;
  bitset_word_t tmp___5 ;
  bitset_word_t tmp___6 ;
  bitset_word_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 3592
  cur_nodes = & state___0->nodes;
#line 3593
  bitset_empty((bitset_word_t *)(accepts));
#line 3594
  ndests = (Idx )0;
#line 3597
  i = (Idx )0;
  }
  {
#line 3597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3597
    if (! (i < (Idx )cur_nodes->nelem)) {
#line 3597
      goto while_break;
    }
#line 3599
    node = dfa->nodes + *(cur_nodes->elems + i);
#line 3600
    type = node->type;
#line 3601
    constraint = node->constraint;
#line 3604
    if ((unsigned int )type == 1U) {
      {
#line 3605
      bitset_set((bitset_word_t *)(accepts), (Idx )node->opr.c);
      }
    } else
#line 3606
    if ((unsigned int )type == 3U) {
      {
#line 3608
      bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)node->opr.sbcset);
      }
    } else
#line 3610
    if ((unsigned int )type == 5U) {
#line 3613
      if (dfa->mb_cur_max > 1) {
        {
#line 3614
        bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)dfa->sb_char);
        }
      } else {
        {
#line 3617
        bitset_set_all((bitset_word_t *)(accepts));
        }
      }
#line 3618
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3619
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3620
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3621
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else
#line 3624
    if ((unsigned int )type == 7U) {
      {
#line 3627
      memset((void *)(accepts), -1, (size_t )16);
      }
#line 3630
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3631
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3632
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3633
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else {
#line 3637
      goto __Cont;
    }
#line 3641
    if (constraint) {
#line 3643
      if (constraint & 32U) {
        {
#line 3645
        tmp = bitset_contain((bitset_word_t */* const  */)(accepts), (Idx )'\n');
#line 3645
        accepts_newline = tmp;
#line 3646
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3647
        if (accepts_newline) {
          {
#line 3648
          bitset_set((bitset_word_t *)(accepts), (Idx )'\n');
          }
        } else {
#line 3650
          goto __Cont;
        }
      }
#line 3652
      if (constraint & 128U) {
        {
#line 3654
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3655
        goto __Cont;
      }
#line 3658
      if (constraint & 4U) {
#line 3660
        any_set = (bitset_word_t )0;
#line 3661
        if ((unsigned int )type == 1U) {
#line 3661
          if (! node->word_char) {
            {
#line 3663
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3664
            goto __Cont;
          }
        }
#line 3667
        if (dfa->mb_cur_max > 1) {
#line 3668
          j = (Idx )0;
          {
#line 3668
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3668
            if (! (j < 4UL)) {
#line 3668
              goto while_break___0;
            }
#line 3669
            tmp___0 = accepts[j] & (dfa->word_char[j] | ~ *(dfa->sb_char + j));
#line 3669
            accepts[j] = tmp___0;
#line 3669
            any_set |= tmp___0;
#line 3668
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 3672
          j = (Idx )0;
          {
#line 3672
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3672
            if (! (j < 4UL)) {
#line 3672
              goto while_break___1;
            }
#line 3673
            tmp___1 = accepts[j] & dfa->word_char[j];
#line 3673
            accepts[j] = tmp___1;
#line 3673
            any_set |= tmp___1;
#line 3672
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 3674
        if (! any_set) {
#line 3675
          goto __Cont;
        }
      }
#line 3677
      if (constraint & 8U) {
#line 3679
        any_set___0 = (bitset_word_t )0;
#line 3680
        if ((unsigned int )type == 1U) {
#line 3680
          if (node->word_char) {
            {
#line 3682
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3683
            goto __Cont;
          }
        }
#line 3686
        if (dfa->mb_cur_max > 1) {
#line 3687
          j = (Idx )0;
          {
#line 3687
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3687
            if (! (j < 4UL)) {
#line 3687
              goto while_break___2;
            }
#line 3688
            tmp___2 = accepts[j] & ~ (dfa->word_char[j] & *(dfa->sb_char + j));
#line 3688
            accepts[j] = tmp___2;
#line 3688
            any_set___0 |= tmp___2;
#line 3687
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 3691
          j = (Idx )0;
          {
#line 3691
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3691
            if (! (j < 4UL)) {
#line 3691
              goto while_break___3;
            }
#line 3692
            tmp___3 = accepts[j] & ~ dfa->word_char[j];
#line 3692
            accepts[j] = tmp___3;
#line 3692
            any_set___0 |= tmp___3;
#line 3691
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3693
        if (! any_set___0) {
#line 3694
          goto __Cont;
        }
      }
    }
#line 3700
    j = (Idx )0;
    {
#line 3700
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3700
      if (! (j < ndests)) {
#line 3700
        goto while_break___4;
      }
#line 3708
      if ((unsigned int )type == 1U) {
        {
#line 3708
        tmp___4 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )node->opr.c);
        }
#line 3708
        if (! tmp___4) {
#line 3709
          goto __Cont___0;
        }
      }
#line 3712
      has_intersec = (bitset_word_t )0;
#line 3713
      k = (Idx )0;
      {
#line 3713
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3713
        if (! (k < 4UL)) {
#line 3713
          goto while_break___5;
        }
#line 3714
        tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3714
        intersec[k] = tmp___5;
#line 3714
        has_intersec |= tmp___5;
#line 3713
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3716
      if (! has_intersec) {
#line 3717
        goto __Cont___0;
      }
#line 3720
      not_consumed = (bitset_word_t )0;
#line 3720
      not_subset = not_consumed;
#line 3721
      k = (Idx )0;
      {
#line 3721
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3721
        if (! (k < 4UL)) {
#line 3721
          goto while_break___6;
        }
#line 3723
        tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3723
        remains[k] = tmp___6;
#line 3723
        not_subset |= tmp___6;
#line 3724
        tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3724
        accepts[k] = tmp___7;
#line 3724
        not_consumed |= tmp___7;
#line 3721
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3729
      if (not_subset) {
        {
#line 3731
        bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(remains));
#line 3732
        bitset_copy((bitset_word_t *)(*(dests_ch + j)), (bitset_word_t */* const  */)(intersec));
#line 3733
        err = re_node_set_init_copy___0(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3734
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3734
        if (tmp___8) {
#line 3735
          goto error_return;
        }
#line 3736
        ndests ++;
      }
      {
#line 3740
      ok = re_node_set_insert___0(dests_node + j, *(cur_nodes->elems + i));
#line 3741
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 3741
      if (tmp___9) {
#line 3742
        goto error_return;
      }
#line 3745
      if (! not_consumed) {
#line 3746
        goto while_break___4;
      }
      __Cont___0: /* CIL Label */ 
#line 3700
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3749
    if (j == ndests) {
      {
#line 3751
      bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(accepts));
#line 3752
      err = re_node_set_init_1___0(dests_node + ndests, *(cur_nodes->elems + i));
#line 3753
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3753
      if (tmp___10) {
#line 3754
        goto error_return;
      }
      {
#line 3755
      ndests ++;
#line 3756
      bitset_empty((bitset_word_t *)(accepts));
      }
    }
    __Cont: /* CIL Label */ 
#line 3597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3759
  return (ndests);
  error_return: 
#line 3761
  j = (Idx )0;
  {
#line 3761
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3761
    if (! (j < ndests)) {
#line 3761
      goto while_break___7;
    }
    {
#line 3762
    free((void *)(dests_node + j)->elems);
#line 3761
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3763
  return ((Idx )-1);
}
}
#line 3775 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static int check_node_accept_bytes___0(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                       Idx str_idx ) 
{ 
  re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  Idx i ;
  unsigned char c ;
  unsigned char d ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t __attribute__((__pure__))  tmp___4 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  wctype_t wt ;
  int tmp___6 ;
  wchar_t cmp_buf[6] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 3780
  node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 3784
  tmp___1 = __builtin_expect((long )((unsigned int const   )node->type == 7U), 0L);
  }
#line 3784
  if (tmp___1) {
    {
#line 3786
    c = *(input->mbs + str_idx);
#line 3787
    tmp = __builtin_expect((long )((int )c < 194), 1L);
    }
#line 3787
    if (tmp) {
#line 3788
      return (0);
    }
#line 3790
    if (str_idx + 2UL > (Idx )input->len) {
#line 3791
      return (0);
    }
#line 3793
    d = *(input->mbs + (str_idx + 1UL));
#line 3794
    if ((int )c < 224) {
#line 3795
      if ((int )d < 128) {
#line 3795
        tmp___0 = 0;
      } else
#line 3795
      if ((int )d > 191) {
#line 3795
        tmp___0 = 0;
      } else {
#line 3795
        tmp___0 = 2;
      }
#line 3795
      return (tmp___0);
    } else
#line 3796
    if ((int )c < 240) {
#line 3798
      char_len = 3;
#line 3799
      if ((int )c == 224) {
#line 3799
        if ((int )d < 160) {
#line 3800
          return (0);
        }
      }
    } else
#line 3802
    if ((int )c < 248) {
#line 3804
      char_len = 4;
#line 3805
      if ((int )c == 240) {
#line 3805
        if ((int )d < 144) {
#line 3806
          return (0);
        }
      }
    } else
#line 3808
    if ((int )c < 252) {
#line 3810
      char_len = 5;
#line 3811
      if ((int )c == 248) {
#line 3811
        if ((int )d < 136) {
#line 3812
          return (0);
        }
      }
    } else
#line 3814
    if ((int )c < 254) {
#line 3816
      char_len = 6;
#line 3817
      if ((int )c == 252) {
#line 3817
        if ((int )d < 132) {
#line 3818
          return (0);
        }
      }
    } else {
#line 3821
      return (0);
    }
#line 3823
    if (str_idx + (Idx )char_len > (Idx )input->len) {
#line 3824
      return (0);
    }
#line 3826
    i = (Idx )1;
    {
#line 3826
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3826
      if (! (i < (Idx )char_len)) {
#line 3826
        goto while_break;
      }
#line 3828
      d = *(input->mbs + (str_idx + i));
#line 3829
      if ((int )d < 128) {
#line 3830
        return (0);
      } else
#line 3829
      if ((int )d > 191) {
#line 3830
        return (0);
      }
#line 3826
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3832
    return (char_len);
  }
  {
#line 3835
  tmp___2 = re_string_char_size_at(input, str_idx);
#line 3835
  char_len = (int )tmp___2;
  }
#line 3836
  if ((unsigned int const   )node->type == 5U) {
#line 3838
    if (char_len <= 1) {
#line 3839
      return (0);
    }
#line 3843
    if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3843
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3847
        return (0);
      } else {
#line 3843
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3843
    if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3843
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3847
        return (0);
      }
    }
#line 3848
    return (char_len);
  }
  {
#line 3851
  tmp___3 = re_string_elem_size_at___0(input, str_idx);
#line 3851
  elem_len = (int )tmp___3;
  }
#line 3852
  if (elem_len <= 1) {
#line 3852
    if (char_len <= 1) {
#line 3853
      return (0);
    } else {
#line 3852
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3852
  if (char_len == 0) {
#line 3853
    return (0);
  }
#line 3855
  if ((unsigned int const   )node->type == 6U) {
#line 3857
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3864
    match_len = 0;
#line 3865
    if (cset->nranges) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else
#line 3865
    if (cset->nchar_classes) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else
#line 3865
    if (cset->nmbchars) {
      {
#line 3865
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3865
      tmp___5 = tmp___4;
      }
    } else {
#line 3865
      tmp___5 = (wint_t __attribute__((__pure__))  )0;
    }
#line 3865
    wc = (wchar_t )tmp___5;
#line 3869
    i = (Idx )0;
    {
#line 3869
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3869
      if (! (i < (Idx )cset->nmbchars)) {
#line 3869
        goto while_break___0;
      }
#line 3870
      if (wc == *(cset->mbchars + i)) {
#line 3872
        match_len = char_len;
#line 3873
        goto check_node_accept_bytes_match;
      }
#line 3869
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3876
    i = (Idx )0;
    {
#line 3876
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3876
      if (! (i < (Idx )cset->nchar_classes)) {
#line 3876
        goto while_break___1;
      }
      {
#line 3878
      wt = *(cset->char_classes + i);
#line 3879
      tmp___6 = iswctype((wint_t )wc, wt);
      }
#line 3879
      if (tmp___6) {
#line 3881
        match_len = char_len;
#line 3882
        goto check_node_accept_bytes_match;
      }
#line 3876
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3979
    cmp_buf[0] = 0;
#line 3979
    cmp_buf[1] = 0;
#line 3979
    cmp_buf[2] = wc;
#line 3979
    cmp_buf[3] = 0;
#line 3979
    cmp_buf[4] = 0;
#line 3979
    cmp_buf[5] = 0;
#line 3984
    i = (Idx )0;
    {
#line 3984
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3984
      if (! (i < (Idx )cset->nranges)) {
#line 3984
        goto while_break___2;
      }
      {
#line 3986
      cmp_buf[0] = *(cset->range_starts + i);
#line 3987
      cmp_buf[4] = *(cset->range_ends + i);
#line 3988
      tmp___7 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
      }
#line 3988
      if (tmp___7 <= 0) {
        {
#line 3988
        tmp___8 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
        }
#line 3988
        if (tmp___8 <= 0) {
#line 3991
          match_len = char_len;
#line 3992
          goto check_node_accept_bytes_match;
        }
      }
#line 3984
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    check_node_accept_bytes_match: 
#line 3997
    if (! cset->non_match) {
#line 3998
      return (match_len);
    } else
#line 4001
    if (match_len > 0) {
#line 4002
      return (0);
    } else {
#line 4004
      if (elem_len > char_len) {
#line 4004
        tmp___9 = elem_len;
      } else {
#line 4004
        tmp___9 = char_len;
      }
#line 4004
      return (tmp___9);
    }
  }
#line 4007
  return (0);
}
}
#line 4075 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static _Bool check_node_accept___0(re_match_context_t const   *mctx , re_token_t const   *node ,
                                   Idx idx ) 
{ 
  unsigned char ch ;
  _Bool tmp ;
  unsigned int context ;
  unsigned int tmp___0 ;

  {
#line 4081
  ch = *(mctx->input.mbs + idx);
  {
#line 4084
  if ((unsigned int const   )node->type == 1U) {
#line 4084
    goto case_1;
  }
#line 4089
  if ((unsigned int const   )node->type == 3U) {
#line 4089
    goto case_3;
  }
#line 4095
  if ((unsigned int const   )node->type == 7U) {
#line 4095
    goto case_7;
  }
#line 4100
  if ((unsigned int const   )node->type == 5U) {
#line 4100
    goto case_5;
  }
#line 4106
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4085
  if ((int const   )node->opr.c != (int const   )ch) {
#line 4086
    return ((_Bool)0);
  }
#line 4087
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4090
  tmp = bitset_contain((bitset_word_t */* const  */)node->opr.sbcset, (Idx )ch);
  }
#line 4090
  if (! tmp) {
#line 4091
    return ((_Bool)0);
  }
#line 4092
  goto switch_break;
  case_7: /* CIL Label */ 
#line 4096
  if ((int )ch >= 128) {
#line 4097
    return ((_Bool)0);
  }
  case_5: /* CIL Label */ 
#line 4101
  if ((int )ch == 10) {
#line 4101
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4103
      return ((_Bool)0);
    } else {
#line 4101
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4101
  if ((int )ch == 0) {
#line 4101
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4103
      return ((_Bool)0);
    }
  }
#line 4104
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4107
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
#line 4110
  if (node->constraint) {
    {
#line 4114
    tmp___0 = re_string_context_at___0(& mctx->input, idx, (int )mctx->eflags);
#line 4114
    context = tmp___0;
    }
#line 4116
    if (node->constraint & 4U) {
#line 4116
      if (! (context & 1U)) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 4116
    if (node->constraint & 8U) {
#line 4116
      if (context & 1U) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4116
    if (node->constraint & 32U) {
#line 4116
      if (! (context & (unsigned int )(1 << 1))) {
#line 4117
        return ((_Bool)0);
      } else {
#line 4116
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4116
    if (node->constraint & 128U) {
#line 4116
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 4117
        return ((_Bool)0);
      }
    }
  }
#line 4120
  return ((_Bool)1);
}
}
#line 4125 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t extend_buffers___0(re_match_context_t *mctx ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  long tmp ;
  long tmp___0 ;
  re_dfastate_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 4130
  pstr = & mctx->input;
#line 4133
  tmp = __builtin_expect((long )(9223372036854775807UL / sizeof(re_dfastate_t *) <= pstr->bufs_len),
                         0L);
  }
#line 4133
  if (tmp) {
#line 4134
    return ((reg_errcode_t )12);
  }
  {
#line 4137
  ret = re_string_realloc_buffers___0(pstr, pstr->bufs_len * 2UL);
#line 4138
  tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 4138
  if (tmp___0) {
#line 4139
    return (ret);
  }
#line 4141
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 4147
    tmp___1 = realloc((void *)mctx->state_log, (pstr->bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 4147
    new_array = (re_dfastate_t **)tmp___1;
#line 4149
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4149
    if (tmp___2) {
#line 4150
      return ((reg_errcode_t )12);
    }
#line 4151
    mctx->state_log = new_array;
  }
#line 4155
  if (pstr->icase) {
#line 4158
    if (pstr->mb_cur_max > 1) {
      {
#line 4160
      ret = build_wcs_upper_buffer___0(pstr);
#line 4161
      tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 4161
      if (tmp___3) {
#line 4162
        return (ret);
      }
    } else {
      {
#line 4166
      build_upper_buffer___0(pstr);
      }
    }
  } else
#line 4171
  if (pstr->mb_cur_max > 1) {
    {
#line 4172
    build_wcs_buffer___0(pstr);
    }
  } else
#line 4176
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
#line 4177
    re_string_translate_buffer___0(pstr);
    }
  }
#line 4180
  return ((reg_errcode_t )0);
}
}
#line 4188 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_init___0(re_match_context_t *mctx , int eflags , Idx n ) 
{ 
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 4192
  mctx->eflags = eflags;
#line 4193
  mctx->match_last = (Idx )-1;
#line 4194
  if (n > 0UL) {
#line 4197
    if (sizeof(struct re_backref_cache_entry ) < sizeof(re_sub_match_top_t *)) {
#line 4197
      tmp = sizeof(re_sub_match_top_t *);
    } else {
#line 4197
      tmp = sizeof(struct re_backref_cache_entry );
    }
    {
#line 4197
    max_object_size = tmp;
#line 4200
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < n),
                               0L);
    }
#line 4200
    if (tmp___0) {
#line 4201
      return ((reg_errcode_t )12);
    }
    {
#line 4203
    tmp___1 = malloc(n * sizeof(struct re_backref_cache_entry ));
#line 4203
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp___1;
#line 4204
    tmp___2 = malloc(n * sizeof(re_sub_match_top_t *));
#line 4204
    mctx->sub_tops = (re_sub_match_top_t **)tmp___2;
    }
#line 4205
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 4205
      tmp___3 = 1;
    } else
#line 4205
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 4205
      tmp___3 = 1;
    } else {
#line 4205
      tmp___3 = 0;
    }
    {
#line 4205
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 4205
    if (tmp___4) {
#line 4206
      return ((reg_errcode_t )12);
    }
  }
#line 4213
  mctx->abkref_ents = n;
#line 4214
  mctx->max_mb_elem_len = 1;
#line 4215
  mctx->asub_tops = n;
#line 4216
  return ((reg_errcode_t )0);
}
}
#line 4223 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void match_ctx_clean___0(re_match_context_t *mctx ) 
{ 
  Idx st_idx ;
  Idx sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4228
  st_idx = (Idx )0;
  {
#line 4228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4228
    if (! (st_idx < mctx->nsub_tops)) {
#line 4228
      goto while_break;
    }
#line 4231
    top = *(mctx->sub_tops + st_idx);
#line 4232
    sl_idx = (Idx )0;
    {
#line 4232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4232
      if (! (sl_idx < top->nlasts)) {
#line 4232
        goto while_break___0;
      }
      {
#line 4234
      last = *(top->lasts + sl_idx);
#line 4235
      free((void *)last->path.array);
#line 4236
      free((void *)last);
#line 4232
      sl_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4238
    free((void *)top->lasts);
    }
#line 4239
    if (top->path) {
      {
#line 4241
      free((void *)(top->path)->array);
#line 4242
      free((void *)top->path);
      }
    }
    {
#line 4244
    free((void *)top);
#line 4228
    st_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4247
  mctx->nsub_tops = (Idx )0;
#line 4248
  mctx->nbkref_ents = (Idx )0;
#line 4249
  return;
}
}
#line 4253 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void match_ctx_free___0(re_match_context_t *mctx ) 
{ 


  {
  {
#line 4258
  match_ctx_clean___0(mctx);
#line 4259
  free((void *)mctx->sub_tops);
#line 4260
  free((void *)mctx->bkref_ents);
  }
#line 4261
  return;
}
}
#line 4268 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_entry___0(re_match_context_t *mctx , Idx node ,
                                             Idx str_idx , Idx from , Idx to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 4273
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
#line 4276
    tmp = realloc((void *)mctx->bkref_ents, (mctx->abkref_ents * 2UL) * sizeof(struct re_backref_cache_entry ));
#line 4276
    new_entry = (struct re_backref_cache_entry *)tmp;
#line 4278
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
#line 4278
    if (tmp___0) {
      {
#line 4280
      free((void *)mctx->bkref_ents);
      }
#line 4281
      return ((reg_errcode_t )12);
    }
    {
#line 4283
    mctx->bkref_ents = new_entry;
#line 4284
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * mctx->abkref_ents);
#line 4286
    mctx->abkref_ents *= 2UL;
    }
  }
#line 4288
  if (mctx->nbkref_ents > 0UL) {
#line 4288
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->str_idx == str_idx) {
#line 4290
      (mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->more = (char)1;
    }
  }
#line 4292
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4293
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4294
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4295
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4305
  if (from == to) {
#line 4305
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)65535;
  } else {
#line 4305
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)0;
  }
#line 4308
  tmp___1 = mctx->nbkref_ents;
#line 4308
  (mctx->nbkref_ents) ++;
#line 4308
  (mctx->bkref_ents + tmp___1)->more = (char)0;
#line 4309
  if ((Idx )mctx->max_mb_elem_len < to - from) {
#line 4310
    mctx->max_mb_elem_len = (int )(to - from);
  }
#line 4311
  return ((reg_errcode_t )0);
}
}
#line 4317 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static Idx search_cur_bkref_entry___0(re_match_context_t const   *mctx , Idx str_idx ) 
{ 
  Idx left ;
  Idx right ;
  Idx mid ;
  Idx last ;

  {
#line 4322
  right = (Idx )mctx->nbkref_ents;
#line 4322
  last = right;
#line 4323
  left = (Idx )0;
  {
#line 4323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4323
    if (! (left < right)) {
#line 4323
      goto while_break;
    }
#line 4325
    mid = (left + right) / 2UL;
#line 4326
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4327
      left = mid + 1UL;
    } else {
#line 4329
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4331
  if (left < last) {
#line 4331
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4332
      return (left);
    } else {
#line 4334
      return ((Idx )-1);
    }
  } else {
#line 4334
    return ((Idx )-1);
  }
}
}
#line 4340 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_subtop___0(re_match_context_t *mctx , Idx node ,
                                              Idx str_idx ) 
{ 
  Idx new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 4348
  tmp___1 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
  }
#line 4348
  if (tmp___1) {
    {
#line 4350
    new_asub_tops = mctx->asub_tops * 2UL;
#line 4351
    tmp = realloc((void *)mctx->sub_tops, new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4351
    new_array = (re_sub_match_top_t **)tmp;
#line 4354
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4354
    if (tmp___0) {
#line 4355
      return ((reg_errcode_t )12);
    }
#line 4356
    mctx->sub_tops = new_array;
#line 4357
    mctx->asub_tops = new_asub_tops;
  }
  {
#line 4359
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
#line 4359
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___2;
#line 4360
  tmp___3 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
  }
#line 4360
  if (tmp___3) {
#line 4361
    return ((reg_errcode_t )12);
  }
#line 4362
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4363
  tmp___4 = mctx->nsub_tops;
#line 4363
  (mctx->nsub_tops) ++;
#line 4363
  (*(mctx->sub_tops + tmp___4))->str_idx = str_idx;
#line 4364
  return ((reg_errcode_t )0);
}
}
#line 4370 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast___0(re_sub_match_top_t *subtop ,
                                                      Idx node , Idx str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  Idx new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 4375
  tmp___1 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
  }
#line 4375
  if (tmp___1) {
    {
#line 4377
    new_alasts = 2UL * subtop->alasts + 1UL;
#line 4378
    tmp = realloc((void *)subtop->lasts, new_alasts * sizeof(re_sub_match_last_t *));
#line 4378
    new_array = (re_sub_match_last_t **)tmp;
#line 4381
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4381
    if (tmp___0) {
#line 4382
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4383
    subtop->lasts = new_array;
#line 4384
    subtop->alasts = new_alasts;
  }
  {
#line 4386
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
#line 4386
  new_entry = (re_sub_match_last_t *)tmp___2;
#line 4387
  tmp___3 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
  }
#line 4387
  if (tmp___3) {
#line 4389
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4390
    new_entry->node = node;
#line 4391
    new_entry->str_idx = str_idx;
#line 4392
    (subtop->nlasts) ++;
  }
#line 4394
  return (new_entry);
}
}
#line 4397 "/home/khheo/project/benchmark/coreutils-7.1/lib/regexec.c"
static void sift_ctx_init___0(re_sift_context_t *sctx , re_dfastate_t **sifted_sts ,
                              re_dfastate_t **limited_sts , Idx last_node , Idx last_str_idx ) 
{ 


  {
  {
#line 4402
  sctx->sifted_states = sifted_sts;
#line 4403
  sctx->limited_states = limited_sts;
#line 4404
  sctx->last_node = last_node;
#line 4405
  sctx->last_str_idx = last_str_idx;
#line 4406
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
  }
#line 4407
  return;
}
}
#line 50 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens0.c"
static void save_token___0(struct Tokens *t ) 
{ 
  size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
#line 54
  __o = (struct obstack  const  *)(& t->o_data);
#line 54
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
#line 55
  __o1 = & t->o_data;
#line 55
  __value = (void *)__o1->object_base;
#line 55
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 55
    __o1->maybe_empty_object = 1U;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp = __o1->object_base;
  } else {
#line 55
    tmp = (char *)0;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp___0 = __o1->object_base;
  } else {
#line 55
    tmp___0 = (char *)0;
  }
#line 55
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 55
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 55
    __o1->next_free = __o1->chunk_limit;
  }
#line 55
  __o1->object_base = __o1->next_free;
#line 55
  s = (char const   *)__value;
#line 56
  __o___0 = & t->o_tok;
#line 56
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
    {
#line 56
    _obstack_newchunk(__o___0, (int )sizeof(void *));
    }
  }
#line 56
  __o1___0 = __o___0;
#line 56
  *((void const   **)__o1___0->next_free) = (void const   *)s;
#line 56
  __o1___0->next_free += sizeof(void const   *);
#line 57
  __o___1 = & t->o_tok_len;
#line 57
  __len = (int )sizeof(len);
#line 57
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
    {
#line 57
    _obstack_newchunk(__o___1, __len);
    }
  }
  {
#line 57
  memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(& len),
         (size_t )__len);
#line 57
  __o___1->next_free += __len;
#line 58
  (t->n_tok) ++;
  }
#line 59
  return;
}
}
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 73 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
static char const   *saved_delim___0  =    (char const   *)((void *)0);
#line 74 "/home/khheo/project/benchmark/coreutils-7.1/lib/readtokens.c"
static char isdelim___0[256]  ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void randread_error___0(void const   *file_name___3 ) 
{ 
  char *tmp ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 122
  if (file_name___3) {
    {
#line 123
    tmp = quotearg_colon((char const   *)file_name___3);
#line 123
    tmp___2 = __errno_location();
    }
#line 123
    if (*tmp___2 == 0) {
#line 123
      tmp___1 = "%s: end of file";
    } else {
#line 123
      tmp___1 = "%s: read error";
    }
    {
#line 123
    tmp___3 = gettext(tmp___1);
#line 123
    tmp___4 = __errno_location();
#line 123
    error((int )exit_failure, *tmp___4, (char const   *)tmp___3, tmp);
    }
  }
  {
#line 126
  abort();
  }
}
}
#line 132 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static struct randread_source *simple_new___0(FILE *source , void const   *handler_arg ) 
{ 
  struct randread_source *s ;
  void *tmp ;

  {
  {
#line 135
  tmp = xmalloc(sizeof(*s));
#line 135
  s = (struct randread_source *)tmp;
#line 136
  s->source = source;
#line 137
  s->handler = & randread_error___0;
#line 138
  s->handler_arg = handler_arg;
  }
#line 139
  return (s);
}
}
#line 209 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void readsource___0(struct randread_source *s , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  size_t tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    tmp = fread_unlocked((void */* __restrict  */)p, sizeof(*p), size, (FILE */* __restrict  */)s->source);
#line 214
    inbytes = tmp;
#line 215
    tmp___0 = __errno_location();
#line 215
    fread_errno = *tmp___0;
#line 216
    p += inbytes;
#line 217
    size -= inbytes;
    }
#line 218
    if (size == 0UL) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___1 = __errno_location();
#line 220
    tmp___3 = ferror_unlocked(s->source);
    }
#line 220
    if (tmp___3) {
#line 220
      *tmp___1 = fread_errno;
    } else {
#line 220
      *tmp___1 = 0;
    }
    {
#line 221
    (*(s->handler))(s->handler_arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 229 "/home/khheo/project/benchmark/coreutils-7.1/lib/randread.c"
static void readisaac___0(struct isaac *isaac , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  uint32_t *wp ;

  {
#line 232
  inbytes = isaac->buffered;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (size <= inbytes) {
      {
#line 238
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
             size);
#line 239
      isaac->buffered = inbytes - size;
      }
#line 240
      return;
    }
    {
#line 243
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
           inbytes);
#line 244
    p += inbytes;
#line 245
    size -= inbytes;
    }
#line 249
    if ((size_t )p % (unsigned long )(& ((struct __anonstruct_833865290___5 *)0)->x) == 0UL) {
#line 251
      wp = (uint32_t *)p;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 252
        if (! ((unsigned long )(1 << 8) * sizeof(uint32_t ) <= size)) {
#line 252
          goto while_break___0;
        }
        {
#line 254
        isaac_refill(& isaac->state, (uint32_t *)wp);
#line 255
        wp += 1 << 8;
#line 256
        size -= (unsigned long )(1 << 8) * sizeof(uint32_t );
        }
#line 257
        if (size == 0UL) {
#line 259
          isaac->buffered = (size_t )0;
#line 260
          return;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 263
      p = (unsigned char *)wp;
    }
    {
#line 266
    isaac_refill(& isaac->state, (uint32_t *)(isaac->data.w));
#line 267
    inbytes = (unsigned long )(1 << 8) * sizeof(uint32_t );
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 31 "/home/khheo/project/benchmark/coreutils-7.1/lib/randperm.c"
static size_t ceil_lg___0(size_t n ) 
{ 
  size_t b ;

  {
#line 34
  b = (size_t )0;
#line 35
  n --;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (n != 0UL)) {
#line 35
      goto while_break;
    }
#line 36
    b ++;
#line 35
    n /= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (b);
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_mix___0(struct isaac_state *s , uint32_t const   *seed ) 
{ 
  int i ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;

  {
#line 115
  a = s->iv[0];
#line 116
  b = s->iv[1];
#line 117
  c = s->iv[2];
#line 118
  d = s->iv[3];
#line 119
  e = s->iv[4];
#line 120
  f = s->iv[5];
#line 121
  g = s->iv[6];
#line 122
  h = s->iv[7];
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 1 << 8)) {
#line 124
      goto while_break;
    }
#line 126
    a += (uint32_t )*(seed + i);
#line 127
    b += (uint32_t )*(seed + (i + 1));
#line 128
    c += (uint32_t )*(seed + (i + 2));
#line 129
    d += (uint32_t )*(seed + (i + 3));
#line 130
    e += (uint32_t )*(seed + (i + 4));
#line 131
    f += (uint32_t )*(seed + (i + 5));
#line 132
    g += (uint32_t )*(seed + (i + 6));
#line 133
    h += (uint32_t )*(seed + (i + 7));
#line 135
    a ^= b << 11;
#line 135
    d += a;
#line 135
    b += c;
#line 135
    b ^= c >> 2;
#line 135
    e += b;
#line 135
    c += d;
#line 135
    c ^= d << 8;
#line 135
    f += c;
#line 135
    d += e;
#line 135
    d ^= e >> 16;
#line 135
    g += d;
#line 135
    e += f;
#line 135
    e ^= f << 10;
#line 135
    h += e;
#line 135
    f += g;
#line 135
    f ^= g >> 4;
#line 135
    a += f;
#line 135
    g += h;
#line 135
    g ^= h << 8;
#line 135
    b += g;
#line 135
    h += a;
#line 135
    h ^= a >> 9;
#line 135
    c += h;
#line 135
    a += b;
#line 137
    s->mm[i] = a;
#line 138
    s->mm[i + 1] = b;
#line 139
    s->mm[i + 2] = c;
#line 140
    s->mm[i + 3] = d;
#line 141
    s->mm[i + 4] = e;
#line 142
    s->mm[i + 5] = f;
#line 143
    s->mm[i + 6] = g;
#line 144
    s->mm[i + 7] = h;
#line 124
    i += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  s->iv[0] = a;
#line 148
  s->iv[1] = b;
#line 149
  s->iv[2] = c;
#line 150
  s->iv[3] = d;
#line 151
  s->iv[4] = e;
#line 152
  s->iv[5] = f;
#line 153
  s->iv[6] = g;
#line 154
  s->iv[7] = h;
#line 155
  return;
}
}
#line 217
static void isaac_seed_start___0(struct isaac_state *s ) ;
#line 217 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static uint32_t const   iv___0[8]  = 
#line 217
  {      (uint32_t const   )325574490,      (uint32_t const   )2514026585U,      (uint32_t const   )3273014859U,      (uint32_t const   )255990488, 
        (uint32_t const   )3643427448U,      (uint32_t const   )2769960009U,      (uint32_t const   )3304057371U,      (uint32_t const   )811634969};
#line 214 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_start___0(struct isaac_state *s ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 232
  memset((void *)(s->mm), 0, sizeof(s->mm));
#line 233
  memcpy((void */* __restrict  */)(s->iv), (void const   */* __restrict  */)(iv___0),
         sizeof(s->iv));
#line 236
  tmp___0 = (uint32_t )0;
#line 236
  s->c = tmp___0;
#line 236
  tmp = tmp___0;
#line 236
  s->b = tmp;
#line 236
  s->a = tmp;
  }
#line 237
  return;
}
}
#line 240 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_data___0(struct isaac_state *s , void const   *buffer , size_t size ) 
{ 
  unsigned char const   *buf___1 ;
  unsigned char *p ;
  size_t avail ;
  size_t i ;

  {
#line 243
  buf___1 = (unsigned char const   *)buffer;
#line 248
  avail = sizeof(s->mm) - (unsigned long )s->c;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (size > avail)) {
#line 251
      goto while_break;
    }
#line 253
    p = (unsigned char *)(s->mm) + s->c;
#line 254
    i = (size_t )0;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (i < avail)) {
#line 254
        goto while_break___0;
      }
#line 255
      *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___1 + i));
#line 254
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 256
    buf___1 += avail;
#line 257
    size -= avail;
#line 258
    isaac_mix___0(s, (uint32_t const   *)(s->mm));
#line 259
    s->c = (uint32_t )0;
#line 260
    avail = sizeof(s->mm);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  p = (unsigned char *)(s->mm) + s->c;
#line 265
  i = (size_t )0;
  {
#line 265
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 265
    if (! (i < size)) {
#line 265
      goto while_break___1;
    }
#line 266
    *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___1 + i));
#line 265
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 267
  s->c = (uint32_t )size;
#line 268
  return;
}
}
#line 272 "/home/khheo/project/benchmark/coreutils-7.1/lib/rand-isaac.c"
static void isaac_seed_finish___0(struct isaac_state *s ) 
{ 


  {
  {
#line 275
  isaac_mix___0(s, (uint32_t const   *)(s->mm));
#line 276
  isaac_mix___0(s, (uint32_t const   *)(s->mm));
#line 278
  s->c = (uint32_t )0;
  }
#line 279
  return;
}
}
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 231
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 87 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct quoting_options default_quoting_options___0  ;
#line 150 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style___0(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
  {
#line 154
  o.style = style;
#line 155
  o.flags = 0;
#line 156
  memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
  }
#line 157
  return (o);
}
}
#line 162 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char const   *gettext_quote___0(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;

  {
  {
#line 165
  tmp = gettext(msgid);
#line 165
  translation = (char const   *)tmp;
  }
#line 166
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 166
    if ((unsigned int )s == 7U) {
#line 167
      translation = "\"";
    }
  }
#line 168
  return (translation);
}
}
#line 184 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled___0(char *buffer , size_t buffersize , char const   *arg ,
                                           size_t argsize , enum quoting_style quoting_style ,
                                           int flags , unsigned int const   *quote_these_too ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  int tmp___3 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___4 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___5 ;
  size_t j ;
  int tmp___6 ;
  int tmp___7 ;
  size_t ilim ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 191
  len = (size_t )0;
#line 192
  quote_string = (char const   *)0;
#line 193
  quote_string_len = (size_t )0;
#line 194
  backslash_escapes = (_Bool)0;
#line 195
  tmp = __ctype_get_mb_cur_max();
#line 195
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 196
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 209
  if ((unsigned int )quoting_style == 4U) {
#line 209
    goto case_4;
  }
#line 213
  if ((unsigned int )quoting_style == 3U) {
#line 213
    goto case_3;
  }
#line 221
  if ((unsigned int )quoting_style == 5U) {
#line 221
    goto case_5;
  }
#line 227
  if ((unsigned int )quoting_style == 7U) {
#line 227
    goto case_7;
  }
#line 227
  if ((unsigned int )quoting_style == 6U) {
#line 227
    goto case_7;
  }
#line 260
  if ((unsigned int )quoting_style == 1U) {
#line 260
    goto case_1;
  }
#line 264
  if ((unsigned int )quoting_style == 2U) {
#line 264
    goto case_2;
  }
#line 271
  if ((unsigned int )quoting_style == 0U) {
#line 271
    goto case_0;
  }
#line 275
  goto switch_default;
  case_4: /* CIL Label */ 
#line 210
  quoting_style = (enum quoting_style )3;
#line 211
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 214
  if (! elide_outer_quotes) {
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 215
      if (len < buffersize) {
#line 215
        *(buffer + len) = (char )'\"';
      }
#line 215
      len ++;
#line 215
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 216
  backslash_escapes = (_Bool)1;
#line 217
  quote_string = "\"";
#line 218
  quote_string_len = (size_t )1;
#line 219
  goto switch_break;
  case_5: /* CIL Label */ 
#line 222
  backslash_escapes = (_Bool)1;
#line 223
  elide_outer_quotes = (_Bool)0;
#line 224
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 249
  tmp___0 = gettext_quote___0("`", quoting_style);
#line 249
  left = tmp___0;
#line 250
  tmp___1 = gettext_quote___0("\'", quoting_style);
#line 250
  right = tmp___1;
  }
#line 251
  if (! elide_outer_quotes) {
#line 252
    quote_string = left;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! *quote_string) {
#line 252
        goto while_break___0;
      }
      {
#line 253
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 253
        if (len < buffersize) {
#line 253
          *(buffer + len) = (char )*quote_string;
        }
#line 253
        len ++;
#line 253
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 252
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 254
  backslash_escapes = (_Bool)1;
#line 255
  quote_string = right;
#line 256
  quote_string_len = strlen(quote_string);
  }
#line 258
  goto switch_break;
  case_1: /* CIL Label */ 
#line 261
  quoting_style = (enum quoting_style )2;
#line 262
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 265
  if (! elide_outer_quotes) {
    {
#line 266
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 266
      if (len < buffersize) {
#line 266
        *(buffer + len) = (char )'\'';
      }
#line 266
      len ++;
#line 266
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 267
  quote_string = "\'";
#line 268
  quote_string_len = (size_t )1;
#line 269
  goto switch_break;
  case_0: /* CIL Label */ 
#line 272
  elide_outer_quotes = (_Bool)0;
#line 273
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 276
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 279
  i = (size_t )0;
  {
#line 279
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 279
    if (argsize == 0xffffffffffffffffUL) {
#line 279
      tmp___8 = (int const   )*(arg + i) == 0;
    } else {
#line 279
      tmp___8 = i == argsize;
    }
#line 279
    if (tmp___8) {
#line 279
      goto while_break___3;
    }
#line 284
    if (backslash_escapes) {
#line 284
      if (quote_string_len) {
#line 284
        if (i + quote_string_len <= argsize) {
          {
#line 284
          tmp___2 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 284
          if (tmp___2 == 0) {
#line 289
            if (elide_outer_quotes) {
#line 290
              goto force_outer_quoting_style;
            }
            {
#line 291
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 291
              if (len < buffersize) {
#line 291
                *(buffer + len) = (char )'\\';
              }
#line 291
              len ++;
#line 291
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 294
    c = (unsigned char )*(arg + i);
    {
#line 297
    if ((int )c == 0) {
#line 297
      goto case_0___0;
    }
#line 314
    if ((int )c == 63) {
#line 314
      goto case_63;
    }
#line 352
    if ((int )c == 7) {
#line 352
      goto case_7___0;
    }
#line 353
    if ((int )c == 8) {
#line 353
      goto case_8;
    }
#line 354
    if ((int )c == 12) {
#line 354
      goto case_12;
    }
#line 355
    if ((int )c == 10) {
#line 355
      goto case_10;
    }
#line 356
    if ((int )c == 13) {
#line 356
      goto case_13;
    }
#line 357
    if ((int )c == 9) {
#line 357
      goto case_9;
    }
#line 358
    if ((int )c == 11) {
#line 358
      goto case_11;
    }
#line 359
    if ((int )c == 92) {
#line 359
      goto case_92;
    }
#line 378
    if ((int )c == 125) {
#line 378
      goto case_125;
    }
#line 378
    if ((int )c == 123) {
#line 378
      goto case_125;
    }
#line 382
    if ((int )c == 126) {
#line 382
      goto case_126;
    }
#line 382
    if ((int )c == 35) {
#line 382
      goto case_126;
    }
#line 394
    if ((int )c == 124) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 96) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 94) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 91) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 62) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 61) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 60) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 59) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 42) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 41) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 40) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 38) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 36) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 34) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 33) {
#line 394
      goto case_124;
    }
#line 394
    if ((int )c == 32) {
#line 394
      goto case_124;
    }
#line 404
    if ((int )c == 39) {
#line 404
      goto case_39___0;
    }
#line 426
    if ((int )c == 122) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 121) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 120) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 119) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 118) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 117) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 116) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 115) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 114) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 113) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 112) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 111) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 110) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 109) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 108) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 107) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 106) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 105) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 104) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 103) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 102) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 101) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 100) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 99) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 98) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 97) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 95) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 93) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 90) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 89) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 88) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 87) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 86) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 85) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 84) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 83) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 82) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 81) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 80) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 79) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 78) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 77) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 76) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 75) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 74) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 73) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 72) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 71) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 70) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 69) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 68) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 67) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 66) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 65) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 58) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 57) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 56) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 55) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 54) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 53) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 52) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 51) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 50) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 49) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 48) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 47) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 46) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 45) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 44) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 43) {
#line 426
      goto case_122;
    }
#line 426
    if ((int )c == 37) {
#line 426
      goto case_122;
    }
#line 431
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 298
    if (backslash_escapes) {
#line 300
      if (elide_outer_quotes) {
#line 301
        goto force_outer_quoting_style;
      }
      {
#line 302
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 302
        if (len < buffersize) {
#line 302
          *(buffer + len) = (char )'\\';
        }
#line 302
        len ++;
#line 302
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 303
      if (i + 1UL < argsize) {
#line 303
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 303
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 305
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 305
              if (len < buffersize) {
#line 305
                *(buffer + len) = (char )'0';
              }
#line 305
              len ++;
#line 305
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 306
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 306
              if (len < buffersize) {
#line 306
                *(buffer + len) = (char )'0';
              }
#line 306
              len ++;
#line 306
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 308
      c = (unsigned char )'0';
    } else
#line 310
    if (flags & 1) {
#line 311
      goto __Cont;
    }
#line 312
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 317
    if ((unsigned int )quoting_style == 2U) {
#line 317
      goto case_2___0;
    }
#line 322
    if ((unsigned int )quoting_style == 3U) {
#line 322
      goto case_3___0;
    }
#line 347
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 318
    if (elide_outer_quotes) {
#line 319
      goto force_outer_quoting_style;
    }
#line 320
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 323
    if (flags & 4) {
#line 323
      if (i + 2UL < argsize) {
#line 323
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 329
            goto case_62;
          }
#line 329
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 329
            goto case_62;
          }
#line 342
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 332
          if (elide_outer_quotes) {
#line 333
            goto force_outer_quoting_style;
          }
#line 334
          c = (unsigned char )*(arg + (i + 2UL));
#line 335
          i += 2UL;
          {
#line 336
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 336
            if (len < buffersize) {
#line 336
              *(buffer + len) = (char )'?';
            }
#line 336
            len ++;
#line 336
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 337
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 337
            if (len < buffersize) {
#line 337
              *(buffer + len) = (char )'\"';
            }
#line 337
            len ++;
#line 337
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 338
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 338
            if (len < buffersize) {
#line 338
              *(buffer + len) = (char )'\"';
            }
#line 338
            len ++;
#line 338
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 339
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 339
            if (len < buffersize) {
#line 339
              *(buffer + len) = (char )'?';
            }
#line 339
            len ++;
#line 339
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 340
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 343
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 345
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 348
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 350
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 352
    esc = (unsigned char )'a';
#line 352
    goto c_escape;
    case_8: /* CIL Label */ 
#line 353
    esc = (unsigned char )'b';
#line 353
    goto c_escape;
    case_12: /* CIL Label */ 
#line 354
    esc = (unsigned char )'f';
#line 354
    goto c_escape;
    case_10: /* CIL Label */ 
#line 355
    esc = (unsigned char )'n';
#line 355
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 356
    esc = (unsigned char )'r';
#line 356
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 357
    esc = (unsigned char )'t';
#line 357
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 358
    esc = (unsigned char )'v';
#line 358
    goto c_escape;
    case_92: /* CIL Label */ 
#line 359
    esc = c;
#line 362
    if (backslash_escapes) {
#line 362
      if (elide_outer_quotes) {
#line 362
        if (quote_string_len) {
#line 363
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 366
    if ((unsigned int )quoting_style == 2U) {
#line 366
      if (elide_outer_quotes) {
#line 368
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 371
    if (backslash_escapes) {
#line 373
      c = esc;
#line 374
      goto store_escape;
    }
#line 376
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 379
    if (argsize == 0xffffffffffffffffUL) {
#line 379
      tmp___3 = (int const   )*(arg + 1) == 0;
    } else {
#line 379
      tmp___3 = argsize == 1UL;
    }
#line 379
    if (! tmp___3) {
#line 380
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 383
    if (i != 0UL) {
#line 384
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 399
    if ((unsigned int )quoting_style == 2U) {
#line 399
      if (elide_outer_quotes) {
#line 401
        goto force_outer_quoting_style;
      }
    }
#line 402
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 405
    if ((unsigned int )quoting_style == 2U) {
#line 407
      if (elide_outer_quotes) {
#line 408
        goto force_outer_quoting_style;
      }
      {
#line 409
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 409
        if (len < buffersize) {
#line 409
          *(buffer + len) = (char )'\'';
        }
#line 409
        len ++;
#line 409
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 410
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 410
        if (len < buffersize) {
#line 410
          *(buffer + len) = (char )'\\';
        }
#line 410
        len ++;
#line 410
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 411
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 411
        if (len < buffersize) {
#line 411
          *(buffer + len) = (char )'\'';
        }
#line 411
        len ++;
#line 411
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 413
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 429
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 443
    if (unibyte_locale) {
      {
#line 445
      m = (size_t )1;
#line 446
      tmp___4 = __ctype_b_loc();
#line 446
      printable = (_Bool )(((int const   )*(*tmp___4 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 451
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 453
      m = (size_t )0;
#line 454
      printable = (_Bool)1;
      }
#line 455
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 456
        argsize = strlen(arg);
        }
      }
      {
#line 458
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 461
        tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 461
        bytes = tmp___5;
        }
#line 463
        if (bytes == 0UL) {
#line 464
          goto while_break___15;
        } else
#line 465
        if (bytes == 0xffffffffffffffffUL) {
#line 467
          printable = (_Bool)0;
#line 468
          goto while_break___15;
        } else
#line 470
        if (bytes == 0xfffffffffffffffeUL) {
#line 472
          printable = (_Bool)0;
          {
#line 473
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 473
            if (i + m < argsize) {
#line 473
              if (! *(arg + (i + m))) {
#line 473
                goto while_break___16;
              }
            } else {
#line 473
              goto while_break___16;
            }
#line 474
            m ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 475
          goto while_break___15;
        } else {
#line 483
          if (elide_outer_quotes) {
#line 483
            if ((unsigned int )quoting_style == 2U) {
#line 487
              j = (size_t )1;
              {
#line 487
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 487
                if (! (j < bytes)) {
#line 487
                  goto while_break___17;
                }
                {
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 491
                  goto case_124___0;
                }
#line 491
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 491
                  goto case_124___0;
                }
#line 494
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 492
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 495
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 487
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            }
          }
          {
#line 499
          tmp___6 = iswprint((wint_t )w);
          }
#line 499
          if (! tmp___6) {
#line 500
            printable = (_Bool)0;
          }
#line 501
          m += bytes;
        }
        {
#line 458
        tmp___7 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 458
        if (tmp___7) {
#line 458
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 507
    if (1UL < m) {
#line 507
      goto _L;
    } else
#line 507
    if (backslash_escapes) {
#line 507
      if (! printable) {
        _L: /* CIL Label */ 
#line 511
        ilim = i + m;
        {
#line 513
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 515
          if (backslash_escapes) {
#line 515
            if (! printable) {
#line 517
              if (elide_outer_quotes) {
#line 518
                goto force_outer_quoting_style;
              }
              {
#line 519
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 519
                if (len < buffersize) {
#line 519
                  *(buffer + len) = (char )'\\';
                }
#line 519
                len ++;
#line 519
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 520
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 520
                if (len < buffersize) {
#line 520
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 520
                len ++;
#line 520
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 521
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 521
                if (len < buffersize) {
#line 521
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 521
                len ++;
#line 521
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 522
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 524
          if (ilim <= i + 1UL) {
#line 525
            goto while_break___18;
          }
          {
#line 526
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 526
            if (len < buffersize) {
#line 526
              *(buffer + len) = (char )c;
            }
#line 526
            len ++;
#line 526
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 527
          i ++;
#line 527
          c = (unsigned char )*(arg + i);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 530
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 535
    if (backslash_escapes) {
#line 535
      goto _L___0;
    } else
#line 535
    if (elide_outer_quotes) {
      _L___0: /* CIL Label */ 
#line 535
      if (quote_these_too) {
#line 535
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 538
          goto store_c;
        }
      } else {
#line 538
        goto store_c;
      }
    } else {
#line 538
      goto store_c;
    }
    store_escape: 
#line 541
    if (elide_outer_quotes) {
#line 542
      goto force_outer_quoting_style;
    }
    {
#line 543
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 543
      if (len < buffersize) {
#line 543
        *(buffer + len) = (char )'\\';
      }
#line 543
      len ++;
#line 543
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 546
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 546
      if (len < buffersize) {
#line 546
        *(buffer + len) = (char )c;
      }
#line 546
      len ++;
#line 546
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 279
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 549
  if (len == 0UL) {
#line 549
    if ((unsigned int )quoting_style == 2U) {
#line 549
      if (elide_outer_quotes) {
#line 551
        goto force_outer_quoting_style;
      }
    }
  }
#line 553
  if (quote_string) {
#line 553
    if (! elide_outer_quotes) {
      {
#line 554
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 554
        if (! *quote_string) {
#line 554
          goto while_break___25;
        }
        {
#line 555
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 555
          if (len < buffersize) {
#line 555
            *(buffer + len) = (char )*quote_string;
          }
#line 555
          len ++;
#line 555
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 554
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 557
  if (len < buffersize) {
#line 558
    *(buffer + len) = (char )'\000';
  }
#line 559
  return (len);
  force_outer_quoting_style: 
  {
#line 564
  tmp___9 = quotearg_buffer_restyled___0(buffer, buffersize, arg, argsize, quoting_style,
                                         flags & -3, (unsigned int const   *)((void *)0));
  }
#line 564
  return (tmp___9);
}
}
#line 633 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char slot0___0[256]  ;
#line 634 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static unsigned int nslots___0  =    1U;
#line 635 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct slotvec slotvec0___0  =    {sizeof(slot0___0), slot0___0};
#line 636 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static struct slotvec *slotvec___0  =    & slotvec0___0;
#line 667 "/home/khheo/project/benchmark/coreutils-7.1/lib/quotearg.c"
static char *quotearg_n_options___0(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 671
  tmp = __errno_location();
#line 671
  e = *tmp;
#line 673
  n0 = (unsigned int )n;
#line 674
  sv = slotvec___0;
  }
#line 676
  if (n < 0) {
    {
#line 677
    abort();
    }
  }
#line 679
  if (nslots___0 <= n0) {
#line 686
    n1 = (size_t )(n0 + 1U);
#line 687
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0___0));
#line 689
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 689
      tmp___0 = -1;
    } else {
#line 689
      tmp___0 = -2;
    }
#line 689
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 690
      xalloc_die();
      }
    }
#line 692
    if (preallocated) {
#line 692
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 692
      tmp___1 = sv;
    }
    {
#line 692
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 692
    sv = (struct slotvec *)tmp___2;
#line 692
    slotvec___0 = sv;
    }
#line 693
    if (preallocated) {
#line 694
      *sv = slotvec0___0;
    }
    {
#line 695
    memset((void *)(sv + nslots___0), 0, (n1 - (size_t )nslots___0) * sizeof(*sv));
#line 696
    nslots___0 = (unsigned int )n1;
    }
  }
  {
#line 700
  size = (sv + n)->size;
#line 701
  val = (sv + n)->val;
#line 703
  flags = (int )(options->flags | 1);
#line 704
  tmp___3 = quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                         flags, (unsigned int const   *)(options->quote_these_too));
#line 704
  qsize = tmp___3;
  }
#line 708
  if (size <= qsize) {
#line 710
    size = qsize + 1UL;
#line 710
    (sv + n)->size = size;
#line 711
    if ((unsigned long )val != (unsigned long )(slot0___0)) {
      {
#line 712
      free((void *)val);
      }
    }
    {
#line 713
    val = xcharalloc(size);
#line 713
    (sv + n)->val = val;
#line 714
    quotearg_buffer_restyled___0(val, size, arg, argsize, (enum quoting_style )options->style,
                                 flags, (unsigned int const   *)(options->quote_these_too));
    }
  }
  {
#line 718
  tmp___4 = __errno_location();
#line 718
  *tmp___4 = e;
  }
#line 719
  return (val);
}
}
#line 127 "/home/khheo/project/benchmark/coreutils-7.1/lib/canonicalize.c"
static _Bool seen_triple___0(Hash_table **ht___1 , char const   *filename , struct stat  const  *st ) 
{ 
  size_t initial_capacity ;
  _Bool tmp ;

  {
#line 130
  if ((unsigned long )*ht___1 == (unsigned long )((void *)0)) {
    {
#line 132
    initial_capacity = (size_t )7;
#line 133
    *ht___1 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
    }
#line 138
    if ((unsigned long )*ht___1 == (unsigned long )((void *)0)) {
      {
#line 139
      xalloc_die();
      }
    }
  }
  {
#line 142
  tmp = seen_file((Hash_table const   *)*ht___1, filename, st);
  }
#line 142
  if (tmp) {
#line 143
    return ((_Bool)1);
  }
  {
#line 145
  record_file(*ht___1, filename, st);
  }
#line 146
  return ((_Bool)0);
}
}
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 48 "/home/khheo/project/benchmark/coreutils-7.1/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded___0(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 51
  tmp = trim2(sub, 2);
#line 51
  tsub = tmp;
#line 52
  found = (_Bool)0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((int const   )*string != 0)) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 56
    tsub_in_string = (char const   *)tmp___0;
    }
#line 57
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 58
      goto while_break;
    } else {
      {
#line 61
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 61
      if (tmp___11 > 1UL) {
        {
#line 67
        string_iter.cur.ptr = string;
#line 67
        string_iter.in_shift = (_Bool)0;
#line 67
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 67
        string_iter.next_done = (_Bool)0;
#line 68
        word_boundary_before = (_Bool)1;
        }
#line 69
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 72
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 74
            mbuiter_multi_next(& string_iter);
            }
#line 74
            if (string_iter.cur.wc_valid) {
#line 74
              if (string_iter.cur.wc == 0) {
#line 74
                tmp___1 = 0;
              } else {
#line 74
                tmp___1 = 1;
              }
            } else {
#line 74
              tmp___1 = 1;
            }
#line 74
            if (! tmp___1) {
              {
#line 75
              abort();
              }
            }
#line 76
            last_char_before_tsub = string_iter.cur;
#line 77
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 77
            string_iter.next_done = (_Bool)0;
#line 72
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 72
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 80
          if (last_char_before_tsub.wc_valid) {
            {
#line 80
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 80
            if (tmp___2) {
#line 81
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 84
        string_iter.cur.ptr = tsub_in_string;
#line 84
        string_iter.in_shift = (_Bool)0;
#line 84
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 84
        string_iter.next_done = (_Bool)0;
#line 88
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 88
        tsub_iter.in_shift = (_Bool)0;
#line 88
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 88
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 88
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 88
          mbuiter_multi_next(& tsub_iter);
          }
#line 88
          if (tsub_iter.cur.wc_valid) {
#line 88
            if (tsub_iter.cur.wc == 0) {
#line 88
              tmp___4 = 0;
            } else {
#line 88
              tmp___4 = 1;
            }
          } else {
#line 88
            tmp___4 = 1;
          }
#line 88
          if (! tmp___4) {
#line 88
            goto while_break___1;
          }
          {
#line 92
          mbuiter_multi_next(& string_iter);
          }
#line 92
          if (string_iter.cur.wc_valid) {
#line 92
            if (string_iter.cur.wc == 0) {
#line 92
              tmp___3 = 0;
            } else {
#line 92
              tmp___3 = 1;
            }
          } else {
#line 92
            tmp___3 = 1;
          }
#line 92
          if (! tmp___3) {
            {
#line 93
            abort();
            }
          }
#line 94
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 94
          string_iter.next_done = (_Bool)0;
#line 88
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 88
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 97
        word_boundary_after = (_Bool)1;
#line 98
        mbuiter_multi_next(& string_iter);
        }
#line 98
        if (string_iter.cur.wc_valid) {
#line 98
          if (string_iter.cur.wc == 0) {
#line 98
            tmp___6 = 0;
          } else {
#line 98
            tmp___6 = 1;
          }
        } else {
#line 98
          tmp___6 = 1;
        }
#line 98
        if (tmp___6) {
#line 100
          first_char_after_tsub = string_iter.cur;
#line 101
          if (first_char_after_tsub.wc_valid) {
            {
#line 101
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 101
            if (tmp___5) {
#line 102
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 105
        if (word_boundary_before) {
#line 105
          if (word_boundary_after) {
#line 107
            found = (_Bool)1;
#line 108
            goto while_break;
          }
        }
        {
#line 111
        string_iter.cur.ptr = tsub_in_string;
#line 111
        string_iter.in_shift = (_Bool)0;
#line 111
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 111
        string_iter.next_done = (_Bool)0;
#line 112
        mbuiter_multi_next(& string_iter);
        }
#line 112
        if (string_iter.cur.wc_valid) {
#line 112
          if (string_iter.cur.wc == 0) {
#line 112
            tmp___7 = 0;
          } else {
#line 112
            tmp___7 = 1;
          }
        } else {
#line 112
          tmp___7 = 1;
        }
#line 112
        if (! tmp___7) {
#line 113
          goto while_break;
        }
#line 114
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 122
        word_boundary_before___0 = (_Bool)1;
#line 123
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 124
          tmp___8 = __ctype_b_loc();
          }
#line 124
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 125
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 127
        tmp___9 = strlen((char const   *)tsub);
#line 127
        p = tsub_in_string + tmp___9;
#line 128
        word_boundary_after___0 = (_Bool)1;
        }
#line 129
        if ((int const   )*p != 0) {
          {
#line 130
          tmp___10 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 131
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 133
        if (word_boundary_before___0) {
#line 133
          if (word_boundary_after___0) {
#line 135
            found = (_Bool)1;
#line 136
            goto while_break;
          }
        }
#line 139
        if ((int const   )*tsub_in_string == 0) {
#line 140
          goto while_break;
        }
#line 141
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  free((void *)tsub);
  }
#line 146
  return (found);
}
}
#line 112 "/home/khheo/project/benchmark/coreutils-7.1/lib/printf-args.c"
static wchar_t const   wide_null_string___0[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 61 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.c"
static int year___0(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ 
  time_t now ;
  struct tm *tmp ;

  {
  {
#line 66
  if (n == 1UL) {
#line 66
    goto case_1;
  }
#line 79
  if (n == 2UL) {
#line 79
    goto case_2;
  }
#line 85
  if (n == 0UL) {
#line 85
    goto case_0;
  }
#line 99
  goto switch_default;
  case_1: /* CIL Label */ 
#line 67
  tm->tm_year = (int )*digit_pair;
#line 71
  if (*(digit_pair + 0) <= 68) {
#line 73
    if (syntax_bits & 16U) {
#line 74
      return (1);
    }
#line 75
    tm->tm_year += 100;
  }
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  if (! (syntax_bits & 4U)) {
#line 81
    return (1);
  }
#line 82
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
#line 83
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 91
  time(& now);
#line 92
  tmp = localtime((time_t const   *)(& now));
  }
#line 93
  if (! tmp) {
#line 94
    return (1);
  }
#line 95
  tm->tm_year = tmp->tm_year;
#line 97
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 100
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 103
  return (0);
}
}
#line 106 "/home/khheo/project/benchmark/coreutils-7.1/lib/posixtm.c"
static int posix_time_parse___0(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ 
  char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int seconds ;

  {
  {
#line 109
  dot = (char const   *)((void *)0);
#line 114
  tmp = strlen(s);
#line 114
  s_len = tmp;
  }
#line 115
  if (syntax_bits & 8U) {
    {
#line 115
    tmp___2 = strchr(s, '.');
#line 115
    dot = (char const   *)tmp___2;
    }
#line 115
    if (dot) {
#line 115
      tmp___1 = (size_t )(dot - s);
    } else {
#line 115
      tmp___1 = s_len;
    }
  } else {
#line 115
    tmp___1 = s_len;
  }
#line 115
  len = tmp___1;
#line 119
  if (len != 8UL) {
#line 119
    if (len != 10UL) {
#line 119
      if (len != 12UL) {
#line 120
        return (1);
      }
    }
  }
#line 122
  if (dot) {
#line 124
    if (! (syntax_bits & 8U)) {
#line 125
      return (1);
    }
#line 127
    if (s_len - len != 3UL) {
#line 128
      return (1);
    }
  }
#line 131
  i = (size_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < len)) {
#line 131
      goto while_break;
    }
#line 132
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
#line 133
      return (1);
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  len /= 2UL;
#line 136
  i = (size_t )0;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < len)) {
#line 136
      goto while_break___0;
    }
#line 137
    pair[i] = (10 * (int )((int const   )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  p = pair;
#line 140
  if (syntax_bits & 1U) {
    {
#line 142
    tmp___3 = year___0(tm, (int const   *)p, len - 4UL, syntax_bits);
    }
#line 142
    if (tmp___3) {
#line 143
      return (1);
    }
#line 144
    p += len - 4UL;
#line 145
    len = (size_t )4;
  }
#line 149
  tmp___4 = p;
#line 149
  p ++;
#line 149
  tm->tm_mon = *tmp___4 - 1;
#line 150
  tmp___5 = p;
#line 150
  p ++;
#line 150
  tm->tm_mday = *tmp___5;
#line 151
  tmp___6 = p;
#line 151
  p ++;
#line 151
  tm->tm_hour = *tmp___6;
#line 152
  tmp___7 = p;
#line 152
  p ++;
#line 152
  tm->tm_min = *tmp___7;
#line 153
  len -= 4UL;
#line 156
  if (syntax_bits & 2U) {
    {
#line 158
    tmp___8 = year___0(tm, (int const   *)p, len, syntax_bits);
    }
#line 158
    if (tmp___8) {
#line 159
      return (1);
    }
  }
#line 163
  if (! dot) {
#line 165
    tm->tm_sec = 0;
  } else {
#line 171
    dot ++;
#line 172
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
#line 173
      return (1);
    } else
#line 172
    if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
#line 173
      return (1);
    }
#line 174
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
#line 176
    tm->tm_sec = seconds;
  }
#line 179
  return (0);
}
}
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/openat-proc.c"
static int proc_status___0  =    0;
#line 22 "/home/khheo/project/benchmark/coreutils-7.1/lib/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "/home/khheo/project/benchmark/coreutils-7.1/lib/nanosleep.c"
static void getnow___0(struct timespec *t ) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = clock_gettime(1, t);
  }
#line 49
  if (tmp == 0) {
#line 50
    return;
  }
  {
#line 52
  gettime(t);
  }
#line 53
  return;
}
}
#line 30 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_with_tmp___0(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                                int (*cmp)(void const   * , void const   * ) ) ;
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_into_tmp___0(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                                int (*cmp)(void const   * , void const   * ) ) 
{ 
  size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  tmp___0 ;
  void const   ** __restrict  tmp___1 ;
  int tmp___2 ;

  {
  {
#line 41
  n1 = n / 2UL;
#line 42
  n2 = n - n1;
#line 43
  a = (size_t )0;
#line 44
  alim = n1;
#line 45
  b = n1;
#line 46
  blim = n;
#line 50
  mpsort_with_tmp___0(base + n1, n2, tmp, cmp);
#line 51
  mpsort_with_tmp___0(base, n1, tmp, cmp);
#line 53
  ba = *(base + a);
#line 54
  bb = *(base + b);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___2 = (*cmp)(ba, bb);
    }
#line 57
    if (tmp___2 <= 0) {
#line 59
      tmp___0 = tmp;
#line 59
      tmp ++;
#line 59
      *tmp___0 = ba;
#line 60
      a ++;
#line 61
      if (a == alim) {
#line 63
        a = b;
#line 64
        alim = blim;
#line 65
        goto while_break;
      }
#line 67
      ba = *(base + a);
    } else {
#line 71
      tmp___1 = tmp;
#line 71
      tmp ++;
#line 71
      *tmp___1 = bb;
#line 72
      b ++;
#line 73
      if (b == blim) {
#line 74
        goto while_break;
      }
#line 75
      bb = *(base + b);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(base + a),
         (alim - a) * sizeof(*base));
  }
#line 79
  return;
}
}
#line 85 "/home/khheo/project/benchmark/coreutils-7.1/lib/mpsort.c"
static void mpsort_with_tmp___0(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                                int (*cmp)(void const   * , void const   * ) ) 
{ 
  void const   *p0 ;
  void const   *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 90
  if (n <= 2UL) {
#line 92
    if (n == 2UL) {
      {
#line 94
      p0 = *(base + 0);
#line 95
      p1 = *(base + 1);
#line 96
      tmp___0 = (*cmp)(p0, p1);
      }
#line 96
      if (! (tmp___0 <= 0)) {
#line 98
        *(base + 0) = p1;
#line 99
        *(base + 1) = p0;
      }
    }
  } else {
    {
#line 105
    n1 = n / 2UL;
#line 106
    n2 = n - n1;
#line 108
    t = (size_t )0;
#line 109
    tlim = n1;
#line 110
    b = n1;
#line 111
    blim = n;
#line 115
    mpsort_with_tmp___0(base + n1, n2, tmp, cmp);
    }
#line 117
    if (n1 < 2UL) {
#line 118
      *(tmp + 0) = *(base + 0);
    } else {
      {
#line 120
      mpsort_into_tmp___0(base, n1, tmp, cmp);
      }
    }
#line 122
    tt = *(tmp + t);
#line 123
    bb = *(base + b);
#line 125
    i = (size_t )0;
    {
#line 125
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 126
      tmp___3 = (*cmp)(tt, bb);
      }
#line 126
      if (tmp___3 <= 0) {
#line 128
        tmp___1 = i;
#line 128
        i ++;
#line 128
        *(base + tmp___1) = tt;
#line 129
        t ++;
#line 130
        if (t == tlim) {
#line 131
          goto while_break;
        }
#line 132
        tt = *(tmp + t);
      } else {
#line 136
        tmp___2 = i;
#line 136
        i ++;
#line 136
        *(base + tmp___2) = bb;
#line 137
        b ++;
#line 138
        if (b == blim) {
          {
#line 140
          memcpy((void */* __restrict  */)(base + i), (void const   */* __restrict  */)(tmp + t),
                 (tlim - t) * sizeof(*base));
          }
#line 141
          goto while_break;
        }
#line 143
        bb = *(base + b);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 28 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
static int last_cherror___0  ;
#line 63 "/home/khheo/project/benchmark/coreutils-7.1/lib/canon-host.c"
static struct addrinfo hints___0  ;
#line 302 "/home/khheo/project/benchmark/coreutils-7.1/lib/mountlist.c"
static dev_t dev_from_mount_options___0(char const   *mount_options ) 
{ 


  {
#line 329
  return ((dev_t )-1);
}
}
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 53 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
static mode_t octal_to_mode___0(unsigned int octal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 58
  if (256 >> 3 == 32) {
#line 58
    if (128 >> 3 == 16) {
#line 58
      if (64 >> 3 == 8) {
#line 58
        if ((256 >> 3) >> 3 == 4) {
#line 58
          if ((128 >> 3) >> 3 == 2) {
#line 58
            if ((64 >> 3) >> 3 == 1) {
#line 58
              tmp___11 = octal;
            } else {
#line 58
              goto _L___3;
            }
          } else {
#line 58
            goto _L___3;
          }
        } else {
#line 58
          goto _L___3;
        }
      } else {
#line 58
        goto _L___3;
      }
    } else {
#line 58
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 58
    if (octal & 2048U) {
#line 58
      tmp = 2048;
    } else {
#line 58
      tmp = 0;
    }
#line 58
    if (octal & 1024U) {
#line 58
      tmp___0 = 1024;
    } else {
#line 58
      tmp___0 = 0;
    }
#line 58
    if (octal & 512U) {
#line 58
      tmp___1 = 512;
    } else {
#line 58
      tmp___1 = 0;
    }
#line 58
    if (octal & 256U) {
#line 58
      tmp___2 = 256;
    } else {
#line 58
      tmp___2 = 0;
    }
#line 58
    if (octal & 128U) {
#line 58
      tmp___3 = 128;
    } else {
#line 58
      tmp___3 = 0;
    }
#line 58
    if (octal & 64U) {
#line 58
      tmp___4 = 64;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (octal & 32U) {
#line 58
      tmp___5 = 256 >> 3;
    } else {
#line 58
      tmp___5 = 0;
    }
#line 58
    if (octal & 16U) {
#line 58
      tmp___6 = 128 >> 3;
    } else {
#line 58
      tmp___6 = 0;
    }
#line 58
    if (octal & 8U) {
#line 58
      tmp___7 = 64 >> 3;
    } else {
#line 58
      tmp___7 = 0;
    }
#line 58
    if (octal & 4U) {
#line 58
      tmp___8 = (256 >> 3) >> 3;
    } else {
#line 58
      tmp___8 = 0;
    }
#line 58
    if (octal & 2U) {
#line 58
      tmp___9 = (128 >> 3) >> 3;
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    if (octal & 1U) {
#line 58
      tmp___10 = (64 >> 3) >> 3;
    } else {
#line 58
      tmp___10 = 0;
    }
#line 58
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
#line 58
  return (tmp___11);
}
}
#line 111 "/home/khheo/project/benchmark/coreutils-7.1/lib/modechange.c"
static struct mode_change *make_node_op_equals___0(mode_t new_mode , mode_t mentioned ) 
{ 
  struct mode_change *p ;
  void *tmp ;

  {
  {
#line 114
  tmp = xmalloc(2UL * sizeof(*p));
#line 114
  p = (struct mode_change *)tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 118
  p->value = new_mode;
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
  }
#line 121
  return (p);
}
}
#line 36 "/home/khheo/project/benchmark/coreutils-7.1/lib/mgetgroups.c"
static gid_t *realloc_groupbuf___0(gid_t *g , size_t num ) 
{ 
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 39
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 39
    tmp___0 = -1;
  } else {
#line 39
    tmp___0 = -2;
  }
#line 39
  if ((size_t )tmp___0 / sizeof(*g) < num) {
    {
#line 41
    tmp = __errno_location();
#line 41
    *tmp = 12;
    }
#line 42
    return ((gid_t *)((void *)0));
  }
  {
#line 45
  tmp___1 = realloc((void *)g, num * sizeof(*g));
  }
#line 45
  return ((gid_t *)tmp___1);
}
}
#line 66 "/home/khheo/project/benchmark/coreutils-7.1/lib/md5.c"
static unsigned char const   fillbuf___6[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache___1  ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
__inline static locale_t c_locale___1(void) 
{ 
  locale_t tmp ;

  {
#line 58
  if (! c_locale_cache___1) {
    {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache___1 = (locale_t volatile   )tmp;
    }
  }
#line 60
  return ((locale_t )c_locale_cache___1);
}
}
#line 51 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache___2  ;
#line 55 "/home/khheo/project/benchmark/coreutils-7.1/lib/c-strtod.c"
__inline static locale_t c_locale___2(void) 
{ 
  locale_t tmp ;

  {
#line 58
  if (! c_locale_cache___2) {
    {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache___2 = (locale_t volatile   )tmp;
    }
  }
#line 60
  return ((locale_t )c_locale_cache___2);
}
}
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
static char const   b64str___0[64]  = 
#line 72 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 223 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
static signed char const   b64___0[256]  = 
#line 223
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 373 "/home/khheo/project/benchmark/coreutils-7.1/lib/base64.c"
__inline static _Bool decode_4___0(char const   * __restrict  in , size_t inlen ,
                                   char * __restrict  *outp , size_t *outleft ) 
{ 
  char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 377
  out = (char *)*outp;
#line 378
  if (inlen < 2UL) {
#line 379
    return ((_Bool)0);
  }
  {
#line 381
  tmp = isbase64((char )*(in + 0));
  }
#line 381
  if (tmp) {
    {
#line 381
    tmp___0 = isbase64((char )*(in + 1));
    }
#line 381
    if (! tmp___0) {
#line 382
      return ((_Bool)0);
    }
  } else {
#line 382
    return ((_Bool)0);
  }
#line 384
  if (*outleft) {
    {
#line 386
    tmp___1 = out;
#line 386
    out ++;
#line 386
    tmp___2 = to_uchar((char )*(in + 0));
#line 386
    tmp___3 = to_uchar((char )*(in + 1));
#line 386
    *tmp___1 = (char )(((int const   )b64___0[tmp___2] << 2) | ((int const   )b64___0[tmp___3] >> 4));
#line 388
    (*outleft) --;
    }
  }
#line 391
  if (inlen == 2UL) {
    {
#line 392
    while (1) {
      while_continue: /* CIL Label */ ;
#line 392
      *outp = (char */* __restrict  */)out;
#line 392
      return ((_Bool)0);
#line 392
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 394
  if ((int const   )*(in + 2) == 61) {
#line 396
    if (inlen != 4UL) {
      {
#line 397
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 397
        *outp = (char */* __restrict  */)out;
#line 397
        return ((_Bool)0);
#line 397
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 399
    if ((int const   )*(in + 3) != 61) {
      {
#line 400
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 400
        *outp = (char */* __restrict  */)out;
#line 400
        return ((_Bool)0);
#line 400
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 404
    tmp___4 = isbase64((char )*(in + 2));
    }
#line 404
    if (! tmp___4) {
      {
#line 405
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 405
        *outp = (char */* __restrict  */)out;
#line 405
        return ((_Bool)0);
#line 405
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 407
    if (*outleft) {
      {
#line 409
      tmp___5 = out;
#line 409
      out ++;
#line 409
      tmp___6 = to_uchar((char )*(in + 1));
#line 409
      tmp___7 = to_uchar((char )*(in + 2));
#line 409
      *tmp___5 = (char )((((int const   )b64___0[tmp___6] << 4) & 240) | ((int const   )b64___0[tmp___7] >> 2));
#line 411
      (*outleft) --;
      }
    }
#line 414
    if (inlen == 3UL) {
      {
#line 415
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 415
        *outp = (char */* __restrict  */)out;
#line 415
        return ((_Bool)0);
#line 415
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 417
    if ((int const   )*(in + 3) == 61) {
#line 419
      if (inlen != 4UL) {
        {
#line 420
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 420
          *outp = (char */* __restrict  */)out;
#line 420
          return ((_Bool)0);
#line 420
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 424
      tmp___8 = isbase64((char )*(in + 3));
      }
#line 424
      if (! tmp___8) {
        {
#line 425
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 425
          *outp = (char */* __restrict  */)out;
#line 425
          return ((_Bool)0);
#line 425
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 427
      if (*outleft) {
        {
#line 429
        tmp___9 = out;
#line 429
        out ++;
#line 429
        tmp___10 = to_uchar((char )*(in + 2));
#line 429
        tmp___11 = to_uchar((char )*(in + 3));
#line 429
        *tmp___9 = (char )((((int const   )b64___0[tmp___10] << 6) & 192) | (int const   )b64___0[tmp___11]);
#line 431
        (*outleft) --;
        }
      }
    }
  }
#line 436
  *outp = (char */* __restrict  */)out;
#line 437
  return ((_Bool)1);
}
}
#line 98 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static void check_extension___0(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
  {
#line 101
  tmp = last_component((char const   *)file);
#line 101
  base = tmp;
#line 102
  tmp___0 = base_len((char const   *)base);
#line 102
  baselen = tmp___0;
#line 103
  baselen_max = (size_t )255;
  }
#line 105
  if (14UL < baselen) {
    {
#line 113
    memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
           sizeof("."));
#line 114
    strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 115
    tmp___2 = __errno_location();
#line 115
    *tmp___2 = 0;
#line 116
    name_max = pathconf((char const   *)file, 3);
    }
#line 117
    if (0L <= name_max) {
#line 117
      goto _L;
    } else {
      {
#line 117
      tmp___3 = __errno_location();
      }
#line 117
      if (*tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 119
        baselen_max = (size_t )name_max;
#line 119
        size = (long )baselen_max;
#line 120
        if (name_max != size) {
#line 121
          baselen_max = (size_t )-1;
        }
      }
    }
    {
#line 123
    memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
           sizeof("."));
    }
  }
#line 141
  if (baselen_max < baselen) {
#line 143
    baselen = (size_t )((file + filelen) - base);
#line 144
    if (baselen_max <= baselen) {
#line 145
      baselen = baselen_max - 1UL;
    }
#line 146
    *(base + baselen) = e;
#line 147
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 149
  return;
}
}
#line 178 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static enum numbered_backup_result numbered_backup___0(char **buffer , size_t buffer_size ,
                                                       size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___1 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 181
  result = (enum numbered_backup_result )2;
#line 184
  buf___1 = *buffer;
#line 185
  versionlenmax = (size_t )1;
#line 186
  tmp = last_component((char const   *)buf___1);
#line 186
  base = tmp;
#line 187
  base_offset = (size_t )(base - buf___1);
#line 188
  tmp___0 = base_len((char const   *)base);
#line 188
  baselen = tmp___0;
#line 193
  memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
         sizeof("."));
#line 194
  strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 195
  dirp = opendir((char const   *)buf___1);
#line 196
  memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
         sizeof("."));
#line 197
  strcpy((char */* __restrict  */)(base + baselen), (char const   */* __restrict  */)".~1~");
  }
#line 199
  if (! dirp) {
#line 200
    return (result);
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    dp = readdir(dirp);
    }
#line 202
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 202
      goto while_break;
    }
#line 210
    if (! (dp->d_ino != 0UL)) {
#line 211
      goto while_continue;
    } else {
      {
#line 210
      tmp___2 = strlen((char const   *)(dp->d_name));
      }
#line 210
      if (tmp___2 < baselen + 4UL) {
#line 211
        goto while_continue;
      }
    }
    {
#line 213
    tmp___3 = memcmp((void const   *)(buf___1 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
    }
#line 213
    if (tmp___3 != 0) {
#line 214
      goto while_continue;
    }
#line 216
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 222
    if (49 <= (int )*p) {
#line 222
      if (! ((int const   )*p <= 57)) {
#line 223
        goto while_continue;
      }
    } else {
#line 223
      goto while_continue;
    }
#line 224
    all_9s = (_Bool )((int const   )*p == 57);
#line 225
    versionlen = (size_t )1;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! ((unsigned int )*(p + versionlen) - 48U <= 9U)) {
#line 225
        goto while_break___0;
      }
#line 226
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 225
      versionlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 228
    if ((int const   )*(p + versionlen) == 126) {
#line 228
      if (! *(p + (versionlen + 1UL))) {
#line 228
        if (! (versionlenmax < versionlen)) {
#line 228
          if (versionlenmax == versionlen) {
            {
#line 228
            tmp___4 = memcmp((void const   *)((buf___1 + filelen) + 2), (void const   *)p,
                             versionlen);
            }
#line 228
            if (! (tmp___4 <= 0)) {
#line 232
              goto while_continue;
            }
          } else {
#line 232
            goto while_continue;
          }
        }
      } else {
#line 232
        goto while_continue;
      }
    } else {
#line 232
      goto while_continue;
    }
#line 238
    versionlenmax = (size_t )all_9s + versionlen;
#line 239
    if (all_9s) {
#line 239
      result = (enum numbered_backup_result )1;
    } else {
#line 239
      result = (enum numbered_backup_result )0;
    }
#line 240
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 241
    if (buffer_size <= new_buflen) {
      {
#line 243
      tmp___5 = xnrealloc((void *)buf___1, (size_t )2, new_buflen);
#line 243
      buf___1 = (char *)tmp___5;
#line 244
      buffer_size = new_buflen * 2UL;
      }
    }
    {
#line 246
    q = buf___1 + filelen;
#line 247
    tmp___6 = q;
#line 247
    q ++;
#line 247
    *tmp___6 = (char )'.';
#line 248
    tmp___7 = q;
#line 248
    q ++;
#line 248
    *tmp___7 = (char )'~';
#line 249
    *q = (char )'0';
#line 250
    q += (int )all_9s;
#line 251
    memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, versionlen + 2UL);
#line 255
    q += versionlen;
    }
    {
#line 256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 256
      q --;
#line 256
      if (! ((int )*q == 57)) {
#line 256
        goto while_break___1;
      }
#line 257
      *q = (char )'0';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 258
    *q = (char )((int )*q + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  closedir(dirp);
#line 262
  *buffer = buf___1;
  }
#line 263
  return (result);
}
}
#line 311 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static char const   * const  backup_args___0[9]  = 
#line 311
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)((void *)0)};
#line 322 "/home/khheo/project/benchmark/coreutils-7.1/lib/backupfile.c"
static enum backup_type  const  backup_types___0[8]  = 
#line 322
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 60 "/home/khheo/project/benchmark/coreutils-7.1/lib/argmatch.c"
static void __argmatch_die___0(void) 
{ 


  {
  {
#line 63
  usage(1);
  }
#line 64
  return;
}
}
#line 2 "/home/khheo/project/benchmark/coreutils-7.1/src/version.c"
char const   *Version  =    "7.1";
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 196
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                                                  int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 240
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 447 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 587
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 117 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 592
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 117 "/home/khheo/project/benchmark/coreutils-7.1/src/system.h"
__inline static void initialize_exit_failure(int status ) 
{ 


  {
#line 120
  if (status != 1) {
#line 121
    exit_failure = (int volatile   )status;
  }
#line 122
  return;
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 675 "/usr/include/stdio.h"
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream ) ;
#line 619 "/home/khheo/project/benchmark/coreutils-7.1/src/system.h"
__inline static void emit_bug_reporting_address___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 622
  tmp = last_component(program_name);
#line 622
  tmp___0 = gettext("\nReport %s bugs to %s\n");
#line 622
  printf((char const   */* __restrict  */)tmp___0, tmp, "bug-coreutils@gnu.org");
#line 625
  tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
#line 625
  printf((char const   */* __restrict  */)tmp___1, "GNU coreutils", "coreutils");
#line 627
  tmp___2 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 627
  fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 634
  tmp___5 = hard_locale(5);
  }
#line 634
  if (tmp___5) {
    {
#line 635
    tmp___3 = last_component(program_name);
#line 635
    tmp___4 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
#line 635
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
    }
  }
#line 638
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 119 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int decimal_point  ;
#line 122 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int thousands_sep  ;
#line 125 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool hard_LC_COLLATE  ;
#line 127 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool hard_LC_TIME  ;
#line 136 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char eolchar  =    (char )'\n';
#line 198 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool blanks[256]  ;
#line 201 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool nonprinting[256]  ;
#line 204 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool nondictionary[256]  ;
#line 207 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char fold_toupper[256]  ;
#line 213 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct month monthtab[12]  = 
#line 213
  {      {"APR", 4}, 
        {"AUG", 8}, 
        {"DEC", 12}, 
        {"FEB", 2}, 
        {"JAN", 1}, 
        {"JUL", 7}, 
        {"JUN", 6}, 
        {"MAR", 3}, 
        {"MAY", 5}, 
        {"NOV", 11}, 
        {"OCT", 10}, 
        {"SEP", 9}};
#line 241 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t merge_buffer_size  =    262144UL;
#line 245 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t sort_size  ;
#line 251 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   **temp_dirs  ;
#line 254 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t temp_dir_count  ;
#line 257 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t temp_dir_alloc  ;
#line 260 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool reverse  ;
#line 265 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool stable  ;
#line 273 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int tab  =    128;
#line 277 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool unique  ;
#line 280 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool have_read_stdin  ;
#line 283 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct keyfield *keylist  ;
#line 286 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   *compress_program  ;
#line 290 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static unsigned int nmerge  =    16U;
#line 292
static void sortlines_temp(struct line *lines , size_t nlines , struct line *temp ) ;
#line 297
static  __attribute__((__noreturn__)) void die(char const   *message , char const   *file ) ;
#line 298
static  __attribute__((__noreturn__)) void die(char const   *message , char const   *file ) ;
#line 298 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void die(char const   *message , char const   *file ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
#line 301
  if (file) {
#line 301
    tmp___0 = file;
  } else {
    {
#line 301
    tmp = gettext("standard output");
#line 301
    tmp___0 = (char const   *)tmp;
    }
  }
  {
#line 301
  tmp___1 = __errno_location();
#line 301
  error(0, *tmp___1, "%s: %s", message, tmp___0);
#line 302
  exit(2);
  }
}
}
#line 305 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 308
  if (status != 0) {
    {
#line 309
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
    }
  } else {
    {
#line 313
    tmp___0 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
#line 313
    printf((char const   */* __restrict  */)tmp___0, program_name, program_name);
#line 318
    tmp___1 = gettext("Write sorted concatenation of all FILE(s) to standard output.\n\n");
#line 318
    fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 322
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 322
    fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 325
    tmp___3 = gettext("Ordering options:\n\n");
#line 325
    fputs_unlocked((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 329
    tmp___4 = gettext("  -b, --ignore-leading-blanks  ignore leading blanks\n  -d, --dictionary-order      consider only blanks and alphanumeric characters\n  -f, --ignore-case           fold lower case to upper case characters\n");
#line 329
    fputs_unlocked((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
#line 334
    tmp___5 = gettext("  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) < `JAN\' < ... < `DEC\'\n");
#line 334
    fputs_unlocked((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
#line 339
    tmp___6 = gettext("  -n, --numeric-sort          compare according to string numerical value\n  -R, --random-sort           sort by random hash of keys\n      --random-source=FILE    get random bytes from FILE (default /dev/urandom)\n  -r, --reverse               reverse the result of comparisons\n");
#line 339
    fputs_unlocked((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 345
    tmp___7 = gettext("      --sort=WORD             sort according to WORD:\n                                general-numeric -g, month -M, numeric -n,\n                                random -R, version -V\n  -V, --version-sort          sort by numeric version\n\n");
#line 345
    fputs_unlocked((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stdout);
#line 352
    tmp___8 = gettext("Other options:\n\n");
#line 352
    fputs_unlocked((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
#line 356
    tmp___9 = gettext("      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n                            for more use temp files\n");
#line 356
    fputs_unlocked((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 360
    tmp___10 = gettext("  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n      --compress-program=PROG  compress temporaries with PROG;\n                              decompress them with PROG -d\n      --files0-from=F       read input from the files specified by\n                            NUL-terminated names in file F;\n                            If F is - then read names from standard input\n");
#line 360
    fputs_unlocked((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stdout);
#line 369
    tmp___11 = gettext("  -k, --key=POS1[,POS2]     start a key at POS1 (origin 1), end it at POS2\n                            (default end of line)\n  -m, --merge               merge already sorted files; do not sort\n");
#line 369
    fputs_unlocked((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stdout);
#line 374
    tmp___12 = gettext("  -o, --output=FILE         write result to FILE instead of standard output\n  -s, --stable              stabilize sort by disabling last-resort comparison\n  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n");
#line 374
    fputs_unlocked((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stdout);
#line 379
    tmp___13 = gettext("  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n                              multiple options specify multiple directories\n  -u, --unique              with -c, check for strict ordering;\n                              without -c, output only the first of an equal run\n");
#line 379
    printf((char const   */* __restrict  */)tmp___13, "/tmp");
#line 386
    tmp___14 = gettext("  -z, --zero-terminated     end lines with 0 byte, not newline\n");
#line 386
    fputs_unlocked((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)stdout);
#line 389
    tmp___15 = gettext("      --help     display this help and exit\n");
#line 389
    fputs_unlocked((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)stdout);
#line 390
    tmp___16 = gettext("      --version  output version information and exit\n");
#line 390
    fputs_unlocked((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)stdout);
#line 391
    tmp___17 = gettext("\nPOS is F[.C][OPTS], where F is the field number and C the character position\nin the field; both are origin 1.  If neither -t nor -b is in effect, characters\nin a field are counted from the beginning of the preceding whitespace.  OPTS is\none or more single-letter ordering options, which override global ordering\noptions for that key.  If no key is given, use the entire line as the key.\n\nSIZE may be followed by the following multiplicative suffixes:\n");
#line 391
    fputs_unlocked((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)stdout);
#line 401
    tmp___18 = gettext("% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\nWith no FILE, or when FILE is -, read standard input.\n\n*** WARNING ***\nThe locale specified by the environment affects sort order.\nSet LC_ALL=C to get the traditional sort order that uses\nnative byte values.\n");
#line 401
    fputs_unlocked((char const   */* __restrict  */)tmp___18, (FILE */* __restrict  */)stdout);
#line 411
    emit_bug_reporting_address___0();
    }
  }
  {
#line 414
  exit(status);
  }
}
}
#line 429 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   short_options[30]  = 
#line 429
  {      (char const   )'-',      (char const   )'b',      (char const   )'c',      (char const   )'C', 
        (char const   )'d',      (char const   )'f',      (char const   )'g',      (char const   )'i', 
        (char const   )'k',      (char const   )':',      (char const   )'m',      (char const   )'M', 
        (char const   )'n',      (char const   )'o',      (char const   )':',      (char const   )'r', 
        (char const   )'R',      (char const   )'s',      (char const   )'S',      (char const   )':', 
        (char const   )'t',      (char const   )':',      (char const   )'T',      (char const   )':', 
        (char const   )'u',      (char const   )'V',      (char const   )'y',      (char const   )':', 
        (char const   )'z',      (char const   )'\000'};
#line 431 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct option  const  long_options___1[28]  = 
#line 431
  {      {"ignore-leading-blanks", 0, (int *)((void *)0), 'b'}, 
        {"check", 2, (int *)((void *)0), 128}, 
        {"compress-program", 1, (int *)((void *)0), 129}, 
        {"dictionary-order", 0, (int *)((void *)0), 'd'}, 
        {"ignore-case", 0, (int *)((void *)0), 'f'}, 
        {"files0-from", 1, (int *)((void *)0), 130}, 
        {"general-numeric-sort", 0, (int *)((void *)0), 'g'}, 
        {"ignore-nonprinting", 0, (int *)((void *)0), 'i'}, 
        {"key", 1, (int *)((void *)0), 'k'}, 
        {"merge", 0, (int *)((void *)0), 'm'}, 
        {"month-sort", 0, (int *)((void *)0), 'M'}, 
        {"numeric-sort", 0, (int *)((void *)0), 'n'}, 
        {"version-sort", 0, (int *)((void *)0), 'V'}, 
        {"random-sort", 0, (int *)((void *)0), 'R'}, 
        {"random-source", 1, (int *)((void *)0), 132}, 
        {"sort", 1, (int *)((void *)0), 133}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"reverse", 0, (int *)((void *)0), 'r'}, 
        {"stable", 0, (int *)((void *)0), 's'}, 
        {"batch-size", 1, (int *)((void *)0), 131}, 
        {"buffer-size", 1, (int *)((void *)0), 'S'}, 
        {"field-separator", 1, (int *)((void *)0), 't'}, 
        {"temporary-directory", 1, (int *)((void *)0), 'T'}, 
        {"unique", 0, (int *)((void *)0), 'u'}, 
        {"zero-terminated", 0, (int *)((void *)0), 'z'}, 
        {"help", 0, (int *)((void *)0), -130}, 
        {"version", 0, (int *)((void *)0), -131}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 468 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   * const  check_args[4]  = {      (char const   */* const  */)"quiet",      (char const   */* const  */)"silent",      (char const   */* const  */)"diagnose-first",      (char const   */* const  */)((void *)0)};
#line 474 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   check_types[3]  = {      (char const   )'C',      (char const   )'C',      (char const   )'c'};
#line 488 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   * const  sort_args[6]  = {      (char const   */* const  */)"general-numeric",      (char const   */* const  */)"month",      (char const   */* const  */)"numeric",      (char const   */* const  */)"random", 
        (char const   */* const  */)"version",      (char const   */* const  */)((void *)0)};
#line 494 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   sort_types[5]  = {      (char const   )'g',      (char const   )'M',      (char const   )'n',      (char const   )'R', 
        (char const   )'V'};
#line 502 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static sigset_t caught_signals  ;
#line 512 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct cs_status cs_enter(void) 
{ 
  struct cs_status status ;
  int tmp ;

  {
  {
#line 516
  tmp = sigprocmask(0, (sigset_t const   */* __restrict  */)(& caught_signals), (sigset_t */* __restrict  */)(& status.sigs));
#line 516
  status.valid = (_Bool )(tmp == 0);
  }
#line 517
  return (status);
}
}
#line 521 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void cs_leave(struct cs_status status ) 
{ 


  {
#line 524
  if (status.valid) {
    {
#line 527
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& status.sigs), (sigset_t */* __restrict  */)((void *)0));
    }
  }
#line 529
  return;
}
}
#line 538 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct tempnode * volatile  temphead  ;
#line 539 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct tempnode * volatile  *temptail  =    & temphead;
#line 551 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static Hash_table *proctab  ;
#line 568 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t proctab_hasher(void const   *entry , size_t tabsize ) 
{ 
  struct procnode  const  *node ;

  {
#line 571
  node = (struct procnode  const  *)entry;
#line 572
  return ((unsigned long )node->pid % tabsize);
}
}
#line 575 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool proctab_comparator(void const   *e1 , void const   *e2 ) 
{ 
  struct procnode  const  *n1 ;
  struct procnode  const  *n2 ;

  {
#line 578
  n1 = (struct procnode  const  *)e1;
#line 578
  n2 = (struct procnode  const  *)e2;
#line 579
  return ((_Bool )(n1->pid == n2->pid));
}
}
#line 584 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t nprocs  ;
#line 594 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static pid_t reap(pid_t pid ) 
{ 
  int status ;
  pid_t cpid ;
  int tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 598
  if (pid < 0) {
#line 598
    tmp = 1;
  } else {
#line 598
    tmp = 0;
  }
  {
#line 598
  tmp___0 = waitpid(pid, & status, tmp);
#line 598
  cpid = tmp___0;
  }
#line 600
  if (cpid < 0) {
    {
#line 601
    tmp___1 = gettext("waiting for %s [-d]");
#line 601
    tmp___2 = __errno_location();
#line 601
    error(2, *tmp___2, (char const   *)tmp___1, compress_program);
    }
  } else
#line 603
  if (0 < cpid) {
#line 605
    if (! ((status & 127) == 0)) {
      {
#line 606
      tmp___3 = gettext("%s [-d] terminated abnormally");
#line 606
      error(2, 0, (char const   *)tmp___3, compress_program);
      }
    } else
#line 605
    if ((status & 65280) >> 8) {
      {
#line 606
      tmp___3 = gettext("%s [-d] terminated abnormally");
#line 606
      error(2, 0, (char const   *)tmp___3, compress_program);
      }
    }
#line 608
    nprocs --;
  }
#line 611
  return (cpid);
}
}
#line 618 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void register_proc(pid_t pid ) 
{ 
  struct procnode test ;
  struct procnode *node ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 623
  if (! proctab) {
    {
#line 625
    proctab = hash_initialize((size_t )47, (Hash_tuning const   *)((void *)0), & proctab_hasher,
                              & proctab_comparator, (void (*)(void * ))(& free));
    }
#line 629
    if (! proctab) {
      {
#line 630
      xalloc_die();
      }
    }
  }
  {
#line 633
  test.pid = pid;
#line 634
  tmp = hash_lookup((Hash_table const   *)proctab, (void const   *)(& test));
#line 634
  node = (struct procnode *)tmp;
  }
#line 635
  if (node) {
#line 637
    node->state = (enum procstate )0;
#line 638
    (node->count) ++;
  } else {
    {
#line 642
    tmp___0 = xmalloc(sizeof(*node));
#line 642
    node = (struct procnode *)tmp___0;
#line 643
    node->pid = pid;
#line 644
    node->state = (enum procstate )0;
#line 645
    node->count = (size_t )1;
#line 646
    hash_insert(proctab, (void const   *)node);
    }
  }
#line 648
  return;
}
}
#line 656 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void update_proc(pid_t pid ) 
{ 
  struct procnode test ;
  struct procnode *node ;
  void *tmp ;

  {
  {
#line 661
  test.pid = pid;
#line 662
  tmp = hash_lookup((Hash_table const   *)proctab, (void const   *)(& test));
#line 662
  node = (struct procnode *)tmp;
  }
#line 663
  if (node) {
#line 664
    node->state = (enum procstate )1;
  }
#line 665
  return;
}
}
#line 674 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void wait_proc(pid_t pid ) 
{ 
  struct procnode test ;
  struct procnode *node ;
  void *tmp ;

  {
  {
#line 679
  test.pid = pid;
#line 680
  tmp = hash_lookup((Hash_table const   *)proctab, (void const   *)(& test));
#line 680
  node = (struct procnode *)tmp;
  }
#line 681
  if ((unsigned int )node->state == 0U) {
    {
#line 682
    reap(pid);
    }
  }
#line 684
  node->state = (enum procstate )1;
#line 685
  (node->count) --;
#line 685
  if (! node->count) {
    {
#line 687
    hash_delete(proctab, (void const   *)node);
#line 688
    free((void *)node);
    }
  }
#line 690
  return;
}
}
#line 696 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void reap_some(void) 
{ 
  pid_t pid ;

  {
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (0UL < nprocs) {
      {
#line 701
      pid = reap(-1);
      }
#line 701
      if (! pid) {
#line 701
        goto while_break;
      }
    } else {
#line 701
      goto while_break;
    }
    {
#line 702
    update_proc(pid);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return;
}
}
#line 707 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void cleanup(void) 
{ 
  struct tempnode  const  *node ;

  {
#line 712
  node = (struct tempnode  const  *)temphead;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! node) {
#line 712
      goto while_break;
    }
    {
#line 713
    unlink((char const   *)(node->name));
#line 712
    node = (struct tempnode  const  *)node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  temphead = (struct tempnode */* volatile  */)((void *)0);
#line 715
  return;
}
}
#line 719 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void exit_cleanup(void) 
{ 
  struct cs_status cs ;
  struct cs_status tmp ;

  {
#line 722
  if (temphead) {
    {
#line 726
    tmp = cs_enter();
#line 726
    cs = tmp;
#line 727
    cleanup();
#line 728
    cs_leave(cs);
    }
  }
  {
#line 731
  close_stdout();
  }
#line 732
  return;
}
}
#line 740
static struct tempnode *create_temp_file(int *pfd ) ;
#line 740 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   slashbase[12]  = 
#line 740
  {      (char const   )'/',      (char const   )'s',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )'X',      (char const   )'X',      (char const   )'X', 
        (char const   )'X',      (char const   )'X',      (char const   )'X',      (char const   )'\000'};
#line 741 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t temp_dir_index  ;
#line 737 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct tempnode *create_temp_file(int *pfd ) 
{ 
  int fd ;
  int saved_errno ;
  char const   *temp_dir ;
  size_t len ;
  size_t tmp ;
  struct tempnode *node ;
  void *tmp___0 ;
  char *file ;
  struct cs_status cs ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 744
  temp_dir = *(temp_dirs + temp_dir_index);
#line 745
  tmp = strlen(temp_dir);
#line 745
  len = tmp;
#line 746
  tmp___0 = xmalloc(((unsigned long )(& ((struct tempnode *)0)->name) + len) + sizeof(slashbase));
#line 746
  node = (struct tempnode *)tmp___0;
#line 748
  file = node->name;
#line 751
  memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)temp_dir,
         len);
#line 752
  memcpy((void */* __restrict  */)(file + len), (void const   */* __restrict  */)(slashbase),
         sizeof(slashbase));
#line 753
  node->next = (struct tempnode */* volatile  */)((void *)0);
#line 754
  node->pid = 0;
#line 755
  temp_dir_index ++;
  }
#line 755
  if (temp_dir_index == temp_dir_count) {
#line 756
    temp_dir_index = (size_t )0;
  }
  {
#line 759
  cs = cs_enter();
#line 760
  fd = mkstemp_safer(file);
  }
#line 761
  if (0 <= fd) {
#line 763
    *temptail = (struct tempnode */* volatile  */)node;
#line 764
    temptail = & node->next;
  }
  {
#line 766
  tmp___1 = __errno_location();
#line 766
  saved_errno = *tmp___1;
#line 767
  cs_leave(cs);
#line 768
  tmp___2 = __errno_location();
#line 768
  *tmp___2 = saved_errno;
  }
#line 770
  if (fd < 0) {
    {
#line 771
    tmp___3 = quote(temp_dir);
#line 771
    tmp___4 = gettext("cannot create temporary file in %s");
#line 771
    tmp___5 = __errno_location();
#line 771
    error(2, *tmp___5, (char const   *)tmp___4, tmp___3);
    }
  }
#line 774
  *pfd = fd;
#line 775
  return (node);
}
}
#line 784 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static FILE *xfopen(char const   *file , char const   *how ) 
{ 
  FILE *fp ;
  char *tmp ;
  int tmp___0 ;

  {
#line 789
  if (! file) {
#line 790
    fp = stdout;
  } else {
    {
#line 791
    tmp___0 = strcmp(file, "-");
    }
#line 791
    if (tmp___0 == 0) {
#line 791
      if ((int const   )*how == 114) {
#line 793
        have_read_stdin = (_Bool)1;
#line 794
        fp = stdin;
      } else {
#line 791
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 798
      fp = fopen_safer(file, how);
      }
#line 799
      if (! fp) {
        {
#line 800
        tmp = gettext("open failed");
#line 800
        die((char const   *)tmp, file);
        }
      }
    }
  }
#line 803
  return (fp);
}
}
#line 808 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void xfclose(FILE *fp , char const   *file ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 811
  tmp = fileno(fp);
  }
  {
#line 813
  if (tmp == 0) {
#line 813
    goto case_0;
  }
#line 819
  if (tmp == 1) {
#line 819
    goto case_1;
  }
#line 825
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 815
  tmp___0 = feof_unlocked(fp);
  }
#line 815
  if (tmp___0) {
    {
#line 816
    clearerr_unlocked(fp);
    }
  }
#line 817
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 821
  tmp___2 = fflush_unlocked(fp);
  }
#line 821
  if (tmp___2 != 0) {
    {
#line 822
    tmp___1 = gettext("fflush failed");
#line 822
    die((char const   *)tmp___1, file);
    }
  }
#line 823
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 826
  tmp___4 = fclose(fp);
  }
#line 826
  if (tmp___4 != 0) {
    {
#line 827
    tmp___3 = gettext("close failed");
#line 827
    die((char const   *)tmp___3, file);
    }
  }
#line 828
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 830
  return;
}
}
#line 832 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void dup2_or_die(int oldfd , int newfd ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 835
  tmp___1 = dup2(oldfd, newfd);
  }
#line 835
  if (tmp___1 < 0) {
    {
#line 836
    tmp = gettext("dup2 failed");
#line 836
    tmp___0 = __errno_location();
#line 836
    error(2, *tmp___0, (char const   *)tmp);
    }
  }
#line 837
  return;
}
}
#line 843 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static pid_t pipe_fork(int *pipefds , size_t tries ) 
{ 
  struct tempnode *saved_temphead ;
  int saved_errno ;
  unsigned int wait_retry ;
  pid_t pid ;
  struct cs_status cs ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 849
  wait_retry = 1U;
#line 853
  tmp = pipe(pipefds);
  }
#line 853
  if (tmp < 0) {
#line 854
    return (-1);
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    tmp___3 = tries;
#line 856
    tries --;
#line 856
    if (! tmp___3) {
#line 856
      goto while_break;
    }
    {
#line 860
    cs = cs_enter();
#line 861
    saved_temphead = (struct tempnode *)temphead;
#line 862
    temphead = (struct tempnode */* volatile  */)((void *)0);
#line 864
    pid = fork();
#line 865
    tmp___0 = __errno_location();
#line 865
    saved_errno = *tmp___0;
    }
#line 866
    if (pid) {
#line 867
      temphead = (struct tempnode */* volatile  */)saved_temphead;
    }
    {
#line 869
    cs_leave(cs);
#line 870
    tmp___1 = __errno_location();
#line 870
    *tmp___1 = saved_errno;
    }
#line 872
    if (0 <= pid) {
#line 873
      goto while_break;
    } else {
      {
#line 872
      tmp___2 = __errno_location();
      }
#line 872
      if (*tmp___2 != 11) {
#line 873
        goto while_break;
      } else {
        {
#line 876
        sleep(wait_retry);
#line 877
        wait_retry *= 2U;
#line 878
        reap_some();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  if (pid < 0) {
    {
#line 884
    close(*(pipefds + 0));
#line 885
    close(*(pipefds + 1));
    }
  } else
#line 887
  if (pid == 0) {
    {
#line 889
    close(0);
#line 890
    close(1);
    }
  } else {
#line 893
    nprocs ++;
  }
#line 895
  return (pid);
}
}
#line 906 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char *create_temp(FILE **pfp , pid_t *ppid ) 
{ 
  int tempfd ;
  struct tempnode *node ;
  struct tempnode *tmp ;
  char *name ;
  int pipefds[2] ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 910
  tmp = create_temp_file(& tempfd);
#line 910
  node = tmp;
#line 911
  name = node->name;
  }
#line 913
  if (compress_program) {
    {
#line 917
    node->pid = pipe_fork((int *)(pipefds), (size_t )2);
    }
#line 918
    if (0 < node->pid) {
      {
#line 920
      close(tempfd);
#line 921
      close(pipefds[0]);
#line 922
      tempfd = pipefds[1];
#line 924
      register_proc(node->pid);
      }
    } else
#line 926
    if (node->pid == 0) {
      {
#line 928
      close(pipefds[1]);
#line 929
      dup2_or_die(tempfd, 1);
#line 930
      close(tempfd);
#line 931
      dup2_or_die(pipefds[0], 0);
#line 932
      close(pipefds[0]);
#line 934
      tmp___2 = execlp(compress_program, compress_program, (char *)((void *)0));
      }
#line 934
      if (tmp___2 < 0) {
        {
#line 935
        tmp___0 = gettext("couldn\'t execute %s");
#line 935
        tmp___1 = __errno_location();
#line 935
        error(2, *tmp___1, (char const   *)tmp___0, compress_program);
        }
      }
    } else {
#line 939
      node->pid = 0;
    }
  }
  {
#line 942
  *pfp = fdopen(tempfd, "w");
  }
#line 943
  if (! *pfp) {
    {
#line 944
    tmp___3 = gettext("couldn\'t create temporary file");
#line 944
    die((char const   *)tmp___3, (char const   *)name);
    }
  }
#line 946
  if (ppid) {
#line 947
    *ppid = node->pid;
  }
#line 949
  return (name);
}
}
#line 956 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static FILE *open_temp(char const   *name , pid_t pid ) 
{ 
  int tempfd ;
  int pipefds[2] ;
  pid_t child_pid ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 963
  wait_proc(pid);
#line 965
  tempfd = open(name, 0);
  }
#line 966
  if (tempfd < 0) {
    {
#line 967
    tmp = gettext("couldn\'t open temporary file");
#line 967
    die((char const   *)tmp, name);
    }
  }
  {
#line 969
  child_pid = pipe_fork((int *)(pipefds), (size_t )8);
  }
#line 970
  if (0 < child_pid) {
    {
#line 972
    close(tempfd);
#line 973
    close(pipefds[1]);
    }
  } else
#line 975
  if (child_pid == 0) {
    {
#line 977
    close(pipefds[0]);
#line 978
    dup2_or_die(tempfd, 0);
#line 979
    close(tempfd);
#line 980
    dup2_or_die(pipefds[1], 1);
#line 981
    close(pipefds[1]);
#line 983
    tmp___2 = execlp(compress_program, compress_program, "-d", (char *)((void *)0));
    }
#line 983
    if (tmp___2 < 0) {
      {
#line 984
      tmp___0 = gettext("couldn\'t execute %s -d");
#line 984
      tmp___1 = __errno_location();
#line 984
      error(2, *tmp___1, (char const   *)tmp___0, compress_program);
      }
    }
  } else {
    {
#line 988
    tmp___3 = gettext("couldn\'t create process for %s -d");
#line 988
    tmp___4 = __errno_location();
#line 988
    error(2, *tmp___4, (char const   *)tmp___3, compress_program);
    }
  }
  {
#line 991
  fp = fdopen(pipefds[0], "r");
  }
#line 992
  if (! fp) {
    {
#line 993
    tmp___5 = gettext("couldn\'t create temporary file");
#line 993
    die((char const   *)tmp___5, name);
    }
  }
#line 995
  return (fp);
}
}
#line 998 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void write_bytes(char const   *buf___1 , size_t n_bytes , FILE *fp , char const   *output_file ) 
{ 
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1001
  tmp___0 = fwrite_unlocked((void const   */* __restrict  */)buf___1, (size_t )1,
                            n_bytes, (FILE */* __restrict  */)fp);
  }
#line 1001
  if (tmp___0 != n_bytes) {
    {
#line 1002
    tmp = gettext("write failed");
#line 1002
    die((char const   *)tmp, output_file);
    }
  }
#line 1003
  return;
}
}
#line 1006 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void add_temp_dir(char const   *dir ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
#line 1009
  if (temp_dir_count == temp_dir_alloc) {
    {
#line 1010
    tmp = x2nrealloc((void *)temp_dirs, & temp_dir_alloc, sizeof(*temp_dirs));
#line 1010
    temp_dirs = (char const   **)tmp;
    }
  }
#line 1012
  tmp___0 = temp_dir_count;
#line 1012
  temp_dir_count ++;
#line 1012
  *(temp_dirs + tmp___0) = dir;
#line 1013
  return;
}
}
#line 1017 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void zaptemp(char const   *name ) 
{ 
  struct tempnode * volatile  *pnode ;
  struct tempnode *node ;
  struct tempnode *next ;
  int unlink_status ;
  int unlink_errno ;
  struct cs_status cs ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 1024
  unlink_errno = 0;
#line 1027
  pnode = & temphead;
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    node = (struct tempnode *)*pnode;
#line 1027
    if (! ((unsigned long )(node->name) != (unsigned long )name)) {
#line 1027
      goto while_break;
    }
#line 1028
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1027
    pnode = & node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1031
  next = (struct tempnode *)node->next;
#line 1032
  cs = cs_enter();
#line 1033
  unlink_status = unlink(name);
#line 1034
  tmp = __errno_location();
#line 1034
  unlink_errno = *tmp;
#line 1035
  *pnode = (struct tempnode */* volatile  */)next;
#line 1036
  cs_leave(cs);
  }
#line 1038
  if (unlink_status != 0) {
    {
#line 1039
    tmp___0 = gettext("warning: cannot remove: %s");
#line 1039
    error(0, unlink_errno, (char const   *)tmp___0, name);
    }
  }
#line 1040
  if (! next) {
#line 1041
    temptail = pnode;
  }
  {
#line 1042
  free((void *)node);
  }
#line 1043
  return;
}
}
#line 1047 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int struct_month_cmp(void const   *m1 , void const   *m2 ) 
{ 
  struct month  const  *month1 ;
  struct month  const  *month2 ;
  int tmp ;

  {
  {
#line 1050
  month1 = (struct month  const  *)m1;
#line 1051
  month2 = (struct month  const  *)m2;
#line 1052
  tmp = strcmp((char const   *)month1->name, (char const   *)month2->name);
  }
#line 1052
  return (tmp);
}
}
#line 1059 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void inittables(void) 
{ 
  size_t i ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *s ;
  size_t s_len ;
  size_t j ;
  char *name ;
  char *tmp___7 ;
  void *tmp___8 ;
  unsigned char tmp___9 ;

  {
#line 1064
  i = (size_t )0;
  {
#line 1064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    if (! (i < 256UL)) {
#line 1064
      goto while_break;
    }
    {
#line 1066
    tmp = __ctype_b_loc();
    }
#line 1066
    if ((int const   )*(*tmp + (int )i) & 1) {
#line 1066
      tmp___0 = 1;
    } else {
#line 1066
      tmp___0 = 0;
    }
    {
#line 1066
    blanks[i] = (_Bool )tmp___0;
#line 1067
    tmp___1 = __ctype_b_loc();
    }
#line 1067
    if ((int const   )*(*tmp___1 + (int )i) & 16384) {
#line 1067
      tmp___2 = 0;
    } else {
#line 1067
      tmp___2 = 1;
    }
    {
#line 1067
    nonprinting[i] = (_Bool )tmp___2;
#line 1068
    tmp___3 = __ctype_b_loc();
    }
#line 1068
    if ((int const   )*(*tmp___3 + (int )i) & 8) {
#line 1068
      tmp___5 = 0;
    } else {
      {
#line 1068
      tmp___4 = __ctype_b_loc();
      }
#line 1068
      if ((int const   )*(*tmp___4 + (int )i) & 1) {
#line 1068
        tmp___5 = 0;
      } else {
#line 1068
        tmp___5 = 1;
      }
    }
    {
#line 1068
    nondictionary[i] = (_Bool )tmp___5;
#line 1069
    tmp___6 = toupper((int )i);
#line 1069
    fold_toupper[i] = (char )tmp___6;
#line 1064
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1074
  if (hard_LC_TIME) {
#line 1076
    i = (size_t )0;
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1076
      if (! (i < 12UL)) {
#line 1076
        goto while_break___0;
      }
      {
#line 1083
      tmp___7 = nl_langinfo((nl_item )(131086UL + i));
#line 1083
      s = (char const   *)tmp___7;
#line 1084
      s_len = strlen(s);
#line 1085
      tmp___8 = xmalloc(s_len + 1UL);
#line 1085
      name = (char *)tmp___8;
#line 1085
      monthtab[i].name = (char const   *)name;
#line 1086
      monthtab[i].val = (int )(i + 1UL);
#line 1088
      j = (size_t )0;
      }
      {
#line 1088
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1088
        if (! (j < s_len)) {
#line 1088
          goto while_break___1;
        }
        {
#line 1089
        tmp___9 = to_uchar((char )*(s + j));
#line 1089
        *(name + j) = fold_toupper[tmp___9];
#line 1088
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1090
      *(name + j) = (char )'\000';
#line 1076
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1092
    qsort((void *)(monthtab), (size_t )12, sizeof(monthtab[0]), & struct_month_cmp);
    }
  }
#line 1096
  return;
}
}
#line 1101 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void specify_nmerge(int oi , char c , char const   *s ) 
{ 
  uintmax_t n ;
  struct rlimit rlimit ;
  enum strtol_error e ;
  strtol_error tmp ;
  unsigned int max_nmerge ;
  rlim_t tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char max_nmerge_buf[(((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1106
  tmp = xstrtoumax(s, (char **)((void *)0), 10, & n, (char const   *)((void *)0));
#line 1106
  e = tmp;
#line 1111
  tmp___2 = getrlimit((__rlimit_resource_t )7, & rlimit);
  }
#line 1111
  if (tmp___2 == 0) {
#line 1111
    tmp___1 = rlimit.rlim_cur;
  } else {
#line 1111
    tmp___1 = (rlim_t )20;
  }
#line 1111
  max_nmerge = (unsigned int )(tmp___1 - 3UL);
#line 1116
  if ((unsigned int )e == 0U) {
#line 1118
    nmerge = (unsigned int )n;
#line 1119
    if ((uintmax_t )nmerge != n) {
#line 1120
      e = (enum strtol_error )1;
    } else
#line 1123
    if (nmerge < 2U) {
      {
#line 1125
      tmp___3 = quote(s);
#line 1125
      tmp___4 = gettext("invalid --%s argument %s");
#line 1125
      error(0, 0, (char const   *)tmp___4, long_options___1[oi].name, tmp___3);
#line 1127
      tmp___5 = quote("2");
#line 1127
      tmp___6 = gettext("minimum --%s argument is %s");
#line 1127
      error(2, 0, (char const   *)tmp___6, long_options___1[oi].name, tmp___5);
      }
    } else
#line 1131
    if (max_nmerge < nmerge) {
#line 1133
      e = (enum strtol_error )1;
    } else {
#line 1136
      return;
    }
  }
#line 1140
  if ((unsigned int )e == 1U) {
    {
#line 1143
    tmp___7 = quote(s);
#line 1143
    tmp___8 = gettext("--%s argument %s too large");
#line 1143
    error(0, 0, (char const   *)tmp___8, long_options___1[oi].name, tmp___7);
#line 1145
    tmp___9 = uinttostr(max_nmerge, max_nmerge_buf);
#line 1145
    tmp___10 = gettext("maximum --%s argument with current rlimit is %s");
#line 1145
    error(2, 0, (char const   *)tmp___10, long_options___1[oi].name, tmp___9);
    }
  } else {
    {
#line 1151
    xstrtol_fatal(e, oi, c, long_options___1, s);
    }
  }
#line 1152
  return;
}
}
#line 1155 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void specify_sort_size(int oi , char c , char const   *s ) 
{ 
  uintmax_t n ;
  char *suffix ;
  enum strtol_error e ;
  strtol_error tmp ;
  double mem ;
  double tmp___0 ;

  {
  {
#line 1160
  tmp = xstrtoumax(s, & suffix, 10, & n, "EgGkKmMPtTYZ");
#line 1160
  e = tmp;
  }
#line 1163
  if ((unsigned int )e == 0U) {
#line 1163
    if ((unsigned int )*(suffix + -1) - 48U <= 9U) {
#line 1165
      if (n <= 18014398509481983UL) {
#line 1166
        n *= 1024UL;
      } else {
#line 1168
        e = (enum strtol_error )1;
      }
    }
  }
#line 1172
  if ((unsigned int )e == 2U) {
#line 1172
    if ((unsigned int )*(suffix + -1) - 48U <= 9U) {
#line 1172
      if (! *(suffix + 1)) {
        {
#line 1175
        if ((int )*(suffix + 0) == 98) {
#line 1175
          goto case_98;
        }
#line 1179
        if ((int )*(suffix + 0) == 37) {
#line 1179
          goto case_37;
        }
#line 1173
        goto switch_break;
        case_98: /* CIL Label */ 
#line 1176
        e = (enum strtol_error )0;
#line 1177
        goto switch_break;
        case_37: /* CIL Label */ 
        {
#line 1181
        tmp___0 = physmem_total();
#line 1181
        mem = (tmp___0 * (double )n) / (double )100;
        }
#line 1184
        if (mem < (double )0xffffffffffffffffUL) {
#line 1186
          n = (uintmax_t )mem;
#line 1187
          e = (enum strtol_error )0;
        } else {
#line 1190
          e = (enum strtol_error )1;
        }
#line 1192
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1195
  if ((unsigned int )e == 0U) {
#line 1199
    if (n < sort_size) {
#line 1200
      return;
    }
#line 1202
    sort_size = n;
#line 1203
    if (sort_size == n) {
#line 1205
      if (sort_size > (unsigned long )nmerge * (2UL + sizeof(struct line ))) {
#line 1205
        sort_size = sort_size;
      } else {
#line 1205
        sort_size = (unsigned long )nmerge * (2UL + sizeof(struct line ));
      }
#line 1206
      return;
    }
#line 1209
    e = (enum strtol_error )1;
  }
  {
#line 1212
  xstrtol_fatal(e, oi, c, long_options___1, s);
  }
}
}
#line 1216 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t default_sort_size(void) 
{ 
  double avail ;
  double tmp ;
  double total ;
  double tmp___0 ;
  double mem ;
  double tmp___1 ;
  struct rlimit rlimit ;
  size_t size ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 1221
  tmp = physmem_available();
#line 1221
  avail = tmp;
#line 1222
  tmp___0 = physmem_total();
#line 1222
  total = tmp___0;
  }
#line 1223
  if (avail > total / (double )8) {
#line 1223
    tmp___1 = avail;
  } else {
#line 1223
    tmp___1 = total / (double )8;
  }
#line 1223
  mem = tmp___1;
#line 1231
  size = 0xffffffffffffffffUL;
#line 1232
  if (mem < (double )size) {
#line 1233
    size = (size_t )mem;
  }
  {
#line 1234
  tmp___2 = getrlimit((__rlimit_resource_t )2, & rlimit);
  }
#line 1234
  if (tmp___2 == 0) {
#line 1234
    if (rlimit.rlim_cur < size) {
#line 1235
      size = rlimit.rlim_cur;
    }
  }
  {
#line 1237
  tmp___3 = getrlimit((__rlimit_resource_t )9, & rlimit);
  }
#line 1237
  if (tmp___3 == 0) {
#line 1237
    if (rlimit.rlim_cur < size) {
#line 1238
      size = rlimit.rlim_cur;
    }
  }
  {
#line 1243
  size /= 2UL;
#line 1248
  tmp___4 = getrlimit((__rlimit_resource_t )5, & rlimit);
  }
#line 1248
  if (tmp___4 == 0) {
#line 1248
    if ((rlimit.rlim_cur / 16UL) * 15UL < size) {
#line 1249
      size = (rlimit.rlim_cur / 16UL) * 15UL;
    }
  }
#line 1253
  if (size > (unsigned long )nmerge * (2UL + sizeof(struct line ))) {
#line 1253
    tmp___5 = size;
  } else {
#line 1253
    tmp___5 = (unsigned long )nmerge * (2UL + sizeof(struct line ));
  }
#line 1253
  return (tmp___5);
}
}
#line 1270 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t size_bound  ;
#line 1263 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t sort_buffer_size(FILE * const  *fps , size_t nfps , char * const  *files ,
                               size_t nfiles , size_t line_bytes ) 
{ 
  size_t worst_case_per_input_byte ;
  size_t size ;
  size_t i ;
  struct stat st ;
  off_t file_size ;
  size_t worst_case ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1273
  worst_case_per_input_byte = line_bytes + 1UL;
#line 1277
  size = worst_case_per_input_byte + 1UL;
#line 1281
  i = (size_t )0;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! (i < nfiles)) {
#line 1281
      goto while_break;
    }
#line 1287
    if (i < nfps) {
      {
#line 1287
      tmp___0 = fileno((FILE *)*(fps + i));
#line 1287
      tmp___1 = fstat(tmp___0, & st);
#line 1287
      tmp___7 = tmp___1;
      }
    } else {
      {
#line 1287
      tmp___6 = strcmp((char const   *)*(files + i), "-");
      }
#line 1287
      if (tmp___6 == 0) {
        {
#line 1287
        tmp___3 = fstat(0, & st);
#line 1287
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 1287
        tmp___4 = stat((char const   */* __restrict  */)*(files + i), (struct stat */* __restrict  */)(& st));
#line 1287
        tmp___5 = tmp___4;
        }
      }
#line 1287
      tmp___7 = tmp___5;
    }
#line 1287
    if (tmp___7 != 0) {
      {
#line 1291
      tmp = gettext("stat failed");
#line 1291
      die((char const   *)tmp, (char const   *)*(files + i));
      }
    }
#line 1293
    if ((st.st_mode & 61440U) == 32768U) {
#line 1294
      file_size = st.st_size;
    } else {
#line 1299
      if (sort_size) {
#line 1300
        return (sort_size);
      }
#line 1301
      file_size = (off_t )1048576;
    }
#line 1304
    if (! size_bound) {
#line 1306
      size_bound = sort_size;
#line 1307
      if (! size_bound) {
        {
#line 1308
        size_bound = default_sort_size();
        }
      }
    }
#line 1314
    worst_case = (size_t )file_size * worst_case_per_input_byte + 1UL;
#line 1315
    if ((size_t )file_size != worst_case / worst_case_per_input_byte) {
#line 1317
      return (size_bound);
    } else
#line 1315
    if (size_bound - size <= worst_case) {
#line 1317
      return (size_bound);
    }
#line 1318
    size += worst_case;
#line 1281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  return (size);
}
}
#line 1328 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void initbuf(struct buffer *buf___1 , size_t line_bytes , size_t alloc ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1337
    alloc += sizeof(struct line ) - alloc % sizeof(struct line );
#line 1338
    tmp = malloc(alloc);
#line 1338
    buf___1->buf = (char *)tmp;
    }
#line 1339
    if (buf___1->buf) {
#line 1340
      goto while_break;
    }
#line 1341
    alloc /= 2UL;
#line 1342
    if (alloc <= line_bytes + 1UL) {
      {
#line 1343
      xalloc_die();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1346
  buf___1->line_bytes = line_bytes;
#line 1347
  buf___1->alloc = alloc;
#line 1348
  tmp___1 = (size_t )0;
#line 1348
  buf___1->nlines = tmp___1;
#line 1348
  tmp___0 = tmp___1;
#line 1348
  buf___1->left = tmp___0;
#line 1348
  buf___1->used = tmp___0;
#line 1349
  buf___1->eof = (_Bool)0;
#line 1350
  return;
}
}
#line 1354 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
__inline static struct line *buffer_linelim(struct buffer  const  *buf___1 ) 
{ 


  {
#line 1357
  return ((struct line *)(buf___1->buf + buf___1->alloc));
}
}
#line 1363 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char *begfield(struct line  const  *line , struct keyfield  const  *key ) 
{ 
  char *ptr ;
  char *lim ;
  size_t sword ;
  size_t schar ;
  size_t remaining_bytes ;
  size_t tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  size_t tmp___2 ;
  unsigned char tmp___3 ;

  {
#line 1366
  ptr = (char *)line->text;
#line 1366
  lim = (ptr + line->length) - 1;
#line 1367
  sword = (size_t )key->sword;
#line 1368
  schar = (size_t )key->schar;
#line 1374
  if (tab != 128) {
    {
#line 1375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1375
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1375
        tmp = sword;
#line 1375
        sword --;
#line 1375
        if (! tmp) {
#line 1375
          goto while_break;
        }
      } else {
#line 1375
        goto while_break;
      }
      {
#line 1377
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1377
        if ((unsigned long )ptr < (unsigned long )lim) {
#line 1377
          if (! ((int )*ptr != tab)) {
#line 1377
            goto while_break___0;
          }
        } else {
#line 1377
          goto while_break___0;
        }
#line 1378
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1379
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1380
        ptr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1383
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1383
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1383
        tmp___2 = sword;
#line 1383
        sword --;
#line 1383
        if (! tmp___2) {
#line 1383
          goto while_break___1;
        }
      } else {
#line 1383
        goto while_break___1;
      }
      {
#line 1385
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1385
        if ((unsigned long )ptr < (unsigned long )lim) {
          {
#line 1385
          tmp___0 = to_uchar(*ptr);
          }
#line 1385
          if (! blanks[tmp___0]) {
#line 1385
            goto while_break___2;
          }
        } else {
#line 1385
          goto while_break___2;
        }
#line 1386
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1387
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1387
        if ((unsigned long )ptr < (unsigned long )lim) {
          {
#line 1387
          tmp___1 = to_uchar(*ptr);
          }
#line 1387
          if (blanks[tmp___1]) {
#line 1387
            goto while_break___3;
          }
        } else {
#line 1387
          goto while_break___3;
        }
#line 1388
        ptr ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1391
  if (key->skipsblanks) {
    {
#line 1392
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1392
      if ((unsigned long )ptr < (unsigned long )lim) {
        {
#line 1392
        tmp___3 = to_uchar(*ptr);
        }
#line 1392
        if (! blanks[tmp___3]) {
#line 1392
          goto while_break___4;
        }
      } else {
#line 1392
        goto while_break___4;
      }
#line 1393
      ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1396
  remaining_bytes = (size_t )(lim - ptr);
#line 1397
  if (schar < remaining_bytes) {
#line 1398
    ptr += schar;
  } else {
#line 1400
    ptr = lim;
  }
#line 1402
  return (ptr);
}
}
#line 1408 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char *limfield(struct line  const  *line , struct keyfield  const  *key ) 
{ 
  char *ptr ;
  char *lim ;
  size_t eword ;
  size_t echar ;
  size_t remaining_bytes ;
  size_t tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  size_t tmp___2 ;
  unsigned char tmp___3 ;

  {
#line 1411
  ptr = (char *)line->text;
#line 1411
  lim = (ptr + line->length) - 1;
#line 1412
  eword = (size_t )key->eword;
#line 1412
  echar = (size_t )key->echar;
#line 1422
  if (tab != 128) {
    {
#line 1423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1423
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1423
        tmp = eword;
#line 1423
        eword --;
#line 1423
        if (! tmp) {
#line 1423
          goto while_break;
        }
      } else {
#line 1423
        goto while_break;
      }
      {
#line 1425
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1425
        if ((unsigned long )ptr < (unsigned long )lim) {
#line 1425
          if (! ((int )*ptr != tab)) {
#line 1425
            goto while_break___0;
          }
        } else {
#line 1425
          goto while_break___0;
        }
#line 1426
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1427
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1427
        if (eword | echar) {
#line 1428
          ptr ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1431
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1431
      if ((unsigned long )ptr < (unsigned long )lim) {
#line 1431
        tmp___2 = eword;
#line 1431
        eword --;
#line 1431
        if (! tmp___2) {
#line 1431
          goto while_break___1;
        }
      } else {
#line 1431
        goto while_break___1;
      }
      {
#line 1433
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1433
        if ((unsigned long )ptr < (unsigned long )lim) {
          {
#line 1433
          tmp___0 = to_uchar(*ptr);
          }
#line 1433
          if (! blanks[tmp___0]) {
#line 1433
            goto while_break___2;
          }
        } else {
#line 1433
          goto while_break___2;
        }
#line 1434
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1435
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1435
        if ((unsigned long )ptr < (unsigned long )lim) {
          {
#line 1435
          tmp___1 = to_uchar(*ptr);
          }
#line 1435
          if (blanks[tmp___1]) {
#line 1435
            goto while_break___3;
          }
        } else {
#line 1435
          goto while_break___3;
        }
#line 1436
        ptr ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1493
  if (key->skipeblanks) {
    {
#line 1494
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1494
      if ((unsigned long )ptr < (unsigned long )lim) {
        {
#line 1494
        tmp___3 = to_uchar(*ptr);
        }
#line 1494
        if (! blanks[tmp___3]) {
#line 1494
          goto while_break___4;
        }
      } else {
#line 1494
        goto while_break___4;
      }
#line 1495
      ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1498
  remaining_bytes = (size_t )(lim - ptr);
#line 1499
  if (echar < remaining_bytes) {
#line 1500
    ptr += echar;
  } else {
#line 1502
    ptr = lim;
  }
#line 1504
  return (ptr);
}
}
#line 1513 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool fillbuf___7(struct buffer *buf___1 , FILE *fp , char const   *file ) 
{ 
  struct keyfield  const  *key ;
  char eol ;
  size_t line_bytes ;
  size_t mergesize ;
  char *ptr ;
  struct line *linelim ;
  struct line *tmp ;
  struct line *line ;
  size_t avail ;
  char *line_start ;
  char *tmp___0 ;
  size_t readsize ;
  size_t bytes_read ;
  size_t tmp___1 ;
  char *ptrlim ;
  char *p ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  unsigned char tmp___7 ;
  void *tmp___8 ;
  struct line *tmp___9 ;
  size_t line_alloc ;
  void *tmp___10 ;

  {
#line 1516
  key = (struct keyfield  const  *)keylist;
#line 1517
  eol = eolchar;
#line 1518
  line_bytes = buf___1->line_bytes;
#line 1519
  mergesize = merge_buffer_size - (2UL + sizeof(struct line ));
#line 1521
  if (buf___1->eof) {
#line 1522
    return ((_Bool)0);
  }
#line 1524
  if (buf___1->used != buf___1->left) {
    {
#line 1526
    memmove((void *)buf___1->buf, (void const   *)((buf___1->buf + buf___1->used) - buf___1->left),
            buf___1->left);
#line 1527
    buf___1->used = buf___1->left;
#line 1528
    buf___1->nlines = (size_t )0;
    }
  }
  {
#line 1531
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1533
    ptr = buf___1->buf + buf___1->used;
#line 1534
    tmp = buffer_linelim((struct buffer  const  *)buf___1);
#line 1534
    linelim = tmp;
#line 1535
    line = linelim - buf___1->nlines;
#line 1536
    avail = (size_t )(((char *)linelim - buf___1->nlines * line_bytes) - ptr);
    }
#line 1537
    if (buf___1->nlines) {
#line 1537
      tmp___0 = line->text + line->length;
    } else {
#line 1537
      tmp___0 = buf___1->buf;
    }
#line 1537
    line_start = tmp___0;
    {
#line 1539
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1539
      if (! (line_bytes + 1UL < avail)) {
#line 1539
        goto while_break___0;
      }
      {
#line 1546
      readsize = (avail - 1UL) / (line_bytes + 1UL);
#line 1547
      tmp___1 = fread_unlocked((void */* __restrict  */)ptr, (size_t )1, readsize,
                               (FILE */* __restrict  */)fp);
#line 1547
      bytes_read = tmp___1;
#line 1548
      ptrlim = ptr + bytes_read;
#line 1550
      avail -= bytes_read;
      }
#line 1552
      if (bytes_read != readsize) {
        {
#line 1554
        tmp___3 = ferror_unlocked(fp);
        }
#line 1554
        if (tmp___3) {
          {
#line 1555
          tmp___2 = gettext("read failed");
#line 1555
          die((char const   *)tmp___2, file);
          }
        }
        {
#line 1556
        tmp___5 = feof_unlocked(fp);
        }
#line 1556
        if (tmp___5) {
#line 1558
          buf___1->eof = (_Bool)1;
#line 1559
          if ((unsigned long )buf___1->buf == (unsigned long )ptrlim) {
#line 1560
            return ((_Bool)0);
          }
#line 1561
          if ((int )*(ptrlim + -1) != (int )eol) {
#line 1562
            tmp___4 = ptrlim;
#line 1562
            ptrlim ++;
#line 1562
            *tmp___4 = eol;
          }
        }
      }
      {
#line 1567
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1567
        tmp___8 = memchr((void const   *)ptr, (int )eol, (size_t )(ptrlim - ptr));
#line 1567
        p = (char *)tmp___8;
        }
#line 1567
        if (! p) {
#line 1567
          goto while_break___1;
        }
#line 1569
        ptr = p + 1;
#line 1570
        line --;
#line 1571
        line->text = line_start;
#line 1572
        line->length = (size_t )(ptr - line_start);
#line 1573
        if (mergesize > line->length) {
#line 1573
          mergesize = mergesize;
        } else {
#line 1573
          mergesize = line->length;
        }
#line 1574
        avail -= line_bytes;
#line 1576
        if (key) {
#line 1580
          if (key->eword == 0xffffffffffffffffUL) {
#line 1580
            line->keylim = p;
          } else {
            {
#line 1580
            tmp___6 = limfield((struct line  const  *)line, key);
#line 1580
            line->keylim = tmp___6;
            }
          }
#line 1584
          if (key->sword != 0xffffffffffffffffUL) {
            {
#line 1585
            line->keybeg = begfield((struct line  const  *)line, key);
            }
          } else {
#line 1588
            if (key->skipsblanks) {
              {
#line 1589
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 1589
                tmp___7 = to_uchar(*line_start);
                }
#line 1589
                if (! blanks[tmp___7]) {
#line 1589
                  goto while_break___2;
                }
#line 1590
                line_start ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 1591
            line->keybeg = line_start;
          }
        }
#line 1595
        line_start = ptr;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1598
      ptr = ptrlim;
#line 1599
      if (buf___1->eof) {
#line 1600
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1603
    buf___1->used = (size_t )(ptr - buf___1->buf);
#line 1604
    tmp___9 = buffer_linelim((struct buffer  const  *)buf___1);
#line 1604
    buf___1->nlines = (size_t )(tmp___9 - line);
    }
#line 1605
    if (buf___1->nlines != 0UL) {
#line 1607
      buf___1->left = (size_t )(ptr - line_start);
#line 1608
      merge_buffer_size = mergesize + (2UL + sizeof(struct line ));
#line 1609
      return ((_Bool)1);
    }
    {
#line 1616
    line_alloc = buf___1->alloc / sizeof(struct line );
#line 1617
    tmp___10 = x2nrealloc((void *)buf___1->buf, & line_alloc, sizeof(struct line ));
#line 1617
    buf___1->buf = (char *)tmp___10;
#line 1618
    buf___1->alloc = line_alloc * sizeof(struct line );
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1627 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int numcompare___3(char const   *a , char const   *b ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1630
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1630
    tmp = to_uchar((char )*a);
    }
#line 1630
    if (! blanks[tmp]) {
#line 1630
      goto while_break;
    }
#line 1631
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1632
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1632
    tmp___0 = to_uchar((char )*b);
    }
#line 1632
    if (! blanks[tmp___0]) {
#line 1632
      goto while_break___0;
    }
#line 1633
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1635
  tmp___1 = strnumcmp(a, b, decimal_point, thousands_sep);
  }
#line 1635
  return (tmp___1);
}
}
#line 1638 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int general_numcompare(char const   *sa , char const   *sb ) 
{ 
  char *ea ;
  char *eb ;
  double a ;
  double tmp ;
  double b ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1647
  tmp = strtod((char const   */* __restrict  */)sa, (char **/* __restrict  */)(& ea));
#line 1647
  a = tmp;
#line 1648
  tmp___0 = strtod((char const   */* __restrict  */)sb, (char **/* __restrict  */)(& eb));
#line 1648
  b = tmp___0;
  }
#line 1651
  if ((unsigned long )sa == (unsigned long )ea) {
#line 1652
    if ((unsigned long )sb == (unsigned long )eb) {
#line 1652
      tmp___1 = 0;
    } else {
#line 1652
      tmp___1 = -1;
    }
#line 1652
    return (tmp___1);
  }
#line 1653
  if ((unsigned long )sb == (unsigned long )eb) {
#line 1654
    return (1);
  }
#line 1659
  if (a < b) {
#line 1659
    tmp___7 = -1;
  } else {
#line 1659
    if (a > b) {
#line 1659
      tmp___6 = 1;
    } else {
#line 1659
      if (a == b) {
#line 1659
        tmp___5 = 0;
      } else {
#line 1659
        if (b == b) {
#line 1659
          tmp___4 = -1;
        } else {
#line 1659
          if (a == a) {
#line 1659
            tmp___3 = 1;
          } else {
            {
#line 1659
            tmp___2 = memcmp((void const   *)((char *)(& a)), (void const   *)((char *)(& b)),
                             sizeof(a));
#line 1659
            tmp___3 = tmp___2;
            }
          }
#line 1659
          tmp___4 = tmp___3;
        }
#line 1659
        tmp___5 = tmp___4;
      }
#line 1659
      tmp___6 = tmp___5;
    }
#line 1659
    tmp___7 = tmp___6;
  }
#line 1659
  return (tmp___7);
}
}
#line 1670 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int getmonth(char const   *month , size_t len ) 
{ 
  size_t lo ;
  size_t hi ;
  char const   *monthlim ;
  unsigned char tmp ;
  size_t ix ;
  char const   *m ;
  char const   *n ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;

  {
#line 1673
  lo = (size_t )0;
#line 1674
  hi = (size_t )12;
#line 1675
  monthlim = month + len;
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1679
    if ((unsigned long )month == (unsigned long )monthlim) {
#line 1680
      return (0);
    }
    {
#line 1681
    tmp = to_uchar((char )*month);
    }
#line 1681
    if (! blanks[tmp]) {
#line 1682
      goto while_break;
    }
#line 1683
    month ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1688
    ix = (lo + hi) / 2UL;
#line 1689
    m = month;
#line 1690
    n = monthtab[ix].name;
    {
#line 1692
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1694
      if (! *n) {
#line 1695
        return (monthtab[ix].val);
      }
#line 1696
      if ((unsigned long )m == (unsigned long )monthlim) {
#line 1698
        hi = ix;
#line 1699
        goto while_break___1;
      } else {
        {
#line 1696
        tmp___2 = to_uchar((char )*m);
#line 1696
        tmp___3 = to_uchar((char )*n);
        }
#line 1696
        if ((int )fold_toupper[tmp___2] < (int )tmp___3) {
#line 1698
          hi = ix;
#line 1699
          goto while_break___1;
        } else {
          {
#line 1701
          tmp___0 = to_uchar((char )*m);
#line 1701
          tmp___1 = to_uchar((char )*n);
          }
#line 1701
          if ((int )fold_toupper[tmp___0] > (int )tmp___1) {
#line 1703
            lo = ix + 1UL;
#line 1704
            goto while_break___1;
          }
        }
      }
#line 1692
      m ++;
#line 1692
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1686
    if (! (lo < hi)) {
#line 1686
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1710
  return (0);
}
}
#line 1714 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct randread_source *randread_source  ;
#line 1725 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct md5_ctx *state  ;
#line 1726 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t used  ;
#line 1727 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t allocated  ;
#line 1720 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct md5_ctx random_state(size_t i ) 
{ 
  struct md5_ctx *s ;
  unsigned char buf___1[16] ;
  void *tmp ;

  {
#line 1729
  s = state + i;
#line 1731
  if (used <= i) {
#line 1735
    used ++;
#line 1737
    if (allocated <= i) {
      {
#line 1739
      tmp = x2nrealloc((void *)state, & allocated, sizeof(*state));
#line 1739
      state = (struct md5_ctx *)tmp;
#line 1740
      s = state + i;
      }
    }
    {
#line 1743
    randread(randread_source, (void *)(buf___1), sizeof(buf___1));
#line 1744
    md5_init_ctx(s);
#line 1745
    md5_process_bytes((void const   *)(buf___1), sizeof(buf___1), s);
    }
  }
#line 1748
  return (*s);
}
}
#line 1755 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int cmp_hashes(char const   *texta , size_t lena , char const   *textb , size_t lenb ) 
{ 
  int diff ;
  size_t i ;
  uint32_t dig[2][16UL / sizeof(uint32_t )] ;
  struct md5_ctx s[2] ;
  int tmp ;

  {
#line 1764
  i = (size_t )0;
  {
#line 1764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1768
    s[1] = random_state(i);
#line 1768
    s[0] = s[1];
#line 1769
    md5_process_bytes((void const   *)texta, lena, & s[0]);
#line 1769
    md5_finish_ctx(& s[0], (void *)(dig[0]));
#line 1770
    md5_process_bytes((void const   *)textb, lenb, & s[1]);
#line 1770
    md5_finish_ctx(& s[1], (void *)(dig[1]));
#line 1771
    diff = memcmp((void const   *)(dig[0]), (void const   *)(dig[1]), sizeof(dig[0]));
    }
#line 1772
    if (diff != 0) {
#line 1773
      goto while_break;
    }
#line 1774
    if (i == 0UL) {
#line 1774
      if (lena == lenb) {
        {
#line 1774
        tmp = memcmp((void const   *)texta, (void const   *)textb, lena);
        }
#line 1774
        if (tmp == 0) {
#line 1775
          goto while_break;
        }
      }
    }
#line 1764
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1778
  return (diff);
}
}
#line 1784 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int compare_random(char * __restrict  texta , size_t lena , char * __restrict  textb ,
                          size_t lenb ) 
{ 
  int diff ;
  char *buf___1 ;
  char stackbuf[4000] ;
  size_t tlena ;
  size_t tmp ;
  _Bool a_fits ;
  size_t tlenb ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 1790
  if (! hard_LC_COLLATE) {
    {
#line 1791
    diff = cmp_hashes((char const   *)texta, lena, (char const   *)textb, lenb);
    }
  } else {
    {
#line 1798
    buf___1 = (char *)((void *)0);
#line 1800
    tmp = xmemxfrm((char */* __restrict  */)(stackbuf), sizeof(stackbuf), texta, lena);
#line 1800
    tlena = tmp;
#line 1801
    a_fits = (_Bool )(tlena <= sizeof(stackbuf));
    }
#line 1802
    if (a_fits) {
#line 1802
      tmp___0 = sizeof(stackbuf) - tlena;
    } else {
#line 1802
      tmp___0 = 0UL;
    }
#line 1802
    if (a_fits) {
#line 1802
      tmp___1 = stackbuf + tlena;
    } else {
#line 1802
      tmp___1 = (char *)((void *)0);
    }
    {
#line 1802
    tmp___2 = xmemxfrm((char */* __restrict  */)tmp___1, tmp___0, textb, lenb);
#line 1802
    tlenb = tmp___2;
    }
#line 1806
    if (a_fits) {
#line 1806
      if (tlena + tlenb <= sizeof(stackbuf)) {
#line 1807
        buf___1 = stackbuf;
      } else {
        {
#line 1812
        tmp___3 = xmalloc((tlena + tlenb) + 1UL);
#line 1812
        buf___1 = (char *)tmp___3;
#line 1813
        xmemxfrm((char */* __restrict  */)buf___1, tlena + 1UL, texta, lena);
#line 1814
        xmemxfrm((char */* __restrict  */)(buf___1 + tlena), tlenb + 1UL, textb, lenb);
        }
      }
    } else {
      {
#line 1812
      tmp___3 = xmalloc((tlena + tlenb) + 1UL);
#line 1812
      buf___1 = (char *)tmp___3;
#line 1813
      xmemxfrm((char */* __restrict  */)buf___1, tlena + 1UL, texta, lena);
#line 1814
      xmemxfrm((char */* __restrict  */)(buf___1 + tlena), tlenb + 1UL, textb, lenb);
      }
    }
    {
#line 1817
    diff = cmp_hashes((char const   *)buf___1, tlena, (char const   *)(buf___1 + tlena),
                      tlenb);
    }
#line 1819
    if ((unsigned long )buf___1 != (unsigned long )(stackbuf)) {
      {
#line 1820
      free((void *)buf___1);
      }
    }
  }
#line 1823
  return (diff);
}
}
#line 1829 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int compare_version(char * __restrict  texta , size_t lena , char * __restrict  textb ,
                           size_t lenb ) 
{ 
  int diff ;
  char sv_a ;
  char sv_b ;

  {
  {
#line 1838
  sv_a = *(texta + lena);
#line 1839
  sv_b = *(textb + lenb);
#line 1841
  *(texta + lena) = (char )'\000';
#line 1842
  *(textb + lenb) = (char )'\000';
#line 1844
  diff = filevercmp((char const   *)texta, (char const   *)textb);
#line 1846
  *(texta + lena) = sv_a;
#line 1847
  *(textb + lenb) = sv_b;
  }
#line 1849
  return (diff);
}
}
#line 1855 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int keycompare(struct line  const  *a , struct line  const  *b ) 
{ 
  struct keyfield  const  *key ;
  char *texta ;
  char *textb ;
  char *lima ;
  char *limb ;
  int diff ;
  char const   *translate ;
  _Bool const   *ignore ;
  size_t lena ;
  long tmp ;
  size_t lenb ;
  long tmp___0 ;
  char savea ;
  char saveb ;
  char tmp___1 ;
  int (*tmp___2)(char const   *a , char const   *b ) ;
  int tmp___3 ;
  int tmp___4 ;
  char buf___1[4000] ;
  size_t size ;
  char *copy_a ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *copy_b ;
  size_t new_len_a ;
  size_t new_len_b ;
  size_t i ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  size_t tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned char tmp___19 ;
  unsigned char tmp___20 ;
  unsigned char tmp___21 ;
  char *tmp___22 ;
  unsigned char tmp___23 ;
  unsigned char tmp___24 ;
  char *tmp___25 ;
  unsigned char tmp___26 ;
  unsigned char tmp___27 ;
  size_t tmp___28 ;
  unsigned char tmp___29 ;
  unsigned char tmp___30 ;
  int tmp___31 ;

  {
#line 1858
  key = (struct keyfield  const  *)keylist;
#line 1862
  texta = (char *)a->keybeg;
#line 1863
  textb = (char *)b->keybeg;
#line 1864
  lima = (char *)a->keylim;
#line 1865
  limb = (char *)b->keylim;
  {
#line 1869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1871
    translate = (char const   *)key->translate;
#line 1872
    ignore = (_Bool const   *)key->ignore;
#line 1875
    if ((unsigned long )lima <= (unsigned long )texta) {
#line 1875
      tmp = 0L;
    } else {
#line 1875
      tmp = lima - texta;
    }
#line 1875
    lena = (size_t )tmp;
#line 1876
    if ((unsigned long )limb <= (unsigned long )textb) {
#line 1876
      tmp___0 = 0L;
    } else {
#line 1876
      tmp___0 = limb - textb;
    }
#line 1876
    lenb = (size_t )tmp___0;
#line 1880
    if (key->random) {
      {
#line 1881
      diff = compare_random((char */* __restrict  */)texta, lena, (char */* __restrict  */)textb,
                            lenb);
      }
    } else
#line 1882
    if ((int const   )key->numeric | (int const   )key->general_numeric) {
#line 1884
      savea = *lima;
#line 1884
      saveb = *limb;
#line 1886
      tmp___1 = (char )'\000';
#line 1886
      *limb = tmp___1;
#line 1886
      *lima = tmp___1;
#line 1887
      if (key->numeric) {
#line 1887
        tmp___2 = & numcompare___3;
      } else {
#line 1887
        tmp___2 = & general_numcompare;
      }
      {
#line 1887
      diff = (*tmp___2)((char const   *)texta, (char const   *)textb);
#line 1889
      *lima = savea;
#line 1889
      *limb = saveb;
      }
    } else
#line 1891
    if (key->version) {
      {
#line 1892
      diff = compare_version((char */* __restrict  */)texta, lena, (char */* __restrict  */)textb,
                             lenb);
      }
    } else
#line 1893
    if (key->month) {
      {
#line 1894
      tmp___3 = getmonth((char const   *)texta, lena);
#line 1894
      tmp___4 = getmonth((char const   *)textb, lenb);
#line 1894
      diff = tmp___3 - tmp___4;
      }
    } else
#line 1897
    if (hard_LC_COLLATE) {
#line 1899
      if (ignore) {
#line 1899
        goto _L;
      } else
#line 1899
      if (translate) {
        _L: /* CIL Label */ 
#line 1902
        size = ((lena + 1UL) + lenb) + 1UL;
#line 1903
        if (size <= sizeof(buf___1)) {
#line 1903
          tmp___6 = buf___1;
        } else {
          {
#line 1903
          tmp___5 = xmalloc(size);
#line 1903
          tmp___6 = (char *)tmp___5;
          }
        }
#line 1903
        copy_a = tmp___6;
#line 1904
        copy_b = (copy_a + lena) + 1;
#line 1908
        i = (size_t )0;
#line 1908
        new_len_b = i;
#line 1908
        new_len_a = new_len_b;
        {
#line 1908
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1908
          if (lena > lenb) {
#line 1908
            tmp___11 = lena;
          } else {
#line 1908
            tmp___11 = lenb;
          }
#line 1908
          if (! (i < tmp___11)) {
#line 1908
            goto while_break___0;
          }
#line 1910
          if (i < lena) {
#line 1912
            if (translate) {
              {
#line 1912
              tmp___7 = to_uchar(*(texta + i));
#line 1912
              *(copy_a + new_len_a) = (char )*(translate + tmp___7);
              }
            } else {
#line 1912
              *(copy_a + new_len_a) = *(texta + i);
            }
#line 1915
            if (! ignore) {
#line 1916
              new_len_a ++;
            } else {
              {
#line 1915
              tmp___8 = to_uchar(*(texta + i));
              }
#line 1915
              if (! *(ignore + tmp___8)) {
#line 1916
                new_len_a ++;
              }
            }
          }
#line 1918
          if (i < lenb) {
#line 1920
            if (translate) {
              {
#line 1920
              tmp___9 = to_uchar(*(textb + i));
#line 1920
              *(copy_b + new_len_b) = (char )*(translate + tmp___9);
              }
            } else {
#line 1920
              *(copy_b + new_len_b) = *(textb + i);
            }
#line 1923
            if (! ignore) {
#line 1924
              new_len_b ++;
            } else {
              {
#line 1923
              tmp___10 = to_uchar(*(textb + i));
              }
#line 1923
              if (! *(ignore + tmp___10)) {
#line 1924
                new_len_b ++;
              }
            }
          }
#line 1908
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1928
        diff = xmemcoll(copy_a, new_len_a, copy_b, new_len_b);
        }
#line 1930
        if (sizeof(buf___1) < size) {
          {
#line 1931
          free((void *)copy_a);
          }
        }
      } else
#line 1933
      if (lena == 0UL) {
#line 1934
        diff = - (lenb != 0UL);
      } else
#line 1935
      if (lenb == 0UL) {
#line 1936
        goto greater;
      } else {
        {
#line 1938
        diff = xmemcoll(texta, lena, textb, lenb);
        }
      }
    } else
#line 1940
    if (ignore) {
#line 1964
      if (translate) {
        {
#line 1965
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1965
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1965
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1965
              if ((unsigned long )texta < (unsigned long )lima) {
                {
#line 1965
                tmp___12 = to_uchar(*texta);
                }
#line 1965
                if (! *(ignore + tmp___12)) {
#line 1965
                  goto while_break___3;
                }
              } else {
#line 1965
                goto while_break___3;
              }
#line 1965
              texta ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 1965
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1965
              if ((unsigned long )textb < (unsigned long )limb) {
                {
#line 1965
                tmp___13 = to_uchar(*textb);
                }
#line 1965
                if (! *(ignore + tmp___13)) {
#line 1965
                  goto while_break___4;
                }
              } else {
#line 1965
                goto while_break___4;
              }
#line 1965
              textb ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1965
            if ((unsigned long )texta < (unsigned long )lima) {
#line 1965
              if (! ((unsigned long )textb < (unsigned long )limb)) {
#line 1965
                goto while_break___2;
              }
            } else {
#line 1965
              goto while_break___2;
            }
            {
#line 1965
            tmp___14 = to_uchar(*texta);
#line 1965
            tmp___15 = to_uchar((char )*(translate + tmp___14));
#line 1965
            tmp___16 = to_uchar(*textb);
#line 1965
            tmp___17 = to_uchar((char )*(translate + tmp___16));
#line 1965
            diff = (int )tmp___15 - (int )tmp___17;
            }
#line 1965
            if (diff) {
#line 1965
              goto not_equal;
            }
#line 1965
            texta ++;
#line 1965
            textb ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1965
          diff = ((unsigned long )texta < (unsigned long )lima) - ((unsigned long )textb < (unsigned long )limb);
#line 1965
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 1968
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1968
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 1968
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1968
              if ((unsigned long )texta < (unsigned long )lima) {
                {
#line 1968
                tmp___18 = to_uchar(*texta);
                }
#line 1968
                if (! *(ignore + tmp___18)) {
#line 1968
                  goto while_break___7;
                }
              } else {
#line 1968
                goto while_break___7;
              }
#line 1968
              texta ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 1968
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1968
              if ((unsigned long )textb < (unsigned long )limb) {
                {
#line 1968
                tmp___19 = to_uchar(*textb);
                }
#line 1968
                if (! *(ignore + tmp___19)) {
#line 1968
                  goto while_break___8;
                }
              } else {
#line 1968
                goto while_break___8;
              }
#line 1968
              textb ++;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 1968
            if ((unsigned long )texta < (unsigned long )lima) {
#line 1968
              if (! ((unsigned long )textb < (unsigned long )limb)) {
#line 1968
                goto while_break___6;
              }
            } else {
#line 1968
              goto while_break___6;
            }
            {
#line 1968
            tmp___20 = to_uchar(*texta);
#line 1968
            tmp___21 = to_uchar(*textb);
#line 1968
            diff = (int )tmp___20 - (int )tmp___21;
            }
#line 1968
            if (diff) {
#line 1968
              goto not_equal;
            }
#line 1968
            texta ++;
#line 1968
            textb ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1968
          diff = ((unsigned long )texta < (unsigned long )lima) - ((unsigned long )textb < (unsigned long )limb);
#line 1968
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    } else
#line 1970
    if (lena == 0UL) {
#line 1971
      diff = - (lenb != 0UL);
    } else
#line 1972
    if (lenb == 0UL) {
#line 1973
      goto greater;
    } else {
#line 1976
      if (translate) {
        {
#line 1978
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1978
          if ((unsigned long )texta < (unsigned long )lima) {
#line 1978
            if (! ((unsigned long )textb < (unsigned long )limb)) {
#line 1978
              goto while_break___9;
            }
          } else {
#line 1978
            goto while_break___9;
          }
          {
#line 1980
          tmp___22 = texta;
#line 1980
          texta ++;
#line 1980
          tmp___23 = to_uchar(*tmp___22);
#line 1980
          tmp___24 = to_uchar((char )*(translate + tmp___23));
#line 1980
          tmp___25 = textb;
#line 1980
          textb ++;
#line 1980
          tmp___26 = to_uchar(*tmp___25);
#line 1980
          tmp___27 = to_uchar((char )*(translate + tmp___26));
#line 1980
          diff = (int )tmp___24 - (int )tmp___27;
          }
#line 1982
          if (diff) {
#line 1983
            goto not_equal;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
#line 1988
        if (lena < lenb) {
#line 1988
          tmp___28 = lena;
        } else {
#line 1988
          tmp___28 = lenb;
        }
        {
#line 1988
        diff = memcmp((void const   *)texta, (void const   *)textb, tmp___28);
        }
#line 1989
        if (diff) {
#line 1990
          goto not_equal;
        }
      }
#line 1992
      if (lena < lenb) {
#line 1992
        diff = -1;
      } else {
#line 1992
        diff = lena != lenb;
      }
    }
#line 1995
    if (diff) {
#line 1996
      goto not_equal;
    }
#line 1998
    key = (struct keyfield  const  *)key->next;
#line 1999
    if (! key) {
#line 2000
      goto while_break;
    }
#line 2003
    if (key->eword != 0xffffffffffffffffUL) {
      {
#line 2004
      lima = limfield(a, key);
#line 2004
      limb = limfield(b, key);
      }
    } else {
#line 2006
      lima = (char *)((a->text + a->length) - 1);
#line 2006
      limb = (char *)((b->text + b->length) - 1);
    }
#line 2008
    if (key->sword != 0xffffffffffffffffUL) {
      {
#line 2009
      texta = begfield(a, key);
#line 2009
      textb = begfield(b, key);
      }
    } else {
#line 2012
      texta = (char *)a->text;
#line 2012
      textb = (char *)b->text;
#line 2013
      if (key->skipsblanks) {
        {
#line 2015
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2015
          if ((unsigned long )texta < (unsigned long )lima) {
            {
#line 2015
            tmp___29 = to_uchar(*texta);
            }
#line 2015
            if (! blanks[tmp___29]) {
#line 2015
              goto while_break___10;
            }
          } else {
#line 2015
            goto while_break___10;
          }
#line 2016
          texta ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 2017
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2017
          if ((unsigned long )textb < (unsigned long )limb) {
            {
#line 2017
            tmp___30 = to_uchar(*textb);
            }
#line 2017
            if (! blanks[tmp___30]) {
#line 2017
              goto while_break___11;
            }
          } else {
#line 2017
            goto while_break___11;
          }
#line 2018
          textb ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2023
  return (0);
  greater: 
#line 2026
  diff = 1;
  not_equal: 
#line 2028
  if (key->reverse) {
#line 2028
    tmp___31 = - diff;
  } else {
#line 2028
    tmp___31 = diff;
  }
#line 2028
  return (tmp___31);
}
}
#line 2034 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int compare(struct line  const  *a , struct line  const  *b ) 
{ 
  int diff ;
  size_t alen ;
  size_t blen ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 2043
  if (keylist) {
    {
#line 2045
    diff = keycompare(a, b);
    }
#line 2046
    if ((diff | (int )unique) | (int )stable) {
#line 2047
      return (diff);
    }
  }
#line 2052
  alen = (size_t )(a->length - 1UL);
#line 2052
  blen = (size_t )(b->length - 1UL);
#line 2054
  if (alen == 0UL) {
#line 2055
    diff = - (blen != 0UL);
  } else
#line 2056
  if (blen == 0UL) {
#line 2057
    diff = 1;
  } else
#line 2058
  if (hard_LC_COLLATE) {
    {
#line 2059
    diff = xmemcoll((char *)a->text, alen, (char *)b->text, blen);
    }
  } else {
#line 2060
    if (alen < blen) {
#line 2060
      tmp = alen;
    } else {
#line 2060
      tmp = blen;
    }
    {
#line 2060
    diff = memcmp((void const   *)a->text, (void const   *)b->text, tmp);
    }
#line 2060
    if (! diff) {
#line 2061
      if (alen < blen) {
#line 2061
        diff = -1;
      } else {
#line 2061
        diff = alen != blen;
      }
    }
  }
#line 2063
  if (reverse) {
#line 2063
    tmp___0 = - diff;
  } else {
#line 2063
    tmp___0 = diff;
  }
#line 2063
  return (tmp___0);
}
}
#line 2071 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static _Bool check(char const   *file_name___3 , char checkonly ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  struct buffer buf___1 ;
  struct line temp ;
  size_t alloc ;
  uintmax_t line_number ;
  struct keyfield  const  *key ;
  _Bool nonunique ;
  _Bool ordered ;
  size_t tmp___0 ;
  struct line  const  *line ;
  struct line *tmp___1 ;
  struct line  const  *linebase ;
  struct line  const  *disorder_line ;
  uintmax_t disorder_line_number ;
  struct line *tmp___2 ;
  char hr_buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  _Bool tmp___9 ;

  {
  {
#line 2074
  tmp = xfopen(file_name___3, "r");
#line 2074
  fp = tmp;
#line 2077
  alloc = (size_t )0;
#line 2078
  line_number = (uintmax_t )0;
#line 2079
  key = (struct keyfield  const  *)keylist;
#line 2080
  nonunique = (_Bool )(! unique);
#line 2081
  ordered = (_Bool)1;
  }
#line 2083
  if (merge_buffer_size > sort_size) {
#line 2083
    tmp___0 = merge_buffer_size;
  } else {
#line 2083
    tmp___0 = sort_size;
  }
  {
#line 2083
  initbuf(& buf___1, sizeof(struct line ), tmp___0);
#line 2085
  temp.text = (char *)((void *)0);
  }
  {
#line 2087
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2087
    tmp___9 = fillbuf___7(& buf___1, fp, file_name___3);
    }
#line 2087
    if (! tmp___9) {
#line 2087
      goto while_break;
    }
    {
#line 2089
    tmp___1 = buffer_linelim((struct buffer  const  *)(& buf___1));
#line 2089
    line = (struct line  const  *)tmp___1;
#line 2090
    linebase = line - buf___1.nlines;
    }
#line 2094
    if (alloc) {
      {
#line 2094
      tmp___6 = compare((struct line  const  *)(& temp), line - 1);
      }
#line 2094
      if ((int )nonunique <= tmp___6) {
        found_disorder: 
#line 2098
        if ((int )checkonly == 99) {
          {
#line 2100
          disorder_line = line - 1;
#line 2101
          tmp___2 = buffer_linelim((struct buffer  const  *)(& buf___1));
#line 2101
          disorder_line_number = (uintmax_t )(tmp___2 - (struct line *)disorder_line) + line_number;
#line 2104
          tmp___3 = umaxtostr(disorder_line_number, hr_buf);
#line 2104
          tmp___4 = gettext("%s: %s:%s: disorder: ");
#line 2104
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                  program_name, file_name___3, tmp___3);
#line 2107
          tmp___5 = gettext("standard error");
#line 2107
          write_bytes((char const   *)disorder_line->text, (size_t )disorder_line->length,
                      stderr, (char const   *)tmp___5);
          }
        }
#line 2111
        ordered = (_Bool)0;
#line 2112
        goto while_break;
      }
    }
    {
#line 2117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2117
      line --;
#line 2117
      if (! ((unsigned long )linebase < (unsigned long )line)) {
#line 2117
        goto while_break___0;
      }
      {
#line 2118
      tmp___7 = compare(line, line - 1);
      }
#line 2118
      if ((int )nonunique <= tmp___7) {
#line 2119
        goto found_disorder;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2121
    line_number += buf___1.nlines;
#line 2124
    if (alloc < (size_t )line->length) {
      {
#line 2126
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2128
        alloc *= 2UL;
#line 2129
        if (! alloc) {
#line 2131
          alloc = (size_t )line->length;
#line 2132
          goto while_break___1;
        }
#line 2126
        if (! (alloc < (size_t )line->length)) {
#line 2126
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2137
      tmp___8 = xrealloc((void *)temp.text, alloc);
#line 2137
      temp.text = (char *)tmp___8;
      }
    }
    {
#line 2139
    memcpy((void */* __restrict  */)temp.text, (void const   */* __restrict  */)line->text,
           (size_t )line->length);
#line 2140
    temp.length = (size_t )line->length;
    }
#line 2141
    if (key) {
#line 2143
      temp.keybeg = temp.text + (line->keybeg - line->text);
#line 2144
      temp.keylim = temp.text + (line->keylim - line->text);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2148
  xfclose(fp, file_name___3);
#line 2149
  free((void *)buf___1.buf);
#line 2150
  free((void *)temp.text);
  }
#line 2151
  return (ordered);
}
}
#line 2162 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void mergefps(struct sortfile *files , size_t ntemps , size_t nfiles , FILE *ofp ,
                     char const   *output_file ) 
{ 
  FILE **fps ;
  void *tmp ;
  struct buffer *buffer ;
  void *tmp___0 ;
  struct line saved ;
  struct line  const  *savedline ;
  size_t savealloc ;
  struct line  const  **cur ;
  void *tmp___1 ;
  struct line  const  **base ;
  void *tmp___2 ;
  size_t *ord ;
  void *tmp___3 ;
  size_t i ;
  size_t j ;
  size_t t ;
  struct keyfield  const  *key ;
  FILE *tmp___4 ;
  FILE *tmp___5 ;
  size_t tmp___6 ;
  struct line  const  *linelim ;
  struct line *tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  struct line  const  *smallest ;
  int tmp___10 ;
  void *tmp___11 ;
  struct line  const  *linelim___0 ;
  struct line *tmp___12 ;
  _Bool tmp___13 ;
  size_t lo ;
  size_t hi ;
  size_t probe ;
  size_t ord0 ;
  size_t count_of_smaller_lines ;
  int cmp ;
  int tmp___14 ;

  {
  {
#line 2166
  tmp = xnmalloc((size_t )nmerge, sizeof(*fps));
#line 2166
  fps = (FILE **)tmp;
#line 2168
  tmp___0 = xnmalloc((size_t )nmerge, sizeof(*buffer));
#line 2168
  buffer = (struct buffer *)tmp___0;
#line 2171
  savedline = (struct line  const  *)((void *)0);
#line 2173
  savealloc = (size_t )0;
#line 2174
  tmp___1 = xnmalloc((size_t )nmerge, sizeof(*cur));
#line 2174
  cur = (struct line  const  **)tmp___1;
#line 2176
  tmp___2 = xnmalloc((size_t )nmerge, sizeof(*base));
#line 2176
  base = (struct line  const  **)tmp___2;
#line 2178
  tmp___3 = xnmalloc((size_t )nmerge, sizeof(*ord));
#line 2178
  ord = (size_t *)tmp___3;
#line 2185
  key = (struct keyfield  const  *)keylist;
#line 2186
  saved.text = (char *)((void *)0);
#line 2189
  i = (size_t )0;
  }
  {
#line 2189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2189
    if (! (i < nfiles)) {
#line 2189
      goto while_break;
    }
#line 2191
    if ((files + i)->pid) {
      {
#line 2191
      tmp___4 = open_temp((files + i)->name, (files + i)->pid);
#line 2191
      *(fps + i) = tmp___4;
      }
    } else {
      {
#line 2191
      tmp___5 = xfopen((files + i)->name, "r");
#line 2191
      *(fps + i) = tmp___5;
      }
    }
#line 2194
    if (merge_buffer_size > sort_size / nfiles) {
#line 2194
      tmp___6 = merge_buffer_size;
    } else {
#line 2194
      tmp___6 = sort_size / nfiles;
    }
    {
#line 2194
    initbuf(buffer + i, sizeof(struct line ), tmp___6);
#line 2196
    tmp___8 = fillbuf___7(buffer + i, *(fps + i), (files + i)->name);
    }
#line 2196
    if (tmp___8) {
      {
#line 2198
      tmp___7 = buffer_linelim((struct buffer  const  *)(buffer + i));
#line 2198
      linelim = (struct line  const  *)tmp___7;
#line 2199
      *(cur + i) = linelim - 1;
#line 2200
      *(base + i) = linelim - (buffer + i)->nlines;
#line 2201
      i ++;
      }
    } else {
      {
#line 2206
      xfclose(*(fps + i), (files + i)->name);
      }
#line 2207
      if (i < ntemps) {
        {
#line 2209
        ntemps --;
#line 2210
        zaptemp((files + i)->name);
        }
      }
      {
#line 2212
      free((void *)(buffer + i)->buf);
#line 2213
      nfiles --;
#line 2214
      j = i;
      }
      {
#line 2214
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2214
        if (! (j < nfiles)) {
#line 2214
          goto while_break___0;
        }
#line 2215
        *(files + j) = *(files + (j + 1UL));
#line 2214
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2219
  if (! ofp) {
    {
#line 2220
    ofp = xfopen(output_file, "w");
    }
  }
#line 2225
  i = (size_t )0;
  {
#line 2225
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2225
    if (! (i < nfiles)) {
#line 2225
      goto while_break___1;
    }
#line 2226
    *(ord + i) = i;
#line 2225
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2227
  i = (size_t )1;
  {
#line 2227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2227
    if (! (i < nfiles)) {
#line 2227
      goto while_break___2;
    }
    {
#line 2228
    tmp___9 = compare(*(cur + *(ord + (i - 1UL))), *(cur + *(ord + i)));
    }
#line 2228
    if (0 < tmp___9) {
#line 2229
      t = *(ord + (i - 1UL));
#line 2229
      *(ord + (i - 1UL)) = *(ord + i);
#line 2229
      *(ord + i) = t;
#line 2229
      i = (size_t )0;
    }
#line 2227
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2232
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2232
    if (! nfiles) {
#line 2232
      goto while_break___3;
    }
#line 2234
    smallest = *(cur + *(ord + 0));
#line 2238
    if (unique) {
#line 2240
      if (savedline) {
        {
#line 2240
        tmp___10 = compare(savedline, smallest);
        }
#line 2240
        if (tmp___10) {
          {
#line 2242
          savedline = (struct line  const  *)((void *)0);
#line 2243
          write_bytes((char const   *)saved.text, saved.length, ofp, output_file);
          }
        }
      }
#line 2245
      if (! savedline) {
#line 2247
        savedline = (struct line  const  *)(& saved);
#line 2248
        if (savealloc < (size_t )smallest->length) {
          {
#line 2250
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2251
            if (! savealloc) {
#line 2253
              savealloc = (size_t )smallest->length;
#line 2254
              goto while_break___4;
            }
#line 2250
            savealloc *= 2UL;
#line 2250
            if (! (savealloc < (size_t )smallest->length)) {
#line 2250
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 2258
          tmp___11 = xrealloc((void *)saved.text, savealloc);
#line 2258
          saved.text = (char *)tmp___11;
          }
        }
        {
#line 2260
        saved.length = (size_t )smallest->length;
#line 2261
        memcpy((void */* __restrict  */)saved.text, (void const   */* __restrict  */)smallest->text,
               saved.length);
        }
#line 2262
        if (key) {
#line 2264
          saved.keybeg = saved.text + (smallest->keybeg - smallest->text);
#line 2266
          saved.keylim = saved.text + (smallest->keylim - smallest->text);
        }
      }
    } else {
      {
#line 2272
      write_bytes((char const   *)smallest->text, (size_t )smallest->length, ofp,
                  output_file);
      }
    }
#line 2275
    if ((unsigned long )*(base + *(ord + 0)) < (unsigned long )smallest) {
#line 2276
      *(cur + *(ord + 0)) = smallest - 1;
    } else {
      {
#line 2279
      tmp___13 = fillbuf___7(buffer + *(ord + 0), *(fps + *(ord + 0)), (files + *(ord + 0))->name);
      }
#line 2279
      if (tmp___13) {
        {
#line 2281
        tmp___12 = buffer_linelim((struct buffer  const  *)(buffer + *(ord + 0)));
#line 2281
        linelim___0 = (struct line  const  *)tmp___12;
#line 2282
        *(cur + *(ord + 0)) = linelim___0 - 1;
#line 2283
        *(base + *(ord + 0)) = linelim___0 - (buffer + *(ord + 0))->nlines;
        }
      } else {
#line 2288
        i = (size_t )1;
        {
#line 2288
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2288
          if (! (i < nfiles)) {
#line 2288
            goto while_break___5;
          }
#line 2289
          if (*(ord + i) > *(ord + 0)) {
#line 2290
            (*(ord + i)) --;
          }
#line 2288
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 2291
        nfiles --;
#line 2292
        xfclose(*(fps + *(ord + 0)), (files + *(ord + 0))->name);
        }
#line 2293
        if (*(ord + 0) < ntemps) {
          {
#line 2295
          ntemps --;
#line 2296
          zaptemp((files + *(ord + 0))->name);
          }
        }
        {
#line 2298
        free((void *)(buffer + *(ord + 0))->buf);
#line 2299
        i = *(ord + 0);
        }
        {
#line 2299
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2299
          if (! (i < nfiles)) {
#line 2299
            goto while_break___6;
          }
#line 2301
          *(fps + i) = *(fps + (i + 1UL));
#line 2302
          *(files + i) = *(files + (i + 1UL));
#line 2303
          *(buffer + i) = *(buffer + (i + 1UL));
#line 2304
          *(cur + i) = *(cur + (i + 1UL));
#line 2305
          *(base + i) = *(base + (i + 1UL));
#line 2299
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2307
        i = (size_t )0;
        {
#line 2307
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2307
          if (! (i < nfiles)) {
#line 2307
            goto while_break___7;
          }
#line 2308
          *(ord + i) = *(ord + (i + 1UL));
#line 2307
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 2309
        goto while_continue___3;
      }
    }
#line 2318
    lo = (size_t )1;
#line 2319
    hi = nfiles;
#line 2320
    probe = lo;
#line 2321
    ord0 = *(ord + 0);
    {
#line 2324
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2324
      if (! (lo < hi)) {
#line 2324
        goto while_break___8;
      }
      {
#line 2326
      tmp___14 = compare(*(cur + ord0), *(cur + *(ord + probe)));
#line 2326
      cmp = tmp___14;
      }
#line 2327
      if (cmp < 0) {
#line 2328
        hi = probe;
      } else
#line 2327
      if (cmp == 0) {
#line 2327
        if (ord0 < *(ord + probe)) {
#line 2328
          hi = probe;
        } else {
#line 2330
          lo = probe + 1UL;
        }
      } else {
#line 2330
        lo = probe + 1UL;
      }
#line 2331
      probe = (lo + hi) / 2UL;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2334
    count_of_smaller_lines = lo - 1UL;
#line 2335
    j = (size_t )0;
    {
#line 2335
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2335
      if (! (j < count_of_smaller_lines)) {
#line 2335
        goto while_break___9;
      }
#line 2336
      *(ord + j) = *(ord + (j + 1UL));
#line 2335
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2337
    *(ord + count_of_smaller_lines) = ord0;
#line 2341
    if (2UL < nprocs) {
      {
#line 2342
      reap_some();
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2345
  if (unique) {
#line 2345
    if (savedline) {
      {
#line 2347
      write_bytes((char const   *)saved.text, saved.length, ofp, output_file);
#line 2348
      free((void *)saved.text);
      }
    }
  }
  {
#line 2351
  xfclose(ofp, output_file);
#line 2352
  free((void *)fps);
#line 2353
  free((void *)buffer);
#line 2354
  free((void *)ord);
#line 2355
  free((void *)base);
#line 2356
  free((void *)cur);
  }
#line 2357
  return;
}
}
#line 2364 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
__inline static void mergelines(struct line *t , struct line  const  *lo , size_t nlo ,
                                struct line  const  *hi , size_t nhi ) 
{ 
  int tmp ;

  {
  {
#line 2369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2370
    tmp = compare(lo - 1, hi - 1);
    }
#line 2370
    if (tmp <= 0) {
#line 2372
      t --;
#line 2372
      lo --;
#line 2372
      *t = (struct line )*lo;
#line 2373
      nlo --;
#line 2373
      if (! nlo) {
#line 2378
        return;
      }
    } else {
#line 2383
      t --;
#line 2383
      hi --;
#line 2383
      *t = (struct line )*hi;
#line 2384
      nhi --;
#line 2384
      if (! nhi) {
        {
#line 2386
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2387
          t --;
#line 2387
          lo --;
#line 2387
          *t = (struct line )*lo;
#line 2386
          nlo --;
#line 2386
          if (! nlo) {
#line 2386
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2390
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2407 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void sortlines(struct line *lines , size_t nlines , struct line *temp ) 
{ 
  struct line tmp ;
  int tmp___0 ;
  size_t nlo ;
  size_t nhi ;
  struct line *lo ;
  struct line *hi ;
  struct line *sorted_lo ;

  {
#line 2410
  if (nlines == 2UL) {
    {
#line 2412
    tmp___0 = compare((struct line  const  *)(lines + -1), (struct line  const  *)(lines + -2));
    }
#line 2412
    if (0 < tmp___0) {
#line 2414
      tmp = *(lines + -1);
#line 2415
      *(lines + -1) = *(lines + -2);
#line 2416
      *(lines + -2) = tmp;
    }
  } else {
    {
#line 2421
    nlo = nlines / 2UL;
#line 2422
    nhi = nlines - nlo;
#line 2423
    lo = lines;
#line 2424
    hi = lines - nlo;
#line 2425
    sorted_lo = temp;
#line 2427
    sortlines(hi, nhi, temp);
    }
#line 2428
    if (1UL < nlo) {
      {
#line 2429
      sortlines_temp(lo, nlo, sorted_lo);
      }
    } else {
#line 2431
      *(sorted_lo + -1) = *(lo + -1);
    }
    {
#line 2433
    mergelines(lines, (struct line  const  *)sorted_lo, nlo, (struct line  const  *)hi,
               nhi);
    }
  }
#line 2435
  return;
}
}
#line 2440 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void sortlines_temp(struct line *lines , size_t nlines , struct line *temp ) 
{ 
  int swap ;
  int tmp ;
  size_t nlo ;
  size_t nhi ;
  struct line *lo ;
  struct line *hi ;
  struct line *sorted_hi ;

  {
#line 2443
  if (nlines == 2UL) {
    {
#line 2448
    tmp = compare((struct line  const  *)(lines + -1), (struct line  const  *)(lines + -2));
#line 2448
    swap = 0 < tmp;
#line 2449
    *(temp + -1) = *(lines + (-1 - swap));
#line 2450
    *(temp + -2) = *(lines + (-2 + swap));
    }
  } else {
    {
#line 2454
    nlo = nlines / 2UL;
#line 2455
    nhi = nlines - nlo;
#line 2456
    lo = lines;
#line 2457
    hi = lines - nlo;
#line 2458
    sorted_hi = temp - nlo;
#line 2460
    sortlines_temp(hi, nhi, sorted_hi);
    }
#line 2461
    if (1UL < nlo) {
      {
#line 2462
      sortlines(lo, nlo, temp);
      }
    }
    {
#line 2464
    mergelines(temp, (struct line  const  *)lo, nlo, (struct line  const  *)sorted_hi,
               nhi);
    }
  }
#line 2466
  return;
}
}
#line 2485 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static size_t avoid_trashing_input(struct sortfile *files , size_t ntemps , size_t nfiles ,
                                   char const   *outfile ) 
{ 
  size_t i ;
  _Bool got_outstat ;
  struct stat outstat ;
  _Bool is_stdin ;
  int tmp ;
  _Bool same ;
  struct stat instat ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  FILE *tftp ;
  pid_t pid ;
  char *temp ;
  char *tmp___8 ;

  {
#line 2490
  got_outstat = (_Bool)0;
#line 2493
  i = ntemps;
  {
#line 2493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2493
    if (! (i < nfiles)) {
#line 2493
      goto while_break;
    }
    {
#line 2495
    tmp = strcmp((files + i)->name, "-");
#line 2495
    is_stdin = (_Bool )(tmp == 0);
    }
#line 2499
    if (outfile) {
      {
#line 2499
      tmp___7 = strcmp(outfile, (files + i)->name);
      }
#line 2499
      if (tmp___7 == 0) {
#line 2499
        if (! is_stdin) {
#line 2500
          same = (_Bool)1;
        } else {
#line 2499
          goto _L___0;
        }
      } else {
#line 2499
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2503
      if (! got_outstat) {
#line 2505
        if (outfile) {
          {
#line 2505
          tmp___0 = stat((char const   */* __restrict  */)outfile, (struct stat */* __restrict  */)(& outstat));
#line 2505
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 2505
          tmp___1 = fstat(1, & outstat);
#line 2505
          tmp___2 = tmp___1;
          }
        }
#line 2505
        if (tmp___2 != 0) {
#line 2509
          goto while_break;
        }
#line 2510
        got_outstat = (_Bool)1;
      }
#line 2513
      if (is_stdin) {
        {
#line 2513
        tmp___3 = fstat(0, & instat);
#line 2513
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 2513
        tmp___4 = stat((char const   */* __restrict  */)(files + i)->name, (struct stat */* __restrict  */)(& instat));
#line 2513
        tmp___5 = tmp___4;
        }
      }
#line 2513
      if (tmp___5 == 0) {
#line 2513
        if (instat.st_ino == outstat.st_ino) {
#line 2513
          if (instat.st_dev == outstat.st_dev) {
#line 2513
            tmp___6 = 1;
          } else {
#line 2513
            tmp___6 = 0;
          }
        } else {
#line 2513
          tmp___6 = 0;
        }
      } else {
#line 2513
        tmp___6 = 0;
      }
#line 2513
      same = (_Bool )tmp___6;
    }
#line 2520
    if (same) {
      {
#line 2524
      tmp___8 = create_temp(& tftp, & pid);
#line 2524
      temp = tmp___8;
#line 2525
      mergefps(files + i, (size_t )0, nfiles - i, tftp, (char const   *)temp);
#line 2526
      (files + i)->name = (char const   *)temp;
#line 2527
      (files + i)->pid = pid;
      }
#line 2528
      return (i + 1UL);
    }
#line 2493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2532
  return (nfiles);
}
}
#line 2540 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void merge(struct sortfile *files , size_t ntemps , size_t nfiles , char const   *output_file ) 
{ 
  size_t in ;
  size_t out ;
  size_t remainder ;
  size_t cheap_slots ;
  FILE *tfp ;
  pid_t pid ;
  char *temp ;
  char *tmp ;
  size_t nt ;
  size_t tmp___0 ;
  size_t nshortmerge ;
  FILE *tfp___0 ;
  pid_t pid___0 ;
  char *temp___0 ;
  char *tmp___1 ;
  size_t nt___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 2544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2544
    if (! ((size_t )nmerge < nfiles)) {
#line 2544
      goto while_break;
    }
#line 2560
    in = (size_t )0;
#line 2560
    out = in;
    {
#line 2560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2560
      if (! (out < nfiles / (size_t )nmerge)) {
#line 2560
        goto while_break___0;
      }
      {
#line 2564
      tmp = create_temp(& tfp, & pid);
#line 2564
      temp = tmp;
      }
#line 2565
      if (ntemps < (size_t )nmerge) {
#line 2565
        tmp___0 = ntemps;
      } else {
#line 2565
        tmp___0 = (size_t )nmerge;
      }
      {
#line 2565
      nt = tmp___0;
#line 2566
      ntemps -= nt;
#line 2567
      mergefps(files + in, nt, (size_t )nmerge, tfp, (char const   *)temp);
#line 2568
      (files + out)->name = (char const   *)temp;
#line 2569
      (files + out)->pid = pid;
#line 2560
      out ++;
#line 2560
      in += (size_t )nmerge;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2572
    remainder = nfiles - in;
#line 2573
    cheap_slots = (unsigned long )nmerge - out % (unsigned long )nmerge;
#line 2575
    if (cheap_slots < remainder) {
      {
#line 2580
      nshortmerge = (remainder - cheap_slots) + 1UL;
#line 2583
      tmp___1 = create_temp(& tfp___0, & pid___0);
#line 2583
      temp___0 = tmp___1;
      }
#line 2584
      if (ntemps < nshortmerge) {
#line 2584
        tmp___2 = ntemps;
      } else {
#line 2584
        tmp___2 = nshortmerge;
      }
      {
#line 2584
      nt___0 = tmp___2;
#line 2585
      ntemps -= nt___0;
#line 2586
      mergefps(files + in, nt___0, nshortmerge, tfp___0, (char const   *)temp___0);
#line 2587
      (files + out)->name = (char const   *)temp___0;
#line 2588
      tmp___3 = out;
#line 2588
      out ++;
#line 2588
      (files + tmp___3)->pid = pid___0;
#line 2589
      in += nshortmerge;
      }
    }
    {
#line 2594
    memmove((void *)(files + out), (void const   *)(files + in), (nfiles - in) * sizeof(*files));
#line 2595
    ntemps += out;
#line 2596
    nfiles -= in - out;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2599
  nfiles = avoid_trashing_input(files, ntemps, nfiles, output_file);
#line 2600
  mergefps(files, ntemps, nfiles, (FILE *)((void *)0), output_file);
  }
#line 2601
  return;
}
}
#line 2605 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void sort(char * const  *files , size_t nfiles , char const   *output_file ) 
{ 
  struct buffer buf___1 ;
  size_t ntemps ;
  _Bool output_file_created ;
  char const   *temp_output ;
  char const   *file ;
  FILE *fp ;
  FILE *tmp ;
  FILE *tfp ;
  size_t bytes_per_line ;
  size_t tmp___0 ;
  struct line *line ;
  struct line *linebase ;
  char *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  size_t i ;
  struct tempnode *node ;
  struct sortfile *tempfiles ;
  void *tmp___4 ;

  {
#line 2609
  ntemps = (size_t )0;
#line 2610
  output_file_created = (_Bool)0;
#line 2612
  buf___1.alloc = (size_t )0;
  {
#line 2614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2614
    if (! nfiles) {
#line 2614
      goto while_break;
    }
    {
#line 2617
    file = (char const   *)*files;
#line 2618
    tmp = xfopen(file, "r");
#line 2618
    fp = tmp;
#line 2620
    bytes_per_line = 2UL * sizeof(struct line ) - sizeof(struct line ) / 2UL;
    }
#line 2623
    if (! buf___1.alloc) {
      {
#line 2624
      tmp___0 = sort_buffer_size((FILE * const  *)(& fp), (size_t )1, files, nfiles,
                                 bytes_per_line);
#line 2624
      initbuf(& buf___1, bytes_per_line, tmp___0);
      }
    }
#line 2626
    buf___1.eof = (_Bool)0;
#line 2627
    files ++;
#line 2628
    nfiles --;
    {
#line 2630
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2630
      tmp___3 = fillbuf___7(& buf___1, fp, file);
      }
#line 2630
      if (! tmp___3) {
#line 2630
        goto while_break___0;
      }
#line 2635
      if (buf___1.eof) {
#line 2635
        if (nfiles) {
#line 2635
          if (bytes_per_line + 1UL < (buf___1.alloc - buf___1.used) - bytes_per_line * buf___1.nlines) {
#line 2642
            buf___1.left = buf___1.used;
#line 2643
            goto while_break___0;
          }
        }
      }
      {
#line 2646
      line = buffer_linelim((struct buffer  const  *)(& buf___1));
#line 2647
      linebase = line - buf___1.nlines;
      }
#line 2648
      if (1UL < buf___1.nlines) {
        {
#line 2649
        sortlines(line, buf___1.nlines, linebase);
        }
      }
#line 2650
      if (buf___1.eof) {
#line 2650
        if (! nfiles) {
#line 2650
          if (! ntemps) {
#line 2650
            if (! buf___1.left) {
              {
#line 2652
              xfclose(fp, file);
#line 2653
              tfp = xfopen(output_file, "w");
#line 2654
              temp_output = output_file;
#line 2655
              output_file_created = (_Bool)1;
              }
            } else {
              {
#line 2659
              ntemps ++;
#line 2660
              tmp___1 = create_temp(& tfp, (pid_t *)((void *)0));
#line 2660
              temp_output = (char const   *)tmp___1;
              }
            }
          } else {
            {
#line 2659
            ntemps ++;
#line 2660
            tmp___1 = create_temp(& tfp, (pid_t *)((void *)0));
#line 2660
            temp_output = (char const   *)tmp___1;
            }
          }
        } else {
          {
#line 2659
          ntemps ++;
#line 2660
          tmp___1 = create_temp(& tfp, (pid_t *)((void *)0));
#line 2660
          temp_output = (char const   *)tmp___1;
          }
        }
      } else {
        {
#line 2659
        ntemps ++;
#line 2660
        tmp___1 = create_temp(& tfp, (pid_t *)((void *)0));
#line 2660
        temp_output = (char const   *)tmp___1;
        }
      }
      {
#line 2663
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2665
        line --;
#line 2666
        write_bytes((char const   *)line->text, line->length, tfp, temp_output);
        }
#line 2667
        if (unique) {
          {
#line 2668
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2668
            if ((unsigned long )linebase < (unsigned long )line) {
              {
#line 2668
              tmp___2 = compare((struct line  const  *)line, (struct line  const  *)(line - 1));
              }
#line 2668
              if (! (tmp___2 == 0)) {
#line 2668
                goto while_break___2;
              }
            } else {
#line 2668
              goto while_break___2;
            }
#line 2669
            line --;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 2663
        if (! ((unsigned long )linebase < (unsigned long )line)) {
#line 2663
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2673
      xfclose(tfp, temp_output);
      }
#line 2676
      if (2UL < nprocs) {
        {
#line 2677
        reap_some();
        }
      }
#line 2679
      if (output_file_created) {
#line 2680
        goto finish;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2682
    xfclose(fp, file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  finish: 
  {
#line 2686
  free((void *)buf___1.buf);
  }
#line 2688
  if (! output_file_created) {
    {
#line 2691
    node = (struct tempnode *)temphead;
#line 2692
    tmp___4 = xnmalloc(ntemps, sizeof(*tempfiles));
#line 2692
    tempfiles = (struct sortfile *)tmp___4;
#line 2693
    i = (size_t )0;
    }
    {
#line 2693
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2693
      if (! node) {
#line 2693
        goto while_break___3;
      }
#line 2695
      (tempfiles + i)->name = (char const   *)(node->name);
#line 2696
      (tempfiles + i)->pid = node->pid;
#line 2697
      node = (struct tempnode *)node->next;
#line 2693
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2699
    merge(tempfiles, ntemps, ntemps, output_file);
#line 2700
    free((void *)tempfiles);
    }
  }
#line 2702
  return;
}
}
#line 2706 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void insertkey(struct keyfield *key_arg ) 
{ 
  struct keyfield **p ;
  struct keyfield *key ;
  void *tmp ;

  {
  {
#line 2710
  tmp = xmemdup((void const   *)key_arg, sizeof(*key));
#line 2710
  key = (struct keyfield *)tmp;
#line 2712
  p = & keylist;
  }
  {
#line 2712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2712
    if (! *p) {
#line 2712
      goto while_break;
    }
#line 2713
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 2712
    p = & (*p)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2714
  *p = key;
#line 2715
  key->next = (struct keyfield *)((void *)0);
#line 2716
  return;
}
}
#line 2720
static  __attribute__((__noreturn__)) void badfieldspec(char const   *spec , char const   *msgid ) ;
#line 2722
static  __attribute__((__noreturn__)) void badfieldspec(char const   *spec , char const   *msgid ) ;
#line 2722 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void badfieldspec(char const   *spec , char const   *msgid ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 2725
  tmp = quote(spec);
#line 2725
  tmp___0 = gettext(msgid);
#line 2725
  tmp___1 = gettext("%s: invalid field specification %s");
#line 2725
  error(2, 0, (char const   *)tmp___1, tmp___0, tmp);
#line 2727
  abort();
  }
}
}
#line 2732
static  __attribute__((__noreturn__)) void incompatible_options(char const   *opts___0 ) ;
#line 2733
static  __attribute__((__noreturn__)) void incompatible_options(char const   *opts___0 ) ;
#line 2733 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void incompatible_options(char const   *opts___0 ) 
{ 
  char *tmp ;

  {
  {
#line 2736
  tmp = gettext("options `-%s\' are incompatible");
#line 2736
  error(2, 0, (char const   *)tmp, opts___0);
#line 2737
  abort();
  }
}
}
#line 2742 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void check_ordering_compatibility(void) 
{ 
  struct keyfield  const  *key ;
  char opts___0[sizeof(short_options)] ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 2747
  key = (struct keyfield  const  *)keylist;
  {
#line 2747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2747
    if (! key) {
#line 2747
      goto while_break;
    }
#line 2748
    if (1 < (int )((((((int const   )key->random + (int const   )key->numeric) + (int const   )key->general_numeric) + (int const   )key->month) + (int const   )key->version) + (int const   )(! (! key->ignore)))) {
#line 2748
      goto _L;
    } else
#line 2748
    if (key->random) {
#line 2748
      if (key->translate) {
        _L: /* CIL Label */ 
#line 2754
        p = opts___0;
#line 2755
        if ((unsigned long )key->ignore == (unsigned long )(nondictionary)) {
#line 2756
          tmp = p;
#line 2756
          p ++;
#line 2756
          *tmp = (char )'d';
        }
#line 2757
        if (key->translate) {
#line 2758
          tmp___0 = p;
#line 2758
          p ++;
#line 2758
          *tmp___0 = (char )'f';
        }
#line 2759
        if (key->general_numeric) {
#line 2760
          tmp___1 = p;
#line 2760
          p ++;
#line 2760
          *tmp___1 = (char )'g';
        }
#line 2761
        if ((unsigned long )key->ignore == (unsigned long )(nonprinting)) {
#line 2762
          tmp___2 = p;
#line 2762
          p ++;
#line 2762
          *tmp___2 = (char )'i';
        }
#line 2763
        if (key->month) {
#line 2764
          tmp___3 = p;
#line 2764
          p ++;
#line 2764
          *tmp___3 = (char )'M';
        }
#line 2765
        if (key->numeric) {
#line 2766
          tmp___4 = p;
#line 2766
          p ++;
#line 2766
          *tmp___4 = (char )'n';
        }
#line 2767
        if (key->version) {
#line 2768
          tmp___5 = p;
#line 2768
          p ++;
#line 2768
          *tmp___5 = (char )'V';
        }
#line 2769
        if (key->random) {
#line 2770
          tmp___6 = p;
#line 2770
          p ++;
#line 2770
          *tmp___6 = (char )'R';
        }
        {
#line 2771
        *p = (char )'\000';
#line 2772
        incompatible_options((char const   *)(opts___0));
        }
      }
    }
#line 2747
    key = (struct keyfield  const  *)key->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2774
  return;
}
}
#line 2782 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char const   *parse_field_count(char const   *string , size_t *val , char const   *msgid ) 
{ 
  char *suffix ;
  uintmax_t n ;
  strtol_error tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2788
  tmp = xstrtoumax(string, & suffix, 10, & n, "");
  }
  {
#line 2791
  if ((unsigned int )tmp == 2U) {
#line 2791
    goto case_2;
  }
#line 2791
  if ((unsigned int )tmp == 0U) {
#line 2791
    goto case_2;
  }
#line 2797
  if ((unsigned int )tmp == 3U) {
#line 2797
    goto case_3;
  }
#line 2797
  if ((unsigned int )tmp == 1U) {
#line 2797
    goto case_3;
  }
#line 2801
  if ((unsigned int )tmp == 4U) {
#line 2801
    goto case_4;
  }
#line 2788
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2792
  *val = n;
#line 2793
  if (*val == n) {
#line 2794
    goto switch_break;
  }
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 2798
  *val = 0xffffffffffffffffUL;
#line 2799
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2802
  if (msgid) {
    {
#line 2803
    tmp___0 = quote(string);
#line 2803
    tmp___1 = gettext(msgid);
#line 2803
    tmp___2 = gettext("%s: invalid count at start of %s");
#line 2803
    error(2, 0, (char const   *)tmp___2, tmp___1, tmp___0);
    }
  }
#line 2805
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 2808
  return ((char const   *)suffix);
}
}
#line 2813 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static void sighandler(int sig___0 ) 
{ 


  {
  {
#line 2819
  cleanup();
#line 2821
  signal(sig___0, (void (*)(int  ))0);
#line 2822
  raise(sig___0);
  }
#line 2823
  return;
}
}
#line 2830 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char *set_ordering(char const   *s , struct keyfield *key , enum blanktype blanktype ) 
{ 


  {
  {
#line 2833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2833
    if (! *s) {
#line 2833
      goto while_break;
    }
    {
#line 2837
    if ((int const   )*s == 98) {
#line 2837
      goto case_98;
    }
#line 2843
    if ((int const   )*s == 100) {
#line 2843
      goto case_100;
    }
#line 2846
    if ((int const   )*s == 102) {
#line 2846
      goto case_102;
    }
#line 2849
    if ((int const   )*s == 103) {
#line 2849
      goto case_103;
    }
#line 2852
    if ((int const   )*s == 105) {
#line 2852
      goto case_105;
    }
#line 2858
    if ((int const   )*s == 77) {
#line 2858
      goto case_77;
    }
#line 2861
    if ((int const   )*s == 110) {
#line 2861
      goto case_110;
    }
#line 2864
    if ((int const   )*s == 82) {
#line 2864
      goto case_82;
    }
#line 2867
    if ((int const   )*s == 114) {
#line 2867
      goto case_114;
    }
#line 2870
    if ((int const   )*s == 86) {
#line 2870
      goto case_86;
    }
#line 2873
    goto switch_default;
    case_98: /* CIL Label */ 
#line 2838
    if ((unsigned int )blanktype == 0U) {
#line 2839
      key->skipsblanks = (_Bool)1;
    } else
#line 2838
    if ((unsigned int )blanktype == 2U) {
#line 2839
      key->skipsblanks = (_Bool)1;
    }
#line 2840
    if ((unsigned int )blanktype == 1U) {
#line 2841
      key->skipeblanks = (_Bool)1;
    } else
#line 2840
    if ((unsigned int )blanktype == 2U) {
#line 2841
      key->skipeblanks = (_Bool)1;
    }
#line 2842
    goto switch_break;
    case_100: /* CIL Label */ 
#line 2844
    key->ignore = (_Bool const   *)(nondictionary);
#line 2845
    goto switch_break;
    case_102: /* CIL Label */ 
#line 2847
    key->translate = (char const   *)(fold_toupper);
#line 2848
    goto switch_break;
    case_103: /* CIL Label */ 
#line 2850
    key->general_numeric = (_Bool)1;
#line 2851
    goto switch_break;
    case_105: /* CIL Label */ 
#line 2855
    if (! key->ignore) {
#line 2856
      key->ignore = (_Bool const   *)(nonprinting);
    }
#line 2857
    goto switch_break;
    case_77: /* CIL Label */ 
#line 2859
    key->month = (_Bool)1;
#line 2860
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2862
    key->numeric = (_Bool)1;
#line 2863
    goto switch_break;
    case_82: /* CIL Label */ 
#line 2865
    key->random = (_Bool)1;
#line 2866
    goto switch_break;
    case_114: /* CIL Label */ 
#line 2868
    key->reverse = (_Bool)1;
#line 2869
    goto switch_break;
    case_86: /* CIL Label */ 
#line 2871
    key->version = (_Bool)1;
#line 2872
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2874
    return ((char *)s);
    switch_break: /* CIL Label */ ;
    }
#line 2876
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2878
  return ((char *)s);
}
}
#line 2881 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static struct keyfield *key_init(struct keyfield *key ) 
{ 


  {
  {
#line 2884
  memset((void *)key, 0, sizeof(*key));
#line 2885
  key->eword = 0xffffffffffffffffUL;
  }
#line 2886
  return (key);
}
}
#line 2944
int main(int argc , char **argv ) ;
#line 2944 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static int const   sig[11]  = 
#line 2944
  {      (int const   )14,      (int const   )1,      (int const   )2,      (int const   )13, 
        (int const   )3,      (int const   )15,      (int const   )29,      (int const   )27, 
        (int const   )26,      (int const   )24,      (int const   )25};
#line 3384 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char *minus  =    (char *)"-";
#line 3403 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
static char opts[3]  = {      (char)0,      (char )'o',      (char)0};
#line 2889 "/home/khheo/project/benchmark/coreutils-7.1/src/sort.c"
int main(int argc , char **argv ) 
{ 
  struct keyfield *key ;
  struct keyfield key_buf ;
  struct keyfield gkey ;
  char const   *s ;
  int c ;
  char checkonly ;
  _Bool mergeonly ;
  char *random_source ;
  _Bool need_random ;
  size_t nfiles ;
  _Bool posixly_correct ;
  char *tmp ;
  _Bool obsolete_usage ;
  int tmp___0 ;
  char **files ;
  char *files_from ;
  struct Tokens tok ;
  char const   *outfile ;
  struct lconv  const  *locale ;
  struct lconv *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  size_t i ;
  struct sigaction act ;
  int tmp___4 ;
  void *tmp___5 ;
  int oi ;
  size_t tmp___6 ;
  int tmp___7 ;
  _Bool minus_pos_usage ;
  int tmp___8 ;
  char const   *optarg1 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  ptrdiff_t tmp___13 ;
  char str[2] ;
  ptrdiff_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char newtab ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char const   *p ;
  FILE *stream ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  _Bool tmp___40 ;
  int tmp___41 ;
  size_t i___0 ;
  char const   *tmp___42 ;
  char *tmp___43 ;
  unsigned long file_number ;
  char *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char const   *tmp_dir ;
  char *tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char *tmp___53 ;
  int tmp___55 ;
  _Bool tmp___56 ;
  struct sortfile *sortfiles ;
  void *tmp___57 ;
  size_t i___1 ;
  char *tmp___58 ;
  int tmp___59 ;

  {
  {
#line 2896
  c = 0;
#line 2897
  checkonly = (char)0;
#line 2898
  mergeonly = (_Bool)0;
#line 2899
  random_source = (char *)((void *)0);
#line 2900
  need_random = (_Bool)0;
#line 2901
  nfiles = (size_t )0;
#line 2902
  tmp = getenv("POSIXLY_CORRECT");
#line 2902
  posixly_correct = (_Bool )((unsigned long )tmp != (unsigned long )((void *)0));
#line 2903
  tmp___0 = posix2_version();
#line 2903
  obsolete_usage = (_Bool )(tmp___0 < 200112);
#line 2905
  files_from = (char *)((void *)0);
#line 2907
  outfile = (char const   *)((void *)0);
#line 2910
  set_program_name((char const   *)*(argv + 0));
#line 2911
  setlocale(6, "");
#line 2912
  bindtextdomain("coreutils", "/usr/local/share/locale");
#line 2913
  textdomain("coreutils");
#line 2915
  initialize_exit_failure(2);
#line 2917
  hard_LC_COLLATE = hard_locale(3);
#line 2919
  hard_LC_TIME = hard_locale(2);
#line 2924
  tmp___1 = localeconv();
#line 2924
  locale = (struct lconv  const  *)tmp___1;
#line 2929
  tmp___2 = to_uchar(*(locale->decimal_point + 0));
#line 2929
  decimal_point = (int )tmp___2;
  }
#line 2930
  if (! decimal_point) {
#line 2931
    decimal_point = '.';
  } else
#line 2930
  if (*(locale->decimal_point + 1)) {
#line 2931
    decimal_point = '.';
  }
  {
#line 2934
  tmp___3 = to_uchar(*(locale->thousands_sep));
#line 2934
  thousands_sep = (int )tmp___3;
  }
#line 2935
  if (! thousands_sep) {
#line 2936
    thousands_sep = -1;
  } else
#line 2935
  if (*(locale->thousands_sep + 1)) {
#line 2936
    thousands_sep = -1;
  }
  {
#line 2939
  have_read_stdin = (_Bool)0;
#line 2940
  inittables();
#line 2969
  sigemptyset(& caught_signals);
#line 2970
  i = (size_t )0;
  }
  {
#line 2970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2970
    if (! (i < 11UL)) {
#line 2970
      goto while_break;
    }
    {
#line 2972
    sigaction((int )sig[i], (struct sigaction  const  */* __restrict  */)((void *)0),
              (struct sigaction */* __restrict  */)(& act));
    }
#line 2973
    if ((unsigned long )act.__sigaction_handler.sa_handler != (unsigned long )((void (*)(int  ))1)) {
      {
#line 2974
      sigaddset(& caught_signals, (int )sig[i]);
      }
    }
#line 2970
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2977
  act.__sigaction_handler.sa_handler = & sighandler;
#line 2978
  act.sa_mask = caught_signals;
#line 2979
  act.sa_flags = 0;
#line 2981
  i = (size_t )0;
  {
#line 2981
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2981
    if (! (i < 11UL)) {
#line 2981
      goto while_break___0;
    }
    {
#line 2982
    tmp___4 = sigismember((sigset_t const   *)(& caught_signals), (int )sig[i]);
    }
#line 2982
    if (tmp___4) {
      {
#line 2983
      sigaction((int )sig[i], (struct sigaction  const  */* __restrict  */)(& act),
                (struct sigaction */* __restrict  */)((void *)0));
      }
    }
#line 2981
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2995
  atexit(& exit_cleanup);
#line 2997
  gkey.eword = 0xffffffffffffffffUL;
#line 2997
  gkey.sword = gkey.eword;
#line 2998
  gkey.ignore = (_Bool const   *)((void *)0);
#line 2999
  gkey.translate = (char const   *)((void *)0);
#line 3000
  gkey.version = (_Bool)0;
#line 3000
  gkey.random = gkey.version;
#line 3000
  gkey.general_numeric = gkey.random;
#line 3000
  gkey.numeric = gkey.general_numeric;
#line 3001
  gkey.reverse = (_Bool)0;
#line 3001
  gkey.month = gkey.reverse;
#line 3002
  gkey.skipeblanks = (_Bool)0;
#line 3002
  gkey.skipsblanks = gkey.skipeblanks;
#line 3004
  tmp___5 = xnmalloc((size_t )argc, sizeof(*files));
#line 3004
  files = (char **)tmp___5;
  }
  {
#line 3006
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3012
    oi = -1;
#line 3014
    if (c == -1) {
#line 3014
      goto _L;
    } else
#line 3014
    if (posixly_correct) {
#line 3014
      if (nfiles != 0UL) {
#line 3014
        if (obsolete_usage) {
#line 3014
          if (! checkonly) {
#line 3014
            if (optind != argc) {
#line 3014
              if ((int )*(*(argv + optind) + 0) == 45) {
#line 3014
                if ((int )*(*(argv + optind) + 1) == 111) {
#line 3014
                  if (*(*(argv + optind) + 2)) {
#line 3014
                    goto _L___1;
                  } else
#line 3014
                  if (optind + 1 != argc) {
#line 3014
                    goto _L___1;
                  } else {
#line 3014
                    goto _L;
                  }
                } else {
#line 3014
                  goto _L;
                }
              } else {
#line 3014
                goto _L;
              }
            } else {
#line 3014
              goto _L;
            }
          } else {
#line 3014
            goto _L;
          }
        } else {
#line 3014
          goto _L;
        }
      } else {
#line 3014
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 3014
      c = getopt_long(argc, (char * const  *)argv, short_options, long_options___1,
                      & oi);
      }
#line 3014
      if (c == -1) {
        _L: /* CIL Label */ 
#line 3025
        if (argc <= optind) {
#line 3026
          goto while_break___1;
        }
#line 3027
        tmp___6 = nfiles;
#line 3027
        nfiles ++;
#line 3027
        tmp___7 = optind;
#line 3027
        optind ++;
#line 3027
        *(files + tmp___6) = *(argv + tmp___7);
      } else {
        {
#line 3031
        if (c == 1) {
#line 3031
          goto case_1;
        }
#line 3072
        if (c == 133) {
#line 3072
          goto case_133;
        }
#line 3084
        if (c == 86) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 82) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 114) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 110) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 77) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 105) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 103) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 102) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 100) {
#line 3084
          goto case_86;
        }
#line 3084
        if (c == 98) {
#line 3084
          goto case_86;
        }
#line 3093
        if (c == 128) {
#line 3093
          goto case_128;
        }
#line 3099
        if (c == 67) {
#line 3099
          goto case_67;
        }
#line 3099
        if (c == 99) {
#line 3099
          goto case_67;
        }
#line 3105
        if (c == 129) {
#line 3105
          goto case_129;
        }
#line 3111
        if (c == 130) {
#line 3111
          goto case_130;
        }
#line 3115
        if (c == 107) {
#line 3115
          goto case_107;
        }
#line 3169
        if (c == 109) {
#line 3169
          goto case_109;
        }
#line 3173
        if (c == 131) {
#line 3173
          goto case_131;
        }
#line 3177
        if (c == 111) {
#line 3177
          goto case_111;
        }
#line 3183
        if (c == 132) {
#line 3183
          goto case_132;
        }
#line 3189
        if (c == 115) {
#line 3189
          goto case_115;
        }
#line 3193
        if (c == 83) {
#line 3193
          goto case_83;
        }
#line 3197
        if (c == 116) {
#line 3197
          goto case_116;
        }
#line 3222
        if (c == 84) {
#line 3222
          goto case_84;
        }
#line 3226
        if (c == 117) {
#line 3226
          goto case_117;
        }
#line 3230
        if (c == 121) {
#line 3230
          goto case_121;
        }
#line 3250
        if (c == 122) {
#line 3250
          goto case_122;
        }
#line 3254
        if (c == -130) {
#line 3254
          goto case_neg_130;
        }
#line 3256
        if (c == -131) {
#line 3256
          goto case_neg_131;
        }
#line 3258
        goto switch_default;
        case_1: /* CIL Label */ 
#line 3032
        key = (struct keyfield *)((void *)0);
#line 3033
        if ((int )*(optarg + 0) == 43) {
#line 3035
          if (optind != argc) {
#line 3035
            if ((int )*(*(argv + optind) + 0) == 45) {
#line 3035
              if ((unsigned int )*(*(argv + optind) + 1) - 48U <= 9U) {
#line 3035
                tmp___8 = 1;
              } else {
#line 3035
                tmp___8 = 0;
              }
            } else {
#line 3035
              tmp___8 = 0;
            }
          } else {
#line 3035
            tmp___8 = 0;
          }
#line 3035
          minus_pos_usage = (_Bool )tmp___8;
#line 3037
          obsolete_usage = (_Bool )((int )obsolete_usage | ((int )minus_pos_usage & ~ ((int )posixly_correct)));
#line 3038
          if (obsolete_usage) {
            {
#line 3042
            key = key_init(& key_buf);
#line 3043
            s = parse_field_count((char const   *)(optarg + 1), & key->sword, (char const   *)((void *)0));
            }
#line 3044
            if (s) {
#line 3044
              if ((int const   )*s == 46) {
                {
#line 3045
                s = parse_field_count(s + 1, & key->schar, (char const   *)((void *)0));
                }
              }
            }
#line 3046
            if (! (key->sword | key->schar)) {
#line 3047
              key->sword = 0xffffffffffffffffUL;
            }
#line 3048
            if (! s) {
#line 3049
              key = (struct keyfield *)((void *)0);
            } else {
              {
#line 3048
              tmp___11 = set_ordering(s, key, (enum blanktype )0);
              }
#line 3048
              if (*tmp___11) {
#line 3049
                key = (struct keyfield *)((void *)0);
              } else {
#line 3052
                if (minus_pos_usage) {
                  {
#line 3054
                  tmp___9 = optind;
#line 3054
                  optind ++;
#line 3054
                  optarg1 = (char const   *)*(argv + tmp___9);
#line 3055
                  s = parse_field_count(optarg1 + 1, & key->eword, "invalid number after `-\'");
                  }
#line 3057
                  if ((int const   )*s == 46) {
                    {
#line 3058
                    s = parse_field_count(s + 1, & key->echar, "invalid number after `.\'");
                    }
                  }
                  {
#line 3060
                  tmp___10 = set_ordering(s, key, (enum blanktype )1);
                  }
#line 3060
                  if (*tmp___10) {
                    {
#line 3061
                    badfieldspec(optarg1, "stray character in field spec");
                    }
                  }
                }
                {
#line 3064
                insertkey(key);
                }
              }
            }
          }
        }
#line 3068
        if (! key) {
#line 3069
          tmp___12 = nfiles;
#line 3069
          nfiles ++;
#line 3069
          *(files + tmp___12) = optarg;
        }
#line 3070
        goto switch_break;
        case_133: /* CIL Label */ 
        {
#line 3073
        tmp___13 = __xargmatch_internal("--sort", (char const   *)optarg, sort_args,
                                        sort_types, sizeof(sort_types[0]), argmatch_die);
#line 3073
        c = (int )sort_types[tmp___13];
        }
        case_86: /* CIL Label */ 
        case_82: /* CIL Label */ 
        case_114: /* CIL Label */ 
        case_110: /* CIL Label */ 
        case_77: /* CIL Label */ 
        case_105: /* CIL Label */ 
        case_103: /* CIL Label */ 
        case_102: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_98: /* CIL Label */ 
        {
#line 3087
        str[0] = (char )c;
#line 3088
        str[1] = (char )'\000';
#line 3089
        set_ordering((char const   *)(str), & gkey, (enum blanktype )2);
        }
#line 3091
        goto switch_break;
        case_128: /* CIL Label */ 
#line 3094
        if (optarg) {
          {
#line 3094
          tmp___14 = __xargmatch_internal("--check", (char const   *)optarg, check_args,
                                          check_types, sizeof(check_types[0]), argmatch_die);
#line 3094
          c = (int )check_types[tmp___14];
          }
        } else {
#line 3094
          c = 'c';
        }
        case_67: /* CIL Label */ 
        case_99: /* CIL Label */ 
#line 3100
        if (checkonly) {
#line 3100
          if ((int )checkonly != c) {
            {
#line 3101
            incompatible_options("cC");
            }
          }
        }
#line 3102
        checkonly = (char )c;
#line 3103
        goto switch_break;
        case_129: /* CIL Label */ 
#line 3106
        if (compress_program) {
          {
#line 3106
          tmp___16 = strcmp(compress_program, (char const   *)optarg);
          }
#line 3106
          if (! (tmp___16 == 0)) {
            {
#line 3107
            tmp___15 = gettext("multiple compress programs specified");
#line 3107
            error(2, 0, (char const   *)tmp___15);
            }
          }
        }
#line 3108
        compress_program = (char const   *)optarg;
#line 3109
        goto switch_break;
        case_130: /* CIL Label */ 
#line 3112
        files_from = optarg;
#line 3113
        goto switch_break;
        case_107: /* CIL Label */ 
        {
#line 3116
        key = key_init(& key_buf);
#line 3119
        s = parse_field_count((char const   *)optarg, & key->sword, "invalid number at field start");
#line 3121
        tmp___17 = key->sword;
#line 3121
        (key->sword) --;
        }
#line 3121
        if (! tmp___17) {
          {
#line 3124
          badfieldspec((char const   *)optarg, "field number is zero");
          }
        }
#line 3126
        if ((int const   )*s == 46) {
          {
#line 3128
          s = parse_field_count(s + 1, & key->schar, "invalid number after `.\'");
#line 3130
          tmp___18 = key->schar;
#line 3130
          (key->schar) --;
          }
#line 3130
          if (! tmp___18) {
            {
#line 3133
            badfieldspec((char const   *)optarg, "character offset is zero");
            }
          }
        }
#line 3136
        if (! (key->sword | key->schar)) {
#line 3137
          key->sword = 0xffffffffffffffffUL;
        }
        {
#line 3138
        tmp___19 = set_ordering(s, key, (enum blanktype )0);
#line 3138
        s = (char const   *)tmp___19;
        }
#line 3139
        if ((int const   )*s != 44) {
#line 3141
          key->eword = 0xffffffffffffffffUL;
#line 3142
          key->echar = (size_t )0;
        } else {
          {
#line 3147
          s = parse_field_count(s + 1, & key->eword, "invalid number after `,\'");
#line 3149
          tmp___20 = key->eword;
#line 3149
          (key->eword) --;
          }
#line 3149
          if (! tmp___20) {
            {
#line 3152
            badfieldspec((char const   *)optarg, "field number is zero");
            }
          }
#line 3154
          if ((int const   )*s == 46) {
            {
#line 3155
            s = parse_field_count(s + 1, & key->echar, "invalid number after `.\'");
            }
          } else {
#line 3160
            (key->eword) ++;
          }
          {
#line 3162
          tmp___21 = set_ordering(s, key, (enum blanktype )1);
#line 3162
          s = (char const   *)tmp___21;
          }
        }
#line 3164
        if (*s) {
          {
#line 3165
          badfieldspec((char const   *)optarg, "stray character in field spec");
          }
        }
        {
#line 3166
        insertkey(key);
        }
#line 3167
        goto switch_break;
        case_109: /* CIL Label */ 
#line 3170
        mergeonly = (_Bool)1;
#line 3171
        goto switch_break;
        case_131: /* CIL Label */ 
        {
#line 3174
        specify_nmerge(oi, (char )c, (char const   *)optarg);
        }
#line 3175
        goto switch_break;
        case_111: /* CIL Label */ 
#line 3178
        if (outfile) {
          {
#line 3178
          tmp___23 = strcmp(outfile, (char const   *)optarg);
          }
#line 3178
          if (! (tmp___23 == 0)) {
            {
#line 3179
            tmp___22 = gettext("multiple output files specified");
#line 3179
            error(2, 0, (char const   *)tmp___22);
            }
          }
        }
#line 3180
        outfile = (char const   *)optarg;
#line 3181
        goto switch_break;
        case_132: /* CIL Label */ 
#line 3184
        if (random_source) {
          {
#line 3184
          tmp___25 = strcmp((char const   *)random_source, (char const   *)optarg);
          }
#line 3184
          if (! (tmp___25 == 0)) {
            {
#line 3185
            tmp___24 = gettext("multiple random sources specified");
#line 3185
            error(2, 0, (char const   *)tmp___24);
            }
          }
        }
#line 3186
        random_source = optarg;
#line 3187
        goto switch_break;
        case_115: /* CIL Label */ 
#line 3190
        stable = (_Bool)1;
#line 3191
        goto switch_break;
        case_83: /* CIL Label */ 
        {
#line 3194
        specify_sort_size(oi, (char )c, (char const   *)optarg);
        }
#line 3195
        goto switch_break;
        case_116: /* CIL Label */ 
#line 3199
        newtab = *(optarg + 0);
#line 3200
        if (! newtab) {
          {
#line 3201
          tmp___26 = gettext("empty tab");
#line 3201
          error(2, 0, (char const   *)tmp___26);
          }
        }
#line 3202
        if (*(optarg + 1)) {
          {
#line 3204
          tmp___29 = strcmp((char const   *)optarg, "\\0");
          }
#line 3204
          if (tmp___29 == 0) {
#line 3205
            newtab = (char )'\000';
          } else {
            {
#line 3212
            tmp___27 = quote((char const   *)optarg);
#line 3212
            tmp___28 = gettext("multi-character tab %s");
#line 3212
            error(2, 0, (char const   *)tmp___28, tmp___27);
            }
          }
        }
#line 3216
        if (tab != 128) {
#line 3216
          if (tab != (int )newtab) {
            {
#line 3217
            tmp___30 = gettext("incompatible tabs");
#line 3217
            error(2, 0, (char const   *)tmp___30);
            }
          }
        }
#line 3218
        tab = (int )newtab;
#line 3220
        goto switch_break;
        case_84: /* CIL Label */ 
        {
#line 3223
        add_temp_dir((char const   *)optarg);
        }
#line 3224
        goto switch_break;
        case_117: /* CIL Label */ 
#line 3227
        unique = (_Bool)1;
#line 3228
        goto switch_break;
        case_121: /* CIL Label */ 
#line 3241
        if ((unsigned long )optarg == (unsigned long )*(argv + (optind - 1))) {
#line 3244
          p = (char const   *)optarg;
          {
#line 3244
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3244
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 3244
              goto while_break___2;
            }
#line 3245
            goto __Cont;
            __Cont: /* CIL Label */ 
#line 3244
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 3246
          optind -= (int const   )*p != 0;
        }
#line 3248
        goto switch_break;
        case_122: /* CIL Label */ 
#line 3251
        eolchar = (char)0;
#line 3252
        goto switch_break;
        case_neg_130: /* CIL Label */ 
        {
#line 3254
        usage(0);
        }
#line 3254
        goto switch_break;
        case_neg_131: /* CIL Label */ 
        {
#line 3256
        version_etc(stdout, "sort", "GNU coreutils", Version, "Mike Haertel", "Paul Eggert",
                    (char *)((void *)0));
#line 3256
        exit(0);
        }
#line 3256
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 3259
        usage(2);
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3263
  if (files_from) {
#line 3269
    if (nfiles) {
      {
#line 3271
      tmp___31 = quote((char const   *)*(files + 0));
#line 3271
      tmp___32 = gettext("extra operand %s");
#line 3271
      error(0, 0, (char const   *)tmp___32, tmp___31);
#line 3272
      tmp___33 = gettext("file operands cannot be combined with --files0-from");
#line 3272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___33);
#line 3274
      usage(2);
      }
    }
    {
#line 3277
    tmp___37 = strcmp((char const   *)files_from, "-");
    }
#line 3277
    if (tmp___37 == 0) {
#line 3278
      stream = stdin;
    } else {
      {
#line 3281
      stream = fopen_safer((char const   *)files_from, "r");
      }
#line 3282
      if ((unsigned long )stream == (unsigned long )((void *)0)) {
        {
#line 3283
        tmp___34 = quote((char const   *)files_from);
#line 3283
        tmp___35 = gettext("cannot open %s for reading");
#line 3283
        tmp___36 = __errno_location();
#line 3283
        error(2, *tmp___36, (char const   *)tmp___35, tmp___34);
        }
      }
    }
    {
#line 3287
    readtokens0_init(& tok);
#line 3289
    tmp___40 = readtokens0(stream, & tok);
    }
#line 3289
    if (tmp___40) {
      {
#line 3289
      tmp___41 = fclose(stream);
      }
#line 3289
      if (tmp___41 != 0) {
        {
#line 3290
        tmp___38 = quote((char const   *)files_from);
#line 3290
        tmp___39 = gettext("cannot read file names from %s");
#line 3290
        error(2, 0, (char const   *)tmp___39, tmp___38);
        }
      }
    } else {
      {
#line 3290
      tmp___38 = quote((char const   *)files_from);
#line 3290
      tmp___39 = gettext("cannot read file names from %s");
#line 3290
      error(2, 0, (char const   *)tmp___39, tmp___38);
      }
    }
#line 3293
    if (tok.n_tok) {
      {
#line 3296
      free((void *)files);
#line 3297
      files = tok.tok;
#line 3298
      nfiles = tok.n_tok;
#line 3299
      i___0 = (size_t )0;
      }
      {
#line 3299
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3299
        if (! (i___0 < nfiles)) {
#line 3299
          goto while_break___3;
        }
        {
#line 3301
        tmp___46 = strcmp((char const   *)*(files + i___0), "-");
        }
#line 3301
        if (tmp___46 == 0) {
          {
#line 3302
          tmp___42 = quote((char const   *)*(files + i___0));
#line 3302
          tmp___43 = gettext("when reading file names from stdin, no file name of %s allowed");
#line 3302
          error(2, 0, (char const   *)tmp___43, tmp___42);
          }
        } else
#line 3305
        if ((int )*(*(files + i___0) + 0) == 0) {
          {
#line 3310
          file_number = i___0 + 1UL;
#line 3311
          tmp___44 = quotearg_colon((char const   *)files_from);
#line 3311
          tmp___45 = gettext("%s:%lu: invalid zero-length file name");
#line 3311
          error(2, 0, (char const   *)tmp___45, tmp___44, file_number);
          }
        }
#line 3299
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 3318
      tmp___47 = quote((char const   *)files_from);
#line 3318
      tmp___48 = gettext("no input from %s");
#line 3318
      error(2, 0, (char const   *)tmp___48, tmp___47);
      }
    }
  }
#line 3323
  key = keylist;
  {
#line 3323
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3323
    if (! key) {
#line 3323
      goto while_break___4;
    }
#line 3325
    if (! key->ignore) {
#line 3325
      if (! key->translate) {
#line 3325
        if (! ((((((((int )key->skipsblanks | (int )key->reverse) | (int )key->skipeblanks) | (int )key->month) | (int )key->numeric) | (int )key->version) | (int )key->general_numeric) | (int )key->random)) {
#line 3336
          key->ignore = gkey.ignore;
#line 3337
          key->translate = gkey.translate;
#line 3338
          key->skipsblanks = gkey.skipsblanks;
#line 3339
          key->skipeblanks = gkey.skipeblanks;
#line 3340
          key->month = gkey.month;
#line 3341
          key->numeric = gkey.numeric;
#line 3342
          key->general_numeric = gkey.general_numeric;
#line 3343
          key->random = gkey.random;
#line 3344
          key->reverse = gkey.reverse;
#line 3345
          key->version = gkey.version;
        }
      }
    }
#line 3348
    need_random = (_Bool )((int )need_random | (int )key->random);
#line 3323
    key = key->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3351
  if (! keylist) {
#line 3351
    if (gkey.ignore) {
      {
#line 3361
      insertkey(& gkey);
#line 3362
      need_random = (_Bool )((int )need_random | (int )gkey.random);
      }
    } else
#line 3351
    if (gkey.translate) {
      {
#line 3361
      insertkey(& gkey);
#line 3362
      need_random = (_Bool )((int )need_random | (int )gkey.random);
      }
    } else
#line 3351
    if (((((((int )gkey.skipsblanks | (int )gkey.skipeblanks) | (int )gkey.month) | (int )gkey.numeric) | (int )gkey.general_numeric) | (int )gkey.random) | (int )gkey.version) {
      {
#line 3361
      insertkey(& gkey);
#line 3362
      need_random = (_Bool )((int )need_random | (int )gkey.random);
      }
    }
  }
  {
#line 3365
  check_ordering_compatibility();
#line 3367
  reverse = gkey.reverse;
  }
#line 3369
  if (need_random) {
    {
#line 3371
    randread_source = randread_new((char const   *)random_source, (size_t )16);
    }
#line 3372
    if (! randread_source) {
      {
#line 3373
      tmp___49 = gettext("open failed");
#line 3373
      die((char const   *)tmp___49, (char const   *)random_source);
      }
    }
  }
#line 3376
  if (temp_dir_count == 0UL) {
    {
#line 3378
    tmp___50 = getenv("TMPDIR");
#line 3378
    tmp_dir = (char const   *)tmp___50;
    }
#line 3379
    if (tmp_dir) {
#line 3379
      tmp___51 = tmp_dir;
    } else {
#line 3379
      tmp___51 = "/tmp";
    }
    {
#line 3379
    add_temp_dir(tmp___51);
    }
  }
#line 3382
  if (nfiles == 0UL) {
    {
#line 3385
    nfiles = (size_t )1;
#line 3386
    free((void *)files);
#line 3387
    files = & minus;
    }
  }
#line 3392
  if (0UL < sort_size) {
#line 3393
    if (sort_size > (unsigned long )nmerge * (2UL + sizeof(struct line ))) {
#line 3393
      sort_size = sort_size;
    } else {
#line 3393
      sort_size = (unsigned long )nmerge * (2UL + sizeof(struct line ));
    }
  }
#line 3395
  if (checkonly) {
#line 3397
    if (nfiles > 1UL) {
      {
#line 3398
      tmp___52 = quote((char const   *)*(files + 1));
#line 3398
      tmp___53 = gettext("extra operand %s not allowed with -%c");
#line 3398
      error(2, 0, (char const   *)tmp___53, tmp___52, (int )checkonly);
      }
    }
#line 3401
    if (outfile) {
      {
#line 3404
      opts[0] = checkonly;
#line 3405
      incompatible_options((char const   *)(opts));
      }
    }
    {
#line 3410
    tmp___56 = check((char const   *)*(files + 0), checkonly);
    }
#line 3410
    if (tmp___56) {
#line 3410
      tmp___55 = 0;
    } else {
#line 3410
      tmp___55 = 1;
    }
    {
#line 3410
    exit(tmp___55);
    }
  }
#line 3413
  if (mergeonly) {
    {
#line 3415
    tmp___57 = xcalloc(nfiles, sizeof(*sortfiles));
#line 3415
    sortfiles = (struct sortfile *)tmp___57;
#line 3418
    i___1 = (size_t )0;
    }
    {
#line 3418
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3418
      if (! (i___1 < nfiles)) {
#line 3418
        goto while_break___5;
      }
#line 3419
      (sortfiles + i___1)->name = (char const   *)*(files + i___1);
#line 3418
      i___1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 3421
    merge(sortfiles, (size_t )0, nfiles, outfile);
    }
  } else {
    {
#line 3425
    sort((char * const  *)files, nfiles, outfile);
    }
  }
#line 3427
  if (have_read_stdin) {
    {
#line 3427
    tmp___59 = fclose(stdin);
    }
#line 3427
    if (tmp___59 == -1) {
      {
#line 3428
      tmp___58 = gettext("close failed");
#line 3428
      die((char const   *)tmp___58, "-");
      }
    }
  }
  {
#line 3430
  exit(0);
  }
}
}
